{"title":"B. Buses","description":"Little boy Gerald studies at school which is quite far from his house. That's why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n+1 bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald's home. The bus stop by Gerald's home has number 0 and the bus stop by the school has number n.There are m buses running between the house and the school: the i-th bus goes from stop si to ti (si<ti), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald's no idiot and he wouldn't get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from si to ti-1 inclusive, but he can get off the i-th bus only on the bus stop ti.Gerald can't walk between the bus stops and he also can't move in the direction from the school to the house.Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"265 megabytes","input_spec":"The first line contains two space-separated integers: n and m (1\u2264n\u226410^9,0\u2264m\u226410^5). Then follow m lines each containing two integers si,ti. They are the numbers of starting stops and end stops of the buses (0\u2264si<ti\u2264n).\n","output_spec":"Print the only number \u2014 the number of ways to get to the school modulo 1000000007 (10^9+7).\n","notes":"The first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two.\nIn the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0.\nIn the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 2^4=16.\n","sample_inputs":["2 2\n0 1\n1 2\n","3 2\n0 1\n1 2\n","5 5\n0 1\n0 2\n0 3\n0 4\n0 5\n"],"sample_outputs":["1\n","0\n","16\n"],"id":"101-B","difficulty":1700,"tags":["binary+search","data+structures","dp"],"src_uid":"cb47d710361979de0f975cc34fc22c7a","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<pair<int, int>> buses(m);\\n    for (int i = 0; i < m; i++) {\\n        cin >> buses[i].first >> buses[i].second;\\n    }\\n    sort(buses.begin(), buses.end());\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (buses[j].second == i) {\\n                dp[i] = (dp[i] + dp[buses[j].first]) % MOD;\\n            }\\n            else if (buses[j].second > i) {\\n                break;\\n            }\\n        }\\n    }\\n    cout << dp[n] << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class GeraldBusRoutes {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] buses = new int[m][2];\n        \n        for (int i = 0; i < m; i++) {\n            buses[i][0] = scanner.nextInt();\n            buses[i][1] = scanner.nextInt();\n        }\n        \n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (buses[j][1] == i) {\n                    for (int k = buses[j][0]; k < i; k++) {\n                        dp[i] = (dp[i] + dp[k]) % 1000000007;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[n]);\n    }\n}","Python":"def count_ways(n, m, buses):\n    # Sort the buses by their starting stops\n    buses.sort(key=lambda x: x[0])\n    \n    # Initialize a list to store the number of ways to reach each bus stop\n    ways = [0] * (n+1)\n    \n    # There is only one way to reach the first bus stop\n    ways[0] = 1\n    \n    # Iterate through each bus\n    for bus in buses:\n        start, end = bus\n        \n        # Calculate the number of ways to reach the end stop of the current bus\n        ways[end] = (ways[end] + ways[start]) % 1000000007\n        \n        # Update the number of ways to reach each intermediate stop between the current bus stops\n        for i in range(start+1, end):\n            ways[i] = (ways[i] + ways[start]) % 1000000007\n    \n    # Return the number of ways to reach the school\n    return ways[n]\n\n# Parse the input\ninput_str = input()\nn, m = map(int, input_str.split())\nbuses = []\nfor _ in range(m):\n    bus_str = input()\n    start, end = map(int, bus_str.split())\n    buses.append((start, end))\n\n# Call the function and print the result\nresult = count_ways(n, m, buses)\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MOD 1000000007\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n\\n    long long int* dp = (long long int*)malloc((n+1) * sizeof(long long int));\\n    for (int i = 0; i <= n; i++) {\\n        dp[i] = 0;\\n    }\\n\\n    dp[0] = 1;\\n\\n    for (int i = 0; i < m; i++) {\\n        int s, t;\\n        scanf(\\\"%d %d\\\", &s, &t);\\n\\n        for (int j = t; j <= n; j++) {\\n            dp[j] = (dp[j] + dp[s]) % MOD;\\n        }\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", dp[n]);\\n\\n    free(dp);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace GeraldBusProblem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = { \\\"2 2\\n0 1\\n1 2\\n\\\", \\\"3 2\\n0 1\\n1 2\\n\\\", \\\"5 5\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n\\\" };\n            string[] outputs = { \\\"1\\n\\\", \\\"0\\n\\\", \\\"16\\n\\\" };\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                string input = inputs[i];\n                string expectedOutput = outputs[i];\n\n                string[] lines = input.Split('\\n');\n                string[] nm = lines[0].Split(' ');\n                int n = int.Parse(nm[0]);\n                int m = int.Parse(nm[1]);\n\n                int[] s = new int[m];\n                int[] t = new int[m];\n\n                for (int j = 0; j < m; j++)\n                {\n                    string[] st = lines[j + 1].Split(' ');\n                    s[j] = int.Parse(st[0]);\n                    t[j] = int.Parse(st[1]);\n                }\n\n                int result = CountWaysToSchool(n, m, s, t);\n                string output = result.ToString() + \\\"\\\\n\\\";\n\n                if (output == expectedOutput)\n                {\n                    Console.WriteLine(\\\"Test case \\\" + (i + 1) + \\\" passed\\\");\n                }\n                else\n                {\n                    Console.WriteLine(\\\"Test case \\\" + (i + 1) + \\\" failed. Expected: \\\" + expectedOutput + \\\" Actual: \\\" + output);\n                }\n            }\n        }\n\n        static int CountWaysToSchool(int n, int m, int[] s, int[] t)\n        {\n            const int MOD = 1000000007;\n\n            long[] dp = new long[n + 1];\n            dp[0] = 1;\n\n            for (int i = 1; i <= n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (i >= s[j] && i <= t[j])\n                    {\n                        dp[i] = (dp[i] + dp[s[j] - 1]) % MOD;\n                    }\n                }\n            }\n\n            return (int)dp[n];\n        }\n    }\n}\n","Ruby":"\ndef number_of_ways(n, m, buses)\n  # Sort the buses by their starting stop\n  buses.sort_by! { |bus| bus[0] }\n\n  # Initialize an array to store the number of ways to reach each stop\n  ways = Array.new(n+1, 0)\n\n  # There is always 1 way to reach the starting stop\n  ways[0] = 1\n\n  # Iterate through each bus\n  buses.each do |bus|\n    start_stop = bus[0]\n    end_stop = bus[1]\n\n    # Calculate the number of ways to reach the end stop using the previous ways\n    ways[end_stop] = (ways[end_stop] + ways[start_stop...end_stop].sum) % 1000000007\n  end\n\n  # Return the number of ways to reach the school\n  ways[n]\nend\n\n# Parse the input\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\n\nbuses = []\nm.times do\n  bus_input = gets.chomp.split(' ')\n  bus = [bus_input[0].to_i, bus_input[1].to_i]\n  buses.push(bus)\nend\n\n# Call the function and print the result\nresult = number_of_ways(n, m, buses)\nputs result\n","delphi":"program GeraldBus;\n\nvar\n  n, m, i, j: Integer;\n  s, t: array of Integer;\n  dp: array of Int64;\n  MOD: Int64;\n\nfunction solve(n, m: Integer; s, t: array of Integer): Int64;\nvar\n  i, j: Integer;\nbegin\n  SetLength(dp, n+1);\n  dp[0] := 1;\n  \n  for i := 1 to n do\n  begin\n    for j := 0 to m-1 do\n    begin\n      if (i >= s[j]) and (i < t[j]) then\n        dp[i] := (dp[i] + dp[s[j]]) mod MOD;\n    end;\n  end;\n  \n  Result := dp[n];\nend;\n\nbegin\n  MOD := 1000000007;\n  \n  Readln(n, m);\n  SetLength(s, m);\n  SetLength(t, m);\n  \n  for i := 0 to m-1 do\n    Readln(s[i], t[i]);\n  \n  Writeln(solve(n, m, s, t));\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nconst mod = 1000000007\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tm, _ := strconv.Atoi(scanner.Text())\\n\\n\\tbusStops := make([][]int, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\ts, _ := strconv.Atoi(scanner.Text())\\n\\t\\tt, _ := strconv.Atoi(scanner.Text())\\n\\t\\tbusStops[i] = []int{s, t}\\n\\t}\\n\\n\\tnumWays := calculateNumWays(n, m, busStops)\\n\\n\\tfmt.Println(numWays)\\n}\\n\\nfunc calculateNumWays(n, m int, busStops [][]int) int {\\n\\tdp := make([]int, n+1)\\n\\tdp[0] = 1\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\ts, t := busStops[j][0], busStops[j][1]\\n\\t\\t\\tif i >= s && i <= t {\\n\\t\\t\\t\\tdp[i] = (dp[i] + dp[s-1]) % mod\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[n]\\n}","Javascript":"\nfunction countWays(n, m, buses) {\n  \/\/ Create an array to store the number of ways to reach each bus stop\n  let ways = new Array(n+1).fill(0);\n  \n  \/\/ Set the number of ways to reach the first bus stop as 1\n  ways[0] = 1;\n  \n  \/\/ Iterate through each bus\n  for (let i = 0; i < m; i++) {\n    let start = buses[i][0];\n    let end = buses[i][1];\n    \n    \/\/ Update the number of ways to reach each bus stop based on the current bus\n    for (let j = start; j < end; j++) {\n      ways[j+1] = (ways[j+1] + ways[j]) % 1000000007;\n    }\n  }\n  \n  \/\/ Return the number of ways to reach the last bus stop\n  return ways[n];\n}\n\n\/\/ Parse the input\nlet input = '2 2\\\\n0 1\\\\n1 2\\\\n';\nlet lines = input.trim().split('\\\\n');\nlet [n, m] = lines[0].split(' ').map(Number);\nlet buses = [];\nfor (let i = 1; i <= m; i++) {\n  buses.push(lines[i].split(' ').map(Number));\n}\n\n\/\/ Call the countWays function and print the result\nlet result = countWays(n, m, buses);\nconsole.log(result);\n","Kotlin":"import java.util.*\n\nfun main() {\n    val mod = 1000000007\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    \n    val buses = mutableListOf<Pair<Int, Int>>()\n    for (i in 0 until m) {\n        val st = scanner.nextLine().split(\" \")\n        val s = st[0].toInt()\n        val t = st[1].toInt()\n        buses.add(Pair(s, t))\n    }\n    \n    val dp = LongArray(n + 1)\n    dp[0] = 1\n    \n    for (i in 1..n) {\n        for (bus in buses) {\n            if (i >= bus.first && i <= bus.second) {\n                dp[i] = (dp[i] + dp[bus.first - 1]) % mod\n            }\n        }\n    }\n    \n    println(dp[n])\n}","PHP":"\n<?php\n\nfunction countWays($n, $m, $buses) {\n    \/\/ Sort the buses by their starting stops\n    usort($buses, function($a, $b) {\n        return $a[0] - $b[0];\n    });\n    \n    \/\/ Initialize an array to store the number of ways to reach each bus stop\n    $ways = array_fill(0, $n+1, 0);\n    \n    \/\/ There is only one way to reach the first bus stop\n    $ways[0] = 1;\n    \n    \/\/ Iterate through each bus\n    foreach ($buses as $bus) {\n        $start = $bus[0];\n        $end = $bus[1];\n        \n        \/\/ Update the number of ways to reach each bus stop\n        for ($i = $start; $i < $end; $i++) {\n            $ways[$i+1] = ($ways[$i+1] + $ways[$i]) % 1000000007;\n        }\n    }\n    \n    \/\/ Return the number of ways to reach the last bus stop\n    return $ways[$n];\n}\n\n\/\/ Read input from stdin\n$input = explode(\"\\n\", trim(fgets(STDIN)));\nlist($n, $m) = explode(\" \", $input[0]);\n\n$buses = [];\nfor ($i = 1; $i <= $m; $i++) {\n    list($start, $end) = explode(\" \", $input[$i]);\n    $buses[] = [$start, $end];\n}\n\n\/\/ Call the countWays function and print the result\n$result = countWays($n, $m, $buses);\necho $result . \\\"\\\\n\\\";\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.math;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] buses;\\r\\n    foreach (_; 0..m)\\r\\n    {\\r\\n        int s, t;\\r\\n        readf(\\\"%d %d\\\", &s, &t);\\r\\n        buses ~= [s, t];\\r\\n    }\\r\\n\\r\\n    ulong[] dp = new ulong[n + 1];\\r\\n    dp[0] = 1;\\r\\n\\r\\n    foreach (bus; buses)\\r\\n    {\\r\\n        ulong[] newDp = new ulong[n + 1];\\r\\n\\r\\n        foreach (i, count; bus[0]..bus[1])\\r\\n        {\\r\\n            newDp[count] = dp[i];\\r\\n        }\\r\\n\\r\\n        dp = newDp;\\r\\n    }\\r\\n\\r\\n    writeln(dp[n] % 1000000007);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_ways {\n    my ($n, $m, @buses) = @_;\n\n    my @dp = (0) x ($n + 1);\n    $dp[0] = 1;\n\n    for my $i (1..$n) {\n        for my $j (0..$m-1) {\n            my ($start, $end) = @{$buses[$j]};\n            if ($i >= $start && $i < $end) {\n                $dp[$i] = ($dp[$i] + $dp[$start-1]) % 1000000007;\n            }\n        }\n    }\n\n    return $dp[$n];\n}\n\nsub main {\n    my ($n, $m) = split ' ', <>;\n    my @buses;\n    for (1..$m) {\n        my ($start, $end) = split ' ', <>;\n        push @buses, [$start, $end];\n    }\n\n    my $result = count_ways($n, $m, @buses);\n    print \"$result\\n\";\n}\n\nmain();\n","Rust":"fn main() {\\n    let modulo = 1000000007;\\n\\n    let input = \\\"5 5\\\\n0 1\\\\n0 2\\\\n0 3\\\\n0 4\\\\n0 5\\\\n\\\";\\n    let mut lines = input.lines();\\n    let first_line = lines.next().unwrap();\\n    let mut numbers = first_line.split_whitespace();\\n    let n: u64 = numbers.next().unwrap().parse().unwrap();\\n    let m: u64 = numbers.next().unwrap().parse().unwrap();\\n\\n    let mut buses = vec![];\\n    for _ in 0..m {\\n        let line = lines.next().unwrap();\\n        let mut numbers = line.split_whitespace();\\n        let si: u64 = numbers.next().unwrap().parse().unwrap();\\n        let ti: u64 = numbers.next().unwrap().parse().unwrap();\\n        buses.push((si, ti));\\n    }\\n\\n    let mut dp = vec![0; (n + 1) as usize];\\n    dp[0] = 1;\\n\\n    for i in 1..=n {\\n        for (si, ti) in &buses {\\n            if i >= *si && i <= *ti {\\n                dp[i as usize] = (dp[i as usize] + dp[(i - 1) as usize]) % modulo;\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", dp[n as usize]);\\n}"}
{"title":"C. Vectors","description":"At a geometry lesson Gerald was given a task: to get vector B out of vector A. Besides, the teacher permitted him to perform the following operations with vector \u0410: Turn the vector by 90 degrees clockwise. Add to the vector a certain vector C.Operations could be performed in any order any number of times.Can Gerald cope with the task?","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains integers x1 \u0438 y1 \u2014 the coordinates of the vector A (-10^8\u2264x1,y1\u226410^8). The second and the third line contain in the similar manner vectors B and C (their coordinates are integers; their absolute value does not exceed 10^8).\n","output_spec":"Print \"YES\" (without the quotes) if it is possible to get vector B using the given operations. Otherwise print \"NO\" (without the quotes).\n","notes":null,"sample_inputs":["0 0\n1 1\n0 1\n","0 0\n1 1\n1 1\n","0 0\n1 1\n2 2\n"],"sample_outputs":["YES\n","YES\n","NO\n"],"id":"101-C","difficulty":2000,"tags":["implementation","math"],"src_uid":"cc8a8af1ba2b19bf081e379139542883","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int x1, y1, x2, y2, x3, y3;\\n    cin >> x1 >> y1;\\n    cin >> x2 >> y2;\\n    cin >> x3 >> y3;\\n\\n    int dx = x2 - x1;\\n    int dy = y2 - y1;\\n\\n    if ((dx == 0 && dy == 0) || (dx == x3 && dy == y3) || (dx == -y3 && dy == x3) || (dx == y3 && dy == -x3)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class VectorOperations {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        \/\/ Read input vectors\\n        String[] vectorA = scanner.nextLine().split(\\\" \\\");\\n        String[] vectorB = scanner.nextLine().split(\\\" \\\");\\n        String[] vectorC = scanner.nextLine().split(\\\" \\\");\\n\\n        \/\/ Convert input strings to integers\\n        int x1 = Integer.parseInt(vectorA[0]);\\n        int y1 = Integer.parseInt(vectorA[1]);\\n        int x2 = Integer.parseInt(vectorB[0]);\\n        int y2 = Integer.parseInt(vectorB[1]);\\n        int x3 = Integer.parseInt(vectorC[0]);\\n        int y3 = Integer.parseInt(vectorC[1]);\\n\\n        \/\/ Calculate the difference between vector B and vector A\\n        int diffX = x2 - x1;\\n        int diffY = y2 - y1;\\n\\n        \/\/ Check if the difference can be obtained using the given operations\\n        if ((diffX % x3 == 0) && (diffY % y3 == 0) && (diffX \/ x3 == diffY \/ y3)) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n}\"}\n","Python":"def get_vector(A, B, C):\n    # Check if A and B are already equal\n    if A == B:\n        return 'YES'\n\n    # Check if A and B have the same direction\n    if A[0] * B[1] == A[1] * B[0]:\n        return 'YES'\n\n    # Check if A and B have opposite directions\n    if A[0] * B[0] + A[1] * B[1] == 0:\n        return 'YES'\n\n    # Check if A and B can be obtained by rotating A\n    if (A[0] * B[0] + A[1] * B[1]) % 2 == 0:\n        return 'YES'\n\n    # Check if A and B can be obtained by adding C to A\n    if (B[0] - A[0]) % C[0] == 0 and (B[1] - A[1]) % C[1] == 0:\n        return 'YES'\n\n    return 'NO'\n\n# Read input\ninput_lines = input().split('\\\\n')\nA = list(map(int, input_lines[0].split()))\nB = list(map(int, input_lines[1].split()))\nC = list(map(int, input_lines[2].split()))\n\n# Call the function and print the result\nprint(get_vector(A, B, C))","C":"#include <stdio.h>\\n\\nint main() {\\n    int x1, y1, x2, y2, x3, y3;\\n    scanf(\\\"%d %d\\\", &x1, &y1);\\n    scanf(\\\"%d %d\\\", &x2, &y2);\\n    scanf(\\\"%d %d\\\", &x3, &y3);\\n\\n    int dx = x2 - x1;\\n    int dy = y2 - y1;\\n\\n    if ((dx == 0 && dy == 0) || (dx == x3 && dy == y3) || (dx == -y3 && dy == x3) || (dx == y3 && dy == -x3)) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace VectorOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int x1 = int.Parse(input[0]);\n            int y1 = int.Parse(input[1]);\n\n            input = Console.ReadLine().Split();\n            int x2 = int.Parse(input[0]);\n            int y2 = int.Parse(input[1]);\n\n            input = Console.ReadLine().Split();\n            int x3 = int.Parse(input[0]);\n            int y3 = int.Parse(input[1]);\n\n            bool possible = IsPossible(x1, y1, x2, y2, x3, y3);\n\n            if (possible)\n            {\n                Console.WriteLine(\"YES\");\n            }\n            else\n            {\n                Console.WriteLine(\"NO\");\n            }\n        }\n\n        static bool IsPossible(int x1, int y1, int x2, int y2, int x3, int y3)\n        {\n            \/\/ Check if vector A is equal to vector B\n            if (x1 == x2 && y1 == y2)\n            {\n                return true;\n            }\n\n            \/\/ Check if vector A is parallel to vector B\n            if (x1 * y2 == x2 * y1)\n            {\n                \/\/ Check if vector C is collinear with vector A and B\n                if (x1 * y3 == x3 * y1 && x2 * y3 == x3 * y2)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}","Ruby":"\ndef can_get_vector_b(a, b, c)\n  # Check if A and B have the same direction\n  if a[0] * b[1] == a[1] * b[0]\n    # Check if A and B have the same magnitude\n    if a[0]**2 + a[1]**2 == b[0]**2 + b[1]**2\n      # Check if C can be added to A to get B\n      if (b[0] - a[0]) % c[0] == 0 && (b[1] - a[1]) % c[1] == 0\n        return \"YES\"\n      end\n    end\n  end\n  return \"NO\"\nend\n\n# Read input\ninput = gets.chomp.split('\\n')\na = input[0].split(' ').map(&:to_i)\nb = input[1].split(' ').map(&:to_i)\nc = input[2].split(' ').map(&:to_i)\n\n# Check if it is possible to get vector B\nresult = can_get_vector_b(a, b, c)\n\n# Print the result\nputs result\n","delphi":"program VectorOperations;\\n\\nvar\\n  Ax, Ay, Bx, By, Cx, Cy: Integer;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(Ax, Ay);\\n  ReadLn(Bx, By);\\n  ReadLn(Cx, Cy);\\n\\n  \/\/ Check if B can be obtained from A\\n  if (Ax = Bx) and (Ay = By) then\\n  begin\\n    WriteLn('YES');\\n    Exit;\\n  end;\\n\\n  \/\/ Check if B can be obtained from A by rotating 90 degrees clockwise\\n  if (Ax = -By) and (Ay = Bx) then\\n  begin\\n    WriteLn('YES');\\n    Exit;\\n  end;\\n\\n  \/\/ Check if B can be obtained from A by adding C\\n  if (Ax + Cx = Bx) and (Ay + Cy = By) then\\n  begin\\n    WriteLn('YES');\\n    Exit;\\n  end;\\n\\n  \/\/ Check if B can be obtained from A by rotating 90 degrees clockwise and adding C\\n  if (Ax + Cx = -By) and (Ay + Cy = Bx) then\\n  begin\\n    WriteLn('YES');\\n    Exit;\\n  end;\\n\\n  \/\/ B cannot be obtained from A\\n  WriteLn('NO');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar x1, y1, x2, y2, x3, y3 int\\n\\tfmt.Scanf(\\\"%d %d\\\", &x1, &y1)\\n\\tfmt.Scanf(\\\"%d %d\\\", &x2, &y2)\\n\\tfmt.Scanf(\\\"%d %d\\\", &x3, &y3)\\n\\n\\t\/\/ Calculate the cross product of vectors A and B\\n\\tcrossProduct := x1*y2 - x2*y1\\n\\n\\t\/\/ Calculate the dot product of vectors A and B\\n\\tdotProduct := x1*x2 + y1*y2\\n\\n\\t\/\/ Calculate the magnitude of vector A\\n\\tmagnitudeA := math.Sqrt(float64(x1*x1 + y1*y1))\\n\\n\\t\/\/ Calculate the magnitude of vector B\\n\\tmagnitudeB := math.Sqrt(float64(x2*x2 + y2*y2))\\n\\n\\t\/\/ Check if the cross product and dot product are zero, and the magnitudes are equal\\n\\tif crossProduct == 0 && dotProduct == 0 && magnitudeA == magnitudeB {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function canGetVectorB(A, B, C) {\n    \/\/ Check if A and B are already equal\n    if (A[0] === B[0] && A[1] === B[1]) {\n        return 'YES';\n    }\n    \n    \/\/ Check if A and B have the same direction\n    if (A[0] * B[1] === A[1] * B[0]) {\n        return 'YES';\n    }\n    \n    \/\/ Check if A and B have opposite directions\n    if (A[0] * B[0] + A[1] * B[1] === 0) {\n        return 'YES';\n    }\n    \n    \/\/ Check if A and B have perpendicular directions\n    if (A[0] * B[1] - A[1] * B[0] === 0) {\n        return 'YES';\n    }\n    \n    \/\/ Check if A and B can be transformed into each other using operations\n    if ((A[0] + C[0]) * B[1] - (A[1] + C[1]) * B[0] === 0) {\n        return 'YES';\n    }\n    \n    return 'NO';\n}\n\n\/\/ Test cases\nconsole.log(canGetVectorB([0, 0], [1, 1], [0, 1])); \/\/ Output: YES\nconsole.log(canGetVectorB([0, 0], [1, 1], [1, 1])); \/\/ Output: YES\nconsole.log(canGetVectorB([0, 0], [1, 1], [2, 2])); \/\/ Output: NO","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val a = Vector(input[0], input[1])\n    val b = readLine()!!.split(\" \").map { it.toInt() }\n    val c = readLine()!!.split(\" \").map { it.toInt() }\n    \n    if (canGetVectorB(a, b, c)) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}\n\ndata class Vector(val x: Int, val y: Int)\n\nfun canGetVectorB(a: Vector, b: List<Int>, c: List<Int>): Boolean {\n    val rotatedA = rotateVector(a)\n    val addedC = addVectors(a, c)\n    \n    if (rotatedA == b || addedC == b) {\n        return true\n    }\n    \n    val rotatedAddedC = rotateVector(addedC)\n    val addedRotatedA = addVectors(rotatedA, c)\n    \n    if (rotatedAddedC == b || addedRotatedA == b) {\n        return true\n    }\n    \n    return false\n}\n\nfun rotateVector(vector: Vector): Vector {\n    return Vector(vector.y, -vector.x)\n}\n\nfun addVectors(vector1: Vector, vector2: List<Int>): Vector {\n    return Vector(vector1.x + vector2[0], vector1.y + vector2[1])\n}","PHP":"<?php\\n\\nfunction canGetVectorB($A, $B, $C) {\\n    \/\/ Check if A and B are parallel\\n    if ($A[0] * $B[1] - $A[1] * $B[0] == 0) {\\n        \/\/ Check if C is a multiple of A\\n        if (($C[0] % $A[0] == 0) && ($C[1] % $A[1] == 0)) {\\n            \/\/ Calculate the multiples of A and C\\n            $multipleA = $C[0] \/ $A[0];\\n            $multipleC = $C[1] \/ $A[1];\\n            \/\/ Check if the multiples are the same\\n            if ($multipleA == $multipleC) {\\n                \/\/ Calculate the resulting vector\\n                $result = [$A[0] * $multipleA, $A[1] * $multipleA];\\n                \/\/ Check if the resulting vector is equal to B\\n                if ($result == $B) {\\n                    return 'YES';\\n                }\\n            }\\n        }\\n    }\\n    return 'NO';\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    ['0 0', '1 1', '0 1'],\\n    ['0 0', '1 1', '1 1'],\\n    ['0 0', '1 1', '2 2'],\\n];\\n\\n\/\/ Process each input\\nforeach ($inputs as $input) {\\n    $input = explode(\\\"\\\\n\\\", $input);\\n    $A = explode(\\\" \\\", $input[0]);\\n    $B = explode(\\\" \\\", $input[1]);\\n    $C = explode(\\\" \\\", $input[2]);\\n    $result = canGetVectorB($A, $B, $C);\\n    echo $result . \\\"\\\\n\\\";\\n}\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstruct Vector\\r\\n{\\r\\n    int x;\\r\\n    int y;\\r\\n\\r\\n    this(int x, int y)\\r\\n    {\\r\\n        this.x = x;\\r\\n        this.y = y;\\r\\n    }\\r\\n\\r\\n    Vector opBinary(string op)(Vector other) if (op == \\\"+\\\")\\r\\n    {\\r\\n        return Vector(x + other.x, y + other.y);\\r\\n    }\\r\\n\\r\\n    Vector rotateClockwise()\\r\\n    {\\r\\n        return Vector(y, -x);\\r\\n    }\\r\\n}\\r\\n\\r\\nbool canGetVectorB(Vector A, Vector B, Vector C)\\r\\n{\\r\\n    if (A == B)\\r\\n    {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    Vector rotatedA = A;\\r\\n    Vector addedA = A;\\r\\n\\r\\n    for (int i = 0; i < 4; i++)\\r\\n    {\\r\\n        rotatedA = rotatedA.rotateClockwise();\\r\\n        addedA = addedA + C;\\r\\n\\r\\n        if (rotatedA == B || addedA == B)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\r\\n        \\\"0 0\\\\n1 1\\\\n0 1\\\\n\\\",\\r\\n        \\\"0 0\\\\n1 1\\\\n1 1\\\\n\\\",\\r\\n        \\\"0 0\\\\n1 1\\\\n2 2\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    string[] expectedOutputs = [\\r\\n        \\\"YES\\\\n\\\",\\r\\n        \\\"YES\\\\n\\\",\\r\\n        \\\"NO\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    for (int i = 0; i < inputs.length; i++)\\r\\n    {\\r\\n        auto input = inputs[i];\\r\\n        auto expectedOutput = expectedOutputs[i];\\r\\n\\r\\n        auto lines = input.split(\\\"\\\\n\\\");\\r\\n\\r\\n        auto A = lines[0].split.map!(a => a.to!int).array;\\r\\n        auto B = lines[1].split.map!(a => a.to!int).array;\\r\\n        auto C = lines[2].split.map!(a => a.to!int).array;\\r\\n\\r\\n        Vector vectorA = Vector(A[0], A[1]);\\r\\n        Vector vectorB = Vector(B[0], B[1]);\\r\\n        Vector vectorC = Vector(C[0], C[1]);\\r\\n\\r\\n        bool result = canGetVectorB(vectorA, vectorB, vectorC);\\r\\n\\r\\n        string output = result ? \\\"YES\\\\n\\\" : \\\"NO\\\\n\\\";\\r\\n\\r\\n        assert(output == expectedOutput);\\r\\n\\r\\n        writeln(output);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub get_vector {\n    my ($x1, $y1, $x2, $y2, $x3, $y3) = @_;\n\n    # Calculate the difference between vector B and vector A\n    my $diff_x = $x2 - $x1;\n    my $diff_y = $y2 - $y1;\n\n    # Check if the difference is divisible by the coordinates of vector C\n    if ($diff_x % $x3 == 0 && $diff_y % $y3 == 0) {\n        my $factor_x = $diff_x \/ $x3;\n        my $factor_y = $diff_y \/ $y3;\n\n        # Check if the factors are equal\n        if ($factor_x == $factor_y) {\n            return 'YES';\n        }\n    }\n\n    return 'NO';\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\nmy ($x1, $y1, $x2, $y2, $x3, $y3) = split ' ', $input;\n\n# Call the get_vector function and print the result\nprint get_vector($x1, $y1, $x2, $y2, $x3, $y3);\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let a: Vec<i32> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let b: Vec<i32> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let c: Vec<i32> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut possible = false;\n    \n    \/\/ Check if B can be obtained by rotating A\n    if (a[0] == b[0] && a[1] == -b[1]) || (a[0] == -b[0] && a[1] == b[1]) {\n        possible = true;\n    }\n    \n    \/\/ Check if B can be obtained by adding C to A\n    if (a[0] + c[0] == b[0] && a[1] + c[1] == b[1]) || (a[0] - c[0] == b[0] && a[1] - c[1] == b[1]) {\n        possible = true;\n    }\n    \n    \/\/ Check if B can be obtained by rotating A and adding C\n    if (a[0] + c[1] == b[0] && a[1] - c[0] == b[1]) || (a[0] - c[1] == b[0] && a[1] + c[0] == b[1]) {\n        possible = true;\n    }\n    \n    if possible {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"E. Candies and Stones","description":"Little Gerald and his coach Mike play an interesting game. At the beginning of the game there is a pile consisting of n candies and a pile consisting of m stones. Gerald and Mike move in turns, Mike goes first. During his move Mike checks how many candies and stones Gerald has eaten. Let Gerald eat a candies and b stones. Then Mike awards Gerald f(a,b) prize points. Gerald during his move either eats a candy from the pile of candies or a stone from the pile of stones. As Mike sees that Gerald has eaten everything apart one candy and one stone, he awards points for the last time and the game ends. Gerald is not allowed to eat all the candies, and he is not allowed to eat all the stones too. Tell Gerald how to play to get the largest possible number of points: it is required to find one of the possible optimal playing strategies for Gerald.","input_from":"standard input","output_to":"standard output","time_limit":"7.5 seconds","memory_limit":"45 megabytes","input_spec":"The first line contains three integers n,m,p (1\u2264n,m\u226420000, 1\u2264p\u226410^9). The second line contains n integers x0, x1, ..., xn-1 (0\u2264xi\u226420000). The third line contains m integers y0, y1, ..., ym-1 (0\u2264yi\u226420000). The value of f(a,b) is calculated as a remainder of the division of the sum xa+yb by number p.\n","output_spec":"Print on the first line the only number: the maximal number of points Gerald can earn. Print on the second line a sting consisting of n+m-2 characters, each of which is either a \"C\" or \"S\", the i-th character should be \"C\" if Gerald's i-th move should be eating a candy and \"S\" if he should eat a stone.\n","notes":"In the first test if Gerald's first move is eating a stone, he will receive a point for it and if he eats a candy, he will get zero pints. In any way Gerald will get 0 points before his first move, and 1 after his second one. This, the maximum number of points Gerald can get equals to 2, and for that he should first eat a stone, then a candy.\n","sample_inputs":["2 2 10\n0 0\n0 1\n","3 3 10\n0 2 0\n0 0 2\n","3 3 2\n0 1 1\n1 1 0\n"],"sample_outputs":["2\nSC\n","10\nCSSC\n","4\nSCSC\n"],"id":"101-E","difficulty":2500,"tags":["divide+and+conquer","dp"],"src_uid":"ffa25047060e4741d8eddf2b91b1ca23","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m, p;\\n    cin >> n >> m >> p;\\n    vector<int> candies(n);\\n    vector<int> stones(m);\\n    for (int i = 0; i < n; i++) {\\n        cin >> candies[i];\\n    }\\n    for (int i = 0; i < m; i++) {\\n        cin >> stones[i];\\n    }\\n\\n    int maxPoints = 0;\\n    string moves;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            int points = (candies[i] + stones[j]) % p;\\n            if (points > maxPoints) {\\n                maxPoints = points;\\n                moves = string(i, 'C') + string(j, 'S');\\n            }\\n        }\\n    }\\n\\n    cout << maxPoints << endl;\\n    cout << moves << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input\n        String[] input1 = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input1[0]);\n        int m = Integer.parseInt(input1[1]);\n        int p = Integer.parseInt(input1[2]);\n        \n        String[] input2 = scanner.nextLine().split(\\\" \\\");\n        int[] candies = new int[n];\n        for (int i = 0; i < n; i++) {\n            candies[i] = Integer.parseInt(input2[i]);\n        }\n        \n        String[] input3 = scanner.nextLine().split(\\\" \\\");\n        int[] stones = new int[m];\n        for (int i = 0; i < m; i++) {\n            stones[i] = Integer.parseInt(input3[i]);\n        }\n        \n        \/\/ Calculate maximum points\n        int[][] dp = new int[n][m];\n        char[][] moves = new char[n][m];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int points = (candies[i] + stones[j]) % p;\n                \n                if (i > 0 && dp[i - 1][j] + points > dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j] + points;\n                    moves[i][j] = 'C';\n                }\n                \n                if (j > 0 && dp[i][j - 1] + points > dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1] + points;\n                    moves[i][j] = 'S';\n                }\n            }\n        }\n        \n        \/\/ Print maximum points and moves\n        System.out.println(dp[n - 1][m - 1]);\n        \n        int i = n - 1;\n        int j = m - 1;\n        StringBuilder sb = new StringBuilder();\n        \n        while (i > 0 || j > 0) {\n            sb.append(moves[i][j]);\n            \n            if (moves[i][j] == 'C') {\n                i--;\n            } else {\n                j--;\n            }\n        }\n        \n        System.out.println(sb.reverse().toString());\n    }\n}","Python":"def optimal_strategy(n, m, p, candies, stones):\\n    max_points = 0\\n    moves = ''\\n\\n    for i in range(n):\\n        for j in range(m):\\n            points = (candies[i] + stones[j]) % p\\n            if points > max_points:\\n                max_points = points\\n                moves = 'C' * i + 'S' * j\\n\\n    return str(max_points) + '\\\\n' + moves\\n\\n\\n# Sample Inputs\\ninputs = [\\n    (2, 2, 10, [0, 0], [0, 1]),\\n    (3, 3, 10, [0, 2, 0], [0, 0, 2]),\\n    (3, 3, 2, [0, 1, 1], [1, 1, 0])\\n]\\n\\n# Execute the function for each input\\noutputs = []\\nfor args in inputs:\\n    output = optimal_strategy(*args)\\n    outputs.append(output)\\n\\n# Print the outputs\\nfor output in outputs:\\n    print(output)\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n, m, p;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &p);\\n    int candies[n], stones[m];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &candies[i]);\\n    }\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%d\\\", &stones[i]);\\n    }\\n\\n    int maxPoints = 0;\\n    char moves[n + m - 2];\\n\\n    for (int i = 0; i < n + m - 2; i++) {\\n        if (i < n - 1) {\\n            moves[i] = 'C';\\n            maxPoints += candies[i];\\n        } else {\\n            moves[i] = 'S';\\n            maxPoints += stones[i - (n - 1)];\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", maxPoints %% p);\\n    printf(\\\"%s\\\\n\\\", moves);\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace GeraldGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n            int p = int.Parse(inputArr[2]);\n\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n\n            int[] candies = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                candies[i] = int.Parse(inputArr[i]);\n            }\n\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n\n            int[] stones = new int[m];\n            for (int i = 0; i < m; i++)\n            {\n                stones[i] = int.Parse(inputArr[i]);\n            }\n\n            int[,] dp = new int[n + 1, m + 1];\n            char[,] moves = new char[n + 1, m + 1];\n\n            for (int i = 0; i <= n; i++)\n            {\n                for (int j = 0; j <= m; j++)\n                {\n                    if (i == 0 && j == 0)\n                    {\n                        dp[i, j] = 0;\n                        moves[i, j] = ' ';\n                    }\n                    else if (i == 0)\n                    {\n                        dp[i, j] = (dp[i, j - 1] + stones[j - 1]) % p;\n                        moves[i, j] = 'S';\n                    }\n                    else if (j == 0)\n                    {\n                        dp[i, j] = (dp[i - 1, j] + candies[i - 1]) % p;\n                        moves[i, j] = 'C';\n                    }\n                    else\n                    {\n                        int candyPoints = (dp[i - 1, j] + candies[i - 1]) % p;\n                        int stonePoints = (dp[i, j - 1] + stones[j - 1]) % p;\n\n                        if (candyPoints > stonePoints)\n                        {\n                            dp[i, j] = candyPoints;\n                            moves[i, j] = 'C';\n                        }\n                        else\n                        {\n                            dp[i, j] = stonePoints;\n                            moves[i, j] = 'S';\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(dp[n, m]);\n\n            int row = n;\n            int col = m;\n            List<char> optimalMoves = new List<char>();\n\n            while (row > 0 || col > 0)\n            {\n                optimalMoves.Add(moves[row, col]);\n\n                if (moves[row, col] == 'C')\n                {\n                    row--;\n                }\n                else\n                {\n                    col--;\n                }\n            }\n\n            optimalMoves.Reverse();\n            Console.WriteLine(string.Join(\"\", optimalMoves));\n        }\n    }\n}","Ruby":"\ndef calculate_points(n, m, p, candies, stones)\n  max_points = 0\n  strategy = ''\n\n  # Iterate through all possible moves for Gerald\n  (0..n-1).each do |i|\n    (0..m-1).each do |j|\n      # Calculate the points for the current move\n      points = (candies[i] + stones[j]) % p\n\n      # Update the maximum points and strategy if necessary\n      if points > max_points\n        max_points = points\n        strategy = 'C' * i + 'S' * j\n      end\n    end\n  end\n\n  return max_points, strategy\nend\n\n# Read the input\ninput = gets.chomp.split('\\\\n')\nn, m, p = input[0].split(' ').map(&:to_i)\ncandies = input[1].split(' ').map(&:to_i)\nstones = input[2].split(' ').map(&:to_i)\n\n# Calculate the maximum points and strategy\nmax_points, strategy = calculate_points(n, m, p, candies, stones)\n\n# Print the output\nputs max_points.to_s\nputs strategy\n","delphi":"program OptimalPlayingStrategy;\\n\\nvar\\n  n, m, p, i, j, maxPoints, maxIndex: Integer;\\n  candies, stones: array of Integer;\\n  points: array of array of Integer;\\n  strategy: string;\\n\\nfunction f(a, b: Integer): Integer;\\nbegin\\n  f := (candies[a] + stones[b]) mod p;\\nend;\\n\\nbegin\\n  ReadLn(n, m, p);\\n  SetLength(candies, n);\\n  SetLength(stones, m);\\n  SetLength(points, n, m);\\n\\n  for i := 0 to n - 1 do\\n    Read(candies[i]);\\n\\n  for i := 0 to m - 1 do\\n    Read(stones[i]);\\n\\n  maxPoints := 0;\\n\\n  for i := 0 to n - 2 do\\n  begin\\n    for j := 0 to m - 2 do\\n    begin\\n      points[i, j] := f(i, j);\\n\\n      if points[i, j] > maxPoints then\\n      begin\\n        maxPoints := points[i, j];\\n        maxIndex := j;\\n      end;\\n    end;\\n  end;\\n\\n  WriteLn(maxPoints);\\n\\n  strategy := '';\\n\\n  for i := 0 to n - 2 do\\n    strategy := strategy + 'C';\\n\\n  for i := 0 to m - 2 do\\n    strategy := strategy + 'S';\\n\\n  WriteLn(strategy);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnmp := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nmp[0])\\n\\tm, _ := strconv.Atoi(nmp[1])\\n\\tp, _ := strconv.Atoi(nmp[2])\\n\\n\\tscanner.Scan()\\n\\tx := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\tscanner.Scan()\\n\\ty := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\tmaxPoints, moves := calculateMaxPoints(n, m, p, x, y)\\n\\n\\tfmt.Println(maxPoints)\\n\\tfmt.Println(moves)\\n}\\n\\nfunc calculateMaxPoints(n, m, p int, x, y []string) (int, string) {\\n\\tmaxPoints := 0\\n\\tmoves := \\\"\\\"\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\txVal, _ := strconv.Atoi(x[i])\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tyVal, _ := strconv.Atoi(y[j])\\n\\t\\t\\tpoints := (xVal + yVal) % p\\n\\t\\t\\tif points > maxPoints {\\n\\t\\t\\t\\tmaxPoints = points\\n\\t\\t\\t\\tmoves = strings.Repeat(\\\"C\\\", i) + strings.Repeat(\\\"S\\\", j) + strings.Repeat(\\\"C\\\", n-i-1) + strings.Repeat(\\\"S\\\", m-j-1)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPoints, moves\\n}","Javascript":"function findOptimalStrategy(input) {\n  const [n, m, p] = input[0].split(' ').map(Number);\n  const candies = input[1].split(' ').map(Number);\n  const stones = input[2].split(' ').map(Number);\n\n  let maxPoints = 0;\n  let strategy = '';\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      const points = (candies[i] + stones[j]) % p;\n      if (points > maxPoints) {\n        maxPoints = points;\n        strategy = 'C'.repeat(i) + 'S'.repeat(j);\n      }\n    }\n  }\n\n  return `${maxPoints}\\n${strategy}`;\n}\n\nconst inputs = [\n  '2 2 10\\n0 0\\n0 1\\n',\n  '3 3 10\\n0 2 0\\n0 0 2\\n',\n  '3 3 2\\n0 1 1\\n1 1 0\\n'\n];\n\nconst outputs = inputs.map(input => findOptimalStrategy(input.split('\\\\n')));\n\nJSON.stringify(outputs);","Kotlin":"import kotlin.math.max\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val m = input[1]\\n    val p = input[2]\\n\\n    val candies = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val stones = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    val dp = Array(n + 1) { IntArray(m + 1) }\\n    val path = Array(n + 1) { CharArray(m + 1) }\\n\\n    for (i in 1..n) {\\n        dp[i][0] = (dp[i - 1][0] + candies[i - 1]) % p\\n        path[i][0] = 'C'\\n    }\\n\\n    for (i in 1..m) {\\n        dp[0][i] = (dp[0][i - 1] + stones[i - 1]) % p\\n        path[0][i] = 'S'\\n    }\\n\\n    for (i in 1..n) {\\n        for (j in 1..m) {\\n            val candyPoints = (dp[i - 1][j] + candies[i - 1]) % p\\n            val stonePoints = (dp[i][j - 1] + stones[j - 1]) % p\\n\\n            if (candyPoints > stonePoints) {\\n                dp[i][j] = candyPoints\\n                path[i][j] = 'C'\\n            } else {\\n                dp[i][j] = stonePoints\\n                path[i][j] = 'S'\\n            }\\n        }\\n    }\\n\\n    var i = n\\n    var j = m\\n    val moves = StringBuilder()\\n\\n    while (i > 0 && j > 0) {\\n        moves.append(path[i][j])\\n\\n        if (path[i][j] == 'C') {\\n            i--\\n        } else {\\n            j--\\n        }\\n    }\\n\\n    while (i > 0) {\\n        moves.append('C')\\n        i--\\n    }\\n\\n    while (j > 0) {\\n        moves.append('S')\\n        j--\\n    }\\n\\n    val maxPoints = dp[n][m]\\n\\n    println(maxPoints)\\n    println(moves.reverse())\\n}","PHP":"\n<?php\n\nfunction calculatePoints($n, $m, $p, $candies, $stones) {\n    $points = 0;\n    $moves = '';\n\n    \/\/ Sort the candies and stones in descending order\n    rsort($candies);\n    rsort($stones);\n\n    \/\/ Calculate the maximum number of moves\n    $maxMoves = min($n, $m) + 1;\n\n    \/\/ Iterate through all possible moves\n    for ($i = 0; $i < $maxMoves; $i++) {\n        $candyIndex = $i;\n        $stoneIndex = $maxMoves - $i - 2;\n\n        \/\/ Calculate the points for the current move\n        $currentPoints = ($candies[$candyIndex] + $stones[$stoneIndex]) % $p;\n\n        \/\/ Update the total points\n        $points += $currentPoints;\n\n        \/\/ Determine the move type (Candy or Stone)\n        if ($currentPoints == 0) {\n            $moves .= 'C';\n        } else {\n            $moves .= 'S';\n        }\n    }\n\n    return [$points, $moves];\n}\n\n\/\/ Read the input\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\nlist($n, $m, $p) = explode(' ', $input[0]);\n$candies = array_map('intval', explode(' ', $input[1]));\n$stones = array_map('intval', explode(' ', $input[2]));\n\n\/\/ Calculate the points and moves\n[$points, $moves] = calculatePoints($n, $m, $p, $candies, $stones);\n\n\/\/ Print the output\necho $points . '\\n';\necho $moves . '\\n';\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, m, p;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &p);\\r\\n\\r\\n    int[] candies;\\r\\n    candies.reserve(n);\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int candy;\\r\\n        readf(\\\"%d\\\", &candy);\\r\\n        candies ~= candy;\\r\\n    }\\r\\n\\r\\n    int[] stones;\\r\\n    stones.reserve(m);\\r\\n    foreach (_; 0..m)\\r\\n    {\\r\\n        int stone;\\r\\n        readf(\\\"%d\\\", &stone);\\r\\n        stones ~= stone;\\r\\n    }\\r\\n\\r\\n    int[][] dp;\\r\\n    dp.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        dp[i].length = m;\\r\\n        foreach (j; 0..m)\\r\\n        {\\r\\n            dp[i][j] = (candies[i] + stones[j]) % p;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[][] maxPoints;\\r\\n    maxPoints.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        maxPoints[i].length = m;\\r\\n        foreach (j; 0..m)\\r\\n        {\\r\\n            maxPoints[i][j] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    char[][] moves;\\r\\n    moves.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        moves[i].length = m;\\r\\n        foreach (j; 0..m)\\r\\n        {\\r\\n            moves[i][j] = ' ';\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for (int i = n - 2; i >= 0; i--)\\r\\n    {\\r\\n        maxPoints[i][m - 1] = maxPoints[i + 1][m - 1] + dp[i][m - 1];\\r\\n        moves[i][m - 1] = 'C';\\r\\n    }\\r\\n\\r\\n    for (int j = m - 2; j >= 0; j--)\\r\\n    {\\r\\n        maxPoints[n - 1][j] = maxPoints[n - 1][j + 1] + dp[n - 1][j];\\r\\n        moves[n - 1][j] = 'S';\\r\\n    }\\r\\n\\r\\n    for (int i = n - 2; i >= 0; i--)\\r\\n    {\\r\\n        for (int j = m - 2; j >= 0; j--)\\r\\n        {\\r\\n            int pointsIfCandy = maxPoints[i + 1][j] + dp[i][j];\\r\\n            int pointsIfStone = maxPoints[i][j + 1] + dp[i][j];\\r\\n\\r\\n            if (pointsIfCandy > pointsIfStone)\\r\\n            {\\r\\n                maxPoints[i][j] = pointsIfCandy;\\r\\n                moves[i][j] = 'C';\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                maxPoints[i][j] = pointsIfStone;\\r\\n                moves[i][j] = 'S';\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxPoints[0][0]);\\r\\n    writeln(moves[0][0..$]);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_points {\n    my ($n, $m, $p, $candies_ref, $stones_ref) = @_;\n\n    my @candies = @$candies_ref;\n    my @stones = @$stones_ref;\n\n    my $max_points = 0;\n    my $moves = '';\n\n    for (my $i = 0; $i < $n; $i++) {\n        my $points = ($candies[$i] + $stones[0]) % $p;\n        if ($points > $max_points) {\n            $max_points = $points;\n            $moves = 'C' x $i . 'S';\n        }\n    }\n\n    for (my $i = 0; $i < $m; $i++) {\n        my $points = ($candies[0] + $stones[$i]) % $p;\n        if ($points > $max_points) {\n            $max_points = $points;\n            $moves = 'S' x $i . 'C';\n        }\n    }\n\n    return ($max_points, $moves);\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $p) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @candies = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @stones = split ' ', $input;\n\n# Calculate points and moves\nmy ($max_points, $moves) = calculate_points($n, $m, $p, \\@candies, \\@stones);\n\n# Print output\nprint \"$max_points\\n\";\nprint \"$moves\\n\";\n","Rust":"fn main() {\\n    let input = \\\"3 3 10\\\\n0 2 0\\\\n0 0 2\\\\n\\\";\\n    let mut lines = input.lines();\\n    let nm = lines.next().unwrap();\\n    let candies = lines.next().unwrap();\\n    let stones = lines.next().unwrap();\\n\\n    let mut max_points = 0;\\n    let mut strategy = String::new();\\n\\n    let mut candy_index = 0;\\n    let mut stone_index = 0;\\n\\n    let mut candy_sum = 0;\\n    let mut stone_sum = 0;\\n\\n    let p = nm.split_whitespace().nth(2).unwrap().parse::<u32>().unwrap();\\n\\n    for _ in 0..(candies.len() + stones.len() - 2) {\\n        let candy = candies.split_whitespace().nth(candy_index).unwrap().parse::<u32>().unwrap();\\n        let stone = stones.split_whitespace().nth(stone_index).unwrap().parse::<u32>().unwrap();\\n\\n        if candy_sum + candy <= stone_sum + stone {\\n            candy_sum += candy;\\n            candy_index += 1;\\n            strategy.push('C');\\n        } else {\\n            stone_sum += stone;\\n            stone_index += 1;\\n            strategy.push('S');\\n        }\\n\\n        let points = (candy_sum + stone_sum) % p;\\n        if points > max_points {\\n            max_points = points;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", max_points);\\n    println!(\\\"{}\\\", strategy);\\n}"}
{"title":"A. Clothes","description":"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.Overall the shop sells n clothing items, and exactly m pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input file line contains integers n and m \u2014 the total number of clothing items in the shop and the total number of matching pairs of clothing items ().\nNext line contains n integers ai (1\u2264ai\u226410^6) \u2014 the prices of the clothing items in rubles.\nNext m lines each contain a pair of space-separated integers ui and vi (1\u2264ui,vi\u2264n,ui\u2260vi). Each such pair of numbers means that the ui-th and the vi-th clothing items match each other. It is guaranteed that in each pair ui and vi are distinct and all the unordered pairs (ui,vi) are different.\n","output_spec":"Print the only number \u2014 the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print \"-1\" (without the quotes).\n","notes":"In the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way \u2014 to buy the 3 pieces of clothing; in this case he spends 6 roubles.\nThe second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.\nIn the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.\n","sample_inputs":["3 3\n1 2 3\n1 2\n2 3\n3 1\n","3 2\n2 3 4\n2 3\n2 1\n","4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1\n"],"sample_outputs":["6\n","-1\n","-1\n"],"id":"102-A","difficulty":1200,"tags":["brute+force"],"src_uid":"d90da1e932a6aa546bec4e1bd4b1fbec","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <climits>\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<int> prices(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> prices[i];\\n    }\\n    vector<vector<int>> matches(m, vector<int>(2));\\n    for (int i = 0; i < m; i++) {\\n        cin >> matches[i][0] >> matches[i][1];\\n    }\\n    int minCost = INT_MAX;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = i + 1; j < m; j++) {\\n            int a = matches[i][0] - 1;\\n            int b = matches[i][1] - 1;\\n            int c = matches[j][0] - 1;\\n            int d = matches[j][1] - 1;\\n            if (a == c || a == d || b == c || b == d) {\\n                continue;\\n            }\\n            int cost = prices[a] + prices[b] + prices[c];\\n            minCost = min(minCost, cost);\\n        }\\n    }\\n    if (minCost == INT_MAX) {\\n        cout << -1 << endl;\\n    } else {\\n        cout << minCost << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class ClothingShop {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input values\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        int[] prices = new int[n];\n        for (int i = 0; i < n; i++) {\n            prices[i] = scanner.nextInt();\n        }\n        \n        List<Integer>[] matches = new List[n];\n        for (int i = 0; i < n; i++) {\n            matches[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int ui = scanner.nextInt() - 1;\n            int vi = scanner.nextInt() - 1;\n            matches[ui].add(vi);\n            matches[vi].add(ui);\n        }\n        \n        int minCost = Integer.MAX_VALUE;\n        \n        \/\/ Find three matching clothing items with minimum cost\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < matches[i].size(); j++) {\n                int u = i;\n                int v = matches[i].get(j);\n                \n                for (int k = 0; k < matches[v].size(); k++) {\n                    int w = matches[v].get(k);\n                    \n                    if (matches[w].contains(u)) {\n                        int cost = prices[u] + prices[v] + prices[w];\n                        minCost = Math.min(minCost, cost);\n                    }\n                }\n            }\n        }\n        \n        if (minCost == Integer.MAX_VALUE) {\n            System.out.println(\"-1\");\n        } else {\n            System.out.println(minCost);\n        }\n    }\n}","Python":"def find_least_sum(n, m, prices, matches):\n    min_sum = float('inf')\n    for i in range(m):\n        for j in range(i+1, m):\n            for k in range(j+1, m):\n                if matches[i][0] != matches[j][0] and matches[i][0] != matches[k][0] and matches[j][0] != matches[k][0]:\n                    sum_price = prices[matches[i][0]-1] + prices[matches[j][0]-1] + prices[matches[k][0]-1]\n                    min_sum = min(min_sum, sum_price)\n    if min_sum == float('inf'):\n        return '-1'\n    return str(min_sum)\n\ninput_data = ['3 3\\\\n1 2 3\\\\n1 2\\\\n2 3\\\\n3 1\\\\n', '3 2\\\\n2 3 4\\\\n2 3\\\\n2 1\\\\n', '4 4\\\\n1 1 1 1\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 1\\\\n']\noutput_data = ['6\\\\n', '-1\\\\n', '-1\\\\n']\n\nfor i in range(len(input_data)):\n    input_lines = input_data[i].strip().split('\\\\n')\n    n, m = map(int, input_lines[0].split())\n    prices = list(map(int, input_lines[1].split()))\n    matches = [list(map(int, line.split())) for line in input_lines[2:]]\n    \n    assert find_least_sum(n, m, prices, matches) == output_data[i].strip()\n\nprint('All test cases pass')","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int prices[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &prices[i]);\\n    }\\n    int matches[m][2];\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%d %d\\\", &matches[i][0], &matches[i][1]);\\n    }\\n    int minSum = -1;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = i + 1; j < m; j++) {\\n            for (int k = j + 1; k < m; k++) {\\n                int item1 = matches[i][0];\\n                int item2 = matches[j][0];\\n                int item3 = matches[k][0];\\n                if ((matches[i][1] == item2 && matches[j][1] == item3 && matches[k][1] == item1) ||\\n                    (matches[i][1] == item3 && matches[j][1] == item1 && matches[k][1] == item2) ||\\n                    (matches[i][1] == item1 && matches[j][1] == item2 && matches[k][1] == item3)) {\\n                    int sum = prices[item1 - 1] + prices[item2 - 1] + prices[item3 - 1];\\n                    if (minSum == -1 || sum < minSum) {\\n                        minSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", minSum);\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace ClothingShop\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n\n            int[] prices = new int[n];\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n            for (int i = 0; i < n; i++)\n            {\n                prices[i] = int.Parse(inputArr[i]);\n            }\n\n            List<int>[] matches = new List<int>[n];\n            for (int i = 0; i < n; i++)\n            {\n                matches[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine();\n                inputArr = input.Split(' ');\n                int u = int.Parse(inputArr[0]) - 1;\n                int v = int.Parse(inputArr[1]) - 1;\n                matches[u].Add(v);\n                matches[v].Add(u);\n            }\n\n            int minCost = int.MaxValue;\n\n            for (int i = 0; i < n; i++)\n            {\n                foreach (int j in matches[i])\n                {\n                    foreach (int k in matches[j])\n                    {\n                        if (matches[k].Contains(i))\n                        {\n                            int totalCost = prices[i] + prices[j] + prices[k];\n                            minCost = Math.Min(minCost, totalCost);\n                        }\n                    }\n                }\n            }\n\n            if (minCost == int.MaxValue)\n            {\n                Console.WriteLine(\"-1\");\n            }\n            else\n            {\n                Console.WriteLine(minCost);\n            }\n        }\n    }\n}\n","Ruby":"\ndef find_least_sum(n, m, prices, matches)\n  # Create a hash to store the prices of each clothing item\n  clothing_prices = {}\n  prices.each_with_index do |price, index|\n    clothing_prices[index + 1] = price\n  end\n\n  # Iterate through all possible combinations of three clothing items\n  (1..n).to_a.combination(3).each do |combination|\n    # Check if all three clothing items match each other\n    if matches.include?([combination[0], combination[1]]) && matches.include?([combination[1], combination[2]]) && matches.include?([combination[0], combination[2]])\n      # Calculate the sum of the prices of the three clothing items\n      sum = clothing_prices[combination[0]] + clothing_prices[combination[1]] + clothing_prices[combination[2]]\n      return sum\n    end\n  end\n\n  # If no three matching clothing items are found, return -1\n  return -1\nend\n\n# Parse the input\ninput = gets.chomp.split('\\n')\nn, m = input[0].split(' ').map(&:to_i)\nprices = input[1].split(' ').map(&:to_i)\nmatches = []\ninput[2..-1].each do |line|\n  matches << line.split(' ').map(&:to_i)\nend\n\n# Call the function and print the result\nresult = find_least_sum(n, m, prices, matches)\nputs result\n","delphi":"program LeastPossibleSum;\\n\\nvar\\n  n, m, i, j, k, minSum: integer;\\n  prices: array of integer;\\n  matches: array of array of integer;\\n  matchCount: array of integer;\\n\\nbegin\\n  readln(n, m);\\n  SetLength(prices, n);\\n  SetLength(matches, m, 2);\\n  SetLength(matchCount, n);\\n\\n  for i := 0 to n-1 do\\n    read(prices[i]);\\n\\n  for i := 0 to m-1 do\\n  begin\\n    readln(matches[i, 0], matches[i, 1]);\\n    Inc(matchCount[matches[i, 0]-1]);\\n    Inc(matchCount[matches[i, 1]-1]);\\n  end;\\n\\n  minSum := -1;\\n\\n  for i := 0 to m-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      if (i <> j) and (matches[i, 1] = matches[j, 0]) then\\n      begin\\n        for k := 0 to n-1 do\\n        begin\\n          if (k <> matches[i, 0]-1) and (k <> matches[i, 1]-1) and (k <> matches[j, 1]-1) and (matchCount[k] > 0) then\\n          begin\\n            if (minSum = -1) or (prices[k] + prices[matches[i, 0]-1] + prices[matches[i, 1]-1] + prices[matches[j, 1]-1] < minSum) then\\n              minSum := prices[k] + prices[matches[i, 0]-1] + prices[matches[i, 1]-1] + prices[matches[j, 1]-1];\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  writeln(minSum);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tprices := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &prices[i])\\n\\t}\\n\\n\\tmatches := make([][]bool, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tmatches[i] = make([]bool, n)\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tvar u, v int\\n\\t\\tfmt.Scanf(\\\"%d %d\\\", &u, &v)\\n\\t\\tmatches[u-1][v-1] = true\\n\\t\\tmatches[v-1][u-1] = true\\n\\t}\\n\\n\\tminCost := math.MaxInt64\\n\\n\\tfor i := 0; i < n-2; i++ {\\n\\t\\tfor j := i+1; j < n-1; j++ {\\n\\t\\t\\tfor k := j+1; k < n; k++ {\\n\\t\\t\\t\\tif matches[i][j] && matches[j][k] && matches[k][i] {\\n\\t\\t\\t\\t\\tcost := prices[i] + prices[j] + prices[k]\\n\\t\\t\\t\\t\\tif cost < minCost {\\n\\t\\t\\t\\t\\t\\tminCost = cost\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif minCost == math.MaxInt64 {\\n\\t\\tfmt.Println(-1)\\n\\t} else {\\n\\t\\tfmt.Println(minCost)\\n\\t}\\n}","Javascript":"function findLeastPossibleSum(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const prices = lines[1].split(' ').map(Number);\n  const matches = [];\n  \n  for (let i = 0; i < m; i++) {\n    const [ui, vi] = lines[i + 2].split(' ').map(Number);\n    matches.push([ui, vi]);\n  }\n  \n  let minSum = Infinity;\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (matches.some(([ui, vi]) => (ui === i + 1 && vi === j + 1) || (ui === j + 1 && vi === k + 1) || (ui === i + 1 && vi === k + 1))) {\n          const sum = prices[i] + prices[j] + prices[k];\n          minSum = Math.min(minSum, sum);\n        }\n      }\n    }\n  }\n  \n  return minSum === Infinity ? '-1' : minSum.toString();\n}\n\nconst inputs = ['3 3\\\\n1 2 3\\\\n1 2\\\\n2 3\\\\n3 1\\\\n', '3 2\\\\n2 3 4\\\\n2 3\\\\n2 1\\\\n', '4 4\\\\n1 1 1 1\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 1\\\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const output = findLeastPossibleSum(inputs[i]);\n  outputs.push(output);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    \n    val prices = scanner.nextLine().split(\" \").map { it.toInt() }\n    \n    val matches = mutableListOf<Pair<Int, Int>>()\n    repeat(m) {\n        val pair = scanner.nextLine().split(\" \").map { it.toInt() }\n        matches.add(Pair(pair[0], pair[1]))\n    }\n    \n    var minSum = Int.MAX_VALUE\n    \n    for (i in 0 until n) {\n        for (j in i + 1 until n) {\n            for (k in j + 1 until n) {\n                if (matches.contains(Pair(i + 1, j + 1)) && matches.contains(Pair(j + 1, k + 1)) && matches.contains(Pair(i + 1, k + 1))) {\n                    val sum = prices[i] + prices[j] + prices[k]\n                    minSum = minOf(minSum, sum)\n                }\n            }\n        }\n    }\n    \n    if (minSum == Int.MAX_VALUE) {\n        println(\"-1\")\n    } else {\n        println(minSum)\n    }\n}","PHP":"\n<?php\n\nfunction findLeastPossibleSum($n, $m, $prices, $matches) {\n    $minSum = PHP_INT_MAX;\n    \n    \/\/ Check all possible combinations of three clothing items\n    for ($i = 0; $i < $n - 2; $i++) {\n        for ($j = $i + 1; $j < $n - 1; $j++) {\n            for ($k = $j + 1; $k < $n; $k++) {\n                \/\/ Check if the three clothing items match each other\n                if (in_array([$i, $j], $matches) && in_array([$j, $k], $matches) && in_array([$k, $i], $matches)) {\n                    $sum = $prices[$i] + $prices[$j] + $prices[$k];\n                    $minSum = min($minSum, $sum);\n                }\n            }\n        }\n    }\n    \n    \/\/ If no matching set of three clothing items is found, return -1\n    if ($minSum == PHP_INT_MAX) {\n        return -1;\n    }\n    \n    return $minSum;\n}\n\n\/\/ Sample inputs\n$inputs = [\n    ['3 3\\n1 2 3\\n1 2\\n2 3\\n3 1\\n'],\n    ['3 2\\n2 3 4\\n2 3\\n2 1\\n'],\n    ['4 4\\n1 1 1 1\\n1 2\\n2 3\\n3 4\\n4 1\\n']\n];\n\n\/\/ Process each sample input\nforeach ($inputs as $input) {\n    $lines = explode('\\n', $input);\n    $params = explode(' ', $lines[0]);\n    $n = intval($params[0]);\n    $m = intval($params[1]);\n    $prices = array_map('intval', explode(' ', $lines[1]));\n    $matches = [];\n    \n    \/\/ Parse the matching pairs\n    for ($i = 2; $i < $m + 2; $i++) {\n        $pair = explode(' ', $lines[$i]);\n        $matches[] = [intval($pair[0]) - 1, intval($pair[1]) - 1];\n    }\n    \n    \/\/ Find the least possible sum\n    $result = findLeastPossibleSum($n, $m, $prices, $matches);\n    \n    \/\/ Print the result\n    echo $result . '\\n';\n}\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nstruct ClothingItem\\r\\n{\\r\\n    int price;\\r\\n    int[] matches;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    ClothingItem[] clothingItems;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int price;\\r\\n        readf(\\\"%d\\\", &price);\\r\\n        clothingItems ~= ClothingItem(price, []);\\r\\n    }\\r\\n\\r\\n    foreach (_; 0..m)\\r\\n    {\\r\\n        int ui, vi;\\r\\n        readf(\\\"%d %d\\\", &ui, &vi);\\r\\n        clothingItems[ui - 1].matches ~= vi - 1;\\r\\n        clothingItems[vi - 1].matches ~= ui - 1;\\r\\n    }\\r\\n\\r\\n    int minPrice = int.max;\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        foreach (j; clothingItems[i].matches)\\r\\n        {\\r\\n            foreach (k; clothingItems[j].matches)\\r\\n            {\\r\\n                if (k != i && k in clothingItems[i].matches)\\r\\n                {\\r\\n                    int totalPrice = clothingItems[i].price + clothingItems[j].price + clothingItems[k].price;\\r\\n                    minPrice = min(minPrice, totalPrice);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (minPrice == int.max)\\r\\n    {\\r\\n        writeln(\\\"-1\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(to!string(minPrice));\\r\\n    }\\r\\n}","perl":"\n# Read input values\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @prices = split ' ', $input;\n\nmy %matches;\nfor (my $i = 0; $i < $m; $i++) {\n    $input = <STDIN>;\n    chomp $input;\n    my ($ui, $vi) = split ' ', $input;\n    $matches{$ui}{$vi} = 1;\n    $matches{$vi}{$ui} = 1;\n}\n\nmy $min_cost = -1;\n\n# Iterate through all possible combinations of three clothing items\nfor (my $i = 1; $i <= $n; $i++) {\n    for (my $j = $i + 1; $j <= $n; $j++) {\n        for (my $k = $j + 1; $k <= $n; $k++) {\n            # Check if all three items match each other\n            if ($matches{$i}{$j} && $matches{$j}{$k} && $matches{$k}{$i}) {\n                my $cost = $prices[$i-1] + $prices[$j-1] + $prices[$k-1];\n                if ($min_cost == -1 || $cost < $min_cost) {\n                    $min_cost = $cost;\n                }\n            }\n        }\n    }\n}\n\nprint $min_cost;\n","Rust":"\nuse std::collections::HashSet;\n\nfn main() {\n    let input = \"3 3\\n1 2 3\\n1 2\\n2 3\\n3 1\\n\";\n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n\n    let nm: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n\n    let prices: Vec<usize> = lines[1].split(' ').map(|x| x.parse().unwrap()).collect();\n\n    let mut matches: HashSet<(usize, usize)> = HashSet::new();\n    for i in 0..m {\n        let pair: Vec<usize> = lines[i + 2].split(' ').map(|x| x.parse().unwrap()).collect();\n        matches.insert((pair[0], pair[1]));\n        matches.insert((pair[1], pair[0]));\n    }\n\n    let mut min_price = usize::MAX;\n    for i in 0..n {\n        for j in (i + 1)..n {\n            if matches.contains(&(i + 1, j + 1)) {\n                for k in (j + 1)..n {\n                    if matches.contains(&(i + 1, k + 1)) && matches.contains(&(j + 1, k + 1)) {\n                        let total_price = prices[i] + prices[j] + prices[k];\n                        min_price = min_price.min(total_price);\n                    }\n                }\n            }\n        }\n    }\n\n    if min_price == usize::MAX {\n        println!(\"-1\");\n    } else {\n        println!(\"{}\", min_price);\n    }\n}\n"}
{"title":"B. Cthulhu","description":"...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.To add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.It is guaranteed that the graph contains no multiple edges and self-loops. ","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1\u2264n\u2264100, 0\u2264m\u2264).\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1\u2264x,y\u2264n,x\u2260y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n","output_spec":"Print \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n","notes":"Let us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v-1 and v, v and 1.\nA tree is a connected undirected graph consisting of n vertices and n-1 edges (n>0).\nA rooted tree is a tree where one vertex is selected to be the root.\n","sample_inputs":["6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n","6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n"],"sample_outputs":["FHTAGN!","NO"],"id":"103-B","difficulty":1500,"tags":["dfs+and+similar","dsu","graphs"],"src_uid":"4ecbfc792da55f458342c6eff2d5da5a","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\nusing namespace std;\\n\\nvector<int> adj[101];\\nbool visited[101];\\n\\nvoid bfs(int start) {\\n    queue<int> q;\\n    q.push(start);\\n    visited[start] = true;\\n\\n    while (!q.empty()) {\\n        int node = q.front();\\n        q.pop();\\n\\n        for (int i = 0; i < adj[node].size(); i++) {\\n            int next = adj[node][i];\\n            if (!visited[next]) {\\n                q.push(next);\\n                visited[next] = true;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    for (int i = 0; i < m; i++) {\\n        int x, y;\\n        cin >> x >> y;\\n        adj[x].push_back(y);\\n        adj[y].push_back(x);\\n    }\\n\\n    bool isCthulhu = true;\\n\\n    if (m != n || n < 3) {\\n        isCthulhu = false;\\n    } else {\\n        bfs(1);\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (!visited[i]) {\\n                isCthulhu = false;\\n                break;\\n            }\\n        }\\n    }\\n\\n    if (isCthulhu) {\\n        cout << \\\"FHTAGN!\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class CthulhuGraph {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            graph.get(x).add(y);\n            graph.get(y).add(x);\n        }\n        \n        boolean isCthulhu = checkCthulhu(graph, n);\n        \n        if (isCthulhu) {\n            System.out.println(\\\"FHTAGN!\\\");\n        } else {\n            System.out.println(\\\"NO\\\");\n        }\n    }\n    \n    private static boolean checkCthulhu(List<List<Integer>> graph, int n) {\n        boolean[] visited = new boolean[n + 1];\n        int[] parent = new int[n + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            if (!visited[i]) {\n                if (dfs(graph, visited, parent, i, -1)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private static boolean dfs(List<List<Integer>> graph, boolean[] visited, int[] parent, int vertex, int prev) {\n        visited[vertex] = true;\n        parent[vertex] = prev;\n        \n        for (int neighbor : graph.get(vertex)) {\n            if (!visited[neighbor]) {\n                if (dfs(graph, visited, parent, neighbor, vertex)) {\n                    return true;\n                }\n            } else if (neighbor != prev) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}","Python":"def is_cthulhu(n, m, edges):\n    if n != m or n < 3:\n        return 'NO'\n    else:\n        return 'FHTAGN!'\n\ninput_data = ['6 6\\n6 3\\n6 4\\n5 1\\n2 5\\n1 4\\n5 4\\n', '6 5\\n5 6\\n4 6\\n3 1\\n5 1\\n1 2\\n']\noutput_data = []\n\nfor data in input_data:\n    data = data.split('\\\\n')\n    n, m = map(int, data[0].split())\n    edges = []\n    for i in range(1, m+1):\n        x, y = map(int, data[i].split())\n        edges.append((x, y))\n    output = is_cthulhu(n, m, edges)\n    output_data.append(output)\n\nresult = [{\"version\": \"Python 3\", \"source code\": is_cthulhu.__code__.co_code.hex()}]\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_VERTICES 100\\n\\nint visited[MAX_VERTICES];\\nint adjMatrix[MAX_VERTICES][MAX_VERTICES];\\n\\nvoid dfs(int v, int n) {\\n    visited[v] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        if (adjMatrix[v][i] && !visited[i]) {\\n            dfs(i, n);\\n        }\\n    }\\n}\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n\\n    for (int i = 0; i < m; i++) {\\n        int x, y;\\n        scanf(\\\"%d %d\\\", &x, &y);\\n        adjMatrix[x][y] = 1;\\n        adjMatrix[y][x] = 1;\\n    }\\n\\n    int connectedComponents = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        if (!visited[i]) {\\n            dfs(i, n);\\n            connectedComponents++;\\n        }\\n    }\\n\\n    if (connectedComponents == 1 && m == n) {\\n        printf(\\\"FHTAGN!\\\");\\n    } else {\\n        printf(\\\"NO\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace CthulhuGraph\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n\n            List<int>[] graph = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                string edge = Console.ReadLine();\n                string[] edgeArr = edge.Split(' ');\n                int x = int.Parse(edgeArr[0]);\n                int y = int.Parse(edgeArr[1]);\n\n                graph[x].Add(y);\n                graph[y].Add(x);\n            }\n\n            bool isCthulhu = IsCthulhu(graph, n);\n\n            if (isCthulhu)\n            {\n                Console.WriteLine(\\\"FHTAGN!\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"NO\\\");\n            }\n        }\n\n        static bool IsCthulhu(List<int>[] graph, int n)\n        {\n            bool[] visited = new bool[n + 1];\n            int[] parent = new int[n + 1];\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (!visited[i])\n                {\n                    if (DFS(graph, visited, parent, i, -1))\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        static bool DFS(List<int>[] graph, bool[] visited, int[] parent, int vertex, int prev)\n        {\n            visited[vertex] = true;\n\n            foreach (int neighbor in graph[vertex])\n            {\n                if (!visited[neighbor])\n                {\n                    parent[neighbor] = vertex;\n                    if (DFS(graph, visited, parent, neighbor, vertex))\n                    {\n                        return true;\n                    }\n                }\n                else if (neighbor != prev)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}","Ruby":"def is_cthulhu(graph)\n  # Count the number of vertices and edges\n  n, m = graph.shift.split.map(&:to_i)\n  \n  # Create an adjacency list to represent the graph\n  adjacency_list = Array.new(n + 1) { [] }\n  graph.each do |edge|\n    x, y = edge.split.map(&:to_i)\n    adjacency_list[x] << y\n    adjacency_list[y] << x\n  end\n  \n  # Perform a depth-first search to check if the graph is Cthulhu\n  visited = Array.new(n + 1, false)\n  stack = [1]\n  visited[1] = true\n  while !stack.empty?\n    current_vertex = stack.pop\n    adjacency_list[current_vertex].each do |neighbor|\n      if !visited[neighbor]\n        stack << neighbor\n        visited[neighbor] = true\n      end\n    end\n  end\n  \n  # Check if all vertices are visited\n  if visited.count(true) == n\n    # Check if the graph has a cycle\n    cycle = false\n    adjacency_list.each_with_index do |neighbors, vertex|\n      if neighbors.size > 1 && !cycle\n        neighbors.each do |neighbor|\n          if adjacency_list[neighbor].size > 1\n            cycle = true\n            break\n          end\n        end\n      end\n    end\n    \n    if cycle\n      return 'FHTAGN!'\n    else\n      return 'NO'\n    end\n  else\n    return 'NO'\n  end\nend\n\n# Test the function with the sample inputs\ninputs = ['6 6\\n6 3\\n6 4\\n5 1\\n2 5\\n1 4\\n5 4\\n', '6 5\\n5 6\\n4 6\\n3 1\\n5 1\\n1 2\\n']\noutputs = ['FHTAGN!', 'NO']\n\nresults = []\ninputs.each_with_index do |input, index|\n  graph = input.split(\"\\n\")\n  result = is_cthulhu(graph)\n  results << (result == outputs[index])\nend\n\nresults","delphi":"Here is a possible implementation in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tm, _ := strconv.Atoi(scanner.Text())\\n\\n\\tadjList := make([][]int, n+1)\\n\\tvisited := make([]bool, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tx, _ := strconv.Atoi(scanner.Text())\\n\\t\\tscanner.Scan()\\n\\t\\ty, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\\tadjList[x] = append(adjList[x], y)\\n\\t\\tadjList[y] = append(adjList[y], x)\\n\\t}\\n\\n\\tif m != n || !isConnected(adjList, visited, 1, -1) {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t} else {\\n\\t\\tif isCthulhu(adjList, visited, 1, -1, 0) {\\n\\t\\t\\tfmt.Println(\\\"FHTAGN!\\\")\\n\\t\\t} else {\\n\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc isConnected(adjList [][]int, visited []bool, node, parent int) bool {\\n\\tvisited[node] = true\\n\\n\\tfor _, neighbor := range adjList[node] {\\n\\t\\tif !visited[neighbor] {\\n\\t\\t\\tif isConnected(adjList, visited, neighbor, node) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t} else if neighbor != parent {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc isCthulhu(adjList [][]int, visited []bool, node, parent, count int) bool {\\n\\tvisited[node] = true\\n\\tcount++\\n\\n\\tif count >= 3 && node == 1 {\\n\\t\\treturn true\\n\\t}\\n\\n\\tfor _, neighbor := range adjList[node] {\\n\\t\\tif !visited[neighbor] {\\n\\t\\t\\tif isCthulhu(adjList, visited, neighbor, node, count) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t} else if neighbor != parent {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}","Javascript":"function isCthulhu(graph) {\n  const n = graph.length;\n  const m = graph.reduce((acc, edges) => acc + edges.length, 0) \/ 2;\n\n  if (n < 3 || m < 3 || n !== m) {\n    return 'NO';\n  }\n\n  const visited = new Array(n + 1).fill(false);\n  const parent = new Array(n + 1).fill(-1);\n\n  let components = 0;\n\n  function dfs(v) {\n    visited[v] = true;\n    components++;\n\n    for (let i = 0; i < graph[v].length; i++) {\n      const u = graph[v][i];\n\n      if (!visited[u]) {\n        parent[u] = v;\n        dfs(u);\n      } else if (parent[v] !== u) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  for (let i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      if (dfs(i)) {\n        return 'FHTAGN!';\n      }\n    }\n  }\n\n  if (components === 1) {\n    return 'NO';\n  }\n\n  return 'FHTAGN!';\n}\n\nconst input = '6 6\\\\n6 3\\\\n6 4\\\\n5 1\\\\n2 5\\\\n1 4\\\\n5 4\\\\n';\nconst lines = input.trim().split('\\\\n');\nconst [n, m] = lines[0].split(' ').map(Number);\n\nconst graph = new Array(n + 1).fill(null).map(() => []);\n\nfor (let i = 1; i <= m; i++) {\n  const [x, y] = lines[i].split(' ').map(Number);\n  graph[x].push(y);\n  graph[y].push(x);\n}\n\nconst result = isCthulhu(graph);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n\n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    val visited = BooleanArray(n + 1)\n\n    repeat(m) {\n        val edge = readLine()!!.split(\" \")\n        val x = edge[0].toInt()\n        val y = edge[1].toInt()\n        graph[x].add(y)\n        graph[y].add(x)\n    }\n\n    fun dfs(v: Int, parent: Int): Boolean {\n        visited[v] = true\n        for (u in graph[v]) {\n            if (!visited[u]) {\n                if (dfs(u, v)) return true\n            } else if (u != parent) {\n                return true\n            }\n        }\n        return false\n    }\n\n    var components = 0\n    for (i in 1..n) {\n        if (!visited[i]) {\n            if (dfs(i, -1)) {\n                println(\"FHTAGN!\")\n                return\n            }\n            components++\n        }\n    }\n\n    if (components == 1) {\n        println(\"NO\")\n    } else {\n        println(\"FHTAGN!\")\n    }\n}","PHP":"<?php\\n\\nfunction isCthulhu($n, $m, $edges) {\\n    \/\/ Create an adjacency list to represent the graph\\n    $adjList = array_fill(1, $n, []);\\n    foreach ($edges as $edge) {\\n        $x = $edge[0];\\n        $y = $edge[1];\\n        $adjList[$x][] = $y;\\n        $adjList[$y][] = $x;\\n    }\\n\\n    \/\/ Perform a depth-first search to check if the graph is Cthulhu\\n    $visited = array_fill(1, $n, false);\\n    $parent = array_fill(1, $n, -1);\\n    $cycleFound = false;\\n\\n    function dfs($node, $prev) {\\n        global $adjList, $visited, $parent, $cycleFound;\\n        $visited[$node] = true;\\n        $parent[$node] = $prev;\\n\\n        foreach ($adjList[$node] as $neighbor) {\\n            if (!$visited[$neighbor]) {\\n                dfs($neighbor, $node);\\n            } elseif ($neighbor != $prev) {\\n                $cycleFound = true;\\n            }\\n        }\\n    }\\n\\n    dfs(1, -1);\\n\\n    \/\/ Check if all vertices are visited and a cycle is found\\n    if (array_search(false, $visited) !== false || !$cycleFound) {\\n        return 'NO';\\n    }\\n\\n    return 'FHTAGN!';\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    ['6 6', '6 3', '6 4', '5 1', '2 5', '1 4', '5 4'],\\n    ['6 5', '5 6', '4 6', '3 1', '5 1', '1 2'],\\n];\\n\\n\/\/ Process sample inputs\\n$outputs = [];\\nforeach ($inputs as $input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    list($n, $m) = explode(\\\" \\\", $lines[0]);\\n    $edges = [];\\n    for ($i = 1; $i <= $m; $i++) {\\n        list($x, $y) = explode(\\\" \\\", $lines[$i]);\\n        $edges[] = [$x, $y];\\n    }\\n    $outputs[] = isCthulhu($n, $m, $edges);\\n}\\n\\n\/\/ Output the results\\nforeach ($outputs as $output) {\\n    echo $output . \\\"\\\\n\\\";\\n}\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    if (m != n || n < 3)\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    Graph graph;\\r\\n\\r\\n    for (int i = 0; i < m; i++)\\r\\n    {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        graph.addEdge(x, y);\\r\\n    }\\r\\n\\r\\n    if (graph.isCthulhu())\\r\\n        writeln(\\\"FHTAGN!\\\");\\r\\n    else\\r\\n        writeln(\\\"NO\\\");\\r\\n}\\r\\n\\r\\nclass Graph\\r\\n{\\r\\n    private\\r\\n    {\\r\\n        int n;\\r\\n        int m;\\r\\n        int[][] adjList;\\r\\n        bool[] visited;\\r\\n\\r\\n        void dfs(int v)\\r\\n        {\\r\\n            visited[v] = true;\\r\\n\\r\\n            foreach (int u; adjList[v])\\r\\n            {\\r\\n                if (!visited[u])\\r\\n                    dfs(u);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    this()\\r\\n    {\\r\\n        n = 0;\\r\\n        m = 0;\\r\\n        adjList = new int[][];\\r\\n        visited = new bool[];\\r\\n    }\\r\\n\\r\\n    void addEdge(int x, int y)\\r\\n    {\\r\\n        if (x > n)\\r\\n            n = x;\\r\\n\\r\\n        if (y > n)\\r\\n            n = y;\\r\\n\\r\\n        if (adjList.length <= n)\\r\\n        {\\r\\n            adjList.length = n + 1;\\r\\n            visited.length = n + 1;\\r\\n        }\\r\\n\\r\\n        adjList[x] ~= y;\\r\\n        adjList[y] ~= x;\\r\\n        m++;\\r\\n    }\\r\\n\\r\\n    bool isCthulhu()\\r\\n    {\\r\\n        if (m != n)\\r\\n            return false;\\r\\n\\r\\n        visited[] = false;\\r\\n        dfs(1);\\r\\n\\r\\n        if (visited.count(true) != n)\\r\\n            return false;\\r\\n\\r\\n        visited[] = false;\\r\\n        dfs(adjList[1][0]);\\r\\n\\r\\n        if (visited.count(true) != n)\\r\\n            return false;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub is_cthulhu {\n    my ($n, $m, @edges) = @_;\n\n    # Check if the number of vertices is less than 3\n    return 'NO' if $n < 3;\n\n    # Check if the number of edges is not equal to the number of vertices\n    return 'NO' if $m != $n;\n\n    # Create an adjacency list representation of the graph\n    my %adj_list;\n    foreach my $edge (@edges) {\n        my ($x, $y) = split ' ', $edge;\n        push @{$adj_list{$x}}, $y;\n        push @{$adj_list{$y}}, $x;\n    }\n\n    # Perform a depth-first search to check if the graph is connected\n    my %visited;\n    my $start_vertex = 1;\n    dfs($start_vertex, \\%adj_list, \\%visited);\n\n    # Check if all vertices are visited\n    return 'NO' if scalar(keys %visited) != $n;\n\n    # Check if the graph contains a cycle\n    my %parent;\n    foreach my $vertex (keys %visited) {\n        next if $visited{$vertex};\n        return 'NO' if dfs_cycle($vertex, \\%adj_list, \\%visited, \\%parent);\n    }\n\n    return 'FHTAGN!';\n}\n\nsub dfs {\n    my ($vertex, $adj_list, $visited) = @_;\n\n    $visited->{$vertex} = 1;\n\n    foreach my $neighbor (@{$adj_list->{$vertex}}) {\n        next if $visited->{$neighbor};\n        dfs($neighbor, $adj_list, $visited);\n    }\n}\n\nsub dfs_cycle {\n    my ($vertex, $adj_list, $visited, $parent) = @_;\n\n    $visited->{$vertex} = 1;\n\n    foreach my $neighbor (@{$adj_list->{$vertex}}) {\n        next if $visited->{$neighbor} && $parent->{$vertex} ne $neighbor;\n        return 1 if !$visited->{$neighbor} && dfs_cycle($neighbor, $adj_list, $visited, $parent);\n    }\n\n    return 0;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\nmy ($n, $m) = split ' ', $input;\n\nmy @edges;\nfor (my $i = 0; $i < $m; $i++) {\n    my $edge = <STDIN>;\n    chomp $edge;\n    push @edges, $edge;\n}\n\n# Check if the graph is Cthulhu\nmy $result = is_cthulhu($n, $m, @edges);\n\n# Print the result\nprint $result;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nm: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n    \n    let mut adj_list: Vec<Vec<usize>> = vec![vec![]; n+1];\n    for _ in 0..m {\n        let edge: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        let u = edge[0];\n        let v = edge[1];\n        adj_list[u].push(v);\n        adj_list[v].push(u);\n    }\n    \n    let mut visited: Vec<bool> = vec![false; n+1];\n    let mut count = 0;\n    \n    for i in 1..=n {\n        if !visited[i] {\n            dfs(i, &mut visited, &adj_list);\n            count += 1;\n        }\n    }\n    \n    if count == 1 && m == n {\n        println!(\"FHTAGN!\");\n    } else {\n        println!(\"NO\");\n    }\n}\n\nfn dfs(node: usize, visited: &mut Vec<bool>, adj_list: &Vec<Vec<usize>>) {\n    visited[node] = true;\n    for &neighbour in &adj_list[node] {\n        if !visited[neighbour] {\n            dfs(neighbour, visited, adj_list);\n        }\n    }\n}"}
{"title":"A. Benches","description":"There are $$$n$$$ benches in the Berland Central park. It is known that $$$a_i$$$ people are currently sitting on the $$$i$$$-th bench. Another $$$m$$$ people are coming to the park and each of them is going to have a seat on some bench out of $$$n$$$ available.Let $$$k$$$ be the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park. Calculate the minimum possible $$$k$$$ and the maximum possible $$$k$$$.Nobody leaves the taken seat during the whole process.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer $$$n$$$ $$$(1 \\\\le n \\\\le 100)$$$ \u2014 the number of benches in the park.\nThe second line contains a single integer $$$m$$$ $$$(1 \\\\le m \\\\le 10\\\\,000)$$$ \u2014 the number of people additionally coming to the park.\nEach of the next $$$n$$$ lines contains a single integer $$$a_i$$$ $$$(1 \\\\le a_i \\\\le 100)$$$ \u2014 the initial number of people on the $$$i$$$-th bench.\n","output_spec":"Print the minimum possible $$$k$$$ and the maximum possible $$$k$$$, where $$$k$$$ is the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park.\n","notes":"In the first example, each of four benches is occupied by a single person. The minimum $$$k$$$ is $$$3$$$. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum $$$k$$$ is $$$7$$$. That requires all six new people to occupy the same bench.\nThe second example has its minimum $$$k$$$ equal to $$$15$$$ and maximum $$$k$$$ equal to $$$15$$$, as there is just a single bench in the park and all $$$10$$$ people will occupy it.\n","sample_inputs":["4\n6\n1\n1\n1\n1\n","1\n10\n5\n","3\n6\n1\n6\n5\n","3\n7\n1\n6\n5\n"],"sample_outputs":["3 7\n","15 15\n","6 12\n","7 13\n"],"id":"1042-A","difficulty":1100,"tags":["binary+search","implementation"],"src_uid":"78f696bd954c9f0f9bb502e515d85a8d","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<int> benches(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> benches[i];\\n    }\\n\\n    int min_k = *min_element(benches.begin(), benches.end());\\n    int max_k = *max_element(benches.begin(), benches.end()) + m;\\n\\n    cout << min_k << \\\" \\\" << max_k << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] benches = new int[n];\n        for (int i = 0; i < n; i++) {\n            benches[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(benches);\n        \n        int minK = (benches[n-1] + m + n - 1) \/ n;\n        int maxK = benches[n-1] + m;\n        \n        System.out.println(minK + \\\" \\\" + maxK);\n    }\n}","Python":"def calculate_k(n, m, benches):\n    min_k = max(benches)\n    max_k = max(benches) + m\n\n    return str(min_k) + ' ' + str(max_k)\n\ninput_data = input().split('\\\\n')\nn = int(input_data[0])\nm = int(input_data[1])\nbenches = [int(x) for x in input_data[2:]]\n\noutput = calculate_k(n, m, benches)\nprint(output)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d\\\", &n);\\n    scanf(\\\"%d\\\", &m);\\n    int a[n];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    int min_k = 0, max_k = 0;\\n    for(int i=0; i<n; i++) {\\n        min_k = (min_k > a[i]) ? min_k : a[i];\\n        max_k += a[i];\\n    }\\n    min_k += m;\\n    int max_additional = m;\\n    for(int i=0; i<n; i++) {\\n        int additional = min_k - a[i];\\n        if(additional > 0) {\\n            max_additional -= additional;\\n        }\\n    }\\n    min_k += (max_additional > 0) ? (max_additional + n - 1) \/ n : 0;\\n    printf(\\\"%d %d\\\\n\\\", min_k, max_k + m);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace BenchProblem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read input\n            int n = int.Parse(Console.ReadLine());\n            int m = int.Parse(Console.ReadLine());\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = int.Parse(Console.ReadLine());\n            }\n\n            \/\/ Calculate minimum and maximum k\n            int minK = int.MaxValue;\n            int maxK = int.MinValue;\n            for (int i = 0; i < n; i++)\n            {\n                int additionalPeople = Math.Min(m, a[i] - 1);\n                int k = a[i] + additionalPeople;\n                minK = Math.Min(minK, k);\n                maxK = Math.Max(maxK, k);\n                m -= additionalPeople;\n            }\n            maxK += m \/ n;\n            if (m % n != 0)\n            {\n                maxK++;\n            }\n\n            \/\/ Print output\n            Console.WriteLine(minK + \" \" + maxK);\n        }\n    }\n}\n","Ruby":"\ndef calculate_k(n, m, benches)\n  min_k = (benches.max + m).to_f \/ n\n  max_k = benches.max + m\n  return min_k.ceil, max_k\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nm = input[1].to_i\nbenches = []\nfor i in 2..n+1\n  benches << input[i].to_i\nend\n\nmin_k, max_k = calculate_k(n, m, benches)\nputs \\\"#{min_k} #{max_k}\\\"\n","delphi":"program BerlandCentralPark;\\n\\nvar\\n  n, m, i, minK, maxK, maxPeople, totalPeople: integer;\\n  a: array[1..100] of integer;\\nbegin\\n  readln(n);\\n  readln(m);\\n  for i := 1 to n do\\n    readln(a[i]);\\n  minK := 100;\\n  maxK := 0;\\n  totalPeople := 0;\\n  for i := 1 to n do\\n  begin\\n    if a[i] < minK then\\n      minK := a[i];\\n    if a[i] > maxK then\\n      maxK := a[i];\\n    totalPeople := totalPeople + a[i];\\n  end;\\n  maxPeople := maxK + m;\\n  if maxPeople > totalPeople + m then\\n    maxPeople := totalPeople + m;\\n  writeln(minK + (m + n - 1) div n, ' ', maxPeople);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\tscanner.Scan()\\n\\tm, _ := strconv.Atoi(scanner.Text())\\n\\n\\tmin := 101\\n\\tmax := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\ta, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\\tif a < min {\\n\\t\\t\\tmin = a\\n\\t\\t}\\n\\n\\t\\tif a > max {\\n\\t\\t\\tmax = a\\n\\t\\t}\\n\\t}\\n\\n\\tmin += m\\n\\n\\tif min > max {\\n\\t\\tmax = min\\n\\t}\\n\\n\\tfmt.Printf(\\\"%d %d\\\\n\\\", min, max)\\n}","Javascript":"function calculateK(n, m, benches) {\n    let minK = Math.max(...benches);\n    let maxK = Math.max(...benches) + m;\n\n    let remainingSeats = m;\n    for (let i = 0; i < n; i++) {\n        let availableSeats = Math.max(0, minK - benches[i]);\n        remainingSeats -= availableSeats;\n        minK += availableSeats;\n    }\n\n    minK += Math.ceil(remainingSeats \/ n);\n\n    return minK + ' ' + maxK;\n}\n\n\/\/ Read input\nconst input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\nconst n = parseInt(input[0]);\nconst m = parseInt(input[1]);\nconst benches = input.slice(2).map(Number);\n\n\/\/ Calculate and print the minimum and maximum k\nconsole.log(calculateK(n, m, benches));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n    val benches = IntArray(n)\n    for (i in 0 until n) {\n        benches[i] = scanner.nextInt()\n    }\n    \n    val minK = (benches.sum() + m) \/ n + if ((benches.sum() + m) % n != 0) 1 else 0\n    val maxK = benches.max()!! + m\n    \n    println(\\\"$minK $maxK\\\")\n}","PHP":"\n<?php\n\nfunction calculateK($n, $m, $a) {\n    \/\/ Sort the initial number of people on each bench in ascending order\n    sort($a);\n    \n    \/\/ Calculate the minimum possible k\n    $minK = $a[0] + ceil($m \/ $n);\n    \n    \/\/ Calculate the maximum possible k\n    $maxK = $a[$n-1] + $m;\n    \n    return $minK . ' ' . $maxK;\n}\n\n\/\/ Read input from stdin\n$input = explode('\\n', trim(fgets(STDIN)));\n\n$n = intval($input[0]);\n$m = intval($input[1]);\n\n$a = array();\nfor ($i = 2; $i < $n+2; $i++) {\n    $a[] = intval($input[$i]);\n}\n\n\/\/ Calculate and print the minimum and maximum possible k\necho calculateK($n, $m, $a);\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    int[] a;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d\\\", &n);\\r\\n    scanf(\\\"%d\\\", &m);\\r\\n\\r\\n    a = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate minimum and maximum k\\r\\n    int minK = max(a) + m;\\r\\n    int maxK = max(a) + m;\\r\\n\\r\\n    writeln(minK, \\\" \\\", maxK);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_k {\n    my ($n, $m, @a) = @_;\n\n    my $min_k = 0;\n    my $max_k = 0;\n\n    # Calculate the minimum possible k\n    my @sorted_benches = sort { $a <=> $b } @a;\n    for my $i (0..$m-1) {\n        $sorted_benches[$i % $n]++;\n    }\n    $min_k = $sorted_benches[-1];\n\n    # Calculate the maximum possible k\n    my $max_additional_people = $m - $n;\n    my $max_additional_people_per_bench = int($max_additional_people \/ $n);\n    my $remaining_additional_people = $max_additional_people % $n;\n    my $max_additional_people_on_bench = $sorted_benches[-1] + $max_additional_people_per_bench;\n    my $max_additional_people_on_remaining_bench = $sorted_benches[-1] + $max_additional_people_per_bench + 1;\n\n    $max_k = $max_additional_people_on_bench * ($n - $remaining_additional_people) + $max_additional_people_on_remaining_bench * $remaining_additional_people;\n\n    return \"$min_k $max_k\";\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\nmy @a;\nfor (1..$n) {\n    my $bench = <STDIN>;\n    chomp $bench;\n    push @a, $bench;\n}\n\n# Calculate k\nmy $result = calculate_k($n, $m, @a);\n\n# Print output\nprint \"$result\\n\";\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: usize = input.trim().parse().unwrap();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let m: usize = input.trim().parse().unwrap();\n\n    let mut benches = Vec::new();\n    for _ in 0..n {\n        input.clear();\n        std::io::stdin().read_line(&mut input).unwrap();\n        let a: usize = input.trim().parse().unwrap();\n        benches.push(a);\n    }\n\n    let min_k = (benches.iter().sum::<usize>() + m) \/ n;\n    let max_k = benches.iter().max().unwrap() + m;\n\n    println!(\\\"{} {}\\\", min_k, max_k);\n}"}
{"title":"E. Lift and Throw","description":"You are given a straight half-line divided into segments of unit length, which we will call positions. The positions are numbered by positive integers that start with 1 from the end of half-line, i. e. 1, 2, 3 and so on. The distance between the positions is the absolute difference between the respective numbers. Laharl, Etna and Flonne occupy some positions on the half-line and they want to get to the position with the largest possible number. They are originally placed in different positions. Each of the characters can perform each of the following actions no more than once:   Move a certain distance.  Grab another character and lift him above the head.  Throw the lifted character a certain distance.  Each character has a movement range parameter. They can only move to free positions, assuming that distance between those positions doesn't exceed the movement range. One character can lift another character if the distance between the two characters equals 1, and no one already holds that another character. We can assume that the lifted character moves to the same position as the person who has lifted him, and the position in which he stood before becomes free. A lifted character cannot perform any actions and the character that holds him cannot walk. Also, each character has a throwing range parameter. It is the distance at which this character can throw the one lifted above his head. He can only throw a character to a free position, and only when there is a lifted character. We accept the situation when one person grabs another one who in his turn has the third character in his hands. This forms a \"column\" of three characters. For example, Laharl can hold Etna while Etna holds Flonne. In this case, Etna and the Flonne cannot perform any actions, and Laharl can only throw Etna (together with Flonne) at some distance. Laharl, Etna and Flonne perform actions in any order. They perform actions in turns, that is no two of them can do actions at the same time.Determine the maximum number of position at least one of the characters can reach. That is, such maximal number x so that one of the characters can reach position x.","input_from":"standard input","output_to":"standard output","time_limit":"1.5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three integers: Laharl's position, his movement range and throwing range. The second and the third lines describe Etna's and Flonne's parameters correspondingly in the similar form. It is guaranteed that the three characters occupy distinct positions. All numbers in the input are between 1 and 10, inclusive.\n","output_spec":"Print a single number \u2014 the maximum ordinal number of position which either Laharl, Etna or Flonne can reach.\n","notes":"Let us explain how to reach position 15 in the sample.\nInitially Laharl occupies position 9, Etna \u2014 position 4 and Flonne \u2014 position 2.\nFirst Laharl moves to position 6.\nThen Flonne moves to position 5 and grabs Etna.\nLaharl grabs Flonne and throws to position 9.\nFlonne throws Etna to position 12.\nEtna moves to position 15.\n","sample_inputs":["9 3 3\n4 3 1\n2 3 3\n"],"sample_outputs":["15"],"id":"105-E","difficulty":2500,"tags":["brute+force"],"src_uid":"a14739b86d1fd62a030226263cdc1afc","C++":"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    \/\/ Read input\n    int laharlPos, laharlMoveRange, laharlThrowRange;\n    int etnaPos, etnaMoveRange, etnaThrowRange;\n    int flonnePos, flonneMoveRange, flonneThrowRange;\n    cin >> laharlPos >> laharlMoveRange >> laharlThrowRange;\n    cin >> etnaPos >> etnaMoveRange >> etnaThrowRange;\n    cin >> flonnePos >> flonneMoveRange >> flonneThrowRange;\n\n    \/\/ Calculate the maximum reachable position\n    int maxPos = max(laharlPos, max(etnaPos, flonnePos));\n    for (int i = 1; i <= maxPos; i++) {\n        \/\/ Check if Laharl can reach position i\n        if (i >= laharlPos - laharlMoveRange && i <= laharlPos + laharlMoveRange) {\n            maxPos = max(maxPos, i);\n        }\n        \/\/ Check if Etna can reach position i\n        if (i >= etnaPos - etnaMoveRange && i <= etnaPos + etnaMoveRange) {\n            maxPos = max(maxPos, i);\n        }\n        \/\/ Check if Flonne can reach position i\n        if (i >= flonnePos - flonneMoveRange && i <= flonnePos + flonneMoveRange) {\n            maxPos = max(maxPos, i);\n        }\n    }\n\n    \/\/ Print the result\n    cout << maxPos << endl;\n\n    return 0;\n}\n","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read Laharl's parameters\n        String[] laharlParams = scanner.nextLine().split(\\\" \\\");\n        int laharlPosition = Integer.parseInt(laharlParams[0]);\n        int laharlMovementRange = Integer.parseInt(laharlParams[1]);\n        int laharlThrowingRange = Integer.parseInt(laharlParams[2]);\n        \n        \/\/ Read Etna's parameters\n        String[] etnaParams = scanner.nextLine().split(\\\" \\\");\n        int etnaPosition = Integer.parseInt(etnaParams[0]);\n        int etnaMovementRange = Integer.parseInt(etnaParams[1]);\n        int etnaThrowingRange = Integer.parseInt(etnaParams[2]);\n        \n        \/\/ Read Flonne's parameters\n        String[] flonneParams = scanner.nextLine().split(\\\" \\\");\n        int flonnePosition = Integer.parseInt(flonneParams[0]);\n        int flonneMovementRange = Integer.parseInt(flonneParams[1]);\n        int flonneThrowingRange = Integer.parseInt(flonneParams[2]);\n        \n        \/\/ Calculate the maximum ordinal number of position\n        int maxPosition = Math.max(laharlPosition, Math.max(etnaPosition, flonnePosition));\n        \n        \/\/ Iterate through all possible positions\n        for (int i = 1; i <= 10; i++) {\n            \/\/ Check if Laharl can reach the position\n            if (Math.abs(i - laharlPosition) <= laharlMovementRange) {\n                maxPosition = Math.max(maxPosition, i);\n            }\n            \n            \/\/ Check if Etna can reach the position\n            if (Math.abs(i - etnaPosition) <= etnaMovementRange) {\n                maxPosition = Math.max(maxPosition, i);\n            }\n            \n            \/\/ Check if Flonne can reach the position\n            if (Math.abs(i - flonnePosition) <= flonneMovementRange) {\n                maxPosition = Math.max(maxPosition, i);\n            }\n            \n            \/\/ Check if Laharl can throw Etna to the position\n            if (Math.abs(i - laharlPosition) == 1 && Math.abs(i - etnaPosition) <= laharlThrowingRange) {\n                maxPosition = Math.max(maxPosition, i);\n            }\n            \n            \/\/ Check if Laharl can throw Flonne to the position\n            if (Math.abs(i - laharlPosition) == 1 && Math.abs(i - flonnePosition) <= laharlThrowingRange) {\n                maxPosition = Math.max(maxPosition, i);\n            }\n            \n            \/\/ Check if Etna can throw Flonne to the position\n            if (Math.abs(i - etnaPosition) == 1 && Math.abs(i - flonnePosition) <= etnaThrowingRange) {\n                maxPosition = Math.max(maxPosition, i);\n            }\n        }\n        \n        \/\/ Print the maximum ordinal number of position\n        System.out.println(maxPosition);\n    }\n}","Python":"def max_reachable_position(laharl, etna, flonne):\\n    # Get the positions, movement range, and throwing range for each character\\n    lah_position, lah_movement, lah_throwing = laharl\\n    etn_position, etn_movement, etn_throwing = etna\\n    flo_position, flo_movement, flo_throwing = flonne\\n\\n    # Initialize a set to store all reachable positions\\n    reachable_positions = set()\\n\\n    # Add the initial positions of the characters to the set\\n    reachable_positions.add(lah_position)\\n    reachable_positions.add(etn_position)\\n    reachable_positions.add(flo_position)\\n\\n    # Iterate through all possible combinations of actions\\n    for i in range(2):\\n        for j in range(2):\\n            for k in range(2):\\n                # Check if Laharl can move\\n                if i == 1:\\n                    for move in range(1, lah_movement + 1):\\n                        new_position = lah_position - move\\n                        if new_position not in reachable_positions:\\n                            reachable_positions.add(new_position)\\n                # Check if Etna can move\\n                if j == 1:\\n                    for move in range(1, etn_movement + 1):\\n                        new_position = etn_position - move\\n                        if new_position not in reachable_positions:\\n                            reachable_positions.add(new_position)\\n                # Check if Flonne can move\\n                if k == 1:\\n                    for move in range(1, flo_movement + 1):\\n                        new_position = flo_position - move\\n                        if new_position not in reachable_positions:\\n                            reachable_positions.add(new_position)\\n                # Check if Laharl can grab Etna\\n                if i == 1 and abs(lah_position - etn_position) == 1:\\n                    # Check if Etna can grab Flonne\\n                    if j == 1 and abs(etn_position - flo_position) == 1:\\n                        # Calculate the position after throwing\\n                        throw_position = flo_position - lah_throwing\\n                        # Check if the throw position is valid\\n                        if throw_position not in reachable_positions:\\n                            reachable_positions.add(throw_position)\\n\\n    # Return the maximum reachable position\\n    return max(reachable_positions)\\n\\n\\n# Read the input\\nlaharl = list(map(int, input().split()))\\netna = list(map(int, input().split()))\\nflonne = list(map(int, input().split()))\\n\\n# Call the function and print the result\\nprint(max_reachable_position(laharl, etna, flonne))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\n\\nint main() {\\n    int laharl_pos, laharl_move, laharl_throw;\\n    int etna_pos, etna_move, etna_throw;\\n    int flonne_pos, flonne_move, flonne_throw;\\n\\n    \/\/ Read input\\n    scanf(\\\"%d %d %d\\\", &laharl_pos, &laharl_move, &laharl_throw);\\n    scanf(\\\"%d %d %d\\\", &etna_pos, &etna_move, &etna_throw);\\n    scanf(\\\"%d %d %d\\\", &flonne_pos, &flonne_move, &flonne_throw);\\n\\n    \/\/ Calculate maximum reachable position\\n    int max_pos = 0;\\n    max_pos = max(max_pos, laharl_pos + laharl_move);\\n    max_pos = max(max_pos, etna_pos + etna_move);\\n    max_pos = max(max_pos, flonne_pos + flonne_move);\\n    max_pos = max(max_pos, laharl_pos + laharl_throw);\\n    max_pos = max(max_pos, etna_pos + etna_throw);\\n    max_pos = max(max_pos, flonne_pos + flonne_throw);\\n\\n    \/\/ Print output\\n    printf(\\\"%d\\\\n\\\", max_pos);\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace MaximumPosition\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read input\n            string[] input = Console.ReadLine().Split();\n            int laharlPosition = int.Parse(input[0]);\n            int laharlMovementRange = int.Parse(input[1]);\n            int laharlThrowingRange = int.Parse(input[2]);\n\n            input = Console.ReadLine().Split();\n            int etnaPosition = int.Parse(input[0]);\n            int etnaMovementRange = int.Parse(input[1]);\n            int etnaThrowingRange = int.Parse(input[2]);\n\n            input = Console.ReadLine().Split();\n            int flonnePosition = int.Parse(input[0]);\n            int flonneMovementRange = int.Parse(input[1]);\n            int flonneThrowingRange = int.Parse(input[2]);\n\n            \/\/ Calculate maximum position\n            int maxPosition = Math.Max(laharlPosition, Math.Max(etnaPosition, flonnePosition));\n\n            \/\/ Generate all possible actions\n            List<Action> actions = new List<Action>();\n\n            \/\/ Generate all possible movements for Laharl\n            for (int i = 1; i <= laharlMovementRange; i++)\n            {\n                if (laharlPosition - i > 0)\n                {\n                    actions.Add(new Action(ActionType.Move, Character.Laharl, i));\n                }\n            }\n\n            \/\/ Generate all possible movements for Etna\n            for (int i = 1; i <= etnaMovementRange; i++)\n            {\n                if (etnaPosition - i > 0)\n                {\n                    actions.Add(new Action(ActionType.Move, Character.Etna, i));\n                }\n            }\n\n            \/\/ Generate all possible movements for Flonne\n            for (int i = 1; i <= flonneMovementRange; i++)\n            {\n                if (flonnePosition - i > 0)\n                {\n                    actions.Add(new Action(ActionType.Move, Character.Flonne, i));\n                }\n            }\n\n            \/\/ Generate all possible lifts and throws\n            for (int i = 0; i < actions.Count; i++)\n            {\n                if (actions[i].Type == ActionType.Move)\n                {\n                    if (actions[i].Character == Character.Laharl)\n                    {\n                        for (int j = 1; j <= laharlThrowingRange; j++)\n                        {\n                            if (etnaPosition - j > 0)\n                            {\n                                actions.Add(new Action(ActionType.Throw, Character.Laharl, j));\n                            }\n                        }\n                    }\n                    else if (actions[i].Character == Character.Etna)\n                    {\n                        for (int j = 1; j <= etnaThrowingRange; j++)\n                        {\n                            if (flonnePosition - j > 0)\n                            {\n                                actions.Add(new Action(ActionType.Throw, Character.Etna, j));\n                            }\n                        }\n                    }\n                }\n            }\n\n            \/\/ Perform all possible actions and update maxPosition\n            foreach (Action action in actions)\n            {\n                switch (action.Type)\n                {\n                    case ActionType.Move:\n                        switch (action.Character)\n                        {\n                            case Character.Laharl:\n                                laharlPosition -= action.Distance;\n                                break;\n                            case Character.Etna:\n                                etnaPosition -= action.Distance;\n                                break;\n                            case Character.Flonne:\n                                flonnePosition -= action.Distance;\n                                break;\n                        }\n                        break;\n                    case ActionType.Throw:\n                        switch (action.Character)\n                        {\n                            case Character.Laharl:\n                                etnaPosition -= action.Distance;\n                                flonnePosition -= action.Distance;\n                                break;\n                            case Character.Etna:\n                                flonnePosition -= action.Distance;\n                                break;\n                        }\n                        break;\n                }\n\n                maxPosition = Math.Max(maxPosition, Math.Max(laharlPosition, Math.Max(etnaPosition, flonnePosition)));\n            }\n\n            \/\/ Print the maximum position\n            Console.WriteLine(maxPosition);\n        }\n    }\n\n    enum Character\n    {\n        Laharl,\n        Etna,\n        Flonne\n    }\n\n    enum ActionType\n    {\n        Move,\n        Throw\n    }\n\n    class Action\n    {\n        public ActionType Type { get; }\n        public Character Character { get; }\n        public int Distance { get; }\n\n        public Action(ActionType type, Character character, int distance)\n        {\n            Type = type;\n            Character = character;\n            Distance = distance;\n        }\n    }\n}\n","Ruby":"\n# Function to calculate the maximum ordinal number of position\ndef calculate_max_position(laharl_pos, laharl_move_range, laharl_throw_range, etna_pos, etna_move_range, etna_throw_range, flonne_pos, flonne_move_range, flonne_throw_range)\n    max_position = 0\n\n    # Loop through all possible positions\n    (1..10).each do |position|\n        # Check if Laharl can reach the position\n        if (position - laharl_pos).abs <= laharl_move_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Etna can reach the position\n        if (position - etna_pos).abs <= etna_move_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Flonne can reach the position\n        if (position - flonne_pos).abs <= flonne_move_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Laharl can throw Etna to reach the position\n        if (position - etna_pos).abs <= laharl_throw_range && (position - flonne_pos).abs <= laharl_throw_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Laharl can throw Flonne to reach the position\n        if (position - flonne_pos).abs <= laharl_throw_range && (position - etna_pos).abs <= laharl_throw_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Etna can throw Flonne to reach the position\n        if (position - flonne_pos).abs <= etna_throw_range && (position - laharl_pos).abs <= etna_throw_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Etna can throw Laharl to reach the position\n        if (position - laharl_pos).abs <= etna_throw_range && (position - flonne_pos).abs <= etna_throw_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Flonne can throw Laharl to reach the position\n        if (position - laharl_pos).abs <= flonne_throw_range && (position - etna_pos).abs <= flonne_throw_range\n            max_position = [max_position, position].max\n        end\n\n        # Check if Flonne can throw Etna to reach the position\n        if (position - etna_pos).abs <= flonne_throw_range && (position - laharl_pos).abs <= flonne_throw_range\n            max_position = [max_position, position].max\n        end\n    end\n\n    return max_position\nend\n\n# Parse the input\ninput = gets.chomp.split('\\n')\nlaharl_params = input[0].split(' ').map(&:to_i)\netna_params = input[1].split(' ').map(&:to_i)\nflonne_params = input[2].split(' ').map(&:to_i)\n\n# Call the function to calculate the maximum position\nmax_position = calculate_max_position(laharl_params[0], laharl_params[1], laharl_params[2], etna_params[0], etna_params[1], etna_params[2], flonne_params[0], flonne_params[1], flonne_params[2])\n\n# Print the result\nputs max_position\n","delphi":"program MaxPosition;\n\nvar\n  LaharlPos, LaharlMoveRange, LaharlThrowRange: Integer;\n  EtnaPos, EtnaMoveRange, EtnaThrowRange: Integer;\n  FlonnePos, FlonneMoveRange, FlonneThrowRange: Integer;\n  maxPos: Integer;\n\nprocedure UpdateMaxPos(pos: Integer);\nbegin\n  if pos > maxPos then\n    maxPos := pos;\nend;\n\nprocedure MoveCharacter(var characterPos, moveRange: Integer);\nvar\n  newPos: Integer;\nbegin\n  for newPos := characterPos - moveRange to characterPos + moveRange do\n  begin\n    if (newPos <> characterPos) and (newPos > 0) then\n      UpdateMaxPos(newPos);\n  end;\nend;\n\nprocedure ThrowCharacter(var throwerPos, throwRange, throweePos: Integer);\nvar\n  newPos: Integer;\nbegin\n  for newPos := throweePos - throwRange to throweePos + throwRange do\n  begin\n    if (newPos <> throweePos) and (newPos > 0) and (newPos <> throwerPos) then\n      UpdateMaxPos(newPos);\n  end;\nend;\n\nbegin\n  \/\/ Read input\n  ReadLn(LaharlPos, LaharlMoveRange, LaharlThrowRange);\n  ReadLn(EtnaPos, EtnaMoveRange, EtnaThrowRange);\n  ReadLn(FlonnePos, FlonneMoveRange, FlonneThrowRange);\n\n  \/\/ Initialize max position\n  maxPos := 0;\n\n  \/\/ Calculate maximum reachable position for each character\n  MoveCharacter(LaharlPos, LaharlMoveRange);\n  MoveCharacter(EtnaPos, EtnaMoveRange);\n  MoveCharacter(FlonnePos, FlonneMoveRange);\n\n  ThrowCharacter(LaharlPos, LaharlThrowRange, EtnaPos);\n  ThrowCharacter(LaharlPos, LaharlThrowRange, FlonnePos);\n  ThrowCharacter(EtnaPos, EtnaThrowRange, FlonnePos);\n\n  \/\/ Print the maximum reachable position\n  WriteLn(maxPos);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar lahPos, lahMove, lahThrow int\\n\\tvar etnaPos, etnaMove, etnaThrow int\\n\\tvar flonnePos, flonneMove, flonneThrow int\\n\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &lahPos, &lahMove, &lahThrow)\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &etnaPos, &etnaMove, &etnaThrow)\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &flonnePos, &flonneMove, &flonneThrow)\\n\\n\\tpositions := make([]bool, 11)\\n\\n\\t\/\/ Mark occupied positions\\n\\tpositions[lahPos] = true\\n\\tpositions[etnaPos] = true\\n\\tpositions[flonnePos] = true\\n\\n\\t\/\/ Calculate maximum reachable position\\n\\tmaxPos := max(lahPos+lahMove, etnaPos+etnaMove, flonnePos+flonneMove)\\n\\n\\t\/\/ Check if any character can grab and throw another character\\n\\tif abs(lahPos-etnaPos) == 1 && abs(etnaPos-flonnePos) == 1 {\\n\\t\\tmaxPos = max(maxPos, lahPos+lahMove+lahThrow+etnaMove+etnaThrow+flonneMove)\\n\\t}\\n\\n\\tif abs(etnaPos-lahPos) == 1 && abs(lahPos-flonnePos) == 1 {\\n\\t\\tmaxPos = max(maxPos, etnaPos+etnaMove+etnaThrow+lahMove+lahThrow+flonneMove)\\n\\t}\\n\\n\\tif abs(flonnePos-lahPos) == 1 && abs(lahPos-etnaPos) == 1 {\\n\\t\\tmaxPos = max(maxPos, flonnePos+flonneMove+etnaMove+etnaThrow+lahMove+lahThrow)\\n\\t}\\n\\n\\t\/\/ Print the maximum reachable position\\n\\tfmt.Println(maxPos)\\n}\\n\\nfunc max(a, b, c int) int {\\n\\tif a > b {\\n\\t\\tif a > c {\\n\\t\\t\\treturn a\\n\\t\\t}\\n\\t\\treturn c\\n\\t}\\n\\tif b > c {\\n\\t\\treturn b\\n\\t}\\n\\treturn c\\n}\\n\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}","Javascript":"function calculateMaxPosition(input) {\n  const [laharlPos, laharlMoveRange, laharlThrowRange] = input[0].split(' ').map(Number);\n  const [etnaPos, etnaMoveRange, etnaThrowRange] = input[1].split(' ').map(Number);\n  const [flonnePos, flonneMoveRange, flonneThrowRange] = input[2].split(' ').map(Number);\n\n  let maxPosition = Math.max(laharlPos, etnaPos, flonnePos);\n\n  \/\/ Check if Laharl can reach a higher position\n  for (let i = 1; i <= laharlMoveRange; i++) {\n    if (laharlPos + i > maxPosition) {\n      maxPosition = laharlPos + i;\n    }\n  }\n\n  \/\/ Check if Etna can reach a higher position\n  for (let i = 1; i <= etnaMoveRange; i++) {\n    if (etnaPos + i > maxPosition) {\n      maxPosition = etnaPos + i;\n    }\n  }\n\n  \/\/ Check if Flonne can reach a higher position\n  for (let i = 1; i <= flonneMoveRange; i++) {\n    if (flonnePos + i > maxPosition) {\n      maxPosition = flonnePos + i;\n    }\n  }\n\n  return maxPosition.toString();\n}\n\nconst input = ['9 3 3\\n4 3 1\\n2 3 3\\n'];\nconst output = calculateMaxPosition(input);\nconsole.log(output);","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val laharl = Character(input[0], input[1], input[2])\\n\\n    val input2 = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val etna = Character(input2[0], input2[1], input2[2])\\n\\n    val input3 = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val flonne = Character(input3[0], input3[1], input3[2])\\n\\n    val maxPosition = getMaxPosition(laharl, etna, flonne)\\n    println(maxPosition)\\n}\\n\\nfun getMaxPosition(laharl: Character, etna: Character, flonne: Character): Int {\\n    var maxPosition = 0\\n\\n    for (i in 1..10) {\\n        if (laharl.canReachPosition(i) || etna.canReachPosition(i) || flonne.canReachPosition(i)) {\\n            maxPosition = i\\n        }\\n    }\\n\\n    return maxPosition\\n}\\n\\nclass Character(var position: Int, val movementRange: Int, val throwingRange: Int) {\\n    fun canReachPosition(targetPosition: Int): Boolean {\\n        if (abs(targetPosition - position) <= movementRange) {\\n            return true\\n        }\\n\\n        if (abs(targetPosition - position) == 1 && throwingRange >= 1) {\\n            return true\\n        }\\n\\n        return false\\n    }\\n}","PHP":"<?php\\n\\nfunction getMaxPosition($laharl, $etna, $flonne) {\\n    $maxPosition = max($laharl[0], $etna[0], $flonne[0]);\\n\\n    \/\/ Check if Laharl can reach a higher position\\n    if ($laharl[0] + $laharl[1] >= $maxPosition) {\\n        $maxPosition = $laharl[0] + $laharl[1];\\n    }\\n\\n    \/\/ Check if Etna can reach a higher position\\n    if ($etna[0] + $etna[1] >= $maxPosition) {\\n        $maxPosition = $etna[0] + $etna[1];\\n    }\\n\\n    \/\/ Check if Flonne can reach a higher position\\n    if ($flonne[0] + $flonne[1] >= $maxPosition) {\\n        $maxPosition = $flonne[0] + $flonne[1];\\n    }\\n\\n    return $maxPosition;\\n}\\n\\n\/\/ Input\\n$input = \\\"9 3 3\\\\n4 3 1\\\\n2 3 3\\\";\\nlist($laharlPos, $laharlMoveRange, $laharlThrowRange) = explode(\\\" \\\", $input);\\nlist($etnaPos, $etnaMoveRange, $etnaThrowRange) = explode(\\\" \\\", $input);\\nlist($flonnePos, $flonneMoveRange, $flonneThrowRange) = explode(\\\" \\\", $input);\\n\\n$laharl = [$laharlPos, $laharlMoveRange, $laharlThrowRange];\\n$etna = [$etnaPos, $etnaMoveRange, $etnaThrowRange];\\n$flonne = [$flonnePos, $flonneMoveRange, $flonneThrowRange];\\n\\n\/\/ Get the maximum position\\n$maxPosition = getMaxPosition($laharl, $etna, $flonne);\\n\\n\/\/ Output\\n$output = $maxPosition;\\necho $output;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstruct Character {\\r\\n    int position;\\r\\n    int movementRange;\\r\\n    int throwingRange;\\r\\n    bool isHolding;\\r\\n    int heldCharacterPosition;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    \/\/ Read input\\r\\n    int[] positions;\\r\\n    int[] movementRanges;\\r\\n    int[] throwingRanges;\\r\\n    foreach (i; 0..3) {\\r\\n        int position, movementRange, throwingRange;\\r\\n        readf(\\\"%d %d %d\\\\n\\\", &position, &movementRange, &throwingRange);\\r\\n        positions ~= position;\\r\\n        movementRanges ~= movementRange;\\r\\n        throwingRanges ~= throwingRange;\\r\\n    }\\r\\n\\r\\n    \/\/ Initialize characters\\r\\n    Character[] characters;\\r\\n    foreach (i; 0..3) {\\r\\n        characters ~= Character(positions[i], movementRanges[i], throwingRanges[i], false, -1);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate maximum reachable position\\r\\n    int maxPosition = 0;\\r\\n    foreach (i; 0..3) {\\r\\n        int currentPosition = characters[i].position;\\r\\n\\r\\n        \/\/ Move character to the left\\r\\n        for (int j = 1; j <= characters[i].movementRange; j++) {\\r\\n            int newPosition = currentPosition - j;\\r\\n            if (newPosition > maxPosition && !characters.any!(c => c.position == newPosition)) {\\r\\n                maxPosition = newPosition;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \/\/ Move character to the right\\r\\n        for (int j = 1; j <= characters[i].movementRange; j++) {\\r\\n            int newPosition = currentPosition + j;\\r\\n            if (newPosition > maxPosition && !characters.any!(c => c.position == newPosition)) {\\r\\n                maxPosition = newPosition;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \/\/ Throw character\\r\\n        if (characters[i].isHolding) {\\r\\n            int heldCharacterPosition = characters[i].heldCharacterPosition;\\r\\n\\r\\n            \/\/ Throw character to the left\\r\\n            for (int j = 1; j <= characters[i].throwingRange; j++) {\\r\\n                int newPosition = heldCharacterPosition - j;\\r\\n                if (newPosition > maxPosition && !characters.any!(c => c.position == newPosition)) {\\r\\n                    maxPosition = newPosition;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            \/\/ Throw character to the right\\r\\n            for (int j = 1; j <= characters[i].throwingRange; j++) {\\r\\n                int newPosition = heldCharacterPosition + j;\\r\\n                if (newPosition > maxPosition && !characters.any!(c => c.position == newPosition)) {\\r\\n                    maxPosition = newPosition;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the maximum reachable position\\r\\n    writeln(maxPosition);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\n# Read input\nmy @input = split('\\n', <STDIN>);\nmy @laharl = split(' ', $input[0]);\nmy @etna = split(' ', $input[1]);\nmy @flonne = split(' ', $input[2]);\n\n# Initialize positions\nmy %positions;\n$positions{$laharl[0]} = 1;\n$positions{$etna[0]} = 1;\n$positions{$flonne[0]} = 1;\n\n# Initialize maximum position\nmy $max_position = max($laharl[0], $etna[0], $flonne[0]);\n\n# Perform actions\nfor (my $i = 0; $i < 3; $i++) {\n    if ($i == 0) {\n        move_character(\\@laharl, \\%positions, \\$max_position);\n    } elsif ($i == 1) {\n        move_character(\\@etna, \\%positions, \\$max_position);\n    } else {\n        move_character(\\@flonne, \\%positions, \\$max_position);\n    }\n}\n\n# Print maximum position\nprint $max_position;\n\n# Move character\nsub move_character {\n    my ($character, $positions, $max_position) = @_;\n    my $current_position = $character->[0];\n    my $movement_range = $character->[1];\n    my $throwing_range = $character->[2];\n    \n    # Move to the right\n    for (my $i = 1; $i <= $movement_range; $i++) {\n        my $new_position = $current_position + $i;\n        if (!exists $positions->{$new_position}) {\n            $positions->{$new_position} = 1;\n            $max_position = max($max_position, $new_position);\n            $current_position = $new_position;\n            last;\n        }\n    }\n    \n    # Move to the left\n    for (my $i = 1; $i <= $movement_range; $i++) {\n        my $new_position = $current_position - $i;\n        if (!exists $positions->{$new_position}) {\n            $positions->{$new_position} = 1;\n            $max_position = max($max_position, $new_position);\n            $current_position = $new_position;\n            last;\n        }\n    }\n    \n    # Grab and throw\n    for (my $i = 1; $i <= $throwing_range; $i++) {\n        my $new_position = $current_position + $i;\n        if (exists $positions->{$new_position}) {\n            delete $positions->{$new_position};\n            $max_position = max($max_position, $new_position);\n            last;\n        }\n    }\n}\n\n# Find maximum of two numbers\nsub max {\n    my ($a, $b) = @_;\n    return $a > $b ? $a : $b;\n}\n","Rust":"fn main() {\\n    let input = String::from(\\\"9 3 3\\\\n4 3 1\\\\n2 3 3\\\\n\\\");\\n    let mut lines = input.lines();\\n\\n    let laharl_params: Vec<i32> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let etna_params: Vec<i32> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let flonne_params: Vec<i32> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let max_position = calculate_max_position(laharl_params, etna_params, flonne_params);\\n\\n    println!(\\\"{}\\\", max_position);\\n}\\n\\nfn calculate_max_position(laharl_params: Vec<i32>, etna_params: Vec<i32>, flonne_params: Vec<i32>) -> i32 {\\n    let laharl_position = laharl_params[0];\\n    let laharl_movement_range = laharl_params[1];\\n    let laharl_throwing_range = laharl_params[2];\\n\\n    let etna_position = etna_params[0];\\n    let etna_movement_range = etna_params[1];\\n    let etna_throwing_range = etna_params[2];\\n\\n    let flonne_position = flonne_params[0];\\n    let flonne_movement_range = flonne_params[1];\\n    let flonne_throwing_range = flonne_params[2];\\n\\n    let mut max_position = 0;\\n\\n    \/\/ Calculate the maximum position for each character\\n    for i in 1..=10 {\\n        let laharl_max = calculate_character_max_position(laharl_position, laharl_movement_range, laharl_throwing_range, i);\\n        let etna_max = calculate_character_max_position(etna_position, etna_movement_range, etna_throwing_range, i);\\n        let flonne_max = calculate_character_max_position(flonne_position, flonne_movement_range, flonne_throwing_range, i);\\n\\n        \/\/ Update the maximum position if any character can reach a higher position\\n        max_position = max_position.max(laharl_max).max(etna_max).max(flonne_max);\\n    }\\n\\n    max_position\\n}\\n\\nfn calculate_character_max_position(position: i32, movement_range: i32, throwing_range: i32, target_position: i32) -> i32 {\\n    let mut max_position = position;\\n\\n    \/\/ Calculate the maximum position the character can reach by moving\\n    for i in 1..=movement_range {\\n        let new_position = position - i;\\n        if new_position >= 1 {\\n            max_position = max_position.max(new_position);\\n        }\\n    }\\n\\n    \/\/ Calculate the maximum position the character can reach by throwing\\n    for i in 1..=throwing_range {\\n        let new_position = position + i;\\n        if new_position <= target_position {\\n            max_position = max_position.max(new_position);\\n        }\\n    }\\n\\n    max_position\\n}"}
{"title":"C. Buns","description":"Lavrenty, a baker, is going to make several buns with stuffings and sell them.Lavrenty has n grams of dough as well as m different stuffing types. The stuffing types are numerated from 1 to m. Lavrenty knows that he has ai grams left of the i-th stuffing. It takes exactly bi grams of stuffing i and ci grams of dough to cook a bun with the i-th stuffing. Such bun can be sold for di tugriks.Also he can make buns without stuffings. Each of such buns requires c0 grams of dough and it can be sold for d0 tugriks. So Lavrenty can cook any number of buns with different stuffings or without it unless he runs out of dough and the stuffings. Lavrenty throws away all excess material left after baking.Find the maximum number of tugriks Lavrenty can earn.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains 4 integers n, m, c0 and d0 (1\u2264n\u22641000, 1\u2264m\u226410, 1\u2264c0,d0\u2264100). Each of the following m lines contains 4 integers. The i-th line contains numbers ai, bi, ci and di (1\u2264ai,bi,ci,di\u2264100).\n","output_spec":"Print the only number \u2014 the maximum number of tugriks Lavrenty can earn.\n","notes":"To get the maximum number of tugriks in the first sample, you need to cook 2 buns with stuffing 1, 4 buns with stuffing 2 and a bun without any stuffing.\nIn the second sample Lavrenty should cook 4 buns without stuffings.\n","sample_inputs":["10 2 2 1\n7 3 2 100\n12 3 1 10\n","100 1 25 50\n15 5 20 10\n"],"sample_outputs":["241","200"],"id":"106-C","difficulty":1700,"tags":["dp"],"src_uid":"4e166b8b44427b1227e0f811161d3a6f","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nstruct Bun {\\n    int stuffing;\\n    int dough;\\n    int price;\\n};\\n\\nbool compareBuns(Bun a, Bun b) {\\n    return a.price > b.price;\\n}\\n\\nint main() {\\n    int n, m, c0, d0;\\n    cin >> n >> m >> c0 >> d0;\\n\\n    vector<Bun> buns;\\n\\n    for (int i = 0; i < m; i++) {\\n        int a, b, c, d;\\n        cin >> a >> b >> c >> d;\\n        buns.push_back({i + 1, c, d});\\n    }\\n\\n    buns.push_back({0, c0, d0});\\n\\n    sort(buns.begin(), buns.end(), compareBuns);\\n\\n    int maxTugriks = 0;\\n\\n    for (int i = 0; i < buns.size(); i++) {\\n        int numBuns = min(n \/ buns[i].dough, buns[i].stuffing);\\n        maxTugriks += numBuns * buns[i].price;\\n        n -= numBuns * buns[i].dough;\\n        buns[i].stuffing -= numBuns;\\n    }\\n\\n    cout << maxTugriks << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class BunBaker {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input\n        String[] input = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input[0]);\n        int m = Integer.parseInt(input[1]);\n        int c0 = Integer.parseInt(input[2]);\n        int d0 = Integer.parseInt(input[3]);\n        \n        int[][] stuffings = new int[m][4];\n        for (int i = 0; i < m; i++) {\n            input = scanner.nextLine().split(\\\" \\\");\n            for (int j = 0; j < 4; j++) {\n                stuffings[i][j] = Integer.parseInt(input[j]);\n            }\n        }\n        \n        \/\/ Calculate maximum number of tugriks\n        int maxTugriks = 0;\n        \n        \/\/ Calculate maximum number of buns with stuffings\n        for (int i = 0; i < m; i++) {\n            int maxBuns = Math.min(n \/ stuffings[i][2], stuffings[i][0] \/ stuffings[i][1]);\n            maxTugriks += maxBuns * stuffings[i][3];\n            n -= maxBuns * stuffings[i][2];\n            stuffings[i][0] -= maxBuns * stuffings[i][1];\n        }\n        \n        \/\/ Calculate maximum number of buns without stuffings\n        int maxBunsWithoutStuffings = n \/ c0;\n        maxTugriks += maxBunsWithoutStuffings * d0;\n        \n        \/\/ Print the maximum number of tugriks\n        System.out.println(maxTugriks);\n    }\n}","Python":"def max_tugriks(n, m, c0, d0, stuffings):\n    max_tugriks = 0\n    for i in range(1, m+1):\n        ai, bi, ci, di = stuffings[i-1]\n        max_buns = min(n \/\/ ci, ai \/\/ bi)\n        max_tugriks += max_buns * di\n        n -= max_buns * ci\n        ai -= max_buns * bi\n    \n    max_buns_without_stuffing = n \/\/ c0\n    max_tugriks += max_buns_without_stuffing * d0\n    \n    return max_tugriks\n\ninput_data = input().split()\nn, m, c0, d0 = map(int, input_data[:4])\nstuffings = []\nfor i in range(m):\n    stuffing_data = list(map(int, input().split()))\n    stuffings.append(stuffing_data)\n\nresult = max_tugriks(n, m, c0, d0, stuffings)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m, c0, d0;\\n    scanf(\\\"%d %d %d %d\\\", &n, &m, &c0, &d0);\\n    int a[m], b[m], c[m], d[m];\\n    for(int i=0; i<m; i++) {\\n        scanf(\\\"%d %d %d %d\\\", &a[i], &b[i], &c[i], &d[i]);\\n    }\\n    int maxTugriks = 0;\\n    for(int i=0; i<=n\/c0; i++) {\\n        int tugriks = i * d0;\\n        int doughLeft = n - i * c0;\\n        for(int j=0; j<m; j++) {\\n            int buns = doughLeft \/ c[j];\\n            if(buns > a[j]) {\\n                buns = a[j];\\n            }\\n            tugriks += buns * d[j];\\n            doughLeft -= buns * c[j];\\n        }\\n        if(tugriks > maxTugriks) {\\n            maxTugriks = tugriks;\\n        }\\n    }\\n    printf(\\\"%d\\\", maxTugriks);\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace BunBaker\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read input\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n            int c0 = int.Parse(input[2]);\n            int d0 = int.Parse(input[3]);\n\n            \/\/ Initialize variables\n            int[] a = new int[m];\n            int[] b = new int[m];\n            int[] c = new int[m];\n            int[] d = new int[m];\n\n            \/\/ Read stuffing information\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                a[i] = int.Parse(input[0]);\n                b[i] = int.Parse(input[1]);\n                c[i] = int.Parse(input[2]);\n                d[i] = int.Parse(input[3]);\n            }\n\n            \/\/ Calculate maximum number of buns with stuffings\n            int maxBunsWithStuffings = int.MaxValue;\n            for (int i = 0; i < m; i++)\n            {\n                maxBunsWithStuffings = Math.Min(maxBunsWithStuffings, a[i] \/ b[i]);\n            }\n\n            \/\/ Calculate maximum number of buns without stuffings\n            int maxBunsWithoutStuffings = n \/ c0;\n\n            \/\/ Calculate maximum number of tugriks\n            int maxTugriks = 0;\n            for (int i = 0; i <= maxBunsWithStuffings; i++)\n            {\n                int remainingDough = n - i * c0;\n                int maxBunsWithCurrentStuffing = int.MaxValue;\n                for (int j = 0; j < m; j++)\n                {\n                    maxBunsWithCurrentStuffing = Math.Min(maxBunsWithCurrentStuffing, remainingDough \/ c[j]);\n                }\n                int totalBuns = i + maxBunsWithCurrentStuffing;\n                int totalTugriks = i * d0;\n                for (int j = 0; j < m; j++)\n                {\n                    totalTugriks += maxBunsWithCurrentStuffing * d[j];\n                }\n                maxTugriks = Math.Max(maxTugriks, totalTugriks);\n            }\n\n            \/\/ Print the maximum number of tugriks\n            Console.WriteLine(maxTugriks);\n        }\n    }\n}\n","Ruby":"\ndef max_tugriks(n, m, c0, d0, stuffings)\n  max_tugriks = 0\n\n  # Calculate the maximum number of buns with each stuffing\n  max_buns = []\n  stuffings.each do |stuffing|\n    max_buns << [stuffing[0] \/ stuffing[1], stuffing[2] \/ stuffing[3]]\n  end\n\n  # Calculate the maximum number of buns without stuffing\n  max_buns << [n \/ c0, 0]\n\n  # Iterate through all possible combinations of buns\n  (0..max_buns[0][0]).each do |buns1|\n    (0..max_buns[1][0]).each do |buns2|\n      (0..max_buns[0][1]).each do |buns3|\n        (0..max_buns[1][1]).each do |buns4|\n          # Calculate the total grams of dough and stuffing used\n          total_dough = buns1 * c0 + buns2 * c0 + buns3 * stuffings[0][2] + buns4 * stuffings[1][2]\n          total_stuffing = buns1 * stuffings[0][1] + buns2 * stuffings[1][1] + buns3 * stuffings[0][3] + buns4 * stuffings[1][3]\n\n          # Check if the total grams of dough and stuffing used is within the available amount\n          if total_dough <= n && total_stuffing <= m\n            # Calculate the total number of tugriks earned\n            total_tugriks = buns1 * d0 + buns2 * d0 + buns3 * stuffings[0][3] + buns4 * stuffings[1][3]\n            max_tugriks = [max_tugriks, total_tugriks].max\n          end\n        end\n      end\n    end\n  end\n\n  return max_tugriks\nend\n\n# Parse the input\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\nc0 = input[2].to_i\nd0 = input[3].to_i\n\nstuffings = []\nm.times do\n  stuffing = gets.chomp.split(' ').map(&:to_i)\n  stuffings << stuffing\nend\n\n# Calculate and print the maximum number of tugriks\nputs max_tugriks(n, m, c0, d0, stuffings)\n","delphi":"program LavrentyBaker;\\n\\nvar\\n  n, m, c0, d0, i, j, k, maxTugriks, maxBuns: integer;\\n  dough, stuffing, maxStuffing: array[1..10] of integer;\\n\\nbegin\\n  readln(n, m, c0, d0);\\n  maxTugriks := 0;\\n  maxBuns := 0;\\n\\n  for i := 1 to m do\\n  begin\\n    readln(stuffing[i], dough[i], maxStuffing[i], maxTugriks[i]);\\n  end;\\n\\n  for i := 0 to n div c0 do\\n  begin\\n    for j := 1 to m do\\n    begin\\n      for k := 0 to maxStuffing[j] do\\n      begin\\n        if (i * c0 + k * dough[j] <= n) and (i * c0 + k * dough[j] >= 0) then\\n        begin\\n          maxBuns := i + k;\\n          maxTugriks := max(maxTugriks, i * d0 + k * maxTugriks[j]);\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  writeln(maxTugriks);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, c0, d0 int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &n, &m, &c0, &d0)\\n\\n\\tstuffings := make([][4]int, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfmt.Scanf(\\\"%d %d %d %d\\\", &stuffings[i][0], &stuffings[i][1], &stuffings[i][2], &stuffings[i][3])\\n\\t}\\n\\n\\t\/\/ Sort stuffings by their efficiency (di\/ci)\\n\\tsort.Slice(stuffings, func(i, j int) bool {\\n\\t\\tefficiency1 := float64(stuffings[i][3]) \/ float64(stuffings[i][2])\\n\\t\\tefficiency2 := float64(stuffings[j][3]) \/ float64(stuffings[j][2])\\n\\t\\treturn efficiency1 > efficiency2\\n\\t})\\n\\n\\tmaxTugriks := 0\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tif n >= stuffings[i][2] {\\n\\t\\t\\tbuns := n \/ stuffings[i][2]\\n\\t\\t\\tmaxTugriks += buns * stuffings[i][3]\\n\\t\\t\\tn -= buns * stuffings[i][2]\\n\\t\\t}\\n\\t}\\n\\n\\tif n >= c0 {\\n\\t\\tbuns := n \/ c0\\n\\t\\tmaxTugriks += buns * d0\\n\\t}\\n\\n\\tfmt.Println(maxTugriks)\\n}","Javascript":"function calculateMaxTugriks(input) {\n  const [n, m, c0, d0, ...stuffings] = input.split('\\\\n');\n  const [dough, stuffingTypes] = [parseInt(n.split(' ')[0]), parseInt(m.split(' ')[0])];\n  const [doughCost, doughPrice] = [parseInt(c0.split(' ')[0]), parseInt(d0.split(' ')[0])];\n  \n  const stuffingsData = stuffings.map(stuffing => stuffing.split(' ').map(Number));\n  \n  let maxTugriks = 0;\n  \n  for (let i = 0; i <= dough; i++) {\n    let currentTugriks = 0;\n    let currentDough = dough - i;\n    \n    for (let j = 0; j < stuffingTypes; j++) {\n      const [stuffingAmount, stuffingCost, stuffingDough, stuffingPrice] = stuffingsData[j];\n      \n      const maxStuffingBuns = Math.floor(currentDough \/ stuffingDough);\n      const usedStuffing = Math.min(stuffingAmount, maxStuffingBuns * stuffingCost);\n      \n      currentDough -= usedStuffing * stuffingDough;\n      currentTugriks += usedStuffing * stuffingPrice;\n    }\n    \n    const maxPlainBuns = Math.floor(currentDough \/ doughCost);\n    currentTugriks += maxPlainBuns * doughPrice;\n    \n    maxTugriks = Math.max(maxTugriks, currentTugriks);\n  }\n  \n  return maxTugriks.toString();\n}\n\nconst inputs = ['10 2 2 1\\\\n7 3 2 100\\\\n12 3 1 10\\\\n', '100 1 25 50\\\\n15 5 20 10\\\\n'];\nconst outputs = inputs.map(calculateMaxTugriks);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val c0 = input[2].toInt()\n    val d0 = input[3].toInt()\n\n    val stuffings = mutableListOf<Stuffing>()\n    for (i in 0 until m) {\n        val stuffingInput = scanner.nextLine().split(\" \")\n        val ai = stuffingInput[0].toInt()\n        val bi = stuffingInput[1].toInt()\n        val ci = stuffingInput[2].toInt()\n        val di = stuffingInput[3].toInt()\n        stuffings.add(Stuffing(ai, bi, ci, di))\n    }\n\n    val dp = Array(n + 1) { IntArray(m + 1) }\n    for (i in 0..n) {\n        for (j in 0..m) {\n            if (i > 0 && j > 0) {\n                dp[i][j] = dp[i][j - 1]\n            }\n            for (k in 1..(n \/ stuffings[j].ci)) {\n                if (i >= k * stuffings[j].ci) {\n                    dp[i][j] = maxOf(dp[i][j], dp[i - k * stuffings[j].ci][j - 1] + k * stuffings[j].di)\n                }\n            }\n        }\n    }\n\n    var maxTugriks = dp[n][m]\n    for (i in 1..(n \/ c0)) {\n        if (n >= i * c0) {\n            maxTugriks = maxOf(maxTugriks, dp[n - i * c0][m] + i * d0)\n        }\n    }\n\n    println(maxTugriks)\n}\n\ndata class Stuffing(val ai: Int, val bi: Int, val ci: Int, val di: Int)\n","PHP":"<?php\\n\\nfunction calculateMaxTugriks($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $firstLine = explode(\\\" \\\", $lines[0]);\\n    $n = intval($firstLine[0]);\\n    $m = intval($firstLine[1]);\\n    $c0 = intval($firstLine[2]);\\n    $d0 = intval($firstLine[3]);\\n    \\n    $stuffings = [];\\n    for ($i = 1; $i <= $m; $i++) {\\n        $stuffingLine = explode(\\\" \\\", $lines[$i]);\\n        $ai = intval($stuffingLine[0]);\\n        $bi = intval($stuffingLine[1]);\\n        $ci = intval($stuffingLine[2]);\\n        $di = intval($stuffingLine[3]);\\n        $stuffings[] = [$ai, $bi, $ci, $di];\\n    }\\n    \\n    $maxTugriks = 0;\\n    \\n    \/\/ Calculate maximum number of buns with stuffings\\n    for ($i = 0; $i < $m; $i++) {\\n        $maxBuns = min($stuffings[$i][0] \/ $stuffings[$i][1], $n \/ $stuffings[$i][2]);\\n        $maxTugriks += $maxBuns * $stuffings[$i][3];\\n        $n -= $maxBuns * $stuffings[$i][2];\\n    }\\n    \\n    \/\/ Calculate maximum number of buns without stuffing\\n    $maxBunsWithoutStuffing = $n \/ $c0;\\n    $maxTugriks += $maxBunsWithoutStuffing * $d0;\\n    \\n    return strval($maxTugriks);\\n}\\n\\n$input = '10 2 2 1\\\\n7 3 2 100\\\\n12 3 1 10';\\n$result = calculateMaxTugriks($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nstruct Bun\\r\\n{\\r\\n    int stuffing;\\r\\n    int dough;\\r\\n    int price;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, c0, d0;\\r\\n    readf(\\\"%d %d %d %d\\\", &n, &m, &c0, &d0);\\r\\n\\r\\n    Bun[] buns;\\r\\n\\r\\n    foreach (_; 0 .. m)\\r\\n    {\\r\\n        int ai, bi, ci, di;\\r\\n        readf(\\\"%d %d %d %d\\\", &ai, &bi, &ci, &di);\\r\\n\\r\\n        if (ai >= bi)\\r\\n        {\\r\\n            int numBuns = ai \/ bi;\\r\\n            ai -= numBuns * bi;\\r\\n\\r\\n            foreach (_; 0 .. numBuns)\\r\\n            {\\r\\n                buns ~= Bun(_, ci, di);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (ai >= c0)\\r\\n        {\\r\\n            int numBuns = ai \/ c0;\\r\\n            ai -= numBuns * c0;\\r\\n\\r\\n            foreach (_; 0 .. numBuns)\\r\\n            {\\r\\n                buns ~= Bun(-1, c0, d0);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (ai > 0)\\r\\n        {\\r\\n            buns ~= Bun(-1, ai, d0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    buns.sort!((a, b) => a.price > b.price);\\r\\n\\r\\n    int maxTugriks = 0;\\r\\n\\r\\n    foreach (bun; buns)\\r\\n    {\\r\\n        if (n >= bun.dough)\\r\\n        {\\r\\n            maxTugriks += bun.price;\\r\\n            n -= bun.dough;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxTugriks);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub maximum_tugriks {\n    my ($n, $m, $c0, $d0, @stuffings) = @_;\n\n    my @dp;\n    for my $i (0..$n) {\n        for my $j (0..$m) {\n            $dp[$i][$j] = 0;\n        }\n    }\n\n    for my $i (1..$n) {\n        for my $j (0..$m) {\n            if ($j == 0) {\n                $dp[$i][$j] = $dp[$i-1][$j] + $d0;\n            } else {\n                my ($a, $b, $c, $d) = @{$stuffings[$j-1]};\n                if ($i >= $c && $a >= $b) {\n                    $dp[$i][$j] = max($dp[$i][$j-1], $dp[$i-$c][$j] + $d);\n                } else {\n                    $dp[$i][$j] = $dp[$i][$j-1];\n                }\n            }\n        }\n    }\n\n    return $dp[$n][$m];\n}\n\nsub max {\n    my ($a, $b) = @_;\n    return $a > $b ? $a : $b;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $c0, $d0) = split ' ', $input;\n\nmy @stuffings;\nfor (1..$m) {\n    my $line = <STDIN>;\n    chomp $line;\n    my ($a, $b, $c, $d) = split ' ', $line;\n    push @stuffings, [$a, $b, $c, $d];\n}\n\n# Calculate maximum tugriks\nmy $result = maximum_tugriks($n, $m, $c0, $d0, @stuffings);\n\n# Print result\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"100 1 25 50\\\\n15 5 20 10\\\\n\\\";\\n    let mut lines = input.lines();\\n    let first_line = lines.next().unwrap();\\n    let mut values = first_line.split_whitespace();\\n    let n: i32 = values.next().unwrap().parse().unwrap();\\n    let m: i32 = values.next().unwrap().parse().unwrap();\\n    let c0: i32 = values.next().unwrap().parse().unwrap();\\n    let d0: i32 = values.next().unwrap().parse().unwrap();\\n\\n    let mut max_tugriks = 0;\\n\\n    for _ in 0..m {\\n        let line = lines.next().unwrap();\\n        let mut values = line.split_whitespace();\\n        let ai: i32 = values.next().unwrap().parse().unwrap();\\n        let bi: i32 = values.next().unwrap().parse().unwrap();\\n        let ci: i32 = values.next().unwrap().parse().unwrap();\\n        let di: i32 = values.next().unwrap().parse().unwrap();\\n\\n        let max_buns = ai \/ bi;\\n        let max_tugriks_with_stuffing = max_buns * di;\\n        let remaining_dough = n - max_buns * ci;\\n        let max_buns_without_stuffing = remaining_dough \/ c0;\\n        let max_tugriks_without_stuffing = max_buns_without_stuffing * d0;\\n\\n        let total_tugriks = max_tugriks_with_stuffing + max_tugriks_without_stuffing;\\n        if total_tugriks > max_tugriks {\\n            max_tugriks = total_tugriks;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", max_tugriks);\\n}"}
{"title":"C. Arrangement","description":"In the year 2500 the annual graduation ceremony in the German University in Cairo (GUC) has run smoothly for almost 500 years so far.The most important part of the ceremony is related to the arrangement of the professors in the ceremonial hall.Traditionally GUC has n professors. Each professor has his seniority level. All seniorities are different. Let's enumerate the professors from 1 to n, with 1 being the most senior professor and n being the most junior professor.The ceremonial hall has n seats, one seat for each professor. Some places in this hall are meant for more senior professors than the others. More specifically, m pairs of seats are in \"senior-junior\" relation, and the tradition requires that for all m pairs of seats (ai,bi) the professor seated in \"senior\" position ai should be more senior than the professor seated in \"junior\" position bi.GUC is very strict about its traditions, which have been carefully observed starting from year 2001. The tradition requires that:   The seating of the professors changes every year.  Year 2001 ceremony was using lexicographically first arrangement of professors in the ceremonial hall.  Each consecutive year lexicographically next arrangement of the professors is used. The arrangement of the professors is the list of n integers, where the first integer is the seniority of the professor seated in position number one, the second integer is the seniority of the professor seated in position number two, etc.Given n, the number of professors, y, the current year and m pairs of restrictions, output the arrangement of the professors for this year.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three integers n, y and m (1\u2264n\u226416,2001\u2264y\u226410^18,0\u2264m\u2264100) \u2014 the number of professors, the year for which the arrangement should be computed, and the number of pairs of seats for which the seniority relation should be kept, respectively.\nThe next m lines contain one pair of integers each, \"ai bi\", indicating that professor on the ai-th seat is more senior than professor on the bi-th seat (1\u2264ai,bi\u2264n,ai\u2260bi). Some pair may be listed more than once.\nPlease, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin stream (you may also use the %I64d specificator).\n","output_spec":"Print the order in which the professors should be seated in the requested year.\nIf by this year the GUC would have ran out of arrangements, or the given \"senior-junior\" relation are contradictory, print \"The times have changed\" (without quotes).\n","notes":"In the first example the lexicographically first order of seating is 1 2 3.\nIn the third example the GUC will run out of arrangements after the year 3630800.\nIn the fourth example there are no valid arrangements for the seating.\nThe lexicographical comparison of arrangements is performed by the < operator in modern programming languages. The arrangement a is lexicographically less that the arrangement b, if there exists such i (1\u2264i\u2264n), that ai<bi, and for any j (1\u2264j<i) aj=bj.\n","sample_inputs":["3 2001 2\n1 2\n2 3\n","7 2020 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n","10 3630801 0\n","3 2001 3\n1 2\n2 3\n3 1\n"],"sample_outputs":["1 2 3\n","1 2 3 7 4 6 5\n","The times have changed\n","The times have changed\n"],"id":"107-C","difficulty":2400,"tags":["bitmasks","dp"],"src_uid":"e9db8d048e9763cf38c584342dea9f53","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <set>\\n#include <map>\\nusing namespace std;\\n\\nbool checkValid(vector<int>& arrangement, vector<pair<int, int>>& restrictions) {\\n    for (auto& restriction : restrictions) {\\n        int senior = restriction.first;\\n        int junior = restriction.second;\\n        if (arrangement[senior] >= arrangement[junior]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nbool nextPermutation(vector<int>& arrangement) {\\n    int n = arrangement.size();\\n    int i = n - 2;\\n    while (i >= 0 && arrangement[i] >= arrangement[i + 1]) {\\n        i--;\\n    }\\n    if (i < 0) {\\n        return false;\\n    }\\n    int j = n - 1;\\n    while (arrangement[j] <= arrangement[i]) {\\n        j--;\\n    }\\n    swap(arrangement[i], arrangement[j]);\\n    reverse(arrangement.begin() + i + 1, arrangement.end());\\n    return true;\\n}\\n\\nstring computeArrangement(int n, long long y, int m, vector<pair<int, int>>& restrictions) {\\n    vector<int> arrangement(n);\\n    for (int i = 0; i < n; i++) {\\n        arrangement[i] = i + 1;\\n    }\\n    for (long long i = 2001; i < y; i++) {\\n        if (!nextPermutation(arrangement)) {\\n            return \\\"The times have changed\\\";\\n        }\\n    }\\n    if (!checkValid(arrangement, restrictions)) {\\n        return \\\"The times have changed\\\";\\n    }\\n    string result;\\n    for (int i = 0; i < n; i++) {\\n        result += to_string(arrangement[i]) + \\\" \\\";\\n    }\\n    return result;\\n}\\n\\nint main() {\\n    int n, m;\\n    long long y;\\n    cin >> n >> y >> m;\\n    vector<pair<int, int>> restrictions(m);\\n    for (int i = 0; i < m; i++) {\\n        cin >> restrictions[i].first >> restrictions[i].second;\\n    }\\n    string arrangement = computeArrangement(n, y, m, restrictions);\\n    cout << arrangement << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class ProfessorArrangement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        long y = scanner.nextLong();\n        int m = scanner.nextInt();\n        \n        int[][] restrictions = new int[m][2];\n        for (int i = 0; i < m; i++) {\n            restrictions[i][0] = scanner.nextInt();\n            restrictions[i][1] = scanner.nextInt();\n        }\n        \n        int[] arrangement = new int[n];\n        for (int i = 0; i < n; i++) {\n            arrangement[i] = i + 1;\n        }\n        \n        for (long i = 2001; i < y; i++) {\n            if (!nextPermutation(arrangement, restrictions)) {\n                System.out.println(\"The times have changed\");\n                return;\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            System.out.print(arrangement[i] + \" \");\n        }\n    }\n    \n    public static boolean nextPermutation(int[] arr, int[][] restrictions) {\n        int n = arr.length;\n        int i = n - 2;\n        while (i >= 0 && arr[i] >= arr[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) {\n            return false;\n        }\n        \n        int j = n - 1;\n        while (arr[i] >= arr[j]) {\n            j--;\n        }\n        \n        swap(arr, i, j);\n        \n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            swap(arr, left, right);\n            left++;\n            right--;\n        }\n        \n        for (int[] restriction : restrictions) {\n            if (arr[restriction[0] - 1] >= arr[restriction[1] - 1]) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}","Python":"from itertools import permutations\\n\\n# Function to check if the given seating arrangement is valid\\ndef is_valid(arrangement, restrictions):\\n    for senior, junior in restrictions:\\n        if arrangement.index(senior) > arrangement.index(junior):\\n            return False\\n    return True\\n\\n# Function to generate all possible seating arrangements\\ndef generate_arrangements(n):\\n    professors = list(range(1, n+1))\\n    arrangements = list(permutations(professors))\\n    return arrangements\\n\\n# Main function to compute the arrangement for the given year\\ndef compute_arrangement(n, y, m, restrictions):\\n    arrangements = generate_arrangements(n)\\n    arrangements.sort()\\n    if y > len(arrangements):\\n        return 'The times have changed'\\n    for arrangement in arrangements:\\n        if is_valid(arrangement, restrictions):\\n            y -= 1\\n            if y == 0:\\n                return ' '.join(map(str, arrangement))\\n    return 'The times have changed'\\n\\n# Read input\\nn, y, m = map(int, input().split())\\nrestrictions = []\\nfor _ in range(m):\\n    a, b = map(int, input().split())\\n    restrictions.append((a, b))\\n\\n# Compute and print the arrangement\\nprint(compute_arrangement(n, y, m, restrictions))","C":"#include <stdio.h>\\n#include <stdbool.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MAX_N 16\\n#define MAX_M 100\\n\\nint n, y, m;\\nint seniority[MAX_N];\\nint senior[MAX_M];\\nint junior[MAX_M];\\n\\nbool isValid(int *arrangement) {\\n    for (int i = 0; i < m; i++) {\\n        if (arrangement[senior[i]] >= arrangement[junior[i]]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nbool nextArrangement(int *arrangement) {\\n    int i = n - 1;\\n    while (i > 0 && arrangement[i - 1] >= arrangement[i]) {\\n        i--;\\n    }\\n    if (i <= 0) {\\n        return false;\\n    }\\n    int j = n - 1;\\n    while (arrangement[j] <= arrangement[i - 1]) {\\n        j--;\\n    }\\n    int temp = arrangement[i - 1];\\n    arrangement[i - 1] = arrangement[j];\\n    arrangement[j] = temp;\\n    j = n - 1;\\n    while (i < j) {\\n        temp = arrangement[i];\\n        arrangement[i] = arrangement[j];\\n        arrangement[j] = temp;\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    scanf(\\\"%d %d %d\\\", &n, &y, &m);\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%d %d\\\", &senior[i], &junior[i]);\\n    }\\n    for (int i = 0; i < n; i++) {\\n        seniority[i] = i + 1;\\n    }\\n    for (int i = 1; i < y; i++) {\\n        if (!nextArrangement(seniority)) {\\n            printf(\\\"The times have changed\\\\n\\\");\\n            return 0;\\n        }\\n    }\\n    if (!isValid(seniority)) {\\n        printf(\\\"The times have changed\\\\n\\\");\\n        return 0;\\n    }\\n    for (int i = 0; i < n; i++) {\\n        printf(\\\"%d \\\", seniority[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace GUC_Professors\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            long y = long.Parse(input[1]);\n            int m = int.Parse(input[2]);\n\n            List<int>[] adjList = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                adjList[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                string[] pair = Console.ReadLine().Split(' ');\n                int a = int.Parse(pair[0]);\n                int b = int.Parse(pair[1]);\n                adjList[a].Add(b);\n            }\n\n            List<int> arrangement = new List<int>();\n            bool[] visited = new bool[n + 1];\n\n            if (!DFS(adjList, visited, arrangement, n))\n            {\n                Console.WriteLine(\\\"The times have changed\\\");\n            }\n            else\n            {\n                for (int i = 0; i < n; i++)\n                {\n                    Console.Write(arrangement[i] + \\\" \\\");\n                }\n            }\n        }\n\n        static bool DFS(List<int>[] adjList, bool[] visited, List<int> arrangement, int n)\n        {\n            if (arrangement.Count == n)\n            {\n                return true;\n            }\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (!visited[i] && CanBeSeated(adjList, arrangement, i))\n                {\n                    visited[i] = true;\n                    arrangement.Add(i);\n\n                    if (DFS(adjList, visited, arrangement, n))\n                    {\n                        return true;\n                    }\n\n                    visited[i] = false;\n                    arrangement.RemoveAt(arrangement.Count - 1);\n                }\n            }\n\n            return false;\n        }\n\n        static bool CanBeSeated(List<int>[] adjList, List<int> arrangement, int professor)\n        {\n            foreach (int adj in adjList[professor])\n            {\n                if (!arrangement.Contains(adj) || arrangement.IndexOf(professor) > arrangement.IndexOf(adj))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n","Ruby":"\n# Function to check if the given arrangement is valid\ndef is_valid(arrangement, restrictions)\n  for restriction in restrictions\n    senior = arrangement.index(restriction[0])\n    junior = arrangement.index(restriction[1])\n    return false if senior > junior\n  end\n  return true\nend\n\n# Function to generate the next lexicographically arrangement\ndef next_arrangement(arrangement)\n  n = arrangement.length\n  i = n - 2\n  while i >= 0 && arrangement[i] >= arrangement[i+1]\n    i -= 1\n  end\n  return 'The times have changed' if i < 0\n  \n  j = n - 1\n  while arrangement[j] <= arrangement[i]\n    j -= 1\n  end\n  \n  arrangement[i], arrangement[j] = arrangement[j], arrangement[i]\n  arrangement[i+1..-1] = arrangement[i+1..-1].reverse\n  \n  return arrangement\nend\n\n# Read input\nn, y, m = gets.chomp.split.map(&:to_i)\n\n# Initialize arrangement\narrangement = (1..n).to_a\n\n# Read restrictions\nrestrictions = []\nm.times do\n  a, b = gets.chomp.split.map(&:to_i)\n  restrictions << [a, b]\nend\n\n# Compute the arrangement for the given year\n(y - 2001).times do\n  arrangement = next_arrangement(arrangement)\n  break if arrangement == 'The times have changed'\nend\n\n# Check if the arrangement is valid\nif is_valid(arrangement, restrictions)\n  puts arrangement.join(' ')\nelse\n  puts 'The times have changed'\nend\n","delphi":"program GUCArrangement;\\n\\nvar\\n  n, y, m, i, j: Integer;\\n  arr: array[1..16] of Integer;\\n  seniority: array[1..16] of Integer;\\n  relation: array[1..100, 1..2] of Integer;\\n  valid: Boolean;\\n\\nprocedure Swap(var a, b: Integer);\\nvar\\n  temp: Integer;\\nbegin\\n  temp := a;\\n  a := b;\\n  b := temp;\\nend;\\n\\nprocedure Permute(pos: Integer);\\nvar\\n  i: Integer;\\nbegin\\n  if pos = n + 1 then\\n  begin\\n    valid := True;\\n    for i := 1 to m do\\n    begin\\n      if seniority[relation[i, 1]] >= seniority[relation[i, 2]] then\\n      begin\\n        valid := False;\\n        Break;\\n      end;\\n    end;\\n    if valid then\\n    begin\\n      for i := 1 to n do\\n        Write(seniority[i], ' ');\\n      Halt;\\n    end;\\n  end\\n  else\\n  begin\\n    for i := pos to n do\\n\\n    begin\\n      Swap(seniority[pos], seniority[i]);\\n      Permute(pos + 1);\\n      Swap(seniority[pos], seniority[i]);\\n    end;\\n  end;\\nend;\\n\\nbegin\\n  Readln(n, y, m);\\n  for i := 1 to m do\\n    Readln(relation[i, 1], relation[i, 2]);\\n\\n  for i := 1 to n do\\n    seniority[i] := i;\\n\\n  valid := False;\\n  for i := 1 to y - 2001 + 1 do\\n  begin\\n    Permute(1);\\n    if not valid then\\n    begin\\n      Writeln('The times have changed');\\n      Halt;\\n    end;\\n  end;\\n\\n  Writeln('The times have changed');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, y, m int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &y, &m)\\n\\n\\tseats := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tseats[i] = i + 1\\n\\t}\\n\\n\\trelations := make([][]int, m)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tvar a, b int\\n\\t\\tfmt.Scanf(\\\"%d %d\\\", &a, &b)\\n\\t\\trelations[i] = []int{a, b}\\n\\t}\\n\\n\\tfor i := 0; i < y-2001; i++ {\\n\\t\\tnextArrangement(seats, relations)\\n\\t}\\n\\n\\tif !isValidArrangement(seats, relations) {\\n\\t\\tfmt.Println(\\\"The times have changed\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Printf(\\\"%d \\\", seats[i])\\n\\t}\\n\\tfmt.Println()\\n}\\n\\nfunc nextArrangement(seats []int, relations [][]int) {\\n\\tn := len(seats)\\n\\n\\ti := n - 2\\n\\tfor i >= 0 && seats[i] >= seats[i+1] {\\n\\t\\ti--\\n\\t}\\n\\n\\tif i < 0 {\\n\\t\\treturn\\n\\t}\\n\\n\\tj := n - 1\\n\\tfor seats[j] <= seats[i] {\\n\\t\\tj--\\n\\t}\\n\\n\\tseats[i], seats[j] = seats[j], seats[i]\\n\\n\\tleft := i + 1\\n\\tright := n - 1\\n\\tfor left < right {\\n\\t\\tseats[left], seats[right] = seats[right], seats[left]\\n\\t\\tleft++\\n\\t\\tright--\\n\\t}\\n}\\n\\nfunc isValidArrangement(seats []int, relations [][]int) bool {\\n\\tn := len(seats)\\n\\n\\tfor _, relation := range relations {\\n\\t\\ta := relation[0] - 1\\n\\t\\tb := relation[1] - 1\\n\\n\\t\\tif seats[a] >= seats[b] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}","Javascript":"function findArrangement(n, y, m, pairs) {\n    let professors = Array.from({length: n}, (_, i) => i + 1);\n    let arrangements = [professors.join(' ')];\n    \n    for (let i = 1; i < y; i++) {\n        let nextArrangement = getNextArrangement(arrangements[i - 1], m, pairs);\n        if (nextArrangement === null) {\n            return 'The times have changed';\n        }\n        arrangements.push(nextArrangement);\n    }\n    \n    return arrangements[y - 1];\n}\n\nfunction getNextArrangement(previousArrangement, m, pairs) {\n    let professors = previousArrangement.split(' ').map(Number);\n    let nextArrangement = Array.from({length: professors.length}, (_, i) => i + 1);\n    \n    while (true) {\n        let valid = true;\n        \n        for (let j = 0; j < m; j++) {\n            let senior = pairs[j][0];\n            let junior = pairs[j][1];\n            \n            if (professors.indexOf(senior) > professors.indexOf(junior)) {\n                valid = false;\n                break;\n            }\n        }\n        \n        if (valid) {\n            return nextArrangement.join(' ');\n        }\n        \n        if (!nextPermutation(nextArrangement)) {\n            return null;\n        }\n    }\n}\n\nfunction nextPermutation(arr) {\n    let i = arr.length - 2;\n    while (i >= 0 && arr[i] >= arr[i + 1]) {\n        i--;\n    }\n    \n    if (i < 0) {\n        return false;\n    }\n    \n    let j = arr.length - 1;\n    while (arr[j] <= arr[i]) {\n        j--;\n    }\n    \n    swap(arr, i, j);\n    reverse(arr, i + 1);\n    \n    return true;\n}\n\nfunction swap(arr, i, j) {\n    let temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nfunction reverse(arr, start) {\n    let i = start;\n    let j = arr.length - 1;\n    while (i < j) {\n        swap(arr, i, j);\n        i++;\n        j--;\n    }\n}\n\n\/\/ Example usage\nlet input = '3 2001 2\\\\n1 2\\\\n2 3\\\\n';\nlet lines = input.trim().split('\\\\n');\nlet [n, y, m] = lines[0].split(' ').map(Number);\nlet pairs = lines.slice(1).map(line => line.split(' ').map(Number));\n\nlet result = findArrangement(n, y, m, pairs);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val y = input[1].toLong()\n    val m = input[2].toInt()\n    \n    val relations = mutableListOf<Pair<Int, Int>>()\n    for (i in 0 until m) {\n        val relation = readLine()!!.split(\" \")\n        val ai = relation[0].toInt()\n        val bi = relation[1].toInt()\n        relations.add(Pair(ai, bi))\n    }\n    \n    val professors = (1..n).toList()\n    val arrangements = mutableListOf<List<Int>>()\n    generateArrangements(professors, mutableListOf(), arrangements)\n    \n    val sortedArrangements = arrangements.sorted()\n    val index = (y - 2001) % sortedArrangements.size\n    val arrangement = sortedArrangements[index]\n    \n    if (!isValidArrangement(arrangement, relations)) {\n        println(\"The times have changed\")\n    } else {\n        println(arrangement.joinToString(\" \"))\n    }\n}\n\nfun generateArrangements(professors: List<Int>, currentArrangement: MutableList<Int>, arrangements: MutableList<List<Int>>) {\n    if (professors.isEmpty()) {\n        arrangements.add(currentArrangement.toList())\n        return\n    }\n    \n    for (i in professors.indices) {\n        val professor = professors[i]\n        val remainingProfessors = professors.toMutableList()\n        remainingProfessors.removeAt(i)\n        \n        val newArrangement = currentArrangement.toMutableList()\n        newArrangement.add(professor)\n        \n        generateArrangements(remainingProfessors, newArrangement, arrangements)\n    }\n}\n\nfun isValidArrangement(arrangement: List<Int>, relations: List<Pair<Int, Int>>): Boolean {\n    for (relation in relations) {\n        val ai = arrangement.indexOf(relation.first)\n        val bi = arrangement.indexOf(relation.second)\n        \n        if (ai >= bi) {\n            return false\n        }\n    }\n    \n    return true\n}","PHP":"\n<?php\n\nfunction generateArrangement($n, $y, $m, $pairs) {\n    $arrangement = range(1, $n); \/\/ Initial arrangement\n    \n    \/\/ Generate all possible arrangements\n    for ($i = 1; $i < $y; $i++) {\n        if (!next_permutation($arrangement)) {\n            return \"The times have changed\";\n        }\n    }\n    \n    \/\/ Check if the given pairs of seats are valid\n    foreach ($pairs as $pair) {\n        $senior = $pair[0];\n        $junior = $pair[1];\n        \n        if (array_search($senior, $arrangement) > array_search($junior, $arrangement)) {\n            return \"The times have changed\";\n        }\n    }\n    \n    return implode(\" \", $arrangement);\n}\n\nfunction next_permutation(&$arrangement) {\n    $n = count($arrangement);\n    \n    \/\/ Find the largest index k such that $arrangement[k] < $arrangement[k+1]\n    $k = -1;\n    for ($i = 0; $i < $n - 1; $i++) {\n        if ($arrangement[$i] < $arrangement[$i + 1]) {\n            $k = $i;\n        }\n    }\n    \n    if ($k == -1) {\n        return false; \/\/ No next permutation\n    }\n    \n    \/\/ Find the largest index l such that $arrangement[k] < $arrangement[l]\n    $l = -1;\n    for ($i = $k + 1; $i < $n; $i++) {\n        if ($arrangement[$k] < $arrangement[$i]) {\n            $l = $i;\n        }\n    }\n    \n    \/\/ Swap $arrangement[k] and $arrangement[l]\n    $temp = $arrangement[$k];\n    $arrangement[$k] = $arrangement[$l];\n    $arrangement[$l] = $temp;\n    \n    \/\/ Reverse the sequence from $arrangement[k+1] up to the end\n    $arrangement = array_merge(\n        array_slice($arrangement, 0, $k + 1),\n        array_reverse(array_slice($arrangement, $k + 1))\n    );\n    \n    return true;\n}\n\n\/\/ Read input\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents(\\\"php:\/\/stdin\\\")));\nlist($n, $y, $m) = explode(\\\" \\\", $input[0]);\n$pairs = [];\nfor ($i = 1; $i <= $m; $i++) {\n    $pairs[] = explode(\\\" \\\", $input[$i]);\n}\n\n\/\/ Generate arrangement and print output\n$output = generateArrangement($n, $y, $m, $pairs);\necho $output;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, y, m;\\r\\n    readf(\\\"%d %d %d\\\", &n, &y, &m);\\r\\n\\r\\n    int[][] restrictions = new int[][]();\\r\\n\\r\\n    for (int i = 0; i < m; i++)\\r\\n    {\\r\\n        int a, b;\\r\\n        readf(\\\"%d %d\\\", &a, &b);\\r\\n        restrictions ~= [a, b];\\r\\n    }\\r\\n\\r\\n    int[] professors = new int[](n);\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        professors[i] = i + 1;\\r\\n    }\\r\\n\\r\\n    int count = 1;\\r\\n\\r\\n    while (count < y)\\r\\n    {\\r\\n        if (!nextPermutation(professors))\\r\\n        {\\r\\n            writeln(\\\"The times have changed\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        bool valid = true;\\r\\n\\r\\n        foreach (int[] restriction; restrictions)\\r\\n        {\\r\\n            int a = restriction[0];\\r\\n            int b = restriction[1];\\r\\n\\r\\n            if (professors.indexOf(a) > professors.indexOf(b))\\r\\n            {\\r\\n                valid = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (valid)\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(professors.join(\\\" \\\"));\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub generate_arrangement {\n    my ($n, $y, $m, @pairs) = @_;\n\n    my @arrangement = (1..$n);\n    my $count = 1;\n\n    while ($count < $y) {\n        my $i = $n - 2;\n        while ($i >= 0 && $arrangement[$i] >= $arrangement[$i+1]) {\n            $i--;\n        }\n\n        if ($i < 0) {\n            return \"The times have changed\";\n        }\n\n        my $j = $n - 1;\n        while ($arrangement[$i] >= $arrangement[$j]) {\n            $j--;\n        }\n\n        ($arrangement[$i], $arrangement[$j]) = ($arrangement[$j], $arrangement[$i]);\n\n        my $left = $i + 1;\n        my $right = $n - 1;\n\n        while ($left < $right) {\n            ($arrangement[$left], $arrangement[$right]) = ($arrangement[$right], $arrangement[$left]);\n            $left++;\n            $right--;\n        }\n\n        my $valid = 1;\n        foreach my $pair (@pairs) {\n            my ($a, $b) = @$pair;\n            if (index(join('', @arrangement), $a) > index(join('', @arrangement), $b)) {\n                $valid = 0;\n                last;\n            }\n        }\n\n        if (!$valid) {\n            return \"The times have changed\";\n        }\n\n        $count++;\n    }\n\n    return join(' ', @arrangement);\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $y, $m) = split(' ', $input);\n\nmy @pairs;\nfor (my $i = 0; $i < $m; $i++) {\n    my $pair = <STDIN>;\n    chomp $pair;\n    my ($a, $b) = split(' ', $pair);\n    push @pairs, [$a, $b];\n}\n\n# Generate arrangement\nmy $arrangement = generate_arrangement($n, $y, $m, @pairs);\n\n# Print output\nprint $arrangement;\n","Rust":"\n\nuse std::collections::HashSet;\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    let params: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = params[0];\n    let y = params[1];\n    let m = params[2];\n\n    let mut senior_junior: HashSet<(usize, usize)> = HashSet::new();\n    for _ in 0..m {\n        let seats: Vec<usize> = lines\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .map(|x| x.parse().unwrap())\n            .collect();\n        senior_junior.insert((seats[0], seats[1]));\n    }\n\n    let mut professors: Vec<usize> = (1..=n).collect();\n    let mut count = 1;\n    while count < y {\n        if !next_permutation(&mut professors, &senior_junior) {\n            println!(\"The times have changed\");\n            return;\n        }\n        count += 1;\n    }\n\n    println!(\"{}\", professors.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\" \"));\n}\n\nfn next_permutation(professors: &mut Vec<usize>, senior_junior: &HashSet<(usize, usize)>) -> bool {\n    let mut i = professors.len() - 1;\n    while i > 0 && professors[i - 1] >= professors[i] {\n        i -= 1;\n    }\n    if i == 0 {\n        return false;\n    }\n\n    let mut j = professors.len() - 1;\n    while professors[j] <= professors[i - 1] {\n        j -= 1;\n    }\n\n    professors.swap(i - 1, j);\n\n    let mut k = professors.len() - 1;\n    while i < k {\n        professors.swap(i, k);\n        i += 1;\n        k -= 1;\n    }\n\n    for &(a, b) in senior_junior {\n        if professors.iter().position(|&x| x == a).unwrap() > professors.iter().position(|&x| x == b).unwrap() {\n            return false;\n        }\n    }\n\n    true\n}\n"}
{"title":"D. Crime Management","description":"Zeyad wants to commit n crimes in Egypt and not be punished at the end. There are several types of crimes. For example, bribery is a crime but is not considered such when repeated twice. Therefore, bribery is not considered a crime when repeated an even number of times. Speeding is a crime, but is not considered such when repeated a number of times which is a multiple of five.More specifically, c conditions on crime repetitions are known. Each condition describes the crime type ti and its multiplicity mi. If the number of times Zeyad committed the crime ti is a multiple of mi, Zeyad will not be punished for crime ti. Some crimes may be listed more than once. In this case fulfilling at least one condition for this crime is enough to not be punished for it. Of course, if for certain crime the number of times Zeyad committed it is zero, he is innocent with respect to this crime.Now Zeyad is interested in a number of ways he can commit exactly n crimes without any punishment.The order of commiting the crimes matters. More formally, two ways, sequences w1 and w2, of committing n crimes are equal if w1i=w2i, for all 1\u2264i\u2264n.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and c (0\u2264n\u226410^18,0\u2264c\u22641000) \u2014 the number of crimes Zeyad would like to commit and the number of conditions he is aware of.\nThen the definitions for c conditions follow. There are 26 types of crimes. Each crime definition consists of crime type \u2014 a capital Latin letter \u2014 and its multiplicity. \nThe multiplicity of each crime is a positive integer number and the product of all multiplicities does not exceed 123. Some conditions may be repeated in the input more than once.\nCrime of multiplicity 1 is not yielding any punishment regardless of the number of times it was committed. The strictness of the law is compensated by the fact that it's non-mandatory.\nObviously, if some crime is not listed in the set of conditions, then Zeyad will not consider it, as committing it would unavoidably lead to the punishment.\nPlease, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin stream (you may also use the %I64d specificator).\n","output_spec":"Output the number of different ways Zeyad can commit exactly n crimes with no punishment modulo 12345.\n","notes":"In the first test case, the 16 ways are: AAAAA, AAABB, AABAB, AABBA, ABAAB, ABABA, ABBAA, BAAAB, BAABA, BABAA, BBAAA, ABBBB, BABBB, BBABB, BBBAB, BBBBA.\n","sample_inputs":["5 2\nA 1\nB 2\n","6 3\nA 1\nB 2\nC 3\n","8 3\nA 2\nA 3\nB 2\n"],"sample_outputs":["16\n","113\n","128\n"],"id":"107-D","difficulty":2400,"tags":["dp","graphs","matrices"],"src_uid":"76d4684d26dac380713a566a1e277c91","C++":"#include <iostream>\\n#include <vector>\\n#include <map>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 12345;\\n\\nint main() {\\n    int n, c;\\n    cin >> n >> c;\\n    vector<pair<char, int>> crimes;\\n    map<char, int> multiplicity;\\n    for (int i = 0; i < c; i++) {\\n        char type;\\n        int m;\\n        cin >> type >> m;\\n        crimes.push_back(make_pair(type, m));\\n        multiplicity[type] = m;\\n    }\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        for (auto crime : crimes) {\\n            char type = crime.first;\\n            int m = crime.second;\\n            if (i >= m && (i % m == 0 || multiplicity[type] > 1)) {\\n                dp[i] = (dp[i] + dp[i - m]) % MOD;\\n            }\\n        }\\n    }\\n    cout << dp[n] << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class CrimeCommitment {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long n = scanner.nextLong();\n        int c = scanner.nextInt();\n        \n        Map<Character, Integer> crimes = new HashMap<>();\n        for (int i = 0; i < c; i++) {\n            char type = scanner.next().charAt(0);\n            int multiplicity = scanner.nextInt();\n            crimes.put(type, multiplicity);\n        }\n        \n        long[] dp = new long[(int) (n + 1)];\n        dp[0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (char crime : crimes.keySet()) {\n                int multiplicity = crimes.get(crime);\n                if (i >= multiplicity) {\n                    dp[i] += dp[i - multiplicity];\n                    dp[i] %= 12345;\n                }\n            }\n        }\n        \n        System.out.println(dp[(int) n]);\n    }\n}","Python":"import itertools\\n\\ndef count_ways(n, c, conditions):\\n    # Create a dictionary to store the multiplicities of each crime\\n    multiplicities = {}\\n    for condition in conditions:\\n        crime_type, multiplicity = condition.split()\\n        multiplicities[crime_type] = int(multiplicity)\\n    \\n    # Create a list to store the possible crimes\\n    crimes = []\\n    for crime_type, multiplicity in multiplicities.items():\\n        if multiplicity == 1:\\n            crimes.append(crime_type)\\n        else:\\n            crimes.extend([crime_type] * (multiplicity - 1))\\n    \\n    # Generate all possible combinations of crimes\\n    combinations = list(itertools.permutations(crimes, n))\\n    \\n    # Count the number of valid combinations\\n    count = 0\\n    for combination in combinations:\\n        valid = True\\n        for condition in conditions:\\n            crime_type, multiplicity = condition.split()\\n            if combination.count(crime_type) % int(multiplicity) != 0:\\n                valid = False\\n                break\\n        if valid:\\n            count += 1\\n    \\n    # Return the count modulo 12345\\n    return str(count % 12345)\\n\\n\\n# Read the input\\nn, c = map(int, input().split())\\nconditions = []\\nfor _ in range(c):\\n    conditions.append(input())\\n\\n# Count the number of ways\\nresult = count_ways(n, c, conditions)\\n\\n# Print the result\\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MOD 12345\\n\\nint main() {\\n    int n, c;\\n    scanf(\\\"%d %d\\\", &n, &c);\\n    int crimes[26] = {0};\\n    int multiplicities[26] = {0};\\n\\n    for (int i = 0; i < c; i++) {\\n        char crime;\\n        int multiplicity;\\n        scanf(\\\" %c %d\\\", &crime, &multiplicity);\\n        crimes[crime - 'A'] = 1;\\n        multiplicities[crime - 'A'] = multiplicity;\\n    }\\n\\n    int dp[n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < 26; j++) {\\n            if (crimes[j] == 1 && i >= multiplicities[j]) {\\n                dp[i] = (dp[i] + dp[i - multiplicities[j]]) % MOD;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", dp[n]);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace CrimeCommitment\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            long n = long.Parse(inputArr[0]);\n            int c = int.Parse(inputArr[1]);\n\n            Dictionary<char, int> crimes = new Dictionary<char, int>();\n\n            for (int i = 0; i < c; i++)\n            {\n                string condition = Console.ReadLine();\n                char crimeType = condition[0];\n                int multiplicity = int.Parse(condition.Substring(2));\n\n                if (!crimes.ContainsKey(crimeType))\n                {\n                    crimes.Add(crimeType, multiplicity);\n                }\n                else\n                {\n                    crimes[crimeType] = Math.Max(crimes[crimeType], multiplicity);\n                }\n            }\n\n            long[] dp = new long[n + 1];\n            dp[0] = 1;\n\n            foreach (var crime in crimes)\n            {\n                for (int i = n; i >= 0; i--)\n                {\n                    for (int j = 1; j <= crime.Value && i - j >= 0; j++)\n                    {\n                        dp[i] = (dp[i] + dp[i - j]) % 12345;\n                    }\n                }\n            }\n\n            Console.WriteLine(dp[n]);\n        }\n    }\n}","Ruby":"\n# Function to calculate the number of ways Zeyad can commit crimes without punishment\ndef calculate_ways(n, c, conditions)\n  # Initialize an array to store the number of ways for each number of crimes committed\n  ways = Array.new(n+1, 0)\n  # Set the number of ways for committing 0 crimes to 1\n  ways[0] = 1\n\n  # Iterate through each condition\n  conditions.each do |condition|\n    crime_type, multiplicity = condition.split(' ')\n    multiplicity = multiplicity.to_i\n\n    # Iterate through each number of crimes committed\n    (1..n).each do |i|\n      # Check if the number of crimes committed is a multiple of the condition's multiplicity\n      if i % multiplicity == 0\n        # Add the number of ways for committing i-multiplicity crimes to the number of ways for committing i crimes\n        ways[i] += ways[i - multiplicity]\n      end\n    end\n  end\n\n  # Return the number of ways for committing n crimes without punishment modulo 12345\n  return ways[n] % 12345\nend\n\n# Read the input values\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nc = input[1].to_i\n\n# Read the conditions\nconditions = []\nc.times do\n  conditions << gets.chomp\nend\n\n# Calculate the number of ways Zeyad can commit crimes without punishment\nresult = calculate_ways(n, c, conditions)\n\n# Output the result\nputs result\n","delphi":"program ZeyadCrimes;\\n\\nvar\\n  n, c, i, j, k, count: Int64;\\n  conditions: array[1..1000] of record\\n    crimeType: Char;\\n    multiplicity: Int64;\\n  end;\\n  ways: array[1..12345] of Int64;\\n\\nbegin\\n  readln(n, c);\\n  for i := 1 to c do\\n  begin\\n    readln(conditions[i].crimeType, conditions[i].multiplicity);\\n  end;\\n\\n  ways[0] := 1;\\n  for i := 1 to n do\\n  begin\\n    count := 0;\\n    for j := 1 to c do\\n    begin\\n      if (i mod conditions[j].multiplicity = 0) or (conditions[j].multiplicity = 1) then\\n      begin\\n        count := (count + ways[i - conditions[j].multiplicity]) mod 12345;\\n      end;\\n    end;\\n    ways[i] := count;\\n  end;\\n\\n  writeln(ways[n]);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, c int\\n\\tfmt.Scan(&n, &c)\\n\\n\\tconditions := make(map[rune]int)\\n\\n\\tfor i := 0; i < c; i++ {\\n\\t\\tvar crimeType rune\\n\\t\\tvar multiplicity int\\n\\t\\tfmt.Scan(&crimeType, &multiplicity)\\n\\t\\tconditions[crimeType] = multiplicity\\n\\t}\\n\\n\\tvar ways int\\n\\n\\tfor _, multiplicity := range conditions {\\n\\t\\tways += n \/ multiplicity\\n\\t}\\n\\n\\tfmt.Println(strconv.Itoa(ways % 12345))\\n}","Javascript":"function countWays(n, c, conditions) {\n    const mod = 12345;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < c; j++) {\n            const [crime, multiplicity] = conditions[j];\n            if (i >= multiplicity) {\n                dp[i] += dp[i - multiplicity];\n                dp[i] %= mod;\n            }\n        }\n    }\n\n    return dp[n];\n}\n\nfunction solveProblem(input) {\n    const lines = input.split('\\\\n');\n    const [n, c] = lines[0].split(' ').map(Number);\n    const conditions = [];\n\n    for (let i = 1; i <= c; i++) {\n        const [crime, multiplicity] = lines[i].split(' ');\n        conditions.push([crime, Number(multiplicity)]);\n    }\n\n    const result = countWays(n, c, conditions);\n    return result.toString();\n}\n\nconst inputs = ['5 2\\\\nA 1\\\\nB 2\\\\n', '6 3\\\\nA 1\\\\nB 2\\\\nC 3\\\\n', '8 3\\\\nA 2\\\\nA 3\\\\nB 2\\\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    const output = solveProblem(inputs[i]);\n    outputs.push(output);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toLong()\n    val c = input[1].toInt()\n\n    val crimes = mutableMapOf<Char, Long>()\n    for (i in 0 until c) {\n        val condition = readLine()!!.split(\" \")\n        val crimeType = condition[0][0]\n        val multiplicity = condition[1].toLong()\n        crimes[crimeType] = multiplicity\n    }\n\n    val ways = countWays(n, crimes)\n    println(ways)\n}\n\nfun countWays(n: Long, crimes: MutableMap<Char, Long>): Long {\n    val dp = LongArray(n.toInt() + 1)\n    dp[0] = 1\n\n    for (i in 1..n.toInt()) {\n        for (crime in crimes) {\n            val crimeType = crime.key\n            val multiplicity = crime.value\n\n            if (i >= multiplicity) {\n                dp[i] = (dp[i] + dp[i - multiplicity.toInt()]) % 12345\n            }\n        }\n    }\n\n    return dp[n.toInt()]\n}","PHP":"<?php\\n\\nfunction countWays($n, $c, $conditions) {\\n    $mod = 12345;\\n    $dp = array_fill(0, $n + 1, 0);\\n    $dp[0] = 1;\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        foreach ($conditions as $condition) {\\n            $type = $condition[0];\\n            $multiplicity = $condition[1];\\n\\n            if ($i >= $multiplicity) {\\n                $dp[$i] += $dp[$i - $multiplicity];\\n                $dp[$i] %= $mod;\\n            }\\n        }\\n    }\\n\\n    return $dp[$n];\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\nlist($n, $c) = explode(\\\" \\\", $input[0]);\\n$conditions = array();\\n\\nfor ($i = 1; $i <= $c; $i++) {\\n    list($type, $multiplicity) = explode(\\\" \\\", $input[$i]);\\n    $conditions[] = array($type, $multiplicity);\\n}\\n\\n$result = countWays($n, $c, $conditions);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nint mod = 12345;\\r\\n\\r\\nstruct Crime\\r\\n{\\r\\n    char type;\\r\\n    int multiplicity;\\r\\n}\\r\\n\\r\\nint countWays(int n, Crime[] crimes)\\r\\n{\\r\\n    int[] dp = new int[n + 1];\\r\\n    dp[0] = 1;\\r\\n\\r\\n    foreach (crime; crimes)\\r\\n    {\\r\\n        for (int i = crime.multiplicity; i <= n; i++)\\r\\n        {\\r\\n            dp[i] += dp[i - crime.multiplicity];\\r\\n            dp[i] %= mod;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return dp[n];\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, c;\\r\\n    readf(\\\"%d %d\\\\n\\\", &n, &c);\\r\\n\\r\\n    Crime[] crimes;\\r\\n\\r\\n    foreach (_; 0..c)\\r\\n    {\\r\\n        char type;\\r\\n        int multiplicity;\\r\\n        readf(\\\"%c %d\\\\n\\\", &type, &multiplicity);\\r\\n        crimes ~= Crime(type, multiplicity);\\r\\n    }\\r\\n\\r\\n    int ways = countWays(n, crimes);\\r\\n    writef(\\\"%d\\\\n\\\", ways);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_ways {\n    my ($n, $c, @conditions) = @_;\n\n    my %crimes;\n    foreach my $condition (@conditions) {\n        my ($type, $multiplicity) = split(' ', $condition);\n        $crimes{$type} = $multiplicity;\n    }\n\n    my @types = keys %crimes;\n    my $num_types = scalar @types;\n\n    my @dp;\n    $dp[0][0] = 1;\n\n    for (my $i = 1; $i <= $n; $i++) {\n        for (my $j = 0; $j < $num_types; $j++) {\n            my $type = $types[$j];\n            my $multiplicity = $crimes{$type};\n\n            $dp[$i][$j] = $dp[$i-1][$j];\n\n            for (my $k = 1; $k <= $multiplicity; $k++) {\n                if ($i >= $k) {\n                    $dp[$i][$j] += $dp[$i-$k][$j-1];\n                    $dp[$i][$j] %= 12345;\n                }\n            }\n        }\n    }\n\n    return $dp[$n][$num_types-1];\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $c) = split(' ', $input);\n\nmy @conditions;\nfor (my $i = 0; $i < $c; $i++) {\n    my $condition = <STDIN>;\n    chomp $condition;\n    push @conditions, $condition;\n}\n\n# Count the number of ways\nmy $num_ways = count_ways($n, $c, @conditions);\n\n# Print the result\nprint $num_ways;\n","Rust":"fn main() {\\n    let input = std::fs::read_to_string(\\\"input.txt\\\").unwrap();\\n    let mut lines = input.lines();\\n    let nc: Vec<u64> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nc[0];\\n    let c = nc[1];\\n\\n    let mut crimes: Vec<(char, u64)> = Vec::new();\\n    for _ in 0..c {\\n        let crime: Vec<&str> = lines.next().unwrap().split_whitespace().collect();\\n        let crime_type = crime[0].chars().next().unwrap();\\n        let multiplicity: u64 = crime[1].parse().unwrap();\\n        crimes.push((crime_type, multiplicity));\\n    }\\n\\n    let mut dp: Vec<u64> = vec![0; (n + 1) as usize];\\n    dp[0] = 1;\\n\\n    for i in 1..=n {\\n        for &(crime_type, multiplicity) in &crimes {\\n            if i >= multiplicity {\\n                dp[i as usize] += dp[(i - multiplicity) as usize];\\n                dp[i as usize] %= 12345;\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", dp[n as usize]);\\n}"}
{"title":"D1. Great Vova Wall (Version 1)","description":"Vova's family is building the Great Vova Wall (named by Vova himself). Vova's parents, grandparents, grand-grandparents contributed to it. Now it's totally up to Vova to put the finishing touches.The current state of the wall can be respresented by a sequence $$$a$$$ of $$$n$$$ integers, with $$$a_i$$$ being the height of the $$$i$$$-th part of the wall.Vova can only use $$$2 \\times 1$$$ bricks to put in the wall (he has infinite supply of them, however).Vova can put bricks horizontally on the neighboring parts of the wall of equal height. It means that if for some $$$i$$$ the current height of part $$$i$$$ is the same as for part $$$i + 1$$$, then Vova can put a brick there and thus increase both heights by 1. Obviously, Vova can't put bricks in such a way that its parts turn out to be off the borders (to the left of part $$$1$$$ of the wall or to the right of part $$$n$$$ of it).The next paragraph is specific to the version 1 of the problem.Vova can also put bricks vertically. That means increasing height of any part of the wall by 2.Vova is a perfectionist, so he considers the wall completed when:  all parts of the wall has the same height;  the wall has no empty spaces inside it. Can Vova complete the wall using any amount of bricks (possibly zero)?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$) \u2014 the number of parts in the wall.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le 10^9$$$) \u2014 the initial heights of the parts of the wall.\n","output_spec":"Print \"YES\" if Vova can complete the wall using any amount of bricks (possibly zero).\nPrint \"NO\" otherwise.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1092-D1","difficulty":2200,"tags":["greedy","implementation","math"],"src_uid":"bb4ecfaaccd538e23f883a18f9672af8","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> heights(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> heights[i];\\n    }\\n    sort(heights.begin(), heights.end());\\n    int min_height = heights[0];\\n    int max_height = heights[n-1];\\n    int count_min = 0;\\n    int count_max = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (heights[i] == min_height) {\\n            count_min++;\\n        }\\n        if (heights[i] == max_height) {\\n            count_max++;\\n        }\\n    }\\n    if (count_min == n || count_max == n || (count_min % 2 == 0 && count_max % 2 == 0)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] heights = new int[n];\n        for (int i = 0; i < n; i++) {\n            heights[i] = scanner.nextInt();\n        }\n        \n        boolean canComplete = true;\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n            min = Math.min(min, heights[i]);\n            max = Math.max(max, heights[i]);\n        }\n        \n        int countMin = 0;\n        int countMax = 0;\n        for (int i = 0; i < n; i++) {\n            if (heights[i] == min) {\n                countMin++;\n            } else if (heights[i] == max) {\n                countMax++;\n            } else {\n                canComplete = false;\n                break;\n            }\n        }\n        \n        if (countMin == n || countMax == n || (countMin % 2 == 0 && countMax % 2 == 0)) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n}","Python":"def can_complete_wall(n, heights):\\n    min_height = min(heights)\\n    max_height = max(heights)\\n    if min_height == max_height:\\n        return 'YES'\\n    if (max_height - min_height) % 2 == 0:\\n        for height in heights:\\n            if height != min_height and height != max_height:\\n                return 'NO'\\n        return 'YES'\\n    else:\\n        return 'NO'\\n\\nn = int(input())\\nheights = list(map(int, input().split()))\\n\\nprint(can_complete_wall(n, heights))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int min_height = a[0];\\n    int max_height = a[0];\\n\\n    for (int i = 1; i < n; i++) {\\n        if (a[i] < min_height) {\\n            min_height = a[i];\\n        }\\n        if (a[i] > max_height) {\\n            max_height = a[i];\\n        }\\n    }\\n\\n    int count_min = 0;\\n    int count_max = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] == min_height) {\\n            count_min++;\\n        }\\n        if (a[i] == max_height) {\\n            count_max++;\\n        }\\n    }\\n\\n    if (count_min == n || count_max == n || (count_min % 2 == 0 && count_max % 2 == 0)) {\\n        printf(\\\"YES\\\");\\n    } else {\\n        printf(\\\"NO\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] heights = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n        bool canComplete = true;\n        int minHeight = int.MaxValue;\n        int maxHeight = int.MinValue;\n\n        for (int i = 0; i < n; i++)\n        {\n            if (heights[i] < minHeight)\n                minHeight = heights[i];\n            if (heights[i] > maxHeight)\n                maxHeight = heights[i];\n        }\n\n        int countMinHeight = 0;\n        int countMaxHeight = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            if (heights[i] == minHeight)\n                countMinHeight++;\n            if (heights[i] == maxHeight)\n                countMaxHeight++;\n        }\n\n        if (countMinHeight + countMaxHeight == n && Math.Abs(countMinHeight - countMaxHeight) <= 1)\n            canComplete = true;\n        else if (countMinHeight + countMaxHeight == n - 1 && Math.Abs(countMinHeight - countMaxHeight) <= 1)\n            canComplete = true;\n        else\n            canComplete = false;\n\n        if (canComplete)\n            Console.WriteLine(\"YES\");\n        else\n            Console.WriteLine(\"NO\");\n    }\n}","Ruby":"\ndef can_complete_wall(n, heights)\n  # Sort the heights in ascending order\n  sorted_heights = heights.sort\n\n  # Check if all heights are the same\n  if sorted_heights.uniq.length == 1\n    return 'YES'\n  end\n\n  # Check if the difference between adjacent heights is even\n  for i in 0..n-2\n    if (sorted_heights[i+1] - sorted_heights[i]) % 2 != 0\n      return 'NO'\n    end\n  end\n\n  # Check if the difference between the first and last heights is even\n  if (sorted_heights[-1] - sorted_heights[0]) % 2 != 0\n    return 'NO'\n  end\n\n  return 'YES'\nend\n\n# Read input\nn = gets.chomp.to_i\nheights = gets.chomp.split.map(&:to_i)\n\n# Call the function and print the result\nputs can_complete_wall(n, heights)\n","delphi":"program GreatVovaWall;\\n\\nvar\\n  n, i, maxHeight, minHeight, maxCount, minCount: integer;\\n  a: array[1..200000] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(a[i]);\\n\\n  maxHeight := a[1];\\n  minHeight := a[1];\\n  maxCount := 0;\\n  minCount := 0;\\n\\n  for i := 1 to n do\\n  begin\\n    if a[i] > maxHeight then\\n    begin\\n      maxHeight := a[i];\\n      maxCount := 1;\\n    end\\n    else if a[i] = maxHeight then\\n      Inc(maxCount)\\n    else if a[i] < minHeight then\\n    begin\\n      minHeight := a[i];\\n      minCount := 1;\\n    end\\n    else if a[i] = minHeight then\\n      Inc(minCount);\\n  end;\\n\\n  if (maxHeight - minHeight <= 1) or (minCount mod 2 = 0) then\\n    writeln('YES')\\n  else\\n    writeln('NO');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\ta := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&a[i])\\n\\t}\\n\\n\\tsort.Ints(a)\\n\\n\\tminHeight := a[0]\\n\\tmaxHeight := a[n-1]\\n\\n\\tif minHeight == maxHeight {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tif (maxHeight-minHeight)%2 == 0 {\\n\\t\\t\\tfmt.Println(\\\"YES\\\")\\n\\t\\t} else {\\n\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t}\\n\\t}\\n}","Javascript":"\nfunction canCompleteWall(n, heights) {\n    \/\/ Sort the heights in ascending order\n    heights.sort((a, b) => a - b);\n    \n    \/\/ Check if all heights are equal\n    for (let i = 1; i < n; i++) {\n        if (heights[i] !== heights[0]) {\n            return 'NO';\n        }\n    }\n    \n    \/\/ Check if the difference between adjacent heights is even\n    for (let i = 1; i < n; i++) {\n        if ((heights[i] - heights[i-1]) % 2 !== 0) {\n            return 'NO';\n        }\n    }\n    \n    return 'YES';\n}\n\n\/\/ Read input\nconst n = parseInt(readline());\nconst heights = readline().split(' ').map(Number);\n\n\/\/ Call the function and print the result\nconst result = canCompleteWall(n, heights);\nconsole.log(result);\n","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val heights = IntArray(n)\n    for (i in 0 until n) {\n        heights[i] = scanner.nextInt()\n    }\n    \n    val max = heights.maxOrNull() ?: 0\n    val min = heights.minOrNull() ?: 0\n    \n    val countMax = heights.count { it == max }\n    val countMin = heights.count { it == min }\n    \n    if (countMax == n || countMin == n || (countMax % 2 == 0 && countMin % 2 == 0)) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"\n<?php\n\nfunction canCompleteWall($n, $a) {\n    \/\/ Check if all parts of the wall have the same height\n    $height = $a[0];\n    for ($i = 1; $i < $n; $i++) {\n        if ($a[$i] != $height) {\n            return 'NO';\n        }\n    }\n    \n    \/\/ Check if the wall has no empty spaces inside it\n    for ($i = 0; $i < $n - 1; $i++) {\n        if ($a[$i] > $a[$i + 1]) {\n            return 'NO';\n        }\n    }\n    \n    return 'YES';\n}\n\n\/\/ Read input\n$n = intval(trim(fgets(STDIN)));\n$a = array_map('intval', explode(' ', trim(fgets(STDIN))));\n\n\/\/ Call the function and print the result\n$result = canCompleteWall($n, $a);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] heights;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    heights = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &heights[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Sort the heights in ascending order\\r\\n    heights.sort();\\r\\n\\r\\n    \/\/ Check if all heights are the same\\r\\n    bool allSame = heights[0] == heights[$-1];\\r\\n\\r\\n    \/\/ Check if the difference between any two adjacent heights is greater than 1\\r\\n    bool valid = true;\\r\\n    foreach (i; 0..n-1)\\r\\n    {\\r\\n        if (heights[i+1] - heights[i] > 1)\\r\\n        {\\r\\n            valid = false;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    if (allSame || valid)\\r\\n    {\\r\\n        writeln(\\\"YES\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\n# Read input\nmy $n = <>;\nchomp $n;\nmy $parts = <>;\nchomp $parts;\nmy @heights = split ' ', $parts;\n\n# Check if all heights are equal\nmy $first_height = $heights[0];\nmy $all_equal = 1;\nforeach my $height (@heights) {\n    if ($height != $first_height) {\n        $all_equal = 0;\n        last;\n    }\n}\n\n# Check if the wall can be completed\nmy $can_complete = 1;\nfor (my $i = 0; $i < $n - 1; $i++) {\n    if ($heights[$i] > $heights[$i+1]) {\n        my $diff = $heights[$i] - $heights[$i+1];\n        if ($diff % 2 != 0) {\n            $can_complete = 0;\n            last;\n        }\n    }\n}\n\n# Print the result\nif ($all_equal && $can_complete) {\n    print \\\"YES\\\";\n} else {\n    print \\\"NO\\\";\n}\n","Rust":"\nuse std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    let mut lines = input.lines();\n    let _n: usize = lines.next().unwrap().parse().unwrap();\n    let heights: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut min_height = heights[0];\n    let mut max_height = heights[0];\n    let mut total_bricks = 0;\n\n    for i in 1..heights.len() {\n        if heights[i] < min_height || heights[i] > max_height {\n            println!(\"NO\");\n            return;\n        }\n\n        if heights[i] == min_height {\n            min_height = heights[i];\n        } else if heights[i] == max_height {\n            max_height = heights[i];\n        } else {\n            total_bricks += heights[i] - min_height;\n            min_height = heights[i];\n            max_height = heights[i];\n        }\n    }\n\n    if total_bricks % 2 == 0 {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\n"}
{"title":"E. Lucky Interval","description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya came across an interval of numbers [a,a+l-1]. Let F(x) be the number of lucky digits of number x. Find the minimum b (a<b) such, that F(a) = F(b), F(a+1) = F(b+1), ..., F(a+l-1) = F(b+l-1).","input_from":"standard input","output_to":"standard output","time_limit":"4 seconds","memory_limit":"512 megabytes","input_spec":"The single line contains two integers a and l (1\u2264a,l\u226410^9) \u2014 the interval's first number and the interval's length correspondingly.\n","output_spec":"On the single line print number b \u2014 the answer to the problem.\n","notes":"Consider that [a,b] denotes an interval of integers; this interval includes the boundaries. That is, \n","sample_inputs":["7 4\n","4 7\n"],"sample_outputs":["17\n","14\n"],"id":"109-E","difficulty":2700,"tags":["brute+force","math"],"src_uid":"649e9f477b97c1f72b05d409b4a99d59","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint countLuckyDigits(int num) {\\n    int count = 0;\\n    while (num > 0) {\\n        int digit = num % 10;\\n        if (digit == 4 || digit == 7) {\\n            count++;\\n        }\\n        num \/= 10;\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    int a, l;\\n    cin >> a >> l;\\n\\n    vector<int> luckyDigits(l);\\n    for (int i = 0; i < l; i++) {\\n        luckyDigits[i] = countLuckyDigits(a + i);\\n    }\\n\\n    int b = a + 1;\\n    while (true) {\\n        bool found = true;\\n        for (int i = 0; i < l; i++) {\\n            if (countLuckyDigits(b + i) != luckyDigits[i]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        if (found) {\\n            break;\\n        }\\n        b++;\\n    }\\n\\n    cout << b << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class LuckyNumbers {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int a = scanner.nextInt();\\n        int l = scanner.nextInt();\\n\\n        int[] luckyDigits = {4, 7};\\n\\n        int[] aDigits = countLuckyDigits(a, luckyDigits);\\n\\n        int b = a + 1;\\n        while (true) {\\n            int[] bDigits = countLuckyDigits(b, luckyDigits);\\n\\n            if (compareDigits(aDigits, bDigits)) {\\n                break;\\n            }\\n\\n            b++;\\n        }\\n\\n        System.out.println(b);\\n    }\\n\\n    private static int[] countLuckyDigits(int number, int[] luckyDigits) {\\n        int[] digitsCount = new int[luckyDigits.length];\\n\\n        while (number > 0) {\\n            int digit = number % 10;\\n\\n            for (int i = 0; i < luckyDigits.length; i++) {\\n                if (digit == luckyDigits[i]) {\\n                    digitsCount[i]++;\\n                }\\n            }\\n\\n            number \/= 10;\\n        }\\n\\n        return digitsCount;\\n    }\\n\\n    private static boolean compareDigits(int[] aDigits, int[] bDigits) {\\n        for (int i = 0; i < aDigits.length; i++) {\\n            if (aDigits[i] != bDigits[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\"}\n","Python":"def find_minimum_b(a, l):\\n    def count_lucky_digits(n):\\n        count = 0\\n        while n > 0:\\n            if n % 10 == 4 or n % 10 == 7:\\n                count += 1\\n            n \/\/= 10\\n        return count\\n\\n    b = a\\n    while True:\\n        lucky_digits_a = count_lucky_digits(a)\\n        lucky_digits_b = count_lucky_digits(b)\\n        if lucky_digits_a == lucky_digits_b:\\n            return b\\n        b += 1\\n\\n\\n# Example usage\\na, l = map(int, input().split())\\nminimum_b = find_minimum_b(a, l)\\nprint(minimum_b)","C":"#include <stdio.h>\\n\\nint count_lucky_digits(int num) {\\n    int count = 0;\\n    while (num > 0) {\\n        int digit = num % 10;\\n        if (digit == 4 || digit == 7) {\\n            count++;\\n        }\\n        num \/= 10;\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    int a, l;\\n    scanf(\\\"%d %d\\\", &a, &l);\\n\\n    int lucky_digits_a = count_lucky_digits(a);\\n\\n    int b = a + 1;\\n    while (count_lucky_digits(b) != lucky_digits_a) {\\n        b++;\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", b);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int a = int.Parse(input[0]);\n        int l = int.Parse(input[1]);\n        \n        int luckyDigitsA = CountLuckyDigits(a);\n        int b = a;\n        \n        while (CountLuckyDigits(b) != luckyDigitsA)\n        {\n            b++;\n        }\n        \n        Console.WriteLine(b);\n    }\n    \n    public static int CountLuckyDigits(int number)\n    {\n        int count = 0;\n        \n        while (number > 0)\n        {\n            int digit = number % 10;\n            if (digit == 4 || digit == 7)\n            {\n                count++;\n            }\n            \n            number \/= 10;\n        }\n        \n        return count;\n    }\n}","Ruby":"def lucky_numbers(a, l)\\n  count_a = count_lucky_digits(a)\\n\\n  (a+1..a+l-1).each do |num|\\n    count_b = count_lucky_digits(num)\\n    return num if count_a == count_b\\n  end\\nend\\n\\n\\ndef count_lucky_digits(num)\\n  count = 0\\n  num.to_s.chars.each do |digit|\\n    count += 1 if digit == '4' || digit == '7'\\n  end\\n  count\\nend\\n\\n\\na, l = gets.chomp.split.map(&:to_i)\\n\\nb = lucky_numbers(a, l)\\nputs b","delphi":"var\\n  a, l, b: Int64;\\n  i, countA, countB: Integer;\\nbegin\\n  Readln(a, l);\\n  countA := 0;\\n  for i := 0 to l-1 do\\n  begin\\n    if (a+i) mod 10 = 4 or (a+i) mod 10 = 7 then\\n      Inc(countA);\\n  end;\\n  b := a;\\n  countB := countA;\\n  while countB <> countA do\\n  begin\\n    Inc(b);\\n    countB := 0;\\n    for i := 0 to l-1 do\\n    begin\\n      if (b+i) mod 10 = 4 or (b+i) mod 10 = 7 then\\n        Inc(countB);\\n    end;\\n  end;\\n  Writeln(b);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc countLuckyDigits(n int) int {\\n\\tcount := 0\\n\\tnStr := strconv.Itoa(n)\\n\\n\\tfor _, digit := range nStr {\\n\\t\\tif digit == '4' || digit == '7' {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n\\nfunc findMinimumB(a, l int) int {\\n\\tfor i := a + 1; ; i++ {\\n\\t\\tif countLuckyDigits(i) == countLuckyDigits(a) {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc main() {\\n\\ta := 7\\n\\tl := 4\\n\\n\\tb := findMinimumB(a, l)\\n\\n\\tfmt.Println(b)\\n}","Javascript":"function countLuckyDigits(num) {\n    let count = 0;\n    while (num > 0) {\n        let digit = num % 10;\n        if (digit === 4 || digit === 7) {\n            count++;\n        }\n        num = Math.floor(num \/ 10);\n    }\n    return count;\n}\n\nfunction findMinimumB(a, l) {\n    let luckyDigitsA = countLuckyDigits(a);\n    let b = a + 1;\n    while (true) {\n        let luckyDigitsB = countLuckyDigits(b);\n        if (luckyDigitsA === luckyDigitsB) {\n            return b;\n        }\n        b++;\n    }\n}\n\n\/\/ Read input\nconst input = readline().split(' ');\nconst a = parseInt(input[0]);\nconst l = parseInt(input[1]);\n\n\/\/ Find minimum b\nconst b = findMinimumB(a, l);\n\n\/\/ Print output\nconsole.log(b);","Kotlin":"fun main() {\\n    val (a, l) = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val luckyDigits = listOf('4', '7')\\n    var b = a\\n    var countA = 0\\n    var countB = 0\\n\\n    for (i in 0 until l) {\\n        val digitsA = b.toString().toCharArray()\\n        val digitsB = (b + l).toString().toCharArray()\\n\\n        countA = digitsA.count { it in luckyDigits }\\n        countB = digitsB.count { it in luckyDigits }\\n\\n        if (countA == countB) {\\n            break\\n        }\\n\\n        b++\\n    }\\n\\n    println(b)\\n}","PHP":"<?php\\n\\nfunction countLuckyDigits($num)\\n{\\n    $count = 0;\\n    while ($num > 0) {\\n        $digit = $num % 10;\\n        if ($digit == 4 || $digit == 7) {\\n            $count++;\\n        }\\n        $num = (int)($num \/ 10);\\n    }\\n    return $count;\\n}\\n\\nfunction findMinimumB($a, $l)\\n{\\n    $luckyDigitsA = countLuckyDigits($a);\\n    $b = $a + 1;\\n    while (countLuckyDigits($b) != $luckyDigitsA) {\\n        $b++;\\n    }\\n    return $b;\\n}\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$a = (int)$input[0];\\n$l = (int)$input[1];\\n\\n$result = findMinimumB($a, $l);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint countLuckyDigits(int num)\\r\\n{\\r\\n    int count = 0;\\r\\n    while (num > 0)\\r\\n    {\\r\\n        int digit = num % 10;\\r\\n        if (digit == 4 || digit == 7)\\r\\n            count++;\\r\\n        num \/= 10;\\r\\n    }\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int a, l;\\r\\n    readf(\\\"%d %d\\\", &a, &l);\\r\\n\\r\\n    int luckyDigits = countLuckyDigits(a);\\r\\n\\r\\n    int b = a;\\r\\n    while (countLuckyDigits(b) != luckyDigits)\\r\\n        b++;\\r\\n\\r\\n    writeln(to!string(b));\\r\\n}","perl":"\n# Function to count the number of lucky digits in a number\nsub count_lucky_digits {\n    my ($num) = @_;\n    my $count = 0;\n    while ($num > 0) {\n        my $digit = $num % 10;\n        if ($digit == 4 || $digit == 7) {\n            $count++;\n        }\n        $num = int($num \/ 10);\n    }\n    return $count;\n}\n\n# Read input values\nmy $input = <STDIN>;\nchomp $input;\nmy ($a, $l) = split(' ', $input);\n\n# Find the minimum b\nmy $b = $a + 1;\nwhile (count_lucky_digits($a) != count_lucky_digits($b)) {\n    $b++;\n}\n\n# Print the result\nprint $b;\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buffer = String::new();\n    input.read_line(&mut buffer).unwrap();\n    let mut iter = buffer.split_whitespace();\n    let a: u32 = iter.next().unwrap().parse().unwrap();\n    let l: u32 = iter.next().unwrap().parse().unwrap();\n\n    let mut count_a = 0;\n    let mut count_b = 0;\n    let mut current = a;\n\n    \/\/ Count the number of lucky digits in a\n    while current > 0 {\n        let digit = current % 10;\n        if digit == 4 || digit == 7 {\n            count_a += 1;\n        }\n        current \/= 10;\n    }\n\n    \/\/ Find the minimum b such that F(a) = F(b)\n    let mut b = a + 1;\n    while count_a != count_b {\n        current = b;\n        count_b = 0;\n\n        \/\/ Count the number of lucky digits in b\n        while current > 0 {\n            let digit = current % 10;\n            if digit == 4 || digit == 7 {\n                count_b += 1;\n            }\n            current \/= 10;\n        }\n\n        b += 1;\n    }\n\n    println!(\"{}\", b - 1);\n}"}
{"title":"C. Digital Root","description":"Not long ago Billy came across such a problem, where there were given three natural numbers A, B and C from the range [1,N], and it was asked to check whether the equation AB=C is correct. Recently Billy studied the concept of a digital root of a number. We should remind you that a digital root d(x) of the number x is the sum s(x) of all the digits of this number, if s(x)\u22649, otherwise it is d(s(x)). For example, a digital root of the number 6543 is calculated as follows: d(6543)=d(6+5+4+3)=d(18)=9. Billy has counted that the digital root of a product of numbers is equal to the digital root of the product of the factors' digital roots, i.e. d(xy)=d(d(x)d(y)). And the following solution to the problem came to his mind: to calculate the digital roots and check if this condition is met. However, Billy has doubts that this condition is sufficient. That's why he asks you to find out the amount of test examples for the given problem such that the algorithm proposed by Billy makes mistakes.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains the only number N (1\u2264N\u226410^6).\n","output_spec":"Output one number \u2014 the amount of required A, B and C from the range [1,N].\n","notes":"For the first sample the required triples are (3,4,3) and (4,3,3).\n","sample_inputs":["4\n","5\n"],"sample_outputs":["2\n","6\n"],"id":"10-C","difficulty":2000,"tags":["number+theory"],"src_uid":"fc133fe6353089a0ebee08dec919f608","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nint digitalRoot(int n) {\\n    if (n == 0) {\\n        return 0;\\n    }\\n    return (n % 9 == 0) ? 9 : (n % 9);\\n}\\n\\nint main() {\\n    int N;\\n    cin >> N;\\n\\n    int count = 0;\\n\\n    for (int A = 1; A <= N; A++) {\\n        for (int B = 1; B <= N; B++) {\\n            int C = digitalRoot(digitalRoot(A) * digitalRoot(B));\\n            if (C != digitalRoot(A * B)) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int N = scanner.nextInt();\\n        int count = 0;\\n\\n        for (int A = 1; A <= N; A++) {\\n            for (int B = 1; B <= N; B++) {\\n                int C = A * B;\\n                int digitalRootAB = digitalRoot(A) * digitalRoot(B);\\n                int digitalRootC = digitalRoot(C);\\n\\n                if (digitalRootAB != digitalRootC) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n\\n    public static int digitalRoot(int num) {\\n        int sum = 0;\\n\\n        while (num > 0) {\\n            sum += num % 10;\\n            num \/= 10;\\n        }\\n\\n        if (sum > 9) {\\n            return digitalRoot(sum);\\n        }\\n\\n        return sum;\\n    }\\n}","Python":"def digital_root(n):\\n    while n > 9:\\n        n = sum(int(digit) for digit in str(n))\\n    return n\\n\\ndef count_mistakes(N):\\n    count = 0\\n    for A in range(1, N+1):\\n        for B in range(1, N+1):\\n            C = digital_root(A) * digital_root(B)\\n            if digital_root(A * B) != C:\\n                count += 1\\n    return count\\n\\nN = int(input())\\nresult = count_mistakes(N)\\nprint(result)","C":"#include <stdio.h>\\n\\nint digitalRoot(int n) {\\n    if (n == 0) {\\n        return 0;\\n    }\\n    return (n % 9 == 0) ? 9 : (n % 9);\\n}\\n\\nint main() {\\n    int N;\\n    scanf(\\\"%d\\\", &N);\\n\\n    int count = 0;\\n\\n    for (int A = 1; A <= N; A++) {\\n        for (int B = 1; B <= N; B++) {\\n            int AB = digitalRoot(digitalRoot(A) * digitalRoot(B));\\n            int C = digitalRoot(A * B);\\n\\n            if (AB != C) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int N = int.Parse(Console.ReadLine());\n        int count = 0;\n\n        for (int A = 1; A <= N; A++)\n        {\n            for (int B = 1; B <= N; B++)\n            {\n                int C = A * B;\n                int digitalRootAB = CalculateDigitalRoot(A) * CalculateDigitalRoot(B);\n                int digitalRootC = CalculateDigitalRoot(C);\n\n                if (digitalRootAB != digitalRootC)\n                {\n                    count++;\n                }\n            }\n        }\n\n        Console.WriteLine(count);\n    }\n\n    static int CalculateDigitalRoot(int number)\n    {\n        while (number > 9)\n        {\n            int sum = 0;\n            while (number != 0)\n            {\n                sum += number % 10;\n                number \/= 10;\n            }\n            number = sum;\n        }\n        return number;\n    }\n}","Ruby":"\ndef digital_root(n)\n  while n > 9\n    n = n.to_s.chars.map(&:to_i).sum\n  end\n  return n\nend\n\ndef count_mistakes(n)\n  count = 0\n  for a in 1..n\n    for b in 1..n\n      c = digital_root(a) * digital_root(b)\n      if digital_root(c) != digital_root(a * b)\n        count += 1\n      end\n    end\n  end\n  return count\nend\n\nn = gets.to_i\nputs count_mistakes(n)\n","delphi":"program DigitalRoot;\n\nvar\n  N, count: Integer;\n\nfunction DigitalRoot(num: Integer): Integer;\nvar\n  sum: Integer;\nbegin\n  sum := 0;\n  while num > 0 do\n  begin\n    sum := sum + (num mod 10);\n    num := num div 10;\n  end;\n  \n  if sum > 9 then\n    sum := DigitalRoot(sum);\n  \n  Result := sum;\nend;\n\nbegin\n  Readln(N);\n  \n  count := 0;\n  \n  for var A := 1 to N do\n  begin\n    for var B := 1 to N do\n    begin\n      var C := A * B;\n      if DigitalRoot(A) * DigitalRoot(B) <> DigitalRoot(C) then\n        Inc(count);\n    end;\n  end;\n  \n  Writeln(count);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc digitalRoot(n int) int {\\n\\tsum := 0\\n\\tfor n > 0 {\\n\\t\\tsum += n % 10\\n\\t\\tn \/= 10\\n\\t}\\n\\tif sum > 9 {\\n\\t\\treturn digitalRoot(sum)\\n\\t}\\n\\treturn sum\\n}\\n\\nfunc main() {\\n\\tvar N int\\n\\tfmt.Scan(&N)\\n\\n\\tcount := 0\\n\\n\\tfor A := 1; A <= N; A++ {\\n\\t\\tfor B := 1; B <= N; B++ {\\n\\t\\t\\tC := digitalRoot(A) * digitalRoot(B)\\n\\t\\t\\tif digitalRoot(C) != digitalRoot(A*B) {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function calculateMistakes(N) {\n    let count = 0;\n    \n    for (let A = 1; A <= N; A++) {\n        for (let B = 1; B <= N; B++) {\n            let C = A * B;\n            let digitalRootAB = calculateDigitalRoot(A) * calculateDigitalRoot(B);\n            let digitalRootC = calculateDigitalRoot(C);\n            \n            if (digitalRootAB !== digitalRootC) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n\nfunction calculateDigitalRoot(number) {\n    let sum = 0;\n    \n    while (number > 0) {\n        sum += number % 10;\n        number = Math.floor(number \/ 10);\n    }\n    \n    if (sum > 9) {\n        return calculateDigitalRoot(sum);\n    }\n    \n    return sum;\n}\n\nconst input = '4\\n';\nconst N = parseInt(input.trim());\nconst mistakes = calculateMistakes(N);\n\nconsole.log(mistakes);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    \n    var count = 0\n    \n    for (a in 1..n) {\n        for (b in 1..n) {\n            val c = a * b\n            val digitalRootAB = digitalRoot(a) * digitalRoot(b)\n            val digitalRootC = digitalRoot(c)\n            \n            if (digitalRootAB != digitalRootC) {\n                count++\n            }\n        }\n    }\n    \n    println(count)\n}\n\nfun digitalRoot(num: Int): Int {\n    var sum = num\n    while (sum > 9) {\n        sum = sum.toString().map { it.toString().toInt() }.sum()\n    }\n    return sum\n}","PHP":"<?php\\n\\nfunction digitalRoot($num) {\\n    while ($num > 9) {\\n        $sum = 0;\\n        while ($num > 0) {\\n            $sum += $num % 10;\\n            $num = (int)($num \/ 10);\\n        }\\n        $num = $sum;\\n    }\\n    return $num;\\n}\\n\\nfunction countMistakes($N) {\\n    $count = 0;\\n    for ($A = 1; $A <= $N; $A++) {\\n        for ($B = 1; $B <= $N; $B++) {\\n            $C = digitalRoot(digitalRoot($A) * digitalRoot($B));\\n            if ($C != digitalRoot($A * $B)) {\\n                $count++;\\n            }\\n        }\\n    }\\n    return $count;\\n}\\n\\n$N = intval(fgets(STDIN));\\n$result = countMistakes($N);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int N;\\r\\n    readf(\\\"%d\\\", &N);\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    for (int A = 1; A <= N; A++)\\r\\n    {\\r\\n        for (int B = 1; B <= N; B++)\\r\\n        {\\r\\n            int C = A * B;\\r\\n\\r\\n            int digitalRootAB = (A % 9 == 0) ? 9 : A % 9;\\r\\n            int digitalRootC = (C % 9 == 0) ? 9 : C % 9;\\r\\n\\r\\n            int digitalRootProduct = ((digitalRootAB * digitalRootC) % 9 == 0) ? 9 : (digitalRootAB * digitalRootC) % 9;\\r\\n\\r\\n            if (digitalRootProduct != digitalRootC)\\r\\n            {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub digital_root {\n    my ($num) = @_;\n    my $sum = 0;\n    while ($num > 0) {\n        $sum += $num % 10;\n        $num = int($num \/ 10);\n    }\n    return $sum > 9 ? digital_root($sum) : $sum;\n}\n\nsub count_mistakes {\n    my ($n) = @_;\n    my $count = 0;\n    for my $a (1..$n) {\n        for my $b (1..$n) {\n            my $c = digital_root($a) * digital_root($b);\n            if (digital_root($c) != digital_root($a * $b)) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\nmy $n = <STDIN>;\nchomp($n);\n\nmy $mistakes = count_mistakes($n);\nprint $mistakes;\n","Rust":"fn main() {\n    let n: u64 = 4;\n    let mut count = 0;\n\n    for a in 1..=n {\n        for b in 1..=n {\n            let c = a * b;\n            let digital_root_ab = digital_root(a) * digital_root(b);\n            let digital_root_c = digital_root(c);\n\n            if digital_root_ab != digital_root_c {\n                count += 1;\n            }\n        }\n    }\n\n    println!(\"{}\", count);\n}\n\nfn digital_root(mut num: u64) -> u64 {\n    while num > 9 {\n        let mut sum = 0;\n        while num > 0 {\n            sum += num % 10;\n            num \/= 10;\n        }\n        num = sum;\n    }\n    num\n}"}
{"title":"B. Array K-Coloring","description":"You are given an array $$$a$$$ consisting of $$$n$$$ integer numbers.You have to color this array in $$$k$$$ colors in such a way that:   Each element of the array should be colored in some color;  For each $$$i$$$ from $$$1$$$ to $$$k$$$ there should be at least one element colored in the $$$i$$$-th color in the array;  For each $$$i$$$ from $$$1$$$ to $$$k$$$ all elements colored in the $$$i$$$-th color should be distinct. Obviously, such coloring might be impossible. In this case, print \"NO\". Otherwise print \"YES\" and any coloring (i.e. numbers $$$c_1, c_2, \\dots c_n$$$, where $$$1 \\le c_i \\le k$$$ and $$$c_i$$$ is the color of the $$$i$$$-th element of the given array) satisfying the conditions above. If there are multiple answers, you can print any.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\\\le k \\\\le n \\\\le 5000$$$) \u2014 the length of the array $$$a$$$ and the number of colors, respectively.\nThe second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le 5000$$$) \u2014 elements of the array $$$a$$$.\n","output_spec":"If there is no answer, print \"NO\". Otherwise print \"YES\" and any coloring (i.e. numbers $$$c_1, c_2, \\\\dots c_n$$$, where $$$1 \\\\le c_i \\\\le k$$$ and $$$c_i$$$ is the color of the $$$i$$$-th element of the given array) satisfying the conditions described in the problem statement. If there are multiple answers, you can print any.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1102-B","difficulty":1400,"tags":["greedy","sortings"],"src_uid":"3d4df21eebf32ce15841179bb85e6f2f","C++":"#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n\\n    unordered_map<int, int> colorCount;\\n    vector<int> colors(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (colorCount[a[i]] < k) {\\n            colors[i] = colorCount[a[i]] + 1;\\n            colorCount[a[i]]++;\\n        } else {\\n            cout << \\\"NO\\\" << endl;\\n            return 0;\\n        }\\n    }\\n\\n    cout << \\\"YES\\\" << endl;\\n    for (int i = 0; i < n; i++) {\\n        cout << colors[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        \n        if (k < n) {\n            System.out.println(\"NO\");\n        } else {\n            System.out.println(\"YES\");\n            int[] colors = new int[n];\n            int color = 1;\n            for (int i = 0; i < n; i++) {\n                if (colors[a[i] - 1] == 0) {\n                    colors[a[i] - 1] = color;\n                    color++;\n                    if (color > k) {\n                        color = 1;\n                    }\n                }\n                System.out.print(colors[a[i] - 1] + \" \");\n            }\n        }\n    }\n}","Python":"def color_array(n, k, a):\\n    if k < n:\\n        return 'NO'\\n    else:\\n        colors = []\\n        for i in range(1, k+1):\\n            colors.append(i)\\n        return 'YES\\\\n' + ' '.join(map(str, colors))\\n\\nn, k = map(int, input().split())\\na = list(map(int, input().split()))\\n\\nresult = color_array(n, k, a)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int color[k];\\n    for (int i = 0; i < k; i++) {\\n        color[i] = -1;\\n    }\\n\\n    int count = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (color[a[i] - 1] == -1) {\\n            color[a[i] - 1] = count++;\\n        }\\n    }\\n\\n    if (count < k) {\\n        printf(\\\"NO\\\");\\n    } else {\\n        printf(\\\"YES\\\\n\\\");\\n        for (int i = 0; i < n; i++) {\\n            printf(\\\"%d \\\", color[a[i] - 1] + 1);\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int k = int.Parse(input[1]);\n\n        int[] a = new int[n];\n        input = Console.ReadLine().Split();\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = int.Parse(input[i]);\n        }\n\n        Dictionary<int, int> colorCount = new Dictionary<int, int>();\n        int[] colors = new int[n];\n\n        for (int i = 0; i < n; i++)\n        {\n            if (!colorCount.ContainsKey(a[i]))\n            {\n                colorCount[a[i]] = 0;\n            }\n\n            if (colorCount[a[i]] >= k)\n            {\n                Console.WriteLine(\"NO\");\n                return;\n            }\n\n            colorCount[a[i]]++;\n            colors[i] = colorCount[a[i]];\n        }\n\n        Console.WriteLine(\"YES\");\n        for (int i = 0; i < n; i++)\n        {\n            Console.Write(colors[i] + \" \");\n        }\n    }\n}","Ruby":"\ndef color_array(n, k, a)\n  # Create a hash to store the colors\n  colors = {}\n\n  # Iterate through the array\n  a.each do |num|\n    # Check if the color already exists in the hash\n    if colors[num]\n      # If the color already exists, check if it has reached the maximum count\n      if colors[num] >= k\n        return \"NO\" # If the maximum count is reached, return \"NO\"\n      else\n        colors[num] += 1 # Increment the count of the color\n      end\n    else\n      colors[num] = 1 # If the color doesn't exist, add it to the hash with count 1\n    end\n  end\n\n  # Check if the number of distinct colors is less than k\n  if colors.keys.length < k\n    return \"NO\" # If the number of distinct colors is less than k, return \"NO\"\n  else\n    # If the number of distinct colors is equal to or greater than k, assign colors to the array elements\n    color_array = []\n    colors_assigned = 0\n\n    a.each do |num|\n      if colors[num] > 1\n        # If the color has already been assigned, assign the same color\n        color_array << colors_assigned % k + 1\n        colors_assigned += 1\n      else\n        # If the color hasn't been assigned, assign a new color\n        color_array << colors_assigned % k + 1\n        colors_assigned += 1\n      end\n    end\n\n    return \"YES\\n#{color_array.join(' ')}\" # Return \"YES\" and the color array\n  end\nend\n\n# Read input values\nn, k = gets.chomp.split.map(&:to_i)\na = gets.chomp.split.map(&:to_i)\n\n# Call the color_array method and print the result\nputs color_array(n, k, a)\n","delphi":"program ColorArray;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nvar\\n  n, k, i, j: Integer;\\n  a: array of Integer;\\n  colors: array of Integer;\\nbegin\\n  \/\/ Read input\\n  ReadLn(n, k);\\n  SetLength(a, n);\\n  for i := 0 to n-1 do\\n    Read(a[i]);\\n\\n  \/\/ Check if coloring is possible\\n  if n < k then\\n  begin\\n    WriteLn('NO');\\n    Exit;\\n  end;\\n\\n  \/\/ Initialize colors array\\n  SetLength(colors, n);\\n  for i := 0 to n-1 do\\n    colors[i] := i mod k + 1;\\n\\n  \/\/ Print coloring\\n  WriteLn('YES');\\n  for i := 0 to n-1 do\\n    Write(colors[i], ' ');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scan(&n, &k)\\n\\n\\ta := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&a[i])\\n\\t}\\n\\n\\t\/\/ Sort the array in ascending order\\n\\tsort.Ints(a)\\n\\n\\t\/\/ Check if it is possible to color the array\\n\\tif n < k || a[k-1] == a[k] {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\tfmt.Println(\\\"YES\\\")\\n\\n\\t\/\/ Color the array\\n\\tcolor := 1\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Printf(\\\"%d \\\", color)\\n\\t\\tif i < k-1 && a[i] != a[i+1] {\\n\\t\\t\\tcolor++\\n\\t\\t}\\n\\t}\\n}","Javascript":"function colorArray(n, k, a) {\n    let colorCount = new Map();\n    let colors = new Array(n);\n    \n    for (let i = 0; i < n; i++) {\n        if (!colorCount.has(a[i])) {\n            colorCount.set(a[i], 0);\n        }\n        \n        if (colorCount.get(a[i]) >= k) {\n            return 'NO';\n        }\n        \n        colors[i] = colorCount.get(a[i]) + 1;\n        colorCount.set(a[i], colorCount.get(a[i]) + 1);\n    }\n    \n    return 'YES\\n' + colors.join(' ');\n}\n\n\/\/ Read input\nconst input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\nconst [n, k] = input[0].split(' ').map(Number);\nconst a = input[1].split(' ').map(Number);\n\n\/\/ Call the function and print the result\nconsole.log(colorArray(n, k, a));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val k = scanner.nextInt()\n    val a = IntArray(n)\n    for (i in 0 until n) {\n        a[i] = scanner.nextInt()\n    }\n    \n    val colorMap = mutableMapOf<Int, Int>()\n    val colors = IntArray(n)\n    var currentColor = 1\n    \n    for (i in 0 until n) {\n        if (colorMap.containsKey(a[i])) {\n            colors[i] = colorMap[a[i]]!!\n        } else {\n            colors[i] = currentColor\n            colorMap[a[i]] = currentColor\n            currentColor++\n            if (currentColor > k) {\n                println(\"NO\")\n                return\n            }\n        }\n    }\n    \n    println(\"YES\")\n    for (i in 0 until n) {\n        print(\"${colors[i]} \")\n    }\n}","PHP":"<?php\\n\\nfunction colorArray($n, $k, $a) {\\n    $coloring = array();\\n    $colorCount = array();\\n\\n    \/\/ Initialize colorCount array\\n    for ($i = 1; $i <= $k; $i++) {\\n        $colorCount[$i] = 0;\\n    }\\n\\n    \/\/ Color the array\\n    for ($i = 0; $i < $n; $i++) {\\n        \/\/ Find the minimum color with the least count\\n        $minColor = 1;\\n        for ($j = 2; $j <= $k; $j++) {\\n            if ($colorCount[$j] < $colorCount[$minColor]) {\\n                $minColor = $j;\\n            }\\n        }\\n\\n        \/\/ Color the element with the minimum color\\n        $coloring[$i] = $minColor;\\n        $colorCount[$minColor]++;\\n    }\\n\\n    \/\/ Check if coloring is possible\\n    for ($i = 1; $i <= $k; $i++) {\\n        if ($colorCount[$i] == 0) {\\n            return 'NO';\\n        }\\n    }\\n\\n    \/\/ Return the coloring\\n    return 'YES\\n' . implode(' ', $coloring);\\n}\\n\\n\/\/ Read input\\n$line1 = trim(fgets(STDIN));\\n$line2 = trim(fgets(STDIN));\\nlist($n, $k) = explode(' ', $line1);\\n$a = explode(' ', $line2);\\n\\n\/\/ Call the function and print the result\\n$result = colorArray($n, $k, $a);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    int[] a;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &n, &k);\\r\\n    a.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Check if coloring is possible\\r\\n    if (n < k)\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    \/\/ Create a map to store the color of each element\\r\\n    auto colorMap = new HashMap!int;\\r\\n\\r\\n    \/\/ Color the array\\r\\n    int color = 1;\\r\\n    foreach (num; a)\\r\\n    {\\r\\n        \/\/ Check if the color is already assigned to another element\\r\\n        if (colorMap.contains(num) && colorMap[num] != color)\\r\\n        {\\r\\n            writeln(\\\"NO\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        \/\/ Assign the color to the element\\r\\n        colorMap[num] = color;\\r\\n\\r\\n        \/\/ Increment the color\\r\\n        color++;\\r\\n        if (color > k)\\r\\n        {\\r\\n            color = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the coloring\\r\\n    writeln(\\\"YES\\\");\\r\\n    foreach (num; a)\\r\\n    {\\r\\n        writeln(colorMap[num]);\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub color_array {\\n    my ($n, $k, @a) = @_;\\n    my %colors;\\n    my @coloring;\\n\\n    if ($k > $n) {\\n        return 'NO';\\n    }\\n\\n    for my $i (0..$n-1) {\\n        if (!exists $colors{$a[$i]}) {\\n            $colors{$a[$i]} = 1;\\n            push @coloring, 1;\\n        }\\n        else {\\n            push @coloring, 0;\\n        }\\n    }\\n\\n    my $color_count = scalar keys %colors;\\n\\n    if ($color_count < $k) {\\n        return 'NO';\\n    }\\n\\n    my $color = 2;\\n\\n    for my $i (0..$n-1) {\\n        if ($coloring[$i] == 0) {\\n            $coloring[$i] = $color;\\n            $color++;\\n            if ($color > $k) {\\n                $color = 2;\\n            }\\n        }\\n    }\\n\\n    return 'YES ' . join(' ', @coloring);\\n}\\n\\n# Example usage\\nmy ($n, $k) = (5, 3);\\nmy @a = (1, 2, 3, 2, 1);\\n\\nmy $result = color_array($n, $k, @a);\\nprint $result;\\n","Rust":"\nuse std::collections::HashSet;\n\nfn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut iter = input.split_whitespace();\n    let n: usize = iter.next().unwrap().parse().unwrap();\n    let k: usize = iter.next().unwrap().parse().unwrap();\n\n    let mut array = Vec::new();\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    for num in input.split_whitespace() {\n        array.push(num.parse().unwrap());\n    }\n\n    let mut color_map = vec![0; n];\n    let mut color_set = HashSet::new();\n\n    for i in 0..n {\n        if color_set.len() == k {\n            break;\n        }\n        if !color_set.contains(&array[i]) {\n            color_set.insert(array[i]);\n            color_map[i] = color_set.len();\n        }\n    }\n\n    if color_set.len() < k {\n        println!(\"NO\");\n    } else {\n        println!(\"YES\");\n        for color in color_map {\n            print!(\"{} \", color);\n        }\n        println!();\n    }\n}\n"}
{"title":"A. Nearly Lucky Number","description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line contains an integer n (1\u2264n\u226410^18).\nPlease do not use the %lld specificator to read or write 64-bit numbers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","output_spec":"Print on the single line \"YES\" if n is a nearly lucky number. Otherwise, print \"NO\" (without the quotes).\n","notes":"In the first sample there are 3 lucky digits (first one and last two), so the answer is \"NO\".\nIn the second sample there are 7 lucky digits, 7 is lucky number, so the answer is \"YES\".\nIn the third sample there are no lucky digits, so the answer is \"NO\".\n","sample_inputs":["40047\n","7747774\n","1000000000000000000\n"],"sample_outputs":["NO\n","YES\n","NO\n"],"id":"110-A","difficulty":800,"tags":["implementation"],"src_uid":"33b73fd9e7f19894ea08e98b790d07f1","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint countLuckyDigits(long long n) {\\n    int count = 0;\\n    while (n > 0) {\\n        int digit = n % 10;\\n        if (digit == 4 || digit == 7) {\\n            count++;\\n        }\\n        n \/= 10;\\n    }\\n    return count;\\n}\\n\\nbool isNearlyLucky(long long n) {\\n    int luckyCount = countLuckyDigits(n);\\n    int luckyDigitsCount = countLuckyDigits(luckyCount);\\n    return luckyDigitsCount == luckyCount;\\n}\\n\\nint main() {\\n    long long n;\\n    cin >> n;\\n\\n    if (isNearlyLucky(n)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class NearlyLuckyNumber {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        long n = scanner.nextLong();\\n        int count = countLuckyDigits(n);\\n        if (isLuckyNumber(count)) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n\\n    public static int countLuckyDigits(long n) {\\n        int count = 0;\\n        while (n > 0) {\\n            long digit = n % 10;\\n            if (digit == 4 || digit == 7) {\\n                count++;\\n            }\\n            n \/= 10;\\n        }\\n        return count;\\n    }\\n\\n    public static boolean isLuckyNumber(int n) {\\n        if (n == 0) {\\n            return false;\\n        }\\n        while (n > 0) {\\n            int digit = n % 10;\\n            if (digit != 4 && digit != 7) {\\n                return false;\\n            }\\n            n \/= 10;\\n        }\\n        return true;\\n    }\\n}","Python":"def is_nearly_lucky(n):\\n    count = 0\\n    while n > 0:\\n        digit = n % 10\\n        if digit == 4 or digit == 7:\\n            count += 1\\n        n = n \/\/ 10\\n    if count == 4 or count == 7:\\n        return 'YES'\\n    else:\\n        return 'NO'\\n\\nn = int(input())\\nprint(is_nearly_lucky(n))","C":"#include <stdio.h>\\n\\nint main() {\\n    long long int n;\\n    scanf(\\\"%lld\\\", &n);\\n    int count = 0;\\n    while (n > 0) {\\n        int digit = n % 10;\\n        if (digit == 4 || digit == 7) {\\n            count++;\\n        }\\n        n \/= 10;\\n    }\\n    if (count == 4 || count == 7) {\\n        printf(\\\"YES\\\");\\n    } else {\\n        printf(\\\"NO\\\");\\n    }\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace NearlyLuckyNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long n = long.Parse(Console.ReadLine());\n            int luckyDigits = 0;\n\n            while (n > 0)\n            {\n                int digit = (int)(n % 10);\n                if (digit == 4 || digit == 7)\n                {\n                    luckyDigits++;\n                }\n                n \/= 10;\n            }\n\n            if (luckyDigits == 4 || luckyDigits == 7)\n            {\n                Console.WriteLine(\\\"YES\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"NO\\\");\n            }\n        }\n    }\n}\n","Ruby":"\ndef nearly_lucky_number(n)\n  count = n.to_s.count('4') + n.to_s.count('7')\n  lucky_numbers = [4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777]\n  \n  if lucky_numbers.include?(count)\n    return 'YES'\n  else\n    return 'NO'\n  end\nend\n\nn = gets.chomp.to_i\nputs nearly_lucky_number(n)\n","delphi":"program NearlyLuckyNumber;\\n\\nvar\\n  n: Int64;\\n  count: Integer;\\n  digit: Integer;\\n  isNearlyLucky: Boolean;\\n\\nbegin\\n  \/\/ Read the input number\\n  ReadLn(n);\\n\\n  \/\/ Initialize variables\\n  count := 0;\\n  isNearlyLucky := False;\\n\\n  \/\/ Count the number of lucky digits\\n  while n > 0 do\\n  begin\\n    digit := n mod 10;\\n    if (digit = 4) or (digit = 7) then\\n      Inc(count);\\n    n := n div 10;\\n  end;\\n\\n  \/\/ Check if the count is a lucky number\\n  while count > 0 do\\n  begin\\n    digit := count mod 10;\\n    if (digit <> 4) and (digit <> 7) then\\n    begin\\n      isNearlyLucky := False;\\n      Break;\\n    end;\\n    count := count div 10;\\n    isNearlyLucky := True;\\n  end;\\n\\n  \/\/ Print the result\\n  if isNearlyLucky then\\n    WriteLn('YES')\\n  else\\n    WriteLn('NO');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc isNearlyLucky(n int64) string {\\n\\tluckyDigits := []rune{'4', '7'}\\n\\tnumLuckyDigits := 0\\n\\n\\tnStr := strconv.FormatInt(n, 10)\\n\\n\\tfor _, digit := range nStr {\\n\\t\\tfor _, luckyDigit := range luckyDigits {\\n\\t\\t\\tif digit == luckyDigit {\\n\\t\\t\\t\\tnumLuckyDigits++\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tluckyNums := []int{4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777}\\n\\n\\tfor _, num := range luckyNums {\\n\\t\\tif num == numLuckyDigits {\\n\\t\\t\\treturn \\\"YES\\\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn \\\"NO\\\"\\n}\\n\\nfunc main() {\\n\\tvar n int64\\n\\tfmt.Scan(&n)\\n\\n\\tresult := isNearlyLucky(n)\\n\\tfmt.Println(result)\\n}","Javascript":"function isNearlyLuckyNumber(n) {\n    let count = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        if (digit === 4 || digit === 7) {\n            count++;\n        }\n        n = Math.floor(n \/ 10);\n    }\n    return isLuckyNumber(count) ? 'YES' : 'NO';\n}\n\nfunction isLuckyNumber(n) {\n    let luckyDigits = [4, 7];\n    while (n > 0) {\n        let digit = n % 10;\n        if (!luckyDigits.includes(digit)) {\n            return false;\n        }\n        n = Math.floor(n \/ 10);\n    }\n    return true;\n}\n\n\/\/ Test cases\nconsole.log(isNearlyLuckyNumber(40047)); \/\/ Output: NO\nconsole.log(isNearlyLuckyNumber(7747774)); \/\/ Output: YES\nconsole.log(isNearlyLuckyNumber(1000000000000000000)); \/\/ Output: NO","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextLong()\n    val luckyDigits = listOf('4', '7')\n    var count = 0\n    \n    \/\/ Count the number of lucky digits in n\n    for (digit in n.toString()) {\n        if (digit in luckyDigits) {\n            count++\n        }\n    }\n    \n    \/\/ Check if the count is a lucky number\n    val isNearlyLucky = count.toString().all { it in luckyDigits }\n    \n    if (isNearlyLucky) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"<?php\\n\\nfunction isNearlyLucky($n) {\\n    $count = 0;\\n    while ($n > 0) {\\n        $digit = $n % 10;\\n        if ($digit == 4 || $digit == 7) {\\n            $count++;\\n        }\\n        $n = (int)($n \/ 10);\\n    }\\n    return isLucky($count);\\n}\\n\\nfunction isLucky($n) {\\n    $luckyDigits = [4, 7];\\n    while ($n > 0) {\\n        $digit = $n % 10;\\n        if (!in_array($digit, $luckyDigits)) {\\n            return false;\\n        }\\n        $n = (int)($n \/ 10);\\n    }\\n    return true;\\n}\\n\\n$input = trim(fgets(STDIN));\\nif (isNearlyLucky($input)) {\\n    echo \\\"YES\\\";\\n} else {\\n    echo \\\"NO\\\";\\n}\\n?>","d":"import std.stdio;\\r\\n\\r\\nbool isNearlyLucky(uint n)\\r\\n{\\r\\n    uint count = 0;\\r\\n    while (n > 0)\\r\\n    {\\r\\n        if (n % 10 == 4 || n % 10 == 7)\\r\\n            count++;\\r\\n        n \/= 10;\\r\\n    }\\r\\n    return count == 4 || count == 7;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    uint n;\\r\\n    readf(\\\"%u\\\", &n);\\r\\n\\r\\n    if (isNearlyLucky(n))\\r\\n        writeln(\\\"YES\\\");\\r\\n    else\\r\\n        writeln(\\\"NO\\\");\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_lucky_digits {\n    my ($number) = @_;\n    my $count = 0;\n    while ($number > 0) {\n        my $digit = $number % 10;\n        if ($digit == 4 || $digit == 7) {\n            $count++;\n        }\n        $number = int($number \/ 10);\n    }\n    return $count;\n}\n\nsub is_nearly_lucky {\n    my ($n) = @_;\n    my $lucky_digit_count = count_lucky_digits($n);\n    my $is_lucky = 0;\n    if ($lucky_digit_count == 4 || $lucky_digit_count == 7) {\n        $is_lucky = 1;\n    }\n    return $is_lucky;\n}\n\nmy $n = <STDIN>;\nchomp($n);\n\nif (is_nearly_lucky($n)) {\n    print \\\"YES\\\\n\\\";\n} else {\n    print \\\"NO\\\\n\\\";\n}\n","Rust":"\n\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let line = stdin.lock().lines().next().unwrap().unwrap();\n    let n: u64 = line.parse().unwrap();\n\n    let mut count = 0;\n    let mut temp = n;\n    while temp > 0 {\n        let digit = temp % 10;\n        if digit == 4 || digit == 7 {\n            count += 1;\n        }\n        temp \/= 10;\n    }\n\n    let mut is_lucky = false;\n    let mut temp = count;\n    while temp > 0 {\n        let digit = temp % 10;\n        if digit != 4 && digit != 7 {\n            is_lucky = false;\n            break;\n        }\n        is_lucky = true;\n        temp \/= 10;\n    }\n\n    if is_lucky {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\n\n"}
{"title":"D. Petya and Coloring","description":"Little Petya loves counting. He wants to count the number of ways to paint a rectangular checkered board of size n\u00d7m (n rows, m columns) in k colors. Besides, the coloring should have the following property: for any vertical line that passes along the grid lines and divides the board in two non-empty parts the number of distinct colors in both these parts should be the same. Help Petya to count these colorings.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains space-separated integers n, m and k (1\u2264n,m\u22641000,1\u2264k\u226410^6) \u2014 the board's vertical and horizontal sizes and the number of colors respectively.\n","output_spec":"Print the answer to the problem. As the answer can be quite a large number, you should print it modulo 10^9+7 (1000000007).\n","notes":null,"sample_inputs":["2 2 1\n","2 2 2\n","3 2 2\n"],"sample_outputs":["1\n","8\n","40\n"],"id":"111-D","difficulty":2300,"tags":["combinatorics","dp"],"src_uid":"f22f28e2d8933f4199ba5ccfc0de8cda","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n, m, k;\\n    cin >> n >> m >> k;\\n\\n    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\\n\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= m; j++) {\\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;\\n        }\\n    }\\n\\n    int ans = 1;\\n    for (int i = 0; i < k; i++) {\\n        ans = (ans * 2) % MOD;\\n    }\\n\\n    cout << (dp[n][m] * ans) % MOD << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int k = scanner.nextInt();\\n\\n        long MOD = 1000000007;\\n\\n        long result = 1;\\n\\n        for (int i = 0; i < n; i++) {\\n            result = (result * k) % MOD;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            result = (result * k) % MOD;\\n        }\\n\\n        System.out.println(result);\\n    }\\n}","Python":"def count_colorings(n, m, k):\n    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (k - j + 1)) % MOD\n            dp[i][j] = (dp[i][j] + dp[i - 1][j] * j) % MOD\n\n    result = 0\n    for i in range(1, k + 1):\n        result = (result + dp[n][i]) % MOD\n\n    return result\n\ninputs = ['2 2 1\\n', '2 2 2\\n', '3 2 2\\n']\noutputs = []\n\nfor input_str in inputs:\n    n, m, k = map(int, input_str.strip().split())\n    result = count_colorings(n, m, k)\n    outputs.append(str(result))\n\noutputs = '\\\\n'.join(outputs)\noutputs = outputs + '\\\\n'\n\n[{\"version\": \"Python 3\", \"source code\": outputs}]","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MOD 1000000007\\n\\nlong long int power(long long int x, long long int y)\\n{\\n    long long int res = 1;\\n    while (y > 0)\\n    {\\n        if (y & 1)\\n            res = (res * x) % MOD;\\n        y = y >> 1;\\n        x = (x * x) % MOD;\\n    }\\n    return res;\\n}\\n\\nint main()\\n{\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n\\n    long long int ans = power(k, (n + 1) \/ 2);\\n    ans = power(ans, m);\\n\\n    printf(\\\"%lld\\\\n\\\", ans);\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        int n = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n        int k = int.Parse(input[2]);\n\n        long mod = 1000000007;\n\n        long result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result = (result * k) % mod;\n        }\n\n        for (int i = 0; i < m; i++)\n        {\n            result = (result * k) % mod;\n        }\n\n        Console.WriteLine(result);\n    }\n}","Ruby":"\nMOD = 1000000007\n\ndef count_colorings(n, m, k)\n  # If there is only one row or one column, there is only one way to color the board\n  return 1 if n == 1 || m == 1\n\n  # Calculate the number of ways to color the board using dynamic programming\n  dp = Array.new(n + 1) { Array.new(m + 1, 0) }\n  dp[1][1] = k\n\n  (1..n).each do |i|\n    (1..m).each do |j|\n      if i == 1 && j == 1\n        next\n      elsif i == 1\n        dp[i][j] = dp[i][j - 1]\n      elsif j == 1\n        dp[i][j] = dp[i - 1][j]\n      else\n        dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n      end\n    end\n  end\n\n  return dp[n][m]\nend\n\n# Parse input\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\nk = input[2].to_i\n\n# Calculate and print the answer\nputs count_colorings(n, m, k) % MOD\n","delphi":"var\n  n, m, k, i: Integer;\n  ans: Int64;\nbegin\n  ReadLn(n, m, k);\n  \n  ans := 1;\n  \n  for i := 1 to n - 1 do\n    ans := (ans * k) mod 1000000007;\n  \n  for i := 1 to m - 1 do\n    ans := (ans * k) mod 1000000007;\n  \n  WriteLn(ans);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, k int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &k)\\n\\n\\tmod := 1000000007\\n\\n\\t\/\/ Initialize dp array\\n\\tdp := make([][]int, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tdp[i] = make([]int, m+1)\\n\\t}\\n\\n\\t\/\/ Base case\\n\\tdp[0][0] = 1\\n\\n\\t\/\/ Fill dp array\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tfor j := 0; j <= m; j++ {\\n\\t\\t\\tfor c := 1; c <= k; c++ {\\n\\t\\t\\t\\tif i > 0 {\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif j > 0 {\\n\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j] + dp[i][j-1]) % mod\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Print the answer\\n\\tfmt.Println(dp[n][m])\\n}","Javascript":"const readline = require('readline');\n\nconst MOD = 1000000007;\n\nfunction countColorings(n, m, k) {\n    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0));\n\n    \/\/ Base cases\n    dp[1][1] = k;\n\n    \/\/ Fill the first row\n    for (let j = 2; j <= m; j++) {\n        dp[1][j] = (dp[1][j - 1] * (k - 1)) % MOD;\n    }\n\n    \/\/ Fill the first column\n    for (let i = 2; i <= n; i++) {\n        dp[i][1] = (dp[i - 1][1] * (k - 1)) % MOD;\n    }\n\n    \/\/ Fill the rest of the grid\n    for (let i = 2; i <= n; i++) {\n        for (let j = 2; j <= m; j++) {\n            dp[i][j] = ((dp[i - 1][j] + dp[i][j - 1]) * (k - 1)) % MOD;\n        }\n    }\n\n    return dp[n][m];\n}\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.question('', (input) => {\n    const [n, m, k] = input.trim().split(' ').map(Number);\n    const result = countColorings(n, m, k);\n    console.log(result);\n    rl.close();\n});","Kotlin":"fun countColorings(n: Int, m: Int, k: Int): Long {\n    val MOD = 1000000007L\n    val dp = Array(n + 1) { LongArray(m + 1) }\n    \n    for (i in 1..n) {\n        for (j in 1..m) {\n            if (i == 1 && j == 1) {\n                dp[i][j] = k.toLong()\n            } else {\n                dp[i][j] = (dp[i - 1][j] * (k - 1) + dp[i][j - 1] * (k - 1)) % MOD\n            }\n        }\n    }\n    \n    return dp[n][m]\n}\n\nfun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val n = input[0]\n    val m = input[1]\n    val k = input[2]\n    \n    val result = countColorings(n, m, k)\n    println(result)\n}","PHP":"<?php\\n\\nfunction countColorings($n, $m, $k) {\\n    $mod = 1000000007;\\n\\n    \/\/ Initialize the dp array\\n    $dp = array_fill(0, $n + 1, array_fill(0, $m + 1, array_fill(0, $k + 1, 0)));\\n\\n    \/\/ Base case: when n = 1 or m = 1, there is only one way to color the board\\n    for ($i = 1; $i <= $n; $i++) {\\n        for ($j = 1; $j <= $k; $j++) {\\n            $dp[$i][1][$j] = 1;\\n        }\\n    }\\n\\n    for ($i = 1; $i <= $m; $i++) {\\n        for ($j = 1; $j <= $k; $j++) {\\n            $dp[1][$i][$j] = 1;\\n        }\\n    }\\n\\n    \/\/ Fill the dp array using dynamic programming\\n    for ($i = 2; $i <= $n; $i++) {\\n        for ($j = 2; $j <= $m; $j++) {\\n            for ($l = 1; $l <= $k; $l++) {\\n                $dp[$i][$j][$l] = ($dp[$i - 1][$j][$l] + $dp[$i][$j - 1][$l]) % $mod;\\n            }\\n        }\\n    }\\n\\n    \/\/ Calculate the total number of colorings\\n    $totalColorings = 0;\\n    for ($i = 1; $i <= $k; $i++) {\\n        $totalColorings = ($totalColorings + $dp[$n][$m][$i]) % $mod;\\n    }\\n\\n    return $totalColorings;\\n}\\n\\n\/\/ Read input\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$m = intval($input[1]);\\n$k = intval($input[2]);\\n\\n\/\/ Calculate and print the answer\\n$result = countColorings($n, $m, $k);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint countColorings(int n, int m, int k)\\r\\n{\\r\\n    int[][] dp = new int[][](n + 1, m + 1);\\r\\n\\r\\n    for (int i = 1; i <= n; i++)\\r\\n    {\\r\\n        for (int j = 1; j <= m; j++)\\r\\n        {\\r\\n            if (i == 1 && j == 1)\\r\\n            {\\r\\n                dp[i][j] = k;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                dp[i][j] = (dp[i - 1][j] * (k - 1) + dp[i][j - 1] * (k - 1)) % 1000000007;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return dp[n][m];\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, k;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &k);\\r\\n\\r\\n    int result = countColorings(n, m, k);\\r\\n\\r\\n    writeln(to!string(result));\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_colorings {\n    my ($n, $m, $k) = @_;\n\n    my $mod = 1000000007;\n\n    # Initialize the dp array\n    my @dp;\n    for (my $i = 0; $i <= $n; $i++) {\n        for (my $j = 0; $j <= $m; $j++) {\n            $dp[$i][$j] = [0] x ($k + 1);\n        }\n    }\n\n    # Base case: if n or m is 1, there is only one way to color the board\n    for (my $i = 1; $i <= $k; $i++) {\n        $dp[1][1][$i] = 1;\n        $dp[$n][1][$i] = 1;\n    }\n    for (my $j = 1; $j <= $k; $j++) {\n        $dp[1][1][$j] = 1;\n        $dp[1][$m][$j] = 1;\n    }\n\n    # Fill in the dp array using dynamic programming\n    for (my $i = 2; $i <= $n; $i++) {\n        for (my $j = 2; $j <= $m; $j++) {\n            for (my $c = 1; $c <= $k; $c++) {\n                # Calculate the number of colorings for each case\n                $dp[$i][$j][$c] = ($dp[$i-1][$j][$c] + $dp[$i][$j-1][$c] - $dp[$i-1][$j-1][$c] + $dp[$i-1][$j-1][$c-1]) % $mod;\n            }\n        }\n    }\n\n    return $dp[$n][$m][$k];\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $k) = split ' ', $input;\n\n# Calculate the number of colorings\nmy $result = count_colorings($n, $m, $k);\n\n# Print the result modulo 10^9+7\nprint $result % 1000000007;\n","Rust":"fn main() {\n    const MOD: u64 = 1_000_000_007;\n\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut iter = input.split_whitespace();\n\n    let n: u64 = iter.next().unwrap().parse().unwrap();\n    let m: u64 = iter.next().unwrap().parse().unwrap();\n    let k: u64 = iter.next().unwrap().parse().unwrap();\n\n    let mut result: u64 = 1;\n\n    for _ in 0..n {\n        result = (result * k) % MOD;\n    }\n\n    for _ in 0..m {\n        result = (result * k) % MOD;\n    }\n\n    println!(\"{}\", result);\n}"}
{"title":"E. Sleeping","description":"One day Vasya was lying in bed watching his electronic clock to fall asleep quicker.Vasya lives in a strange country, where days have h hours, and every hour has m minutes. Clock shows time in decimal number system, in format H:M, where the string H always has a fixed length equal to the number of digits in the decimal representation of number h-1. To achieve this, leading zeros are added if necessary. The string M has a similar format, and its length is always equal to the number of digits in the decimal representation of number m-1. For example, if h=17, m=1000, then time equal to 13 hours and 75 minutes will be displayed as \"13:075\".Vasya had been watching the clock from h1 hours m1 minutes to h2 hours m2 minutes inclusive, and then he fell asleep. Now he asks you to count how many times he saw the moment at which at least k digits changed on the clock simultaneously.For example, when switching 04:19 \u2192 04:20 two digits change. When switching 23:59 \u2192 00:00, four digits change.Consider that Vasya has been watching the clock for strictly less than one day. Note that the last time Vasya saw on the clock before falling asleep was \"h2:m2\". That is, Vasya didn't see the moment at which time \"h2:m2\" switched to the next value.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input file contains three space-separated integers h, m and k (2\u2264h,m\u226410^9, 1\u2264k\u226420). The second line contains space-separated integers h1, m1 (0\u2264h1<h, 0\u2264m1<m). The third line contains space-separated integers h2, m2 (0\u2264h2<h, 0\u2264m2<m).\n","output_spec":"Print a single number \u2014 the number of times Vasya saw the moment of changing at least k digits simultaneously.\nPlease do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin stream (also you may use the %I64d specificator).\n","notes":"In the first example Vasya will see the following moments of time: 4:4  0:0 \u2192 0:1 \u2192 0:2 \u2192 0:3 \u2192 0:4  1:0 \u2192 1:1 \u2192 1:2 \u2192 1:3 \u2192 1:4  2:0 \u2192 2:1 \u2192 2:2 \u2192 2:3 \u2192 2:4. Double arrow () marks the sought moments of time (in this example \u2014 when Vasya sees two numbers changing simultaneously).\nIn the second example k=1. Any switching time can be accepted, since during switching of the clock at least one digit is changed. Total switching equals to 24\u00b760=1440, but Vasya have not seen one of them \u2014 the switching of 23:59  00:00.\nIn the third example Vasya fell asleep immediately after he began to look at the clock, so he did not see any change.\n","sample_inputs":["5 5 2\n4 4\n2 1\n","24 60 1\n0 0\n23 59\n","24 60 3\n23 59\n23 59\n"],"sample_outputs":["3\n","1439\n","0\n"],"id":"113-E","difficulty":2700,"tags":["combinatorics","implementation","math"],"src_uid":"e2782743229645ad3a0f8e815d86dc5f","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int h, m, k;\\n    cin >> h >> m >> k;\\n    int h1, m1;\\n    cin >> h1 >> m1;\\n    int h2, m2;\\n    cin >> h2 >> m2;\\n\\n    int count = 0;\\n\\n    while (h1 != h2 || m1 != m2) {\\n        int h1_digits = log10(h1) + 1;\\n        int m1_digits = log10(m1) + 1;\\n\\n        int h1_zeros = log10(h - 1) + 1 - h1_digits;\\n        int m1_zeros = log10(m - 1) + 1 - m1_digits;\\n\\n        if (h1_zeros + m1_zeros >= k) {\\n            count++;\\n        }\\n\\n        m1++;\\n        if (m1 == m) {\\n            m1 = 0;\\n            h1++;\\n            if (h1 == h) {\\n                h1 = 0;\\n            }\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ClockDigits {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int h = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int h1 = scanner.nextInt();\\n        int m1 = scanner.nextInt();\\n        int h2 = scanner.nextInt();\\n        int m2 = scanner.nextInt();\\n\\n        int count = 0;\\n\\n        while (h1 != h2 || m1 != m2) {\\n            int hDigits = String.valueOf(h1).length();\\n            int mDigits = String.valueOf(m1).length();\\n\\n            if (hDigits >= k && mDigits >= k) {\\n                count++;\\n            }\\n\\n            m1++;\\n            if (m1 == m) {\\n                m1 = 0;\\n                h1++;\\n                if (h1 == h) {\\n                    h1 = 0;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.util.Scanner;\\n\\npublic class ClockDigits {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int h = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int h1 = scanner.nextInt();\\n        int m1 = scanner.nextInt();\\n        int h2 = scanner.nextInt();\\n        int m2 = scanner.nextInt();\\n\\n        int count = 0;\\n\\n        while (h1 != h2 || m1 != m2) {\\n            int hDigits = String.valueOf(h1).length();\\n            int mDigits = String.valueOf(m1).length();\\n\\n            if (hDigits >= k && mDigits >= k) {\\n                count++;\\n            }\\n\\n            m1++;\\n            if (m1 == m) {\\n                m1 = 0;\\n                h1++;\\n                if (h1 == h) {\\n                    h1 = 0;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.util.Scanner;\\n\\npublic class ClockDigits {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int h = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int h1 = scanner.nextInt();\\n        int m1 = scanner.nextInt();\\n        int h2 = scanner.nextInt();\\n        int m2 = scanner.nextInt();\\n\\n        int count = 0;\\n\\n        while (h1 != h2 || m1 != m2) {\\n            int hDigits = String.valueOf(h1).length();\\n            int mDigits = String.valueOf(m1).length();\\n\\n            if (hDigits >= k && mDigits >= k) {\\n                count++;\\n            }\\n\\n            m1++;\\n            if (m1 == m) {\\n                m1 = 0;\\n                h1++;\\n                if (h1 == h) {\\n                    h1 = 0;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.util.Scanner;\\n\\npublic class ClockDigits {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int h = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int h1 = scanner.nextInt();\\n        int m1 = scanner.nextInt();\\n        int h2 = scanner.nextInt();\\n        int m2 = scanner.nextInt();\\n\\n        int count = 0;\\n\\n        while (h1 != h2 || m1 != m2) {\\n            int hDigits = String.valueOf(h1).length();\\n            int mDigits = String.valueOf(m1).length();\\n\\n            if (hDigits >= k && mDigits >= k) {\\n                count++;\\n            }\\n\\n            m1++;\\n            if (m1 == m) {\\n                m1 = 0;\\n                h1++;\\n                if (h1 == h) {\\n                    h1 = 0;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}","Python":"\ndef count_digit_changes(h, m, k, h1, m1, h2, m2):\n    count = 0\n    for hour in range(h1, h2+1):\n        for minute in range(m1, m2+1):\n            hour_str = str(hour).zfill(len(str(h-1)))\n            minute_str = str(minute).zfill(len(str(m-1)))\n            changes = sum([1 for i in range(len(hour_str)) if hour_str[i] != minute_str[i]])\n            if changes >= k:\n                count += 1\n    return count\n\ninput_data = input().split('\\n')\nh, m, k = map(int, input_data[0].split())\nh1, m1 = map(int, input_data[1].split())\nh2, m2 = map(int, input_data[2].split())\n\nresult = count_digit_changes(h, m, k, h1, m1, h2, m2)\nprint(result)\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int h, m, k;\\n    int h1, m1;\\n    int h2, m2;\\n    int count = 0;\\n\\n    scanf(\\\"%d %d %d\\\", &h, &m, &k);\\n    scanf(\\\"%d %d\\\", &h1, &m1);\\n    scanf(\\\"%d %d\\\", &h2, &m2);\\n\\n    while (h1 != h2 || m1 != m2) {\\n        int h1_digits = 0;\\n        int m1_digits = 0;\\n        int temp_h1 = h1;\\n        int temp_m1 = m1;\\n\\n        while (temp_h1 > 0) {\\n            temp_h1 \/= 10;\\n            h1_digits++;\\n        }\\n\\n        while (temp_m1 > 0) {\\n            temp_m1 \/= 10;\\n            m1_digits++;\\n        }\\n\\n        if (h1_digits + m1_digits >= k) {\\n            count++;\\n        }\\n\\n        m1++;\\n        if (m1 == m) {\\n            m1 = 0;\\n            h1++;\\n            if (h1 == h) {\\n                h1 = 0;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace ClockDigits\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int h = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n            int k = int.Parse(input[2]);\n\n            input = Console.ReadLine().Split(' ');\n            int h1 = int.Parse(input[0]);\n            int m1 = int.Parse(input[1]);\n\n            input = Console.ReadLine().Split(' ');\n            int h2 = int.Parse(input[0]);\n            int m2 = int.Parse(input[1]);\n\n            int count = 0;\n\n            for (int i = h1; i != h2 || i != (h2 + 1) % h; i = (i + 1) % h)\n            {\n                for (int j = (i == h1 ? m1 : 0); j != (i == h2 ? m2 : m); j = (j + 1) % m)\n                {\n                    int digitChanges = CountDigitChanges(i, j, h, m);\n                    if (digitChanges >= k)\n                    {\n                        count++;\n                    }\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n\n        static int CountDigitChanges(int hour, int minute, int h, int m)\n        {\n            int digitChanges = 0;\n\n            int hourDigits = hour.ToString().Length;\n            int minuteDigits = minute.ToString().Length;\n\n            for (int i = 0; i < hourDigits; i++)\n            {\n                int currentDigit = (hour \/ (int)Math.Pow(10, i)) % 10;\n                int nextDigit = ((hour + 1) % h \/ (int)Math.Pow(10, i)) % 10;\n\n                if (currentDigit != nextDigit)\n                {\n                    digitChanges++;\n                }\n            }\n\n            for (int i = 0; i < minuteDigits; i++)\n            {\n                int currentDigit = (minute \/ (int)Math.Pow(10, i)) % 10;\n                int nextDigit = ((minute + 1) % m \/ (int)Math.Pow(10, i)) % 10;\n\n                if (currentDigit != nextDigit)\n                {\n                    digitChanges++;\n                }\n            }\n\n            return digitChanges;\n        }\n    }\n}\n","Ruby":"\ndef count_digit_changes(h, m, k, h1, m1, h2, m2)\n  count = 0\n  current_h = h1\n  current_m = m1\n\n  while current_h != h2 || current_m != m2\n    current_h_str = current_h.to_s.rjust(Math.log10(h-1).to_i + 1, '0')\n    current_m_str = current_m.to_s.rjust(Math.log10(m-1).to_i + 1, '0')\n\n    digit_changes = 0\n    (0...current_h_str.length).each do |i|\n      digit_changes += 1 if current_h_str[i] != current_h_str[i+1]\n    end\n    (0...current_m_str.length).each do |i|\n      digit_changes += 1 if current_m_str[i] != current_m_str[i+1]\n    end\n\n    count += 1 if digit_changes >= k\n\n    current_m += 1\n    if current_m == m\n      current_m = 0\n      current_h += 1\n    end\n  end\n\n  count\nend\n\ninput = gets.chomp.split(' ').map(&:to_i)\nh = input[0]\nm = input[1]\nk = input[2]\n\ninput = gets.chomp.split(' ').map(&:to_i)\nh1 = input[0]\nm1 = input[1]\n\ninput = gets.chomp.split(' ').map(&:to_i)\nh2 = input[0]\nm2 = input[1]\n\nputs count_digit_changes(h, m, k, h1, m1, h2, m2)\n","delphi":"program ClockChanges;\\n\\nvar\\n  h, m, k, h1, m1, h2, m2, count: Int64;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(h, m, k);\\n  ReadLn(h1, m1);\\n  ReadLn(h2, m2);\\n\\n  \/\/ Calculate the number of times Vasya saw the moment of changing at least k digits\\n  count := 0;\\n\\n  \/\/ Loop through all possible times\\n  while (h1 <> h2) or (m1 <> m2) do\\n  begin\\n    \/\/ Check if at least k digits change\\n    if (h1 div 10 <> h2 div 10) or (h1 mod 10 <> h2 mod 10) or (m1 div 10 <> m2 div 10) or (m1 mod 10 <> m2 mod 10) then\\n      Inc(count);\\n\\n    \/\/ Increment time\\n    Inc(m1);\\n    if m1 = m then\\n    begin\\n      m1 := 0;\\n      Inc(h1);\\n      if h1 = h then\\n        h1 := 0;\\n    end;\\n  end;\\n\\n  \/\/ Print the result\\n  WriteLn(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar h, m, k int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &h, &m, &k)\\n\\n\\tvar h1, m1 int\\n\\tfmt.Scanf(\\\"%d %d\\\", &h1, &m1)\\n\\n\\tvar h2, m2 int\\n\\tfmt.Scanf(\\\"%d %d\\\", &h2, &m2)\\n\\n\\tcount := 0\\n\\n\\tfor h1 != h2 || m1 != m2 {\\n\\t\\tif countDigits(h1, h) + countDigits(m1, m) >= k {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\n\\t\\tm1++\\n\\t\\tif m1 == m {\\n\\t\\t\\tm1 = 0\\n\\t\\t\\th1++\\n\\t\\t\\tif h1 == h {\\n\\t\\t\\t\\th1 = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}\\n\\nfunc countDigits(n, base int) int {\\n\\tcount := 0\\n\\n\\tfor n > 0 {\\n\\t\\tn \/= base\\n\\t\\tcount++\\n\\t}\\n\\n\\treturn count\\n}","Javascript":"function countChangingDigits(h, m, k, h1, m1, h2, m2) {\n    let count = 0;\n    \n    while (h1 !== h2 || m1 !== m2) {\n        let hStr = h1.toString().padStart(Math.floor(Math.log10(h - 1)) + 1, '0');\n        let mStr = m1.toString().padStart(Math.floor(Math.log10(m - 1)) + 1, '0');\n        \n        let changingDigits = 0;\n        for (let i = 0; i < hStr.length; i++) {\n            if (hStr[i] !== hStr[i + 1]) {\n                changingDigits++;\n            }\n        }\n        for (let i = 0; i < mStr.length; i++) {\n            if (mStr[i] !== mStr[i + 1]) {\n                changingDigits++;\n            }\n        }\n        \n        if (changingDigits >= k) {\n            count++;\n        }\n        \n        m1++;\n        if (m1 === m) {\n            m1 = 0;\n            h1++;\n            if (h1 === h) {\n                h1 = 0;\n            }\n        }\n    }\n    \n    return count;\n}\n\n\/\/ Sample inputs\nconst inputs = [\n    [5, 5, 2, 4, 4, 2, 1],\n    [24, 60, 1, 0, 0, 23, 59],\n    [24, 60, 3, 23, 59, 23, 59]\n];\n\n\/\/ Execute the function for each sample input\nconst outputs = inputs.map(input => countChangingDigits(...input));\n\n\/\/ Print the outputs\nconsole.log(outputs.join('\\\\n'));","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input1 = scanner.nextLine().split(\" \").map { it.toInt() }\n    val input2 = scanner.nextLine().split(\" \").map { it.toInt() }\n    val input3 = scanner.nextLine().split(\" \").map { it.toInt() }\n    \n    val h = input1[0]\n    val m = input1[1]\n    val k = input1[2]\n    \n    val h1 = input2[0]\n    val m1 = input2[1]\n    \n    val h2 = input3[0]\n    val m2 = input3[1]\n    \n    var count = 0\n    \n    for (i in h1 until h2) {\n        for (j in if (i == h1) m1 else 0 until if (i == h2 - 1) m2 else m) {\n            val hourDigitsChanged = countDigitsChanged(i, h)\n            val minuteDigitsChanged = countDigitsChanged(j, m)\n            \n            if (hourDigitsChanged + minuteDigitsChanged >= k) {\n                count++\n            }\n        }\n    }\n    \n    println(count)\n}\n\nfun countDigitsChanged(num: Int, base: Int): Int {\n    var count = 0\n    var n = num\n    \n    while (n > 0) {\n        if (n % base != (n - 1) % base) {\n            count++\n        }\n        n \/= base\n    }\n    \n    return count\n}","PHP":"\n<?php\n\nfunction countChangingDigits($h, $m, $k, $h1, $m1, $h2, $m2) {\n    $count = 0;\n    \n    \/\/ Calculate the total number of minutes in a day\n    $totalMinutes = $h * $m;\n    \n    \/\/ Convert the starting and ending times to minutes\n    $startMinutes = $h1 * $m + $m1;\n    $endMinutes = $h2 * $m + $m2;\n    \n    \/\/ Loop through all the minutes between the starting and ending times\n    for ($minutes = $startMinutes; $minutes < $endMinutes; $minutes++) {\n        \/\/ Calculate the current hour and minute\n        $currentHour = floor($minutes \/ $m) % $h;\n        $currentMinute = $minutes % $m;\n        \n        \/\/ Convert the current hour and minute to strings with leading zeros\n        $currentHourString = str_pad($currentHour, strlen($h - 1), '0', STR_PAD_LEFT);\n        $currentMinuteString = str_pad($currentMinute, strlen($m - 1), '0', STR_PAD_LEFT);\n        \n        \/\/ Count the number of digits that have changed from the previous time\n        $changedDigits = 0;\n        for ($i = 0; $i < strlen($currentHourString); $i++) {\n            if ($currentHourString[$i] != $previousHourString[$i]) {\n                $changedDigits++;\n            }\n        }\n        for ($i = 0; $i < strlen($currentMinuteString); $i++) {\n            if ($currentMinuteString[$i] != $previousMinuteString[$i]) {\n                $changedDigits++;\n            }\n        }\n        \n        \/\/ Check if the number of changed digits is at least k\n        if ($changedDigits >= $k) {\n            $count++;\n        }\n        \n        \/\/ Set the previous hour and minute for the next iteration\n        $previousHourString = $currentHourString;\n        $previousMinuteString = $currentMinuteString;\n    }\n    \n    return $count;\n}\n\n\/\/ Read the input from the command line\n$input = explode('\\n', file_get_contents('php:\/\/stdin'));\nlist($h, $m, $k) = explode(' ', $input[0]);\nlist($h1, $m1) = explode(' ', $input[1]);\nlist($h2, $m2) = explode(' ', $input[2]);\n\n\/\/ Call the countChangingDigits function and print the result\n$result = countChangingDigits($h, $m, $k, $h1, $m1, $h2, $m2);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint countDigits(int n)\\r\\n{\\r\\n    int count = 0;\\r\\n    while (n != 0)\\r\\n    {\\r\\n        n \/= 10;\\r\\n        count++;\\r\\n    }\\r\\n    return count;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int h, m, k;\\r\\n    int h1, m1;\\r\\n    int h2, m2;\\r\\n    int count = 0;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d %d\\\", &h, &m, &k);\\r\\n    scanf(\\\"%d %d\\\", &h1, &m1);\\r\\n    scanf(\\\"%d %d\\\", &h2, &m2);\\r\\n\\r\\n    \/\/ Calculate the number of times digits change\\r\\n    for (int i = h1; i < h2; i++)\\r\\n    {\\r\\n        for (int j = (i == h1 ? m1 : 0); j < m; j++)\\r\\n        {\\r\\n            int prevH = i;\\r\\n            int prevM = j;\\r\\n            int currH = (i + 1) % h;\\r\\n            int currM = (j + 1) % m;\\r\\n\\r\\n            int digitChanges = countDigits(prevH) - countDigits(currH) + countDigits(prevM) - countDigits(currM);\\r\\n\\r\\n            if (digitChanges >= k)\\r\\n            {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    printf(\\\"%d\\\\n\\\", count);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_digit_changes {\n    my ($h, $m, $k, $h1, $m1, $h2, $m2) = @_;\n\n    my $count = 0;\n\n    for my $hour ($h1..$h2) {\n        for my $minute ($m1..$m2) {\n            my $hour_str = sprintf('%0' . length($h-1) . 'd', $hour);\n            my $minute_str = sprintf('%0' . length($m-1) . 'd', $minute);\n\n            my $digit_changes = 0;\n            for my $i (0..length($hour_str)-1) {\n                $digit_changes++ if substr($hour_str, $i, 1) ne substr($minute_str, $i, 1);\n            }\n            for my $i (0..length($minute_str)-1) {\n                $digit_changes++ if substr($minute_str, $i, 1) ne substr($minute_str, $i, 1);\n            }\n\n            $count++ if $digit_changes >= $k;\n        }\n    }\n\n    return $count;\n}\n\n# Read input\nmy $input = <>;\nchomp $input;\nmy ($h, $m, $k) = split ' ', $input;\n\n$input = <>;\nchomp $input;\nmy ($h1, $m1) = split ' ', $input;\n\n$input = <>;\nchomp $input;\nmy ($h2, $m2) = split ' ', $input;\n\n# Call the function and print the result\nmy $result = count_digit_changes($h, $m, $k, $h1, $m1, $h2, $m2);\nprint $result;\n","Rust":"\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n\n    let params: Vec<u64> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let h = params[0];\n    let m = params[1];\n    let k = params[2];\n\n    let start: Vec<u64> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let h1 = start[0];\n    let m1 = start[1];\n\n    let end: Vec<u64> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let h2 = end[0];\n    let m2 = end[1];\n\n    let mut count = 0;\n\n    for hour in h1..h2 {\n        for minute in 0..m {\n            let hour_str = format!(\"{:0width$}\", hour, width = h.to_string().len());\n            let minute_str = format!(\"{:0width$}\", minute, width = m.to_string().len());\n\n            let mut digit_changes = 0;\n\n            for (h_char, h1_char) in hour_str.chars().zip(h1.to_string().chars()) {\n                if h_char != h1_char {\n                    digit_changes += 1;\n                }\n            }\n\n            for (m_char, m1_char) in minute_str.chars().zip(m1.to_string().chars()) {\n                if m_char != m1_char {\n                    digit_changes += 1;\n                }\n            }\n\n            if digit_changes >= k {\n                count += 1;\n            }\n        }\n    }\n\n    println!(\"{}\", count);\n}\n"}
{"title":"A. Cifera","description":"When Petya went to school, he got interested in large numbers and what they were called in ancient times. For instance, he learned that the Russian word \"tma\" (which now means \"too much to be counted\") used to stand for a thousand and \"tma tmyschaya\" (which literally means \"the tma of tmas\") used to stand for a million.Petya wanted to modernize the words we use for numbers and invented a word petricium that represents number k. Moreover, petricium la petricium stands for number k^2, petricium la petricium la petricium stands for k^3 and so on. All numbers of this form are called petriciumus cifera, and the number's importance is the number of articles la in its title.Petya's invention brought on a challenge that needed to be solved quickly: does some number l belong to the set petriciumus cifera? As Petya is a very busy schoolboy he needs to automate the process, he asked you to solve it.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains integer number k, the second line contains integer number l (2\u2264k,l\u22642^31-1).\n","output_spec":"You should print in the first line of the output \"YES\", if the number belongs to the set petriciumus cifera and otherwise print \"NO\". If the number belongs to the set, then print on the seconds line the only number \u2014 the importance of number l.\n","notes":null,"sample_inputs":["5\n25\n","3\n8\n"],"sample_outputs":["YES\n1\n","NO\n"],"id":"114-A","difficulty":1000,"tags":["math"],"src_uid":"8ce89b754aa4080e7c3b2c3b10f4be46","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int k, l;\\n    cin >> k >> l;\\n\\n    int importance = 0;\\n    while (l % k == 0) {\\n        l \/= k;\\n        importance++;\\n    }\\n\\n    if (l == 1) {\\n        cout << \\\"YES\\\" << endl;\\n        cout << importance << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class PetriciumusCifera {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int k = scanner.nextInt();\\n        int l = scanner.nextInt();\\n\\n        int importance = 0;\\n        long currentNumber = k;\\n\\n        while (currentNumber <= l) {\\n            if (currentNumber == l) {\\n                System.out.println(\\\"YES\\\");\\n                System.out.println(importance);\\n                return;\\n            }\\n\\n            currentNumber *= k;\\n            importance++;\\n        }\\n\\n        System.out.println(\\\"NO\\\");\\n    }\\n}\" }","Python":"def is_petriciumus_cifera(k, l):\\n    importance = 0\\n    while l % k == 0:\\n        l = l \/\/ k\\n        importance += 1\\n    if l == 1:\\n        return 'YES\\\\n' + str(importance) + '\\\\n'\\n    else:\\n        return 'NO\\\\n'\\n\\nk = int(input())\\nl = int(input())\\n\\nprint(is_petriciumus_cifera(k, l))","C":"#include <stdio.h>\\n#include <math.h>\\n\\nint main() {\\n    int k, l;\\n    scanf(\\\"%d\\\", &k);\\n    scanf(\\\"%d\\\", &l);\\n\\n    int importance = 0;\\n    int power = 1;\\n\\n    while (power <= l) {\\n        if (power == l) {\\n            printf(\\\"YES\\\\n\\\");\\n            printf(\\\"%d\\\\n\\\", importance);\\n            return 0;\\n        }\\n        power *= k;\\n        importance++;\\n    }\\n\\n    printf(\\\"NO\\\\n\\\");\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int k = int.Parse(Console.ReadLine());\n        int l = int.Parse(Console.ReadLine());\n\n        int importance = 0;\n        long petricium = k;\n\n        while (petricium <= l)\n        {\n            if (petricium == l)\n            {\n                Console.WriteLine(\\\"YES\\\");\n                Console.WriteLine(importance);\n                return;\n            }\n\n            petricium *= k;\n            importance++;\n        }\n\n        Console.WriteLine(\\\"NO\\\");\n    }\n}","Ruby":"def petriciumus_cifera(k, l)\\n  importance = 0\\n  while l % k == 0\\n    l \/= k\\n    importance += 1\\n  end\\n\\n  if l == 1\\n    return 'YES\\\\n' + importance.to_s + '\\\\n'\\n  else\\n    return 'NO\\\\n'\\n  end\\nend\\n\\ninput = gets.chomp.split('\\\\n')\\nk = input[0].to_i\\nl = input[1].to_i\\n\\nputs petriciumus_cifera(k, l)","delphi":"program PetriciumusCifera;\\n\\nvar\\n  k, l, importance: Integer;\\n\\nbegin\\n  Readln(k);\\n  Readln(l);\\n\\n  importance := 0;\\n\\n  while l mod k = 0 do\\n  begin\\n    l := l div k;\\n    importance := importance + 1;\\n  end;\\n\\n  if l = 1 then\\n    Writeln('YES')\\n  else\\n    Writeln('NO');\\n\\n  if l = 1 then\\n    Writeln(importance);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar k, l int\\n\\tfmt.Scan(&k)\\n\\tfmt.Scan(&l)\\n\\n\\timportance := 0\\n\\tn := int(math.Log(float64(l)) \/ math.Log(float64(k)))\\n\\n\\tif int(math.Pow(float64(k), float64(n))) == l {\\n\\t\\timportance = n\\n\\t}\\n\\n\\tif importance > 0 {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t\\tfmt.Println(importance)\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function findPetriciumusCifera(k, l) {\n    let importance = 0;\n    let power = 1;\n    \n    while (power <= l) {\n        if (power === l) {\n            return `YES\\\\n${importance}\\\\n`;\n        }\n        \n        power *= k;\n        importance++;\n    }\n    \n    return 'NO\\\\n';\n}\n\nconst input = '5\\\\n25\\\\n';\nconst lines = input.split('\\\\n');\nconst k = parseInt(lines[0]);\nconst l = parseInt(lines[1]);\n\nconst result = findPetriciumusCifera(k, l);\nconsole.log(result);","Kotlin":"import kotlin.math.log2\\n\\nfun main() {\\n    val k = readLine()!!.toInt()\\n    val l = readLine()!!.toInt()\\n\\n    val importance = log2(l.toDouble()) \/ log2(k.toDouble())\\n    val isPetriciumusCifera = importance % 1 == 0.0\\n\\n    if (isPetriciumusCifera) {\\n        println(\\\"YES\\\")\\n        println(importance.toInt())\\n    } else {\\n        println(\\\"NO\\\")\\n    }\\n}","PHP":"<?php\\n\\nfunction petriciumusCifera($k, $l) {\\n    $importance = 0;\\n    while ($l % $k == 0) {\\n        $l \/= $k;\\n        $importance++;\\n    }\\n    if ($l == 1) {\\n        return ['YES', $importance];\\n    } else {\\n        return ['NO'];\\n    }\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$k = intval($input[0]);\\n$l = intval($input[1]);\\n\\n$result = petriciumusCifera($k, $l);\\necho $result[0] . \\\"\\\\n\\\";\\nif ($result[0] == 'YES') {\\n    echo $result[1] . \\\"\\\\n\\\";\\n}\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int k = readln!int();\\r\\n    int l = readln!int();\\r\\n\\r\\n    int importance = 0;\\r\\n    int power = k;\\r\\n\\r\\n    while (power <= l)\\r\\n    {\\r\\n        if (power == l)\\r\\n        {\\r\\n            writeln(\\\"YES\\\");\\r\\n            writeln(importance);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        power *= k;\\r\\n        importance++;\\r\\n    }\\r\\n\\r\\n    writeln(\\\"NO\\\");\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_importance {\n    my ($k, $l) = @_;\n    \n    my $importance = 0;\n    my $current_number = $k;\n    \n    while ($current_number <= $l) {\n        $current_number *= $k;\n        $importance++;\n        \n        if ($current_number == $l) {\n            return $importance;\n        }\n    }\n    \n    return 0;\n}\n\nsub check_petriciumus_cifera {\n    my ($k, $l) = @_;\n    \n    my $importance = calculate_importance($k, $l);\n    \n    if ($importance > 0) {\n        return \\\"YES\\\\n$importance\\\\n\\\";\n    } else {\n        return \\\"NO\\\\n\\\";\n    }\n}\n\n# Read input\nmy $k = <>;\nmy $l = <>;\nchomp($k, $l);\n\n# Check if l belongs to the set petriciumus cifera\nmy $output = check_petriciumus_cifera($k, $l);\n\n# Print output\nprint $output;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let k: u32 = input.trim().parse().unwrap();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let l: u32 = input.trim().parse().unwrap();\n    \n    let mut importance = 0;\n    let mut num = k;\n    \n    while num <= l {\n        num *= k;\n        importance += 1;\n        \n        if num == l {\n            println!(\"YES\");\n            println!(\"{}\", importance);\n            return;\n        }\n    }\n    \n    println!(\"NO\");\n}"}
{"title":"B. Long Number","description":"You are given a long decimal number $$$a$$$ consisting of $$$n$$$ digits from $$$1$$$ to $$$9$$$. You also have a function $$$f$$$ that maps every digit from $$$1$$$ to $$$9$$$ to some (possibly the same) digit from $$$1$$$ to $$$9$$$.You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in $$$a$$$, and replace each digit $$$x$$$ from this segment with $$$f(x)$$$. For example, if $$$a = 1337$$$, $$$f(1) = 1$$$, $$$f(3) = 5$$$, $$$f(7) = 3$$$, and you choose the segment consisting of three rightmost digits, you get $$$1553$$$ as the result.What is the maximum possible number you can obtain applying this operation no more than once?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$) \u2014 the number of digits in $$$a$$$.\nThe second line contains a string of $$$n$$$ characters, denoting the number $$$a$$$. Each character is a decimal digit from $$$1$$$ to $$$9$$$.\nThe third line contains exactly $$$9$$$ integers $$$f(1)$$$, $$$f(2)$$$, ..., $$$f(9)$$$ ($$$1 \\\\le f(i) \\\\le 9$$$).\n","output_spec":"Print the maximum number you can get after applying the operation described in the statement no more than once.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1157-B","difficulty":1300,"tags":["greedy"],"src_uid":"378a9ab7ad891d60f23645106d24f314","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    string a;\\n    cin >> a;\\n    vector<int> f(9);\\n    for (int i = 0; i < 9; i++) {\\n        cin >> f[i];\\n    }\\n\\n    bool canReplace = false;\\n    for (int i = 0; i < n; i++) {\\n        int digit = a[i] - '0';\\n        if (f[digit - 1] > digit) {\\n            canReplace = true;\\n            break;\\n        }\\n    }\\n\\n    if (canReplace) {\\n        for (int i = 0; i < n; i++) {\\n            int digit = a[i] - '0';\\n            if (f[digit - 1] >= digit) {\\n                a[i] = f[digit - 1] + '0';\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    cout << a << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.nextLine();\\n        String a = scanner.nextLine();\\n        int[] f = new int[10];\\n        for (int i = 1; i <= 9; i++) {\\n            f[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        StringBuilder result = new StringBuilder();\\n        boolean replaced = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            int digit = Character.getNumericValue(a.charAt(i));\\n            if (f[digit] > digit) {\\n                result.append(f[digit]);\\n                replaced = true;\\n            } else if (f[digit] == digit) {\\n                result.append(digit);\\n            } else {\\n                if (replaced) {\\n                    result.append(a.substring(i));\\n                    break;\\n                } else {\\n                    result.append(digit);\\n                }\\n            }\\n        }\\n\\n        System.out.println(result.toString());\\n    }\\n}","Python":"def max_possible_number(n, a, f):\\n    a = list(a)\\n    for i in range(n):\\n        if f[int(a[i])-1] > int(a[i]):\\n            j = i\\n            while j < n and f[int(a[j])-1] >= int(a[j]):\\n                a[j] = str(f[int(a[j])-1])\\n                j += 1\\n            break\\n    return ''.join(a)\\n\\nn = int(input())\\na = input()\\nf = list(map(int, input().split()))\\n\\nprint(max_possible_number(n, a, f))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    char a[n+1];\\n    scanf(\\\"%s\\\", a);\\n    int f[9];\\n    for (int i = 0; i < 9; i++) {\\n        scanf(\\\"%d\\\", &f[i]);\\n    }\\n\\n    int max_num = 0;\\n    int start = 0;\\n    int end = 0;\\n    int flag = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        int digit = a[i] - '0';\\n        if (f[digit-1] > digit) {\\n            if (flag == 0) {\\n                start = i;\\n                flag = 1;\\n            }\\n            a[i] = f[digit-1] + '0';\\n            end = i;\\n        }\\n        else if (flag == 1) {\\n            break;\\n        }\\n    }\\n\\n    printf(\\\"%s\\\", a);\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        string a = Console.ReadLine();\n        int[] f = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n        char[] result = a.ToCharArray();\n\n        bool operationPerformed = false;\n\n        for (int i = 0; i < n; i++)\n        {\n            int digit = int.Parse(result[i].ToString());\n            int mappedDigit = f[digit - 1];\n\n            if (mappedDigit > digit)\n            {\n                result[i] = mappedDigit.ToString()[0];\n                operationPerformed = true;\n            }\n            else if (mappedDigit < digit && operationPerformed)\n            {\n                break;\n            }\n        }\n\n        Console.WriteLine(new string(result));\n    }\n}","Ruby":"\ndef maximum_number(n, a, f)\n  max_num = a.dup\n  max_num.each_char.with_index do |digit, i|\n    max_num[i] = f[digit.to_i].to_s if f[digit.to_i] > digit.to_i\n    break if f[digit.to_i] < digit.to_i\n  end\n  max_num\nend\n\nn = gets.to_i\na = gets.chomp\nf = gets.split.map(&:to_i)\n\nputs maximum_number(n, a, f)\n","delphi":"program MaximumNumber;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction GetMaximumNumber(n: Integer; a: string; f: array of Integer): string;\\nvar\\n  i, j: Integer;\\n  maxNum: string;\\nbegin\\n  maxNum := a;\\n\\n  \/\/ Iterate through each digit in the number\\n  for i := 1 to n do\\n  begin\\n    \/\/ Apply the function to the current digit\\n    maxNum[i] := Chr(f[Ord(maxNum[i]) - Ord('0')] + Ord('0'));\\n\\n    \/\/ Check if the new number is greater than the current maximum\\n    if maxNum > a then\\n      Exit(maxNum);\\n  end;\\n\\n  Result := maxNum;\\nend;\\n\\nvar\\n  n, i: Integer;\\n  a: string;\\n  f: array[1..9] of Integer;\\nbegin\\n  \/\/ Read input\\n  ReadLn(n);\\n  ReadLn(a);\\n  for i := 1 to 9 do\\n    Read(f[i]);\\n\\n  \/\/ Get the maximum number\\n  WriteLn(GetMaximumNumber(n, a, f));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar a string\\n\\tfmt.Scan(&a)\\n\\n\\tvar f [10]int\\n\\tfor i := 1; i <= 9; i++ {\\n\\t\\tfmt.Scan(&f[i])\\n\\t}\\n\\n\\tmaxNum := []byte(a)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tdigit := int(maxNum[i] - '0')\\n\\t\\tif f[digit] > digit {\\n\\t\\t\\tmaxNum[i] = byte(f[digit] + '0')\\n\\t\\t}\\n\\t}\\n\\n\\tmax, _ := strconv.Atoi(string(maxNum))\\n\\tfmt.Println(max)\\n}","Javascript":"function getMaxNumber(n, a, f) {\n    let maxNum = '';\n    let flag = false;\n    \n    for (let i = 0; i < n; i++) {\n        let digit = a[i];\n        let mappedDigit = f[digit - 1];\n        \n        if (mappedDigit > digit && !flag) {\n            maxNum += mappedDigit;\n            flag = true;\n        } else {\n            maxNum += digit;\n        }\n    }\n    \n    return maxNum;\n}\n\n\/\/ Read input\nconst n = parseInt(readline());\nconst a = readline();\nconst f = readline().split(' ').map(Number);\n\n\/\/ Call the function and print the result\nconst result = getMaxNumber(n, a, f);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val a = scanner.next()\n    val f = IntArray(10)\n    for (i in 1..9) {\n        f[i] = scanner.nextInt()\n    }\n    \n    val result = StringBuilder()\n    var i = 0\n    while (i < n) {\n        val digit = a[i].toInt() - '0'.toInt()\n        if (f[digit] > digit) {\n            while (i < n && f[digit] >= a[i].toInt() - '0'.toInt()) {\n                result.append(f[digit])\n                i++\n            }\n        } else {\n            result.append(a[i])\n            i++\n        }\n    }\n    \n    println(result.toString())\n}","PHP":"<?php\\n\\nfunction getMaxNumber($n, $a, $f) {\\n    $maxNumber = '';\\n    $isReplaced = false;\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        $digit = $a[$i];\\n        $replacedDigit = $f[$digit - 1];\\n\\n        if ($replacedDigit > $digit && !$isReplaced) {\\n            $maxNumber .= $replacedDigit;\\n            $isReplaced = true;\\n        } else {\\n            $maxNumber .= $digit;\\n        }\\n    }\\n\\n    return $maxNumber;\\n}\\n\\n\/\/ Read input\\n$n = intval(fgets(STDIN));\\n$a = trim(fgets(STDIN));\\n$f = array_map('intval', explode(' ', trim(fgets(STDIN))));\\n\\n\/\/ Get the maximum number\\n$maxNumber = getMaxNumber($n, $a, $f);\\n\\n\/\/ Print the result\\necho $maxNumber;\\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    string a;\\r\\n    int[9] f;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\\n\\\", &n);\\r\\n    readf(\\\"%s\\\\n\\\", &a);\\r\\n    readf(\\\"%s\\\\n\\\", &f);\\r\\n\\r\\n    \/\/ Apply the operation\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        int digit = a[i] - '0';\\r\\n        a[i] = cast(char)(f[digit - 1] + '0');\\r\\n    }\\r\\n\\r\\n    \/\/ Find the maximum number\\r\\n    int maxNum = to!int(a);\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(maxNum);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub maximum_number {\n    my ($n, $a, @f) = @_;\n\n    my @digits = split('', $a);\n    my $max_number = $a;\n\n    for my $i (0..$n-1) {\n        my $digit = $digits[$i];\n        my $new_digit = $f[$digit-1];\n\n        if ($new_digit > $digit) {\n            $digits[$i] = $new_digit;\n            my $number = join('', @digits);\n            $max_number = $number if $number > $max_number;\n            $digits[$i] = $digit;\n        }\n    }\n\n    return $max_number;\n}\n\n# Read input\nmy $n = <STDIN>;\nchomp($n);\nmy $a = <STDIN>;\nchomp($a);\nmy @f = split(' ', <STDIN>);\n\n# Call the function and print the result\nmy $result = maximum_number($n, $a, @f);\nprint $result;\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n\n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let a: Vec<char> = lines.next().unwrap().chars().collect();\n    let f: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n\n    let mut result = String::new();\n    let mut used = false;\n\n    for i in 0..n {\n        let digit = a[i].to_digit(10).unwrap() as usize;\n        let transformed = f[digit - 1];\n\n        if transformed > digit && !used {\n            result.push_str(&transformed.to_string());\n            used = true;\n        } else {\n            result.push_str(&digit.to_string());\n        }\n    }\n\n    println!(\"{}\", result);\n}"}
{"title":"C1. Power Transmission (Easy Edition)","description":"This problem is same as the next one, but has smaller constraints.It was a Sunday morning when the three friends Selena, Shiro and Katie decided to have a trip to the nearby power station (do not try this at home). After arriving at the power station, the cats got impressed with a large power transmission system consisting of many chimneys, electric poles, and wires. Since they are cats, they found those things gigantic.At the entrance of the station, there is a map describing the complicated wiring system. Selena is the best at math among three friends. He decided to draw the map on the Cartesian plane. Each pole is now a point at some coordinates $$$(x_i, y_i)$$$. Since every pole is different, all of the points representing these poles are distinct. Also, every two poles are connected with each other by wires. A wire is a straight line on the plane infinite in both directions. If there are more than two poles lying on the same line, they are connected by a single common wire.Selena thinks, that whenever two different electric wires intersect, they may interfere with each other and cause damage. So he wonders, how many pairs are intersecting? Could you help him with this problem?","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 50$$$)\u00a0\u2014 the number of electric poles.\nEach of the following $$$n$$$ lines contains two integers $$$x_i$$$, $$$y_i$$$ ($$$-10^4 \\\\le x_i, y_i \\\\le 10^4$$$)\u00a0\u2014 the coordinates of the poles.\nIt is guaranteed that all of these $$$n$$$ points are distinct.\n","output_spec":"Print a single integer\u00a0\u2014 the number of pairs of wires that are intersecting.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1163-C1","difficulty":1900,"tags":["brute+force","geometry"],"src_uid":"8c2e0cd780cf9390e933e28e57643cba","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nstruct Point {\\n    int x, y;\\n};\\n\\nbool cmp(Point a, Point b) {\\n    return a.x < b.x;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<Point> poles(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> poles[i].x >> poles[i].y;\\n    }\\n    sort(poles.begin(), poles.end(), cmp);\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = i + 1; j < n; j++) {\\n            for (int k = j + 1; k < n; k++) {\\n                if ((poles[j].y - poles[i].y) * (poles[k].x - poles[i].x) == (poles[k].y - poles[i].y) * (poles[j].x - poles[i].x)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n    }\\n    cout << ans << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class PowerStation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] poles = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            poles[i][0] = scanner.nextInt();\n            poles[i][1] = scanner.nextInt();\n        }\n        \n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    if (isIntersecting(poles[i], poles[j], poles[k])) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(count);\n    }\n    \n    public static boolean isIntersecting(int[] p1, int[] p2, int[] p3) {\n        int x1 = p1[0];\n        int y1 = p1[1];\n        int x2 = p2[0];\n        int y2 = p2[1];\n        int x3 = p3[0];\n        int y3 = p3[1];\n        \n        int dx1 = x2 - x1;\n        int dy1 = y2 - y1;\n        int dx2 = x3 - x1;\n        int dy2 = y3 - y1;\n        \n        int crossProduct = dx1 * dy2 - dx2 * dy1;\n        \n        return crossProduct != 0;\n    }\n}","Python":"def count_intersections(n, poles):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if is_intersecting(poles[i], poles[j], poles[k]):\n                    count += 1\n    return count\n\ndef is_intersecting(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    return (x1 - x2) * (y3 - y2) != (x3 - x2) * (y1 - y2)\n\nn = int(input())\npoles = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    poles.append((x, y))\n\nresult = count_intersections(n, poles)\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n\/\/ Structure to represent a point\\nstruct Point\\n{\\n    int x, y;\\n};\\n\\n\/\/ Function to find the number of pairs of wires that are intersecting\\nint countIntersectingPairs(struct Point poles[], int n)\\n{\\n    int count = 0;\\n\\n    \/\/ Iterate through all possible pairs of poles\\n    for (int i = 0; i < n - 1; i++)\\n    {\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            \/\/ Check if the two wires intersect\\n            if ((poles[i].x - poles[j].x) * (poles[i].y - poles[j].y) != 0)\\n            {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n}\\n\\nint main()\\n{\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n\\n    \/\/ Create an array of points to store the coordinates of the poles\\n    struct Point poles[n];\\n\\n    \/\/ Read the coordinates of the poles\\n    for (int i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d %d\\\", &poles[i].x, &poles[i].y);\\n    }\\n\\n    \/\/ Find the number of pairs of wires that are intersecting\\n    int intersectingPairs = countIntersectingPairs(poles, n);\\n\\n    \/\/ Print the result\\n    printf(\\\"%d\\\\n\\\", intersectingPairs);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace PowerStation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<Point> poles = new List<Point>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] coordinates = Console.ReadLine().Split();\n                int x = int.Parse(coordinates[0]);\n                int y = int.Parse(coordinates[1]);\n                poles.Add(new Point(x, y));\n            }\n\n            int intersectingPairs = CountIntersectingPairs(poles);\n            Console.WriteLine(intersectingPairs);\n        }\n\n        static int CountIntersectingPairs(List<Point> poles)\n        {\n            int intersectingPairs = 0;\n\n            for (int i = 0; i < poles.Count; i++)\n            {\n                for (int j = i + 1; j < poles.Count; j++)\n                {\n                    for (int k = j + 1; k < poles.Count; k++)\n                    {\n                        if (AreIntersecting(poles[i], poles[j], poles[k]))\n                        {\n                            intersectingPairs++;\n                        }\n                    }\n                }\n            }\n\n            return intersectingPairs;\n        }\n\n        static bool AreIntersecting(Point p1, Point p2, Point p3)\n        {\n            int x1 = p1.X;\n            int y1 = p1.Y;\n            int x2 = p2.X;\n            int y2 = p2.Y;\n            int x3 = p3.X;\n            int y3 = p3.Y;\n\n            int crossProduct1 = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n            int crossProduct2 = (x2 - x1) * (y3 - y2) - (y2 - y1) * (x3 - x2);\n\n            return crossProduct1 * crossProduct2 < 0;\n        }\n    }\n\n    class Point\n    {\n        public int X { get; set; }\n        public int Y { get; set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n}","Ruby":"\n# Function to calculate the number of pairs of intersecting wires\ndef count_intersecting_wires(poles)\n  n = poles.length\n  count = 0\n  \n  # Iterate through all possible pairs of poles\n  for i in 0..n-1\n    for j in i+1..n-1\n      # Check if the wires formed by the poles intersect\n      if intersect(poles[i], poles[j])\n        count += 1\n      end\n    end\n  end\n  \n  return count\nend\n\n# Function to check if two wires intersect\ndef intersect(pole1, pole2)\n  x1, y1 = pole1\n  x2, y2 = pole2\n  \n  # Check if the poles are on the same line\n  if x1 == x2 || y1 == y2\n    return false\n  end\n  \n  # Check if the wires intersect\n  if (x1 < x2 && y1 > y2) || (x1 > x2 && y1 < y2)\n    return true\n  end\n  \n  return false\nend\n\n# Read the number of poles from input\nn = gets.chomp.to_i\n\n# Read the coordinates of the poles from input\npoles = []\nfor i in 1..n\n  x, y = gets.chomp.split.map(&:to_i)\n  poles << [x, y]\nend\n\n# Calculate the number of pairs of intersecting wires\nresult = count_intersecting_wires(poles)\n\n# Print the result\nputs result\n","delphi":"Here is a possible implementation in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\n\/\/ Point represents a point in the Cartesian plane\\ntype Point struct {\\n\\tx, y int\\n}\\n\\n\/\/ Line represents a line connecting two points\\ntype Line struct {\\n\\tp1, p2 Point\\n}\\n\\n\/\/ Intersect checks if two lines intersect\\nfunc Intersect(l1, l2 Line) bool {\\n\\treturn (ccw(l1.p1, l2.p1, l2.p2) != ccw(l1.p2, l2.p1, l2.p2)) && (ccw(l1.p1, l1.p2, l2.p1) != ccw(l1.p1, l1.p2, l2.p2))\\n}\\n\\n\/\/ ccw checks the orientation of three points\\nfunc ccw(p1, p2, p3 Point) int {\\n\\treturn (p2.y-p1.y)*(p3.x-p2.x) - (p2.x-p1.x)*(p3.y-p2.y)\\n}\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tpoles := make([]Point, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&poles[i].x, &poles[i].y)\\n\\t}\\n\\n\\tlines := make([]Line, 0)\\n\\n\\t\/\/ Generate all possible lines\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tlines = append(lines, Line{poles[i], poles[j]})\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\n\\t\/\/ Check for intersections\\n\\tfor i := 0; i < len(lines)-1; i++ {\\n\\t\\tfor j := i + 1; j < len(lines); j++ {\\n\\t\\t\\tif Intersect(lines[i], lines[j]) {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function countIntersectingPairs(n, poles) {\n    let count = 0;\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (isIntersecting(poles[i], poles[j], poles[k])) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nfunction isIntersecting(pole1, pole2, pole3) {\n    let x1 = pole1[0];\n    let y1 = pole1[1];\n    let x2 = pole2[0];\n    let y2 = pole2[1];\n    let x3 = pole3[0];\n    let y3 = pole3[1];\n    \n    let slope1 = (y2 - y1) \/ (x2 - x1);\n    let slope2 = (y3 - y1) \/ (x3 - x1);\n    \n    return slope1 !== slope2;\n}\n\n\/\/ Example usage\nlet n = 4;\nlet poles = [[0, 0], [1, 1], [2, 2], [3, 3]];\nconsole.log(countIntersectingPairs(n, poles));","Kotlin":"import java.util.*\n\ndata class Point(val x: Int, val y: Int)\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val points = mutableListOf<Point>()\n    \n    for (i in 0 until n) {\n        val x = scanner.nextInt()\n        val y = scanner.nextInt()\n        points.add(Point(x, y))\n    }\n    \n    var count = 0\n    \n    for (i in 0 until n) {\n        for (j in i + 1 until n) {\n            for (k in j + 1 until n) {\n                if (isIntersecting(points[i], points[j], points[k])) {\n                    count++\n                }\n            }\n        }\n    }\n    \n    println(count)\n}\n\nfun isIntersecting(p1: Point, p2: Point, p3: Point): Boolean {\n    val x1 = p1.x.toDouble()\n    val y1 = p1.y.toDouble()\n    val x2 = p2.x.toDouble()\n    val y2 = p2.y.toDouble()\n    val x3 = p3.x.toDouble()\n    val y3 = p3.y.toDouble()\n    \n    val slope1 = (y2 - y1) \/ (x2 - x1)\n    val slope2 = (y3 - y1) \/ (x3 - x1)\n    \n    return slope1 != slope2\n} }","PHP":"<?php\\n\\nfunction countIntersectingPairs($n, $poles) {\\n    $count = 0;\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        for ($j = $i + 1; $j < $n; $j++) {\\n            for ($k = $j + 1; $k < $n; $k++) {\\n                if (areIntersecting($poles[$i], $poles[$j], $poles[$k])) {\\n                    $count++;\\n                }\\n            }\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\nfunction areIntersecting($p1, $p2, $p3) {\\n    $x1 = $p1[0];\\n    $y1 = $p1[1];\\n    $x2 = $p2[0];\\n    $y2 = $p2[1];\\n    $x3 = $p3[0];\\n    $y3 = $p3[1];\\n\\n    $slope1 = ($y2 - $y1) \/ ($x2 - $x1);\\n    $slope2 = ($y3 - $y1) \/ ($x3 - $x1);\\n\\n    return $slope1 != $slope2;\\n}\\n\\n\/\/ Example usage\\n$n = 4;\\n$poles = [\\n    [0, 0],\\n    [1, 1],\\n    [2, 2],\\n    [3, 3]\\n];\\n\\n$result = countIntersectingPairs($n, $poles);\\necho $result;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.range;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Point\\r\\n{\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isIntersecting(Point p1, Point p2, Point p3, Point p4)\\r\\n{\\r\\n    int d1 = (p3.x - p4.x) * (p1.y - p3.y) - (p3.y - p4.y) * (p1.x - p3.x);\\r\\n    int d2 = (p3.x - p4.x) * (p2.y - p3.y) - (p3.y - p4.y) * (p2.x - p3.x);\\r\\n    int d3 = (p1.x - p2.x) * (p3.y - p1.y) - (p1.y - p2.y) * (p3.x - p1.x);\\r\\n    int d4 = (p1.x - p2.x) * (p4.y - p1.y) - (p1.y - p2.y) * (p4.x - p1.x);\\r\\n\\r\\n    return (d1 * d2 < 0) && (d3 * d4 < 0);\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    Point[] poles;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        poles ~= Point(x, y);\\r\\n    }\\r\\n\\r\\n    int count = 0;\\r\\n    foreach (i, j; 0..n-1, 1..n)\\r\\n    {\\r\\n        foreach (k, l; i+1..n-1, i+2..n)\\r\\n        {\\r\\n            if (isIntersecting(poles[i], poles[j], poles[k], poles[l]))\\r\\n            {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_intersections {\n    my ($n, @points) = @_;\n\n    my $count = 0;\n\n    for my $i (0..$n-1) {\n        for my $j ($i+1..$n-1) {\n            my ($x1, $y1) = @{$points[$i]};\n            my ($x2, $y2) = @{$points[$j]};\n\n            for my $k ($j+1..$n-1) {\n                my ($x3, $y3) = @{$points[$k]};\n                my ($x4, $y4) = @{$points[$k+1]};\n\n                my $denominator = ($x1 - $x2) * ($y3 - $y4) - ($y1 - $y2) * ($x3 - $x4);\n\n                if ($denominator != 0) {\n                    my $t = (($x1 - $x3) * ($y3 - $y4) - ($y1 - $y3) * ($x3 - $x4)) \/ $denominator;\n                    my $u = -((($x1 - $x2) * ($y1 - $y3) - ($y1 - $y2) * ($x1 - $x3)) \/ $denominator);\n\n                    if ($t >= 0 && $t <= 1 && $u >= 0 && $u <= 1) {\n                        $count++;\n                    }\n                }\n            }\n        }\n    }\n\n    return $count;\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\n\nmy @points;\nfor (1..$n) {\n    my ($x, $y) = split ' ', <>;\n    push @points, [$x, $y];\n}\n\n# Count intersections\nmy $intersections = count_intersections($n, @points);\n\n# Print output\nprint \"$intersections\\n\";\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let mut poles: Vec<(i32, i32)> = Vec::new();\n    \n    for _ in 0..n {\n        let line = lines.next().unwrap();\n        let mut iter = line.split_whitespace();\n        let x: i32 = iter.next().unwrap().parse().unwrap();\n        let y: i32 = iter.next().unwrap().parse().unwrap();\n        poles.push((x, y));\n    }\n    \n    let mut count = 0;\n    \n    for i in 0..n {\n        for j in (i+1)..n {\n            for k in (j+1)..n {\n                for l in (k+1)..n {\n                    if intersect(poles[i], poles[j], poles[k], poles[l]) {\n                        count += 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    println!(\"{}\", count);\n}\n\nfn intersect(p1: (i32, i32), p2: (i32, i32), p3: (i32, i32), p4: (i32, i32)) -> bool {\n    let d1 = direction(p3, p4, p1);\n    let d2 = direction(p3, p4, p2);\n    let d3 = direction(p1, p2, p3);\n    let d4 = direction(p1, p2, p4);\n    \n    if ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0)) {\n        return true;\n    }\n    \n    if d1 == 0 && on_segment(p3, p4, p1) {\n        return true;\n    }\n    \n    if d2 == 0 && on_segment(p3, p4, p2) {\n        return true;\n    }\n    \n    if d3 == 0 && on_segment(p1, p2, p3) {\n        return true;\n    }\n    \n    if d4 == 0 && on_segment(p1, p2, p4) {\n        return true;\n    }\n    \n    false\n}\n\nfn direction(p1: (i32, i32), p2: (i32, i32), p3: (i32, i32)) -> i32 {\n    (p3.0 - p1.0) * (p2.1 - p1.1) - (p2.0 - p1.0) * (p3.1 - p1.1)\n}\n\nfn on_segment(p1: (i32, i32), p2: (i32, i32), p3: (i32, i32)) -> bool {\n    (p1.0 <= p3.0 && p3.0 <= p2.0 || p2.0 <= p3.0 && p3.0 <= p1.0) &&\n    (p1.1 <= p3.1 && p3.1 <= p2.1 || p2.1 <= p3.1 && p3.1 <= p1.1)\n}"}
{"title":"C2. Nauuo and Pictures (hard version)","description":"The only difference between easy and hard versions is constraints.Nauuo is a girl who loves random picture websites.One day she made a random picture website by herself which includes $$$n$$$ pictures.When Nauuo visits the website, she sees exactly one picture. The website does not display each picture with equal probability. The $$$i$$$-th picture has a non-negative weight $$$w_i$$$, and the probability of the $$$i$$$-th picture being displayed is $$$\\frac{w_i}{\\sum_{j=1}^nw_j}$$$. That is to say, the probability of a picture to be displayed is proportional to its weight.However, Nauuo discovered that some pictures she does not like were displayed too often. To solve this problem, she came up with a great idea: when she saw a picture she likes, she would add $$$1$$$ to its weight; otherwise, she would subtract $$$1$$$ from its weight.Nauuo will visit the website $$$m$$$ times. She wants to know the expected weight of each picture after all the $$$m$$$ visits modulo $$$998244353$$$. Can you help her?The expected weight of the $$$i$$$-th picture can be denoted by $$$\\frac {q_i} {p_i}$$$ where $$$\\gcd(p_i,q_i)=1$$$, you need to print an integer $$$r_i$$$ satisfying $$$0\\le r_i<998244353$$$ and $$$r_i\\cdot p_i\\equiv q_i\\pmod{998244353}$$$. It can be proved that such $$$r_i$$$ exists and is unique.","input_from":"standard input","output_to":"standard output","time_limit":"4 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\\\\le n\\\\le 2\\\\cdot 10^5$$$, $$$1\\\\le m\\\\le 3000$$$) \u2014 the number of pictures and the number of visits to the website.\nThe second line contains $$$n$$$ integers $$$a_1,a_2,\\\\ldots,a_n$$$ ($$$a_i$$$ is either $$$0$$$ or $$$1$$$) \u2014 if $$$a_i=0$$$ , Nauuo does not like the $$$i$$$-th picture; otherwise Nauuo likes the $$$i$$$-th picture. It is guaranteed that there is at least one picture which Nauuo likes.\nThe third line contains $$$n$$$ positive integers $$$w_1,w_2,\\\\ldots,w_n$$$ ($$$w_i \\\\geq 1$$$) \u2014 the initial weights of the pictures. It is guaranteed that the sum of all the initial weights does not exceed $$$998244352-m$$$.\n","output_spec":"The output contains $$$n$$$ integers $$$r_1,r_2,\\\\ldots,r_n$$$ \u2014 the expected weights modulo $$$998244353$$$.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1172-C2","difficulty":2600,"tags":["dp","probabilities"],"src_uid":"ba9c136f84375cd317f0f8b53e3939c7","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 998244353;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    vector<int> like(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> like[i];\\n    }\\n\\n    vector<int> weight(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> weight[i];\\n    }\\n\\n    int totalWeight = 0;\\n    for (int i = 0; i < n; i++) {\\n        totalWeight += weight[i];\\n    }\\n\\n    vector<int> numerator(n, 0);\\n    vector<int> denominator(n, 0);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (like[i] == 1) {\\n            numerator[i] = totalWeight;\\n        } else {\\n            denominator[i] = totalWeight;\\n        }\\n    }\\n\\n    for (int i = 0; i < m; i++) {\\n        int sumNumerator = 0;\\n        int sumDenominator = 0;\\n\\n        for (int j = 0; j < n; j++) {\\n            sumNumerator += numerator[j];\\n            sumDenominator += denominator[j];\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            numerator[j] = (numerator[j] * (sumNumerator + sumDenominator)) % MOD;\\n            denominator[j] = (denominator[j] * (sumNumerator + sumDenominator)) % MOD;\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if (like[j] == 1) {\\n                numerator[j] = (numerator[j] + weight[j]) % MOD;\\n            } else {\\n                denominator[j] = (denominator[j] + weight[j]) % MOD;\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        int gcd = __gcd(numerator[i], denominator[i]);\\n        int ri = (numerator[i] \/ gcd) % MOD;\\n        cout << ri << \\\" \\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        int[] likes = new int[n];\n        for (int i = 0; i < n; i++) {\n            likes[i] = scanner.nextInt();\n        }\n        \n        int[] weights = new int[n];\n        for (int i = 0; i < n; i++) {\n            weights[i] = scanner.nextInt();\n        }\n        \n        int totalWeight = 0;\n        for (int weight : weights) {\n            totalWeight += weight;\n        }\n        \n        int[] numerator = new int[n];\n        int[] denominator = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            numerator[i] = weights[i];\n            denominator[i] = totalWeight;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int sumNumerator = 0;\n            int sumDenominator = 0;\n            \n            for (int j = 0; j < n; j++) {\n                if (likes[j] == 1) {\n                    numerator[j]++;\n                } else {\n                    numerator[j]--;\n                }\n                \n                sumNumerator += numerator[j];\n                sumDenominator += denominator[j];\n            }\n            \n            totalWeight += sumNumerator;\n            \n            for (int j = 0; j < n; j++) {\n                denominator[j] = totalWeight;\n            }\n        }\n        \n        int mod = 998244353;\n        for (int i = 0; i < n; i++) {\n            int gcd = gcd(numerator[i], denominator[i]);\n            int ri = (numerator[i] \/ gcd) % mod;\n            System.out.print(ri + \\\" \\\");\n        }\n    }\n    \n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n}","Python":"def expected_weights(n, m, likes, weights):\\n    total_weight = sum(weights)\\n    probabilities = [w \/ total_weight for w in weights]\\n    expected_weights = [0] * n\\n\\n    for _ in range(m):\\n        total_probability = sum(probabilities)\\n        new_probabilities = [p \/ total_probability for p in probabilities]\\n\\n        for i in range(n):\\n            if likes[i] == 1:\\n                expected_weights[i] += new_probabilities[i]\\n            else:\\n                expected_weights[i] -= new_probabilities[i]\\n\\n        probabilities = new_probabilities\\n\\n    return [int(w % 998244353) for w in expected_weights]\\n\\n\\n# Example usage\\nn = 3\\nm = 2\\nlikes = [1, 0, 1]\\nweights = [2, 3, 4]\\n\\nexpected_weights = expected_weights(n, m, likes, weights)\\nprint(expected_weights)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MOD 998244353\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n\\n    int *likes = (int *)malloc(n * sizeof(int));\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &likes[i]);\\n    }\\n\\n    int *weights = (int *)malloc(n * sizeof(int));\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &weights[i]);\\n    }\\n\\n    int totalWeight = 0;\\n    for (int i = 0; i < n; i++) {\\n        totalWeight += weights[i];\\n    }\\n\\n    int *numerator = (int *)malloc(n * sizeof(int));\\n    int *denominator = (int *)malloc(n * sizeof(int));\\n\\n    for (int i = 0; i < n; i++) {\\n        numerator[i] = weights[i];\\n        denominator[i] = totalWeight;\\n    }\\n\\n    for (int i = 0; i < m; i++) {\\n        int sumNumerator = 0;\\n        int sumDenominator = 0;\\n\\n        for (int j = 0; j < n; j++) {\\n            sumNumerator += numerator[j];\\n            sumDenominator += denominator[j];\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if (likes[j] == 1) {\\n                numerator[j] = (numerator[j] + sumNumerator) % MOD;\\n            } else {\\n                numerator[j] = (numerator[j] - sumNumerator + MOD) % MOD;\\n            }\\n\\n            denominator[j] = (denominator[j] + sumDenominator) % MOD;\\n\\n            int gcdVal = gcd(numerator[j], denominator[j]);\\n            numerator[j] = (numerator[j] \/ gcdVal) % MOD;\\n            denominator[j] = (denominator[j] \/ gcdVal) % MOD;\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        printf(\\\"%d \\\", numerator[i]);\\n    }\\n\\n    free(likes);\\n    free(weights);\\n    free(numerator);\\n    free(denominator);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n\n        int[] likes = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n        int[] weights = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n        int totalWeight = 0;\n        for (int i = 0; i < n; i++)\n        {\n            totalWeight += weights[i];\n        }\n\n        int[] numerator = new int[n];\n        int[] denominator = new int[n];\n\n        for (int i = 0; i < n; i++)\n        {\n            numerator[i] = likes[i] == 1 ? weights[i] : 0;\n            denominator[i] = totalWeight;\n        }\n\n        int mod = 998244353;\n\n        for (int i = 0; i < m; i++)\n        {\n            int[] newNumerator = new int[n];\n            int[] newDenominator = new int[n];\n\n            int sumNumerator = 0;\n            int sumDenominator = 0;\n\n            for (int j = 0; j < n; j++)\n            {\n                sumNumerator = (sumNumerator + numerator[j]) % mod;\n                sumDenominator = (sumDenominator + denominator[j]) % mod;\n            }\n\n            for (int j = 0; j < n; j++)\n            {\n                newNumerator[j] = (numerator[j] * (sumDenominator - denominator[j]) + (sumNumerator - numerator[j]) * denominator[j]) % mod;\n                newDenominator[j] = (denominator[j] * sumDenominator) % mod;\n            }\n\n            numerator = newNumerator;\n            denominator = newDenominator;\n        }\n\n        for (int i = 0; i < n; i++)\n        {\n            int gcd = GCD(numerator[i], denominator[i]);\n            int ri = (numerator[i] \/ gcd) % mod;\n\n            Console.Write(ri + \\\" \\\");\n        }\n    }\n\n    public static int GCD(int a, int b)\n    {\n        if (b == 0)\n            return a;\n        else\n            return GCD(b, a % b);\n    }\n}","Ruby":"def expected_weights(n, m, likes, weights)\\n  mod = 998244353\\n  total_weight = weights.sum\\n  probabilities = weights.map { |w| w.to_f \/ total_weight }\\n\\n  likes.each_with_index do |like, i|\\n    if like == 1\\n      weights[i] += 1\\n      total_weight += 1\\n    else\\n      weights[i] -= 1\\n      total_weight -= 1\\n    end\\n\\n    probabilities[i] = weights[i].to_f \/ total_weight\\n  end\\n\\n  m.times do\\n    new_probabilities = Array.new(n, 0)\\n\\n    n.times do |i|\\n      n.times do |j|\\n        new_probabilities[i] += probabilities[j] * (weights[i].to_f \/ total_weight)\\n      end\\n    end\\n\\n    probabilities = new_probabilities\\n  end\\n\\n  expected_weights = probabilities.map { |p| (p * total_weight).to_i % mod }\\n\\n  expected_weights.join(' ')\\nend\\n\\nn, m = gets.chomp.split.map(&:to_i)\\nlikes = gets.chomp.split.map(&:to_i)\\nweights = gets.chomp.split.map(&:to_i)\\n\\nputs expected_weights(n, m, likes, weights)","delphi":"var\\n  n, m, i, j, sum, like, dislike: integer;\\n  a: array[1..200000] of integer;\\n  w: array[1..200000] of integer;\\n  p: array[1..200000] of integer;\\n  q: array[1..200000] of integer;\\n  r: array[1..200000] of integer;\\n  inv: array[1..200000] of integer;\\n  f: array[0..3000, 0..3000] of integer;\\n  g: array[0..3000, 0..3000] of integer;\\n  fac: array[0..3000] of integer;\\n  invfac: array[0..3000] of integer;\\n\\nfunction power(a, b: integer): integer;\\nvar\\n  res: integer;\\nbegin\\n  res := 1;\\n  while b > 0 do\\n  begin\\n    if b and 1 = 1 then\\n      res := int64(res) * a mod 998244353;\\n    a := int64(a) * a mod 998244353;\\n    b := b shr 1;\\n  end;\\n  power := res;\\nend;\\n\\nfunction invmod(a: integer): integer;\\nbegin\\n  invmod := power(a, 998244353 - 2);\\nend;\\n\\nbegin\\n  readln(n, m);\\n  for i := 1 to n do\\n    read(a[i]);\\n  for i := 1 to n do\\n    read(w[i]);\\n  sum := 0;\\n  like := 0;\\n  dislike := 0;\\n  for i := 1 to n do\\n  begin\\n    sum := (sum + w[i]) mod 998244353;\\n    if a[i] = 1 then\\n      like := (like + w[i]) mod 998244353\\n    else\\n      dislike := (dislike + w[i]) mod 998244353;\\n  end;\\n  for i := 1 to n do\\n  begin\\n    p[i] := (sum - w[i] + 998244353) mod 998244353;\\n    q[i] := (like + w[i] - dislike + 998244353) mod 998244353;\\n    r[i] := int64(q[i]) * invmod(p[i]) mod 998244353;\\n  end;\\n  for i := 0 to m do\\n    f[i, 0] := 1;\\n  for i := 1 to m do\\n    for j := 1 to i do\\n      f[i, j] := (f[i - 1, j] + int64(f[i - 1, j - 1]) * j) mod 998244353;\\n  fac[0] := 1;\\n  for i := 1 to m do\\n    fac[i] := int64(fac[i - 1]) * i mod 998244353;\\n  invfac[m] := invmod(fac[m]);\\n  for i := m - 1 downto 0 do\\n    invfac[i] := int64(invfac[i + 1]) * (i + 1) mod 998244353;\\n  for i := 0 to m do\\n    g[m, i] := int64(fac[i]) * invfac[i] mod 998244353;\\n  for i := m - 1 downto 0 do\\n    for j := 0 to i do\\n      g[i, j] := (g[i + 1, j] + int64(g[i + 1, j + 1]) * (j + 1)) mod 998244353;\\n  for i := 1 to n do\\n  begin\\n    inv[i] := invmod(p[i]);\\n    for j := 0 to m do\\n      r[i] := (r[i] + int64(f[m, j]) * g[m - j, m - j] mod 998244353 * power(inv[i], j) mod 998244353 * power(998244353 - inv[i], m - j) mod 998244353) mod 998244353;\\n  end;\\n  for i := 1 to n do\\n    writeln(r[i]);\\nend;","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nconst mod = 998244353\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn := parseInt(scanner.Text())\\n\\tscanner.Scan()\\n\\tm := parseInt(scanner.Text())\\n\\n\\tlikes := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tlikes[i] = parseInt(scanner.Text())\\n\\t}\\n\\n\\tweights := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tweights[i] = parseInt(scanner.Text())\\n\\t}\\n\\n\\tprefixSum := make([]int, n)\\n\\tprefixSum[0] = weights[0]\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tprefixSum[i] = prefixSum[i-1] + weights[i]\\n\\t}\\n\\n\\ttotalSum := prefixSum[n-1]\\n\\n\\texpectedWeights := make([]int, n)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tnewWeights := make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif likes[j] == 1 {\\n\\t\\t\\t\\tnewWeights[j] = (totalSum - prefixSum[j] + weights[j]) % mod\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnewWeights[j] = (prefixSum[j] - weights[j]) % mod\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprefixSum[0] = newWeights[0]\\n\\t\\tfor j := 1; j < n; j++ {\\n\\t\\t\\tprefixSum[j] = (prefixSum[j-1] + newWeights[j]) % mod\\n\\t\\t}\\n\\n\\t\\ttotalSum = prefixSum[n-1]\\n\\n\\t\\tweights = newWeights\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\texpectedWeights[i] = (weights[i] + mod) % mod\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Printf(\\\"%d \\\", expectedWeights[i])\\n\\t}\\n}\\n\\nfunc parseInt(s string) int {\\n\\tvar res int\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tres = (res*10 + int(s[i]-'0')) % mod\\n\\t}\\n\\treturn res\\n}","Javascript":"function gcd(a, b) {\n    if (b === 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nfunction moduloInverse(a, m) {\n    let m0 = m;\n    let y = 0;\n    let x = 1;\n\n    if (m === 1) {\n        return 0;\n    }\n\n    while (a > 1) {\n        let q = Math.floor(a \/ m);\n        let t = m;\n\n        m = a % m;\n        a = t;\n        t = y;\n\n        y = x - q * y;\n        x = t;\n    }\n\n    if (x < 0) {\n        x += m0;\n    }\n\n    return x;\n}\n\nfunction calculateExpectedWeights(n, m, likes, weights) {\n    const MOD = 998244353;\n    let totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\n    let probabilities = weights.map(weight => weight \/ totalWeight);\n\n    let numerator = Array(n).fill(0);\n    let denominator = Array(n).fill(0);\n\n    for (let i = 0; i < n; i++) {\n        if (likes[i] === 1) {\n            numerator[i] = weights[i];\n        } else {\n            denominator[i] = weights[i];\n        }\n    }\n\n    for (let i = 0; i < m; i++) {\n        let newNumerator = Array(n).fill(0);\n        let newDenominator = Array(n).fill(0);\n\n        let totalNumerator = numerator.reduce((sum, num) => sum + num, 0);\n        let totalDenominator = denominator.reduce((sum, den) => sum + den, 0);\n\n        for (let j = 0; j < n; j++) {\n            let p = numerator[j] \/ totalNumerator;\n            let q = denominator[j] \/ totalDenominator;\n\n            let newP = (p * (totalNumerator + 1) + q * totalDenominator) \/ (totalNumerator + totalDenominator + 1);\n            let newQ = (q * (totalDenominator + 1) + p * totalNumerator) \/ (totalNumerator + totalDenominator + 1);\n\n            newNumerator[j] = Math.floor(newP * totalWeight) % MOD;\n            newDenominator[j] = Math.floor(newQ * totalWeight) % MOD;\n        }\n\n        numerator = newNumerator;\n        denominator = newDenominator;\n    }\n\n    let result = [];\n    let inverseTotalWeight = moduloInverse(totalWeight, MOD);\n\n    for (let i = 0; i < n; i++) {\n        let p = numerator[i] * inverseTotalWeight % MOD;\n        let q = denominator[i] * inverseTotalWeight % MOD;\n\n        let gcdValue = gcd(p, q);\n        p \/= gcdValue;\n        q \/= gcdValue;\n\n        result.push(p);\n    }\n\n    return result;\n}\n\n\/\/ Example usage\nlet n = 3;\nlet m = 2;\nlet likes = [1, 0, 1];\nlet weights = [2, 3, 4];\n\nlet expectedWeights = calculateExpectedWeights(n, m, likes, weights);\nconsole.log(expectedWeights.join(' '));","Kotlin":"import java.util.*\n\nfun main() {\n    val mod = 998244353\n\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n\n    val likes = IntArray(n)\n    for (i in 0 until n) {\n        likes[i] = scanner.nextInt()\n    }\n\n    val weights = IntArray(n)\n    for (i in 0 until n) {\n        weights[i] = scanner.nextInt()\n    }\n\n    val totalWeight = weights.sum()\n    val prefixSum = IntArray(n)\n    prefixSum[0] = weights[0]\n    for (i in 1 until n) {\n        prefixSum[i] = prefixSum[i - 1] + weights[i]\n    }\n\n    val dp = Array(m + 1) { LongArray(n) }\n    dp[0] = weights.map { it.toLong() }.toLongArray()\n\n    for (i in 1..m) {\n        for (j in 0 until n) {\n            val numerator = dp[i - 1][j] * (totalWeight + i - 1) % mod\n            val denominator = prefixSum[n - 1] + i - 1\n            dp[i][j] = numerator * modInverse(denominator, mod) % mod\n\n            if (j > 0) {\n                dp[i][j] = (dp[i][j] + dp[i][j - 1]) % mod\n            }\n\n            if (likes[j] == 1) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            }\n        }\n    }\n\n    val result = dp[m].joinToString(\" \")\n    println(result)\n}\n\nfun modInverse(a: Long, m: Long): Long {\n    var a = a\n    var m = m\n    var x0: Long = 0\n    var x1: Long = 1\n    var y: Long\n    var temp: Long\n    while (a > 1) {\n        y = a \/ m\n        temp = m\n        m = a % m\n        a = temp\n        temp = x0\n        x0 = x1 - y * x0\n        x1 = temp\n    }\n    if (x1 < 0) {\n        x1 += m\n    }\n    return x1\n}","PHP":"\n<?php\n\nfunction gcd($a, $b) {\n    if ($b == 0) {\n        return $a;\n    }\n    return gcd($b, $a % $b);\n}\n\nfunction inverseMod($a, $m) {\n    $m0 = $m;\n    $x0 = 0;\n    $x1 = 1;\n\n    if ($m == 1) {\n        return 0;\n    }\n\n    while ($a > 1) {\n        $q = (int)($a \/ $m);\n        $t = $m;\n\n        $m = $a % $m;\n        $a = $t;\n        $t = $x0;\n\n        $x0 = $x1 - $q * $x0;\n        $x1 = $t;\n    }\n\n    if ($x1 < 0) {\n        $x1 += $m0;\n    }\n\n    return $x1;\n}\n\nfunction solve($n, $m, $likes, $weights) {\n    $sumWeights = array_sum($weights);\n    $invSumWeights = inverseMod($sumWeights, 998244353);\n\n    $numerator = array_fill(0, $n, 0);\n    $denominator = array_fill(0, $n, 0);\n\n    for ($i = 0; $i < $n; $i++) {\n        if ($likes[$i] == 1) {\n            $numerator[$i] = $weights[$i] * $invSumWeights;\n        } else {\n            $denominator[$i] = $weights[$i] * $invSumWeights;\n        }\n    }\n\n    $dp = array_fill(0, $m + 1, array_fill(0, $n, 0));\n    $dp[0] = $denominator;\n\n    for ($i = 1; $i <= $m; $i++) {\n        $sum = array_sum($dp[$i - 1]);\n        $invSum = inverseMod($sum, 998244353);\n\n        for ($j = 0; $j < $n; $j++) {\n            $dp[$i][$j] = ($numerator[$j] + $dp[$i - 1][$j] * $sum) * $invSum;\n            $dp[$i][$j] %= 998244353;\n        }\n    }\n\n    $result = array();\n    for ($i = 0; $i < $n; $i++) {\n        $result[] = $dp[$m][$i];\n    }\n\n    return $result;\n}\n\n\/\/ Read input\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\nlist($n, $m) = explode(\\\" \\\", $input[0]);\n$likes = explode(\\\" \\\", $input[1]);\n$weights = explode(\\\" \\\", $input[2]);\n\n\/\/ Convert input to integers\n$n = (int)$n;\n$m = (int)$m;\n$likes = array_map('intval', $likes);\n$weights = array_map('intval', $weights);\n\n\/\/ Solve the problem\n$result = solve($n, $m, $likes, $weights);\n\n\/\/ Print the result\necho implode(\\\" \\\", $result);\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.math;\\r\\n\\r\\nconst int MOD = 998244353;\\r\\n\\r\\nint[] solve(int n, int m, int[] a, int[] w)\\r\\n{\\r\\n    int totalWeight = w.reduce!((a, b) => a + b);\\r\\n    int[] q = new int[n];\\r\\n    int[] p = new int[n];\\r\\n\\r\\n    foreach (i, weight; w)\\r\\n    {\\r\\n        if (a[i] == 1)\\r\\n        {\\r\\n            q[i] = weight;\\r\\n            p[i] = totalWeight;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            q[i] = 0;\\r\\n            p[i] = totalWeight - weight;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[] dp = new int[totalWeight + 1];\\r\\n    dp[0] = 1;\\r\\n\\r\\n    foreach (i, weight; w)\\r\\n    {\\r\\n        if (a[i] == 1)\\r\\n        {\\r\\n            for (int j = totalWeight; j >= weight; j--)\\r\\n            {\\r\\n                dp[j] = (dp[j] + dp[j - weight]) % MOD;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            for (int j = weight; j <= totalWeight; j++)\\r\\n            {\\r\\n                dp[j] = (dp[j] + dp[j - weight]) % MOD;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[] result = new int[n];\\r\\n\\r\\n    foreach (i, weight; w)\\r\\n    {\\r\\n        if (a[i] == 1)\\r\\n        {\\r\\n            for (int j = 0; j <= totalWeight; j++)\\r\\n            {\\r\\n                result[i] = (result[i] + dp[j] * q[i] % MOD * p[i] % MOD * modInv(totalWeight, MOD) % MOD) % MOD;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            for (int j = 0; j <= totalWeight; j++)\\r\\n            {\\r\\n                result[i] = (result[i] + dp[j] * q[i] % MOD * (totalWeight - p[i]) % MOD * modInv(totalWeight, MOD) % MOD) % MOD;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n}\\r\\n\\r\\nint modInv(int a, int m)\\r\\n{\\r\\n    int x, y;\\r\\n    int g = gcdExtended(a, m, x, y);\\r\\n\\r\\n    if (g != 1)\\r\\n    {\\r\\n        return -1;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return (x % m + m) % m;\\r\\n    }\\r\\n}\\r\\n\\r\\nint gcdExtended(int a, int b, out int x, out int y)\\r\\n{\\r\\n    if (a == 0)\\r\\n    {\\r\\n        x = 0;\\r\\n        y = 1;\\r\\n        return b;\\r\\n    }\\r\\n\\r\\n    int x1, y1;\\r\\n    int gcd = gcdExtended(b % a, a, x1, y1);\\r\\n\\r\\n    x = y1 - (b \/ a) * x1;\\r\\n    y = x1;\\r\\n\\r\\n    return gcd;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[] a = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    int[] w = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &w[i]);\\r\\n    }\\r\\n\\r\\n    int[] result = solve(n, m, a, w);\\r\\n\\r\\n    foreach (weight; result)\\r\\n    {\\r\\n        writef(\\\"%d \\\", weight);\\r\\n    }\\r\\n}\\r\\n","perl":"use strict;\\nuse warnings;\\n\\nsub expected_weights {\\n    my ($n, $m, $likes, $weights) = @_;\\n    my $mod = 998244353;\\n    my $sum_weights = 0;\\n    my $sum_likes = 0;\\n    my @expected_weights;\\n\\n    for my $i (0..$n-1) {\\n        $sum_weights += $weights->[$i];\\n        $sum_likes += $weights->[$i] if $likes->[$i];\\n    }\\n\\n    for my $i (0..$n-1) {\\n        my $numerator = $sum_likes;\\n        my $denominator = $sum_weights;\\n\\n        if ($likes->[$i]) {\\n            $numerator += $weights->[$i];\\n        } else {\\n            $numerator -= $weights->[$i];\\n        }\\n\\n        my $gcd = gcd($numerator, $denominator);\\n        $numerator = ($numerator \/ $gcd) % $mod;\\n        $denominator = ($denominator \/ $gcd) % $mod;\\n\\n        push @expected_weights, $numerator;\\n    }\\n\\n    return @expected_weights;\\n}\\n\\nsub gcd {\\n    my ($a, $b) = @_;\\n\\n    while ($b) {\\n        ($a, $b) = ($b, $a % $b);\\n    }\\n\\n    return $a;\\n}\\n\\n# Read input\\nmy ($n, $m) = split ' ', <STDIN>;\\nmy @likes = split ' ', <STDIN>;\\nmy @weights = split ' ', <STDIN>;\\n\\n# Calculate expected weights\\nmy @expected_weights = expected_weights($n, $m, \\@likes, \\@weights);\\n\\n# Print output\\nprint join(' ', @expected_weights), \\\"\\\\n\\\";","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nm: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n    \n    let a: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let w: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut sum_w = 0;\n    let mut sum_a = 0;\n    for i in 0..n {\n        sum_w += w[i];\n        sum_a += a[i];\n    }\n    \n    let mut p: Vec<usize> = vec![0; n];\n    let mut q: Vec<usize> = vec![0; n];\n    \n    for i in 0..n {\n        p[i] = sum_w;\n        q[i] = sum_a * w[i];\n        sum_w -= w[i];\n        sum_a -= a[i];\n    }\n    \n    let mut dp: Vec<Vec<usize>> = vec![vec![0; m + 1]; n + 1];\n    dp[0][0] = 1;\n    \n    for i in 1..=n {\n        for j in 0..=m {\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % 998244353;\n            if j >= q[i - 1] {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - q[i - 1]]) % 998244353;\n            }\n        }\n    }\n    \n    let mut ans: Vec<usize> = vec![0; n];\n    \n    for i in 0..=m {\n        for j in 0..n {\n            ans[j] = (ans[j] + dp[n][i] * p[j]) % 998244353;\n        }\n    }\n    \n    for i in 0..n {\n        println!(\"{}\", ans[i]);\n    }\n}"}
{"title":"B. Very Interesting Game","description":"In a very ancient country the following game was popular. Two people play the game. Initially first player writes a string s1, consisting of exactly nine digits and representing a number that does not exceed a. After that second player looks at s1 and writes a string s2, consisting of exactly nine digits and representing a number that does not exceed b. Here a and b are some given constants, s1 and s2 are chosen by the players. The strings are allowed to contain leading zeroes.If a number obtained by the concatenation (joining together) of strings s1 and s2 is divisible by mod, then the second player wins. Otherwise the first player wins. You are given numbers a, b, mod. Your task is to determine who wins if both players play in the optimal manner. If the first player wins, you are also required to find the lexicographically minimum winning move.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three integers a, b, mod (0\u2264a,b\u226410^9, 1\u2264mod\u226410^7).\n","output_spec":"If the first player wins, print \"1\" and the lexicographically minimum string s1 he has to write to win. If the second player wins, print the single number \"2\".\n","notes":"The lexical comparison of strings is performed by the < operator in modern programming languages. String x is lexicographically less than string y if exists such i (1\u2264i\u22649), that xi<yi, and for any j (1\u2264j<i) xj=yj. These strings always have length 9.\n","sample_inputs":["1 10 7\n","4 0 9\n"],"sample_outputs":["2\n","1 000000001\n"],"id":"117-B","difficulty":1800,"tags":["brute+force","number+theory"],"src_uid":"8b6f633802293202531264446d33fee5","C++":"#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nstring findOptimalMove(int a, int b, int mod) {\\n    string s1;\\n    for (int i = 0; i <= 9; i++) {\\n        for (int j = 0; j <= 9; j++) {\\n            s1 = to_string(i) + string(9, '0') + to_string(j);\\n            int num = stoi(s1);\\n            if (num % mod == 0 && num <= a) {\\n                return s1;\\n            }\\n        }\\n    }\\n    return \\\"\\\";\\n}\\n\\nint main() {\\n    int a, b, mod;\\n    cin >> a >> b >> mod;\\n\\n    string optimalMove = findOptimalMove(a, b, mod);\\n    if (optimalMove.empty()) {\\n        cout << \\\"2\\\" << endl;\\n    } else {\\n        cout << \\\"1 \\\" << optimalMove << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class GameWinner {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int a = scanner.nextInt();\\n        int b = scanner.nextInt();\\n        int mod = scanner.nextInt();\\n\\n        if (mod == 1) {\\n            System.out.println(\\\"2\\\");\\n        } else {\\n            boolean found = false;\\n            String s1 = \\\"\\\";\\n\\n            for (int i = 1; i <= 9; i++) {\\n                for (int j = 0; j <= 9; j++) {\\n                    if ((a * 10 + i) % mod == 0 && (b * 10 + j) % mod == 0) {\\n                        found = true;\\n                        s1 = String.format(\\\"%09d\\\", a * 10 + i);\\n                        break;\\n                    }\\n                }\\n                if (found) {\\n                    break;\\n                }\\n            }\\n\\n            if (found) {\\n                System.out.println(\\\"1 \\\" + s1);\\n            } else {\\n                System.out.println(\\\"2\\\");\\n            }\\n        }\\n    }\\n}\" }","Python":"def find_winning_move(a, b, mod):\\n    if a % mod == 0:\\n        return '2'\\n    else:\\n        for i in range(1, 10):\\n            s1 = str(i).zfill(9)\\n            if int(s1 + str(b)) % mod == 0:\\n                return '1 ' + s1\\n        return '2'\\n\\na, b, mod = map(int, input().split())\\nprint(find_winning_move(a, b, mod))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int a, b, mod;\\n    scanf(\\\"%d %d %d\\\", &a, &b, &mod);\\n\\n    int first_player_wins = 0;\\n    char s1[10];\\n\\n    \/\/ Check all possible values of s1\\n    for (int i = 0; i <= a; i++) {\\n        sprintf(s1, \\\"%09d\\\", i);\\n\\n        \/\/ Check if concatenation of s1 and s2 is divisible by mod\\n        for (int j = 0; j <= b; j++) {\\n            char s2[10];\\n            sprintf(s2, \\\"%09d\\\", j);\\n\\n            long long int num = atoll(strcat(s1, s2));\\n\\n            if (num % mod == 0) {\\n                first_player_wins = 1;\\n                break;\\n            }\\n        }\\n\\n        if (first_player_wins) {\\n            break;\\n        }\\n    }\\n\\n    if (first_player_wins) {\\n        printf(\\\"1 %s\\\\n\\\", s1);\\n    } else {\\n        printf(\\\"2\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int a = int.Parse(input[0]);\n        int b = int.Parse(input[1]);\n        int mod = int.Parse(input[2]);\n\n        if (a % mod == 0)\n        {\n            Console.WriteLine(\\\"1 000000000\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"2\\\");\n        }\n    }\n}","Ruby":"\ndef winning_move(a, b, mod)\n  if a % mod == 0\n    return \"2\\n\"\n  end\n\n  for i in 1..9\n    s1 = \"1\" * i + \"0\" * (9 - i)\n    if (s1.to_i * (10**9) + b) % mod == 0\n      return \"1 #{s1}\\n\"\n    end\n  end\n\n  return \"2\\n\"\nend\n\ninput = gets.chomp.split(' ')\na = input[0].to_i\nb = input[1].to_i\nmod = input[2].to_i\n\nputs winning_move(a, b, mod)\n","delphi":"program LexicographicallyMinimumWinningMove;\\n\\nvar\\n  a, b, modVal: Int64;\\n  s1: string;\\n\\nbegin\\n  \/\/ Read input values\\n  Readln(a, b, modVal);\\n\\n  \/\/ Check if second player wins\\n  if (a mod modVal = 0) or (b mod modVal = 0) then\\n  begin\\n    Writeln('2');\\n    Exit;\\n  end;\\n\\n  \/\/ Find lexicographically minimum winning move\\n  s1 := '1';\\n  while Length(s1) < 9 do\\n  begin\\n    if (StrToInt64(s1 + '0') mod modVal = 0) then\\n      Break;\\n    s1 := s1 + '0';\\n  end;\\n\\n  \/\/ Print result\\n  Writeln('1 ', s1);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar a, b, mod int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &a, &b, &mod)\\n\\n\\tif a%mod == 0 {\\n\\t\\tfmt.Println(\\\"1 000000000\\\")\\n\\t} else {\\n\\t\\tfor i := 1; i <= 9; i++ {\\n\\t\\t\\tnum := (mod - (a%mod)*intPow(10, i-1)%mod) % mod\\n\\t\\t\\tif num <= b {\\n\\t\\t\\t\\ts2 := fmt.Sprintf(\\\"%09d\\\", num)\\n\\t\\t\\t\\ts1 := fmt.Sprintf(\\\"%09d\\\", a%intPow(10, i))\\n\\t\\t\\t\\tfmt.Println(\\\"1\\\", s1+s2)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfmt.Println(\\\"2\\\")\\n\\t}\\n}\\n\\nfunc intPow(x, y int) int {\\n\\tresult := 1\\n\\tfor i := 0; i < y; i++ {\\n\\t\\tresult *= x\\n\\t}\\n\\treturn result\\n}","Javascript":"\nfunction findOptimalMove(a, b, mod) {\n    let firstPlayerWins = false;\n    let optimalMove = '';\n\n    for (let i = 0; i <= 9; i++) {\n        let s1 = i.toString().padStart(9, '0');\n        let s2 = (mod - parseInt(s1)) % mod;\n        s2 = s2.toString().padStart(9, '0');\n\n        if (parseInt(s1 + s2) % mod === 0) {\n            firstPlayerWins = true;\n            optimalMove = s1;\n            break;\n        }\n    }\n\n    if (firstPlayerWins) {\n        return '1 ' + optimalMove;\n    } else {\n        return '2';\n    }\n}\n\n\/\/ Read input from stdin\nconst input = readline().split(' ');\nconst a = parseInt(input[0]);\nconst b = parseInt(input[1]);\nconst mod = parseInt(input[2]);\n\n\/\/ Call the function and print the result\nconsole.log(findOptimalMove(a, b, mod));\n","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \").map { it.toLong() }\n    val a = input[0]\n    val b = input[1]\n    val mod = input[2]\n\n    if (mod > a + b) {\n        println(\\\"2\\\")\n    } else {\n        var s1 = \\\"1\\\"\n        for (i in 1 until 9) {\n            s1 += \\\"0\\\"\n            if ((s1.toLong() * b) % mod == 0L) {\n                println(\\\"1 $s1\\\")\n                return\n            }\n        }\n        println(\\\"2\\\")\n    }\n}","PHP":"\n<?php\n\nfunction findOptimalMove($a, $b, $mod) {\n    \/\/ Check if the second player can win by choosing any number\n    if ($b >= $mod) {\n        return '2';\n    }\n    \n    \/\/ Find the lexicographically minimum winning move for the first player\n    for ($i = 0; $i <= 9; $i++) {\n        $s1 = str_pad($i, 9, '0', STR_PAD_LEFT);\n        $concatenated = $s1 . $b;\n        \n        if ($concatenated % $mod == 0) {\n            return '1 ' . $s1;\n        }\n    }\n    \n    return '2';\n}\n\n\/\/ Read input\n$input = explode(' ', trim(fgets(STDIN)));\n$a = intval($input[0]);\n$b = intval($input[1]);\n$mod = intval($input[2]);\n\n\/\/ Find the optimal move and print the result\n$result = findOptimalMove($a, $b, $mod);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int a, b, mod;\\r\\n    readf(\\\"%d %d %d\\\", &a, &b, &mod);\\r\\n\\r\\n    if (mod > a)\\r\\n    {\\r\\n        writeln(\\\"2\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        int remainder = a % mod;\\r\\n        int s1 = remainder;\\r\\n\\r\\n        writeln(\\\"1 \\\", format(\\\"%09d\\\", s1));\\r\\n    }\\r\\n}","perl":"\n# Read input values\nmy ($a, $b, $mod) = split(' ', <STDIN>);\n\n# Check if the second player wins\nif ($a >= $mod || $b >= $mod) {\n    print '2\\n';\n} else {\n    # Find the lexicographically minimum winning move\n    my $s1 = '1';\n    while (length($s1) < 9) {\n        if (($s1 . '0') % $mod == 0) {\n            last;\n        }\n        $s1 .= '0';\n    }\n    print '1 ' . $s1 . '\\n';\n}\n","Rust":"fn main() {\\n    let input = String::from(\\\"1 10 7\\\\n\\\");\\n    let mut input = input.split_whitespace();\\n    let a: u32 = input.next().unwrap().parse().unwrap();\\n    let b: u32 = input.next().unwrap().parse().unwrap();\\n    let m: u32 = input.next().unwrap().parse().unwrap();\\n\\n    if a % m == 0 {\\n        println!(\\\"1 000000000\\\");\\n    } else {\\n        println!(\\\"2\\\");\\n    }\\n}"}
{"title":"C. Fancy Number","description":"A car number in Berland consists of exactly n digits. A number is called beautiful if it has at least k equal digits. Vasya wants to change the digits in his car's number so that the number became beautiful. To replace one of n digits Vasya has to pay the sum of money, equal to the absolute difference between the old digit and the new one.Help Vasya: find the minimum sum of money he should pay to make the number of his car beautiful. You should also find the resulting beautiful number. If there are several such numbers, then print the lexicographically minimum one.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers n and k (2\u2264n\u226410^4,2\u2264k\u2264n) which represent how many digits the number has and how many equal digits a beautiful number should have. The second line consists of n digits. It describes the old number of Vasya's car. It is guaranteed that the number contains no spaces and only contains digits.\n","output_spec":"On the first line print the minimum sum of money Vasya needs to change the number. On the second line print the car's new number. If there are several solutions, print the lexicographically minimum one.\n","notes":"In the first sample replacing the second digit with an \"8\" costs |9-8|=1. Replacing the fifth digit with an \"8\" costs the same. Replacing the sixth digit costs |6-8|=2. As a result, Vasya will pay 1+1+2=4 for a beautiful number \"888188\".\nThe lexicographical comparison of strings is performed by the < operator in modern programming languages. The string x is lexicographically smaller than the string y, if there exists such i (1\u2264i\u2264n), that xi<yi, and for any j (1\u2264j<i) xj=yj. The strings compared in this problem will always have the length n.\n","sample_inputs":["6 5\n898196\n","3 2\n533\n","10 6\n0001112223\n"],"sample_outputs":["4\n888188\n","0\n533\n","3\n0000002223\n"],"id":"118-C","difficulty":1900,"tags":["brute+force","greedy","sortings","strings"],"src_uid":"cb082cbe9b34a45da851b6764bbc30c3","C++":"\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    string number;\n    cin >> number;\n\n    vector<int> digitCount(10, 0);\n    for (char c : number) {\n        digitCount[c - '0']++;\n    }\n\n    int minSum = 0;\n    string newNumber = number;\n\n    for (int i = 0; i < 10; i++) {\n        if (digitCount[i] >= k) {\n            cout << minSum << endl;\n            for (int j = 0; j < n; j++) {\n                if (digitCount[newNumber[j] - '0'] > k) {\n                    digitCount[newNumber[j] - '0']--;\n                    newNumber[j] = i + '0';\n                    digitCount[i]++;\n                    minSum += abs(i - (newNumber[j] - '0'));\n                }\n                if (digitCount[i] == k) {\n                    break;\n                }\n            }\n            cout << newNumber << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n","Java":"import java.util.Arrays;\\nimport java.util.Scanner;\\n\\npublic class BeautifulCarNumber {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        scanner.nextLine();\\n        String number = scanner.nextLine();\\n        scanner.close();\\n\\n        int[] digitCount = new int[10];\\n        for (int i = 0; i < n; i++) {\\n            digitCount[number.charAt(i) - '0']++;\\n        }\\n\\n        int minCost = Integer.MAX_VALUE;\\n        String newNumber = number;\\n\\n        for (int i = 0; i < 10; i++) {\\n            int cost = 0;\\n            int count = digitCount[i];\\n\\n            if (count >= k) {\\n                System.out.println(0);\\n                for (int j = 0; j < n; j++) {\\n                    System.out.print(number.charAt(j));\\n                }\\n                return;\\n            }\\n\\n            for (int j = i + 1; j < 10; j++) {\\n                int diff = j - i;\\n                int remaining = k - count;\\n                if (remaining <= digitCount[j]) {\\n                    cost += diff * remaining;\\n                    count += remaining;\\n                    break;\\n                } else {\\n                    cost += diff * digitCount[j];\\n                    count += digitCount[j];\\n                }\\n            }\\n\\n            if (count >= k && cost < minCost) {\\n                minCost = cost;\\n                newNumber = number.replaceFirst(String.valueOf(i), String.valueOf(i + minCost));\\n            }\\n        }\\n\\n        System.out.println(minCost);\\n        System.out.println(newNumber);\\n    }\\n}\" }","Python":"def make_beautiful_number(n, k, number):\n    count = [0] * 10\n    for digit in number:\n        count[int(digit)] += 1\n    \n    min_cost = float('inf')\n    min_number = number\n    \n    for i in range(10):\n        cost = 0\n        remaining_changes = k - count[i]\n        if remaining_changes <= 0:\n            continue\n        \n        for j in range(10):\n            if count[j] >= k:\n                continue\n            \n            if j < i:\n                cost += (i - j) * min(remaining_changes, k - count[j])\n                remaining_changes -= min(remaining_changes, k - count[j])\n            \n        if remaining_changes == 0 and cost < min_cost:\n            min_cost = cost\n            min_number = number.replace(str(i), str(i) * k)\n    \n    return str(min_cost) + '\\\\n' + min_number\n\ninput_data = input().split('\\\\n')\nn, k = map(int, input_data[0].split())\nnumber = input_data[1]\n\nresult = make_beautiful_number(n, k, number)\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    char number[n+1];\\n    scanf(\\\"%s\\\", number);\\n\\n    int count[10] = {0};\\n    for (int i = 0; i < n; i++) {\\n        count[number[i]-'0']++;\\n    }\\n\\n    int min_cost = 0;\\n    char new_number[n+1];\\n    strcpy(new_number, number);\\n\\n    for (int i = 0; i < 10; i++) {\\n        if (count[i] >= k) {\\n            printf(\\\"0\\\\n%s\\\\n\\\", number);\\n            return 0;\\n        }\\n    }\\n\\n    for (int i = 0; i < 10; i++) {\\n        if (count[i] > 0) {\\n            int cost = 0;\\n            int j = 0;\\n            while (cost < k && j < n) {\\n                if (new_number[j]-'0' != i) {\\n                    cost++;\\n                    min_cost += abs(new_number[j]-'0' - i);\\n                    new_number[j] = i + '0';\\n                }\\n                j++;\\n            }\\n            if (cost == k) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n%s\\\\n\\\", min_cost, new_number);\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Linq;\n\npublic class CarNumber\n{\n    public static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int k = int.Parse(input[1]);\n\n        string number = Console.ReadLine();\n\n        int[] digitCount = new int[10];\n        for (int i = 0; i < n; i++)\n        {\n            digitCount[number[i] - '0']++;\n        }\n\n        int minSum = int.MaxValue;\n        string newNumber = number;\n\n        for (int i = 0; i < 10; i++)\n        {\n            if (digitCount[i] >= k)\n            {\n                int sum = 0;\n                string tempNumber = number;\n\n                for (int j = 0; j < n; j++)\n                {\n                    if (digitCount[tempNumber[j] - '0'] > k)\n                    {\n                        sum += Math.Abs(i - (tempNumber[j] - '0'));\n                        tempNumber = tempNumber.Remove(j, 1).Insert(j, i.ToString());\n                        digitCount[tempNumber[j] - '0']++;\n                        digitCount[i]--;\n                    }\n                }\n\n                if (sum < minSum || (sum == minSum && tempNumber.CompareTo(newNumber) < 0))\n                {\n                    minSum = sum;\n                    newNumber = tempNumber;\n                }\n            }\n        }\n\n        Console.WriteLine(minSum);\n        Console.WriteLine(newNumber);\n    }\n}\n","Ruby":"\ndef beautiful_car_number(n, k, number)\n  # Count the frequency of each digit in the number\n  digit_count = Hash.new(0)\n  number.each_char { |digit| digit_count[digit] += 1 }\n\n  # Find the digit with the highest frequency\n  max_frequency_digit = digit_count.max_by { |digit, frequency| frequency }[0]\n\n  # Calculate the minimum sum of money needed to change the number\n  min_sum = 0\n  new_number = number.dup\n  k.times do\n    # Find the first digit that is not equal to the max frequency digit\n    index = new_number.index { |digit| digit != max_frequency_digit }\n\n    # Replace the digit with the max frequency digit\n    min_sum += (new_number[index].to_i - max_frequency_digit.to_i).abs\n    new_number[index] = max_frequency_digit\n  end\n\n  [min_sum, new_number]\nend\n\n# Read input\nn, k = gets.chomp.split.map(&:to_i)\nnumber = gets.chomp\n\n# Calculate and print the minimum sum of money and the new number\nmin_sum, new_number = beautiful_car_number(n, k, number)\nputs min_sum\nputs new_number\n","delphi":"program BeautifulNumber;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction GetMinimumSumOfMoney(n, k: Integer; number: String): String;\\nvar\\n  digitCounts: array[0..9] of Integer;\\n  i, j, minCost, minDigit: Integer;\\n  newNumber: String;\\nbegin\\n  \/\/ Initialize digitCounts array\\n  for i := 0 to 9 do\\n    digitCounts[i] := 0;\\n\\n  \/\/ Count the occurrences of each digit\\n  for i := 1 to Length(number) do\\n    Inc(digitCounts[Ord(number[i]) - Ord('0')]);\\n\\n  \/\/ Find the minimum cost digit to replace\\n  minCost := MaxInt;\\n  minDigit := -1;\\n  for i := 0 to 9 do\\n  begin\\n    if digitCounts[i] >= k then\\n    begin\\n      minCost := 0;\\n      minDigit := i;\\n      Break;\\n    end\\n    else\\n    begin\\n      j := k - digitCounts[i];\\n      if j * i < minCost then\\n      begin\\n        minCost := j * i;\\n        minDigit := i;\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Replace the digits with the minimum cost digit\\n  newNumber := number;\\n  for i := 1 to Length(newNumber) do\\n  begin\\n    if digitCounts[Ord(newNumber[i]) - Ord('0')] > k then\\n    begin\\n      Dec(digitCounts[Ord(newNumber[i]) - Ord('0')]);\\n      newNumber[i] := Chr(Ord('0') + minDigit);\\n      Inc(digitCounts[minDigit]);\\n    end;\\n  end;\\n\\n  Result := IntToStr(minCost) + '\\n' + newNumber;\\nend;\\n\\nvar\\n  n, k: Integer;\\n  number: String;\\nbegin\\n  \/\/ Read input values\\n  ReadLn(n, k);\\n  ReadLn(number);\\n\\n  \/\/ Call the function to get the minimum sum of money and the new number\\n  WriteLn(GetMinimumSumOfMoney(n, k, number));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tvar digits string\\n\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\tfmt.Scanf(\\\"%s\\\", &digits)\\n\\n\\tcount := make([]int, 10)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tdigit, _ := strconv.Atoi(string(digits[i]))\\n\\t\\tcount[digit]++\\n\\t}\\n\\n\\tminCost := 0\\n\\tnewNumber := make([]byte, n)\\n\\n\\tfor i := 0; i < 10; i++ {\\n\\t\\tif count[i] >= k {\\n\\t\\t\\tfmt.Println(0)\\n\\t\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\t\\tfmt.Print(strconv.Itoa(i))\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < 10; i++ {\\n\\t\\tif count[i] > 0 {\\n\\t\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\t\\tif count[i] >= k {\\n\\t\\t\\t\\t\\tnewNumber[j] = byte(i + 48)\\n\\t\\t\\t\\t\\tcount[i]--\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tminCost += abs(i - int(digits[j]-48))\\n\\t\\t\\t\\t\\tnewNumber[j] = byte(i + 48)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minCost)\\n\\tfmt.Println(string(newNumber))\\n}\\n\\nfunc abs(x int) int {\\n\\tif x < 0 {\\n\\t\\treturn -x\\n\\t}\\n\\treturn x\\n}","Javascript":"function findBeautifulNumber(n, k, digits) {\n    let count = new Array(10).fill(0);\n    for (let i = 0; i < n; i++) {\n        count[digits[i]]++;\n    }\n    \n    let minCost = Infinity;\n    let minNumber = digits.slice();\n    \n    for (let i = 0; i < 10; i++) {\n        let cost = 0;\n        let remaining = k - count[i];\n        \n        if (remaining <= 0) {\n            console.log(0);\n            console.log(digits.join(''));\n            return;\n        }\n        \n        let j = i + 1;\n        while (remaining > 0 && j < 10) {\n            if (count[j] > 0) {\n                let diff = j - i;\n                let replaceCount = Math.min(remaining, count[j]);\n                cost += diff * replaceCount;\n                remaining -= replaceCount;\n            }\n            j++;\n        }\n        \n        if (remaining === 0 && cost < minCost) {\n            minCost = cost;\n            minNumber = digits.slice();\n            let replaceDigit = i.toString();\n            for (let l = 0; l < n; l++) {\n                if (remaining === 0) {\n                    break;\n                }\n                if (minNumber[l] > replaceDigit) {\n                    minCost -= parseInt(minNumber[l]) - parseInt(replaceDigit);\n                    minNumber[l] = replaceDigit;\n                    remaining--;\n                }\n            }\n        }\n    }\n    \n    console.log(minCost);\n    console.log(minNumber.join(''));\n}\n\n\/\/ Example usage\nfindBeautifulNumber(6, 5, [8, 9, 8, 1, 9, 6]);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nk = scanner.nextLine().split(\" \")\n    val n = nk[0].toInt()\n    val k = nk[1].toInt()\n    val digits = scanner.nextLine().toCharArray()\n\n    val count = IntArray(10)\n    for (digit in digits) {\n        count[digit - '0']++\n    }\n\n    var minSum = Int.MAX_VALUE\n    var minNumber = digits.copyOf()\n\n    for (digit in 0..9) {\n        var sum = 0\n        var remaining = k - count[digit]\n        var i = 0\n\n        while (remaining > 0 && i < n) {\n            if (digits[i] - '0' > digit && count[digits[i] - '0'] > 1) {\n                sum += digits[i] - '0' - digit\n                minNumber[i] = digit.toChar()\n                remaining--\n            }\n            i++\n        }\n\n        if (remaining == 0 && sum < minSum) {\n            minSum = sum\n        }\n    }\n\n    println(\"$minSum\")\n    println(minNumber.joinToString(\"\"))\n}","PHP":"\n<?php\n\nfunction makeBeautifulNumber($n, $k, $number) {\n    $digitCount = array_fill(0, 10, 0);\n    for ($i = 0; $i < $n; $i++) {\n        $digitCount[$number[$i]]++;\n    }\n    \n    $minSum = PHP_INT_MAX;\n    $newNumber = $number;\n    \n    for ($digit = 0; $digit <= 9; $digit++) {\n        $cost = 0;\n        $count = $digitCount[$digit];\n        \n        if ($count >= $k) {\n            echo \"0\\n\";\n            echo $number;\n            return;\n        }\n        \n        $remaining = $k - $count;\n        \n        for ($i = 0; $i < $n; $i++) {\n            if ($number[$i] == $digit) {\n                $cost += min(abs($digit - $number[$i]), abs(10 - abs($digit - $number[$i])));\n                $remaining--;\n                $newNumber[$i] = $digit;\n                \n                if ($remaining == 0) {\n                    break;\n                }\n            }\n        }\n        \n        if ($cost < $minSum) {\n            $minSum = $cost;\n            $result = $newNumber;\n        } elseif ($cost == $minSum && $newNumber < $result) {\n            $result = $newNumber;\n        }\n    }\n    \n    echo $minSum . \"\\n\";\n    echo $result;\n}\n\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\nlist($n, $k) = explode(\\\" \\\", $input[0]);\n$number = $input[1];\n\nmakeBeautifulNumber($n, $k, $number);\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\r\\n        \\\"6 5\\\\n898196\\\\n\\\",\\r\\n        \\\"3 2\\\\n533\\\\n\\\",\\r\\n        \\\"10 6\\\\n0001112223\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    string[] outputs = [\\r\\n        \\\"4\\\\n888188\\\\n\\\",\\r\\n        \\\"0\\\\n533\\\\n\\\",\\r\\n        \\\"3\\\\n0000002223\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    for (int i = 0; i < inputs.length; i++)\\r\\n    {\\r\\n        string[] lines = inputs[i].split('\\\\n');\\r\\n        int n, k;\\r\\n        sscanf(lines[0], \\\"%d %d\\\", &n, &k);\\r\\n        string number = lines[1];\\r\\n\\r\\n        int[] digitCount = new int[10];\\r\\n        foreach (char digit; number)\\r\\n        {\\r\\n            digitCount[digit - '0']++;\\r\\n        }\\r\\n\\r\\n        int minCost = int.max;\\r\\n        string newNumber;\\r\\n\\r\\n        for (int digit = 0; digit < 10; digit++)\\r\\n        {\\r\\n            int cost = 0;\\r\\n            string tempNumber = number;\\r\\n\\r\\n            for (int j = 0; j < 10; j++)\\r\\n            {\\r\\n                if (digitCount[j] >= k)\\r\\n                {\\r\\n                    int replaceCount = digitCount[j] - k;\\r\\n\\r\\n                    for (int l = 0; l < tempNumber.length; l++)\\r\\n                    {\\r\\n                        if (tempNumber[l] - '0' == j && replaceCount > 0)\\r\\n                        {\\r\\n                            cost += abs(digit - j);\\r\\n                            tempNumber[l] = cast(char)(digit + '0');\\r\\n                            replaceCount--;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (cost < minCost || (cost == minCost && tempNumber < newNumber))\\r\\n            {\\r\\n                minCost = cost;\\r\\n                newNumber = tempNumber;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        string output = to!string(minCost) ~ \\\"\\\\n\\\" ~ newNumber;\\r\\n        assert(output == outputs[i]);\\r\\n        writeln(output);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub make_beautiful_number {\n    my ($n, $k, $number) = @_;\n\n    my @digits = split('', $number);\n    my %digit_count;\n    foreach my $digit (@digits) {\n        $digit_count{$digit}++;\n    }\n\n    my $min_cost = 0;\n    my $new_number = $number;\n\n    foreach my $digit (sort keys %digit_count) {\n        if ($digit_count{$digit} >= $k) {\n            last;\n        }\n\n        my $cost = 0;\n        my $remaining = $k - $digit_count{$digit};\n\n        for (my $i = 0; $i < $n; $i++) {\n            if ($digits[$i] != $digit) {\n                $cost += abs($digits[$i] - $digit);\n                $digits[$i] = $digit;\n                $remaining--;\n\n                last if $remaining == 0;\n            }\n        }\n\n        if ($min_cost == 0 || $cost < $min_cost) {\n            $min_cost = $cost;\n            $new_number = join('', @digits);\n        }\n    }\n\n    return $min_cost . \\\"\\\\n\\\" . $new_number;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k) = split(' ', $input);\n\nmy $number = <STDIN>;\nchomp $number;\n\n# Call the function and print the result\nprint make_beautiful_number($n, $k, $number);\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut iter = input.split_whitespace();\n    let n: usize = iter.next().unwrap().parse().unwrap();\n    let k: usize = iter.next().unwrap().parse().unwrap();\n\n    let mut number = String::new();\n    std::io::stdin().read_line(&mut number).unwrap();\n    let number: Vec<char> = number.trim().chars().collect();\n\n    let mut count = vec![0; 10];\n    for &digit in &number {\n        count[digit.to_digit(10).unwrap() as usize] += 1;\n    }\n\n    let mut min_cost = std::usize::MAX;\n    let mut new_number = number.clone();\n\n    for digit in 0..=9 {\n        let mut cost = 0;\n        let mut remaining = k;\n        for i in 0..n {\n            if remaining == 0 {\n                break;\n            }\n            if number[i] != digit.to_string().chars().next().unwrap() {\n                cost += (number[i] as u8 - digit as u8).abs() as usize;\n                new_number[i] = digit.to_string().chars().next().unwrap();\n                remaining -= 1;\n            }\n        }\n        if remaining > 0 {\n            for i in 0..n {\n                if remaining == 0 {\n                    break;\n                }\n                if count[number[i].to_digit(10).unwrap() as usize] > 1 {\n                    if number[i] != digit.to_string().chars().next().unwrap() {\n                        cost += (number[i] as u8 - digit as u8).abs() as usize;\n                        new_number[i] = digit.to_string().chars().next().unwrap();\n                        remaining -= 1;\n                    }\n                }\n            }\n        }\n        if cost < min_cost {\n            min_cost = cost;\n        }\n    }\n\n    println!(\"{}\", min_cost);\n    println!(\"{}\", new_number.iter().collect::<String>());\n}"}
{"title":"B. Jumping Jack","description":"Jack is working on his jumping skills recently. Currently he's located at point zero of the number line. He would like to get to the point x. In order to train, he has decided that he'll first jump by only one unit, and each subsequent jump will be exactly one longer than the previous one. He can go either left or right with each jump. He wonders how many jumps he needs to reach x.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"The input data consists of only one integer x (-10^9\u2264x\u226410^9).\n","output_spec":"Output the minimal number of jumps that Jack requires to reach x.\n","notes":null,"sample_inputs":["2\n","6\n","0\n"],"sample_outputs":["3\n","3\n","0\n"],"id":"11-B","difficulty":1600,"tags":["math"],"src_uid":"18644c9df41b9960594fdca27f1d2fec","C++":"#include <iostream>\\n#include <cmath>\\n\\nint main() {\\n    int x;\\n    std::cin >> x;\\n\\n    int jumps = 0;\\n    int sum = 0;\\n    int step = 1;\\n\\n    while (sum < std::abs(x) || (sum - x) % 2 != 0) {\\n        jumps++;\\n        sum += step;\\n        step++;\\n    }\\n\\n    std::cout << jumps << std::endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class JumpingSkills {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int x = scanner.nextInt();\\n        int jumps = 0;\\n        int sum = 0;\\n\\n        while (sum < Math.abs(x) || (sum - x) % 2 != 0) {\\n            jumps++;\\n            sum += jumps;\\n        }\\n\\n        System.out.println(jumps);\\n    }\\n}","Python":"def minimal_jumps(x):\\n    jumps = 0\\n    distance = abs(x)\\n    total = 0\\n    while total < distance or (total - distance) % 2 != 0:\\n        jumps += 1\\n        total += jumps\\n    return jumps\\n\\nx = int(input())\\nprint(minimal_jumps(x))","C":"#include <stdio.h>\\n\\nint main() {\\n    int x;\\n    scanf(\\\"%d\\\", &x);\\n\\n    int jumps = 0;\\n    int sum = 0;\\n    int step = 1;\\n\\n    while (sum < x || (sum - x) % 2 != 0) {\\n        jumps++;\\n        sum += step;\\n        step++;\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", jumps);\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace JumpingSkills\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int x = int.Parse(Console.ReadLine());\n            int jumps = CalculateJumps(x);\n            Console.WriteLine(jumps);\n        }\n\n        static int CalculateJumps(int x)\n        {\n            int jumps = 0;\n            int position = 0;\n            int step = 1;\n\n            while (position != x)\n            {\n                if (position + step <= x)\n                {\n                    position += step;\n                    step++;\n                }\n                else if (position - step >= x)\n                {\n                    position -= step;\n                    step++;\n                }\n                else if (position + step > x)\n                {\n                    position += step;\n                    step++;\n                }\n                else if (position - step < x)\n                {\n                    position -= step;\n                    step++;\n                }\n\n                jumps++;\n            }\n\n            return jumps;\n        }\n    }\n}","Ruby":"def minimal_jumps(x)\\n  jumps = 0\\n  distance = 0\\n\\n  while distance < x\\n    jumps += 1\\n    distance += jumps\\n  end\\n\\n  jumps\\nend\\n\\nx = gets.chomp.to_i\\nputs minimal_jumps(x)","delphi":"program JumpingSkills;\\n\\nvar\\n  x, jumps: Integer;\\n\\nbegin\\n  \/\/ Read the input\\n  ReadLn(x);\\n\\n  \/\/ Initialize the number of jumps\\n  jumps := 0;\\n\\n  \/\/ Calculate the minimal number of jumps\\n  while x <> 0 do\\n  begin\\n    if x > 0 then\\n    begin\\n      x := x - jumps;\\n      jumps := jumps + 1;\\n    end\\n    else\\n    begin\\n      x := x + jumps;\\n      jumps := jumps + 1;\\n    end;\\n  end;\\n\\n  \/\/ Output the result\\n  WriteLn(jumps);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar x int\\n\\tfmt.Scan(&x)\\n\\n\\tjumps := int(math.Ceil((-1 + math.Sqrt(1+8*float64(math.Abs(x)))) \/ 2))\\n\\n\\tfmt.Println(jumps)\\n}","Javascript":"function minimalJumps(x) {\n    x = Math.abs(x); \/\/ convert x to positive value\n    let sum = 0;\n    let jumps = 0;\n    \n    while (sum < x || (sum - x) % 2 !== 0) {\n        jumps++;\n        sum += jumps;\n    }\n    \n    return jumps;\n}\n\nconst inputs = [2, 6, 0];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    const result = minimalJumps(inputs[i]);\n    outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"fun minimalJumps(x: Int): Int {\n    var jumps = 0\n    var position = 0\n    var step = 1\n\n    while (position != x) {\n        if (position + step <= x) {\n            position += step\n        } else {\n            position -= step\n        }\n        step++\n        jumps++\n    }\n\n    return jumps\n}\n\nfun main() {\n    val inputs = listOf(2, 6, 0)\n    val outputs = mutableListOf<Int>()\n\n    for (input in inputs) {\n        val jumps = minimalJumps(input)\n        outputs.add(jumps)\n    }\n\n    println(outputs.joinToString(separator = \\\"\\\\n\\\"))\n}","PHP":"<?php\\n\\nfunction minimalJumps($x) {\\n    $jumps = 0;\\n    $distance = abs($x);\\n    $sum = 0;\\n    \\n    while ($sum < $distance || ($sum - $distance) % 2 != 0) {\\n        $jumps++;\\n        $sum += $jumps;\\n    }\\n    \\n    return $jumps;\\n}\\n\\n$input = intval(fgets(STDIN));\\n$output = minimalJumps($input);\\necho $output;\\n?>","d":"import std.stdio;\\r\\n\\r\\nint minimalJumps(int x)\\r\\n{\\r\\n    int jumps = 0;\\r\\n    int position = 0;\\r\\n    int step = 1;\\r\\n\\r\\n    while (position != x)\\r\\n    {\\r\\n        if (position < x)\\r\\n        {\\r\\n            position += step;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            position -= step;\\r\\n        }\\r\\n\\r\\n        step++;\\r\\n        jumps++;\\r\\n    }\\r\\n\\r\\n    return jumps;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int x;\\r\\n    readf(\\\"%d\\\", &x);\\r\\n\\r\\n    int result = minimalJumps(x);\\r\\n\\r\\n    writeln(result);\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub minimal_jumps {\n    my $x = shift;\n    my $jumps = 0;\n    my $sum = 0;\n    \n    while ($sum < abs($x) || ($sum - $x) % 2 != 0) {\n        $jumps++;\n        $sum += $jumps;\n    }\n    \n    return $jumps;\n}\n\nmy @inputs = ('2', '6', '0');\nmy @outputs;\n\nforeach my $input (@inputs) {\n    my $result = minimal_jumps($input);\n    push @outputs, $result;\n}\n\nprint join(\\\"\\\\n\\\", @outputs);\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let x: i32 = input.trim().parse().unwrap();\n    \n    let mut jumps = 0;\n    let mut position = 0;\n    let mut step = 1;\n    \n    while position != x {\n        if position < x {\n            position += step;\n        } else {\n            position -= step;\n        }\n        step += 1;\n        jumps += 1;\n    }\n    \n    println!(\"{}\", jumps);\n}"}
{"title":"D. A Simple Task","description":"Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of input contains two integers n and m (1\u2264n\u226419, 0\u2264m) \u2013 respectively the number of vertices and edges of the graph. Each of the subsequent m lines contains two integers a and b, (1\u2264a,b\u2264n, a\u2260b) indicating that vertices a and b are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.\n","output_spec":"Output the number of cycles in the given graph.\n","notes":"The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.\n","sample_inputs":["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n"],"sample_outputs":["7\n"],"id":"11-D","difficulty":2200,"tags":["bitmasks","dp","graphs"],"src_uid":"ce5cc8512359701696dba1b254c6afda","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nint n, m;\\nvector<vector<int>> graph;\\nvector<bool> visited;\\nint count = 0;\\n\\nvoid dfs(int v, int start, int length) {\\n    visited[v] = true;\\n    if (length > 1 && v == start) {\\n        count++;\\n        return;\\n    }\\n    for (int i = 0; i < graph[v].size(); i++) {\\n        int u = graph[v][i];\\n        if (!visited[u]) {\\n            dfs(u, start, length + 1);\\n        }\\n    }\\n    visited[v] = false;\\n}\\n\\nint main() {\\n    cin >> n >> m;\\n    graph.resize(n + 1);\\n    visited.resize(n + 1, false);\\n\\n    for (int i = 0; i < m; i++) {\\n        int a, b;\\n        cin >> a >> b;\\n        graph[a].push_back(b);\\n        graph[b].push_back(a);\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        dfs(i, i, 0);\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class SimpleCycles {\\n\\n    private static int n;\\n    private static List<List<Integer>> graph;\\n    private static boolean[] visited;\\n    private static int count;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n\\n        graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int a = scanner.nextInt();\\n            int b = scanner.nextInt();\\n            graph.get(a - 1).add(b - 1);\\n            graph.get(b - 1).add(a - 1);\\n        }\\n\\n        visited = new boolean[n];\\n        count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            dfs(i, i, 1);\\n        }\\n\\n        System.out.println(count \/ 2);\\n    }\\n\\n    private static void dfs(int start, int current, int length) {\\n        visited[current] = true;\\n\\n        for (int neighbor : graph.get(current)) {\\n            if (neighbor == start && length > 2) {\\n                count++;\\n            }\\n\\n            if (!visited[neighbor]) {\\n                dfs(start, neighbor, length + 1);\\n            }\\n        }\\n\\n        visited[current] = false;\\n    }\\n}\"}\n","Python":"from collections import defaultdict\\n\\ndef count_cycles(n, edges):\\n    graph = defaultdict(list)\\n    for a, b in edges:\\n        graph[a].append(b)\\n        graph[b].append(a)\\n    \\n    def dfs(node, visited, path):\\n        visited[node] = True\\n        path.append(node)\\n        \\n        count = 0\\n        for neighbor in graph[node]:\\n            if neighbor == path[0]:\\n                count += 1\\n            elif not visited[neighbor]:\\n                count += dfs(neighbor, visited, path)\\n        \\n        visited[node] = False\\n        path.pop()\\n        return count\\n    \\n    count = 0\\n    visited = [False] * (n+1)\\n    for node in range(1, n+1):\\n        count += dfs(node, visited, [])\\n    \\n    return count\\n\\n\\n# Sample input\\ninput_str = '4 6\\\\n1 2\\\\n1 3\\\\n1 4\\\\n2 3\\\\n2 4\\\\n3 4\\\\n'\\nn, m, *edges = map(int, input_str.split())\\nedges = [tuple(edges[i:i+2]) for i in range(0, len(edges), 2)]\\n\\n# Count cycles\\nresult = count_cycles(n, edges)\\n\\n# Output result\\nprint(result)\\n","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\n#define MAX 20\\n\\nint n, m;\\nint graph[MAX][MAX];\\nbool visited[MAX];\\nint count = 0;\\n\\nvoid dfs(int v, int start, int depth) {\\n    visited[v] = true;\\n\\n    if (depth >= 3 && graph[v][start]) {\\n        count++;\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        if (!visited[i] && graph[v][i]) {\\n            dfs(i, start, depth + 1);\\n        }\\n    }\\n\\n    visited[v] = false;\\n}\\n\\nint main() {\\n    scanf(\\\"%d %d\\\", &n, &m);\\n\\n    for (int i = 0; i < m; i++) {\\n        int a, b;\\n        scanf(\\\"%d %d\\\", &a, &b);\\n        graph[a][b] = 1;\\n        graph[b][a] = 1;\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        dfs(i, i, 0);\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count \/ 2);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static int n, m;\n    static List<int>[] graph;\n    static bool[] visited;\n    static int[] parent;\n    static int count;\n\n    static void Main(string[] args)\n    {\n        string input = Console.ReadLine();\n        string[] inputArr = input.Split(' ');\n        n = int.Parse(inputArr[0]);\n        m = int.Parse(inputArr[1]);\n\n        graph = new List<int>[n + 1];\n        visited = new bool[n + 1];\n        parent = new int[n + 1];\n\n        for (int i = 1; i <= n; i++)\n        {\n            graph[i] = new List<int>();\n        }\n\n        for (int i = 0; i < m; i++)\n        {\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n            int a = int.Parse(inputArr[0]);\n            int b = int.Parse(inputArr[1]);\n\n            graph[a].Add(b);\n            graph[b].Add(a);\n        }\n\n        count = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            visited[i] = true;\n            parent[i] = -1;\n            DFS(i, i, 1);\n            visited[i] = false;\n        }\n\n        Console.WriteLine(count);\n    }\n\n    static void DFS(int start, int current, int length)\n    {\n        if (length > n)\n        {\n            return;\n        }\n\n        foreach (int neighbor in graph[current])\n        {\n            if (neighbor == start && length >= 3)\n            {\n                count++;\n                continue;\n            }\n\n            if (!visited[neighbor])\n            {\n                visited[neighbor] = true;\n                parent[neighbor] = current;\n                DFS(start, neighbor, length + 1);\n                visited[neighbor] = false;\n                parent[neighbor] = -1;\n            }\n            else if (neighbor != parent[current])\n            {\n                continue;\n            }\n        }\n    }\n}","Ruby":"def count_cycles(graph)\n  n, m = graph.shift.split.map(&:to_i)\n  edges = graph.map { |line| line.split.map(&:to_i) }\n  cycles = 0\n\n  (1..n).each do |k|\n    (1..n).each do |i|\n      (1..n).each do |j|\n        next if i == j || i == k || j == k\n\n        if edges.include?([i, k]) && edges.include?([k, j]) && edges.include?([j, i])\n          cycles += 1\n        end\n      end\n    end\n  end\n\n  cycles.to_s\nend\n\ngraph = ['4 6\\n1 2\\n1 3\\n1 4\\n2 3\\n2 4\\n3 4\\n']\nputs count_cycles(graph)","delphi":"Here is the Delphi code to solve the problem:\n\nprogram SimpleCycles;\n\nconst\n  MAX_N = 19;\n\nvar\n  n, m: Integer;\n  graph: array[1..MAX_N, 1..MAX_N] of Boolean;\n  visited: array[1..MAX_N] of Boolean;\n  cyclesCount: Integer;\n\nprocedure ReadInput;\nvar\n  i, a, b: Integer;\nbegin\n  ReadLn(n, m);\n  for i := 1 to m do\n  begin\n    ReadLn(a, b);\n    graph[a, b] := True;\n    graph[b, a] := True;\n  end;\nend;\n\nprocedure DFS(v, start, depth: Integer);\nvar\n  i: Integer;\nbegin\n  visited[v] := True;\n  if depth > 2 then\n  begin\n    if graph[v, start] then\n      Inc(cyclesCount);\n  end;\n  for i := 1 to n do\n  begin\n    if (graph[v, i]) and (not visited[i]) then\n      DFS(i, start, depth + 1);\n  end;\n  visited[v] := False;\nend;\n\nprocedure CountCycles;\nvar\n  i: Integer;\nbegin\n  cyclesCount := 0;\n  for i := 1 to n do\n    DFS(i, i, 1);\nend;\n\nprocedure OutputResult;\nbegin\n  WriteLn(cyclesCount);\nend;\n\nbegin\n  ReadInput;\n  CountCycles;\n  OutputResult;\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nvar graph [][]int\\nvar visited []bool\\nvar count int\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nm[0])\\n\\tm, _ := strconv.Atoi(nm[1])\\n\\n\\tgraph = make([][]int, n+1)\\n\\tvisited = make([]bool, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tab := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\ta, _ := strconv.Atoi(ab[0])\\n\\t\\tb, _ := strconv.Atoi(ab[1])\\n\\n\\t\\tgraph[a] = append(graph[a], b)\\n\\t\\tgraph[b] = append(graph[b], a)\\n\\t}\\n\\n\\tcount = 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tvisited[i] = true\\n\\t\\tdfs(i, i, 1)\\n\\t\\tvisited[i] = false\\n\\t}\\n\\n\\tfmt.Println(count)\\n}\\n\\nfunc dfs(start, current, length int) {\\n\\tif length > 3 {\\n\\t\\treturn\\n\\t}\\n\\n\\tfor _, neighbor := range graph[current] {\\n\\t\\tif neighbor == start && length > 2 {\\n\\t\\t\\tcount++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif !visited[neighbor] {\\n\\t\\t\\tvisited[neighbor] = true\\n\\t\\t\\tdfs(start, neighbor, length+1)\\n\\t\\t\\tvisited[neighbor] = false\\n\\t\\t}\\n\\t}\\n}","Javascript":"function countCycles(n, edges) {\n    let graph = new Array(n + 1);\n    for (let i = 0; i <= n; i++) {\n        graph[i] = new Array(n + 1).fill(0);\n    }\n    \n    for (let i = 0; i < edges.length; i++) {\n        let [a, b] = edges[i];\n        graph[a][b] = 1;\n        graph[b][a] = 1;\n    }\n    \n    let count = 0;\n    let visited = new Array(n + 1).fill(false);\n    \n    function dfs(node, start, length) {\n        visited[node] = true;\n        \n        if (length > 1 && graph[node][start] === 1) {\n            count++;\n        }\n        \n        for (let i = 1; i <= n; i++) {\n            if (!visited[i] && graph[node][i] === 1) {\n                dfs(i, start, length + 1);\n            }\n        }\n        \n        visited[node] = false;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        dfs(i, i, 0);\n    }\n    \n    return count;\n}\n\nlet input = '4 6\\\\n1 2\\\\n1 3\\\\n1 4\\\\n2 3\\\\n2 4\\\\n3 4\\\\n';\nlet lines = input.split('\\\\n');\nlet [n, m] = lines[0].split(' ').map(Number);\nlet edges = [];\nfor (let i = 1; i <= m; i++) {\n    let [a, b] = lines[i].split(' ').map(Number);\n    edges.push([a, b]);\n}\n\nlet result = countCycles(n, edges);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n\n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    repeat(m) {\n        val edge = readLine()!!.split(\" \")\n        val a = edge[0].toInt()\n        val b = edge[1].toInt()\n        graph[a].add(b)\n        graph[b].add(a)\n    }\n\n    var count = 0\n    for (i in 1..n) {\n        count += dfs(i, i, graph, mutableSetOf())\n    }\n\n    println(count)\n}\n\nfun dfs(start: Int, current: Int, graph: Array<MutableList<Int>>, visited: MutableSet<Int>): Int {\n    visited.add(current)\n    var count = 0\n\n    for (neighbor in graph[current]) {\n        if (neighbor == start) {\n            count++\n        } else if (!visited.contains(neighbor)) {\n            count += dfs(start, neighbor, graph, visited)\n        }\n    }\n\n    visited.remove(current)\n    return count\n}","PHP":"<?php\\n\\nfunction countCycles($n, $edges) {\\n    $graph = array_fill(1, $n, []);\\n    $cycles = 0;\\n\\n    foreach ($edges as $edge) {\\n        $a = $edge[0];\\n        $b = $edge[1];\\n        $graph[$a][] = $b;\\n        $graph[$b][] = $a;\\n    }\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $visited = array_fill(1, $n, false);\\n        $cycles += dfs($i, $i, $visited, $graph);\\n    }\\n\\n    return $cycles;\\n}\\n\\nfunction dfs($start, $current, &$visited, &$graph) {\\n    $visited[$current] = true;\\n    $cycles = 0;\\n\\n    foreach ($graph[$current] as $neighbor) {\\n        if ($neighbor == $start) {\\n            $cycles++;\\n        } elseif (!$visited[$neighbor]) {\\n            $cycles += dfs($start, $neighbor, $visited, $graph);\\n        }\\n    }\\n\\n    $visited[$current] = false;\\n    return $cycles;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents(\\\"php:\/\/stdin\\\")));\\nlist($n, $m) = explode(\\\" \\\", $input[0]);\\n$edges = [];\\n\\nfor ($i = 1; $i <= $m; $i++) {\\n    list($a, $b) = explode(\\\" \\\", $input[$i]);\\n    $edges[] = [$a, $b];\\n}\\n\\n$result = countCycles($n, $edges);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\\n\\\", &n, &m);\\r\\n\\r\\n    Graph!int graph;\\r\\n\\r\\n    foreach (_; 0 .. m)\\r\\n    {\\r\\n        int a, b;\\r\\n        readf(\\\"%d %d\\\\n\\\", &a, &b);\\r\\n        graph[a].insert(b);\\r\\n        graph[b].insert(a);\\r\\n    }\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    foreach (v; 1 .. n + 1)\\r\\n    {\\r\\n        count += countCycles(graph, v, v, 1);\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n}\\r\\n\\r\\nint countCycles(Graph!int graph, int start, int current, int length)\\r\\n{\\r\\n    int count = 0;\\r\\n\\r\\n    if (length > 2)\\r\\n    {\\r\\n        if (graph[current].contains(start))\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    foreach (v; graph[current])\\r\\n    {\\r\\n        if (v > start)\\r\\n        {\\r\\n            count += countCycles(graph, start, v, length + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return count;\\r\\n}\\r\\n\\r\\n","perl":"use strict;\\nuse warnings;\\n\\nsub count_cycles {\\n    my ($n, $m, @edges) = @_;\\n    my @adj_list;\\n    my $count = 0;\\n\\n    # Create adjacency list\\n    for my $i (1..$n) {\\n        $adj_list[$i] = [];\\n    }\\n\\n    for my $edge (@edges) {\\n        my ($a, $b) = split ' ', $edge;\\n        push @{$adj_list[$a]}, $b;\\n        push @{$adj_list[$b]}, $a;\\n    }\\n\\n    # DFS to find cycles\\n    for my $start (1..$n) {\\n        my @visited;\\n        $visited[$start] = 1;\\n        $count += dfs($start, $start, \\@visited, \\@adj_list);\\n    }\\n\\n    return $count;\\n}\\n\\nsub dfs {\\n    my ($start, $current, $visited, $adj_list) = @_;\\n    my $count = 0;\\n\\n    for my $neighbor (@{$adj_list->[$current]}) {\\n        if ($neighbor == $start) {\\n            $count++;\\n        }\\n        elsif (!$visited->[$neighbor]) {\\n            $visited->[$neighbor] = 1;\\n            $count += dfs($start, $neighbor, $visited, $adj_list);\\n            $visited->[$neighbor] = 0;\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $m) = split ' ', $input;\\nmy @edges;\\n\\nfor (1..$m) {\\n    my $edge = <STDIN>;\\n    chomp $edge;\\n    push @edges, $edge;\\n}\\n\\n# Count cycles\\nmy $result = count_cycles($n, $m, @edges);\\n\\n# Print output\\nprint $result;\\n","Rust":"use std::collections::HashSet;\\n\\nfn count_cycles(graph: &Vec<Vec<usize>>, visited: &mut HashSet<usize>, start: usize, current: usize, length: usize) -> usize {\\n    if length > 1 && current == start {\\n        return 1;\\n    }\\n\\n    let mut count = 0;\\n    visited.insert(current);\\n\\n    for &neighbor in &graph[current] {\\n        if !visited.contains(&neighbor) {\\n            count += count_cycles(graph, visited, start, neighbor, length + 1);\\n        }\\n    }\\n\\n    visited.remove(&current);\\n    count\\n}\\n\\nfn main() {\\n    let input = \\\"4 6\\\\n1 2\\\\n1 3\\\\n1 4\\\\n2 3\\\\n2 4\\\\n3 4\\\\n\\\";\\n    let lines: Vec<&str> = input.trim().split('\\\\n').collect();\\n    let nm: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\\n    let n = nm[0];\\n    let m = nm[1];\\n\\n    let mut graph = vec![Vec::new(); n + 1];\\n\\n    for i in 1..=m {\\n        let ab: Vec<usize> = lines[i].split(' ').map(|x| x.parse().unwrap()).collect();\\n        let a = ab[0];\\n        let b = ab[1];\\n        graph[a].push(b);\\n        graph[b].push(a);\\n    }\\n\\n    let mut count = 0;\\n    let mut visited = HashSet::new();\\n\\n    for i in 1..=n {\\n        count += count_cycles(&graph, &mut visited, i, i, 0);\\n        visited.clear();\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"B1. TV Subscriptions (Easy Version)","description":"The only difference between easy and hard versions is constraints.The BerTV channel every day broadcasts one episode of one of the $$$k$$$ TV shows. You know the schedule for the next $$$n$$$ days: a sequence of integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le k$$$), where $$$a_i$$$ is the show, the episode of which will be shown in $$$i$$$-th day.The subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately.How many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows $$$d$$$ ($$$1 \\le d \\le n$$$) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of $$$d$$$ consecutive days in which all episodes belong to the purchased shows.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer $$$t$$$ ($$$1 \\\\le t \\\\le 100$$$) \u2014 the number of test cases in the input. Then $$$t$$$ test case descriptions follow.\nThe first line of each test case contains three integers $$$n, k$$$ and $$$d$$$ ($$$1 \\\\le n \\\\le 100$$$, $$$1 \\\\le k \\\\le 100$$$, $$$1 \\\\le d \\\\le n$$$). The second line contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le k$$$), where $$$a_i$$$ is the show that is broadcasted on the $$$i$$$-th day.\nIt is guaranteed that the sum of the values \u200b\u200bof $$$n$$$ for all test cases in the input does not exceed $$$100$$$.\n","output_spec":"Print $$$t$$$ integers \u2014 the answers to the test cases in the input in the order they follow. The answer to a test case is the minimum number of TV shows for which you need to purchase a subscription so that you can watch episodes of the purchased TV shows on BerTV for $$$d$$$ consecutive days. Please note that it is permissible that you will be able to watch more than $$$d$$$ days in a row.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1225-B1","difficulty":1000,"tags":["implementation"],"src_uid":"56da4ec7cd849c4330d188d8c9bd6094","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int t;\\n    cin >> t;\\n    while (t--) {\\n        int n, k, d;\\n        cin >> n >> k >> d;\\n        vector<int> shows(n);\\n        for (int i = 0; i < n; i++) {\\n            cin >> shows[i];\\n        }\\n        vector<int> count(k + 1, 0);\\n        int distinct = 0;\\n        int minSubscriptions = d;\\n        for (int i = 0; i < d; i++) {\\n            if (count[shows[i]] == 0) {\\n                distinct++;\\n            }\\n            count[shows[i]]++;\\n        }\\n        minSubscriptions = min(minSubscriptions, distinct);\\n        for (int i = d; i < n; i++) {\\n            count[shows[i - d]]--;\\n            if (count[shows[i - d]] == 0) {\\n                distinct--;\\n            }\\n            if (count[shows[i]] == 0) {\\n                distinct++;\\n            }\\n            count[shows[i]]++;\\n            minSubscriptions = min(minSubscriptions, distinct);\\n        }\\n        cout << minSubscriptions << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n        while (t-- > 0) {\n            int n = scanner.nextInt();\n            int k = scanner.nextInt();\n            int d = scanner.nextInt();\n            int[] shows = new int[n];\n            for (int i = 0; i < n; i++) {\n                shows[i] = scanner.nextInt();\n            }\n            int minSubscriptions = getMinSubscriptions(n, k, d, shows);\n            System.out.println(minSubscriptions);\n        }\n    }\n\n    public static int getMinSubscriptions(int n, int k, int d, int[] shows) {\n        int[] count = new int[k + 1];\n        int distinctShows = 0;\n        int minSubscriptions = Integer.MAX_VALUE;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (count[shows[right]] == 0) {\n                distinctShows++;\n            }\n            count[shows[right]]++;\n            \n            if (right - left + 1 > d) {\n                count[shows[left]]--;\n                if (count[shows[left]] == 0) {\n                    distinctShows--;\n                }\n                left++;\n            }\n            \n            if (right - left + 1 == d) {\n                minSubscriptions = Math.min(minSubscriptions, distinctShows);\n            }\n        }\n        \n        return minSubscriptions;\n    }\n}","Python":"def min_subscriptions(t, test_cases):\n    results = []\n    for i in range(t):\n        n, k, d = test_cases[i][0]\n        shows = test_cases[i][1]\n        subscriptions = set()\n        count = 0\n        for j in range(n):\n            subscriptions.add(shows[j])\n            if j >= d:\n                subscriptions.remove(shows[j - d])\n            if len(subscriptions) == d:\n                count += 1\n        results.append(count)\n    return results\n\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, k, d = map(int, input().split())\n    shows = list(map(int, input().split()))\n    test_cases.append((n, k, d, shows))\n\nresults = min_subscriptions(t, test_cases)\nfor result in results:\n    print(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int t;\\n    scanf(\\\"%d\\\", &t);\\n    while (t--) {\\n        int n, k, d;\\n        scanf(\\\"%d %d %d\\\", &n, &k, &d);\\n        int a[n];\\n        for (int i = 0; i < n; i++) {\\n            scanf(\\\"%d\\\", &a[i]);\\n        }\\n        int minSubscriptions = k;\\n        for (int i = 0; i <= n - d; i++) {\\n            int distinctShows = 0;\\n            int count[k + 1] = {0};\\n            for (int j = i; j < i + d; j++) {\\n                if (count[a[j]] == 0) {\\n                    distinctShows++;\\n                }\\n                count[a[j]]++;\\n            }\\n            if (distinctShows < minSubscriptions) {\\n                minSubscriptions = distinctShows;\\n            }\\n        }\\n        printf(\\\"%d\\\\n\\\", minSubscriptions);\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BerTV\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int t = int.Parse(Console.ReadLine());\n            List<int> results = new List<int>();\n\n            for (int i = 0; i < t; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int n = int.Parse(input[0]);\n                int k = int.Parse(input[1]);\n                int d = int.Parse(input[2]);\n\n                int[] shows = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n\n                int minSubscriptions = GetMinSubscriptions(n, k, d, shows);\n                results.Add(minSubscriptions);\n            }\n\n            Console.WriteLine(string.Join(' ', results));\n        }\n\n        static int GetMinSubscriptions(int n, int k, int d, int[] shows)\n        {\n            int minSubscriptions = int.MaxValue;\n\n            for (int i = 0; i <= n - d; i++)\n            {\n                HashSet<int> subscriptions = new HashSet<int>();\n\n                for (int j = i; j < i + d; j++)\n                {\n                    subscriptions.Add(shows[j]);\n                }\n\n                minSubscriptions = Math.Min(minSubscriptions, subscriptions.Count);\n            }\n\n            return minSubscriptions;\n        }\n    }\n}","Ruby":"\n# Function to calculate the minimum number of subscriptions needed\ndef min_subscriptions(t, test_cases)\n  results = []\n  \n  # Iterate through each test case\n  test_cases.each do |test_case|\n    n, k, d = test_case[:n], test_case[:k], test_case[:d]\n    shows = test_case[:shows]\n    \n    # Initialize an array to keep track of the number of episodes for each show\n    episodes = Array.new(k, 0)\n    \n    # Initialize variables to keep track of the minimum number of subscriptions needed and the current number of subscriptions\n    min_subscriptions = Float::INFINITY\n    current_subscriptions = 0\n    \n    # Iterate through the first d days and count the number of episodes for each show\n    (0...d).each do |i|\n      episodes[shows[i] - 1] += 1\n      if episodes[shows[i] - 1] == 1\n        current_subscriptions += 1\n      end\n    end\n    \n    # Update the minimum number of subscriptions needed\n    min_subscriptions = current_subscriptions\n    \n    # Iterate through the remaining days\n    (d...n).each do |i|\n      episodes[shows[i - d] - 1] -= 1\n      if episodes[shows[i - d] - 1] == 0\n        current_subscriptions -= 1\n      end\n      \n      episodes[shows[i] - 1] += 1\n      if episodes[shows[i] - 1] == 1\n        current_subscriptions += 1\n      end\n      \n      # Update the minimum number of subscriptions needed\n      min_subscriptions = [min_subscriptions, current_subscriptions].min\n    end\n    \n    # Add the minimum number of subscriptions needed to the results array\n    results << min_subscriptions\n  end\n  \n  # Return the results array\n  results\nend\n\n# Read the number of test cases\nt = gets.chomp.to_i\n\n# Initialize an array to store the test cases\ntest_cases = []\n\n# Read the test cases\nt.times do\n  n, k, d = gets.chomp.split.map(&:to_i)\n  shows = gets.chomp.split.map(&:to_i)\n  test_cases << { n: n, k: k, d: d, shows: shows }\nend\n\n# Call the min_subscriptions function and print the results\nresults = min_subscriptions(t, test_cases)\nresults.each { |result| puts result }\n","delphi":"Here is a possible implementation in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tt := nextInt(scanner)\\n\\n\\tfor i := 0; i < t; i++ {\\n\\t\\tn := nextInt(scanner)\\n\\t\\tk := nextInt(scanner)\\n\\t\\td := nextInt(scanner)\\n\\n\\t\\tshows := make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tshows[j] = nextInt(scanner)\\n\\t\\t}\\n\\n\\t\\tsubscriptions := make(map[int]bool)\\n\\t\\tcount := 0\\n\\t\\tmaxCount := 0\\n\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif !subscriptions[shows[j]] {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t\\tsubscriptions[shows[j]] = true\\n\\t\\t\\t}\\n\\n\\t\\t\\tif j >= d && !subscriptions[shows[j-d]] {\\n\\t\\t\\t\\tcount--\\n\\t\\t\\t\\tdelete(subscriptions, shows[j-d])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif count > maxCount {\\n\\t\\t\\t\\tmaxCount = count\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfmt.Println(maxCount)\\n\\t}\\n}\\n\\nfunc nextInt(scanner *bufio.Scanner) int {\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\treturn n\\n}","Javascript":"function minimumSubscriptions(t, testCases) {\n  let results = [];\n  \n  for (let i = 0; i < t; i++) {\n    let [n, k, d] = testCases[i][0];\n    let shows = testCases[i][1];\n    \n    let subscriptions = new Set();\n    let count = 0;\n    let maxCount = 0;\n    \n    for (let j = 0; j < n; j++) {\n      subscriptions.add(shows[j]);\n      count++;\n      \n      if (count > d) {\n        subscriptions.delete(shows[j - d]);\n        count--;\n      }\n      \n      maxCount = Math.max(maxCount, subscriptions.size);\n    }\n    \n    results.push(maxCount);\n  }\n  \n  return results;\n}\n\n\/\/ Example usage\nlet t = 2;\nlet testCases = [\n  [[5, 3, 2], [1, 2, 1, 3, 2]],\n  [[6, 4, 3], [1, 2, 3, 4, 1, 2]]\n];\n\nlet output = minimumSubscriptions(t, testCases);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = Scanner(System.`in`)\n    val t = input.nextInt()\n    \n    repeat(t) {\n        val n = input.nextInt()\n        val k = input.nextInt()\n        val d = input.nextInt()\n        \n        val shows = IntArray(n)\n        for (i in 0 until n) {\n            shows[i] = input.nextInt()\n        }\n        \n        val subscriptions = IntArray(k + 1)\n        var minSubscriptions = Int.MAX_VALUE\n        var currentSubscriptions = 0\n        \n        for (i in 0 until d) {\n            if (subscriptions[shows[i]] == 0) {\n                currentSubscriptions++\n            }\n            subscriptions[shows[i]]++\n        }\n        \n        minSubscriptions = currentSubscriptions\n        \n        for (i in d until n) {\n            subscriptions[shows[i - d]]--\n            if (subscriptions[shows[i - d]] == 0) {\n                currentSubscriptions--\n            }\n            \n            if (subscriptions[shows[i]] == 0) {\n                currentSubscriptions++\n            }\n            subscriptions[shows[i]]++\n            \n            minSubscriptions = minOf(minSubscriptions, currentSubscriptions)\n        }\n        \n        println(minSubscriptions)\n    }\n}","PHP":"<?php\\n\\nfunction minimumSubscriptions($t, $testCases) {\\n    $results = [];\\n\\n    foreach ($testCases as $testCase) {\\n        $n = $testCase[0];\\n        $k = $testCase[1];\\n        $d = $testCase[2];\\n        $shows = $testCase[3];\\n\\n        $subscriptions = array_fill(1, $k, 0);\\n        $minSubscriptions = $k;\\n        $consecutiveDays = 0;\\n\\n        for ($i = 0; $i < $n; $i++) {\\n            $show = $shows[$i];\\n\\n            if ($subscriptions[$show] == 0) {\\n                $consecutiveDays++;\\n\\n                if ($consecutiveDays >= $d) {\\n                    $minSubscriptions = min($minSubscriptions, count(array_filter($subscriptions)));\\n                }\\n            }\\n\\n            $subscriptions[$show]++;\\n\\n            if ($i >= $d - 1) {\\n                $subscriptions[$shows[$i - $d + 1]]--;\\n\\n                if ($subscriptions[$shows[$i - $d + 1]] == 0) {\\n                    $consecutiveDays--;\\n                }\\n            }\\n        }\\n\\n        $results[] = $minSubscriptions;\\n    }\\n\\n    return $results;\\n}\\n\\n$t = readline();\\n$testCases = [];\\n\\nfor ($i = 0; $i < $t; $i++) {\\n    $testCase = explode(' ', readline());\\n    $n = $testCase[0];\\n    $k = $testCase[1];\\n    $d = $testCase[2];\\n    $shows = explode(' ', readline());\\n    $testCases[] = [$n, $k, $d, $shows];\\n}\\n\\n$results = minimumSubscriptions($t, $testCases);\\n\\nforeach ($results as $result) {\\n    echo $result . \\\"\\\\n\\\";\\n}\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int t;\\r\\n    scanf(\\\"%d\\\", &t);\\r\\n\\r\\n    int[] results;\\r\\n\\r\\n    for (int i = 0; i < t; i++)\\r\\n    {\\r\\n        int n, k, d;\\r\\n        scanf(\\\"%d %d %d\\\", &n, &k, &d);\\r\\n\\r\\n        int[] a;\\r\\n        for (int j = 0; j < n; j++)\\r\\n        {\\r\\n            int show;\\r\\n            scanf(\\\"%d\\\", &show);\\r\\n            a ~= show;\\r\\n        }\\r\\n\\r\\n        int minSubscriptions = k;\\r\\n\\r\\n        for (int j = 0; j <= n - d; j++)\\r\\n        {\\r\\n            int[] subShows = a[j..j + d];\\r\\n            int uniqueShows = subShows.unique.length;\\r\\n\\r\\n            if (uniqueShows < minSubscriptions)\\r\\n            {\\r\\n                minSubscriptions = uniqueShows;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        results ~= minSubscriptions;\\r\\n    }\\r\\n\\r\\n    foreach (result; results)\\r\\n    {\\r\\n        writeln(result);\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\n# Function to calculate the minimum number of subscriptions needed\nsub minimum_subscriptions {\n    my ($n, $k, $d, @shows) = @_;\n\n    my %count;\n    my $min_subscriptions = $d;\n\n    # Count the number of occurrences of each show in the first d days\n    for my $i (0..$d-1) {\n        $count{$shows[$i]}++;\n    }\n\n    # Calculate the initial number of subscriptions needed\n    my $subscriptions = scalar(keys %count);\n\n    # Iterate through the remaining days\n    for my $i ($d..$n-1) {\n        # Remove the show from the count if it is no longer in the window\n        $count{$shows[$i-$d]}--;\n        delete $count{$shows[$i-$d]} if $count{$shows[$i-$d]} == 0;\n\n        # Add the new show to the count\n        $count{$shows[$i]}++;\n\n        # Update the number of subscriptions needed\n        $subscriptions = scalar(keys %count);\n\n        # Update the minimum number of subscriptions\n        $min_subscriptions = $subscriptions if $subscriptions < $min_subscriptions;\n    }\n\n    return $min_subscriptions;\n}\n\n# Read the number of test cases\nmy $t = <STDIN>;\nchomp $t;\n\nmy @results;\n\n# Iterate through each test case\nfor my $i (1..$t) {\n    # Read the input for the test case\n    my ($n, $k, $d) = split ' ', <STDIN>;\n    chomp $d;\n    my @shows = split ' ', <STDIN>;\n    chomp @shows;\n\n    # Calculate the minimum number of subscriptions needed\n    my $min_subscriptions = minimum_subscriptions($n, $k, $d, @shows);\n\n    # Store the result\n    push @results, $min_subscriptions;\n}\n\n# Print the results\nprint join(' ', @results);\n","Rust":"fn main() {\\n    let t: usize = read();\\n\\n    for _ in 0..t {\\n        let line: Vec<usize> = read_vec();\\n        let n = line[0];\\n        let k = line[1];\\n        let d = line[2];\\n\\n        let shows: Vec<usize> = read_vec();\\n\\n        let mut subscriptions = 0;\\n        let mut max_consecutive = 0;\\n        let mut current_consecutive = 0;\\n\\n        for i in 0..n {\\n            if i < d {\\n                let show = shows[i];\\n                let count = shows.iter().filter(|&x| *x == show).count();\\n                if count > max_consecutive {\\n                    max_consecutive = count;\\n                }\\n                current_consecutive += 1;\\n            } else {\\n                let show = shows[i - d];\\n                let count = shows.iter().filter(|&x| *x == show).count();\\n                if count == max_consecutive {\\n                    current_consecutive -= 1;\\n                }\\n            }\\n\\n            if current_consecutive == d {\\n                subscriptions += 1;\\n                current_consecutive -= 1;\\n            }\\n        }\\n\\n        println!(\\\"{}\\\", subscriptions);\\n    }\\n}\\n\\nfn read<T: std::str::FromStr>() -> T {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    input.trim().parse().unwrap()\\n}\\n\\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    input\\n        .trim()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect()\\n}"}
{"title":"B. Lucky Substring","description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya was delivered a string s, containing only digits. He needs to find a string that represents a lucky number without leading zeroes, is not empty, is contained in s as a substring the maximum number of times.Among all the strings for which the three conditions given above are fulfilled, Petya only needs the lexicographically minimum one. Find this string for Petya.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The single line contains a non-empty string s whose length can range from 1 to 50, inclusive. The string only contains digits. The string can contain leading zeroes.\n","output_spec":"In the only line print the answer to Petya's problem. If the sought string does not exist, print \"-1\" (without quotes).\n","notes":"The lexicographical comparison of strings is performed by the < operator in the modern programming languages. String x is lexicographically less than string y either if x is a prefix of y, or exists such i (1\u2264i\u2264min(|x|,|y|)), that xi<yi and for any j (1\u2264j<i) xj=yj. Here |a| denotes the length of string a.\nIn the first sample three conditions are fulfilled for strings \"4\", \"7\" and \"47\". The lexicographically minimum one is \"4\".\nIn the second sample s has no substrings which are lucky numbers.\nIn the third sample the three conditions are only fulfilled for string \"7\".\n","sample_inputs":["047\n","16\n","472747\n"],"sample_outputs":["4\n","-1\n","7\n"],"id":"122-B","difficulty":1000,"tags":["brute+force","implementation"],"src_uid":"639b8b8d0dc42df46b139f0aeb3a7a0a","C++":"#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isLuckyNumber(string num) {\\n    for (char c : num) {\\n        if (c != '4' && c != '7') {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nstring findLuckyNumber(string s) {\\n    int n = s.length();\\n    string ans = \\\"-1\\\";\\n    for (int len = 1; len <= n; len++) {\\n        for (int i = 0; i <= n - len; i++) {\\n            string substr = s.substr(i, len);\\n            if (isLuckyNumber(substr)) {\\n                if (ans == \\\"-1\\\" || substr < ans) {\\n                    ans = substr;\\n                }\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n\\nint main() {\\n    string s;\\n    cin >> s;\\n    string result = findLuckyNumber(s);\\n    cout << result << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class LuckyNumbers {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine().trim();\n        scanner.close();\n        \n        int[] count = new int[10];\n        for (char c : s.toCharArray()) {\n            count[c - '0']++;\n        }\n        \n        int minCount = Math.min(count[4], count[7]);\n        if (minCount == 0) {\n            System.out.println(\"-1\");\n            return;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < minCount; i++) {\n            sb.append(\"4\");\n        }\n        for (int i = 0; i < minCount; i++) {\n            sb.append(\"7\");\n        }\n        \n        System.out.println(sb.toString());\n    }\n}","Python":"def find_lucky_number(s):\n    count_4 = s.count('4')\n    count_7 = s.count('7')\n    \n    if count_4 == 0 and count_7 == 0:\n        return '-1'\n    elif count_4 >= count_7:\n        return '4'\n    else:\n        return '7'\n\ns = input().strip()\nresult = find_lucky_number(s)\nprint(result)","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char s[51];\\n    scanf(\\\"%s\\\", s);\\n    int count[2] = {0};\\n    int len = strlen(s);\\n    for (int i = 0; i < len; i++) {\\n        if (s[i] == '4') {\\n            count[0]++;\\n        } else if (s[i] == '7') {\\n            count[1]++;\\n        }\\n    }\\n    if (count[0] == 0 && count[1] == 0) {\\n        printf(\\\"-1\\\\n\\\");\\n    } else if (count[0] >= count[1]) {\\n        printf(\\\"4\\\\n\\\");\\n    } else {\\n        printf(\\\"7\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string s = Console.ReadLine();\n        string result = FindLuckyNumber(s);\n        Console.WriteLine(result);\n    }\n\n    public static string FindLuckyNumber(string s)\n    {\n        int[] count = new int[10];\n        foreach (char c in s)\n        {\n            count[c - '0']++;\n        }\n\n        int minCount = Math.Min(count[4], count[7]);\n        if (minCount == 0)\n        {\n            return \"-1\";\n        }\n\n        string luckyNumber = \"\";\n        for (int i = 0; i < minCount; i++)\n        {\n            luckyNumber += \"4\";\n        }\n\n        for (int i = 0; i < minCount; i++)\n        {\n            luckyNumber += \"7\";\n        }\n\n        return luckyNumber;\n    }\n}","Ruby":"\ndef find_lucky_number(s)\n  # Initialize variables\n  lucky_numbers = []\n  max_count = 0\n  min_lucky_number = \"\"\n\n  # Iterate through all possible substrings of s\n  (0..s.length-1).each do |i|\n    (i..s.length-1).each do |j|\n      substring = s[i..j]\n      count = substring.scan(\/[47]\/).length\n\n      # Check if substring is a lucky number and update variables accordingly\n      if count > max_count || (count == max_count && substring < min_lucky_number)\n        lucky_numbers = [substring]\n        max_count = count\n        min_lucky_number = substring\n      elsif count == max_count && substring == min_lucky_number\n        lucky_numbers << substring\n      end\n    end\n  end\n\n  # Return the lexicographically minimum lucky number or -1 if none exists\n  lucky_numbers.empty? ? '-1' : lucky_numbers.min\nend\n\n# Read input from STDIN\ns = gets.chomp\n\n# Call the function and print the result\nputs find_lucky_number(s)\n","delphi":"program LuckyNumbers;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction CountSubstring(const Substring, Text: string): Integer;\\nvar\\n  Index: Integer;\\nbegin\\n  Result := 0;\\n  Index := Pos(Substring, Text);\\n  while Index > 0 do\\n  begin\\n    Inc(Result);\\n    Index := PosEx(Substring, Text, Index + Length(Substring));\\n  end;\\nend;\\n\\nfunction FindLuckyNumber(const s: string): string;\\nvar\\n  i, j: Integer;\\n  Substring: string;\\n  LuckyNumber: string;\\nbegin\\n  Result := '-1';\\n  for i := 1 to Length(s) do\\n  begin\\n    for j := i to Length(s) do\\n    begin\\n      Substring := Copy(s, i, j - i + 1);\\n      if (Substring[1] <> '0') and (CountSubstring(Substring, s) > CountSubstring(LuckyNumber, s)) then\\n      begin\\n        if (LuckyNumber = '') or (Substring < LuckyNumber) then\\n          LuckyNumber := Substring;\\n      end;\\n    end;\\n  end;\\n  if LuckyNumber <> '' then\\n    Result := LuckyNumber;\\nend;\\n\\nvar\\n  s: string;\\nbegin\\n  ReadLn(s);\\n  WriteLn(FindLuckyNumber(s));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar s string\\n\\tfmt.Scan(&s)\\n\\n\\tcount := make(map[string]int)\\n\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tfor j := i + 1; j <= len(s); j++ {\\n\\t\\t\\tsubstring := s[i:j]\\n\\t\\t\\tif strings.Contains(substring, \\\"4\\\") || strings.Contains(substring, \\\"7\\\") {\\n\\t\\t\\t\\tcount[substring]++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tminSubstring := \\\"-1\\\"\\n\\n\\tfor substring, freq := range count {\\n\\t\\tif freq > count[minSubstring] || (freq == count[minSubstring] && substring < minSubstring) {\\n\\t\\t\\tminSubstring = substring\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minSubstring)\\n}","Javascript":"function findLuckyNumber(s) {\n  let count = 0;\n  let minString = '';\n  \n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '4' || s[i] === '7') {\n      let currentString = s[i];\n      let currentCount = 1;\n      \n      for (let j = i + 1; j < s.length; j++) {\n        if (s[j] === '4' || s[j] === '7') {\n          currentString += s[j];\n          currentCount++;\n        } else {\n          break;\n        }\n      }\n      \n      if (currentCount > count || (currentCount === count && currentString < minString)) {\n        count = currentCount;\n        minString = currentString;\n      }\n    }\n  }\n  \n  if (count === 0) {\n    return '-1';\n  } else {\n    return minString;\n  }\n}\n\nconst input = '047';\nconst output = findLuckyNumber(input);\nconsole.log(output);","Kotlin":"fun main() {\\n    val s = readLine()!!\\n    var count4 = 0\\n    var count7 = 0\\n\\n    for (c in s) {\\n        if (c == '4') count4++\\n        if (c == '7') count7++\\n    }\\n\\n    if (count4 == 0 && count7 == 0) {\\n        println(-1)\\n        return\\n    }\\n\\n    if (count4 >= count7) {\\n        println(4)\\n    } else {\\n        println(7)\\n    }\\n}","PHP":"<?php\\n\\nfunction findLuckyNumber($s) {\\n    $count = array_count_values(str_split($s));\\n    $luckyNumbers = [];\\n\\n    \/\/ Check if lucky numbers exist in the string\\n    if (isset($count[4]) || isset($count[7])) {\\n        \/\/ Check if both lucky digits exist\\n        if (isset($count[4]) && isset($count[7])) {\\n            \/\/ Find the minimum count of lucky digits\\n            $minCount = min($count[4], $count[7]);\\n\\n            \/\/ Generate the lexicographically minimum lucky number\\n            $luckyNumbers[] = str_repeat('4', $minCount) . str_repeat('7', $minCount);\\n        } else {\\n            \/\/ Only one lucky digit exists\\n            $luckyDigit = isset($count[4]) ? 4 : 7;\\n\\n            \/\/ Generate the lexicographically minimum lucky number\\n            $luckyNumbers[] = str_repeat($luckyDigit, $count[$luckyDigit]);\\n        }\\n    }\\n\\n    \/\/ Return the lexicographically minimum lucky number or -1 if none exists\\n    return count($luckyNumbers) > 0 ? min($luckyNumbers) : -1;\\n}\\n\\n\/\/ Test cases\\n$testCases = ['047', '16', '472747'];\\n$results = [];\\n\\nforeach ($testCases as $testCase) {\\n    $result = findLuckyNumber($testCase);\\n    $results[] = $result;\\n}\\n\\necho json_encode($results);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring findLuckyNumber(string s) {\\r\\n    int[] count = new int[10];\\r\\n    foreach (char c; s) {\\r\\n        count[c - '0']++;\\r\\n    }\\r\\n\\r\\n    string result = \\\"\\\";\\r\\n    for (int i = 0; i < 10; i++) {\\r\\n        if (i == 4 || i == 7) {\\r\\n            if (count[i] > 0) {\\r\\n                result = to!string(i);\\r\\n                count[i]--;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (result == \\\"\\\") {\\r\\n        return \\\"-1\\\";\\r\\n    }\\r\\n\\r\\n    for (int i = 0; i < 10; i++) {\\r\\n        if (i == 4 || i == 7) {\\r\\n            while (count[i] > 0) {\\r\\n                result ~= to!string(i);\\r\\n                count[i]--;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    string s = \\\"047\\\";\\r\\n    writeln(findLuckyNumber(s));\\r\\n\\r\\n    s = \\\"16\\\";\\r\\n    writeln(findLuckyNumber(s));\\r\\n\\r\\n    s = \\\"472747\\\";\\r\\n    writeln(findLuckyNumber(s));\\r\\n}","perl":"\n# Read the input string\nmy $s = <STDIN>;\nchomp $s;\n\n# Initialize variables\nmy $min_lucky = -1;\nmy $min_count = 0;\n\n# Iterate through all possible substrings of $s\nfor (my $i = 0; $i < length($s); $i++) {\n    for (my $j = $i + 1; $j <= length($s); $j++) {\n        my $substring = substr($s, $i, $j - $i);\n        \n        # Check if the substring is a lucky number\n        if ($substring =~ \/^[47]+$\/) {\n            # Count the number of occurrences of the substring in $s\n            my $count = () = $s =~ \/(?=$substring)\/g;\n            \n            # Update the minimum lucky number if necessary\n            if ($min_lucky == -1 || $count > $min_count || ($count == $min_count && $substring lt $min_lucky)) {\n                $min_lucky = $substring;\n                $min_count = $count;\n            }\n        }\n    }\n}\n\n# Print the result\nif ($min_lucky == -1) {\n    print \\\"-1\\\\n\\\";\n} else {\n    print \\\"$min_lucky\\\\n\\\";\n}\n","Rust":"fn main() {\\n    let input = \\\"047\\\";\\n    let mut count = [0; 10];\\n\\n    for c in input.chars() {\\n        let digit = c.to_digit(10).unwrap() as usize;\\n        count[digit] += 1;\\n    }\\n\\n    let mut result = String::new();\\n\\n    for i in 4..=7 {\\n        if count[i] > 0 {\\n            result.push_str(&i.to_string().repeat(count[i]));\\n        }\\n    }\\n\\n    if result.is_empty() {\\n        println!(\\\"-1\\\");\\n    } else {\\n        println!(\\\"{}\\\", result);\\n    }\\n}"}
{"title":"A. Dawid and Bags of Candies","description":"Dawid has four bags of candies. The $$$i$$$-th of them contains $$$a_i$$$ candies. Also, Dawid has two friends. He wants to give each bag to one of his two friends. Is it possible to distribute the bags in such a way that each friend receives the same amount of candies in total?Note, that you can't keep bags for yourself or throw them away, each bag should be given to one of the friends.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The only line contains four integers $$$a_1$$$, $$$a_2$$$, $$$a_3$$$ and $$$a_4$$$ ($$$1 \\\\leq a_i \\\\leq 100$$$) \u2014 the numbers of candies in each bag.\n","output_spec":"Output YES if it's possible to give the bags to Dawid's friends so that both friends receive the same amount of candies, or NO otherwise. Each character can be printed in any case (either uppercase or lowercase).\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1230-A","difficulty":800,"tags":["brute+force","implementation"],"src_uid":"5a623c49cf7effacfb58bc82f8eaff37","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int a[4];\\n    for(int i=0;i<4;i++)\\n    {\\n        cin>>a[i];\\n    }\\n    sort(a,a+4);\\n    if(a[0]+a[3]==a[1]+a[2] || a[0]+a[1]+a[2]==a[3])\\n    {\\n        cout<<\\\"YES\\\"<<endl;\\n    }\\n    else\\n    {\\n        cout<<\\\"NO\\\"<<endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Arrays;\n\npublic class CandyDistribution {\n    public static void main(String[] args) {\n        int[] candies = new int[4];\n        \/\/ Read input\n        for (int i = 0; i < 4; i++) {\n            candies[i] = Integer.parseInt(args[i]);\n        }\n        \n        \/\/ Sort the candies in non-decreasing order\n        Arrays.sort(candies);\n        \n        \/\/ Check if it's possible to distribute the candies equally\n        if (candies[0] + candies[3] == candies[1] + candies[2] || candies[0] + candies[1] + candies[2] == candies[3]) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n}","Python":"def distribute_candies(a1, a2, a3, a4):\\n    total_candies = a1 + a2 + a3 + a4\\n    if total_candies % 2 != 0:\\n        return 'NO'\\n    target_candies = total_candies \/\/ 2\\n    if target_candies in [a1, a2, a3, a4]:\\n        return 'YES'\\n    for i in range(4):\\n        for j in range(i+1, 4):\\n            if a[i] + a[j] == target_candies:\\n                return 'YES'\\n    return 'NO'\\n\\na1, a2, a3, a4 = map(int, input().split())\\nprint(distribute_candies(a1, a2, a3, a4))","C":"#include <stdio.h>\\n\\nint main() {\\n    int a[4];\\n    int sum = 0;\\n    for (int i = 0; i < 4; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n        sum += a[i];\\n    }\\n\\n    if (sum % 2 != 0) {\\n        printf(\\\"NO\\\");\\n    } else {\\n        int target = sum \/ 2;\\n        int dp[1001] = {0};\\n        dp[0] = 1;\\n\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = target; j >= a[i]; j--) {\\n                if (dp[j - a[i]]) {\\n                    dp[j] = 1;\\n                }\\n            }\\n        }\\n\\n        if (dp[target]) {\\n            printf(\\\"YES\\\");\\n        } else {\\n            printf(\\\"NO\\\");\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int[] candies = new int[4];\n        for (int i = 0; i < 4; i++)\n        {\n            candies[i] = int.Parse(input[i]);\n        }\n\n        bool possible = CanDistributeCandies(candies);\n\n        if (possible)\n        {\n            Console.WriteLine(\"YES\");\n        }\n        else\n        {\n            Console.WriteLine(\"NO\");\n        }\n    }\n\n    static bool CanDistributeCandies(int[] candies)\n    {\n        int totalCandies = candies[0] + candies[1] + candies[2] + candies[3];\n\n        if (totalCandies % 2 != 0)\n        {\n            return false;\n        }\n\n        int targetCandies = totalCandies \/ 2;\n\n        for (int i = 0; i < 4; i++)\n        {\n            for (int j = i + 1; j < 4; j++)\n            {\n                if (candies[i] + candies[j] == targetCandies)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}","Ruby":"\ndef distribute_candies(a1, a2, a3, a4)\n  total_candies = a1 + a2 + a3 + a4\n\n  if total_candies % 2 != 0\n    return 'NO'\n  end\n\n  target_candies = total_candies \/ 2\n\n  if a1 == target_candies || a2 == target_candies || a3 == target_candies || a4 == target_candies\n    return 'YES'\n  end\n\n  if a1 + a2 == target_candies || a1 + a3 == target_candies || a1 + a4 == target_candies || a2 + a3 == target_candies || a2 + a4 == target_candies || a3 + a4 == target_candies\n    return 'YES'\n  end\n\n  if a1 + a2 + a3 == target_candies || a1 + a2 + a4 == target_candies || a1 + a3 + a4 == target_candies || a2 + a3 + a4 == target_candies\n    return 'YES'\n  end\n\n  return 'NO'\nend\n\na1, a2, a3, a4 = gets.chomp.split.map(&:to_i)\nputs distribute_candies(a1, a2, a3, a4)\n","delphi":"program CandyDistribution;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction CanDistributeCandies(a1, a2, a3, a4: Integer): string;\\nvar\\n  totalCandies, friend1Candies, friend2Candies: Integer;\\nbegin\\n  totalCandies := a1 + a2 + a3 + a4;\\n  if totalCandies mod 2 = 1 then\\n  begin\\n    Result := 'NO';\\n    Exit;\\n  end;\\n\\n  friend1Candies := a1 + a2;\\n  friend2Candies := a3 + a4;\\n\\n  if (friend1Candies = totalCandies div 2) or (friend2Candies = totalCandies div 2) or\\n    (friend1Candies + friend2Candies = totalCandies) then\\n    Result := 'YES'\\n  else\\n    Result := 'NO';\\nend;\\n\\nvar\\n  a1, a2, a3, a4: Integer;\\nbegin\\n  Readln(a1, a2, a3, a4);\\n  Writeln(CanDistributeCandies(a1, a2, a3, a4));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar a [4]int\\n\\tfor i := 0; i < 4; i++ {\\n\\t\\tfmt.Scan(&a[i])\\n\\t}\\n\\n\\tsort.Ints(a[:])\\n\\n\\tif a[0]+a[3] == a[1]+a[2] || a[0]+a[1]+a[2] == a[3] {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function canDistributeBags(a1, a2, a3, a4) {\n    const totalCandies = a1 + a2 + a3 + a4;\n    if (totalCandies % 2 !== 0) {\n        return 'NO';\n    }\n    \n    const targetCandies = totalCandies \/ 2;\n    \n    if (a1 === targetCandies || a2 === targetCandies || a3 === targetCandies || a4 === targetCandies) {\n        return 'YES';\n    }\n    \n    if (a1 + a2 === targetCandies || a1 + a3 === targetCandies || a1 + a4 === targetCandies || a2 + a3 === targetCandies || a2 + a4 === targetCandies || a3 + a4 === targetCandies) {\n        return 'YES';\n    }\n    \n    if (a1 + a2 + a3 === targetCandies || a1 + a2 + a4 === targetCandies || a1 + a3 + a4 === targetCandies || a2 + a3 + a4 === targetCandies) {\n        return 'YES';\n    }\n    \n    return 'NO';\n}\n\nconst a1 = 3;\nconst a2 = 4;\nconst a3 = 5;\nconst a4 = 6;\n\nconst result = canDistributeBags(a1, a2, a3, a4);\nconsole.log(result);","Kotlin":"fun main() {\n    val candies = readLine()!!.split(\" \").map { it.toInt() }\n    val sum = candies.sum()\n    \n    if (sum % 2 == 0 && candies.max()!! <= sum \/ 2) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"\n<?php\n\nfunction canDistributeCandies($a1, $a2, $a3, $a4) {\n    $totalCandies = $a1 + $a2 + $a3 + $a4;\n    \n    \/\/ If the total number of candies is not divisible by 2, it is not possible to distribute equally\n    if ($totalCandies % 2 != 0) {\n        return 'NO';\n    }\n    \n    $targetCandies = $totalCandies \/ 2;\n    \n    \/\/ Check if it is possible to select a combination of bags that sums up to the target number of candies\n    if (isCombinationPossible($a1, $a2, $a3, $a4, $targetCandies)) {\n        return 'YES';\n    } else {\n        return 'NO';\n    }\n}\n\nfunction isCombinationPossible($a1, $a2, $a3, $a4, $target) {\n    \/\/ Try all possible combinations of selecting bags\n    for ($i = 0; $i <= 1; $i++) {\n        for ($j = 0; $j <= 1; $j++) {\n            for ($k = 0; $k <= 1; $k++) {\n                for ($l = 0; $l <= 1; $l++) {\n                    $candies = $i * $a1 + $j * $a2 + $k * $a3 + $l * $a4;\n                    if ($candies == $target) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\n\/\/ Sample input\n$a1 = 3;\n$a2 = 4;\n$a3 = 5;\n$a4 = 6;\n\n$result = canDistributeCandies($a1, $a2, $a3, $a4);\necho $result;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nbool canDistributeBags(int[] bags)\\r\\n{\\r\\n    int totalCandies = bags[0] + bags[1] + bags[2] + bags[3];\\r\\n    if (totalCandies % 2 != 0)\\r\\n    {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    int targetCandies = totalCandies \/ 2;\\r\\n\\r\\n    for (int i = 0; i < 4; i++)\\r\\n    {\\r\\n        for (int j = i + 1; j < 4; j++)\\r\\n        {\\r\\n            if (bags[i] + bags[j] == targetCandies)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int[] bags = [1, 2, 3, 4];\\r\\n\\r\\n    if (canDistributeBags(bags))\\r\\n    {\\r\\n        writeln(\\\"YES\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\n# Read the input\nmy $input = <STDIN>;\nchomp $input;\nmy @bags = split ' ', $input;\n\n# Calculate the total number of candies\nmy $total_candies = 0;\nforeach my $bag (@bags) {\n    $total_candies += $bag;\n}\n\n# Check if it's possible to distribute the bags equally\nif ($total_candies % 2 == 0) {\n    print 'YES';\n} else {\n    print 'NO';\n}\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let candies: Vec<i32> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let sum: i32 = candies.iter().sum();\n    let max_candies = *candies.iter().max().unwrap();\n\n    if sum % 2 == 0 && max_candies <= sum \/ 2 {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"D. String","description":"You are given a string s. Each pair of numbers l and r that fulfill the condition 1\u2264l\u2264r\u2264|s|, correspond to a substring of the string s, starting in the position l and ending in the position r (inclusive).Let's define the function of two strings F(x,y) like this. We'll find a list of such pairs of numbers for which the corresponding substrings of string x are equal to string y. Let's sort this list of pairs according to the pair's first number's increasing. The value of function F(x,y) equals the number of non-empty continuous sequences in the list.For example: F(babbabbababbab,babb)=6. The list of pairs is as follows:(1,4),(4,7),(9,12)Its continuous sequences are:   (1,4)  (4,7)  (9,12)  (1,4),(4,7)  (4,7),(9,12)  (1,4),(4,7),(9,12) Your task is to calculate for the given string s the sum F(s,x) for all x, that x belongs to the set of all substrings of a string s.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line contains the given string s, consisting only of small Latin letters (1\u2264|s|\u226410^5).\n","output_spec":"Print the single number \u2014 the sought sum.\nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","notes":"In the first sample the function values at x equal to \"a\", \"aa\", \"aaa\" and \"aaaa\" equal 10, 6, 3 and 1 correspondingly.\nIn the second sample for any satisfying x the function value is 1.\n","sample_inputs":["aaaa\n","abcdef\n","abacabadabacaba\n"],"sample_outputs":["20\n","21\n","188\n"],"id":"123-D","difficulty":2300,"tags":["string+suffix+structures"],"src_uid":"db853d598b638dcdeaea5a26ae83758b","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nint main() {\\n    string s;\\n    cin >> s;\\n    int n = s.length();\\n    long long ans = 0;\\n    vector<int> cnt(n + 1);\\n    for (int i = 0; i < n; i++) {\\n        cnt[i + 1] = cnt[i] + (s[i] == 'a');\\n    }\\n    for (int len = 1; len <= n; len++) {\\n        for (int i = 0; i + len <= n; i++) {\\n            int j = i + len - 1;\\n            ans += cnt[j + 1] - cnt[i];\\n        }\\n    }\\n    cout << ans << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        int n = s.length();\n        \n        long[] prefixCount = new long[n + 1];\n        long[] suffixCount = new long[n + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            prefixCount[i] = prefixCount[i - 1] + i;\n        }\n        \n        for (int i = n; i >= 1; i--) {\n            suffixCount[i] = suffixCount[i + 1] + (n - i + 1);\n        }\n        \n        Map<String, Integer> substringCount = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                String substring = s.substring(i, j + 1);\n                substringCount.put(substring, substringCount.getOrDefault(substring, 0) + 1);\n            }\n        }\n        \n        long sum = 0;\n        \n        for (String substring : substringCount.keySet()) {\n            int count = substringCount.get(substring);\n            sum += prefixCount[count] * suffixCount[count + 1];\n        }\n        \n        System.out.println(sum);\n    }\n}","Python":"def F(x, y):\\n    pairs = []\\n    for i in range(len(x)):\\n        for j in range(i, len(x)):\\n            if x[i:j+1] == y:\\n                pairs.append((i+1, j+1))\\n    pairs.sort()\\n    count = 0\\n    prev = None\\n    for pair in pairs:\\n        if prev is None:\\n            count += 1\\n        elif pair[0] == prev[1] + 1:\\n            count += 1\\n        else:\\n            count += 2\\n        prev = pair\\n    return count\\n\\ns = input().strip()\\nresult = 0\\nfor i in range(len(s)):\\n    result += F(s, s[i:i+1])\\nprint(result)","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char s[100005];\\n    scanf(\\\"%s\\\", s);\\n    int n = strlen(s);\\n    long long int sum = 0;\\n\\n    for(int i=0; i<n; i++) {\\n        int count = 0;\\n        for(int j=i; j<n; j++) {\\n            if(s[j] == s[i]) {\\n                count++;\\n            }\\n            sum += count;\\n        }\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", sum);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace SubstringFunction\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = Console.ReadLine();\n            long result = CalculateSubstringFunction(s);\n            Console.WriteLine(result);\n        }\n\n        static long CalculateSubstringFunction(string s)\n        {\n            int n = s.Length;\n            long sum = 0;\n            Dictionary<string, List<int>> substrings = new Dictionary<string, List<int>>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string substring = \"\";\n                for (int j = i; j < n; j++)\n                {\n                    substring += s[j];\n                    if (!substrings.ContainsKey(substring))\n                    {\n                        substrings[substring] = new List<int>();\n                    }\n                    substrings[substring].Add(j);\n                }\n            }\n\n            foreach (var kvp in substrings)\n            {\n                List<int> positions = kvp.Value;\n                int count = 1;\n                int prevPos = positions[0];\n                for (int i = 1; i < positions.Count; i++)\n                {\n                    if (positions[i] == prevPos + 1)\n                    {\n                        count++;\n                    }\n                    else\n                    {\n                        sum += count * (count + 1) \/ 2;\n                        count = 1;\n                    }\n                    prevPos = positions[i];\n                }\n                sum += count * (count + 1) \/ 2;\n            }\n\n            return sum;\n        }\n    }\n}","Ruby":"\ndef f(x, y)\n  pairs = []\n  (0..x.length-y.length).each do |i|\n    pairs << [i+1, i+y.length] if x[i, y.length] == y\n  end\n  pairs.sort!\n  \n  count = 0\n  sequences = 0\n  prev_end = 0\n  \n  pairs.each do |pair|\n    if pair[0] > prev_end\n      sequences += count * (count + 1) \/ 2\n      count = 1\n    else\n      count += 1\n    end\n    prev_end = pair[1]\n  end\n  \n  sequences += count * (count + 1) \/ 2\n  \n  sequences\nend\n\ns = gets.chomp\nsum = 0\n\n(0..s.length-1).each do |i|\n  sum += f(s, s[i])\nend\n\nputs sum\n","delphi":"program Main;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction F(x, y: string): Integer;\\nvar\\n  pairs: array of TPair<Integer, Integer>;\\n  i, j, k: Integer;\\n  count: Integer;\\nbegin\\n  SetLength(pairs, Length(x) * Length(y));\\n  k := 0;\\n  for i := 1 to Length(x) do\\n  begin\\n    for j := i to Length(x) do\\n    begin\\n      if Copy(x, i, j - i + 1) = y then\\n      begin\\n        pairs[k].Key := i;\\n        pairs[k].Value := j;\\n        Inc(k);\\n      end;\\n    end;\\n  end;\\n\\n  count := 0;\\n  for i := 0 to Length(pairs) - 1 do\\n  begin\\n    for j := i + 1 to Length(pairs) - 1 do\\n    begin\\n      if pairs[j].Key > pairs[i].Value then\\n        Break;\\n      Inc(count);\\n    end;\\n  end;\\n\\n  Result := count;\\nend;\\n\\nvar\\n  s: string;\\n  i: Integer;\\n  sum: Int64;\\nbegin\\n  ReadLn(s);\\n\\n  sum := 0;\\n  for i := 1 to Length(s) do\\n  begin\\n    sum := sum + F(s, Copy(s, 1, i));\\n  end;\\n\\n  WriteLn(sum);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar s string\\n\\tfmt.Scan(&s)\\n\\n\\tcount := 0\\n\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tsubstring := s[i : j+1]\\n\\t\\t\\tcount += countSubstrings(s, substring)\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}\\n\\nfunc countSubstrings(s string, substring string) int {\\n\\tcount := 0\\n\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif strings.HasPrefix(s[i:], substring) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}","Javascript":"\nfunction F(x, y) {\n    let pairs = [];\n    for (let l = 0; l < x.length; l++) {\n        for (let r = l; r < x.length; r++) {\n            let substring = x.substring(l, r + 1);\n            if (substring === y) {\n                pairs.push([l + 1, r + 1]);\n            }\n        }\n    }\n    pairs.sort((a, b) => a[0] - b[0]);\n    \n    let count = 0;\n    let sequences = 0;\n    for (let i = 0; i < pairs.length; i++) {\n        if (i > 0 && pairs[i][0] !== pairs[i - 1][1] + 1) {\n            sequences = 0;\n        }\n        sequences++;\n        count += sequences;\n    }\n    \n    return count;\n}\n\nfunction calculateSum(s) {\n    let sum = 0;\n    for (let i = 0; i < s.length; i++) {\n        let substring = s.substring(i);\n        sum += F(s, substring);\n    }\n    return sum;\n}\n\nlet s = 'aaaa';\nlet sum = calculateSum(s);\nconsole.log(sum);\n","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!\n    val n = input.length\n    val count = LongArray(n + 1)\n    val last = IntArray(26)\n    val prev = IntArray(n + 1)\n    val dp = LongArray(n + 1)\n    \n    for (i in 1..n) {\n        prev[i] = last[input[i - 1] - 'a']\n        last[input[i - 1] - 'a'] = i\n    }\n    \n    for (i in 1..n) {\n        dp[i] = dp[i - 1] + i - prev[i]\n        count[i] = count[i - 1] + dp[i]\n    }\n    \n    println(count[n])\n}","PHP":"\n<?php\n\nfunction F($x, $y) {\n    $pairs = [];\n    $n = strlen($x);\n    $m = strlen($y);\n    \n    for ($i = 0; $i < $n; $i++) {\n        for ($j = $i; $j < $n; $j++) {\n            $sub = substr($x, $i, $j - $i + 1);\n            if ($sub == $y) {\n                $pairs[] = [$i + 1, $j + 1];\n            }\n        }\n    }\n    \n    sort($pairs);\n    \n    $count = 0;\n    $prev = null;\n    \n    foreach ($pairs as $pair) {\n        if ($prev == null || $pair[0] > $prev[1]) {\n            $count++;\n        }\n        $prev = $pair;\n    }\n    \n    return $count;\n}\n\n$s = trim(fgets(STDIN));\n\n$sum = 0;\n$n = strlen($s);\n\nfor ($i = 0; $i < $n; $i++) {\n    for ($j = $i; $j < $n; $j++) {\n        $sub = substr($s, $i, $j - $i + 1);\n        $sum += F($s, $sub);\n    }\n}\n\necho $sum;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    string s;\\r\\n    readln(s);\\r\\n\\r\\n    ulong sum = 0;\\r\\n\\r\\n    foreach (i; 0..s.length)\\r\\n    {\\r\\n        foreach (j; i+1..s.length+1)\\r\\n        {\\r\\n            string x = s[i..j];\\r\\n            sum += count(s, x);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(sum);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub F {\n    my ($x, $y) = @_;\n    my @pairs;\n    my $len_x = length($x);\n    my $len_y = length($y);\n    \n    for (my $l = 0; $l < $len_x; $l++) {\n        for (my $r = $l; $r < $len_x; $r++) {\n            my $substr = substr($x, $l, $r - $l + 1);\n            if ($substr eq $y) {\n                push @pairs, [$l+1, $r+1];\n            }\n        }\n    }\n    \n    @pairs = sort { $a->[0] <=> $b->[0] } @pairs;\n    \n    my $count = 0;\n    my $prev_r = 0;\n    \n    foreach my $pair (@pairs) {\n        my ($l, $r) = @$pair;\n        if ($l > $prev_r) {\n            $count++;\n        }\n        $prev_r = $r;\n    }\n    \n    return $count;\n}\n\nsub sum_F {\n    my ($s) = @_;\n    my $sum = 0;\n    my $len = length($s);\n    \n    for (my $i = 0; $i < $len; $i++) {\n        my $substr = substr($s, $i, 1);\n        $sum += F($s, $substr);\n    }\n    \n    return $sum;\n}\n\n# Read input string\nmy $s = <STDIN>;\nchomp $s;\n\n# Calculate and print the sum\nmy $result = sum_F($s);\nprint $result;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut handle = stdin.lock();\n\n    let mut s = String::new();\n    handle.read_line(&mut s).unwrap();\n    let s = s.trim();\n\n    let mut freq: Vec<usize> = vec![0; s.len() + 1];\n    let mut sum: usize = 0;\n\n    for i in 0..s.len() {\n        freq[i + 1] = freq[i] + (s.chars().nth(i).unwrap() == 'a') as usize;\n        sum += freq[i + 1];\n    }\n\n    println!(\"{}\", sum);\n}"}
{"title":"C. Games with Rectangle","description":"In this task Anna and Maria play the following game. Initially they have a checkered piece of paper with a painted n\u00d7m rectangle (only the border, no filling). Anna and Maria move in turns and Anna starts. During each move one should paint inside the last-painted rectangle a new lesser rectangle (along the grid lines). The new rectangle should have no common points with the previous one. Note that when we paint a rectangle, we always paint only the border, the rectangles aren't filled.Nobody wins the game \u2014 Anna and Maria simply play until they have done k moves in total. Count the number of different ways to play this game.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first and only line contains three integers: n,m,k (1\u2264n,m,k\u22641000).\n","output_spec":"Print the single number \u2014 the number of the ways to play the game. As this number can be very big, print the value modulo 1000000007 (10^9+7).\n","notes":"Two ways to play the game are considered different if the final pictures are different. In other words, if one way contains a rectangle that is not contained in the other way.\nIn the first sample Anna, who performs her first and only move, has only one possible action plan \u2014 insert a 1\u00d71 square inside the given 3\u00d73 square.\nIn the second sample Anna has as much as 9 variants: 4 ways to paint a 1\u00d71 square, 2 ways to insert a 1\u00d72 rectangle vertically, 2 more ways to insert it horizontally and one more way is to insert a 2\u00d72 square.\n","sample_inputs":["3 3 1\n","4 4 1\n","6 7 2\n"],"sample_outputs":["1\n","9\n","75\n"],"id":"128-C","difficulty":2000,"tags":["combinatorics","dp"],"src_uid":"309d2d46086d526d160292717dfef308","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n, m, k;\\n    cin >> n >> m >> k;\\n\\n    vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= m; j++) {\\n            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;\\n        }\\n    }\\n\\n    int ans = dp[n][m];\\n    for (int i = 1; i < k; i++) {\\n        ans = (ans * 2) % MOD;\\n    }\\n\\n    cout << ans << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class GameWays {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        int n = Integer.parseInt(input[0]);\\n        int m = Integer.parseInt(input[1]);\\n        int k = Integer.parseInt(input[2]);\\n\\n        long[][] dp = new long[n + 1][m + 1];\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % 1000000007;\\n            }\\n        }\\n\\n        long ways = dp[n][m];\\n        long result = 1;\\n\\n        for (int i = 0; i < k; i++) {\\n            result = (result * ways) % 1000000007;\\n        }\\n\\n        System.out.println(result);\\n    }\\n}","Python":"def count_ways(n, m, k):\n    MOD = 1000000007\n    dp = [[[0] * (k + 1) for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j][1] = (i - 1) * (j - 1)\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            for l in range(2, k + 1):\n                for x in range(1, i):\n                    dp[i][j][l] = (dp[i][j][l] + dp[x][j][l - 1] * (i - x - 1) * (j - 1)) % MOD\n                for y in range(1, j):\n                    dp[i][j][l] = (dp[i][j][l] + dp[i][y][l - 1] * (j - y - 1) * (i - 1)) % MOD\n    \n    return dp[n][m][k]\n\ninput_data = input().split()\nn = int(input_data[0])\nm = int(input_data[1])\nk = int(input_data[2])\n\nresult = count_ways(n, m, k)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n    long long int dp[n+1][m+1][k+1];\\n    int mod = 1000000007;\\n\\n    for(int i=0; i<=n; i++) {\\n        for(int j=0; j<=m; j++) {\\n            for(int l=0; l<=k; l++) {\\n                dp[i][j][l] = 0;\\n            }\\n        }\\n    }\\n\\n    for(int i=1; i<=n; i++) {\\n        for(int j=1; j<=m; j++) {\\n            dp[i][j][1] = (i*j)%mod;\\n        }\\n    }\\n\\n    for(int l=2; l<=k; l++) {\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                for(int x=1; x<i; x++) {\\n                    dp[i][j][l] = (dp[i][j][l] + dp[x][j][l-1])%mod;\\n                }\\n                for(int y=1; y<j; y++) {\\n                    dp[i][j][l] = (dp[i][j][l] + dp[i][y][l-1])%mod;\\n                }\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", dp[n][m][k]);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace GameWays\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = { \\\"3 3 1\\\", \\\"4 4 1\\\", \\\"6 7 2\\\" };\n            string[] outputs = { \\\"1\\\", \\\"9\\\", \\\"75\\\" };\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                string[] input = inputs[i].Split(' ');\n                int n = int.Parse(input[0]);\n                int m = int.Parse(input[1]);\n                int k = int.Parse(input[2]);\n\n                int result = CountGameWays(n, m, k);\n                Console.WriteLine(result == int.Parse(outputs[i]) ? \\\"Test case passed\\\" : \\\"Test case failed\\\");\n            }\n        }\n\n        static int CountGameWays(int n, int m, int k)\n        {\n            const int MOD = 1000000007;\n            int[,] dp = new int[n + 1, m + 1];\n\n            for (int i = 1; i <= n; i++)\n            {\n                for (int j = 1; j <= m; j++)\n                {\n                    if (i * j <= k)\n                    {\n                        dp[i, j] = 1;\n                    }\n                    else\n                    {\n                        for (int x = 1; x < i; x++)\n                        {\n                            dp[i, j] = (dp[i, j] + dp[x, j] * dp[i - x, j]) % MOD;\n                        }\n\n                        for (int y = 1; y < j; y++)\n                        {\n                            dp[i, j] = (dp[i, j] + dp[i, y] * dp[i, j - y]) % MOD;\n                        }\n                    }\n                }\n            }\n\n            return dp[n, m];\n        }\n    }\n}\n","Ruby":"\nMOD = 1000000007\n\ndef count_ways(n, m, k)\n  dp = Array.new(n+1) { Array.new(m+1, 0) }\n  dp[0][0] = 1\n\n  (1..n).each do |i|\n    (1..m).each do |j|\n      dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD\n    end\n  end\n\n  result = dp[n][m]\n  result = (result ** k) % MOD\n\n  return result\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\nk = input[2].to_i\n\noutput = count_ways(n, m, k)\nputs output\n","delphi":"Here is the Delphi code to solve the problem:\n\nprogram GameWays;\n\nconst\n  MODULO = 1000000007;\n\nvar\n  n, m, k: Integer;\n\nfunction PowerMod(base, exponent: Integer): Integer;\nvar\n  result: Integer;\nbegin\n  result := 1;\n  while exponent > 0 do\n  begin\n    if exponent mod 2 = 1 then\n      result := (result * base) mod MODULO;\n    base := (base * base) mod MODULO;\n    exponent := exponent div 2;\n  end;\n  Result := result;\nend;\n\nfunction CalculateWays(n, m, k: Integer): Integer;\nvar\n  result: Integer;\nbegin\n  if k = 1 then\n    result := n * m\n  else\n    result := (PowerMod(n, k) + PowerMod(m, k) - 2 * PowerMod(n - 1, k) - 2 * PowerMod(m - 1, k) + 2 * PowerMod(n - 1, k) * PowerMod(m - 1, k)) mod MODULO;\n  if result < 0 then\n    result := result + MODULO;\n  Result := result;\nend;\n\nbegin\n  ReadLn(n, m, k);\n  WriteLn(CalculateWays(n, m, k));\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, k int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &k)\\n\\n\\t\/\/ Create a 2D slice to store the number of ways to play the game\\n\\tways := make([][]int, n+1)\\n\\tfor i := range ways {\\n\\t\\tways[i] = make([]int, m+1)\\n\\t}\\n\\n\\t\/\/ Initialize the base cases\\n\\tways[0][0] = 1\\n\\n\\t\/\/ Calculate the number of ways to play the game\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tfor j := 1; j <= m; j++ {\\n\\t\\t\\t\/\/ Calculate the number of ways to play the game using dynamic programming\\n\\t\\t\\tways[i][j] = (ways[i-1][j] + ways[i][j-1]) % 1000000007\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Print the number of ways to play the game\\n\\tfmt.Println(ways[n][m])\\n}","Javascript":"function countWays(n, m, k) {\n    const MOD = 1000000007;\n    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0));\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 2) % MOD;\n        }\n    }\n    \n    let ways = dp[n][m];\n    let totalWays = 1;\n    \n    for (let i = 1; i <= k; i++) {\n        totalWays = (totalWays * ways) % MOD;\n    }\n    \n    return totalWays;\n}\n\nlet input = '6 7 2\\n';\nlet [n, m, k] = input.trim().split(' ').map(Number);\nlet result = countWays(n, m, k);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val k = input[2].toInt()\n\n    val dp = Array(n + 1) { LongArray(m + 1) }\n    val mod = 1000000007\n\n    for (i in 1..n) {\n        for (j in 1..m) {\n            dp[i][j] = if (i == 1 && j == 1) 1 else (dp[i - 1][j] + dp[i][j - 1]) % mod\n        }\n    }\n\n    val result = dp[n][m].modPow(k.toLong(), mod.toLong()).toInt()\n    println(result)\n}","PHP":"<?php\\n\\nfunction countWays($n, $m, $k) {\\n    $dp = array_fill(0, $n+1, array_fill(0, $m+1, array_fill(0, $k+1, 0)));\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        for ($j = 1; $j <= $m; $j++) {\\n            $dp[$i][$j][0] = 1;\\n        }\\n    }\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        for ($j = 1; $j <= $m; $j++) {\\n            for ($l = 1; $l <= $k; $l++) {\\n                $dp[$i][$j][$l] = ($dp[$i-1][$j][$l] + $dp[$i][$j-1][$l] - $dp[$i-1][$j-1][$l] + $dp[$i-1][$j][$l-1] + $dp[$i][$j-1][$l-1] - $dp[$i-1][$j-1][$l-1] + 1000000007) % 1000000007;\\n            }\\n        }\\n    }\\n\\n    return $dp[$n][$m][$k];\\n}\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$m = intval($input[1]);\\n$k = intval($input[2]);\\n\\n$result = countWays($n, $m, $k);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, m, k;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &k);\\r\\n\\r\\n    int[][][] dp = new int[][][](n + 1, m + 1, k + 1);\\r\\n\\r\\n    for (int i = 1; i <= n; i++)\\r\\n    {\\r\\n        for (int j = 1; j <= m; j++)\\r\\n        {\\r\\n            dp[i][j][0] = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for (int i = 1; i <= n; i++)\\r\\n    {\\r\\n        for (int j = 1; j <= m; j++)\\r\\n        {\\r\\n            for (int l = 1; l <= k; l++)\\r\\n            {\\r\\n                dp[i][j][l] = (dp[i - 1][j][l - 1] + dp[i][j - 1][l - 1] + dp[i - 1][j - 1][l - 1]) % 1000000007;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(dp[n][m][k]);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_ways {\n    my ($n, $m, $k) = @_;\n\n    # Initialize the dynamic programming table\n    my @dp;\n    for my $i (0..$n) {\n        for my $j (0..$m) {\n            $dp[$i][$j][0] = 1;\n        }\n    }\n\n    # Calculate the number of ways to play the game\n    for my $moves (1..$k) {\n        for my $i (1..$n) {\n            for my $j (1..$m) {\n                $dp[$i][$j][$moves] = ($dp[$i-1][$j][$moves-1] + $dp[$i][$j-1][$moves-1] + $dp[$i-1][$j-1][$moves-1]) % 1000000007;\n            }\n        }\n    }\n\n    return $dp[$n][$m][$k];\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $k) = split ' ', $input;\n\n# Calculate and print the number of ways to play the game\nmy $result = count_ways($n, $m, $k);\nprint $result . \\\"\\\\n\\\";\n\n","Rust":"fn main() {\\n    let modulo = 1000000007;\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let input: Vec<usize> = input\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = input[0];\\n    let m = input[1];\\n    let k = input[2];\\n\\n    let mut dp = vec![vec![0; m + 1]; n + 1];\\n\\n    for i in 1..=n {\\n        for j in 1..=m {\\n            if i * j == 1 {\\n                dp[i][j] = 1;\\n            } else {\\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % modulo;\\n            }\\n        }\\n    }\\n\\n    let mut result = 0;\\n\\n    for i in 1..=n {\\n        for j in 1..=m {\\n            result = (result + dp[i][j] * dp[n - i + 1][m - j + 1]) % modulo;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", result);\\n}"}
{"title":"B. Students and Shoelaces","description":"Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.Determine how many groups of students will be kicked out of the club.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m \u2014 the initial number of students and laces (). The students are numbered from 1 to n, and the laces are numbered from 1 to m. Next m lines each contain two integers a and b \u2014 the numbers of students tied by the i-th lace (1\u2264a,b\u2264n,a\u2260b). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.\n","output_spec":"Print the single number \u2014 the number of groups of students that will be kicked out from the club.\n","notes":"In the first sample Anna and Maria won't kick out any group of students \u2014 in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.\nIn the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then \u2014 two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.\nIn the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.\n","sample_inputs":["3 3\n1 2\n2 3\n3 1\n","6 3\n1 2\n2 3\n3 4\n","6 5\n1 4\n2 4\n3 4\n5 4\n6 4\n"],"sample_outputs":["0\n","2\n","1\n"],"id":"129-B","difficulty":1200,"tags":["brute+force","dfs+and+similar","graphs","implementation"],"src_uid":"f8315dc903b0542c453cab4577bcb20d","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<int>> adj(n+1);\\n    vector<int> degree(n+1, 0);\\n    for (int i = 0; i < m; i++) {\\n        int a, b;\\n        cin >> a >> b;\\n        adj[a].push_back(b);\\n        adj[b].push_back(a);\\n        degree[a]++;\\n        degree[b]++;\\n    }\\n    queue<int> q;\\n    for (int i = 1; i <= n; i++) {\\n        if (degree[i] == 1) {\\n            q.push(i);\\n        }\\n    }\\n    int groups = 0;\\n    while (!q.empty()) {\\n        int size = q.size();\\n        groups++;\\n        for (int i = 0; i < size; i++) {\\n            int curr = q.front();\\n            q.pop();\\n            degree[curr]--;\\n            for (int j = 0; j < adj[curr].size(); j++) {\\n                int neighbor = adj[curr][j];\\n                if (degree[neighbor] > 0) {\\n                    degree[neighbor]--;\\n                    if (degree[neighbor] == 1) {\\n                        q.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    cout << groups << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class MathClub {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] input = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input[0]);\n        int m = Integer.parseInt(input[1]);\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            String[] lace = scanner.nextLine().split(\\\" \\\");\n            int a = Integer.parseInt(lace[0]);\n            int b = Integer.parseInt(lace[1]);\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n        \n        int groups = 0;\n        boolean[] visited = new boolean[n + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            if (!visited[i]) {\n                groups++;\n                dfs(graph, visited, i);\n            }\n        }\n        \n        System.out.println(groups - 1);\n    }\n    \n    private static void dfs(List<List<Integer>> graph, boolean[] visited, int node) {\n        visited[node] = true;\n        \n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(graph, visited, neighbor);\n            }\n        }\n    }\n}","Python":"def kick_out_students(n, m, laces):\n    students = [[] for _ in range(n+1)]\n    for a, b in laces:\n        students[a].append(b)\n        students[b].append(a)\n    \n    groups = 0\n    while True:\n        kicked_out = []\n        for i in range(1, n+1):\n            if len(students[i]) == 1:\n                kicked_out.append(i)\n        \n        if not kicked_out:\n            break\n        \n        groups += 1\n        for student in kicked_out:\n            neighbor = students[student][0]\n            students[student].remove(neighbor)\n            students[neighbor].remove(student)\n    \n    return str(groups)\n\ninputs = ['3 3\\\\n1 2\\\\n2 3\\\\n3 1\\\\n', '6 3\\\\n1 2\\\\n2 3\\\\n3 4\\\\n', '6 5\\\\n1 4\\\\n2 4\\\\n3 4\\\\n5 4\\\\n6 4\\\\n']\noutputs = []\nfor input_str in inputs:\n    input_lines = input_str.strip().split('\\\\n')\n    n, m = map(int, input_lines[0].split())\n    laces = [list(map(int, line.split())) for line in input_lines[1:]]\n    outputs.append(kick_out_students(n, m, laces))\n\noutputs = [o + '\\\\n' for o in outputs]\noutput","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int *students = (int *)malloc((n + 1) * sizeof(int));\\n    int *laces = (int *)malloc((m + 1) * sizeof(int));\\n    int *groups = (int *)malloc((n + 1) * sizeof(int));\\n    for (int i = 1; i <= n; i++) {\\n        students[i] = 0;\\n        groups[i] = 0;\\n    }\\n    for (int i = 1; i <= m; i++) {\\n        int a, b;\\n        scanf(\\\"%d %d\\\", &a, &b);\\n        students[a]++;\\n        students[b]++;\\n        laces[i] = a;\\n    }\\n    int kickedOut = 0;\\n    int flag = 1;\\n    while (flag) {\\n        flag = 0;\\n        for (int i = 1; i <= m; i++) {\\n            int a = laces[i];\\n            if (students[a] == 1) {\\n                students[a]--;\\n                students[laces[i]]--;\\n                groups[a] = 1;\\n                kickedOut++;\\n                flag = 1;\\n            }\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", kickedOut);\\n    free(students);\\n    free(laces);\\n    free(groups);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace MathClub\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n\n            List<int>[] graph = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                string laceInput = Console.ReadLine();\n                string[] laceArr = laceInput.Split(' ');\n                int a = int.Parse(laceArr[0]);\n                int b = int.Parse(laceArr[1]);\n\n                graph[a].Add(b);\n                graph[b].Add(a);\n            }\n\n            int groupsKickedOut = 0;\n            bool[] reprimanded = new bool[n + 1];\n\n            while (true)\n            {\n                bool reprimandedStudent = false;\n\n                for (int i = 1; i <= n; i++)\n                {\n                    if (!reprimanded[i])\n                    {\n                        if (graph[i].Count == 1)\n                        {\n                            reprimanded[i] = true;\n                            reprimandedStudent = true;\n                        }\n                    }\n                }\n\n                if (!reprimandedStudent)\n                {\n                    break;\n                }\n\n                groupsKickedOut++;\n\n                for (int i = 1; i <= n; i++)\n                {\n                    if (reprimanded[i])\n                    {\n                        foreach (int neighbor in graph[i])\n                        {\n                            graph[neighbor].Remove(i);\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(groupsKickedOut);\n        }\n    }\n}","Ruby":"\ndef kick_out_students(input)\n  # Parse input\n  lines = input.split('\\n')\n  n, m = lines[0].split(' ').map(&:to_i)\n  laces = lines[1..m].map { |line| line.split(' ').map(&:to_i) }\n\n  # Initialize variables\n  students = Array.new(n) { [] }\n  groups = 0\n\n  # Build adjacency list\n  laces.each do |a, b|\n    students[a-1] << b-1\n    students[b-1] << a-1\n  end\n\n  # Process students\n  while true\n    reprimanded = []\n    students.each_with_index do |ties, i|\n      if ties.length == 1\n        reprimanded << i\n        students[ties[0]].delete(i)\n      end\n    end\n\n    break if reprimanded.empty?\n\n    groups += 1\n    reprimanded.each { |student| students[student] = [] }\n  end\n\n  groups.to_s\nend\n\n# Test cases\ninputs = ['3 3\\n1 2\\n2 3\\n3 1\\n', '6 3\\n1 2\\n2 3\\n3 4\\n', '6 5\\n1 4\\n2 4\\n3 4\\n5 4\\n6 4\\n']\noutputs = ['0\\n', '2\\n', '1\\n']\n\nresults = []\ninputs.each_with_index do |input, i|\n  result = kick_out_students(input)\n  expected_output = outputs[i]\n  results << (result == expected_output)\nend\n\nresults.all? ? 'All test cases passed' : 'Some test cases failed'\n","delphi":"program MathClub;\n\nvar\n  n, m, i, j, a, b, count: integer;\n  students: array of integer;\n  laces: array of array of integer;\n  kickedOutGroups: integer;\n\nbegin\n  kickedOutGroups := 0;\n  \n  \/\/ Read input\n  readln(n, m);\n  \n  \/\/ Initialize arrays\n  SetLength(students, n + 1);\n  SetLength(laces, m);\n  \n  \/\/ Read laces\n  for i := 0 to m - 1 do\n  begin\n    readln(a, b);\n    laces[i] := [a, b];\n    Inc(students[a]);\n    Inc(students[b]);\n  end;\n  \n  \/\/ Find and kick out groups of students\n  repeat\n    count := 0;\n    \n    for i := 1 to n do\n    begin\n      if students[i] = 1 then\n      begin\n        Inc(count);\n        students[i] := 0;\n        \n        for j := 0 to m - 1 do\n        begin\n          if (laces[j] <> []) and (i in laces[j]) then\n          begin\n            a := laces[j][1];\n            b := laces[j][2];\n            \n            if a = i then\n              students[b] := students[b] - 1\n            else\n              students[a] := students[a] - 1;\n            \n            laces[j] := [];\n          end;\n        end;\n      end;\n    end;\n    \n    if count > 0 then\n      Inc(kickedOutGroups);\n  until count = 0;\n  \n  \/\/ Print the number of kicked out groups\n  writeln(kickedOutGroups);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := scanner.Text()\\n\\tn, _ := strconv.Atoi(string(nm[0]))\\n\\tm, _ := strconv.Atoi(string(nm[2]))\\n\\n\\tlaces := make([][]int, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tab := scanner.Text()\\n\\t\\ta, _ := strconv.Atoi(string(ab[0]))\\n\\t\\tb, _ := strconv.Atoi(string(ab[2]))\\n\\t\\tlaces[i] = []int{a, b}\\n\\t}\\n\\n\\tgroups := 0\\n\\n\\tfor len(laces) > 0 {\\n\\t\\treprimanded := make(map[int]bool)\\n\\n\\t\\tfor _, lace := range laces {\\n\\t\\t\\ta := lace[0]\\n\\t\\t\\tb := lace[1]\\n\\n\\t\\t\\tif reprimanded[a] || reprimanded[b] {\\n\\t\\t\\t\\treprimanded[a] = true\\n\\t\\t\\t\\treprimanded[b] = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif len(reprimanded) == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tgroups++\\n\\n\\t\\tnewLaces := make([][]int, 0)\\n\\n\\t\\tfor _, lace := range laces {\\n\\t\\t\\ta := lace[0]\\n\\t\\t\\tb := lace[1]\\n\\n\\t\\t\\tif !reprimanded[a] && !reprimanded[b] {\\n\\t\\t\\t\\tnewLaces = append(newLaces, lace)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlaces = newLaces\\n\\t}\\n\\n\\tfmt.Println(groups)\\n}","Javascript":"function kickOutStudents(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const laces = lines.slice(1, m + 1).map(line => line.split(' ').map(Number));\n  \n  const students = new Array(n + 1).fill(0);\n  const groups = [];\n  \n  for (let i = 0; i < m; i++) {\n    const [a, b] = laces[i];\n    students[a]++;\n    students[b]++;\n  }\n  \n  while (true) {\n    let kickedOut = false;\n    \n    for (let i = 1; i <= n; i++) {\n      if (students[i] === 1) {\n        kickedOut = true;\n        groups.push(i);\n        students[i] = 0;\n        \n        for (let j = 0; j < m; j++) {\n          const [a, b] = laces[j];\n          if (a === i) students[b]--;\n          if (b === i) students[a]--;\n        }\n      }\n    }\n    \n    if (!kickedOut) break;\n  }\n  \n  return groups.length.toString();\n}\n\nconst inputs = ['3 3\\\\n1 2\\\\n2 3\\\\n3 1\\\\n', '6 3\\\\n1 2\\\\n2 3\\\\n3 4\\\\n', '6 5\\\\n1 4\\\\n2 4\\\\n3 4\\\\n5 4\\\\n6 4\\\\n'];\nconst outputs = inputs.map(kickOutStudents);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    \n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    val visited = BooleanArray(n + 1)\n    \n    repeat(m) {\n        val (a, b) = readLine()!!.split(\" \").map { it.toInt() }\n        graph[a].add(b)\n        graph[b].add(a)\n    }\n    \n    var groups = 0\n    \n    for (i in 1..n) {\n        if (!visited[i]) {\n            val queue: Queue<Int> = LinkedList()\n            queue.add(i)\n            visited[i] = true\n            \n            while (queue.isNotEmpty()) {\n                val current = queue.poll()\n                \n                for (neighbor in graph[current]) {\n                    if (!visited[neighbor]) {\n                        queue.add(neighbor)\n                        visited[neighbor] = true\n                    }\n                }\n            }\n            \n            groups++\n        }\n    }\n    \n    println(groups - 1)\n}","PHP":"\n<?php\n\nfunction kickOutStudents($n, $m, $laces) {\n    $groups = 0;\n    $students = array_fill(1, $n, 0);\n    \n    foreach ($laces as $lace) {\n        $students[$lace[0]]++;\n        $students[$lace[1]]++;\n    }\n    \n    while (true) {\n        $reprimanded = false;\n        \n        foreach ($students as $student => $ties) {\n            if ($ties == 1) {\n                $reprimanded = true;\n                $students[$student] = 0;\n                \n                foreach ($laces as $key => $lace) {\n                    if ($lace[0] == $student || $lace[1] == $student) {\n                        unset($laces[$key]);\n                    }\n                }\n            }\n        }\n        \n        if (!$reprimanded) {\n            break;\n        }\n        \n        $groups++;\n    }\n    \n    return $groups;\n}\n\n$input = explode('\\n', '6 5\\n1 4\\n2 4\\n3 4\\n5 4\\n6 4\\n');\n$n = explode(' ', $input[0])[0];\n$m = explode(' ', $input[0])[1];\n$laces = array();\nfor ($i = 1; $i <= $m; $i++) {\n    $laces[] = explode(' ', $input[$i]);\n}\n\n$result = kickOutStudents($n, $m, $laces);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    auto students = new Array!int[](n + 1);\\r\\n    auto laces = new Array!int[](m + 1);\\r\\n\\r\\n    foreach (i; 1 .. m + 1)\\r\\n    {\\r\\n        int a, b;\\r\\n        readf(\\\"%d %d\\\", &a, &b);\\r\\n\\r\\n        students[a] += 1;\\r\\n        students[b] += 1;\\r\\n\\r\\n        laces[i] = a;\\r\\n    }\\r\\n\\r\\n    int groups = 0;\\r\\n\\r\\n    while (true)\\r\\n    {\\r\\n        auto kickedOut = new Array!int[]();\\r\\n\\r\\n        foreach (i; 1 .. n + 1)\\r\\n        {\\r\\n            if (students[i] == 1)\\r\\n            {\\r\\n                kickedOut ~= i;\\r\\n                students[i] = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (kickedOut.empty)\\r\\n            break;\\r\\n\\r\\n        groups += 1;\\r\\n\\r\\n        foreach (i; 1 .. m + 1)\\r\\n        {\\r\\n            if (laces[i] in kickedOut)\\r\\n            {\\r\\n                int a = laces[i];\\r\\n                int b = i;\\r\\n\\r\\n                students[a] -= 1;\\r\\n                students[b] -= 1;\\r\\n\\r\\n                laces[i] = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(groups);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub kick_out_students {\n    my ($n, $m, @laces) = @_;\n\n    my %students;\n    foreach my $i (1..$n) {\n        $students{$i} = [];\n    }\n\n    foreach my $lace (@laces) {\n        my ($a, $b) = split(' ', $lace);\n        push @{$students{$a}}, $b;\n        push @{$students{$b}}, $a;\n    }\n\n    my $groups_kicked_out = 0;\n    my @students_to_reprimand;\n\n    while (1) {\n        my @students_reprimanded;\n        foreach my $student (keys %students) {\n            if (@{$students{$student}} == 1) {\n                push @students_reprimanded, $student;\n            }\n        }\n\n        last if scalar @students_reprimanded == 0;\n\n        $groups_kicked_out++;\n        push @students_to_reprimand, @students_reprimanded;\n\n        foreach my $student (@students_reprimanded) {\n            my $tied_student = $students{$student}[0];\n            @{$students{$student}} = ();\n            @{$students{$tied_student}} = grep { $_ != $student } @{$students{$tied_student}};\n        }\n    }\n\n    return $groups_kicked_out;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split(' ', $input);\nmy @laces;\nforeach (1..$m) {\n    my $lace = <STDIN>;\n    chomp $lace;\n    push @laces, $lace;\n}\n\n# Call the function and print the result\nmy $result = kick_out_students($n, $m, @laces);\nprint $result;\n","Rust":"use std::collections::HashMap;\n\nfn main() {\n    let input = \"6 5\\n1 4\\n2 4\\n3 4\\n5 4\\n6 4\\n\";\n    let (n, m, laces) = parse_input(input);\n    let mut graph: HashMap<usize, Vec<usize>> = HashMap::new();\n    let mut reprimanded: Vec<usize> = Vec::new();\n    \n    for (a, b) in laces {\n        graph.entry(a).or_insert(Vec::new()).push(b);\n        graph.entry(b).or_insert(Vec::new()).push(a);\n    }\n    \n    while let Some(student) = find_single_tied_student(&graph) {\n        reprimanded.push(student);\n        graph.remove(&student);\n        for (_, neighbors) in graph.iter_mut() {\n            neighbors.retain(|&x| x != student);\n        }\n    }\n    \n    let num_groups = reprimanded.len();\n    println!(\"{}\", num_groups);\n}\n\nfn parse_input(input: &str) -> (usize, usize, Vec<(usize, usize)>) {\n    let mut lines = input.lines();\n    let first_line = lines.next().unwrap();\n    let mut nums = first_line.split_whitespace();\n    let n: usize = nums.next().unwrap().parse().unwrap();\n    let m: usize = nums.next().unwrap().parse().unwrap();\n    let laces: Vec<(usize, usize)> = lines\n        .map(|line| {\n            let mut nums = line.split_whitespace();\n            let a: usize = nums.next().unwrap().parse().unwrap();\n            let b: usize = nums.next().unwrap().parse().unwrap();\n            (a, b)\n        })\n        .collect();\n    (n, m, laces)\n}\n\nfn find_single_tied_student(graph: &HashMap<usize, Vec<usize>>) -> Option<usize> {\n    for (student, neighbors) in graph.iter() {\n        if neighbors.len() == 1 {\n            return Some(*student);\n        }\n    }\n    None\n}"}
{"title":"B. Correct Solution?","description":"One cold winter evening Alice and her older brother Bob was sitting at home near the fireplace and giving each other interesting problems to solve. When it was Alice's turn, she told the number n to Bob and said:\u2014Shuffle the digits in this number in order to obtain the smallest possible number without leading zeroes.\u2014No problem! \u2014 said Bob and immediately gave her an answer.Alice said a random number, so she doesn't know whether Bob's answer is correct. Help her to find this out, because impatient brother is waiting for the verdict.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains one integer n (0\u2264n\u226410^9) without leading zeroes. The second lines contains one integer m (0\u2264m\u226410^9) \u2014 Bob's answer, possibly with leading zeroes.\n","output_spec":"Print OK if Bob's answer is correct and WRONG_ANSWER otherwise.\n","notes":null,"sample_inputs":["3310\n1033\n","4\n5\n"],"sample_outputs":["OK\n","WRONG_ANSWER\n"],"id":"12-B","difficulty":1100,"tags":["implementation","sortings"],"src_uid":"d1e381b72a6c09a0723cfe72c0917372","C++":"#include <iostream>\\n#include <algorithm>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    string n, m;\\n    cin >> n >> m;\\n    sort(n.begin(), n.end());\\n    if (n[0] == '0') {\\n        for (int i = 1; i < n.size(); i++) {\\n            if (n[i] != '0') {\\n                swap(n[0], n[i]);\\n                break;\\n            }\\n        }\\n    }\\n    if (n == m) {\\n        cout << \\\"OK\\\" << endl;\\n    } else {\\n        cout << \\\"WRONG_ANSWER\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Arrays;\\nimport java.util.Scanner;\\n\\npublic class ShuffleDigits {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        scanner.close();\\n\\n        String nString = String.valueOf(n);\\n        String mString = String.valueOf(m);\\n\\n        char[] nDigits = nString.toCharArray();\\n        char[] mDigits = mString.toCharArray();\\n\\n        Arrays.sort(nDigits);\\n\\n        if (nDigits[0] == '0') {\\n            for (int i = 1; i < nDigits.length; i++) {\\n                if (nDigits[i] != '0') {\\n                    char temp = nDigits[0];\\n                    nDigits[0] = nDigits[i];\\n                    nDigits[i] = temp;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        String sortedN = new String(nDigits);\\n\\n        if (sortedN.equals(mString)) {\\n            System.out.println(\\\"OK\\\");\\n        } else {\\n            System.out.println(\\\"WRONG_ANSWER\\\");\\n        }\\n    }\\n}","Python":"def check_answer(n, m):\n    n = str(n)\n    m = str(m)\n    sorted_n = ''.join(sorted(n))\n    if sorted_n == m:\n        return 'OK'\n    else:\n        return 'WRONG_ANSWER'\n\nn = int(input())\nm = int(input())\nresult = check_answer(n, m)\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint compare(const void *a, const void *b) {\\n    return (*(char*)a - *(char*)b);\\n}\\n\\nint main() {\\n    char n[11];\\n    char m[11];\\n    scanf(\\\"%s\\\", n);\\n    scanf(\\\"%s\\\", m);\\n    int len_n = strlen(n);\\n    int len_m = strlen(m);\\n    qsort(n, len_n, sizeof(char), compare);\\n    if (n[0] == '0') {\\n        for (int i = 1; i < len_n; i++) {\\n            if (n[i] != '0') {\\n                char temp = n[0];\\n                n[0] = n[i];\\n                n[i] = temp;\\n                break;\\n            }\\n        }\\n    }\\n    if (strcmp(n, m) == 0) {\\n        printf(\\\"OK\\\\n\\\");\\n    } else {\\n        printf(\\\"WRONG_ANSWER\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string n = Console.ReadLine();\n        string m = Console.ReadLine();\n\n        string sortedN = SortDigits(n);\n\n        if (sortedN == m)\n        {\n            Console.WriteLine(\\\"OK\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"WRONG_ANSWER\\\");\n        }\n    }\n\n    static string SortDigits(string number)\n    {\n        char[] digits = number.ToCharArray();\n        Array.Sort(digits);\n        return new string(digits).TrimStart('0');\n    }\n}","Ruby":"\ndef shuffle_digits(n, m)\n  n_digits = n.to_s.chars.sort.join.to_i\n  m_digits = m.to_s.chars.sort.join.to_i\n  \n  if n_digits == m_digits\n    return 'OK'\n  else\n    return 'WRONG_ANSWER'\n  end\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nm = input[1].to_i\n\nputs shuffle_digits(n, m)\n","delphi":"program ShuffleDigits;\\n\\nvar\\n  n, m, nSorted, mSorted: Integer;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(n);\\n  ReadLn(m);\\n\\n  \/\/ Sort the digits of n and m in ascending order\\n  nSorted := 0;\\n  mSorted := 0;\\n\\n  while n > 0 do\\n  begin\\n    nSorted := nSorted * 10 + n mod 10;\\n    n := n div 10;\\n  end;\\n\\n  while m > 0 do\\n  begin\\n    mSorted := mSorted * 10 + m mod 10;\\n    m := m div 10;\\n  end;\\n\\n  \/\/ Check if Bob's answer is correct\\n  if nSorted = mSorted then\\n    WriteLn('OK')\\n  else\\n    WriteLn('WRONG_ANSWER');\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scan(&n)\\n\\tfmt.Scan(&m)\\n\\n\\tnStr := strconv.Itoa(n)\\n\\tmStr := strconv.Itoa(m)\\n\\n\\tnDigits := make([]int, len(nStr))\\n\\tmDigits := make([]int, len(mStr))\\n\\n\\tfor i, digit := range nStr {\\n\\t\\tnDigits[i], _ = strconv.Atoi(string(digit))\\n\\t}\\n\\n\\tfor i, digit := range mStr {\\n\\t\\tmDigits[i], _ = strconv.Atoi(string(digit))\\n\\t}\\n\\n\\tsort.Ints(nDigits)\\n\\n\\tif nDigits[0] == 0 {\\n\\t\\tfor i := 1; i < len(nDigits); i++ {\\n\\t\\t\\tif nDigits[i] != 0 {\\n\\t\\t\\t\\tnDigits[0], nDigits[i] = nDigits[i], nDigits[0]\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tsortedNStr := \\\"\\\"\\n\\tfor _, digit := range nDigits {\\n\\t\\tsortedNStr += strconv.Itoa(digit)\\n\\t}\\n\\n\\tif sortedNStr == mStr {\\n\\t\\tfmt.Println(\\\"OK\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"WRONG_ANSWER\\\")\\n\\t}\\n}","Javascript":"function checkAnswer(n, m) {\n  \/\/ Convert the numbers to strings\n  let nStr = n.toString();\n  let mStr = m.toString();\n\n  \/\/ Sort the digits in ascending order\n  let sortedN = nStr.split('').sort().join('');\n  let sortedM = mStr.split('').sort().join('');\n\n  \/\/ Check if the sorted numbers are equal\n  if (sortedN === sortedM) {\n    return 'OK';\n  } else {\n    return 'WRONG_ANSWER';\n  }\n}\n\n\/\/ Test the function with the sample inputs\nconsole.log(checkAnswer(3310, 1033)); \/\/ Output: OK\nconsole.log(checkAnswer(4, 5)); \/\/ Output: WRONG_ANSWER","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextLine()\n    val m = scanner.nextLine()\n    \n    val sortedN = n.toCharArray().sorted().joinToString(\"\").trimStart('0')\n    val sortedM = m.toCharArray().sorted().joinToString(\"\").trimStart('0')\n    \n    if (sortedN == sortedM) {\n        println(\\\"OK\\\")\n    } else {\n        println(\\\"WRONG_ANSWER\\\")\n    }\n}","PHP":"<?php\\n\\n\/\/ Read input from stdin\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n\\n\/\/ Extract the numbers from the input\\n$n = intval($input[0]);\\n$m = intval($input[1]);\\n\\n\/\/ Convert the numbers to strings\\n$n_str = strval($n);\\n$m_str = strval($m);\\n\\n\/\/ Sort the digits in ascending order\\nsort($n_str);\\n\\n\/\/ Remove leading zeroes from the sorted number\\n$n_str = ltrim($n_str, '0');\\n\\n\/\/ Convert the sorted number back to integer\\n$sorted_n = intval($n_str);\\n\\n\/\/ Check if Bob's answer is correct\\nif ($sorted_n == $m) {\\n    echo \\\"OK\\\\n\\\";\\n} else {\\n    echo \\\"WRONG_ANSWER\\\\n\\\";\\n}\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    readf(\\\"%d\\\", &m);\\r\\n\\r\\n    auto nDigits = n.to!string;\\r\\n    auto mDigits = m.to!string;\\r\\n\\r\\n    sort(nDigits);\\r\\n\\r\\n    if (nDigits == mDigits)\\r\\n    {\\r\\n        writeln(\\\"OK\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"WRONG_ANSWER\\\");\\r\\n    }\\r\\n}","perl":"\n# Read input values\nmy $n = <STDIN>;\nmy $m = <STDIN>;\n\n# Remove leading zeroes from both numbers\n$n =~ s\/^0+\/\/;\n$m =~ s\/^0+\/\/;\n\n# Sort the digits of $n in ascending order\nmy @digits = split('', $n);\n@digits = sort { $a <=> $b } @digits;\n$n = join('', @digits);\n\n# Print the verdict\nif ($n eq $m) {\n    print 'OK\\n';\n} else {\n    print 'WRONG_ANSWER\\n';\n}\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let mut lines = input.lines();\n    let n: u32 = lines.next().unwrap().trim().parse().unwrap();\n    let m: u32 = lines.next().unwrap().trim().parse().unwrap();\n    \n    let mut n_digits: Vec<u32> = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect();\n    n_digits.sort();\n    \n    let mut m_digits: Vec<u32> = m.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect();\n    m_digits.sort();\n    \n    let n_min: u32 = n_digits.iter().fold(0, |acc, &digit| acc * 10 + digit);\n    let m_min: u32 = m_digits.iter().fold(0, |acc, &digit| acc * 10 + digit);\n    \n    if n_min == m_min {\n        println!(\"OK\");\n    } else {\n        println!(\"WRONG_ANSWER\");\n    }\n}"}
{"title":"A. cAPS lOCK","description":"wHAT DO WE NEED cAPS LOCK FOR?Caps lock is a computer keyboard key. Pressing it sets an input mode in which typed letters are capital by default. If it is pressed by accident, it leads to accidents like the one we had in the first passage. Let's consider that a word has been typed with the Caps lock key accidentally switched on, if:   either it only contains uppercase letters;  or all letters except for the first one are uppercase. In this case we should automatically change the case of all letters. For example, the case of the letters that form words \"hELLO\", \"HTTP\", \"z\" should be changed.Write a program that applies the rule mentioned above. If the rule cannot be applied, the program should leave the word unchanged.","input_from":"standard input","output_to":"standard output","time_limit":"0.5 second","memory_limit":"256 megabytes","input_spec":"The first line of the input data contains a word consisting of uppercase and lowercase Latin letters. The word's length is from 1 to 100 characters, inclusive.\n","output_spec":"Print the result of the given word's processing.\n","notes":null,"sample_inputs":["cAPS\n","Lock\n"],"sample_outputs":["Caps","Lock\n"],"id":"131-A","difficulty":1000,"tags":["implementation","strings"],"src_uid":"db0eb44d8cd8f293da407ba3adee10cf","C++":"#include <iostream>\\n#include <string>\\n#include <cctype>\\n\\nstd::string processWord(std::string word) {\\n    bool allUppercase = true;\\n    bool firstLowercase = false;\\n\\n    for (int i = 0; i < word.length(); i++) {\\n        if (islower(word[i])) {\\n            allUppercase = false;\\n            if (i == 0) {\\n                firstLowercase = true;\\n            }\\n        }\\n    }\\n\\n    if (allUppercase || firstLowercase) {\\n        for (int i = 0; i < word.length(); i++) {\\n            if (islower(word[i])) {\\n                word[i] = toupper(word[i]);\\n            }\\n            else {\\n                word[i] = tolower(word[i]);\\n            }\\n        }\\n    }\\n\\n    return word;\\n}\\n\\nint main() {\\n    std::string word;\\n    std::getline(std::cin, word);\\n\\n    std::cout << processWord(word) << std::endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class CapsLock {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String word = scanner.nextLine();\\n        String result = processWord(word);\\n        System.out.println(result);\\n    }\\n\\n    public static String processWord(String word) {\\n        if (word.length() == 1) {\\n            return word;\\n        }\\n\\n        boolean allUppercase = word.toUpperCase().equals(word);\\n        boolean firstLowercase = Character.isLowerCase(word.charAt(0));\\n        boolean restUppercase = word.substring(1).toUpperCase().equals(word.substring(1));\\n\\n        if (allUppercase || (firstLowercase && restUppercase)) {\\n            return word.toLowerCase();\\n        }\\n\\n        return word;\\n    }\\n}\"}}","Python":"def apply_caps_lock_rule(word):\\n    if word.isupper() or word[1:].isupper():\\n        return word.lower()\\n    else:\\n        return word\\n\\nword = input().strip()\\nresult = apply_caps_lock_rule(word)\\nprint(result)","C":"#include <stdio.h>\\n#include <string.h>\\n#include <ctype.h>\\n\\nvoid changeCase(char* word) {\\n    int length = strlen(word);\\n    int i;\\n    int allUppercase = 1;\\n\\n    \/\/ Check if all letters are uppercase\\n    for (i = 0; i < length; i++) {\\n        if (!isupper(word[i])) {\\n            allUppercase = 0;\\n            break;\\n        }\\n    }\\n\\n    \/\/ If all letters are uppercase or all except the first one are uppercase, change the case\\n    if (allUppercase || (length > 1 && isupper(word[0]) && isupper(word[1]))) {\\n        for (i = 0; i < length; i++) {\\n            if (isupper(word[i])) {\\n                word[i] = tolower(word[i]);\\n            } else {\\n                word[i] = toupper(word[i]);\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    char word[101];\\n    fgets(word, sizeof(word), stdin);\\n    word[strcspn(word, \\\"\\\\n\\\")] = 0; \/\/ Remove newline character\\n\\n    changeCase(word);\\n    printf(\\\"%s\\\\n\\\", word);\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string word = Console.ReadLine().Trim();\n\n        if (IsCapsLockAccidental(word))\n        {\n            Console.WriteLine(ChangeCase(word));\n        }\n        else\n        {\n            Console.WriteLine(word);\n        }\n    }\n\n    static bool IsCapsLockAccidental(string word)\n    {\n        if (word.Length == 1)\n        {\n            return char.IsLower(word[0]);\n        }\n        else\n        {\n            bool allUppercase = true;\n            bool firstLowercase = char.IsLower(word[0]);\n\n            for (int i = 1; i < word.Length; i++)\n            {\n                if (char.IsLower(word[i]))\n                {\n                    allUppercase = false;\n                    break;\n                }\n            }\n\n            return allUppercase || firstLowercase;\n        }\n    }\n\n    static string ChangeCase(string word)\n    {\n        char[] chars = word.ToCharArray();\n\n        for (int i = 0; i < chars.Length; i++)\n        {\n            if (char.IsLower(chars[i]))\n            {\n                chars[i] = char.ToUpper(chars[i]);\n            }\n            else\n            {\n                chars[i] = char.ToLower(chars[i]);\n            }\n        }\n\n        return new string(chars);\n    }\n}","Ruby":"def caps_lock(word)\\n  if word == word.upcase || word[1..-1] == word[1..-1].upcase\\n    word.downcase\\n  else\\n    word\\n  end\\nend\\n\\ninput = gets.chomp\\nputs caps_lock(input)","delphi":"program CapsLock;\n\nuses\n  SysUtils;\n\nfunction ApplyCapsLockRule(word: string): string;\nvar\n  i: Integer;\nbegin\n  \/\/ Check if the word only contains uppercase letters\n  if UpperCase(word) = word then\n  begin\n    Result := LowerCase(word);\n    Exit;\n  end;\n\n  \/\/ Check if all letters except for the first one are uppercase\n  if Length(word) > 1 then\n  begin\n    for i := 2 to Length(word) do\n    begin\n      if not (UpperCase(word[i]) = word[i]) then\n      begin\n        Result := word;\n        Exit;\n      end;\n    end;\n    Result := LowerCase(word);\n    Exit;\n  end;\n\n  Result := word;\nend;\n\nvar\n  inputWord: string;\nbegin\n  \/\/ Read the input word\n  ReadLn(inputWord);\n\n  \/\/ Apply the Caps Lock rule\n  inputWord := ApplyCapsLockRule(inputWord);\n\n  \/\/ Print the result\n  WriteLn(inputWord);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tword := scanner.Text()\\n\\n\\tif len(word) == 1 {\\n\\t\\tfmt.Println(word)\\n\\t\\treturn\\n\\t}\\n\\n\\tif strings.ToUpper(word) == word {\\n\\t\\tfmt.Println(strings.ToLower(word))\\n\\t\\treturn\\n\\t}\\n\\n\\tif strings.ToLower(word[1:]) == word[1:] {\\n\\t\\tfmt.Println(strings.Title(strings.ToLower(word)))\\n\\t\\treturn\\n\\t}\\n\\n\\tfmt.Println(word)\\n}","Javascript":"function applyCapsLockRule(word) {\n  if (word === word.toUpperCase() || word.slice(1) === word.slice(1).toUpperCase()) {\n    return word.toLowerCase();\n  } else {\n    return word;\n  }\n}\n\nconst input = ['cAPS\\n', 'Lock\\n'];\nconst output = [];\n\nfor (let i = 0; i < input.length; i++) {\n  const processedWord = applyCapsLockRule(input[i].trim());\n  output.push(processedWord);\n}\n\nJSON.stringify(output);","Kotlin":"fun main() {\\n    val word = readLine()!!\\n    val result = if (word == word.toUpperCase() || word.substring(1) == word.substring(1).toUpperCase()) {\\n        word.toLowerCase()\\n    } else {\\n        word\\n    }\\n    println(result)\\n}","PHP":"<?php\\n\\n$input = trim(fgets(STDIN));\\n\\nif (ctype_upper($input) || (ctype_upper(substr($input, 1)) && ctype_lower(substr($input, 0, 1))))) {\\n    echo strtolower($input);\\n} else {\\n    echo $input;\\n}\\n","d":"import std.stdio;\\r\\nimport std.string;\\r\\n\\r\\nstring applyCapsLockRule(string word) {\\r\\n    bool allUppercase = true;\\r\\n    bool firstLowercase = false;\\r\\n    \\r\\n    foreach (char c; word) {\\r\\n        if (isLower(c)) {\\r\\n            allUppercase = false;\\r\\n        }\\r\\n        if (isUpper(c) && c != word[0]) {\\r\\n            firstLowercase = true;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    if (allUppercase || firstLowercase) {\\r\\n        return word.toLower;\\r\\n    }\\r\\n    \\r\\n    return word;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    string word = readln.chomp;\\r\\n    string processedWord = applyCapsLockRule(word);\\r\\n    writeln(processedWord);\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub apply_caps_lock_rule {\n    my ($word) = @_;\n    \n    if ($word =~ \/^[A-Z]+$\/) {\n        return lc($word);\n    }\n    \n    if ($word =~ \/^[A-Z][a-z]+$\/) {\n        return ucfirst(lc($word));\n    }\n    \n    return $word;\n}\n\nmy $input = <STDIN>;\nchomp($input);\n\nmy $result = apply_caps_lock_rule($input);\nprint $result;\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    if let Some(Ok(word)) = lines.next() {\n        let mut chars: Vec<char> = word.chars().collect();\n\n        if chars.iter().all(|&c| c.is_uppercase()) || (chars[0].is_uppercase() && chars[1..].iter().all(|&c| c.is_uppercase())) {\n            chars.iter_mut().for_each(|c| {\n                if c.is_uppercase() {\n                    *c = c.to_lowercase().next().unwrap();\n                } else {\n                    *c = c.to_uppercase().next().unwrap();\n                }\n            });\n        }\n\n        let result: String = chars.into_iter().collect();\n        println!(\"{}\", result);\n    }\n}"}
{"title":"C. The World is a Theatre","description":"There are n boys and m girls attending a theatre club. To set a play \"The Big Bang Theory\", they need to choose a group containing exactly t actors containing no less than 4 boys and no less than one girl. How many ways are there to choose a group? Of course, the variants that only differ in the composition of the troupe are considered different.Perform all calculations in the 64-bit type: long long for \u0421\/\u0421++, int64 for Delphi and long for Java.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line of the input data contains three integers n, m, t (4\u2264n\u226430,1\u2264m\u226430,5\u2264t\u2264n+m).\n","output_spec":"Find the required number of ways.\nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n","notes":null,"sample_inputs":["5 2 5\n","4 3 5\n"],"sample_outputs":["10\n","3\n"],"id":"131-C","difficulty":1400,"tags":["combinatorics","math"],"src_uid":"489e69c7a2fba5fac34e89d7388ed4b8","C++":"#include <iostream>\\n\\nusing namespace std;\\n\\nlong long chooseGroup(int n, int m, int t) {\\n    long long ways = 0;\\n    for (int boys = 4; boys <= n; boys++) {\\n        for (int girls = 1; girls <= m; girls++) {\\n            if (boys + girls == t) {\\n                ways++;\\n            }\\n        }\\n    }\\n    return ways;\\n}\\n\\nint main() {\\n    int n, m, t;\\n    cin >> n >> m >> t;\\n    long long result = chooseGroup(n, m, t);\\n    cout << result << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class TheatreClub {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int t = scanner.nextInt();\\n\\n        long ways = chooseGroup(n, m, t);\\n\\n        System.out.println(ways);\\n    }\\n\\n    public static long chooseGroup(int n, int m, int t) {\\n        long[][] dp = new long[n + 1][t + 1];\\n\\n        for (int i = 4; i <= n; i++) {\\n            dp[i][i] = 1;\\n        }\\n\\n        for (int i = 5; i <= n; i++) {\\n            for (int j = 1; j <= t; j++) {\\n                for (int k = 1; k <= Math.min(j, m); k++) {\\n                    dp[i][j] += dp[i - 1][j - k];\\n                }\\n            }\\n        }\\n\\n        long ways = 0;\\n        for (int i = 4; i <= n; i++) {\\n            ways += dp[i][t];\\n        }\\n\\n        return ways;\\n    }\\n}\" }","Python":"def choose_group(n, m, t):\n    count = 0\n    for boys in range(4, n+1):\n        for girls in range(1, m+1):\n            if boys + girls == t:\n                count += 1\n    return count\n\nn, m, t = map(int, input().split())\nresult = choose_group(n, m, t)\nprint(result)","C":"#include <stdio.h>\\n\\nlong long chooseGroup(int n, int m, int t) {\\n    long long ways = 0;\\n    for (int boys = 4; boys <= n; boys++) {\\n        for (int girls = 1; girls <= m; girls++) {\\n            if (boys + girls == t) {\\n                ways++;\\n            }\\n        }\\n    }\\n    return ways;\\n}\\n\\nint main() {\\n    int n, m, t;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &t);\\n    long long result = chooseGroup(n, m, t);\\n    printf(\\\"%lld\\\\n\\\", result);\\n    return 0;\\n}","C#":"using System;\n\nnamespace TheatreClub\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n            int t = int.Parse(input[2]);\n\n            long ways = CalculateWays(n, m, t);\n            Console.WriteLine(ways);\n        }\n\n        static long CalculateWays(int n, int m, int t)\n        {\n            long[,] dp = new long[n + 1, t + 1];\n\n            for (int i = 4; i <= n; i++)\n            {\n                dp[i, i] = 1;\n            }\n\n            for (int i = 5; i <= n; i++)\n            {\n                for (int j = 1; j <= t; j++)\n                {\n                    for (int k = 1; k <= Math.Min(j, m); k++)\n                    {\n                        dp[i, j] += dp[i - 1, j - k];\n                    }\n                }\n            }\n\n            long ways = 0;\n            for (int i = 4; i <= n; i++)\n            {\n                ways += dp[i, t];\n            }\n\n            return ways;\n        }\n    }\n}","Ruby":"\ndef choose_group(n, m, t)\n  count = 0\n  for boys in 4..(t-1)\n    girls = t - boys\n    if boys <= n && girls <= m\n      count += nCr(n, boys) * nCr(m, girls)\n    end\n  end\n  return count\nend\n\ndef nCr(n, r)\n  return factorial(n) \/ (factorial(r) * factorial(n - r))\nend\n\ndef factorial(n)\n  result = 1\n  for i in 1..n\n    result *= i\n  end\n  return result\nend\n\ninput = gets.chomp.split(' ').map(&:to_i)\nn = input[0]\nm = input[1]\nt = input[2]\n\nresult = choose_group(n, m, t)\nputs result\n","delphi":"var\n  n, m, t: Integer;\n  ways: Int64;\nbegin\n  Readln(n, m, t);\n  \n  ways := 0;\n  \n  \/\/ Iterate through all possible combinations of boys and girls\n  for var boys := 4 to n do\n  begin\n    for var girls := 1 to m do\n    begin\n      \/\/ Check if the total number of actors is equal to t\n      if (boys + girls = t) then\n      begin\n        \/\/ Calculate the number of ways to choose the group\n        ways := ways + (nCr(n, boys) * nCr(m, girls));\n      end;\n    end;\n  end;\n  \n  \/\/ Output the result\n  Writeln(ways);\nend;\n\nfunction nCr(n, r: Integer): Int64;\nbegin\n  \/\/ Calculate the binomial coefficient using dynamic programming\n  var dp: array of array of Int64;\n  SetLength(dp, n + 1, r + 1);\n  \n  for var i := 0 to n do\n  begin\n    for var j := 0 to Min(i, r) do\n    begin\n      if (j = 0) or (j = i) then\n        dp[i, j] := 1\n      else\n        dp[i, j] := dp[i - 1, j - 1] + dp[i - 1, j];\n    end;\n  end;\n  \n  Result := dp[n, r];\nend","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, t int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &t)\\n\\n\\tcount := 0\\n\\n\\tfor i := 4; i <= n; i++ {\\n\\t\\tfor j := 1; j <= m; j++ {\\n\\t\\t\\tif i+j == t {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function chooseGroup(n, m, t) {\n    let ways = 0;\n    \n    for (let boys = 4; boys <= n; boys++) {\n        for (let girls = 1; girls <= m; girls++) {\n            if (boys + girls === t) {\n                ways++;\n            }\n        }\n    }\n    \n    return ways;\n}\n\nconst input = '5 2 5\\n';\nconst [n, m, t] = input.trim().split(' ').map(Number);\n\nconst result = chooseGroup(n, m, t);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val t = input[2].toInt()\n\n    val result = chooseGroup(n, m, t)\n    println(result)\n}\n\nfun chooseGroup(n: Int, m: Int, t: Int): Long {\n    var count: Long = 0\n\n    for (boys in 4..n) {\n        for (girls in 1..m) {\n            if (boys + girls == t) {\n                count++\n            }\n        }\n    }\n\n    return count\n} }","PHP":"<?php\\n\\nfunction chooseGroup($n, $m, $t) {\\n    $ways = 0;\\n\\n    \/\/ Iterate through all possible combinations of boys and girls\\n    for ($boys = 4; $boys <= $n; $boys++) {\\n        for ($girls = 1; $girls <= $m; $girls++) {\\n            \/\/ Check if the total number of actors is equal to t\\n            if ($boys + $girls == $t) {\\n                \/\/ Calculate the number of ways to choose the group\\n                $boysWays = factorial($n) \/ (factorial($boys) * factorial($n - $boys));\\n                $girlsWays = factorial($m) \/ (factorial($girls) * factorial($m - $girls));\\n                $ways += $boysWays * $girlsWays;\\n            }\\n        }\\n    }\\n\\n    return $ways;\\n}\\n\\nfunction factorial($n) {\\n    $result = 1;\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $result *= $i;\\n    }\\n\\n    return $result;\\n}\\n\\n\/\/ Read input\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$m = intval($input[1]);\\n$t = intval($input[2]);\\n\\n\/\/ Calculate and print the number of ways to choose the group\\necho chooseGroup($n, $m, $t);\\n?>","d":"import std.stdio;\\r\\n\\r\\nlong long chooseGroup(int n, int m, int t)\\r\\n{\\r\\n    long long ways = 0;\\r\\n    for (int boys = 4; boys <= n; boys++)\\r\\n    {\\r\\n        for (int girls = 1; girls <= m; girls++)\\r\\n        {\\r\\n            if (boys + girls == t)\\r\\n            {\\r\\n                ways++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return ways;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, t;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &t);\\r\\n    long long result = chooseGroup(n, m, t);\\r\\n    writef(\\\"%lld\\\\n\\\", result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub choose_group {\n    my ($n, $m, $t) = @_;\n\n    my $ways = 0;\n\n    for my $boys (4..$n) {\n        for my $girls (1..$m) {\n            if ($boys + $girls == $t) {\n                $ways++;\n            }\n        }\n    }\n\n    return $ways;\n}\n\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $t) = split ' ', $input;\n\nmy $result = choose_group($n, $m, $t);\nprint $result;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut nums = input.trim().split_whitespace().map(|x| x.parse::<i64>().unwrap());\n    let n = nums.next().unwrap();\n    let m = nums.next().unwrap();\n    let t = nums.next().unwrap();\n\n    let mut count = 0;\n    for boys in 4..=n {\n        for girls in 1..=m {\n            if boys + girls == t {\n                count += combination(n, boys) * combination(m, girls);\n            }\n        }\n    }\n\n    println!(\"{}\", count);\n}\n\nfn combination(n: i64, k: i64) -> i64 {\n    let mut result = 1;\n    for i in 0..k {\n        result *= n - i;\n        result \/= i + 1;\n    }\n    result\n}"}
{"title":"B. Piet","description":"Piet is one of the most known visual esoteric programming languages. The programs in Piet are constructed from colorful blocks of pixels and interpreted using pretty complicated rules. In this problem we will use a subset of Piet language with simplified rules.The program will be a rectangular image consisting of colored and black pixels. The color of each pixel will be given by an integer number between 0 and 9, inclusive, with 0 denoting black. A block of pixels is defined as a rectangle of pixels of the same color (not black). It is guaranteed that all connected groups of colored pixels of the same color will form rectangular blocks. Groups of black pixels can form arbitrary shapes.The program is interpreted using movement of instruction pointer (IP) which consists of three parts: current block pointer (BP); note that there is no concept of current pixel within the block; direction pointer (DP) which can point left, right, up or down; block chooser (CP) which can point to the left or to the right from the direction given by DP; in absolute values CP can differ from DP by 90 degrees counterclockwise or clockwise, respectively.Initially BP points to the block which contains the top-left corner of the program, DP points to the right, and CP points to the left (see the orange square on the image below).One step of program interpretation changes the state of IP in a following way. The interpreter finds the furthest edge of the current color block in the direction of the DP. From all pixels that form this edge, the interpreter selects the furthest one in the direction of CP. After this, BP attempts to move from this pixel into the next one in the direction of DP. If the next pixel belongs to a colored block, this block becomes the current one, and two other parts of IP stay the same. It the next pixel is black or outside of the program, BP stays the same but two other parts of IP change. If CP was pointing to the left, now it points to the right, and DP stays the same. If CP was pointing to the right, now it points to the left, and DP is rotated 90 degrees clockwise.This way BP will never point to a black block (it is guaranteed that top-left pixel of the program will not be black).You are given a Piet program. You have to figure out which block of the program will be current after n steps.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input contains two integer numbers m (1\u2264m\u226450) and n (1\u2264n\u22645\u00b710^7). Next m lines contain the rows of the program. All the lines have the same length between 1 and 50 pixels, and consist of characters 0-9. The first character of the first line will not be equal to 0.\n","output_spec":"Output the color of the block which will be current after n steps of program interpretation.\n","notes":"In the first example IP changes in the following way. After step 1 block 2 becomes current one and stays it after two more steps. After step 4 BP moves to block 3, after step 7 \u2014 to block 4, and finally after step 10 BP returns to block 1.\n \nThe sequence of states of IP is shown on the image: the arrows are traversed clockwise, the main arrow shows direction of DP, the side one \u2014 the direction of CP.\n","sample_inputs":["2 10\n12\n43\n","3 12\n1423\n6624\n6625\n","5 9\n10345\n23456\n34567\n45678\n56789\n"],"sample_outputs":["1\n","6\n","5\n"],"id":"132-B","difficulty":2100,"tags":["implementation"],"src_uid":"09249ddeefb69734c50f9df3222ec7cb","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nstruct Block {\\n    int color;\\n    int top, left, bottom, right;\\n};\\n\\nint main() {\\n    int m, n;\\n    cin >> m >> n;\\n    vector<string> program(m);\\n    for (int i = 0; i < m; i++) {\\n        cin >> program[i];\\n    }\\n\\n    vector<Block> blocks;\\n    vector<vector<int>> visited(m, vector<int>(n, 0));\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (visited[i][j] == 0 && program[i][j] != '0') {\\n                Block block;\\n                block.color = program[i][j] - '0';\\n                block.top = i;\\n                block.left = j;\\n                block.bottom = i;\\n                block.right = j;\\n\\n                visited[i][j] = 1;\\n\\n                for (int k = i; k < m; k++) {\\n                    if (program[k][j] == program[i][j]) {\\n                        block.bottom = k;\\n                        visited[k][j] = 1;\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                }\\n\\n                for (int k = j; k < n; k++) {\\n                    if (program[i][k] == program[i][j]) {\\n                        block.right = k;\\n                        visited[i][k] = 1;\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                }\\n\\n                blocks.push_back(block);\\n            }\\n        }\\n    }\\n\\n    int currentBlock = 0;\\n    int steps = 0;\\n    int direction = 0;\\n    int blockChooser = 1;\\n\\n    while (steps < n) {\\n        Block& current = blocks[currentBlock];\\n        int nextBlock = -1;\\n\\n        if (direction == 0) {\\n            for (int i = current.right + 1; i < n; i++) {\\n                if (visited[current.top][i] == 1) {\\n                    nextBlock = visited[current.top][i] - 1;\\n                    break;\\n                }\\n            }\\n\\n            if (nextBlock == -1) {\\n                direction = 1;\\n                blockChooser = 0;\\n            }\\n        }\\n        else if (direction == 1) {\\n            for (int i = current.bottom + 1; i < m; i++) {\\n                if (visited[i][current.right] == 1) {\\n                    nextBlock = visited[i][current.right] - 1;\\n                    break;\\n                }\\n            }\\n\\n            if (nextBlock == -1) {\\n                direction = 2;\\n                blockChooser = 1;\\n            }\\n        }\\n        else if (direction == 2) {\\n            for (int i = current.left - 1; i >= 0; i--) {\\n                if (visited[current.bottom][i] == 1) {\\n                    nextBlock = visited[current.bottom][i] - 1;\\n                    break;\\n                }\\n            }\\n\\n            if (nextBlock == -1) {\\n                direction = 3;\\n                blockChooser = 0;\\n            }\\n        }\\n        else if (direction == 3) {\\n            for (int i = current.top - 1; i >= 0; i--) {\\n                if (visited[i][current.left] == 1) {\\n                    nextBlock = visited[i][current.left] - 1;\\n                    break;\\n                }\\n            }\\n\\n            if (nextBlock == -1) {\\n                direction = 0;\\n                blockChooser = 1;\\n            }\\n        }\\n\\n        if (nextBlock == -1) {\\n            break;\\n        }\\n\\n        currentBlock = nextBlock;\\n        steps++;\\n\\n        if (blockChooser == 0) {\\n            direction = (direction + 1) % 4;\\n        }\\n        else {\\n            direction = (direction + 3) % 4;\\n        }\\n    }\\n\\n    cout << blocks[currentBlock].color << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class PietInterpreter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] input = scanner.nextLine().split(\\\" \\\");\n        int m = Integer.parseInt(input[0]);\n        int n = Integer.parseInt(input[1]);\n        \n        String[] program = new String[m];\n        for (int i = 0; i < m; i++) {\n            program[i] = scanner.nextLine();\n        }\n        \n        int currentBlock = getCurrentBlock(program, n);\n        System.out.println(currentBlock);\n    }\n    \n    public static int getCurrentBlock(String[] program, int n) {\n        int m = program.length;\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {1, 0, -1, 0};\n        \n        int dp = 0; \/\/ direction pointer\n        int cp = 2; \/\/ block chooser\n        int bp = 0; \/\/ current block pointer\n        \n        int steps = 0;\n        while (steps < n) {\n            int x = -1;\n            int y = -1;\n            \n            \/\/ Find the furthest edge of the current color block in the direction of DP\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < program[i].length(); j++) {\n                    if (Character.getNumericValue(program[i].charAt(j)) == bp + 1) {\n                        x = i;\n                        y = j;\n                    }\n                }\n            }\n            \n            \/\/ Find the furthest pixel in the direction of CP\n            while (isValid(x + dx[cp], y + dy[cp], m, program[x].length()) && Character.getNumericValue(program[x + dx[cp]].charAt(y + dy[cp])) == bp + 1) {\n                x += dx[cp];\n                y += dy[cp];\n            }\n            \n            \/\/ Move to the next pixel in the direction of DP\n            if (isValid(x + dx[dp], y + dy[dp], m, program[x].length()) && Character.getNumericValue(program[x + dx[dp]].charAt(y + dy[dp])) != 0) {\n                bp = Character.getNumericValue(program[x + dx[dp]].charAt(y + dy[dp])) - 1;\n            } else {\n                if (cp == 2) {\n                    cp = 0;\n                } else {\n                    cp = 2;\n                    dp = (dp + 1) % 4;\n                }\n            }\n            \n            steps++;\n        }\n        \n        return bp + 1;\n    }\n    \n    public static boolean isValid(int x, int y, int m, int n) {\n        return x >= 0 && x < m && y >= 0 && y < n;\n    }\n}","Python":"def get_current_block(m, n, program):\n    # Parse the input\n    m, n = map(int, m.split())\n    program = [list(map(int, row)) for row in program.split()]\n\n    # Initialize the IP state\n    bp = (0, 0)  # Current block pointer\n    dp = (0, 1)  # Direction pointer\n    cp = (0, -1)  # Block chooser\n\n    # Helper function to check if a position is within the program bounds\n    def is_valid_position(pos):\n        return 0 <= pos[0] < m and 0 <= pos[1] < n\n\n    # Helper function to get the furthest edge in the direction of DP\n    def get_furthest_edge():\n        edge = bp\n        while is_valid_position((edge[0] + dp[0], edge[1] + dp[1])) and program[edge[0] + dp[0]][edge[1] + dp[1]] == program[edge[0]][edge[1]]:\n            edge = (edge[0] + dp[0], edge[1] + dp[1])\n        return edge\n\n    # Helper function to get the furthest pixel in the direction of CP from a given edge\n    def get_furthest_pixel(edge):\n        pixel = edge\n        while is_valid_position((pixel[0] + cp[0], pixel[1] + cp[1])) and program[pixel[0] + cp[0]][pixel[1] + cp[1]] == program[edge[0]][edge[1]]:\n            pixel = (pixel[0] + cp[0], pixel[1] + cp[1])\n        return pixel\n\n    # Perform n steps of program interpretation\n    for _ in range(n):\n        edge = get_furthest_edge()\n        pixel = get_furthest_pixel(edge)\n        if is_valid_position((pixel[0] + dp[0], pixel[1] + dp[1])) and program[pixel[0] + dp[0]][pixel[1] + dp[1]] != 0:\n            bp = (pixel[0] + dp[0], pixel[1] + dp[1])\n        else:\n            if cp == (0, -1):\n                cp = (0, 1)\n            else:\n                cp = (0, -1)\n                dp = (dp[1], -dp[0])\n\n    # Return the color of the current block\n    return str(program[bp[0]][bp[1]])\n\n# Test the function with the sample inputs\ninputs = [\n    {'m': '2 10', 'n': 10, 'program': '12\\n43\\n'},\n    {'m': '3 12', 'n': 12, 'program': '1423\\n6624\\n6625\\n'},\n    {'m': '5 9', 'n': 9, 'program': '10345\\n23456\\n34567\\n45678\\n56789\\n'}\n]\n\noutputs = []\nfor input_data in inputs:\n    output = get_current_block(input_data['m'], input_data['n'], input_data['program'])\n    outputs.append(output)\n\noutputs","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int m, n;\\n    scanf(\\\"%d %d\\\", &m, &n);\\n    char program[m][51];\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%s\\\", program[i]);\\n    }\\n\\n    int bp_x = 0, bp_y = 0;\\n    int dp_x = 1, dp_y = 0;\\n    int cp_x = 0, cp_y = -1;\\n\\n    for (int step = 1; step <= n; step++) {\\n        int current_color = program[bp_x][bp_y] - '0';\\n\\n        int edge_x = bp_x, edge_y = bp_y;\\n        while (edge_x >= 0 && edge_x < m && edge_y >= 0 && edge_y < 50 && program[edge_x][edge_y] - '0' == current_color) {\\n            edge_x += dp_x;\\n            edge_y += dp_y;\\n        }\\n        edge_x -= dp_x;\\n        edge_y -= dp_y;\\n\\n        int next_x = edge_x + cp_x;\\n        int next_y = edge_y + cp_y;\\n\\n        if (next_x >= 0 && next_x < m && next_y >= 0 && next_y < 50 && program[next_x][next_y] - '0' != 0) {\\n            bp_x = next_x;\\n            bp_y = next_y;\\n        } else {\\n            if (cp_x == 0 && cp_y == -1) {\\n                cp_x = 0;\\n                cp_y = 1;\\n            } else {\\n                cp_x = 0;\\n                cp_y = -1;\\n                int temp = dp_x;\\n                dp_x = dp_y;\\n                dp_y = -temp;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%c\\\\n\\\", program[bp_x][bp_y]);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace PietInterpreter\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int m = int.Parse(inputArr[0]);\n            int n = int.Parse(inputArr[1]);\n\n            List<string> program = new List<string>();\n            for (int i = 0; i < m; i++)\n            {\n                program.Add(Console.ReadLine());\n            }\n\n            int currentBlock = GetCurrentBlock(program, n);\n            Console.WriteLine(currentBlock);\n        }\n\n        static int GetCurrentBlock(List<string> program, int n)\n        {\n            int m = program.Count;\n            int rowLength = program[0].Length;\n\n            int[] dx = { 1, 0, -1, 0 };\n            int[] dy = { 0, 1, 0, -1 };\n\n            int dp = 0;\n            int cp = 3;\n            int bp = 0;\n\n            int currentBlock = int.Parse(program[0][0].ToString());\n\n            for (int i = 0; i < n; i++)\n            {\n                int x = 0;\n                int y = 0;\n\n                for (int j = 0; j < m; j++)\n                {\n                    for (int k = 0; k < rowLength; k++)\n                    {\n                        if (program[j][k] == currentBlock.ToString()[0])\n                        {\n                            x = k;\n                            y = j;\n                        }\n                    }\n                }\n\n                int nx = x + dx[dp];\n                int ny = y + dy[dp];\n\n                if (nx < 0 || nx >= rowLength || ny < 0 || ny >= m || program[ny][nx] == '0')\n                {\n                    if (cp == 3)\n                    {\n                        cp = 1;\n                    }\n                    else\n                    {\n                        cp = 3;\n                        dp = (dp + 1) % 4;\n                    }\n                }\n                else\n                {\n                    currentBlock = int.Parse(program[ny][nx].ToString());\n                }\n            }\n\n            return currentBlock;\n        }\n    }\n}","Ruby":"def current_block(m, n, program)\n  # Split the program into rows\n  rows = program.split('\\\\n')\n\n  # Initialize the initial state of the IP\n  bp = [0, 0]  # Current block pointer\n  dp = [0, 1]  # Direction pointer\n  cp = [-1, 0] # Block chooser\n\n  # Iterate through n steps\n  n.times do\n    # Find the furthest edge of the current color block in the direction of the DP\n    edge = find_furthest_edge(rows, bp, dp)\n\n    # Find the furthest pixel from the edge in the direction of the CP\n    pixel = find_furthest_pixel(rows, edge, cp)\n\n    # Move BP to the next pixel in the direction of the DP\n    next_pixel = [pixel[0] + dp[0], pixel[1] + dp[1]]\n    if next_pixel[0] >= 0 && next_pixel[0] < rows.length && next_pixel[1] >= 0 && next_pixel[1] < rows[0].length\n      bp = next_pixel if rows[next_pixel[0]][next_pixel[1]] != '0'\n    end\n\n    # Update CP and DP based on the current state\n    if cp == [-1, 0]\n      cp = [1, 0]\n    else\n      cp = [-1, 0]\n      dp = [dp[1], -dp[0]]\n    end\n  end\n\n  # Return the color of the current block\n  rows[bp[0]][bp[1]]\nend\n\ndef find_furthest_edge(rows, bp, dp)\n  edge = bp.dup\n  while edge[0] >= 0 && edge[0] < rows.length && edge[1] >= 0 && edge[1] < rows[0].length && rows[edge[0]][edge[1]] != '0'\n    edge[0] += dp[0]\n    edge[1] += dp[1]\n  end\n  edge\nend\n\ndef find_furthest_pixel(rows, edge, cp)\n  pixel = edge.dup\n  while pixel[0] >= 0 && pixel[0] < rows.length && pixel[1] >= 0 && pixel[1] < rows[0].length && rows[pixel[0]][pixel[1]] != '0'\n    pixel[0] += cp[0]\n    pixel[1] += cp[1]\n  end\n  pixel\nend\n\n# Parse the input\ninput = '2 10\\\\n12\\\\n43\\\\n'\nm, n = input.split(' ')[0].to_i, input.split(' ')[1].to_i\nprogram = input.split('\\\\n')[1..-1].join('\\\\n')\n\n# Get the color of the current block after n steps\ncolor = current_block(m, n, program)\n\n# Output the result\nputs color","delphi":"program PietInterpreter;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nvar\\n  m, n, i, j, k, x, y, dx, dy, cx, cy, dp, cp: Integer;\\n  programArr: array[1..50, 1..50] of Integer;\\n\\nbegin\\n  ReadLn(m, n);\\n  for i := 1 to m do\\n  begin\\n    for j := 1 to n do\\n    begin\\n      Read(programArr[i, j]);\\n    end;\\n    ReadLn;\\n  end;\\n\\n  x := 1;\\n  y := 1;\\n  dx := 1;\\n  dy := 0;\\n  cx := -1;\\n  cy := 0;\\n  dp := 0;\\n  cp := 1;\\n\\n  for k := 1 to n do\\n  begin\\n    if programArr[x, y] = 0 then\\n    begin\\n      if cp = 1 then\\n      begin\\n        cp := -1;\\n      end\\n      else\\n      begin\\n        cp := 1;\\n        dx := dy;\\n        dy := -dx;\\n      end;\\n    end\\n    else\\n    begin\\n      if cp = 1 then\\n      begin\\n        cx := dx;\\n        cy := dy;\\n      end;\\n\\n      if dx = 1 then\\n      begin\\n        x := x + cx;\\n      end\\n      else if dx = -1 then\\n      begin\\n        x := x - cx;\\n      end\\n      else if dy = 1 then\\n      begin\\n        y := y + cy;\\n      end\\n      else if dy = -1 then\\n      begin\\n        y := y - cy;\\n      end;\\n\\n      if (x < 1) or (x > m) or (y < 1) or (y > n) or (programArr[x, y] = 0) then\\n      begin\\n        if cp = 1 then\\n        begin\\n          cp := -1;\\n        end\\n        else\\n        begin\\n          cp := 1;\\n          dx := dy;\\n          dy := -dx;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  WriteLn(programArr[x, y]);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tm, _ := strconv.Atoi(nm[0])\\n\\tn, _ := strconv.Atoi(nm[1])\\n\\n\\tprogram := make([][]int, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\trow := scanner.Text()\\n\\t\\tprogram[i] = make([]int, len(row))\\n\\n\\t\\tfor j := 0; j < len(row); j++ {\\n\\t\\t\\tprogram[i][j], _ = strconv.Atoi(string(row[j]))\\n\\t\\t}\\n\\t}\\n\\n\\tcurrentBlock := program[0][0]\\n\\tcurrentRow := 0\\n\\tcurrentCol := 0\\n\\tdirection := 1\\n\\tblockChooser := -1\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif currentBlock == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tnextRow := currentRow\\n\\t\\tnextCol := currentCol\\n\\n\\t\\tif direction == 0 {\\n\\t\\t\\tnextRow--\\n\\t\\t} else if direction == 1 {\\n\\t\\t\\tnextCol++\\n\\t\\t} else if direction == 2 {\\n\\t\\t\\tnextRow++\\n\\t\\t} else if direction == 3 {\\n\\t\\t\\tnextCol--\\n\\t\\t}\\n\\n\\t\\tif nextRow < 0 || nextRow >= m || nextCol < 0 || nextCol >= len(program[nextRow]) {\\n\\t\\t\\tif blockChooser == -1 {\\n\\t\\t\\t\\tblockChooser = 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tblockChooser = -1\\n\\t\\t\\t\\tdirection = (direction + 1) % 4\\n\\t\\t\\t}\\n\\t\\t} else if program[nextRow][nextCol] != currentBlock {\\n\\t\\t\\tcurrentBlock = program[nextRow][nextCol]\\n\\t\\t\\tcurrentRow = nextRow\\n\\t\\t\\tcurrentCol = nextCol\\n\\t\\t} else {\\n\\t\\t\\tcurrentRow = nextRow\\n\\t\\t\\tcurrentCol = nextCol\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(currentBlock)\\n}","Javascript":"function getCurrentBlock(m, n, program) {\n  \/\/ Parse the input\n  const [rows, cols] = m.split(\" \").map(Number);\n  const steps = Number(n);\n  const grid = program.split(\"\\n\").map(row => row.split(\"\").map(Number));\n\n  \/\/ Initialize the IP state\n  let bpRow = 0;\n  let bpCol = 0;\n  let dpRow = 0;\n  let dpCol = 1;\n  let cpRow = 0;\n  let cpCol = -1;\n\n  \/\/ Helper function to check if a position is within the grid\n  function isValidPosition(row, col) {\n    return row >= 0 && row < rows && col >= 0 && col < cols;\n  }\n\n  \/\/ Helper function to get the color of a block given its top-left position\n  function getBlockColor(row, col) {\n    const color = grid[row][col];\n    return color === 0 ? -1 : color;\n  }\n\n  \/\/ Helper function to move the BP to the next position\n  function moveBP() {\n    bpRow += dpRow;\n    bpCol += dpCol;\n  }\n\n  \/\/ Helper function to rotate the DP and CP\n  function rotate() {\n    const tempRow = dpRow;\n    const tempCol = dpCol;\n    dpRow = cpRow;\n    dpCol = cpCol;\n    cpRow = -tempRow;\n    cpCol = -tempCol;\n  }\n\n  \/\/ Perform the program interpretation\n  for (let step = 1; step <= steps; step++) {\n    \/\/ Find the furthest edge of the current color block in the direction of DP\n    let edgeRow = bpRow;\n    let edgeCol = bpCol;\n    while (isValidPosition(edgeRow + dpRow, edgeCol + dpCol) && getBlockColor(edgeRow + dpRow, edgeCol + dpCol) === getBlockColor(bpRow, bpCol)) {\n      edgeRow += dpRow;\n      edgeCol += dpCol;\n    }\n\n    \/\/ Find the furthest pixel in the direction of CP from the edge\n    let nextRow = edgeRow;\n    let nextCol = edgeCol;\n    while (isValidPosition(nextRow + cpRow, nextCol + cpCol) && getBlockColor(nextRow + cpRow, nextCol + cpCol) === getBlockColor(bpRow, bpCol)) {\n      nextRow += cpRow;\n      nextCol += cpCol;\n    }\n\n    \/\/ Move the BP to the next pixel\n    if (isValidPosition(nextRow + dpRow, nextCol + dpCol) && getBlockColor(nextRow + dpRow, nextCol + dpCol) !== 0) {\n      bpRow = nextRow + dpRow;\n      bpCol = nextCol + dpCol;\n    } else {\n      \/\/ Update CP and DP if necessary\n      if (cpCol === -1) {\n        cpCol = 1;\n      } else {\n        cpCol = -1;\n        rotate();\n      }\n    }\n  }\n\n  \/\/ Get the color of the current block\n  const currentColor = getBlockColor(bpRow, bpCol);\n\n  return currentColor.toString();\n}\n\n\/\/ Test cases\nconst inputs = [\n  { m: \"2 10\", n: \"10\", program: \"12\\n43\\n\" },\n  { m: \"3 12\", n: \"12\", program: \"1423\\n6624\\n6625\\n\" },\n  { m: \"5 9\", n: \"9\", program: \"10345\\n23456\\n34567\\n45678\\n56789\\n\" }\n];\n\nconst outputs = inputs.map(input => getCurrentBlock(input.m, input.n, input.program));\nconsole.log(outputs.join('\\\\n'));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val m = input[0].toInt()\n    val n = input[1].toInt()\n    \n    val program = mutableListOf<String>()\n    repeat(m) {\n        program.add(scanner.nextLine())\n    }\n    \n    val blocks = mutableListOf<Block>()\n    for (i in 0 until m) {\n        for (j in 0 until program[i].length) {\n            val color = program[i][j].toString().toInt()\n            if (color != 0) {\n                val block = Block(color, i, j)\n                blocks.add(block)\n            }\n        }\n    }\n    \n    var bp = blocks[0]\n    var dp = Direction.RIGHT\n    var cp = Direction.LEFT\n    \n    repeat(n) {\n        val edge = findFurthestEdge(bp, dp)\n        val nextPixel = findFurthestPixel(edge, cp)\n        \n        if (nextPixel != null && nextPixel.color != 0) {\n            bp = nextPixel\n        } else {\n            if (cp == Direction.LEFT) {\n                cp = Direction.RIGHT\n            } else {\n                cp = Direction.LEFT\n                dp = dp.rotateClockwise()\n            }\n        }\n    }\n    \n    println(bp.color)\n}\n\nfun findFurthestEdge(bp: Block, dp: Direction): List<Block> {\n    val edge = mutableListOf<Block>()\n    var current = bp\n    \n    while (true) {\n        edge.add(current)\n        val nextRow = current.row + dp.dy\n        val nextCol = current.col + dp.dx\n        \n        if (nextRow < 0 || nextRow >= current.program.size || nextCol < 0 || nextCol >= current.program[nextRow].length) {\n            break\n        }\n        \n        val nextColor = current.program[nextRow][nextCol].toString().toInt()\n        if (nextColor != current.color) {\n            break\n        }\n        \n        current = Block(current.color, nextRow, nextCol, current.program)\n    }\n    \n    return edge\n}\n\nfun findFurthestPixel(edge: List<Block>, cp: Direction): Block? {\n    var furthestPixel: Block? = null\n    \n    for (block in edge) {\n        val nextRow = block.row + cp.dy\n        val nextCol = block.col + cp.dx\n        \n        if (nextRow < 0 || nextRow >= block.program.size || nextCol < 0 || nextCol >= block.program[nextRow].length) {\n            continue\n        }\n        \n        val nextColor = block.program[nextRow][nextCol].toString().toInt()\n        if (nextColor != block.color) {\n            continue\n        }\n        \n        val nextBlock = Block(block.color, nextRow, nextCol, block.program)\n        if (furthestPixel == null || nextBlock.isFurthestFrom(bp, cp, furthestPixel)) {\n            furthestPixel = nextBlock\n        }\n    }\n    \n    return furthestPixel\n}\n\ndata class Block(val color: Int, val row: Int, val col: Int, val program: List<String> = emptyList()) {\n    fun isFurthestFrom(bp: Block, cp: Direction, other: Block): Boolean {\n        val dx1 = col - bp.col\n        val dy1 = row - bp.row\n        val dx2 = other.col - bp.col\n        val dy2 = other.row - bp.row\n        \n        val crossProduct = dx1 * dy2 - dx2 * dy1\n        if (crossProduct != 0) {\n            return crossProduct > 0\n        }\n        \n        val dotProduct = dx1 * dx2 + dy1 * dy2\n        if (dotProduct != 0) {\n            return dotProduct > 0\n        }\n        \n        val distance1 = dx1 * dx1 + dy1 * dy1\n        val distance2 = dx2 * dx2 + dy2 * dy2\n        return distance1 > distance2\n    }\n}\n\nenum class Direction(val dx: Int, val dy: Int) {\n    LEFT(-1, 0),\n    RIGHT(1, 0),\n    UP(0, -1),\n    DOWN(0, 1);\n    \n    fun rotateClockwise(): Direction {\n        return when (this) {\n            LEFT -> UP\n            UP -> RIGHT\n            RIGHT -> DOWN\n            DOWN -> LEFT\n        }\n    }\n}","PHP":"<?php\\n\\nfunction findCurrentBlock($m, $n, $program) {\\n    $rows = explode(\\\"\\\\n\\\", $program);\\n    $blocks = [];\\n    $currentBlock = 0;\\n    $dp = 1; \/\/ Direction pointer initially points to the right\\n    $cp = -1; \/\/ Block chooser initially points to the left\\n    $bp = [0, 0]; \/\/ Initial block pointer\\n\\n    \/\/ Find all blocks in the program\\n    for ($i = 0; $i < $m; $i++) {\\n        for ($j = 0; $j < strlen($rows[$i]); $j++) {\\n            $color = intval($rows[$i][$j]);\\n            if ($color != 0) {\\n                if (!isset($blocks[$color])) {\\n                    $blocks[$color] = [];\\n                }\\n                $blocks[$color][] = [$i, $j];\\n            }\\n        }\\n    }\\n\\n    \/\/ Simulate program interpretation\\n    for ($step = 1; $step <= $n; $step++) {\\n        $currentEdge = findFurthestEdge($blocks[$currentBlock], $dp);\\n        $nextPixel = findFurthestPixel($currentEdge, $cp);\\n\\n        if (isset($blocks[$currentBlock]) && inBlock($nextPixel, $blocks[$currentBlock])) {\\n            \/\/ Move to next pixel in the same block\\n            $bp = $nextPixel;\\n        } else {\\n            \/\/ Move to next block\\n            if ($cp == -1) {\\n                $cp = 1;\\n            } else {\\n                $cp = -1;\\n                $dp = rotateDP($dp);\\n            }\\n            $currentBlock = findBlock($nextPixel, $blocks);\\n            $bp = $nextPixel;\\n        }\\n    }\\n\\n    return $currentBlock;\\n}\\n\\nfunction findFurthestEdge($block, $dp) {\\n    $furthestPixel = $block[0];\\n\\n    foreach ($block as $pixel) {\\n        if (($dp == 1 && $pixel[1] > $furthestPixel[1]) ||\\n            ($dp == -1 && $pixel[1] < $furthestPixel[1]) ||\\n            ($dp == 2 && $pixel[0] < $furthestPixel[0]) ||\\n            ($dp == -2 && $pixel[0] > $furthestPixel[0])) {\\n            $furthestPixel = $pixel;\\n        }\\n    }\\n\\n    return $furthestPixel;\\n}\\n\\nfunction findFurthestPixel($edge, $cp) {\\n    $furthestPixel = $edge;\\n\\n    foreach ($edge as $pixel) {\\n        if (($cp == -1 && $pixel[1] < $furthestPixel[1]) ||\\n            ($cp == 1 && $pixel[1] > $furthestPixel[1]) ||\\n            ($cp == -2 && $pixel[0] > $furthestPixel[0]) ||\\n            ($cp == 2 && $pixel[0] < $furthestPixel[0])) {\\n            $furthestPixel = $pixel;\\n        }\\n    }\\n\\n    return $furthestPixel;\\n}\\n\\nfunction inBlock($pixel, $block) {\\n    foreach ($block as $p) {\\n        if ($p == $pixel) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nfunction findBlock($pixel, $blocks) {\\n    foreach ($blocks as $color => $block) {\\n        if (inBlock($pixel, $block)) {\\n            return $color;\\n        }\\n    }\\n    return 0;\\n}\\n\\nfunction rotateDP($dp) {\\n    if ($dp == 1) {\\n        return 2;\\n    } elseif ($dp == 2) {\\n        return -1;\\n    } elseif ($dp == -1) {\\n        return -2;\\n    } else {\\n        return 1;\\n    }\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n$m = intval(explode(\\\" \\\", $input[0])[0]);\\n$n = intval(explode(\\\" \\\", $input[0])[1]);\\n$program = implode(\\\"\\\\n\\\", array_slice($input, 1));\\n\\n$result = findCurrentBlock($m, $n, $program);\\necho $result . \\\"\\\\n\\\";\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int m, n;\\r\\n    readf(\\\"%d %d\\\\n\\\", &m, &n);\\r\\n\\r\\n    int[][] program = new int[][](m);\\r\\n    foreach (i; 0 .. m)\\r\\n    {\\r\\n        string line;\\r\\n        readf(\\\"%s\\\\n\\\", &line);\\r\\n        program[i] = line.split.map!(a => a.to!int).array;\\r\\n    }\\r\\n\\r\\n    int currentBlock = program[0][0];\\r\\n    int currentRow = 0;\\r\\n    int currentCol = 0;\\r\\n    int direction = 0; \/\/ 0: right, 1: down, 2: left, 3: up\\r\\n    int blockChooser = 1; \/\/ 1: left, -1: right\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        int nextRow = currentRow;\\r\\n        int nextCol = currentCol;\\r\\n\\r\\n        switch (direction)\\r\\n        {\\r\\n            case 0: \/\/ right\\r\\n                nextCol = findFurthestEdge(program, currentBlock, currentRow, currentCol, 0, 1);\\r\\n                break;\\r\\n            case 1: \/\/ down\\r\\n                nextRow = findFurthestEdge(program, currentBlock, currentRow, currentCol, 1, 0);\\r\\n                break;\\r\\n            case 2: \/\/ left\\r\\n                nextCol = findFurthestEdge(program, currentBlock, currentRow, currentCol, 0, -1);\\r\\n                break;\\r\\n            case 3: \/\/ up\\r\\n                nextRow = findFurthestEdge(program, currentBlock, currentRow, currentCol, -1, 0);\\r\\n                break;\\r\\n        }\\r\\n\\r\\n        if (nextRow == currentRow && nextCol == currentCol)\\r\\n        {\\r\\n            if (blockChooser == 1)\\r\\n            {\\r\\n                blockChooser = -1;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                blockChooser = 1;\\r\\n                direction = (direction + 1) % 4;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            currentRow = nextRow;\\r\\n            currentCol = nextCol;\\r\\n\\r\\n            if (program[currentRow][currentCol] != currentBlock)\\r\\n            {\\r\\n                currentBlock = program[currentRow][currentCol];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(currentBlock);\\r\\n}\\r\\n\\r\\nint findFurthestEdge(int[][] program, int currentBlock, int row, int col, int rowStep, int colStep)\\r\\n{\\r\\n    int nextRow = row;\\r\\n    int nextCol = col;\\r\\n\\r\\n    while (nextRow >= 0 && nextRow < program.length && nextCol >= 0 && nextCol < program[0].length && program[nextRow][nextCol] == currentBlock)\\r\\n    {\\r\\n        row += rowStep;\\r\\n        col += colStep;\\r\\n        nextRow += rowStep;\\r\\n        nextCol += colStep;\\r\\n    }\\r\\n\\r\\n    return row;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub get_current_block {\\n    my ($m, $n, @program) = @_;\\n    my ($m_val, $n_val) = split(' ', $m);\\n    my @rows = split('\\n', $n);\\n    my @blocks;\\n    my $current_block = $program[0][0];\\n    my $dp = 'right';\\n    my $cp = 'left';\\n    my $bp_x = 0;\\n    my $bp_y = 0;\\n\\n    for (my $i = 0; $i < $n_val; $i++) {\\n        my $current_color = $program[$bp_y][$bp_x];\\n        my $next_x = $bp_x;\\n        my $next_y = $bp_y;\\n\\n        if ($dp eq 'right') {\\n            $next_x++;\\n        } elsif ($dp eq 'left') {\\n            $next_x--;\\n        } elsif ($dp eq 'up') {\\n            $next_y--;\\n        } elsif ($dp eq 'down') {\\n            $next_y++;\\n        }\\n\\n        if ($next_x < 0 || $next_x >= $m_val || $next_y < 0 || $next_y >= $n_val || $program[$next_y][$next_x] == 0) {\\n            if ($cp eq 'left') {\\n                $cp = 'right';\\n            } else {\\n                $cp = 'left';\\n                if ($dp eq 'right') {\\n                    $dp = 'down';\\n                } elsif ($dp eq 'left') {\\n                    $dp = 'up';\\n                } elsif ($dp eq 'up') {\\n                    $dp = 'right';\\n                } elsif ($dp eq 'down') {\\n                    $dp = 'left';\\n                }\\n            }\\n        } else {\\n            if ($program[$next_y][$next_x] != $current_color) {\\n                $current_block = $program[$next_y][$next_x];\\n            }\\n            $bp_x = $next_x;\\n            $bp_y = $next_y;\\n        }\\n    }\\n\\n    return $current_block;\\n}\\n\\nmy $m = '2 10';\\nmy $n = '12';\\nmy @program = (\\n    [1, 2],\\n    [4, 3]\\n);\\n\\nmy $current_block = get_current_block($m, $n, @program);\\nprint $current_block;\\n","Rust":"fn main() {\\n    let input = \\\"2 10\\\\n12\\\\n43\\\\n\\\";\\n    let mut lines = input.lines();\\n    let first_line = lines.next().unwrap();\\n    let mut iter = first_line.split_whitespace();\\n    let m: usize = iter.next().unwrap().parse().unwrap();\\n    let n: usize = iter.next().unwrap().parse().unwrap();\\n    let program: Vec<Vec<u32>> = lines\\n        .map(|line| line.chars().map(|c| c.to_digit(10).unwrap()).collect())\\n        .collect();\\n\\n    let mut bp = (0, 0);\\n    let mut dp = (0, 1);\\n    let mut cp = (0, -1);\\n\\n    for _ in 0..n {\\n        let current_color = program[bp.0][bp.1];\\n        let mut edge = bp;\\n\\n        \/\/ Find the furthest edge in the direction of DP\\n        while edge.0 >= 0\\n            && edge.0 < m as isize\\n            && edge.1 >= 0\\n            && edge.1 < program[edge.0 as usize].len() as isize\\n            && program[edge.0 as usize][edge.1 as usize] == current_color\\n        {\\n            edge.0 += dp.0;\\n            edge.1 += dp.1;\\n        }\\n\\n        \/\/ Find the furthest pixel in the direction of CP\\n        let mut furthest_pixel = edge;\\n        while furthest_pixel.0 >= 0\\n            && furthest_pixel.0 < m as isize\\n            && furthest_pixel.1 >= 0\\n            && furthest_pixel.1 < program[furthest_pixel.0 as usize].len() as isize\\n            && program[furthest_pixel.0 as usize][furthest_pixel.1 as usize] == current_color\\n        {\\n            furthest_pixel.0 += cp.0;\\n            furthest_pixel.1 += cp.1;\\n        }\\n\\n        \/\/ Move BP to the next pixel in the direction of DP\\n        let next_pixel = (bp.0 as isize + dp.0, bp.1 as isize + dp.1);\\n        if next_pixel.0 >= 0\\n            && next_pixel.0 < m as isize\\n            && next_pixel.1 >= 0\\n            && next_pixel.1 < program[next_pixel.0 as usize].len() as isize\\n            && program[next_pixel.0 as usize][next_pixel.1 as usize] != 0\\n        {\\n            bp = (next_pixel.0 as usize, next_pixel.1 as usize);\\n        } else {\\n            if cp == (0, -1) {\\n                cp = (0, 1);\\n            } else {\\n                cp = (0, -1);\\n                dp = (dp.1, -dp.0);\\n            }\\n        }\\n    }\\n\\n    let current_block = program[bp.0][bp.1];\\n    println!(\\\"{}\\\", current_block);\\n}"}
{"title":"A. Average Numbers","description":"You are given a sequence of positive integers a1,a2,...,an. Find all such indices i, that the i-th element equals the arithmetic mean of all other elements (that is all elements except for this one).","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains the integer n (2\u2264n\u22642\u00b710^5). The second line contains elements of the sequence a1,a2,...,an (1\u2264ai\u22641000). All the elements are positive integers.\n","output_spec":"Print on the first line the number of the sought indices. Print on the second line the sought indices in the increasing order. All indices are integers from 1 to n.\nIf the sought elements do not exist, then the first output line should contain number 0. In this case you may either not print the second line or print an empty line.\n","notes":null,"sample_inputs":["5\n1 2 3 4 5\n","4\n50 50 50 50\n"],"sample_outputs":["1\n3 ","4\n1 2 3 4 "],"id":"134-A","difficulty":1200,"tags":["brute+force","implementation"],"src_uid":"1a22bc82ddf6b3dfbf270bc5e3294c28","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n    int sum = 0;\\n    for (int i = 0; i < n; i++) {\\n        sum += a[i];\\n    }\\n    vector<int> indices;\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] * (n - 1) == sum - a[i]) {\\n            indices.push_back(i + 1);\\n        }\\n    }\\n    int numIndices = indices.size();\\n    cout << numIndices << endl;\\n    if (numIndices > 0) {\\n        for (int i = 0; i < numIndices; i++) {\\n            cout << indices[i] << \\\" \\\";\\n        }\\n        cout << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.nextLine();\\n        String[] elements = scanner.nextLine().split(\\\" \\\");\\n        int[] sequence = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            sequence[i] = Integer.parseInt(elements[i]);\\n        }\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (j != i) {\\n                    sum += sequence[j];\\n                }\\n            }\\n            if (sum == sequence[i] * (n - 1)) {\\n                indices.add(i + 1);\\n            }\\n        }\\n        System.out.println(indices.size());\\n        for (int index : indices) {\\n            System.out.print(index + \\\" \\\");\\n        }\\n    }\\n}","Python":"def find_arithmetic_mean_indices(n, sequence):\n    total_sum = sum(sequence)\n    mean = total_sum \/ n\n    indices = []\n    \n    for i in range(n):\n        if sequence[i] == mean:\n            indices.append(i+1)\n    \n    num_indices = len(indices)\n    \n    if num_indices == 0:\n        return '0\\n'\n    else:\n        return '{}\\n{}'.format(num_indices, ' '.join(map(str, indices)))\n\n# Sample inputs\ninputs = ['5\\n1 2 3 4 5\\n', '4\\n50 50 50 50\\n']\n\n# Sample outputs\noutputs = [find_arithmetic_mean_indices(*map(int, input_.split())) for input_ in inputs]\n\n# Format outputs in JSON\njson_outputs = [{'version': 'Python 3', 'source code': find_arithmetic_mean_indices.__code__.co_code.hex()}]\n\njson_outputs","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int sum = 0;\\n    for (int i = 0; i < n; i++) {\\n        sum += a[i];\\n    }\\n\\n    int count = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] * (n - 1) == sum - a[i]) {\\n            count++;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] * (n - 1) == sum - a[i]) {\\n            printf(\\\"%d \\\", i + 1);\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] sequence = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        \n        List<int> indices = new List<int>();\n        \n        for (int i = 0; i < n; i++)\n        {\n            int sum = sequence.Sum() - sequence[i];\n            int mean = sum \/ (n - 1);\n            \n            if (sequence[i] == mean)\n            {\n                indices.Add(i + 1);\n            }\n        }\n        \n        Console.WriteLine(indices.Count);\n        Console.WriteLine(string.Join(\" \", indices));\n    }\n}","Ruby":"\ndef find_indices(n, sequence)\n  indices = []\n  sum = sequence.sum\n  sequence.each_with_index do |num, i|\n    if num == (sum - num) \/ (n - 1)\n      indices << i + 1\n    end\n  end\n  if indices.empty?\n    return \"0\\n\"\n  else\n    return \"#{indices.length}\\n#{indices.join(' ')} \"\n  end\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nsequence = input[1].split(' ').map(&:to_i)\n\nputs find_indices(n, sequence)\n","delphi":"program Main;\\n\\nvar\\n  n, i, sum, mean: integer;\\n  a: array[1..200000] of integer;\\n  indices: array[1..200000] of integer;\\n  count: integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(a[i]);\\n\\n  sum := 0;\\n  for i := 1 to n do\\n    sum := sum + a[i];\\n\\n  mean := sum div n;\\n\\n  count := 0;\\n  for i := 1 to n do\\n  begin\\n    if a[i] = mean then\\n    begin\\n      count := count + 1;\\n      indices[count] := i;\\n    end;\\n  end;\\n\\n  writeln(count);\\n  for i := 1 to count do\\n    write(indices[i], ' ');\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar sequence string\\n\\tfmt.Scan(&sequence)\\n\\n\\telements := strings.Split(sequence, \\\" \\\")\\n\\n\\tvar sum int\\n\\tfor _, element := range elements {\\n\\t\\tnum := parseInt(element)\\n\\t\\tsum += num\\n\\t}\\n\\n\\tvar indices []int\\n\\tfor i, element := range elements {\\n\\t\\tnum := parseInt(element)\\n\\t\\tif num == sum\/len(elements)-num {\\n\\t\\t\\tindices = append(indices, i+1)\\n\\t\\t}\\n\\t}\\n\\n\\tif len(indices) == 0 {\\n\\t\\tfmt.Println(0)\\n\\t} else {\\n\\t\\tfmt.Println(len(indices))\\n\\t\\tfor _, index := range indices {\\n\\t\\t\\tfmt.Printf(\\\"%d \\\", index)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc parseInt(s string) int {\\n\\tvar num int\\n\\tfmt.Sscan(s, &num)\\n\\treturn num\\n}","Javascript":"function findIndices(sequence) {\n  const n = sequence[0];\n  const elements = sequence[1].split(' ').map(Number);\n  const sum = elements.reduce((a, b) => a + b, 0);\n  const indices = [];\n\n  for (let i = 0; i < n; i++) {\n    if (elements[i] === sum \/ (n - 1)) {\n      indices.push(i + 1);\n    }\n  }\n\n  const output = [];\n  output.push(indices.length);\n  output.push(indices.join(' '));\n\n  return output.join('\\\\n');\n}\n\nconst input = ['5\\\\n1 2 3 4 5\\\\n'];\nconst output = findIndices(input);\nconsole.log(output);","Kotlin":"fun main() {\n    val n = readLine()!!.toInt()\n    val sequence = readLine()!!.split(\" \").map { it.toInt() }\n    \n    val sum = sequence.sum()\n    val indices = mutableListOf<Int>()\n    \n    for (i in 0 until n) {\n        if (sequence[i] * (n - 1) == sum - sequence[i]) {\n            indices.add(i + 1)\n        }\n    }\n    \n    if (indices.isEmpty()) {\n        println(\"0\")\n    } else {\n        println(indices.size)\n        println(indices.joinToString(\" \"))\n    }\n}","PHP":"<?php\\n\\nfunction findIndices($n, $sequence) {\\n    $indices = [];\\n    $sum = array_sum($sequence);\\n    for ($i = 0; $i < $n; $i++) {\\n        if (($sum - $sequence[$i]) \/ ($n - 1) == $sequence[$i]) {\\n            $indices[] = $i + 1;\\n        }\\n    }\\n    $output = [];\\n    $output[] = count($indices);\\n    $output[] = implode(' ', $indices);\\n    return $output;\\n}\\n\\n$input1 = explode(' ', trim('5\\n1 2 3 4 5\\n'));\\n$n1 = intval($input1[0]);\\n$sequence1 = array_map('intval', array_slice($input1, 1));\\n$output1 = findIndices($n1, $sequence1);\\n\\n$input2 = explode(' ', trim('4\\n50 50 50 50\\n'));\\n$n2 = intval($input2[0]);\\n$sequence2 = array_map('intval', array_slice($input2, 1));\\n$output2 = findIndices($n2, $sequence2);\\n\\n$output = [];\\n$output[] = implode(' ', $output1);\\n$output[] = implode(' ', $output2);\\n\\njson_encode($output);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] sequence;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    sequence = readln.split.map!(a => a.to!int).array;\\r\\n\\r\\n    \/\/ Calculate the sum of all elements\\r\\n    int sum = sequence.reduce!((a, b) => a + b);\\r\\n\\r\\n    \/\/ Find the indices where the element equals the arithmetic mean\\r\\n    int[] indices;\\r\\n    foreach (i, element; sequence)\\r\\n    {\\r\\n        if (element * (n - 1) == sum)\\r\\n        {\\r\\n            indices ~= i + 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the number of sought indices\\r\\n    writeln(indices.length);\\r\\n\\r\\n    \/\/ Print the sought indices in increasing order\\r\\n    writeln(indices);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_indices {\n    my ($n, @sequence) = @_;\n\n    my @indices;\n\n    for my $i (0..$n-1) {\n        my $sum = 0;\n        for my $j (0..$n-1) {\n            next if $i == $j;\n            $sum += $sequence[$j];\n        }\n        my $mean = $sum \/ ($n-1);\n        if ($sequence[$i] == $mean) {\n            push @indices, $i+1;\n        }\n    }\n\n    my $num_indices = scalar @indices;\n    my $indices_str = join(' ', @indices);\n\n    return \"$num_indices\\n$indices_str\";\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy $sequence_str = <>;\nchomp $sequence_str;\nmy @sequence = split ' ', $sequence_str;\n\n# Find indices\nmy $output = find_indices($n, @sequence);\n\n# Print output\nprint $output;\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    \/\/ Read n\n    let n: usize = lines.next().unwrap().unwrap().trim().parse().unwrap();\n\n    \/\/ Read the sequence\n    let sequence: Vec<u32> = lines\n        .next()\n        .unwrap()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    \/\/ Calculate the sum of all elements\n    let sum: u32 = sequence.iter().sum();\n\n    \/\/ Find the indices where the element equals the arithmetic mean\n    let indices: Vec<usize> = sequence\n        .iter()\n        .enumerate()\n        .filter(|&(i, &x)| x * (n as u32) == sum - x)\n        .map(|(i, _)| i + 1)\n        .collect();\n\n    \/\/ Print the number of sought indices\n    println!(\"{}\", indices.len());\n\n    \/\/ Print the sought indices in increasing order\n    for index in indices {\n        print!(\"{} \", index);\n    }\n    println!();\n}"}
{"title":"E. Omkar and Last Floor","description":"Omkar is building a house. He wants to decide how to make the floor plan for the last floor.Omkar's floor starts out as $$$n$$$ rows of $$$m$$$ zeros ($$$1 \\le n,m \\le 100$$$). Every row is divided into intervals such that every $$$0$$$ in the row is in exactly $$$1$$$ interval. For every interval for every row, Omkar can change exactly one of the $$$0$$$s contained in that interval to a $$$1$$$. Omkar defines the quality of a floor as the sum of the squares of the sums of the values in each column, i. e. if the sum of the values in the $$$i$$$-th column is $$$q_i$$$, then the quality of the floor is $$$\\sum_{i = 1}^m q_i^2$$$.Help Omkar find the maximum quality that the floor can have.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers, $$$n$$$ and $$$m$$$ ($$$1 \\\\le n,m \\\\le 100$$$), which are the number of rows and number of columns, respectively.\nYou will then receive a description of the intervals in each row. For every row $$$i$$$ from $$$1$$$ to $$$n$$$: The first row contains a single integer $$$k_i$$$ ($$$1 \\\\le k_i \\\\le m$$$), which is the number of intervals on row $$$i$$$. The $$$j$$$-th of the next $$$k_i$$$ lines contains two integers $$$l_{i,j}$$$ and $$$r_{i,j}$$$, which are the left and right bound (both inclusive), respectively, of the $$$j$$$-th interval of the $$$i$$$-th row. It is guaranteed that all intervals other than the first interval will be directly after the interval before it. Formally, $$$l_{i,1} = 1$$$, $$$l_{i,j} \\\\leq r_{i,j}$$$ for all $$$1 \\\\le j \\\\le k_i$$$, $$$r_{i,j-1} + 1 = l_{i,j}$$$ for all $$$2 \\\\le j \\\\le k_i$$$, and $$$r_{i,k_i} = m$$$.\n","output_spec":"Output one integer, which is the maximum possible quality of an eligible floor plan.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1372-E","difficulty":2900,"tags":["dp","greedy","two+pointers"],"src_uid":"a493914a91add305043ecc35823e99f8","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    vector<vector<int>> intervals(n);\\n    for (int i = 0; i < n; i++) {\\n        int k;\\n        cin >> k;\\n        intervals[i].resize(k);\\n        for (int j = 0; j < k; j++) {\\n            cin >> intervals[i][j].first >> intervals[i][j].second;\\n        }\\n    }\\n\\n    int maxQuality = 0;\\n    for (int i = 0; i < m; i++) {\\n        vector<int> column(n, 0);\\n        for (int j = 0; j < n; j++) {\\n            for (int k = 0; k < intervals[j].size(); k++) {\\n                if (intervals[j][k].first <= i+1 && intervals[j][k].second >= i+1) {\\n                    column[j] = 1;\\n                    break;\\n                }\\n            }\\n        }\\n        int columnSum = accumulate(column.begin(), column.end(), 0);\\n        maxQuality += columnSum * columnSum;\\n    }\\n\\n    cout << maxQuality << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        int[][] intervals = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            int k = scanner.nextInt();\n            for (int j = 0; j < k; j++) {\n                int l = scanner.nextInt();\n                int r = scanner.nextInt();\n                for (int x = l - 1; x < r; x++) {\n                    intervals[i][x] = 1;\n                }\n            }\n        }\n        \n        int[] columnSums = new int[m];\n        for (int j = 0; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                columnSums[j] += intervals[i][j];\n            }\n        }\n        \n        int maxQuality = 0;\n        for (int j = 0; j < m; j++) {\n            maxQuality += columnSums[j] * columnSums[j];\n        }\n        \n        System.out.println(maxQuality);\n    }\n}","Python":"def max_quality(n, m, intervals):\n    floor = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(len(intervals[i])):\n            l, r = intervals[i][j]\n            for k in range(l-1, r):\n                floor[i][k] = 1\n    \n    column_sums = [sum(col) for col in zip(*floor)]\n    quality = sum([sum(col)**2 for col in zip(*column_sums)])\n    \n    return quality\n\n# Read input\nn, m = map(int, input().split())\nintervals = []\nfor _ in range(n):\n    k = int(input())\n    row_intervals = []\n    for _ in range(k):\n        l, r = map(int, input().split())\n        row_intervals.append((l, r))\n    intervals.append(row_intervals)\n\n# Calculate and print the maximum quality\nprint(max_quality(n, m, intervals))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int intervals[n][m];\\n    for (int i = 0; i < n; i++) {\\n        int k;\\n        scanf(\\\"%d\\\", &k);\\n        for (int j = 0; j < k; j++) {\\n            int l, r;\\n            scanf(\\\"%d %d\\\", &l, &r);\\n            for (int x = l - 1; x < r; x++) {\\n                intervals[i][x] = 1;\\n            }\\n        }\\n    }\\n    int quality = 0;\\n    for (int j = 0; j < m; j++) {\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += intervals[i][j];\\n        }\\n        quality += sum * sum;\\n    }\\n    printf(\\\"%d\\\", quality);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace FloorPlan\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read input\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            \/\/ Initialize floor plan\n            int[][] floorPlan = new int[n][];\n            for (int i = 0; i < n; i++)\n            {\n                floorPlan[i] = new int[m];\n            }\n\n            \/\/ Read intervals for each row\n            for (int i = 0; i < n; i++)\n            {\n                int k = int.Parse(Console.ReadLine());\n                for (int j = 0; j < k; j++)\n                {\n                    string[] interval = Console.ReadLine().Split();\n                    int left = int.Parse(interval[0]) - 1;\n                    int right = int.Parse(interval[1]) - 1;\n\n                    \/\/ Update floor plan\n                    for (int col = left; col <= right; col++)\n                    {\n                        floorPlan[i][col] = 1;\n                    }\n                }\n            }\n\n            \/\/ Calculate quality of the floor plan\n            int[] columnSums = new int[m];\n            for (int col = 0; col < m; col++)\n            {\n                for (int row = 0; row < n; row++)\n                {\n                    columnSums[col] += floorPlan[row][col];\n                }\n            }\n\n            int quality = columnSums.Sum(x => x * x);\n\n            \/\/ Print the maximum quality\n            Console.WriteLine(quality);\n        }\n    }\n}","Ruby":"def max_quality(n, m, intervals)\n  # Initialize a 2D array to represent the floor plan\n  floor = Array.new(n) { Array.new(m, 0) }\n\n  # Iterate through each row\n  intervals.each_with_index do |row_intervals, i|\n    # Iterate through each interval in the row\n    row_intervals.each do |interval|\n      # Set the corresponding values in the floor plan to 1\n      (interval[0]..interval[1]).each do |j|\n        floor[i][j] = 1\n      end\n    end\n  end\n\n  # Calculate the quality of the floor plan\n  quality = 0\n  (0...m).each do |j|\n    column_sum = 0\n    (0...n).each do |i|\n      column_sum += floor[i][j]\n    end\n    quality += column_sum**2\n  end\n\n  return quality\nend\n\n# Read input from standard input\nn, m = gets.chomp.split.map(&:to_i)\nintervals = []\n(0...n).each do\n  k = gets.chomp.to_i\n  row_intervals = []\n  (0...k).each do\n    l, r = gets.chomp.split.map(&:to_i)\n    row_intervals << [l-1, r-1] # Adjust indices to 0-based\n  end\n  intervals << row_intervals\nend\n\n# Calculate and print the maximum quality\nputs max_quality(n, m, intervals)\n","delphi":"program MaximumQuality;\\n\\nvar\\n  n, m, i, j, k, l, r, maxQuality: integer;\\n  intervals: array[1..100, 1..2] of integer;\\n\\nbegin\\n  readln(n, m);\\n  maxQuality := 0;\\n\\n  for i := 1 to n do\\n  begin\\n    readln(k);\\n    for j := 1 to k do\\n    begin\\n      readln(l, r);\\n      intervals[j, 1] := l;\\n      intervals[j, 2] := r;\\n    end;\\n\\n    for j := 1 to m do\\n    begin\\n      for k := 1 to l do\\n      begin\\n        if (k >= intervals[j, 1]) and (k <= intervals[j, 2]) then\\n          maxQuality := maxQuality + 1;\\n      end;\\n    end;\\n  end;\\n\\n  writeln(maxQuality);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scan(&n, &m)\\n\\n\\tintervals := make([][]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar k int\\n\\t\\tfmt.Scan(&k)\\n\\n\\t\\tintervals[i] = make([]int, 2*k)\\n\\n\\t\\tfor j := 0; j < 2*k; j += 2 {\\n\\t\\t\\tfmt.Scan(&intervals[i][j], &intervals[i][j+1])\\n\\t\\t}\\n\\t}\\n\\n\\tmaxQuality := 0\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := i; j < m; j++ {\\n\\t\\t\\tquality := 0\\n\\n\\t\\t\\tfor _, interval := range intervals {\\n\\t\\t\\t\\tsum := 0\\n\\n\\t\\t\\t\\tfor k := 0; k < len(interval); k += 2 {\\n\\t\\t\\t\\t\\tif interval[k] >= i+1 && interval[k+1] <= j+1 {\\n\\t\\t\\t\\t\\t\\tsum += interval[k+1] - interval[k] + 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tquality += sum * sum\\n\\t\\t\\t}\\n\\n\\t\\t\\tif quality > maxQuality {\\n\\t\\t\\t\\tmaxQuality = quality\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxQuality)\\n}","Javascript":"function findMaxQuality(n, m, intervals) {\n    let floor = Array.from(Array(n), () => Array(m).fill(0)); \/\/ Initialize floor with all zeros\n    \n    \/\/ Iterate through each row\n    for (let i = 0; i < n; i++) {\n        let k = intervals[i][0]; \/\/ Number of intervals in current row\n        \n        \/\/ Iterate through each interval in current row\n        for (let j = 1; j <= k; j++) {\n            let left = intervals[i][j][0]; \/\/ Left bound of interval\n            let right = intervals[i][j][1]; \/\/ Right bound of interval\n            \n            \/\/ Find the column with the maximum sum in the current interval\n            let maxSum = 0;\n            let maxColumn = -1;\n            for (let col = left; col <= right; col++) {\n                let sum = 0;\n                for (let row = 0; row < n; row++) {\n                    sum += floor[row][col];\n                }\n                if (sum > maxSum) {\n                    maxSum = sum;\n                    maxColumn = col;\n                }\n            }\n            \n            \/\/ Change the value in the maximum sum column to 1\n            floor[i][maxColumn] = 1;\n        }\n    }\n    \n    \/\/ Calculate the quality of the floor\n    let quality = 0;\n    for (let col = 0; col < m; col++) {\n        let sum = 0;\n        for (let row = 0; row < n; row++) {\n            sum += floor[row][col];\n        }\n        quality += sum * sum;\n    }\n    \n    return quality;\n}\n\n\/\/ Example usage\nlet n = 3;\nlet m = 4;\nlet intervals = [\n    [2, [1, 2], [3, 4]],\n    [1, [1, 4]],\n    [3, [1, 1], [2, 2], [3, 4]]\n];\n\nlet maxQuality = findMaxQuality(n, m, intervals);\nconsole.log(maxQuality);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n    val intervals = Array(n) { IntArray(m) }\n    for (i in 0 until n) {\n        val k = scanner.nextInt()\n        for (j in 0 until k) {\n            val l = scanner.nextInt()\n            val r = scanner.nextInt()\n            for (x in l - 1 until r) {\n                intervals[i][x] = 1\n            }\n        }\n    }\n    var maxQuality = 0\n    for (j in 0 until m) {\n        var columnSum = 0\n        for (i in 0 until n) {\n            columnSum += intervals[i][j]\n        }\n        maxQuality += columnSum * columnSum\n    }\n    println(maxQuality)\n}","PHP":"<?php\\n\\nfunction calculateQuality($n, $m, $intervals) {\\n    $floor = array_fill(0, $n, array_fill(0, $m, 0));\\n\\n    foreach ($intervals as $row => $rowIntervals) {\\n        foreach ($rowIntervals as $interval) {\\n            for ($i = $interval[0]; $i <= $interval[1]; $i++) {\\n                $floor[$row][$i - 1] = 1;\\n            }\\n        }\\n    }\\n\\n    $columnSums = array_fill(0, $m, 0);\\n\\n    for ($i = 0; $i < $m; $i++) {\\n        for ($j = 0; $j < $n; $j++) {\\n            $columnSums[$i] += $floor[$j][$i];\\n        }\\n    }\\n\\n    $quality = 0;\\n\\n    foreach ($columnSums as $sum) {\\n        $quality += $sum * $sum;\\n    }\\n\\n    return $quality;\\n}\\n\\n\/\/ Example usage\\n$n = 3;\\n$m = 4;\\n$intervals = [\\n    [[1, 2], [3, 4]],\\n    [[1, 1], [3, 3]],\\n    [[2, 3], [4, 4]],\\n];\\n\\n$result = calculateQuality($n, $m, $intervals);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] intervals = new int[][](n);\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        int k;\\r\\n        readf(\\\"%d\\\", &k);\\r\\n\\r\\n        intervals[i] = new int[k * 2];\\r\\n\\r\\n        for (int j = 0; j < k; j++)\\r\\n        {\\r\\n            readf(\\\"%d %d\\\", &intervals[i][j * 2], &intervals[i][j * 2 + 1]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[][] floor = new int[][](n);\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        floor[i] = new int[m];\\r\\n\\r\\n        for (int j = 0; j < m; j++)\\r\\n        {\\r\\n            floor[i][j] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int maxQuality = 0;\\r\\n\\r\\n    void backtrack(int row, int col, int[][] floor, int[][] intervals)\\r\\n    {\\r\\n        if (row == n)\\r\\n        {\\r\\n            int[] columnSums = new int[m];\\r\\n\\r\\n            for (int j = 0; j < m; j++)\\r\\n            {\\r\\n                for (int i = 0; i < n; i++)\\r\\n                {\\r\\n                    columnSums[j] += floor[i][j];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            int quality = columnSums.map!(x => x * x).sum;\\r\\n\\r\\n            if (quality > maxQuality)\\r\\n            {\\r\\n                maxQuality = quality;\\r\\n            }\\r\\n\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < intervals[row].length; i += 2)\\r\\n        {\\r\\n            for (int j = intervals[row][i]; j <= intervals[row][i + 1]; j++)\\r\\n            {\\r\\n                floor[row][j - 1] = 1;\\r\\n            }\\r\\n\\r\\n            backtrack(row + 1, 0, floor, intervals);\\r\\n\\r\\n            for (int j = intervals[row][i]; j <= intervals[row][i + 1]; j++)\\r\\n            {\\r\\n                floor[row][j - 1] = 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    backtrack(0, 0, floor, intervals);\\r\\n\\r\\n    writeln(maxQuality);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_quality {\n    my ($n, $m, $intervals) = @_;\n\n    my @floor = ();\n    for (my $i = 0; $i < $n; $i++) {\n        push @floor, [(0) x $m];\n    }\n\n    foreach my $row (@$intervals) {\n        my ($k, @intervals) = @$row;\n        for (my $i = 0; $i < $k; $i++) {\n            my ($l, $r) = @{$intervals[$i]};\n            for (my $j = $l - 1; $j < $r; $j++) {\n                $floor[$i][$j] = 1;\n            }\n        }\n    }\n\n    my @column_sums = ();\n    for (my $j = 0; $j < $m; $j++) {\n        my $sum = 0;\n        for (my $i = 0; $i < $n; $i++) {\n            $sum += $floor[$i][$j];\n        }\n        push @column_sums, $sum;\n    }\n\n    my $quality = 0;\n    foreach my $sum (@column_sums) {\n        $quality += $sum ** 2;\n    }\n\n    return $quality;\n}\n\n# Read input\nmy ($n, $m) = split ' ', <STDIN>;\nmy @intervals = ();\nfor (my $i = 0; $i < $n; $i++) {\n    my $k = <STDIN>;\n    my @row_intervals = ();\n    for (my $j = 0; $j < $k; $j++) {\n        my ($l, $r) = split ' ', <STDIN>;\n        push @row_intervals, [$l, $r];\n    }\n    push @intervals, [$k, @row_intervals];\n}\n\n# Calculate and print the maximum quality\nmy $max_quality = calculate_quality($n, $m, \\@intervals);\nprint $max_quality;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut input_iter = input.trim().split_whitespace();\\n    let n: usize = input_iter.next().unwrap().parse().unwrap();\\n    let m: usize = input_iter.next().unwrap().parse().unwrap();\\n\\n    let mut intervals = vec![vec![]; n];\\n\\n    for i in 0..n {\\n        let mut input = String::new();\\n        std::io::stdin().read_line(&mut input).unwrap();\\n        let mut input_iter = input.trim().split_whitespace();\\n        let k: usize = input_iter.next().unwrap().parse().unwrap();\\n\\n        for _ in 0..k {\\n            let l: usize = input_iter.next().unwrap().parse().unwrap();\\n            let r: usize = input_iter.next().unwrap().parse().unwrap();\\n            intervals[i].push((l, r));\\n        }\\n    }\\n\\n    let mut max_quality = 0;\\n\\n    for i in 0..m {\\n        let mut column_sum = 0;\\n\\n        for j in 0..n {\\n            let mut row_sum = 0;\\n\\n            for interval in &intervals[j] {\\n                if interval.0 <= i + 1 && i + 1 <= interval.1 {\\n                    row_sum += 1;\\n                }\\n            }\\n\\n            column_sum += row_sum;\\n        }\\n\\n        max_quality += column_sum * column_sum;\\n    }\\n\\n    println!(\\\"{}\\\", max_quality);\\n}"}
{"title":"B. Permutation","description":"\"Hey, it's homework time\" \u2014 thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.The sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.You are given an arbitrary sequence a1,a2,...,an containing n integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input data contains an integer n (1\u2264n\u22645000) which represents how many numbers are in the sequence. The second line contains a sequence of integers ai (1\u2264ai\u22645000,1\u2264i\u2264n).\n","output_spec":"Print the only number \u2014 the minimum number of changes needed to get the permutation.\n","notes":"The first sample contains the permutation, which is why no replacements are required.\nIn the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.\nIn the third sample we can replace the second element with number 4 and the fourth element with number 2.\n","sample_inputs":["3\n3 1 2\n","2\n2 2\n","5\n5 3 3 3 1\n"],"sample_outputs":["0\n","1\n","2\n"],"id":"137-B","difficulty":1000,"tags":["greedy"],"src_uid":"bdd86c8bc54bbac6e2bb5a9d68b6eb1c","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> sequence(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> sequence[i];\\n    }\\n\\n    vector<bool> present(n + 1, false);\\n    int changes = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (sequence[i] >= 1 && sequence[i] <= n) {\\n            present[sequence[i]] = true;\\n        }\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        if (!present[i]) {\\n            changes++;\\n        }\\n    }\\n\\n    cout << changes << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class MinimumChangesForPermutation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] sequence = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            sequence[i] = scanner.nextInt();\n        }\n        \n        int[] count = new int[n + 1];\n        int changes = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (sequence[i] >= 1 && sequence[i] <= n) {\n                count[sequence[i]]++;\n            } else {\n                changes++;\n            }\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (count[i] == 0) {\n                changes++;\n            }\n        }\n        \n        System.out.println(changes);\n    }\n}","Python":"def minimum_changes(n, sequence):\n    count = [0] * (n+1)\n    for num in sequence:\n        if num <= n:\n            count[num] += 1\n    return n - max(count[1:]) + 1\n\ninput_data = ['3\\n3 1 2\\n', '2\\n2 2\\n', '5\\n5 3 3 3 1\\n']\noutput_data = []\n\nfor data in input_data:\n    data = data.strip().split('\\n')\n    n = int(data[0])\n    sequence = list(map(int, data[1].split()))\n    output = minimum_changes(n, sequence)\n    output_data.append(str(output) + '\\\\n')\n\nresult = [{\"version\": \"Python 3\", \"source code\": inspect.getsource(minimum_changes)}]\nresult.append({\"version\": \"Python 3\", \"source code\": inspect.getsource(main)})\n\njson.dumps(result)","C":"#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\\\"%d\\\", &n);\n    \n    int sequence[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\\\"%d\\\", &sequence[i]);\n    }\n    \n    int count[5001] = {0};\n    for (int i = 0; i < n; i++) {\n        count[sequence[i]]++;\n    }\n    \n    int changes = 0;\n    for (int i = 1; i <= n; i++) {\n        if (count[i] == 0) {\n            changes++;\n        }\n    }\n    \n    printf(\\\"%d\\\\n\\\", changes);\n    \n    return 0;\n}","C#":"\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] sequence = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        \n        int[] count = new int[n + 1];\n        foreach (int num in sequence)\n        {\n            if (num >= 1 && num <= n)\n            {\n                count[num]++;\n            }\n        }\n        \n        int changes = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (count[i] == 0)\n            {\n                changes++;\n            }\n        }\n        \n        Console.WriteLine(changes);\n    }\n}\n","Ruby":"\ndef minimum_changes(n, sequence)\n  # Create a hash to keep track of the frequency of each number in the sequence\n  frequency = Hash.new(0)\n  \n  # Iterate through the sequence and update the frequency hash\n  sequence.each do |num|\n    frequency[num] += 1\n  end\n  \n  # Initialize the minimum changes needed to 0\n  min_changes = 0\n  \n  # Iterate from 1 to n and check if each number is present in the sequence\n  # If a number is not present or its frequency is greater than 1, increment the minimum changes needed\n  (1..n).each do |num|\n    if frequency[num] == 0 || frequency[num] > 1\n      min_changes += 1\n    end\n  end\n  \n  return min_changes\nend\n\n# Read the input from standard input\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nsequence = input[1].split(' ').map(&:to_i)\n\n# Call the minimum_changes method and print the result\nputs minimum_changes(n, sequence)\n","delphi":"program MinimumChanges;\n\nvar\n  n, i, num, changes: Integer;\n  sequence: array of Integer;\n  count: array[1..5000] of Boolean;\n\nbegin\n  \/\/ Read the number of elements in the sequence\n  ReadLn(n);\n  \n  \/\/ Initialize the count array\n  for i := 1 to 5000 do\n    count[i] := False;\n  \n  \/\/ Read the sequence of integers\n  SetLength(sequence, n);\n  for i := 1 to n do\n  begin\n    Read(num);\n    sequence[i] := num;\n    count[num] := True;\n  end;\n  \n  \/\/ Count the number of elements that need to be changed\n  changes := 0;\n  for i := 1 to n do\n  begin\n    if not count[i] then\n      Inc(changes);\n  end;\n  \n  \/\/ Print the minimum number of changes needed\n  WriteLn(changes);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar sequence string\\n\\tfmt.Scan(&sequence)\\n\\n\\tsequenceArr := strings.Split(sequence, \\\" \\\")\\n\\n\\tcount := make([]int, n+1)\\n\\n\\tfor _, num := range sequenceArr {\\n\\t\\tnumInt := parseInt(num)\\n\\t\\tcount[numInt]++\\n\\t}\\n\\n\\tchanges := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif count[i] == 0 {\\n\\t\\t\\tchanges++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(changes)\\n}\\n\\nfunc parseInt(s string) int {\\n\\tvar num int\\n\\tfmt.Sscanf(s, \\\"%d\\\", &num)\\n\\treturn num\\n}","Javascript":"function minimumChanges(n, sequence) {\n    let count = 0;\n    let numbers = new Set(sequence);\n\n    for (let i = 1; i <= n; i++) {\n        if (!numbers.has(i)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\nconst input = '5\\\\n5 3 3 3 1\\\\n';\nconst lines = input.split('\\\\n');\nconst n = parseInt(lines[0]);\nconst sequence = lines[1].split(' ').map(Number);\n\nconst result = minimumChanges(n, sequence);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val sequence = IntArray(n)\n    val count = IntArray(n + 1)\n    \n    for (i in 0 until n) {\n        sequence[i] = scanner.nextInt()\n        count[sequence[i]]++\n    }\n    \n    var changes = 0\n    for (i in 1..n) {\n        if (count[i] == 0 || count[i] > 1) {\n            changes++\n        }\n    }\n    \n    println(changes)\n}","PHP":"\n<?php\n\nfunction minimumChanges($n, $sequence) {\n    $count = array_fill(1, $n, 0);\n    \n    foreach ($sequence as $num) {\n        if ($num >= 1 && $num <= $n) {\n            $count[$num]++;\n        }\n    }\n    \n    $changes = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        if ($count[$i] == 0) {\n            $changes++;\n        }\n    }\n    \n    return $changes;\n}\n\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\n$n = intval($input[0]);\n$sequence = array_map('intval', explode(' ', $input[1]));\n\n$output = minimumChanges($n, $sequence);\necho $output;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] sequence;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    sequence = readln.split.map!(a => a.to!int).array;\\r\\n\\r\\n    \/\/ Sort the sequence\\r\\n    sequence.sort;\\r\\n\\r\\n    \/\/ Find the minimum number of changes needed\\r\\n    int changes = 0;\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        if (sequence[i] != i + 1)\\r\\n        {\\r\\n            changes++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(changes);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimum_changes {\n    my ($n, @sequence) = @_;\n\n    my %count;\n    foreach my $num (@sequence) {\n        $count{$num}++;\n    }\n\n    my $changes = 0;\n    for my $i (1..$n) {\n        if (!$count{$i}) {\n            $changes++;\n        }\n    }\n\n    return $changes;\n}\n\n# Read input\nmy $n = <>;\nchomp($n);\nmy $sequence = <>;\nchomp($sequence);\nmy @sequence = split(' ', $sequence);\n\n# Call the function and print the result\nmy $result = minimum_changes($n, @sequence);\nprint $result;\n","Rust":"\nuse std::collections::HashSet;\n\nfn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: usize = input.trim().parse().unwrap();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let sequence: Vec<usize> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut unique_elements: HashSet<usize> = HashSet::new();\n    let mut changes = 0;\n\n    for num in sequence {\n        if num <= n && !unique_elements.contains(&num) {\n            unique_elements.insert(num);\n        } else {\n            changes += 1;\n        }\n    }\n\n    let missing_elements = n - unique_elements.len();\n    changes += missing_elements;\n\n    println!(\"{}\", changes);\n}\n"}
{"title":"A. Literature Lesson","description":"Vera adores poems. All the poems Vera knows are divided into quatrains (groups of four lines) and in each quatrain some lines contain rhymes.Let's consider that all lines in the poems consist of lowercase Latin letters (without spaces). Letters \"a\", \"e\", \"i\", \"o\", \"u\" are considered vowels.Two lines rhyme if their suffixes that start from the k-th vowels (counting from the end) match. If a line has less than k vowels, then such line can't rhyme with any other line. For example, if k=1, lines commit and hermit rhyme (the corresponding suffixes equal it), and if k=2, they do not rhyme (ommit\u2260ermit).Today on a literature lesson Vera learned that quatrains can contain four different schemes of rhymes, namely the following ones (the same letters stand for rhyming lines):   Clerihew (aabb);  Alternating (abab);  Enclosed (abba). If all lines of a quatrain pairwise rhyme, then the quatrain can belong to any rhyme scheme (this situation is represented by aaaa).If all quatrains of a poem belong to the same rhyme scheme, then we can assume that the whole poem belongs to this rhyme scheme. If in each quatrain all lines pairwise rhyme, then the rhyme scheme of the poem is aaaa. Let us note that it doesn't matter whether lines from different quatrains rhyme with each other or not. In other words, it is possible that different quatrains aren't connected by a rhyme.Vera got a long poem as a home task. The girl has to analyse it and find the poem rhyme scheme. Help Vera cope with the task.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and k (1\u2264n\u22642500, 1\u2264k\u22645)\u00a0\u2014 the number of quatrains in the poem and the vowel's number, correspondingly. Next 4n lines contain the poem. Each line is not empty and only consists of small Latin letters. The total length of the lines does not exceed 10^4.\nIf we assume that the lines are numbered starting from 1, then the first quatrain contains lines number 1, 2, 3, 4; the second one contains lines number 5, 6, 7, 8; and so on.\n","output_spec":"Print the rhyme scheme of the poem as \"aabb\", \"abab\", \"abba\", \"aaaa\"; or \"NO\" if the poem does not belong to any of the above mentioned schemes.\n","notes":"In the last sample both quatrains have rhymes but finding the common scheme is impossible, so the answer is \"NO\".\n","sample_inputs":["1 1\nday\nmay\nsun\nfun\n","1 1\nday\nmay\ngray\nway\n","2 1\na\na\na\na\na\na\ne\ne\n","2 1\nday\nmay\nsun\nfun\ntest\nhill\nfest\nthrill\n"],"sample_outputs":["aabb\n","aaaa\n","aabb\n","NO\n"],"id":"138-A","difficulty":1600,"tags":["implementation"],"src_uid":"a17bac596b1f060209534cbffdf0f40e","C++":"#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isVowel(char c) {\\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n}\\n\\nstring getSuffix(string line, int k) {\\n    string suffix;\\n    int vowelCount = 0;\\n    for (int i = line.size() - 1; i >= 0; i--) {\\n        if (isVowel(line[i])) {\\n            vowelCount++;\\n            if (vowelCount == k) {\\n                suffix = line.substr(i);\\n                break;\\n            }\\n        }\\n    }\\n    return suffix;\\n}\\n\\nstring getRhymeScheme(vector<string>& poem, int k) {\\n    int n = poem.size() \/ 4;\\n    string rhymeScheme;\\n    bool allLinesRhyme = true;\\n    for (int i = 0; i < n; i++) {\\n        string a = getSuffix(poem[i * 4], k);\\n        string b = getSuffix(poem[i * 4 + 1], k);\\n        string c = getSuffix(poem[i * 4 + 2], k);\\n        string d = getSuffix(poem[i * 4 + 3], k);\\n        if (a == b && b == c && c == d) {\\n            rhymeScheme += 'a';\\n        } else if (a == c && b == d) {\\n            rhymeScheme += 'b';\\n        } else if (a == b && c == d) {\\n            rhymeScheme += 'b';\\n        } else if (a == d && b == c) {\\n            rhymeScheme += 'a';\\n        } else {\\n            allLinesRhyme = false;\\n            break;\\n        }\\n    }\\n    if (allLinesRhyme) {\\n        if (rhymeScheme.size() == 1) {\\n            rhymeScheme = \\\"aaaa\\\";\\n        } else {\\n            rhymeScheme = \\\"NO\\\";\\n        }\\n    }\\n    return rhymeScheme;\\n}\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<string> poem;\\n    for (int i = 0; i < 4 * n; i++) {\\n        string line;\\n        cin >> line;\\n        poem.push_back(line);\\n    }\\n    string rhymeScheme = getRhymeScheme(poem, k);\\n    cout << rhymeScheme << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class PoemRhymeScheme {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        scanner.nextLine();\n        \n        List<String> lines = new ArrayList<>();\n        for (int i = 0; i < 4 * n; i++) {\n            lines.add(scanner.nextLine());\n        }\n        \n        String rhymeScheme = findRhymeScheme(n, k, lines);\n        System.out.println(rhymeScheme);\n    }\n    \n    public static String findRhymeScheme(int n, int k, List<String> lines) {\n        boolean aabb = true;\n        boolean abab = true;\n        boolean abba = true;\n        boolean aaaa = true;\n        \n        for (int i = 0; i < n; i++) {\n            String line1 = lines.get(i * 4);\n            String line2 = lines.get(i * 4 + 1);\n            String line3 = lines.get(i * 4 + 2);\n            String line4 = lines.get(i * 4 + 3);\n            \n            if (!checkRhyme(line1, line2, k)) {\n                aabb = false;\n            }\n            if (!checkRhyme(line1, line3, k)) {\n                abab = false;\n            }\n            if (!checkRhyme(line1, line4, k)) {\n                abba = false;\n            }\n            if (!checkRhyme(line2, line3, k) || !checkRhyme(line2, line4, k) || !checkRhyme(line3, line4, k)) {\n                aaaa = false;\n            }\n        }\n        \n        if (aaaa) {\n            return \"aaaa\";\n        } else if (aabb) {\n            return \"aabb\";\n        } else if (abab) {\n            return \"abab\";\n        } else if (abba) {\n            return \"abba\";\n        } else {\n            return \"NO\";\n        }\n    }\n    \n    public static boolean checkRhyme(String line1, String line2, int k) {\n        int vowels1 = 0;\n        int vowels2 = 0;\n        \n        for (int i = line1.length() - 1; i >= 0; i--) {\n            char c = line1.charAt(i);\n            if (isVowel(c)) {\n                vowels1++;\n                if (vowels1 == k) {\n                    break;\n                }\n            }\n        }\n        \n        for (int i = line2.length() - 1; i >= 0; i--) {\n            char c = line2.charAt(i);\n            if (isVowel(c)) {\n                vowels2++;\n                if (vowels2 == k) {\n                    break;\n                }\n            }\n        }\n        \n        return line1.substring(line1.length() - vowels1).equals(line2.substring(line2.length() - vowels2));\n    }\n    \n    public static boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}","Python":"def find_rhyme_scheme(poem):\n    n, k = map(int, poem[0].split())\n    quatrains = [poem[i:i+4] for i in range(1, len(poem), 4)]\n    \n    rhyme_schemes = ['aabb', 'abab', 'abba', 'aaaa']\n    \n    for scheme in rhyme_schemes:\n        valid = True\n        for quatrain in quatrains:\n            vowels = []\n            for line in quatrain:\n                vowel_count = 0\n                for char in line[::-1]:\n                    if char in 'aeiou':\n                        vowel_count += 1\n                    if vowel_count == k:\n                        break\n                vowels.append(line[-vowel_count:])\n            \n            if len(set(vowels)) != len(vowels):\n                valid = False\n                break\n        \n        if valid:\n            return scheme\n    \n    return 'NO'\n\n# Sample inputs\npoems = [\n    '1 1\\\\nday\\\\nmay\\\\nsun\\\\nfun\\\\n',\n    '1 1\\\\nday\\\\nmay\\\\ngray\\\\nway\\\\n',\n    '2 1\\\\na\\\\na\\\\na\\\\na\\\\na\\\\na\\\\ne\\\\ne\\\\n',\n    '2 1\\\\nday\\\\nmay\\\\nsun\\\\nfun\\\\ntest\\\\nhill\\\\nfest\\\\nthrill\\\\n'\n]\n\n# Process each poem and print the rhyme scheme\nfor poem in poems:\n    poem = poem.split('\\\\n')\n    result = find_rhyme_scheme(poem)\n    print(result)\n","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint is_vowel(char c) {\\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n}\\n\\nchar* get_suffix(char* line, int k) {\\n    int vowels_count = 0;\\n    int i = strlen(line) - 1;\\n    while (vowels_count < k && i >= 0) {\\n        if (is_vowel(line[i])) {\\n            vowels_count++;\\n        }\\n        i--;\\n    }\\n    if (vowels_count < k) {\\n        return NULL;\\n    }\\n    return line + i + 1;\\n}\\n\\nchar* get_rhyme_scheme(int n, int k, char** lines) {\\n    char* rhyme_scheme = malloc((n + 1) * sizeof(char));\\n    int i;\\n    for (i = 0; i < n; i++) {\\n        char* suffix1 = get_suffix(lines[i * 4], k);\\n        char* suffix2 = get_suffix(lines[i * 4 + 1], k);\\n        char* suffix3 = get_suffix(lines[i * 4 + 2], k);\\n        char* suffix4 = get_suffix(lines[i * 4 + 3], k);\\n        if (suffix1 == NULL || suffix2 == NULL || suffix3 == NULL || suffix4 == NULL) {\\n            free(rhyme_scheme);\\n            return \\\"NO\\\";\\n        }\\n        if (strcmp(suffix1, suffix2) == 0 && strcmp(suffix2, suffix3) == 0 && strcmp(suffix3, suffix4) == 0) {\\n            rhyme_scheme[i] = 'a';\\n        } else if (strcmp(suffix1, suffix2) == 0 && strcmp(suffix3, suffix4) == 0) {\\n            rhyme_scheme[i] = 'b';\\n        } else if (strcmp(suffix1, suffix3) == 0 && strcmp(suffix2, suffix4) == 0) {\\n            rhyme_scheme[i] = 'c';\\n        } else if (strcmp(suffix1, suffix4) == 0 && strcmp(suffix2, suffix3) == 0) {\\n            rhyme_scheme[i] = 'd';\\n        } else {\\n            free(rhyme_scheme);\\n            return \\\"NO\\\";\\n        }\\n    }\\n    rhyme_scheme[n] = '\\\\0';\\n    return rhyme_scheme;\\n}\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    char** lines = malloc(4 * n * sizeof(char*));\\n    int i;\\n    for (i = 0; i < 4 * n; i++) {\\n        lines[i] = malloc(10001 * sizeof(char));\\n        scanf(\\\"%s\\\", lines[i]);\\n    }\\n    char* rhyme_scheme = get_rhyme_scheme(n, k, lines);\\n    printf(\\\"%s\\\\n\\\", rhyme_scheme);\\n    for (i = 0; i < 4 * n; i++) {\\n        free(lines[i]);\\n    }\\n    free(lines);\\n    free(rhyme_scheme);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace RhymeScheme\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = {\n                \\\"1 1\\\\nday\\\\nmay\\\\nsun\\\\nfun\\\\n\\\",\n                \\\"1 1\\\\nday\\\\nmay\\\\ngray\\\\nway\\\\n\\\",\n                \\\"2 1\\\\na\\\\na\\\\na\\\\na\\\\na\\\\na\\\\ne\\\\ne\\\\n\\\",\n                \\\"2 1\\\\nday\\\\nmay\\\\nsun\\\\nfun\\\\ntest\\\\nhill\\\\nfest\\\\nthrill\\\\n\\\"\n            };\n\n            string[] expectedOutputs = {\n                \\\"aabb\\\\n\\\",\n                \\\"aaaa\\\\n\\\",\n                \\\"aabb\\\\n\\\",\n                \\\"NO\\\\n\\\"\n            };\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                string input = inputs[i];\n                string expectedOutput = expectedOutputs[i];\n\n                string output = FindRhymeScheme(input);\n                Console.WriteLine(output == expectedOutput ? \\\"Test case passed\\\" : \\\"Test case failed\\\");\n            }\n        }\n\n        static string FindRhymeScheme(string input)\n        {\n            string[] lines = input.Split('\\\\n', StringSplitOptions.RemoveEmptyEntries);\n            string[] quatrainLines = new string[4];\n            List<string> rhymeSchemes = new List<string>();\n\n            int n, k;\n            string[] nk = lines[0].Split(' ');\n            n = int.Parse(nk[0]);\n            k = int.Parse(nk[1]);\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < 4; j++)\n                {\n                    quatrainLines[j] = lines[i * 4 + j + 1];\n                }\n\n                string rhymeScheme = GetRhymeScheme(quatrainLines, k);\n                if (rhymeScheme == \\\"NO\\\")\n                {\n                    return \\\"NO\\\\n\\\";\n                }\n                else\n                {\n                    rhymeSchemes.Add(rhymeScheme);\n                }\n            }\n\n            string commonRhymeScheme = GetCommonRhymeScheme(rhymeSchemes);\n            return commonRhymeScheme != \\\"NO\\\" ? commonRhymeScheme + \\\"\\\\n\\\" : \\\"NO\\\\n\\\";\n        }\n\n        static string GetRhymeScheme(string[] quatrainLines, int k)\n        {\n            bool aabb = IsAABB(quatrainLines, k);\n            bool abab = IsABAB(quatrainLines, k);\n            bool abba = IsABBA(quatrainLines, k);\n            bool aaaa = IsAAAA(quatrainLines, k);\n\n            if (aabb)\n            {\n                return \\\"aabb\\\";\n            }\n            else if (abab)\n            {\n                return \\\"abab\\\";\n            }\n            else if (abba)\n            {\n                return \\\"abba\\\";\n            }\n            else if (aaaa)\n            {\n                return \\\"aaaa\\\";\n            }\n            else\n            {\n                return \\\"NO\\\";\n            }\n        }\n\n        static bool IsAABB(string[] quatrainLines, int k)\n        {\n            string suffix1 = GetSuffix(quatrainLines[0], k);\n            string suffix2 = GetSuffix(quatrainLines[1], k);\n            string suffix3 = GetSuffix(quatrainLines[2], k);\n            string suffix4 = GetSuffix(quatrainLines[3], k);\n\n            return suffix1 == suffix2 && suffix3 == suffix4 && suffix1 != suffix3;\n        }\n\n        static bool IsABAB(string[] quatrainLines, int k)\n        {\n            string suffix1 = GetSuffix(quatrainLines[0], k);\n            string suffix2 = GetSuffix(quatrainLines[1], k);\n            string suffix3 = GetSuffix(quatrainLines[2], k);\n            string suffix4 = GetSuffix(quatrainLines[3], k);\n\n            return suffix1 == suffix3 && suffix2 == suffix4 && suffix1 != suffix2;\n        }\n\n        static bool IsABBA(string[] quatrainLines, int k)\n        {\n            string suffix1 = GetSuffix(quatrainLines[0], k);\n            string suffix2 = GetSuffix(quatrainLines[1], k);\n            string suffix3 = GetSuffix(quatrainLines[2], k);\n            string suffix4 = GetSuffix(quatrainLines[3], k);\n\n            return suffix1 == suffix4 && suffix2 == suffix3 && suffix1 != suffix2;\n        }\n\n        static bool IsAAAA(string[] quatrainLines, int k)\n        {\n            string suffix1 = GetSuffix(quatrainLines[0], k);\n            string suffix2 = GetSuffix(quatrainLines[1], k);\n            string suffix3 = GetSuffix(quatrainLines[2], k);\n            string suffix4 = GetSuffix(quatrainLines[3], k);\n\n            return suffix1 == suffix2 && suffix2 == suffix3 && suffix3 == suffix4;\n        }\n\n        static string GetSuffix(string line, int k)\n        {\n            string vowels = \\\"aeiou\\\";\n            string suffix = \\\"\\\";\n\n            int vowelCount = 0;\n            for (int i = line.Length - 1; i >= 0; i--)\n            {\n                if (vowels.Contains(line[i]))\n                {\n                    vowelCount++;\n                    if (vowelCount >= k)\n                    {\n                        suffix = line.Substring(i);\n                        break;\n                    }\n                }\n            }\n\n            return suffix;\n        }\n\n        static string GetCommonRhymeScheme(List<string> rhymeSchemes)\n        {\n            string commonRhymeScheme = rhymeSchemes[0];\n            for (int i = 1; i < rhymeSchemes.Count; i++)\n            {\n                if (rhymeSchemes[i] != commonRhymeScheme)\n                {\n                    return \\\"NO\\\";\n                }\n            }\n\n            return commonRhymeScheme;\n        }\n    }\n}","Ruby":"\ndef find_rhyme_scheme(poem)\n  n, k = poem.shift.split.map(&:to_i)\n  quatrains = poem.each_slice(4).to_a\n\n  rhyme_schemes = [\"aabb\", \"abab\", \"abba\", \"aaaa\"]\n  rhyme_scheme = nil\n\n  quatrains.each do |quatrain|\n    vowels = quatrain.map { |line| line.scan(\/[aeiou]\/) }\n    rhyme_scheme = \"aaaa\" if vowels.all? { |v| v.size >= k }\n\n    if rhyme_scheme.nil?\n      rhyme_scheme = \"aabb\" if vowels[0][-k..-1] == vowels[1][-k..-1] && vowels[2][-k..-1] == vowels[3][-k..-1]\n      rhyme_scheme = \"abab\" if vowels[0][-k..-1] == vowels[2][-k..-1] && vowels[1][-k..-1] == vowels[3][-k..-1]\n      rhyme_scheme = \"abba\" if vowels[0][-k..-1] == vowels[3][-k..-1] && vowels[1][-k..-1] == vowels[2][-k..-1]\n    end\n\n    break if rhyme_scheme.nil?\n  end\n\n  rhyme_scheme.nil? ? \"NO\" : rhyme_scheme\nend\n\npoems = [\n  '1 1\\nday\\nmay\\nsun\\nfun\\n',\n  '1 1\\nday\\nmay\\ngray\\nway\\n',\n  '2 1\\na\\na\\na\\na\\na\\na\\ne\\ne\\n',\n  '2 1\\nday\\nmay\\nsun\\nfun\\ntest\\nhill\\nfest\\nthrill\\n'\n]\n\nresults = poems.map { |poem| find_rhyme_scheme(poem.split(\"\\n\")) }\nresults.each { |result| puts result }\n","delphi":"program RhymeScheme;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction GetVowelCount(const line: string): Integer;\nvar\n  i: Integer;\nbegin\n  Result := 0;\n  for i := Length(line) downto 1 do\n  begin\n    if line[i] in ['a', 'e', 'i', 'o', 'u'] then\n      Inc(Result);\n  end;\nend;\n\nfunction GetSuffix(const line: string; k: Integer): string;\nvar\n  i, vowelCount: Integer;\nbegin\n  vowelCount := 0;\n  for i := Length(line) downto 1 do\n  begin\n    if line[i] in ['a', 'e', 'i', 'o', 'u'] then\n    begin\n      Inc(vowelCount);\n      if vowelCount = k then\n      begin\n        Result := Copy(line, i, Length(line) - i + 1);\n        Exit;\n      end;\n    end;\n  end;\n  Result := '';\nend;\n\nfunction GetRhymeScheme(const poem: string; k: Integer): string;\nvar\n  lines: TStringList;\n  i, j, n: Integer;\n  suffixes: array of string;\n  rhymeScheme: string;\n  isRhyme: Boolean;\nbegin\n  lines := TStringList.Create;\n  lines.Text := poem;\n  \n  n := lines.Count div 4;\n  SetLength(suffixes, n * 4);\n  \n  for i := 0 to n - 1 do\n  begin\n    for j := 0 to 3 do\n    begin\n      suffixes[i * 4 + j] := GetSuffix(lines[i * 4 + j], k);\n    end;\n  end;\n  \n  isRhyme := True;\n  rhymeScheme := '';\n  \n  for i := 0 to n - 1 do\n  begin\n    if (suffixes[i * 4] = suffixes[i * 4 + 1]) and (suffixes[i * 4 + 1] = suffixes[i * 4 + 2]) and (suffixes[i * 4 + 2] = suffixes[i * 4 + 3]) then\n    begin\n      rhymeScheme := 'aaaa';\n    end\n    else if (suffixes[i * 4] = suffixes[i * 4 + 2]) and (suffixes[i * 4 + 1] = suffixes[i * 4 + 3]) then\n    begin\n      if rhymeScheme = '' then\n        rhymeScheme := 'abba'\n      else if rhymeScheme <> 'abba' then\n        isRhyme := False;\n    end\n    else if (suffixes[i * 4] = suffixes[i * 4 + 1]) and (suffixes[i * 4 + 2] = suffixes[i * 4 + 3]) then\n    begin\n      if rhymeScheme = '' then\n        rhymeScheme := 'aabb'\n      else if rhymeScheme <> 'aabb' then\n        isRhyme := False;\n    end\n    else if (suffixes[i * 4] = suffixes[i * 4 + 3]) and (suffixes[i * 4 + 1] = suffixes[i * 4 + 2]) then\n    begin\n      if rhymeScheme = '' then\n        rhymeScheme := 'abab'\n      else if rhymeScheme <> 'abab' then\n        isRhyme := False;\n    end\n    else\n    begin\n      isRhyme := False;\n    end;\n  end;\n  \n  if isRhyme then\n    Result := rhymeScheme\n  else\n    Result := 'NO';\n  \n  lines.Free;\nend;\n\nvar\n  n, k, i: Integer;\n  poem: string;\nbegin\n  ReadLn(n, k);\n  \n  poem := '';\n  for i := 1 to 4 * n do\n  begin\n    ReadLn(poem);\n  end;\n  \n  WriteLn(GetRhymeScheme(poem, k));\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnk := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nk[0])\\n\\tk, _ := strconv.Atoi(nk[1])\\n\\n\\tpoem := make([]string, 4*n)\\n\\tfor i := 0; i < 4*n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tpoem[i] = scanner.Text()\\n\\t}\\n\\n\\trhymeScheme := getRhymeScheme(poem, k)\\n\\tfmt.Println(rhymeScheme)\\n}\\n\\nfunc getRhymeScheme(poem []string, k int) string {\\n\\trhymeSchemes := []string{\\\"aabb\\\", \\\"abab\\\", \\\"abba\\\", \\\"aaaa\\\"}\\n\\n\\tfor _, scheme := range rhymeSchemes {\\n\\t\\tvalid := true\\n\\t\\tfor i := 0; i < len(poem); i += 4 {\\n\\t\\t\\trhymeGroup := poem[i : i+4]\\n\\t\\t\\tvalidGroup := true\\n\\t\\t\\tfor j := 0; j < len(rhymeGroup); j++ {\\n\\t\\t\\t\\tif !checkRhyme(rhymeGroup[j], k, scheme[j]) {\\n\\t\\t\\t\\t\\tvalidGroup = false\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif !validGroup {\\n\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif valid {\\n\\t\\t\\treturn scheme\\n\\t\\t}\\n\\t}\\n\\n\\treturn \\\"NO\\\"\\n}\\n\\nfunc checkRhyme(line string, k int, rhymeChar byte) bool {\\n\\tvowelCount := 0\\n\\tfor i := len(line) - 1; i >= 0; i-- {\\n\\t\\tif isVowel(line[i]) {\\n\\t\\t\\tvowelCount++\\n\\t\\t\\tif vowelCount == k {\\n\\t\\t\\t\\treturn line[i] == rhymeChar\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc isVowel(c byte) bool {\\n\\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\\n}","Javascript":"\nfunction findRhymeScheme(poem) {\n    const [n, k, ...lines] = poem.split('\\n').filter(Boolean);\n    const quatrains = [];\n    \n    for (let i = 0; i < n * 4; i += 4) {\n        quatrains.push(lines.slice(i, i + 4));\n    }\n    \n    const rhymeSchemes = ['aabb', 'abab', 'abba', 'aaaa'];\n    \n    for (const scheme of rhymeSchemes) {\n        let isValidScheme = true;\n        \n        for (const quatrain of quatrains) {\n            const rhymePairs = scheme.split('').map((letter, index) => {\n                return quatrain[index].split('').reverse().join('').match(\/[aeiou]\/g);\n            });\n            \n            if (!rhymePairs.every(pair => pair && pair.length >= k && pair.every((vowel, index) => vowel === rhymePairs[0][index]))) {\n                isValidScheme = false;\n                break;\n            }\n        }\n        \n        if (isValidScheme) {\n            return scheme;\n        }\n    }\n    \n    return 'NO';\n}\n\nconst poems = [\n    '1 1\\\\nday\\\\nmay\\\\nsun\\\\nfun\\\\n',\n    '1 1\\\\nday\\\\nmay\\\\ngray\\\\nway\\\\n',\n    '2 1\\\\na\\\\na\\\\na\\\\na\\\\na\\\\na\\\\ne\\\\ne\\\\n',\n    '2 1\\\\nday\\\\nmay\\\\nsun\\\\nfun\\\\ntest\\\\nhill\\\\nfest\\\\nthrill\\\\n'\n];\n\nconst results = [];\n\nfor (const poem of poems) {\n    const rhymeScheme = findRhymeScheme(poem);\n    results.push(rhymeScheme + '\\\\n');\n}\n\nJSON.stringify(results);\n","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nk = scanner.nextLine().split(\" \")\n    val n = nk[0].toInt()\n    val k = nk[1].toInt()\n\n    val poem = mutableListOf<String>()\n    repeat(4 * n) {\n        poem.add(scanner.nextLine())\n    }\n\n    val rhymeScheme = findRhymeScheme(poem, k)\n    println(rhymeScheme)\n}\n\nfun findRhymeScheme(poem: List<String>, k: Int): String {\n    val quatrains = poem.chunked(4)\n    val rhymeSchemes = mutableSetOf<String>()\n\n    for (quatrain in quatrains) {\n        val vowels = quatrain.map { countVowels(it) }\n        val scheme = when {\n            vowels[0] == vowels[1] && vowels[1] == vowels[2] && vowels[2] == vowels[3] -> \"aaaa\"\n            vowels[0] == vowels[1] && vowels[2] == vowels[3] -> \"aabb\"\n            vowels[0] == vowels[2] && vowels[1] == vowels[3] -> \"abab\"\n            vowels[0] == vowels[3] && vowels[1] == vowels[2] -> \"abba\"\n            else -> \"NO\"\n        }\n        rhymeSchemes.add(scheme)\n    }\n\n    return if (rhymeSchemes.size == 1) rhymeSchemes.first() else \"NO\"\n}\n\nfun countVowels(line: String): Int {\n    val vowels = setOf('a', 'e', 'i', 'o', 'u')\n    var count = 0\n    for (i in line.length - 1 downTo 0) {\n        if (line[i] in vowels) {\n            count++\n            if (count == k) {\n                break\n            }\n        }\n    }\n    return count\n}\n","PHP":"<?php\\n\\nfunction findRhymeScheme($n, $k, $poem) {\\n    $rhymeSchemes = ['aabb', 'abab', 'abba', 'aaaa'];\\n    $lines = explode(\\\"\\\\n\\\", $poem);\\n    $quatrains = array_chunk($lines, 4);\\n    $rhymeScheme = '';\\n\\n    foreach ($quatrains as $quatrain) {\\n        $rhymePairs = [];\\n\\n        foreach ($quatrain as $line) {\\n            $vowels = preg_match_all('\/[aeiou]\/', $line, $matches);\\n\\n            if ($vowels >= $k) {\\n                $suffix = implode('', array_slice($matches[0], -$k));\\n                $rhymePairs[] = $suffix;\\n            }\\n        }\\n\\n        $rhymePairs = array_unique($rhymePairs);\\n\\n        if (count($rhymePairs) === 1) {\\n            $rhymeScheme .= 'aaaa';\\n        } elseif (count($rhymePairs) === 2) {\\n            $rhymeScheme .= 'aabb';\\n        } elseif (count($rhymePairs) === 3) {\\n            $rhymeScheme .= 'abab';\\n        } elseif (count($rhymePairs) === 4) {\\n            $rhymeScheme .= 'abba';\\n        } else {\\n            return 'NO';\\n        }\\n    }\\n\\n    return $rhymeScheme;\\n}\\n\\n$input = '2 1\\\\na\\\\na\\\\na\\\\na\\\\na\\\\na\\\\ne\\\\ne\\\\n';\\nlist($n, $k, $poem) = explode(\\\"\\\\n\\\", $input);\\n$result = findRhymeScheme($n, $k, $poem);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring findRhymeScheme(int n, int k, string[] lines)\\r\\n{\\r\\n    string[] suffixes;\\r\\n    foreach (string line; lines)\\r\\n    {\\r\\n        int vowelCount = 0;\\r\\n        foreach (char c; line)\\r\\n        {\\r\\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\\r\\n                vowelCount++;\\r\\n        }\\r\\n        if (vowelCount >= k)\\r\\n        {\\r\\n            string suffix = line[line.length - k .. $];\\r\\n            suffixes ~= suffix;\\r\\n        }\\r\\n    }\\r\\n    if (suffixes.length == 0)\\r\\n        return \\\"NO\\\";\\r\\n    if (suffixes.length == 1)\\r\\n        return \\\"aaaa\\\";\\r\\n    if (suffixes.length % 4 != 0)\\r\\n        return \\\"NO\\\";\\r\\n    string[] schemes = [\\\"aabb\\\", \\\"abab\\\", \\\"abba\\\"];\\r\\n    foreach (string scheme; schemes)\\r\\n    {\\r\\n        bool valid = true;\\r\\n        for (int i = 0; i < suffixes.length; i += 4)\\r\\n        {\\r\\n            string[] quatrainSuffixes = suffixes[i .. i + 4];\\r\\n            if (!allEqual(quatrainSuffixes, scheme))\\r\\n            {\\r\\n                valid = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (valid)\\r\\n            return scheme;\\r\\n    }\\r\\n    return \\\"NO\\\";\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    readf(\\\"%d %d\\\\n\\\", &n, &k);\\r\\n    string[] lines;\\r\\n    foreach (_; 0 .. 4 * n)\\r\\n    {\\r\\n        string line;\\r\\n        readf(\\\"%s\\\\n\\\", &line);\\r\\n        lines ~= line;\\r\\n    }\\r\\n    string rhymeScheme = findRhymeScheme(n, k, lines);\\r\\n    writeln(rhymeScheme);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_rhyme_scheme {\n    my ($n, $k, @poem) = @_;\n\n    my @rhyme_schemes = ('aabb', 'abab', 'abba', 'aaaa');\n    my %rhyme_counts;\n\n    for (my $i = 0; $i < $n; $i++) {\n        my @quatrain = @poem[$i*4..$i*4+3];\n        my %rhyme_pairs;\n\n        foreach my $line (@quatrain) {\n            my $suffix = get_suffix($line, $k);\n            $rhyme_pairs{$suffix}++;\n        }\n\n        my $rhyme_count = scalar keys %rhyme_pairs;\n        $rhyme_counts{$rhyme_count}++;\n    }\n\n    if (scalar keys %rhyme_counts == 1) {\n        my $rhyme_count = (keys %rhyme_counts)[0];\n        return $rhyme_schemes[$rhyme_count-1];\n    } else {\n        return 'NO';\n    }\n}\n\nsub get_suffix {\n    my ($line, $k) = @_;\n\n    my @vowels = ('a', 'e', 'i', 'o', 'u');\n    my @line_vowels;\n\n    while ($line =~ \/[aeiou]\/g) {\n        push @line_vowels, $&;\n    }\n\n    if (scalar @line_vowels < $k) {\n        return '';\n    } else {\n        return join('', @line_vowels[-$k..-1]);\n    }\n}\n\n# Sample inputs\nmy @inputs = (\n    ['1 1\\nday\\nmay\\nsun\\nfun\\n'],\n    ['1 1\\nday\\nmay\\ngray\\nway\\n'],\n    ['2 1\\na\\na\\na\\na\\na\\na\\ne\\ne\\n'],\n    ['2 1\\nday\\nmay\\nsun\\nfun\\ntest\\nhill\\nfest\\nthrill\\n']\n);\n\n# Process sample inputs\nforeach my $input (@inputs) {\n    my ($n, $k, @poem) = split('\\n', $input);\n    my $rhyme_scheme = find_rhyme_scheme($n, $k, @poem);\n    print \"$rhyme_scheme\\n\";\n}\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    \/\/ Read input\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    let nk: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = nk[0];\n    let k = nk[1];\n\n    \/\/ Read poem lines\n    let mut poem_lines: Vec<String> = Vec::new();\n    for _ in 0..4 * n {\n        poem_lines.push(lines.next().unwrap());\n    }\n\n    \/\/ Check if lines rhyme\n    fn rhyme(a: &str, b: &str, k: usize) -> bool {\n        let vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n        let a_vowels: Vec<usize> = a\n            .chars()\n            .rev()\n            .enumerate()\n            .filter(|(_, c)| vowels.contains(c))\n            .map(|(i, _)| i)\n            .collect();\n        let b_vowels: Vec<usize> = b\n            .chars()\n            .rev()\n            .enumerate()\n            .filter(|(_, c)| vowels.contains(c))\n            .map(|(i, _)| i)\n            .collect();\n\n        if a_vowels.len() < k || b_vowels.len() < k {\n            return false;\n        }\n\n        for i in 0..k {\n            if a_vowels[i] != b_vowels[i] {\n                return false;\n            }\n        }\n\n        true\n    }\n\n    \/\/ Check rhyme scheme for a quatrain\n    fn check_rhyme_scheme(quatrain: &[String], k: usize) -> String {\n        let aabb = rhyme(&quatrain[0], &quatrain[1], k) && rhyme(&quatrain[2], &quatrain[3], k);\n        let abab = rhyme(&quatrain[0], &quatrain[2], k) && rhyme(&quatrain[1], &quatrain[3], k);\n        let abba = rhyme(&quatrain[0], &quatrain[3], k) && rhyme(&quatrain[1], &quatrain[2], k);\n        let aaaa = rhyme(&quatrain[0], &quatrain[1], k)\n            && rhyme(&quatrain[0], &quatrain[2], k)\n            && rhyme(&quatrain[0], &quatrain[3], k);\n\n        if aaaa {\n            return String::from(\"aaaa\");\n        } else if aabb {\n            return String::from(\"aabb\");\n        } else if abab {\n            return String::from(\"abab\");\n        } else if abba {\n            return String::from(\"abba\");\n        } else {\n            return String::from(\"NO\");\n        }\n    }\n\n    \/\/ Check rhyme scheme for the whole poem\n    let mut rhyme_scheme = String::new();\n    for i in 0..n {\n        let quatrain = &poem_lines[i * 4..(i * 4) + 4];\n        let quatrain_rhyme_scheme = check_rhyme_scheme(quatrain, k);\n        if i == 0 {\n            rhyme_scheme = quatrain_rhyme_scheme;\n        } else if rhyme_scheme != quatrain_rhyme_scheme {\n            rhyme_scheme = String::from(\"NO\");\n            break;\n        }\n    }\n\n    \/\/ Print the rhyme scheme\n    println!(\"{}\", rhyme_scheme);\n}"}
{"title":"D. World of Darkraft","description":"Recently Roma has become the happy owner of a new game World of Darkraft. This game combines elements of virtually all known genres, and on one of the later stages of the game Roma faced difficulties solving a puzzle.In this part Roma fights with a cunning enemy magician. The battle takes place on a rectangular field plaid n\u00d7m. Each cell contains one magical character: L, R or X. Initially all the squares of the field are \"active\".The players, Roma and enemy magician, take turns. Roma makes the first move. During a move a player selects one of the active cells. Then depending on the image in the character in the cell one of the following actions takes place:   L \u2014 magical waves radiate from the cell to the left downwards and to the right upwards along diagonal paths. All cells on the path of the waves (including the selected cell too) become inactive. The waves continue until the next inactive cell or to the edge of the field if there are no inactive cells on the way.  R \u2014 the magical waves radiate to the left upwards and to the right downwards.  X \u2014 the magical waves radiate in all four diagonal directions. If the next player cannot make a move (i.e., all cells are inactive), he loses.Roma has been trying to defeat the computer opponent for three days but he just keeps losing. He asks you to help him and determine whether it is guaranteed that he can beat the opponent, or he will have to hack the game.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers n and m (1\u2264n,m\u226420).\nNext n lines contain m characters describing the playing field: the j-th character of the i-th line equals to the magical character of the corresponding field square.\n","output_spec":"On the first line print \"WIN\" if Roma can win or \"LOSE\" if it is impossible to win considering that the opponent pays optimally.\n","notes":"In the first test each move makes one diagonal line of the square inactive, thus it is guaranteed that Roma loses after two moves.\nThere are three variants of making a move in the second test: to \"finish off\" the main diagonal line or any of the squares that are left. That means that after three moves the game stops and Roma wins.\n","sample_inputs":["2 2\nRL\nLR\n","2 2\nRR\nRR\n"],"sample_outputs":["LOSE\n","WIN\n"],"id":"138-D","difficulty":2500,"tags":["dp","games"],"src_uid":"f6380129212b575b1a5e9861565a511a","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<char>> field(n, vector<char>(m));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            cin >> field[i][j];\\n        }\\n    }\\n    \\n    bool romaWins = false;\\n    \\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (field[i][j] == 'L') {\\n                int x = i, y = j;\\n                while (x >= 0 && y >= 0 && x < n && y < m && field[x][y] != 'X') {\\n                    field[x][y] = '.';\\n                    x--;\\n                    y++;\\n                }\\n            }\\n            else if (field[i][j] == 'R') {\\n                int x = i, y = j;\\n                while (x >= 0 && y >= 0 && x < n && y < m && field[x][y] != 'X') {\\n                    field[x][y] = '.';\\n                    x++;\\n                    y--;\\n                }\\n            }\\n            else if (field[i][j] == 'X') {\\n                int x = i, y = j;\\n                while (x >= 0 && y >= 0 && x < n && y < m && field[x][y] != 'X') {\\n                    field[x][y] = '.';\\n                    x--;\\n                    y++;\\n                }\\n                x = i, y = j;\\n                while (x >= 0 && y >= 0 && x < n && y < m && field[x][y] != 'X') {\\n                    field[x][y] = '.';\\n                    x++;\\n                    y--;\\n                }\\n                x = i, y = j;\\n                while (x >= 0 && y >= 0 && x < n && y < m && field[x][y] != 'X') {\\n                    field[x][y] = '.';\\n                    x--;\\n                    y--;\\n                }\\n                x = i, y = j;\\n                while (x >= 0 && y >= 0 && x < n && y < m && field[x][y] != 'X') {\\n                    field[x][y] = '.';\\n                    x++;\\n                    y++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (field[i][j] != '.') {\\n                romaWins = true;\\n                break;\\n            }\\n        }\\n        if (romaWins) {\\n            break;\\n        }\\n    }\\n    \\n    if (romaWins) {\\n        cout << \\\"WIN\\\";\\n    } else {\\n        cout << \\\"LOSE\\\";\\n    }\\n    \\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        char[][] field = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < m; j++) {\n                field[i][j] = line.charAt(j);\n            }\n        }\n        \n        boolean[][] active = new boolean[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                active[i][j] = true;\n            }\n        }\n        \n        boolean romaWins = canRomaWin(field, active, true);\n        \n        if (romaWins) {\n            System.out.println(\"WIN\");\n        } else {\n            System.out.println(\"LOSE\");\n        }\n    }\n    \n    public static boolean canRomaWin(char[][] field, boolean[][] active, boolean romaTurn) {\n        boolean romaWins = false;\n        \n        if (romaTurn) {\n            romaWins = true;\n        } else {\n            romaWins = false;\n        }\n        \n        for (int i = 0; i < field.length; i++) {\n            for (int j = 0; j < field[0].length; j++) {\n                if (active[i][j]) {\n                    if (field[i][j] == 'L') {\n                        int row = i;\n                        int col = j;\n                        \n                        while (row < field.length && col >= 0 && active[row][col]) {\n                            active[row][col] = false;\n                            row++;\n                            col--;\n                        }\n                        \n                        row = i - 1;\n                        col = j + 1;\n                        \n                        while (row >= 0 && col < field[0].length && active[row][col]) {\n                            active[row][col] = false;\n                            row--;\n                            col++;\n                        }\n                    } else if (field[i][j] == 'R') {\n                        int row = i;\n                        int col = j;\n                        \n                        while (row >= 0 && col >= 0 && active[row][col]) {\n                            active[row][col] = false;\n                            row--;\n                            col--;\n                        }\n                        \n                        row = i + 1;\n                        col = j + 1;\n                        \n                        while (row < field.length && col < field[0].length && active[row][col]) {\n                            active[row][col] = false;\n                            row++;\n                            col++;\n                        }\n                    } else if (field[i][j] == 'X') {\n                        int row = i;\n                        int col = j;\n                        \n                        while (row >= 0 && col >= 0 && active[row][col]) {\n                            active[row][col] = false;\n                            row--;\n                            col--;\n                        }\n                        \n                        row = i + 1;\n                        col = j + 1;\n                        \n                        while (row < field.length && col < field[0].length && active[row][col]) {\n                            active[row][col] = false;\n                            row++;\n                            col++;\n                        }\n                        \n                        row = i - 1;\n                        col = j + 1;\n                        \n                        while (row >= 0 && col < field[0].length && active[row][col]) {\n                            active[row][col] = false;\n                            row--;\n                            col++;\n                        }\n                        \n                        row = i + 1;\n                        col = j - 1;\n                        \n                        while (row < field.length && col >= 0 && active[row][col]) {\n                            active[row][col] = false;\n                            row++;\n                            col--;\n                        }\n                    }\n                }\n            }\n        }\n        \n        boolean allInactive = true;\n        for (int i = 0; i < field.length; i++) {\n            for (int j = 0; j < field[0].length; j++) {\n                if (active[i][j]) {\n                    allInactive = false;\n                    break;\n                }\n            }\n        }\n        \n        if (allInactive) {\n            return !romaTurn;\n        }\n        \n        for (int i = 0; i < field.length; i++) {\n            for (int j = 0; j < field[0].length; j++) {\n                if (active[i][j]) {\n                    char[][] newField = new char[field.length][field[0].length];\n                    boolean[][] newActive = new boolean[field.length][field[0].length];\n                    \n                    for (int k = 0; k < field.length; k++) {\n                        for (int l = 0; l < field[0].length; l++) {\n                            newField[k][l] = field[k][l];\n                            newActive[k][l] = active[k][l];\n                        }\n                    }\n                    \n                    newActive[i][j] = false;\n                    \n                    boolean result = canRomaWin(newField, newActive, !romaTurn);\n                    \n                    if (romaTurn && result) {\n                        return true;\n                    } else if (!romaTurn && !result) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return romaWins;\n    }\n}","Python":"def solve_game(n, m, field):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def make_move(x, y):\n        if field[x][y] == 'L':\n            dx = [-1, 1]\n            dy = [-1, 1]\n        elif field[x][y] == 'R':\n            dx = [-1, 1]\n            dy = [1, -1]\n        else:\n            dx = [-1, 1]\n            dy = [-1, 1]\n\n        for i in range(2):\n            nx, ny = x, y\n            while True:\n                nx += dx[i]\n                ny += dy[i]\n                if not is_valid(nx, ny) or field[nx][ny] == '.':\n                    break\n                field[nx][ny] = '.'\n                make_move(nx, ny)\n\n    for i in range(n):\n        field[i] = list(field[i])\n\n    make_move(0, 0)\n\n    if any('.' in row for row in field):\n        return 'LOSE'\n    else:\n        return 'WIN'\n\n# Sample Inputs\ninputs = ['2 2\\nRL\\nLR\\n', '2 2\\nRR\\nRR\\n']\noutputs = ['LOSE\\n', 'WIN\\n']\n\nresults = []\nfor i in range(len(inputs)):\n    n, m = map(int, inputs[i].split()[0].split())\n    field = inputs[i].split()[1:]\n    result = solve_game(n, m, field)\n    results.append(result == outputs[i])\n\n# Check if all test cases passed\nif all(results):\n    print('All test cases passed')\nelse:\n    print('Some test cases failed')}","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\n#define MAX_SIZE 20\\n\\nint n, m;\\nchar field[MAX_SIZE][MAX_SIZE];\\nbool visited[MAX_SIZE][MAX_SIZE];\\n\\nbool isValid(int x, int y) {\\n    return x >= 0 && x < n && y >= 0 && y < m;\\n}\\n\\nvoid dfs(int x, int y) {\\n    visited[x][y] = true;\\n    if (field[x][y] == 'L') {\\n        int i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i++;\\n            j--;\\n        }\\n        i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i--;\\n            j++;\\n        }\\n    } else if (field[x][y] == 'R') {\\n        int i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i++;\\n            j++;\\n        }\\n        i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i--;\\n            j--;\\n        }\\n    } else if (field[x][y] == 'X') {\\n        int i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i++;\\n            j++;\\n        }\\n        i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i--;\\n            j--;\\n        }\\n        i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i++;\\n            j--;\\n        }\\n        i = x, j = y;\\n        while (isValid(i, j) && field[i][j] != 'X' && !visited[i][j]) {\\n            visited[i][j] = true;\\n            i--;\\n            j++;\\n        }\\n    }\\n}\\n\\nbool isGameOver() {\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (field[i][j] != 'X' && !visited[i][j]) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nbool canWin() {\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (field[i][j] != 'X' && !visited[i][j]) {\\n                dfs(i, j);\\n                if (isGameOver()) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nint main() {\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s\\\", field[i]);\\n    }\\n    if (canWin()) {\\n        printf(\\\"WIN\\\\n\\\");\\n    } else {\\n        printf(\\\"LOSE\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace WorldOfDarkraft\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] dimensions = input.Split(' ');\n            int n = int.Parse(dimensions[0]);\n            int m = int.Parse(dimensions[1]);\n\n            char[,] field = new char[n, m];\n\n            for (int i = 0; i < n; i++)\n            {\n                string line = Console.ReadLine();\n                for (int j = 0; j < m; j++)\n                {\n                    field[i, j] = line[j];\n                }\n            }\n\n            bool[,] visited = new bool[n, m];\n\n            bool romaWins = CanRomaWin(field, visited, n, m, true);\n\n            if (romaWins)\n            {\n                Console.WriteLine(\"WIN\");\n            }\n            else\n            {\n                Console.WriteLine(\"LOSE\");\n            }\n        }\n\n        static bool CanRomaWin(char[,] field, bool[,] visited, int n, int m, bool romaTurn)\n        {\n            bool allInactive = true;\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (field[i, j] != 'X' && visited[i, j] == false)\n                    {\n                        allInactive = false;\n                        if (romaTurn)\n                        {\n                            visited[i, j] = true;\n                            if (field[i, j] == 'L')\n                            {\n                                int row = i;\n                                int col = j;\n                                while (row < n && col >= 0 && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row++;\n                                    col--;\n                                }\n                                row = i - 1;\n                                col = j + 1;\n                                while (row >= 0 && col < m && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row--;\n                                    col++;\n                                }\n                            }\n                            else if (field[i, j] == 'R')\n                            {\n                                int row = i;\n                                int col = j;\n                                while (row >= 0 && col >= 0 && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row--;\n                                    col--;\n                                }\n                                row = i + 1;\n                                col = j + 1;\n                                while (row < n && col < m && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row++;\n                                    col++;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            visited[i, j] = true;\n                            if (field[i, j] == 'L')\n                            {\n                                int row = i;\n                                int col = j;\n                                while (row >= 0 && col < m && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row--;\n                                    col++;\n                                }\n                                row = i + 1;\n                                col = j - 1;\n                                while (row < n && col >= 0 && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row++;\n                                    col--;\n                                }\n                            }\n                            else if (field[i, j] == 'R')\n                            {\n                                int row = i;\n                                int col = j;\n                                while (row < n && col < m && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row++;\n                                    col++;\n                                }\n                                row = i - 1;\n                                col = j - 1;\n                                while (row >= 0 && col >= 0 && field[row, col] != 'X' && visited[row, col] == false)\n                                {\n                                    visited[row, col] = true;\n                                    row--;\n                                    col--;\n                                }\n                            }\n                        }\n\n                        bool romaWins = CanRomaWin(field, visited, n, m, !romaTurn);\n                        visited[i, j] = false;\n\n                        if (romaTurn && romaWins)\n                        {\n                            return true;\n                        }\n                        else if (!romaTurn && !romaWins)\n                        {\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            if (allInactive)\n            {\n                return !romaTurn;\n            }\n\n            return romaTurn;\n        }\n    }\n}","Ruby":"\ndef solve_game(n, m, field)\n  # Create a 2D array to represent the game field\n  game_field = field.split(\"\\n\").map { |row| row.chars }\n\n  # Helper function to check if a cell is within the bounds of the game field\n  def valid_cell?(x, y)\n    x >= 0 && x < n && y >= 0 && y < m\n  end\n\n  # Helper function to check if a cell is active\n  def active_cell?(x, y)\n    valid_cell?(x, y) && game_field[x][y] != '.'\n  end\n\n  # Helper function to deactivate a cell\n  def deactivate_cell(x, y)\n    game_field[x][y] = '.'\n  end\n\n  # Helper function to check if a player can make a move\n  def can_make_move?(player)\n    game_field.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if active_cell?(x, y) && (cell == 'X' || cell == player)\n          return true\n        end\n      end\n    end\n    false\n  end\n\n  # Helper function to simulate the waves from a cell\n  def simulate_waves(x, y, dx, dy)\n    while valid_cell?(x, y) && active_cell?(x, y)\n      deactivate_cell(x, y)\n      x += dx\n      y += dy\n    end\n  end\n\n  # Main game logic\n  def game_logic(player)\n    game_field.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if active_cell?(x, y) && (cell == 'X' || cell == player)\n          if cell == 'L'\n            simulate_waves(x, y, 1, 1)\n            simulate_waves(x, y, -1, -1)\n          elsif cell == 'R'\n            simulate_waves(x, y, -1, 1)\n            simulate_waves(x, y, 1, -1)\n          elsif cell == 'X'\n            simulate_waves(x, y, 1, 1)\n            simulate_waves(x, y, -1, -1)\n            simulate_waves(x, y, -1, 1)\n            simulate_waves(x, y, 1, -1)\n          end\n        end\n      end\n    end\n  end\n\n  # Start the game with Roma making the first move\n  game_logic('R')\n\n  # Check if Roma can win or lose\n  if can_make_move?('R')\n    return 'WIN'\n  else\n    return 'LOSE'\n  end\nend\n\n# Parse the input\ninput = '2 2\\nRL\\nLR\\n'\nn, m = input.split(\"\\n\")[0].split.map(&:to_i)\nfield = input.split(\"\\n\")[1..-1].join(\"\\n\")\n\n# Solve the game and print the result\nresult = solve_game(n, m, field)\nputs result\n","delphi":"program WorldOfDarkraft;\n\nuses\n  SysUtils;\n\nconst\n  MAX_N = 20;\n  MAX_M = 20;\n\ntype\n  TField = array[1..MAX_N, 1..MAX_M] of Char;\n\nvar\n  n, m: Integer;\n  field: TField;\n\nfunction CanWin(field: TField; n, m: Integer): Boolean;\nvar\n  i, j: Integer;\n  canWin: Boolean;\nbegin\n  canWin := False;\n  \n  for i := 1 to n do\n  begin\n    for j := 1 to m do\n    begin\n      if field[i, j] = 'L' then\n      begin\n        field[i, j] := '.';\n        \n        \/\/ Radiate waves to the left downwards\n        for k := 1 to Min(n - i, j - 1) do\n        begin\n          if field[i + k, j - k] = '.' then\n            Break;\n          field[i + k, j - k] := '.';\n        end;\n        \n        \/\/ Radiate waves to the right upwards\n        for k := 1 to Min(i - 1, m - j) do\n        begin\n          if field[i - k, j + k] = '.' then\n            Break;\n          field[i - k, j + k] := '.';\n        end;\n      end\n      else if field[i, j] = 'R' then\n      begin\n        field[i, j] := '.';\n        \n        \/\/ Radiate waves to the left upwards\n        for k := 1 to Min(i - 1, j - 1) do\n        begin\n          if field[i - k, j - k] = '.' then\n            Break;\n          field[i - k, j - k] := '.';\n        end;\n        \n        \/\/ Radiate waves to the right downwards\n        for k := 1 to Min(n - i, m - j) do\n        begin\n          if field[i + k, j + k] = '.' then\n            Break;\n          field[i + k, j + k] := '.';\n        end;\n      end\n      else if field[i, j] = 'X' then\n      begin\n        field[i, j] := '.';\n        \n        \/\/ Radiate waves to the left downwards\n        for k := 1 to Min(n - i, j - 1) do\n        begin\n          if field[i + k, j - k] = '.' then\n            Break;\n          field[i + k, j - k] := '.';\n        end;\n        \n        \/\/ Radiate waves to the right upwards\n        for k := 1 to Min(i - 1, m - j) do\n        begin\n          if field[i - k, j + k] = '.' then\n            Break;\n          field[i - k, j + k] := '.';\n        end;\n        \n        \/\/ Radiate waves to the left upwards\n        for k := 1 to Min(i - 1, j - 1) do\n        begin\n          if field[i - k, j - k] = '.' then\n            Break;\n          field[i - k, j - k] := '.';\n        end;\n        \n        \/\/ Radiate waves to the right downwards\n        for k := 1 to Min(n - i, m - j) do\n        begin\n          if field[i + k, j + k] = '.' then\n            Break;\n          field[i + k, j + k] := '.';\n        end;\n      end;\n    end;\n  end;\n  \n  \/\/ Check if there are any active cells left\n  for i := 1 to n do\n  begin\n    for j := 1 to m do\n    begin\n      if field[i, j] <> '.' then\n      begin\n        canWin := True;\n        Break;\n      end;\n    end;\n    \n    if canWin then\n      Break;\n  end;\n  \n  Result := canWin;\nend;\n\nvar\n  input: string;\n  lines: TStringList;\n  i, j: Integer;\nbegin\n  \/\/ Read input\n  ReadLn(input);\n  \n  lines := TStringList.Create;\n  lines.Text := input;\n  \n  \/\/ Parse n and m\n  n := StrToInt(lines[0].Split([' '])[0]);\n  m := StrToInt(lines[0].Split([' '])[1]);\n  \n  \/\/ Parse field\n  for i := 1 to n do\n  begin\n    for j := 1 to m do\n    begin\n      field[i, j] := lines[i][j];\n    end;\n  end;\n  \n  \/\/ Check if Roma can win\n  if CanWin(field, n, m) then\n    WriteLn('WIN')\n  else\n    WriteLn('LOSE');\n  \n  lines.Free;\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tfield := make([][]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar row string\\n\\t\\tfmt.Scanf(\\\"%s\\\", &row)\\n\\t\\tfield[i] = strings.Split(row, \\\"\\\")\\n\\t}\\n\\n\\tactive := make([][]bool, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tactive[i] = make([]bool, m)\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tactive[i][j] = true\\n\\t\\t}\\n\\t}\\n\\n\\tcanWin := false\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif active[i][j] {\\n\\t\\t\\t\\tif field[i][j] == \\\"L\\\" {\\n\\t\\t\\t\\t\\tk := 1\\n\\t\\t\\t\\t\\tfor i-k >= 0 && j-k >= 0 && field[i-k][j-k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i-k][j-k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tk = 1\\n\\t\\t\\t\\t\\tfor i+k < n && j+k < m && field[i+k][j+k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i+k][j+k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if field[i][j] == \\\"R\\\" {\\n\\t\\t\\t\\t\\tk := 1\\n\\t\\t\\t\\t\\tfor i-k >= 0 && j+k < m && field[i-k][j+k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i-k][j+k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tk = 1\\n\\t\\t\\t\\t\\tfor i+k < n && j-k >= 0 && field[i+k][j-k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i+k][j-k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if field[i][j] == \\\"X\\\" {\\n\\t\\t\\t\\t\\tk := 1\\n\\t\\t\\t\\t\\tfor i-k >= 0 && j-k >= 0 && field[i-k][j-k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i-k][j-k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tk = 1\\n\\t\\t\\t\\t\\tfor i-k >= 0 && j+k < m && field[i-k][j+k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i-k][j+k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tk = 1\\n\\t\\t\\t\\t\\tfor i+k < n && j-k >= 0 && field[i+k][j-k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i+k][j-k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tk = 1\\n\\t\\t\\t\\t\\tfor i+k < n && j+k < m && field[i+k][j+k] != \\\"X\\\" {\\n\\t\\t\\t\\t\\t\\tactive[i+k][j+k] = false\\n\\t\\t\\t\\t\\t\\tk++\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif active[i][j] {\\n\\t\\t\\t\\tcanWin = true\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif canWin {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif canWin {\\n\\t\\tfmt.Println(\\\"WIN\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"LOSE\\\")\\n\\t}\\n}","Javascript":"function canWin(n, m, field) {\n    let activeCells = 0;\n    let waves = [];\n    \n    \/\/ Count the number of active cells\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (field[i][j] !== '.') {\n                activeCells++;\n            }\n        }\n    }\n    \n    \/\/ Initialize the waves array\n    for (let i = 0; i < n; i++) {\n        waves[i] = [];\n        for (let j = 0; j < m; j++) {\n            waves[i][j] = true;\n        }\n    }\n    \n    \/\/ Function to check if a cell is valid\n    function isValidCell(x, y) {\n        return x >= 0 && x < n && y >= 0 && y < m;\n    }\n    \n    \/\/ Function to check if a cell is active\n    function isActiveCell(x, y) {\n        return field[x][y] !== '.';\n    }\n    \n    \/\/ Function to check if a cell is already hit by a wave\n    function isHitCell(x, y) {\n        return !waves[x][y];\n    }\n    \n    \/\/ Function to mark a cell as hit by a wave\n    function markHitCell(x, y) {\n        waves[x][y] = false;\n    }\n    \n    \/\/ Function to check if a cell is reachable by a wave\n    function isReachableCell(x, y) {\n        return isValidCell(x, y) && isActiveCell(x, y) && !isHitCell(x, y);\n    }\n    \n    \/\/ Function to make a move\n    function makeMove(x, y) {\n        if (field[x][y] === 'L') {\n            \/\/ Radiate waves to the left downwards and to the right upwards\n            let i = x, j = y;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i--;\n                j--;\n            }\n            i = x + 1;\n            j = y + 1;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i++;\n                j++;\n            }\n        } else if (field[x][y] === 'R') {\n            \/\/ Radiate waves to the left upwards and to the right downwards\n            let i = x, j = y;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i--;\n                j++;\n            }\n            i = x + 1;\n            j = y - 1;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i++;\n                j--;\n            }\n        } else if (field[x][y] === 'X') {\n            \/\/ Radiate waves in all four diagonal directions\n            let i = x, j = y;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i--;\n                j--;\n            }\n            i = x;\n            j = y + 1;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i--;\n                j++;\n            }\n            i = x + 1;\n            j = y;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i++;\n                j--;\n            }\n            i = x + 1;\n            j = y + 1;\n            while (isReachableCell(i, j)) {\n                markHitCell(i, j);\n                i++;\n                j++;\n            }\n        }\n    }\n    \n    \/\/ Roma makes the first move\n    let romaMoves = 0;\n    let enemyMoves = 0;\n    \n    while (activeCells > 0) {\n        if (romaMoves % 2 === 0) {\n            \/\/ Roma's turn\n            let romaMoveMade = false;\n            for (let i = 0; i < n; i++) {\n                for (let j = 0; j < m; j++) {\n                    if (isActiveCell(i, j)) {\n                        makeMove(i, j);\n                        activeCells--;\n                        romaMoveMade = true;\n                        break;\n                    }\n                }\n                if (romaMoveMade) {\n                    break;\n                }\n            }\n            if (!romaMoveMade) {\n                \/\/ Roma cannot make a move, he loses\n                return 'LOSE';\n            }\n            romaMoves++;\n        } else {\n            \/\/ Enemy magician's turn\n            let enemyMoveMade = false;\n            for (let i = 0; i < n; i++) {\n                for (let j = 0; j < m; j++) {\n                    if (isActiveCell(i, j)) {\n                        makeMove(i, j);\n                        activeCells--;\n                        enemyMoveMade = true;\n                        break;\n                    }\n                }\n                if (enemyMoveMade) {\n                    break;\n                }\n            }\n            if (!enemyMoveMade) {\n                \/\/ Enemy magician cannot make a move, Roma wins\n                return 'WIN';\n            }\n            enemyMoves++;\n        }\n    }\n    \n    \/\/ If the number of moves made by Roma is odd, Roma wins\n    if (romaMoves % 2 === 1) {\n        return 'WIN';\n    } else {\n        return 'LOSE';\n    }\n}\n\n\/\/ Test cases\nconsole.log(canWin(2, 2, ['RL', 'LR'])); \/\/ Output: LOSE\nconsole.log(canWin(2, 2, ['RR', 'RR'])); \/\/ Output: WIN","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    val field = Array(n) { CharArray(m) }\n    for (i in 0 until n) {\n        val line = scanner.nextLine()\n        for (j in 0 until m) {\n            field[i][j] = line[j]\n        }\n    }\n    val result = solveGame(field)\n    println(result)\n}\n\nfun solveGame(field: Array<CharArray>): String {\n    val n = field.size\n    val m = field[0].size\n    val visited = Array(n) { BooleanArray(m) }\n    val directions = arrayOf(\n        intArrayOf(-1, -1), \/\/ top left\n        intArrayOf(-1, 1), \/\/ top right\n        intArrayOf(1, -1), \/\/ bottom left\n        intArrayOf(1, 1) \/\/ bottom right\n    )\n    val queue: Queue<Pair<Int, Int>> = LinkedList()\n    var romaTurn = true\n\n    \/\/ Check if there are any active cells\n    for (i in 0 until n) {\n        for (j in 0 until m) {\n            if (field[i][j] != 'X') {\n                return \"WIN\"\n            }\n        }\n    }\n\n    \/\/ Perform BFS to simulate the game\n    while (true) {\n        var hasActiveCells = false\n\n        \/\/ Check if there are any active cells\n        for (i in 0 until n) {\n            for (j in 0 until m) {\n                if (field[i][j] != 'X') {\n                    hasActiveCells = true\n                    break\n                }\n            }\n            if (hasActiveCells) {\n                break\n            }\n        }\n\n        if (!hasActiveCells) {\n            return if (romaTurn) \"LOSE\" else \"WIN\"\n        }\n\n        \/\/ Roma's turn\n        if (romaTurn) {\n            var canWin = false\n\n            for (i in 0 until n) {\n                for (j in 0 until m) {\n                    if (field[i][j] != 'X' && !visited[i][j]) {\n                        visited[i][j] = true\n                        queue.offer(Pair(i, j))\n\n                        while (!queue.isEmpty()) {\n                            val cell = queue.poll()\n                            val x = cell.first\n                            val y = cell.second\n\n                            if (field[x][y] == 'L' || field[x][y] == 'X') {\n                                for (direction in directions) {\n                                    var newX = x + direction[0]\n                                    var newY = y + direction[1]\n\n                                    while (newX >= 0 && newX < n && newY >= 0 && newY < m && field[newX][newY] != 'X') {\n                                        if (!visited[newX][newY]) {\n                                            visited[newX][newY] = true\n                                            queue.offer(Pair(newX, newY))\n                                        }\n                                        newX += direction[0]\n                                        newY += direction[1]\n                                    }\n                                }\n                            } else if (field[x][y] == 'R' || field[x][y] == 'X') {\n                                for (direction in directions) {\n                                    var newX = x + direction[0]\n                                    var newY = y - direction[1]\n\n                                    while (newX >= 0 && newX < n && newY >= 0 && newY < m && field[newX][newY] != 'X') {\n                                        if (!visited[newX][newY]) {\n                                            visited[newX][newY] = true\n                                            queue.offer(Pair(newX, newY))\n                                        }\n                                        newX += direction[0]\n                                        newY -= direction[1]\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            romaTurn = false\n        }\n        \/\/ Enemy magician's turn\n        else {\n            for (i in 0 until n) {\n                for (j in 0 until m) {\n                    if (field[i][j] != 'X' && !visited[i][j]) {\n                        visited[i][j] = true\n                        queue.offer(Pair(i, j))\n\n                        while (!queue.isEmpty()) {\n                            val cell = queue.poll()\n                            val x = cell.first\n                            val y = cell.second\n\n                            if (field[x][y] == 'L' || field[x][y] == 'X') {\n                                for (direction in directions) {\n                                    var newX = x - direction[0]\n                                    var newY = y + direction[1]\n\n                                    while (newX >= 0 && newX < n && newY >= 0 && newY < m && field[newX][newY] != 'X') {\n                                        if (!visited[newX][newY]) {\n                                            visited[newX][newY] = true\n                                            queue.offer(Pair(newX, newY))\n                                        }\n                                        newX -= direction[0]\n                                        newY += direction[1]\n                                    }\n                                }\n                            } else if (field[x][y] == 'R' || field[x][y] == 'X') {\n                                for (direction in directions) {\n                                    var newX = x - direction[0]\n                                    var newY = y - direction[1]\n\n                                    while (newX >= 0 && newX < n && newY >= 0 && newY < m && field[newX][newY] != 'X') {\n                                        if (!visited[newX][newY]) {\n                                            visited[newX][newY] = true\n                                            queue.offer(Pair(newX, newY))\n                                        }\n                                        newX -= direction[0]\n                                        newY -= direction[1]\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            romaTurn = true\n        }\n    }\n}","PHP":"<?php\\n\\nfunction canWin($n, $m, $field) {\\n    $activeCells = 0;\\n    $waves = [];\\n\\n    \/\/ Count the number of active cells\\n    for ($i = 0; $i < $n; $i++) {\\n        for ($j = 0; $j < $m; $j++) {\\n            if ($field[$i][$j] != '.') {\\n                $activeCells++;\\n            }\\n        }\\n    }\\n\\n    \/\/ Check if Roma can win\\n    while ($activeCells > 0) {\\n        $foundMove = false;\\n\\n        \/\/ Iterate through each cell\\n        for ($i = 0; $i < $n; $i++) {\\n            for ($j = 0; $j < $m; $j++) {\\n                if ($field[$i][$j] != '.') {\\n                    \/\/ Check if the cell can be selected\\n                    if (!in_array([$i, $j], $waves)) {\\n                        \/\/ Perform the corresponding action based on the character\\n                        switch ($field[$i][$j]) {\\n                            case 'L':\\n                                \/\/ Radiate waves to the left downwards and right upwards\\n                                for ($k = $i, $l = $j; $k < $n && $l >= 0; $k++, $l--) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                for ($k = $i, $l = $j; $k >= 0 && $l < $m; $k--, $l++) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                break;\\n                            case 'R':\\n                                \/\/ Radiate waves to the left upwards and right downwards\\n                                for ($k = $i, $l = $j; $k >= 0 && $l >= 0; $k--, $l--) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                for ($k = $i, $l = $j; $k < $n && $l < $m; $k++, $l++) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                break;\\n                            case 'X':\\n                                \/\/ Radiate waves in all four diagonal directions\\n                                for ($k = $i, $l = $j; $k >= 0 && $l >= 0; $k--, $l--) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                for ($k = $i, $l = $j; $k >= 0 && $l < $m; $k--, $l++) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                for ($k = $i, $l = $j; $k < $n && $l >= 0; $k++, $l--) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                for ($k = $i, $l = $j; $k < $n && $l < $m; $k++, $l++) {\\n                                    if ($field[$k][$l] != '.') {\\n                                        $waves[] = [$k, $l];\\n                                        $activeCells--;\\n                                    }\\n                                }\\n                                break;\\n                        }\\n\\n                        \/\/ Mark the cell as selected\\n                        $waves[] = [$i, $j];\\n                        $activeCells--;\\n                        $foundMove = true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if ($foundMove) {\\n                break;\\n            }\\n        }\\n\\n        \/\/ If no move is found, Roma loses\\n        if (!$foundMove) {\\n            return 'LOSE';\\n        }\\n    }\\n\\n    \/\/ If all cells are inactive, Roma wins\\n    return 'WIN';\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    ['2 2', 'RL', 'LR'],\\n    ['2 2', 'RR', 'RR'],\\n];\\n\\n\/\/ Process each input\\nforeach ($inputs as $input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $dimensions = explode(\\\" \\\", $lines[0]);\\n    $n = intval($dimensions[0]);\\n    $m = intval($dimensions[1]);\\n    $field = [];\\n\\n    \/\/ Create the field\\n    for ($i = 1; $i <= $n; $i++) {\\n        $field[] = str_split($lines[$i]);\\n    }\\n\\n    \/\/ Check if Roma can win\\n    $result = canWin($n, $m, $field);\\n    echo $result . \\\"\\\\n\\\";\\n}\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    char[][] field = new char[][](n);\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        field[i] = readln.chomp().dup;\\r\\n    }\\r\\n\\r\\n    bool[][] active = new bool[][](n, m);\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        foreach (j; 0..m)\\r\\n        {\\r\\n            active[i][j] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    bool romaWins = false;\\r\\n\\r\\n    while (true)\\r\\n    {\\r\\n        bool canMove = false;\\r\\n\\r\\n        foreach (i; 0..n)\\r\\n        {\\r\\n            foreach (j; 0..m)\\r\\n            {\\r\\n                if (active[i][j])\\r\\n                {\\r\\n                    canMove = true;\\r\\n\\r\\n                    switch (field[i][j])\\r\\n                    {\\r\\n                        case 'L':\\r\\n                            for (int k = 1; i + k < n && j + k < m; k++)\\r\\n                            {\\r\\n                                active[i + k][j + k] = false;\\r\\n                            }\\r\\n                            for (int k = 1; i - k >= 0 && j - k >= 0; k++)\\r\\n                            {\\r\\n                                active[i - k][j - k] = false;\\r\\n                            }\\r\\n                            break;\\r\\n\\r\\n                        case 'R':\\r\\n                            for (int k = 1; i + k < n && j - k >= 0; k++)\\r\\n                            {\\r\\n                                active[i + k][j - k] = false;\\r\\n                            }\\r\\n                            for (int k = 1; i - k >= 0 && j + k < m; k++)\\r\\n                            {\\r\\n                                active[i - k][j + k] = false;\\r\\n                            }\\r\\n                            break;\\r\\n\\r\\n                        case 'X':\\r\\n                            for (int k = 1; i + k < n && j + k < m; k++)\\r\\n                            {\\r\\n                                active[i + k][j + k] = false;\\r\\n                            }\\r\\n                            for (int k = 1; i - k >= 0 && j - k >= 0; k++)\\r\\n                            {\\r\\n                                active[i - k][j - k] = false;\\r\\n                            }\\r\\n                            for (int k = 1; i + k < n && j - k >= 0; k++)\\r\\n                            {\\r\\n                                active[i + k][j - k] = false;\\r\\n                            }\\r\\n                            for (int k = 1; i - k >= 0 && j + k < m; k++)\\r\\n                            {\\r\\n                                active[i - k][j + k] = false;\\r\\n                            }\\r\\n                            break;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!canMove)\\r\\n        {\\r\\n            romaWins = false;\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        bool allInactive = true;\\r\\n\\r\\n        foreach (i; 0..n)\\r\\n        {\\r\\n            foreach (j; 0..m)\\r\\n            {\\r\\n                if (active[i][j])\\r\\n                {\\r\\n                    allInactive = false;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (!allInactive)\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (allInactive)\\r\\n        {\\r\\n            romaWins = true;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (romaWins)\\r\\n    {\\r\\n        writeln(\\\"WIN\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"LOSE\\\");\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub solve_puzzle {\\n    my ($n, $m, @field) = @_;\\n    my $active_count = 0;\\n    my $active_cells = [];\\n\\n    # Count the number of active cells\\n    for my $i (0..$n-1) {\\n        for my $j (0..$m-1) {\\n            if ($field[$i][$j] ne '.') {\\n                $active_count++;\\n                push @$active_cells, [$i, $j];\\n            }\\n        }\\n    }\\n\\n    # Check if Roma can win\\n    if ($active_count % 2 == 0) {\\n        return 'LOSE';\\n    } else {\\n        return 'WIN';\\n    }\\n}\\n\\n# Read input\\nmy ($n, $m) = split ' ', <STDIN>;\\nchomp(my @field = <STDIN>);\\n\\n# Convert field to 2D array\\nfor my $i (0..$n-1) {\\n    $field[$i] = [split '', $field[$i]];\\n}\\n\\n# Solve the puzzle\\nmy $result = solve_puzzle($n, $m, @field);\\n\\n# Print the result\\nprint $result . \\\"\\\\n\\\";\\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buffer = String::new();\n    input.read_line(&mut buffer).unwrap();\n    let nm: Vec<usize> = buffer\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = nm[0];\n    let m = nm[1];\n\n    let mut field: Vec<Vec<char>> = Vec::new();\n    for _ in 0..n {\n        buffer.clear();\n        input.read_line(&mut buffer).unwrap();\n        let row: Vec<char> = buffer.trim().chars().collect();\n        field.push(row);\n    }\n\n    let mut active_cells = 0;\n    for i in 0..n {\n        for j in 0..m {\n            if field[i][j] != '.' {\n                active_cells += 1;\n            }\n        }\n    }\n\n    let mut roma_wins = false;\n    let mut enemy_wins = false;\n\n    while active_cells > 0 {\n        let mut roma_moves = false;\n        let mut enemy_moves = false;\n\n        for i in 0..n {\n            for j in 0..m {\n                if field[i][j] != '.' {\n                    let mut waves = Vec::new();\n                    match field[i][j] {\n                        'L' => {\n                            waves.push((-1, -1));\n                            waves.push((1, 1));\n                        }\n                        'R' => {\n                            waves.push((-1, 1));\n                            waves.push((1, -1));\n                        }\n                        'X' => {\n                            waves.push((-1, -1));\n                            waves.push((1, 1));\n                            waves.push((-1, 1));\n                            waves.push((1, -1));\n                        }\n                        _ => {}\n                    }\n\n                    for wave in waves {\n                        let mut x = i as isize;\n                        let mut y = j as isize;\n\n                        while x >= 0 && x < n as isize && y >= 0 && y < m as isize {\n                            if field[x as usize][y as usize] != '.' {\n                                field[x as usize][y as usize] = '.';\n                                active_cells -= 1;\n                            }\n\n                            x += wave.0;\n                            y += wave.1;\n                        }\n                    }\n\n                    if active_cells == 0 {\n                        roma_wins = true;\n                        break;\n                    }\n\n                    roma_moves = true;\n                }\n            }\n\n            if roma_wins {\n                break;\n            }\n        }\n\n        if !roma_moves {\n            enemy_wins = true;\n            break;\n        }\n\n        if roma_wins {\n            break;\n        }\n\n        for i in 0..n {\n            for j in 0..m {\n                if field[i][j] != '.' {\n                    let mut waves = Vec::new();\n                    match field[i][j] {\n                        'L' => {\n                            waves.push((-1, -1));\n                            waves.push((1, 1));\n                        }\n                        'R' => {\n                            waves.push((-1, 1));\n                            waves.push((1, -1));\n                        }\n                        'X' => {\n                            waves.push((-1, -1));\n                            waves.push((1, 1));\n                            waves.push((-1, 1));\n                            waves.push((1, -1));\n                        }\n                        _ => {}\n                    }\n\n                    for wave in waves {\n                        let mut x = i as isize;\n                        let mut y = j as isize;\n\n                        while x >= 0 && x < n as isize && y >= 0 && y < m as isize {\n                            if field[x as usize][y as usize] != '.' {\n                                field[x as usize][y as usize] = '.';\n                                active_cells -= 1;\n                            }\n\n                            x += wave.0;\n                            y += wave.1;\n                        }\n                    }\n\n                    if active_cells == 0 {\n                        enemy_wins = true;\n                        break;\n                    }\n\n                    enemy_moves = true;\n                }\n            }\n\n            if enemy_wins {\n                break;\n            }\n        }\n\n        if !enemy_moves {\n            roma_wins = true;\n            break;\n        }\n    }\n\n    if roma_wins {\n        println!(\"WIN\");\n    } else if enemy_wins {\n        println!(\"LOSE\");\n    }\n}"}
{"title":"D. Boboniu and Jianghu","description":"Since Boboniu finished building his Jianghu, he has been doing Kungfu on these mountains every day. Boboniu designs a map for his $$$n$$$ mountains. He uses $$$n-1$$$ roads to connect all $$$n$$$ mountains. Every pair of mountains is connected via roads.For the $$$i$$$-th mountain, Boboniu estimated the tiredness of doing Kungfu on the top of it as $$$t_i$$$. He also estimated the height of each mountain as $$$h_i$$$.A path is a sequence of mountains $$$M$$$ such that for each $$$i$$$ ($$$1 \\le i < |M|$$$), there exists a road between $$$M_i$$$ and $$$M_{i+1}$$$. Boboniu would regard the path as a challenge if for each $$$i$$$ ($$$1\\le i<|M|$$$), $$$h_{M_i}\\le h_{M_{i+1}}$$$.Boboniu wants to divide all $$$n-1$$$ roads into several challenges. Note that each road must appear in exactly one challenge, but a mountain may appear in several challenges. Boboniu wants to minimize the total tiredness to do all the challenges. The tiredness of a challenge $$$M$$$ is the sum of tiredness of all mountains in it, i.e. $$$\\sum_{i=1}^{|M|}t_{M_i}$$$. He asked you to find the minimum total tiredness. As a reward for your work, you'll become a guardian in his Jianghu.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 2 \\\\cdot 10^5$$$), denoting the number of the mountains.\nThe second line contains $$$n$$$ integers $$$t_1, t_2, \\\\ldots, t_n$$$ ($$$1 \\\\le t_i \\\\le 10^6$$$), denoting the tiredness for Boboniu to do Kungfu on each mountain.\nThe third line contains $$$n$$$ integers $$$h_1, h_2, \\\\ldots, h_n$$$ ($$$1 \\\\le h_i \\\\le 10^6$$$), denoting the height of each mountain.\nEach of the following $$$n - 1$$$ lines contains two integers $$$u_i$$$, $$$v_i$$$ ($$$1 \\\\le u_i, v_i \\\\le n, u_i \\\\neq v_i$$$), denoting the ends of the road. It's guaranteed that all mountains are connected via roads.\n","output_spec":"Print one integer: the smallest sum of tiredness of all challenges.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1394-D","difficulty":2800,"tags":["dp","greedy","sortings","trees"],"src_uid":"c6a1e6ad5134dc210f08bd9ab4104754","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nconst int MAXN = 2e5 + 5;\\n\\nvector<int> adj[MAXN];\\nvector<int> t, h;\\nlong long dp[MAXN][2];\\n\\nvoid dfs(int u, int p) {\\n    dp[u][0] = dp[u][1] = 0;\\n    for (int v : adj[u]) {\\n        if (v == p) continue;\\n        dfs(v, u);\\n        dp[u][0] += max(dp[v][0] + abs(h[u] - h[v]), dp[v][1] + abs(h[u] - t[v]));\\n        dp[u][1] += max(dp[v][0] + abs(t[u] - h[v]), dp[v][1] + abs(t[u] - t[v]));\\n    }\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    t.resize(n + 1);\\n    h.resize(n + 1);\\n    for (int i = 1; i <= n; i++) {\\n        cin >> t[i];\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        cin >> h[i];\\n    }\\n    for (int i = 1; i < n; i++) {\\n        int u, v;\\n        cin >> u >> v;\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n    dfs(1, 0);\\n    cout << max(dp[1][0], dp[1][1]) << endl;\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    static class Mountain {\\n        int index;\\n        int tiredness;\\n        int height;\\n\\n        public Mountain(int index, int tiredness, int height) {\\n            this.index = index;\\n            this.tiredness = tiredness;\\n            this.height = height;\\n        }\\n    }\\n\\n    static List<List<Integer>> graph;\\n    static List<Mountain> mountains;\\n    static long minTiredness;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n\\n        mountains = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            int tiredness = scanner.nextInt();\\n            mountains.add(new Mountain(i, tiredness, 0));\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int height = scanner.nextInt();\\n            mountains.get(i).height = height;\\n        }\\n\\n        graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            int u = scanner.nextInt() - 1;\\n            int v = scanner.nextInt() - 1;\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n        minTiredness = Long.MAX_VALUE;\\n        dfs(0, -1);\\n\\n        System.out.println(minTiredness);\\n    }\\n\\n    static int dfs(int node, int parent) {\\n        int maxTiredness = 0;\\n        int totalTiredness = mountains.get(node).tiredness;\\n\\n        for (int neighbor : graph.get(node)) {\\n            if (neighbor != parent) {\\n                int neighborTiredness = dfs(neighbor, node);\\n                maxTiredness = Math.max(maxTiredness, neighborTiredness);\\n                totalTiredness += neighborTiredness;\\n            }\\n        }\\n\\n        maxTiredness = Math.max(maxTiredness, mountains.get(node).tiredness);\\n        minTiredness = Math.min(minTiredness, totalTiredness - maxTiredness);\\n\\n        return maxTiredness;\\n    }\\n}\"}}","Python":"import sys\\n\\nsys.setrecursionlimit(10**6)\\n\\n\\ndef dfs(node, parent, heights, tiredness, graph):\\n    global ans\\n    ans += tiredness[node]\\n    for child in graph[node]:\\n        if child != parent:\\n            if heights[child] >= heights[node]:\\n                dfs(child, node, heights, tiredness, graph)\\n            else:\\n                dfs(child, node, heights, tiredness, graph)\\n\\n\\nn = int(input())\\ntiredness = list(map(int, input().split()))\\nheights = list(map(int, input().split()))\\n\\ngraph = [[] for _ in range(n+1)]\\n\\nfor _ in range(n-1):\\n    u, v = map(int, input().split())\\n    graph[u].append(v)\\n    graph[v].append(u)\\n\\nans = 0\\n\\nif heights[1] != max(heights):\\n    dfs(heights.index(max(heights)), 0, heights, tiredness, graph)\\nelse:\\n    dfs(1, 0, heights, tiredness, graph)\\n\\nprint(ans)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXN 200005\\n\\nint n;\\nint t[MAXN], h[MAXN];\\nint u[MAXN], v[MAXN];\\nint dp[MAXN][2];\\nint g[MAXN][2];\\n\\nint max(int a, int b) {\\n    return a > b ? a : b;\\n}\\n\\nvoid dfs(int x, int fa) {\\n    dp[x][0] = dp[x][1] = 0;\\n    for (int i = g[x][0]; i; i = g[i][1]) {\\n        int y = u[i] ^ v[i] ^ x;\\n        if (y == fa) continue;\\n        dfs(y, x);\\n        dp[x][0] += max(dp[y][0] + abs(h[x] - h[y]), dp[y][1] + abs(h[x] - h[y]));\\n        dp[x][1] += dp[y][0] + abs(h[x] - h[y]) + t[y];\\n    }\\n}\\n\\nint main() {\\n    scanf(\\\"%d\\\", &n);\\n    for (int i = 1; i <= n; i++) {\\n        scanf(\\\"%d\\\", &t[i]);\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        scanf(\\\"%d\\\", &h[i]);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        scanf(\\\"%d%d\\\", &u[i], &v[i]);\\n        g[i][0] = g[u[i]][0];\\n        g[i][1] = g[v[i]][0];\\n        g[u[i]][0] = g[v[i]][0] = i;\\n    }\\n    dfs(1, 0);\\n    printf(\\\"%d\\\\n\\\", max(dp[1][0], dp[1][1]));\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace Jianghu\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] tiredness = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n            int[] height = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            List<int>[] graph = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n\n            for (int i = 0; i < n - 1; i++)\n            {\n                int[] road = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n                int u = road[0];\n                int v = road[1];\n                graph[u].Add(v);\n                graph[v].Add(u);\n            }\n\n            long[] dp = new long[n + 1];\n            long[] maxTiredness = new long[n + 1];\n\n            DFS(graph, 1, 0, tiredness, height, dp, maxTiredness);\n\n            Console.WriteLine(dp[1]);\n        }\n\n        static void DFS(List<int>[] graph, int node, int parent, int[] tiredness, int[] height, long[] dp, long[] maxTiredness)\n        {\n            dp[node] = tiredness[node - 1];\n\n            foreach (int child in graph[node])\n            {\n                if (child == parent)\n                    continue;\n\n                DFS(graph, child, node, tiredness, height, dp, maxTiredness);\n\n                dp[node] += dp[child];\n                maxTiredness[node] = Math.Max(maxTiredness[node], maxTiredness[child]);\n            }\n\n            maxTiredness[node] = Math.Max(maxTiredness[node], dp[node] - height[node - 1]);\n\n            if (maxTiredness[node] < 0)\n                maxTiredness[node] = 0;\n        }\n    }\n}","Ruby":"\n# Function to calculate the minimum total tiredness\ndef calculate_minimum_tiredness(n, t, h, roads)\n  # Create an adjacency list to represent the graph\n  graph = Array.new(n + 1) { [] }\n  roads.each do |u, v|\n    graph[u] << v\n    graph[v] << u\n  end\n\n  # Initialize an array to store the minimum tiredness for each mountain\n  min_tiredness = Array.new(n + 1, Float::INFINITY)\n\n  # Perform a depth-first search to calculate the minimum tiredness for each mountain\n  dfs(1, 0, t, h, graph, min_tiredness)\n\n  # Return the minimum total tiredness\n  min_tiredness[1]\nend\n\n# Depth-first search function\ndef dfs(node, parent, t, h, graph, min_tiredness)\n  # Calculate the minimum tiredness for the current mountain\n  min_tiredness[node] = t[node]\n\n  # Iterate through the neighbors of the current mountain\n  graph[node].each do |neighbor|\n    next if neighbor == parent\n\n    # Recursively calculate the minimum tiredness for the neighbor mountain\n    dfs(neighbor, node, t, h, graph, min_tiredness)\n\n    # Update the minimum tiredness for the current mountain\n    min_tiredness[node] = [min_tiredness[node], min_tiredness[neighbor]].min\n  end\nend\n\n# Read the input\nn = gets.to_i\nt = gets.split.map(&:to_i)\nh = gets.split.map(&:to_i)\nroads = []\n(n - 1).times do\n  u, v = gets.split.map(&:to_i)\n  roads << [u, v]\nend\n\n# Calculate the minimum total tiredness\nminimum_tiredness = calculate_minimum_tiredness(n, t, h, roads)\n\n# Print the result\nputs minimum_tiredness\n","delphi":"program Jianghu;\\n\\nconst\\n  MAXN = 200005;\\n\\nvar\\n  n, i, u, v: integer;\\n  t, h: array[1..MAXN] of integer;\\n  adj: array[1..MAXN] of array of integer;\\n  dp: array[1..MAXN, 0..1] of int64;\\n\\nprocedure dfs(v, p: integer);\\nvar\\n  i, u: integer;\\nbegin\\n  dp[v, 0] := 0;\\n  dp[v, 1] := t[v];\\n  for i := 0 to Length(adj[v]) - 1 do\\n  begin\\n    u := adj[v][i];\\n    if u = p then\\n      continue;\\n    dfs(u, v);\\n    dp[v, 0] := dp[v, 0] + max(dp[u, 0] + abs(h[v] - h[u]), dp[u, 1] + abs(h[v] - h[u]));\\n    dp[v, 1] := dp[v, 1] + max(dp[u, 0] + abs(h[v] - h[u]), dp[u, 1] + abs(h[v] - h[u]) + t[u]);\\n  end;\\nend;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(t[i]);\\n  for i := 1 to n do\\n    read(h[i]);\\n  for i := 1 to n - 1 do\\n  begin\\n    readln(u, v);\\n    SetLength(adj[u], Length(adj[u]) + 1);\\n    adj[u][Length(adj[u]) - 1] := v;\\n    SetLength(adj[v], Length(adj[v]) + 1);\\n    adj[v][Length(adj[v]) - 1] := u;\\n  end;\\n  dfs(1, 0);\\n  writeln(min(dp[1, 0], dp[1, 1]));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\t\/\/ Read the number of mountains\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\/\/ Read the tiredness for each mountain\\n\\ttiredness := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\ttiredness[i], _ = strconv.Atoi(scanner.Text())\\n\\t}\\n\\n\\t\/\/ Read the height of each mountain\\n\\theight := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\theight[i], _ = strconv.Atoi(scanner.Text())\\n\\t}\\n\\n\\t\/\/ Read the roads\\n\\troads := make([][]int, n-1)\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tu, _ := strconv.Atoi(scanner.Text())\\n\\t\\tscanner.Scan()\\n\\t\\tv, _ := strconv.Atoi(scanner.Text())\\n\\t\\troads[i] = []int{u, v}\\n\\t}\\n\\n\\t\/\/ Calculate the smallest sum of tiredness\\n\\ttotalTiredness := calculateTotalTiredness(tiredness, height, roads)\\n\\n\\t\/\/ Print the result\\n\\tfmt.Println(totalTiredness)\\n}\\n\\nfunc calculateTotalTiredness(tiredness []int, height []int, roads [][]int) int {\\n\\t\/\/ TODO: Implement the algorithm to calculate the smallest sum of tiredness\\n\\treturn 0\\n}","Javascript":"\n\/\/ Function to find the minimum total tiredness\nfunction findMinimumTiredness(n, t, h, roads) {\n  \/\/ Create an adjacency list to represent the graph\n  const graph = new Array(n + 1).fill(null).map(() => []);\n  \n  \/\/ Add the roads to the adjacency list\n  for (let i = 0; i < roads.length; i++) {\n    const [u, v] = roads[i];\n    graph[u].push(v);\n    graph[v].push(u);\n  }\n  \n  \/\/ Function to perform DFS on the graph\n  function dfs(node, parent, minTiredness) {\n    let totalTiredness = t[node];\n    \n    \/\/ Iterate through the neighbors of the current node\n    for (let i = 0; i < graph[node].length; i++) {\n      const neighbor = graph[node][i];\n      \n      \/\/ Skip the parent node\n      if (neighbor === parent) continue;\n      \n      \/\/ Find the minimum tiredness for the current neighbor\n      const neighborTiredness = dfs(neighbor, node, Math.min(minTiredness, t[neighbor]));\n      \n      \/\/ Add the minimum tiredness of the neighbor to the total tiredness\n      totalTiredness += neighborTiredness;\n    }\n    \n    return totalTiredness;\n  }\n  \n  \/\/ Start the DFS from the root node (mountain 1)\n  const minimumTiredness = dfs(1, -1, t[1]);\n  \n  return minimumTiredness;\n}\n\n\/\/ Read the input\nconst n = parseInt(readline());\nconst t = readline().split(' ').map(Number);\nconst h = readline().split(' ').map(Number);\nconst roads = [];\nfor (let i = 0; i < n - 1; i++) {\n  const [u, v] = readline().split(' ').map(Number);\n  roads.push([u, v]);\n}\n\n\/\/ Find the minimum total tiredness\nconst minimumTiredness = findMinimumTiredness(n, t, h, roads);\n\n\/\/ Print the result\nconsole.log(minimumTiredness);\n","Kotlin":"import java.util.*\n\ndata class Mountain(val index: Int, val tiredness: Int, val height: Int)\n\nfun main() {\n    val input = Scanner(System.`in`)\n    val n = input.nextInt()\n    val tiredness = IntArray(n)\n    val height = IntArray(n)\n    val mountains = ArrayList<Mountain>()\n    \n    for (i in 0 until n) {\n        tiredness[i] = input.nextInt()\n    }\n    \n    for (i in 0 until n) {\n        height[i] = input.nextInt()\n        mountains.add(Mountain(i, tiredness[i], height[i]))\n    }\n    \n    val graph = Array(n) { ArrayList<Int>() }\n    \n    for (i in 0 until n - 1) {\n        val u = input.nextInt() - 1\n        val v = input.nextInt() - 1\n        graph[u].add(v)\n        graph[v].add(u)\n    }\n    \n    val dp = Array(n) { LongArray(2) }\n    \n    fun dfs(u: Int, parent: Int) {\n        var sum1: Long = 0\n        var sum2: Long = 0\n        \n        for (v in graph[u]) {\n            if (v == parent) continue\n            dfs(v, u)\n            val diff = mountains[u].height - mountains[v].height\n            val tiredness1 = mountains[u].tiredness + dp[v][0] + diff\n            val tiredness2 = mountains[u].tiredness + dp[v][1] - diff\n            sum1 += minOf(tiredness1, dp[v][1])\n            sum2 += minOf(tiredness2, dp[v][0])\n        }\n        \n        dp[u][0] = sum1\n        dp[u][1] = sum2\n    }\n    \n    dfs(0, -1)\n    \n    val result = minOf(dp[0][0], dp[0][1])\n    println(result)\n}","PHP":"\n<?php\n\n\/\/ Read input\n$n = intval(fgets(STDIN));\n$tiredness = array_map('intval', explode(' ', fgets(STDIN)));\n$height = array_map('intval', explode(' ', fgets(STDIN)));\n$roads = [];\nfor ($i = 0; $i < $n - 1; $i++) {\n    $line = explode(' ', fgets(STDIN));\n    $u = intval($line[0]);\n    $v = intval($line[1]);\n    $roads[$u][] = $v;\n    $roads[$v][] = $u;\n}\n\n\/\/ Initialize variables\n$dp = array_fill(1, $n, array_fill(0, 2, PHP_INT_MAX));\n$dp[1][0] = $tiredness[1];\n$dp[1][1] = $tiredness[1];\n\n\/\/ DFS function to calculate minimum tiredness\nfunction dfs($node, $parent, $tiredness, $height, $roads, &$dp) {\n    $minTiredness = PHP_INT_MAX;\n    $minTirednessWithParent = PHP_INT_MAX;\n    \n    foreach ($roads[$node] as $neighbor) {\n        if ($neighbor == $parent) {\n            continue;\n        }\n        \n        dfs($neighbor, $node, $tiredness, $height, $roads, $dp);\n        \n        $minTiredness = min($minTiredness, $dp[$neighbor][0]);\n        $minTirednessWithParent = min($minTirednessWithParent, $dp[$neighbor][1]);\n    }\n    \n    $dp[$node][0] = $minTiredness + $tiredness[$node];\n    $dp[$node][1] = min($minTirednessWithParent + $tiredness[$node], $dp[$node][0] - $tiredness[$node] + $height[$node]);\n}\n\n\/\/ Call DFS function\ndfs(1, 0, $tiredness, $height, $roads, $dp);\n\n\/\/ Print the smallest sum of tiredness\necho $dp[1][0];\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.functional;\\r\\nimport std.range;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Mountain\\r\\n{\\r\\n    int tiredness;\\r\\n    int height;\\r\\n}\\r\\n\\r\\nvoid dfs(int v, int p, int[] visited, Mountain[] mountains, int[][] graph, int[][] dp)\\r\\n{\\r\\n    visited[v] = 1;\\r\\n    dp[v][0] = mountains[v].tiredness;\\r\\n    dp[v][1] = 0;\\r\\n    for (int i = 0; i < graph[v].length; i++)\\r\\n    {\\r\\n        int u = graph[v][i];\\r\\n        if (u == p)\\r\\n            continue;\\r\\n        dfs(u, v, visited, mountains, graph, dp);\\r\\n        dp[v][0] += min(dp[u][0], dp[u][1]);\\r\\n        dp[v][1] += dp[u][0];\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    Mountain[] mountains = new Mountain[n];\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &mountains[i].tiredness);\\r\\n    }\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &mountains[i].height);\\r\\n    }\\r\\n    int[][] graph = new int[n][];\\r\\n    for (int i = 0; i < n - 1; i++)\\r\\n    {\\r\\n        int u, v;\\r\\n        readf(\\\"%d %d\\\", &u, &v);\\r\\n        graph[u - 1] ~= v - 1;\\r\\n        graph[v - 1] ~= u - 1;\\r\\n    }\\r\\n    int[][] dp = new int[n][];\\r\\n    foreach (ref dpRow; dp)\\r\\n    {\\r\\n        dpRow = new int[2];\\r\\n    }\\r\\n    int[] visited = new int[n];\\r\\n    dfs(0, -1, visited, mountains, graph, dp);\\r\\n    writeln(min(dp[0][0], dp[0][1]));\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\n# Read input\nmy $n = <>;\nchomp $n;\n\nmy @tiredness = split ' ', <>;\nchomp @tiredness;\n\nmy @height = split ' ', <>;\nchomp @height;\n\nmy @roads;\nfor (1..$n-1) {\n    my ($u, $v) = split ' ', <>;\n    push @roads, [$u, $v];\n}\n\n# Create adjacency list representation of the graph\nmy %graph;\nforeach my $road (@roads) {\n    my ($u, $v) = @$road;\n    push @{$graph{$u}}, $v;\n    push @{$graph{$v}}, $u;\n}\n\n# Initialize variables\nmy @dp;\nmy @visited;\nmy $total_tiredness = 0;\n\n# DFS function to calculate the minimum total tiredness\nsub dfs {\n    my ($node, $parent) = @_;\n    \n    # Mark the current node as visited\n    $visited[$node] = 1;\n    \n    # Calculate the tiredness of the current node\n    my $current_tiredness = $tiredness[$node-1];\n    \n    # Iterate through the neighbors of the current node\n    foreach my $neighbor (@{$graph{$node}}) {\n        next if $neighbor == $parent;\n        \n        # If the neighbor has not been visited, perform DFS on it\n        if (!$visited[$neighbor]) {\n            dfs($neighbor, $node);\n            \n            # Add the tiredness of the neighbor to the current node's tiredness\n            $current_tiredness += $dp[$neighbor];\n        }\n    }\n    \n    # Update the minimum total tiredness\n    $total_tiredness += $current_tiredness;\n    \n    # Store the minimum tiredness of the current node in the dp array\n    $dp[$node] = $current_tiredness;\n}\n\n# Perform DFS on the first mountain\ndfs(1, 0);\n\n# Print the minimum total tiredness\nprint $total_tiredness;\n","Rust":"use std::cmp::min;\\nuse std::collections::HashMap;\\nuse std::io::{self, BufRead};\\n\\nfn dfs(\\n    node: usize,\\n    parent: usize,\\n    heights: &[usize],\\n    tiredness: &[usize],\\n    graph: &HashMap<usize, Vec<usize>>,\\n    dp: &mut HashMap<(usize, usize), usize>,\\n) -> usize {\\n    if let Some(&result) = dp.get(&(node, parent)) {\\n        return result;\\n    }\\n\\n    let mut total_tiredness = tiredness[node];\\n\\n    for &child in graph.get(&node).unwrap() {\\n        if child == parent {\\n            continue;\\n        }\\n\\n        let child_tiredness = dfs(child, node, heights, tiredness, graph, dp);\\n        total_tiredness += min(child_tiredness, heights[child]);\\n    }\\n\\n    dp.insert((node, parent), total_tiredness);\\n    total_tiredness\\n}\\n\\nfn main() {\\n    let stdin = io::stdin();\\n    let mut lines = stdin.lock().lines().map(|line| line.unwrap());\\n\\n    let n: usize = lines.next().unwrap().parse().unwrap();\\n    let tiredness: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let heights: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut graph: HashMap<usize, Vec<usize>> = HashMap::new();\\n\\n    for _ in 0..n - 1 {\\n        let line = lines.next().unwrap();\\n        let mut iter = line.split_whitespace();\\n        let u: usize = iter.next().unwrap().parse().unwrap();\\n        let v: usize = iter.next().unwrap().parse().unwrap();\\n\\n        graph.entry(u).or_insert(Vec::new()).push(v);\\n        graph.entry(v).or_insert(Vec::new()).push(u);\\n    }\\n\\n    let mut dp: HashMap<(usize, usize), usize> = HashMap::new();\\n\\n    let result = dfs(1, 0, &heights, &tiredness, &graph, &mut dp);\\n\\n    println!(\\\"{}\\\", result);\\n}"}
{"title":"B. RPG Protagonist","description":"You are playing one RPG from the 2010s. You are planning to raise your smithing skill, so you need as many resources as possible. So how to get resources? By stealing, of course.You decided to rob a town's blacksmith and you take a follower with you. You can carry at most $$$p$$$ units and your follower\u00a0\u2014 at most $$$f$$$ units.In the blacksmith shop, you found $$$cnt_s$$$ swords and $$$cnt_w$$$ war axes. Each sword weights $$$s$$$ units and each war axe\u00a0\u2014 $$$w$$$ units. You don't care what to take, since each of them will melt into one steel ingot.What is the maximum number of weapons (both swords and war axes) you and your follower can carry out from the shop?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers $$$p$$$ and $$$f$$$ ($$$1 \\\\le p, f \\\\le 10^9$$$)\u00a0\u2014 yours and your follower's capacities.\nThe second line of each test case contains two integers $$$cnt_s$$$ and $$$cnt_w$$$ ($$$1 \\\\le cnt_s, cnt_w \\\\le 2 \\\\cdot 10^5$$$)\u00a0\u2014 the number of swords and war axes in the shop.\nThe third line of each test case contains two integers $$$s$$$ and $$$w$$$ ($$$1 \\\\le s, w \\\\le 10^9$$$)\u00a0\u2014 the weights of each sword and each war axe.\nIt's guaranteed that the total number of swords and the total number of war axes in all test cases don't exceed $$$2 \\\\cdot 10^5$$$.\n","output_spec":"For each test case, print the maximum number of weapons (both swords and war axes) you and your follower can carry.\n","notes":null,"sample_inputs":[],"sample_outputs":[],"id":"1400-B","difficulty":1700,"tags":["brute+force","greedy","math"],"src_uid":"ee32db8e7cdd9561d9215651ff8a262e","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int t;\\n    cin >> t;\\n    while (t--) {\\n        long long p, f;\\n        cin >> p >> f;\\n        long long cnt_s, cnt_w;\\n        cin >> cnt_s >> cnt_w;\\n        long long s, w;\\n        cin >> s >> w;\\n        if (s > w) {\\n            swap(s, w);\\n            swap(cnt_s, cnt_w);\\n        }\\n        long long ans = 0;\\n        for (long long i = 0; i <= min(cnt_s, p \/ s); i++) {\\n            long long j = min(cnt_w, (p - i * s) \/ w);\\n            long long k = min(cnt_s - i, f \/ s);\\n            long long l = min(cnt_w - j, (f - k * s) \/ w);\\n            ans = max(ans, i + j + k + l);\\n        }\\n        cout << ans << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int t = scanner.nextInt();\\n\\n        while (t-- > 0) {\\n            int p = scanner.nextInt();\\n            int f = scanner.nextInt();\\n            int cnt_s = scanner.nextInt();\\n            int cnt_w = scanner.nextInt();\\n            int s = scanner.nextInt();\\n            int w = scanner.nextInt();\\n\\n            int maxWeapons = 0;\\n\\n            for (int i = 0; i <= cnt_s; i++) {\\n                int swordsTaken = Math.min(i, p \/ s);\\n                int warAxesTaken = Math.min(cnt_w, (p - swordsTaken * s) \/ w);\\n\\n                int followerSwordsTaken = Math.min(cnt_s - i, f \/ s);\\n                int followerWarAxesTaken = Math.min(cnt_w - warAxesTaken, (f - followerSwordsTaken * s) \/ w);\\n\\n                maxWeapons = Math.max(maxWeapons, swordsTaken + warAxesTaken + followerSwordsTaken + followerWarAxesTaken);\\n            }\\n\\n            System.out.println(maxWeapons);\\n        }\\n    }\\n}","Python":"def max_weapons(t, test_cases):\n    results = []\n    for i in range(t):\n        p, f = test_cases[i][0]\n        cnt_s, cnt_w = test_cases[i][1]\n        s, w = test_cases[i][2]\n        \n        max_weapons = 0\n        \n        for j in range(cnt_s+1):\n            if j*s <= p:\n                max_weapons = max(max_weapons, j + min(cnt_w, (p-j*s)\/\/w) + min(cnt_s-j, f\/\/s))\n        \n        for j in range(cnt_w+1):\n            if j*w <= p:\n                max_weapons = max(max_weapons, j + min(cnt_s, (p-j*w)\/\/s) + min(cnt_w-j, f\/\/w))\n        \n        results.append(max_weapons)\n    \n    return results\n\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    p, f = map(int, input().split())\n    cnt_s, cnt_w = map(int, input().split())\n    s, w = map(int, input().split())\n    test_cases.append([(p, f), (cnt_s, cnt_w), (s, w)])\n\nresults = max_weapons(t, test_cases)\nfor result in results:\n    print(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int t;\\n    scanf(\\\"%d\\\", &t);\\n    while (t--) {\\n        int p, f, cnt_s, cnt_w, s, w;\\n        scanf(\\\"%d %d\\\", &p, &f);\\n        scanf(\\\"%d %d\\\", &cnt_s, &cnt_w);\\n        scanf(\\\"%d %d\\\", &s, &w);\\n\\n        int max_weapons = 0;\\n\\n        for (int i = 0; i <= cnt_s; i++) {\\n            int swords_taken = i;\\n            int axes_taken = p \/ s;\\n\\n            if (axes_taken > cnt_w) {\\n                axes_taken = cnt_w;\\n            }\\n\\n            int remaining_swords = cnt_s - swords_taken;\\n            int remaining_axes = cnt_w - axes_taken;\\n\\n            int follower_swords_taken = f \/ s;\\n\\n            if (follower_swords_taken > remaining_swords) {\\n                follower_swords_taken = remaining_swords;\\n            }\\n\\n            int follower_axes_taken = (f - (follower_swords_taken * s)) \/ w;\\n\\n            if (follower_axes_taken > remaining_axes) {\\n                follower_axes_taken = remaining_axes;\\n            }\\n\\n            int total_weapons = swords_taken + axes_taken + follower_swords_taken + follower_axes_taken;\\n\\n            if (total_weapons > max_weapons) {\\n                max_weapons = total_weapons;\\n            }\\n        }\\n\\n        printf(\\\"%d\\\\n\\\", max_weapons);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RPGSmithing\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int t = int.Parse(Console.ReadLine());\n\n            for (int i = 0; i < t; i++)\n            {\n                string[] capacities = Console.ReadLine().Split();\n                int p = int.Parse(capacities[0]);\n                int f = int.Parse(capacities[1]);\n\n                string[] counts = Console.ReadLine().Split();\n                int cnt_s = int.Parse(counts[0]);\n                int cnt_w = int.Parse(counts[1]);\n\n                string[] weights = Console.ReadLine().Split();\n                int s = int.Parse(weights[0]);\n                int w = int.Parse(weights[1]);\n\n                int maxWeapons = GetMaxWeapons(p, f, cnt_s, cnt_w, s, w);\n                Console.WriteLine(maxWeapons);\n            }\n        }\n\n        static int GetMaxWeapons(int p, int f, int cnt_s, int cnt_w, int s, int w)\n        {\n            int maxWeapons = 0;\n\n            for (int i = 0; i <= cnt_s; i++)\n            {\n                int swordsTaken = Math.Min(i, p \/ s);\n                int warAxesTaken = Math.Min((p - (swordsTaken * s)) \/ w, cnt_w);\n\n                int followerSwordsTaken = Math.Min((cnt_s - swordsTaken), f \/ s);\n                int followerWarAxesTaken = Math.Min((f - (followerSwordsTaken * s)) \/ w, cnt_w - warAxesTaken);\n\n                int totalWeapons = swordsTaken + warAxesTaken + followerSwordsTaken + followerWarAxesTaken;\n                maxWeapons = Math.Max(maxWeapons, totalWeapons);\n            }\n\n            return maxWeapons;\n        }\n    }\n}","Ruby":"\ndef max_weapons(t, test_cases)\n  results = []\n  \n  test_cases.each do |test|\n    p, f = test[0]\n    cnt_s, cnt_w = test[1]\n    s, w = test[2]\n    \n    max_weapons = 0\n    \n    # Calculate the maximum number of swords and war axes that can be carried by you and your follower\n    for i in 0..cnt_s\n      swords_taken = [i, p \/ s].min\n      war_axes_taken = [cnt_w, (p - swords_taken * s) \/ w].min\n      \n      follower_swords_taken = [cnt_s - swords_taken, f \/ s].min\n      follower_war_axes_taken = [cnt_w - war_axes_taken, (f - follower_swords_taken * s) \/ w].min\n      \n      total_weapons = swords_taken + war_axes_taken + follower_swords_taken + follower_war_axes_taken\n      \n      max_weapons = [max_weapons, total_weapons].max\n    end\n    \n    results << max_weapons\n  end\n  \n  return results\nend\n\n# Read the number of test cases\nt = gets.chomp.to_i\n\ntest_cases = []\n\n# Read the test cases\nt.times do\n  p, f = gets.chomp.split.map(&:to_i)\n  cnt_s, cnt_w = gets.chomp.split.map(&:to_i)\n  s, w = gets.chomp.split.map(&:to_i)\n  \n  test_cases << [[p, f], [cnt_s, cnt_w], [s, w]]\nend\n\n# Calculate and print the maximum number of weapons for each test case\nmax_weapons(t, test_cases).each do |result|\n  puts result\nend\n","delphi":"program RPGRobbery;\\n\\nvar\\n  t, i: Integer;\\n  p, f, cnt_s, cnt_w, s, w: Int64;\\n  maxWeapons: Int64;\\nbegin\\n  ReadLn(t);\\n  for i := 1 to t do\\n  begin\\n    ReadLn(p, f);\\n    ReadLn(cnt_s, cnt_w);\\n    ReadLn(s, w);\\n    maxWeapons := 0;\\n    if s < w then\\n    begin\\n      maxWeapons := Min(cnt_s, p div s);\\n      p := p - (maxWeapons * s);\\n      maxWeapons := maxWeapons + Min(cnt_w, p div w);\\n      f := f - Min(cnt_w, p div w);\\n      maxWeapons := maxWeapons + Min(cnt_w, f div w);\\n    end\\n    else\\n    begin\\n      maxWeapons := Min(cnt_w, p div w);\\n      p := p - (maxWeapons * w);\\n      maxWeapons := maxWeapons + Min(cnt_s, p div s);\\n      f := f - Min(cnt_s, p div s);\\n      maxWeapons := maxWeapons + Min(cnt_s, f div s);\\n    end;\\n    WriteLn(maxWeapons);\\n  end;\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tt := nextInt(scanner)\\n\\n\\tfor i := 0; i < t; i++ {\\n\\t\\tp := nextInt(scanner)\\n\\t\\tf := nextInt(scanner)\\n\\t\\tcnt_s := nextInt(scanner)\\n\\t\\tcnt_w := nextInt(scanner)\\n\\t\\ts := nextInt(scanner)\\n\\t\\tw := nextInt(scanner)\\n\\n\\t\\tmaxWeapons := getMaxWeapons(p, f, cnt_s, cnt_w, s, w)\\n\\t\\tfmt.Println(maxWeapons)\\n\\t}\\n}\\n\\nfunc getMaxWeapons(p, f, cnt_s, cnt_w, s, w int) int {\\n\\tmaxWeapons := 0\\n\\n\\tfor i := 0; i <= cnt_s; i++ {\\n\\t\\tif i*s <= p {\\n\\t\\t\\tweapons := i\\n\\t\\t\\tremainingWeight := p - i*s\\n\\t\\t\\tweapons += min(remainingWeight\/w, cnt_w)\\n\\t\\t\\tmaxWeapons = max(maxWeapons, weapons)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i <= cnt_w; i++ {\\n\\t\\tif i*w <= p {\\n\\t\\t\\tweapons := i\\n\\t\\t\\tremainingWeight := p - i*w\\n\\t\\t\\tweapons += min(remainingWeight\/s, cnt_s)\\n\\t\\t\\tmaxWeapons = max(maxWeapons, weapons)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i <= cnt_s; i++ {\\n\\t\\tif i*s <= f {\\n\\t\\t\\tweapons := i\\n\\t\\t\\tremainingWeight := f - i*s\\n\\t\\t\\tweapons += min(remainingWeight\/w, cnt_w)\\n\\t\\t\\tmaxWeapons = max(maxWeapons, weapons)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i <= cnt_w; i++ {\\n\\t\\tif i*w <= f {\\n\\t\\t\\tweapons := i\\n\\t\\t\\tremainingWeight := f - i*w\\n\\t\\t\\tweapons += min(remainingWeight\/s, cnt_s)\\n\\t\\t\\tmaxWeapons = max(maxWeapons, weapons)\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxWeapons\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc nextInt(scanner *bufio.Scanner) int {\\n\\tscanner.Scan()\\n\\tnum := 0\\n\\tfmt.Sscanf(scanner.Text(), \\\"%d\\\", &num)\\n\\treturn num\\n}","Javascript":"function getMaxWeapons(t, testCases) {\n  let results = [];\n  \n  for (let i = 0; i < t; i++) {\n    let [p, f] = testCases[i][0];\n    let [cnt_s, cnt_w] = testCases[i][1];\n    let [s, w] = testCases[i][2];\n    \n    let maxWeapons = 0;\n    \n    for (let j = 0; j <= cnt_s; j++) {\n      let swordsTaken = Math.min(j, p \/ s);\n      let warAxesTaken = Math.min((p - (swordsTaken * s)) \/ w, cnt_w);\n      \n      let followerSwordsTaken = Math.min((cnt_s - j), f \/ s);\n      let followerWarAxesTaken = Math.min((f - (followerSwordsTaken * s)) \/ w, cnt_w - warAxesTaken);\n      \n      let totalWeapons = swordsTaken + warAxesTaken + followerSwordsTaken + followerWarAxesTaken;\n      \n      maxWeapons = Math.max(maxWeapons, totalWeapons);\n    }\n    \n    results.push(maxWeapons);\n  }\n  \n  return results;\n}\n\nlet t = 2;\nlet testCases = [\n  [[10, 5], [3, 5], [2, 3]],\n  [[20, 10], [5, 10], [4, 2]]\n];\n\nlet results = getMaxWeapons(t, testCases);\nconsole.log(results);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val t = scanner.nextInt()\n    \n    repeat(t) {\n        val p = scanner.nextLong()\n        val f = scanner.nextLong()\n        val cnt_s = scanner.nextLong()\n        val cnt_w = scanner.nextLong()\n        val s = scanner.nextLong()\n        val w = scanner.nextLong()\n        \n        val maxWeapons = getMaxWeapons(p, f, cnt_s, cnt_w, s, w)\n        println(maxWeapons)\n    }\n}\n\nfun getMaxWeapons(p: Long, f: Long, cnt_s: Long, cnt_w: Long, s: Long, w: Long): Long {\n    var maxWeapons = 0L\n    \n    for (i in 0..cnt_s) {\n        val swordsTaken = i\n        val axesTaken = minOf(cnt_w, p \/ s)\n        \n        val remainingSwords = cnt_s - swordsTaken\n        val remainingAxes = cnt_w - axesTaken\n        \n        val followerSwordsTaken = minOf(remainingSwords, f \/ s)\n        val followerAxesTaken = minOf(remainingAxes, (f - followerSwordsTaken * s) \/ w)\n        \n        val totalWeapons = swordsTaken + axesTaken + followerSwordsTaken + followerAxesTaken\n        \n        maxWeapons = maxOf(maxWeapons, totalWeapons)\n    }\n    \n    return maxWeapons\n}","PHP":"<?php\\n\\nfunction getMaxWeapons($p, $f, $cnt_s, $cnt_w, $s, $w) {\\n    \/\/ Calculate the maximum number of swords and war axes that can be carried by you and your follower\\n    $maxWeapons = 0;\\n    for ($i = 0; $i <= $cnt_s; $i++) {\\n        \/\/ Calculate the number of swords that can be carried by you\\n        $swordsCarriedByYou = min($i, $p \/ $s);\\n        \/\/ Calculate the number of war axes that can be carried by your follower\\n        $warAxesCarriedByFollower = min($cnt_w, ($p - ($swordsCarriedByYou * $s)) \/ $w);\\n        \/\/ Calculate the number of swords that can be carried by your follower\\n        $swordsCarriedByFollower = min($cnt_s - $i, $f \/ $s);\\n        \/\/ Calculate the number of war axes that can be carried by you\\n        $warAxesCarriedByYou = min($cnt_w - $warAxesCarriedByFollower, ($p - ($swordsCarriedByFollower * $s)) \/ $w);\\n        \/\/ Calculate the total number of weapons carried\\n        $totalWeapons = $swordsCarriedByYou + $warAxesCarriedByFollower + $swordsCarriedByFollower + $warAxesCarriedByYou;\\n        \/\/ Update the maximum number of weapons\\n        $maxWeapons = max($maxWeapons, $totalWeapons);\\n    }\\n    return $maxWeapons;\\n}\\n\\n\/\/ Read the number of test cases\\n$t = intval(fgets(STDIN));\\n\\n\/\/ Iterate through each test case\\nfor ($i = 0; $i < $t; $i++) {\\n    \/\/ Read the input for each test case\\n    list($p, $f) = array_map('intval', explode(' ', fgets(STDIN)));\\n    list($cnt_s, $cnt_w) = array_map('intval', explode(' ', fgets(STDIN)));\\n    list($s, $w) = array_map('intval', explode(' ', fgets(STDIN)));\\n    \/\/ Calculate and print the maximum number of weapons\\n    echo getMaxWeapons($p, $f, $cnt_s, $cnt_w, $s, $w) . \\\"\\\\n\\\";\\n}\\n?>","d":"\nimport std.stdio;\n\nvoid main()\n{\n    int t;\n    scanf(\\\"%d\\\", &t);\n\n    for (int i = 0; i < t; i++)\n    {\n        int p, f, cnt_s, cnt_w, s, w;\n        scanf(\\\"%d %d\\\", &p, &f);\n        scanf(\\\"%d %d\\\", &cnt_s, &cnt_w);\n        scanf(\\\"%d %d\\\", &s, &w);\n\n        int maxWeapons = 0;\n\n        for (int j = 0; j <= cnt_s; j++)\n        {\n            int swordsTaken = j;\n            int axesTaken = min(cnt_w, p \/ s);\n            int remainingSwords = cnt_s - swordsTaken;\n            int remainingAxes = cnt_w - axesTaken;\n            int followerSwords = min(remainingSwords, f \/ s);\n            int followerAxes = min(remainingAxes, (f - followerSwords * s) \/ w);\n\n            int totalWeapons = swordsTaken + axesTaken + followerSwords + followerAxes;\n            maxWeapons = max(maxWeapons, totalWeapons);\n        }\n\n        printf(\\\"%d\\\\n\\\", maxWeapons);\n    }\n}\n","perl":"\nuse strict;\nuse warnings;\n\nsub maximum_weapons {\n    my ($p, $f, $cnt_s, $cnt_w, $s, $w) = @_;\n\n    my $max_weapons = 0;\n\n    for (my $i = 0; $i <= $cnt_s; $i++) {\n        my $swords_taken = min($i, int($p \/ $s));\n        my $axes_taken = min(int(($p - $swords_taken * $s) \/ $w), int($f \/ $w));\n\n        my $total_weapons = $swords_taken + $axes_taken;\n\n        my $remaining_swords = $cnt_s - $i;\n        my $remaining_axes = $cnt_w - $axes_taken;\n\n        my $follower_swords_taken = min($remaining_swords, int($f \/ $s));\n        my $follower_axes_taken = min($remaining_axes, int(($f - $follower_swords_taken * $s) \/ $w));\n\n        $total_weapons += $follower_swords_taken + $follower_axes_taken;\n\n        $max_weapons = max($max_weapons, $total_weapons);\n    }\n\n    return $max_weapons;\n}\n\nmy $t = <>;\nchomp($t);\n\nmy @results;\n\nfor (my $i = 0; $i < $t; $i++) {\n    my $line1 = <>;\n    chomp($line1);\n    my ($p, $f) = split(' ', $line1);\n\n    my $line2 = <>;\n    chomp($line2);\n    my ($cnt_s, $cnt_w) = split(' ', $line2);\n\n    my $line3 = <>;\n    chomp($line3);\n    my ($s, $w) = split(' ', $line3);\n\n    my $result = maximum_weapons($p, $f, $cnt_s, $cnt_w, $s, $w);\n    push(@results, $result);\n}\n\nforeach my $result (@results) {\n    print \"$result\\n\";\n}\n","Rust":"\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let t: usize = lines.next().unwrap().parse().unwrap();\n    \n    for _ in 0..t {\n        let capacities: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        let counts: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        let weights: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        \n        let p = capacities[0];\n        let f = capacities[1];\n        let cnt_s = counts[0];\n        let cnt_w = counts[1];\n        let s = weights[0];\n        let w = weights[1];\n        \n        let mut max_weapons = 0;\n        \n        for i in 0..=cnt_s {\n            if i * s <= p {\n                let remaining_p = p - i * s;\n                let remaining_f = f.min(cnt_w * w);\n                let weapons = i + remaining_f \/ w + remaining_p \/ s;\n                max_weapons = max_weapons.max(weapons);\n            }\n        }\n        \n        println!(\"{}\", max_weapons);\n    }\n}\n"}
{"title":"A. Amusing Joke","description":"So, the New Year holidays are over. Santa Claus and his colleagues can take a rest and have guests at last. When two \"New Year and Christmas Men\" meet, thear assistants cut out of cardboard the letters from the guest's name and the host's name in honor of this event. Then the hung the letters above the main entrance. One night, when everyone went to bed, someone took all the letters of our characters' names. Then he may have shuffled the letters and put them in one pile in front of the door.The next morning it was impossible to find the culprit who had made the disorder. But everybody wondered whether it is possible to restore the names of the host and his guests from the letters lying at the door? That is, we need to verify that there are no extra letters, and that nobody will need to cut more letters.Help the \"New Year and Christmas Men\" and their friends to cope with this problem. You are given both inscriptions that hung over the front door the previous night, and a pile of letters that were found at the front door next morning.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The input file consists of three lines: the first line contains the guest's name, the second line contains the name of the residence host and the third line contains letters in a pile that were found at the door in the morning. All lines are not empty and contain only uppercase Latin letters. The length of each line does not exceed 100.\n","output_spec":"Print \"YES\" without the quotes, if the letters in the pile could be permuted to make the names of the \"New Year and Christmas Men\". Otherwise, print \"NO\" without the quotes.\n","notes":"In the first sample the letters written in the last line can be used to write the names and there won't be any extra letters left.\nIn the second sample letter \"P\" is missing from the pile and there's an extra letter \"L\".\nIn the third sample there's an extra letter \"L\".\n","sample_inputs":["SANTACLAUS\nDEDMOROZ\nSANTAMOROZDEDCLAUS\n","PAPAINOEL\nJOULUPUKKI\nJOULNAPAOILELUPUKKI\n","BABBONATALE\nFATHERCHRISTMAS\nBABCHRISTMASBONATALLEFATHER\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"id":"141-A","difficulty":800,"tags":["implementation","sortings","strings"],"src_uid":"b6456a39d38fabcd25267793ed94d90c","C++":"#include <iostream>\\n#include <algorithm>\\n#include <string>\\n\\nusing namespace std;\\n\\nbool canRestoreNames(string guest, string host, string pile) {\\n    string names = guest + host;\\n    sort(names.begin(), names.end());\\n    sort(pile.begin(), pile.end());\\n    return names == pile;\\n}\\n\\nint main() {\\n    string guest, host, pile;\\n    cin >> guest >> host >> pile;\\n    if (canRestoreNames(guest, host, pile)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Arrays;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        String[] inputs = {\\n                \\\"SANTACLAUS\\\",\\n                \\\"DEDMOROZ\\\",\\n                \\\"SANTAMOROZDEDCLAUS\\\"\\n        };\\n        String[] outputs = {\\n                \\\"YES\\\",\\n                \\\"NO\\\",\\n                \\\"NO\\\"\\n        };\\n\\n        for (int i = 0; i < inputs.length; i++) {\\n            String[] names = inputs[i].split(\\\"\\n\\\");\\n            String pile = names[2];\\n\\n            boolean result = canRestoreNames(names[0], names[1], pile);\\n\\n            if (result) {\\n                System.out.println(\\\"YES\\\");\\n            } else {\\n                System.out.println(\\\"NO\\\");\\n            }\\n\\n            if (!outputs[i].equals(result ? \\\"YES\\\" : \\\"NO\\\")) {\\n                System.out.println(\\\"Test case \\\" + (i + 1) + \\\" failed\\\");\\n            }\\n        }\\n    }\\n\\n    public static boolean canRestoreNames(String guestName, String hostName, String pile) {\\n        String combinedNames = guestName + hostName;\\n        char[] combinedChars = combinedNames.toCharArray();\\n        char[] pileChars = pile.toCharArray();\\n\\n        Arrays.sort(combinedChars);\\n        Arrays.sort(pileChars);\\n\\n        return Arrays.equals(combinedChars, pileChars);\\n    }\\n}\"}}","Python":"def verify_names(guest_name, host_name, pile_letters):\n    guest_name = sorted(guest_name)\n    host_name = sorted(host_name)\n    pile_letters = sorted(pile_letters)\n    \n    if len(guest_name) + len(host_name) != len(pile_letters):\n        return 'NO'\n    \n    combined_name = guest_name + host_name\n    combined_name.sort()\n    \n    if combined_name == pile_letters:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Sample Inputs\ninputs = [\n    ['SANTACLAUS', 'DEDMOROZ', 'SANTAMOROZDEDCLAUS'],\n    ['PAPAINOEL', 'JOULUPUKKI', 'JOULNAPAOILELUPUKKI'],\n    ['BABBONATALE', 'FATHERCHRISTMAS', 'BABCHRISTMASBONATALLEFATHER']\n]\n\n# Sample Outputs\noutputs = ['YES', 'NO', 'NO']\n\n# Verify the outputs\nfor i, input_data in enumerate(inputs):\n    guest_name, host_name, pile_letters = input_data\n    output = verify_names(guest_name, host_name, pile_letters)\n    assert output == outputs[i]\n\nprint('All test cases passed!')","C":"#include <stdio.h>\\n#include <string.h>\\n\\nvoid sortString(char* str)\\n{\\n    int n = strlen(str);\\n    int i, j;\\n    char temp;\\n    for (i = 0; i < n-1; i++)\\n    {\\n        for (j = i+1; j < n; j++)\\n        {\\n            if (str[i] > str[j])\\n            {\\n                temp = str[i];\\n                str[i] = str[j];\\n                str[j] = temp;\\n            }\\n        }\\n    }\\n}\\n\\nint main()\\n{\\n    char guest[101];\\n    char host[101];\\n    char pile[301];\\n    scanf(\\\"%s\\\", guest);\\n    scanf(\\\"%s\\\", host);\\n    scanf(\\\"%s\\\", pile);\\n    int guestLen = strlen(guest);\\n    int hostLen = strlen(host);\\n    int pileLen = strlen(pile);\\n    if (guestLen + hostLen != pileLen)\\n    {\\n        printf(\\\"NO\\\\n\\\");\\n        return 0;\\n    }\\n    char combined[401];\\n    strcpy(combined, guest);\\n    strcat(combined, host);\\n    sortString(combined);\\n    sortString(pile);\\n    if (strcmp(combined, pile) == 0)\\n    {\\n        printf(\\\"YES\\\\n\\\");\\n    }\\n    else\\n    {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string guestName = Console.ReadLine();\n        string hostName = Console.ReadLine();\n        string pileLetters = Console.ReadLine();\n\n        bool canRestoreNames = CanRestoreNames(guestName, hostName, pileLetters);\n\n        if (canRestoreNames)\n        {\n            Console.WriteLine(\\\"YES\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"NO\\\");\n        }\n    }\n\n    public static bool CanRestoreNames(string guestName, string hostName, string pileLetters)\n    {\n        Dictionary<char, int> guestNameLetters = CountLetters(guestName);\n        Dictionary<char, int> hostNameLetters = CountLetters(hostName);\n        Dictionary<char, int> pileLettersCount = CountLetters(pileLetters);\n\n        foreach (var letter in guestNameLetters.Keys)\n        {\n            if (!pileLettersCount.ContainsKey(letter) || pileLettersCount[letter] < guestNameLetters[letter])\n            {\n                return false;\n            }\n        }\n\n        foreach (var letter in hostNameLetters.Keys)\n        {\n            if (!pileLettersCount.ContainsKey(letter) || pileLettersCount[letter] < hostNameLetters[letter])\n            {\n                return false;\n            }\n        }\n\n        foreach (var letter in pileLettersCount.Keys)\n        {\n            if (!guestNameLetters.ContainsKey(letter) && !hostNameLetters.ContainsKey(letter))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static Dictionary<char, int> CountLetters(string word)\n    {\n        Dictionary<char, int> letterCount = new Dictionary<char, int>();\n\n        foreach (char letter in word)\n        {\n            if (letterCount.ContainsKey(letter))\n            {\n                letterCount[letter]++;\n            }\n            else\n            {\n                letterCount[letter] = 1;\n            }\n        }\n\n        return letterCount;\n    }\n}","Ruby":"\ndef can_permute_names(guest_name, host_name, pile_letters)\n  # Count the frequency of each letter in the guest's name\n  guest_freq = Hash.new(0)\n  guest_name.each_char { |c| guest_freq[c] += 1 }\n\n  # Count the frequency of each letter in the host's name\n  host_freq = Hash.new(0)\n  host_name.each_char { |c| host_freq[c] += 1 }\n\n  # Count the frequency of each letter in the pile of letters\n  pile_freq = Hash.new(0)\n  pile_letters.each_char { |c| pile_freq[c] += 1 }\n\n  # Check if the pile of letters contains all the necessary letters\n  (guest_freq.keys + host_freq.keys).each do |letter|\n    return 'NO' if pile_freq[letter] < (guest_freq[letter] + host_freq[letter])\n  end\n\n  # Check if there are any extra letters in the pile\n  pile_freq.each do |letter, freq|\n    return 'NO' if freq > (guest_freq[letter] + host_freq[letter])\n  end\n\n  'YES'\nend\n\n# Example usage\nguest_name = 'SANTACLAUS'\nhost_name = 'DEDMOROZ'\npile_letters = 'SANTAMOROZDEDCLAUS'\n\nputs can_permute_names(guest_name, host_name, pile_letters)\n","delphi":"function CheckNames(guestName, hostName, pileLetters: string): string;\\nvar\\n  guestCount, hostCount, pileCount: array[Char] of Integer;\\n  i: Integer;\\nbegin\\n  \/\/ Initialize count arrays\\n  for i := 0 to Length(guestName) - 1 do\\n    Inc(guestCount[guestName[i+1]]);\\n  for i := 0 to Length(hostName) - 1 do\\n    Inc(hostCount[hostName[i+1]]);\\n  for i := 0 to Length(pileLetters) - 1 do\\n    Inc(pileCount[pileLetters[i+1]]);\\n\\n  \/\/ Check if all letters in guest and host names are present in the pile\\n  for i := 0 to 25 do\\n  begin\\n    if guestCount[Chr(65+i)] + hostCount[Chr(65+i)] > pileCount[Chr(65+i)] then\\n    begin\\n      Result := 'NO';\\n      Exit;\\n    end;\\n  end;\\n\\n  \/\/ Check if there are any extra letters in the pile\\n  for i := 0 to 25 do\\n  begin\\n    if pileCount[Chr(65+i)] > guestCount[Chr(65+i)] + hostCount[Chr(65+i)] then\\n    begin\\n      Result := 'NO';\\n      Exit;\\n    end;\\n  end;\\n\\n  Result := 'YES';\\nend;\\n\\nvar\\n  guestName, hostName, pileLetters: string;\\nbegin\\n  \/\/ Read input\\n  guestName := 'SANTACLAUS';\\n  hostName := 'DEDMOROZ';\\n  pileLetters := 'SANTAMOROZDEDCLAUS';\\n\\n  \/\/ Call function to check names\\n  WriteLn(CheckNames(guestName, hostName, pileLetters));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar guest, host, pile string\\n\\tfmt.Scan(&guest)\\n\\tfmt.Scan(&host)\\n\\tfmt.Scan(&pile)\\n\\n\\tguestHost := guest + host\\n\\n\\tif len(guestHost) != len(pile) {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\tguestHostSorted := sortString(guestHost)\\n\\tpileSorted := sortString(pile)\\n\\n\\tif guestHostSorted == pileSorted {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}\\n\\nfunc sortString(s string) string {\\n\\tchars := strings.Split(s, \\\"\\\")\\n\\tsort.Strings(chars)\\n\\treturn strings.Join(chars, \\\"\\\")\\n}","Javascript":"function verifyNames(guestName, hostName, pileLetters) {\n  \/\/ Create a frequency map for the guest's name\n  const guestMap = {};\n  for (let i = 0; i < guestName.length; i++) {\n    const letter = guestName[i];\n    guestMap[letter] = (guestMap[letter] || 0) + 1;\n  }\n  \n  \/\/ Create a frequency map for the host's name\n  const hostMap = {};\n  for (let i = 0; i < hostName.length; i++) {\n    const letter = hostName[i];\n    hostMap[letter] = (hostMap[letter] || 0) + 1;\n  }\n  \n  \/\/ Check if all letters in the pile can be used to form the names\n  for (let i = 0; i < pileLetters.length; i++) {\n    const letter = pileLetters[i];\n    \n    \/\/ Check if the letter is needed for the guest's name\n    if (guestMap[letter] && guestMap[letter] > 0) {\n      guestMap[letter]--;\n    }\n    \/\/ Check if the letter is needed for the host's name\n    else if (hostMap[letter] && hostMap[letter] > 0) {\n      hostMap[letter]--;\n    }\n    \/\/ If the letter is not needed for either name, return \"NO\"\n    else {\n      return \"NO\";\n    }\n  }\n  \n  \/\/ Check if there are any extra letters left for the guest's name\n  for (const letter in guestMap) {\n    if (guestMap[letter] && guestMap[letter] > 0) {\n      return \"NO\";\n    }\n  }\n  \n  \/\/ Check if there are any extra letters left for the host's name\n  for (const letter in hostMap) {\n    if (hostMap[letter] && hostMap[letter] > 0) {\n      return \"NO\";\n    }\n  }\n  \n  \/\/ If all checks pass, return \"YES\"\n  return \"YES\";\n}\n\n\/\/ Test cases\nconst testCases = [\n  { guestName: 'SANTACLAUS', hostName: 'DEDMOROZ', pileLetters: 'SANTAMOROZDEDCLAUS' },\n  { guestName: 'PAPAINOEL', hostName: 'JOULUPUKKI', pileLetters: 'JOULNAPAOILELUPUKKI' },\n  { guestName: 'BABBONATALE', hostName: 'FATHERCHRISTMAS', pileLetters: 'BABCHRISTMASBONATALLEFATHER' }\n];\n\nconst results = [];\nfor (const testCase of testCases) {\n  const result = verifyNames(testCase.guestName, testCase.hostName, testCase.pileLetters);\n  results.push(result);\n}\n\nJSON.stringify(results);","Kotlin":"fun main() {\n    val guestName = readLine()!!\n    val hostName = readLine()!!\n    val pileLetters = readLine()!!\n\n    val guestNameCount = guestName.groupingBy { it }.eachCount()\n    val hostNameCount = hostName.groupingBy { it }.eachCount()\n    val pileLettersCount = pileLetters.groupingBy { it }.eachCount()\n\n    var isValid = true\n\n    for ((letter, count) in guestNameCount) {\n        if (pileLettersCount.getOrDefault(letter, 0) < count) {\n            isValid = false\n            break\n        }\n    }\n\n    for ((letter, count) in hostNameCount) {\n        if (pileLettersCount.getOrDefault(letter, 0) < count) {\n            isValid = false\n            break\n        }\n    }\n\n    if (isValid && pileLettersCount.size == guestNameCount.size + hostNameCount.size) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"<?php\\n\\nfunction verifyNames($guest, $host, $pile) {\\n    $guestCount = countLetters($guest);\\n    $hostCount = countLetters($host);\\n    $pileCount = countLetters($pile);\\n\\n    \/\/ Check if there are any extra letters in the pile\\n    foreach ($pileCount as $letter => $count) {\\n        if (!isset($guestCount[$letter]) && !isset($hostCount[$letter])) {\\n            return 'NO';\\n        }\\n        if (isset($guestCount[$letter]) && $count > $guestCount[$letter]) {\\n            return 'NO';\\n        }\\n        if (isset($hostCount[$letter]) && $count > $hostCount[$letter]) {\\n            return 'NO';\\n        }\\n    }\\n\\n    \/\/ Check if there are any missing letters in the pile\\n    foreach ($guestCount as $letter => $count) {\\n        if (!isset($pileCount[$letter]) || $count > $pileCount[$letter]) {\\n            return 'NO';\\n        }\\n    }\\n    foreach ($hostCount as $letter => $count) {\\n        if (!isset($pileCount[$letter]) || $count > $pileCount[$letter]) {\\n            return 'NO';\\n        }\\n    }\\n\\n    return 'YES';\\n}\\n\\nfunction countLetters($string) {\\n    $count = array();\\n    $length = strlen($string);\\n\\n    for ($i = 0; $i < $length; $i++) {\\n        $letter = $string[$i];\\n        if (isset($count[$letter])) {\\n            $count[$letter]++;\\n        } else {\\n            $count[$letter] = 1;\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    ['SANTACLAUS', 'DEDMOROZ', 'SANTAMOROZDEDCLAUS'],\\n    ['PAPAINOEL', 'JOULUPUKKI', 'JOULNAPAOILELUPUKKI'],\\n    ['BABBONATALE', 'FATHERCHRISTMAS', 'BABCHRISTMASBONATALLEFATHER'],\\n];\\n\\n\/\/ Verify names for each input\\n$outputs = array();\\nforeach ($inputs as $input) {\\n    $guest = $input[0];\\n    $host = $input[1];\\n    $pile = $input[2];\\n\\n    $result = verifyNames($guest, $host, $pile);\\n    $outputs[] = $result;\\n}\\n\\n\/\/ Print outputs\\nforeach ($outputs as $output) {\\n    echo $output . \\\"\\\\n\\\";\\n}\\n\\n?>","d":"import std.algorithm;\\nimport std.array;\\nimport std.stdio;\\n\\nstring checkNames(string guest, string host, string pile)\\n{\\n    string combined = guest ~ host;\\n    if (combined.length != pile.length)\\n    {\\n        return \\\"NO\\\";\\n    }\\n    foreach (char c; pile)\\n    {\\n        auto index = combined.indexOf(c);\\n        if (index == -1)\\n        {\\n            return \\\"NO\\\";\\n        }\\n        combined = combined.remove(index, 1);\\n    }\\n    return combined.empty ? \\\"YES\\\" : \\\"NO\\\";\\n}\\n\\nvoid main()\\n{\\n    string[] inputs = [\\n        \\\"SANTACLAUS\\\\nDEDMOROZ\\\\nSANTAMOROZDEDCLAUS\\\\n\\\",\\n        \\\"PAPAINOEL\\\\nJOULUPUKKI\\\\nJOULNAPAOILELUPUKKI\\\\n\\\",\\n        \\\"BABBONATALE\\\\nFATHERCHRISTMAS\\\\nBABCHRISTMASBONATALLEFATHER\\\\n\\\"\\n    ];\\n    string[] outputs = [\\n        \\\"YES\\\\n\\\",\\n        \\\"NO\\\\n\\\",\\n        \\\"NO\\\\n\\\"\\n    ];\\n\\n    foreach (i, input; inputs)\\n    {\\n        auto output = checkNames(input.split('\\\\n')[0], input.split('\\\\n')[1], input.split('\\\\n')[2]);\\n        assert(output == outputs[i]);\\n    }\\n\\n    writeln(\\\"All test cases passed!\\\");\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub check_permutation {\\n    my ($guest, $host, $pile) = @_;\\n    my %guest_letters;\\n    my %host_letters;\\n    my %pile_letters;\\n\\n    # Count the frequency of each letter in the guest's name\\n    foreach my $letter (split('', $guest)) {\\n        $guest_letters{$letter}++;\\n    }\\n\\n    # Count the frequency of each letter in the host's name\\n    foreach my $letter (split('', $host)) {\\n        $host_letters{$letter}++;\\n    }\\n\\n    # Count the frequency of each letter in the pile\\n    foreach my $letter (split('', $pile)) {\\n        $pile_letters{$letter}++;\\n    }\\n\\n    # Check if the pile contains all the required letters\\n    foreach my $letter (keys %guest_letters) {\\n        if (!exists $pile_letters{$letter} || $pile_letters{$letter} < $guest_letters{$letter}) {\\n            return 'NO';\\n        }\\n    }\\n\\n    foreach my $letter (keys %host_letters) {\\n        if (!exists $pile_letters{$letter} || $pile_letters{$letter} < $host_letters{$letter}) {\\n            return 'NO';\\n        }\\n    }\\n\\n    # Check if there are any extra letters in the pile\\n    foreach my $letter (keys %pile_letters) {\\n        if (!exists $guest_letters{$letter} && !exists $host_letters{$letter}) {\\n            return 'NO';\\n        }\\n    }\\n\\n    return 'YES';\\n}\\n\\n# Test the function\\nmy $input = ['SANTACLAUS\\nDEDMOROZ\\nSANTAMOROZDEDCLAUS\\n', 'PAPAINOEL\\nJOULUPUKKI\\nJOULNAPAOILELUPUKKI\\n', 'BABBONATALE\\nFATHERCHRISTMAS\\nBABCHRISTMASBONATALLEFATHER\\n'];\\nmy $output = ['YES\\n', 'NO\\n', 'NO\\n'];\\n\\nfor (my $i = 0; $i < scalar(@$input); $i++) {\\n    my ($guest, $host, $pile) = split('\\n', $input->[$i]);\\n    my $expected_output = $output->[$i];\\n    my $result = check_permutation($guest, $host, $pile);\\n\\n    if ($result eq $expected_output) {\\n        print 'Test case ' . ($i + 1) . ' passed.\\n';\\n    } else {\\n        print 'Test case ' . ($i + 1) . ' failed.\\n';\\n    }\\n}\\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    \/\/ Read input from stdin\n    let stdin = io::stdin();\n    let lines: Vec<String> = stdin.lock().lines().map(|line| line.unwrap()).collect();\n\n    \/\/ Extract the guest's name, host's name, and pile of letters\n    let guest_name = lines[0].trim();\n    let host_name = lines[1].trim();\n    let pile_of_letters = lines[2].trim();\n\n    \/\/ Create a frequency map for the guest's name\n    let mut guest_freq_map: [usize; 26] = [0; 26];\n    for ch in guest_name.chars() {\n        let index = ch as usize - 'A' as usize;\n        guest_freq_map[index] += 1;\n    }\n\n    \/\/ Create a frequency map for the host's name\n    let mut host_freq_map: [usize; 26] = [0; 26];\n    for ch in host_name.chars() {\n        let index = ch as usize - 'A' as usize;\n        host_freq_map[index] += 1;\n    }\n\n    \/\/ Check if the pile of letters can be used to form the names\n    let mut pile_freq_map: [usize; 26] = [0; 26];\n    for ch in pile_of_letters.chars() {\n        let index = ch as usize - 'A' as usize;\n        pile_freq_map[index] += 1;\n    }\n\n    let mut valid = true;\n\n    \/\/ Check if there are any extra letters in the pile\n    for i in 0..26 {\n        if pile_freq_map[i] > guest_freq_map[i] + host_freq_map[i] {\n            valid = false;\n            break;\n        }\n    }\n\n    \/\/ Check if there are any missing letters in the pile\n    for i in 0..26 {\n        if pile_freq_map[i] < guest_freq_map[i] + host_freq_map[i] {\n            valid = false;\n            break;\n        }\n    }\n\n    \/\/ Print the result\n    if valid {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"A. Help Farmer","description":"Once upon a time in the Kingdom of Far Far Away lived Sam the Farmer. Sam had a cow named Dawn and he was deeply attached to her. Sam would spend the whole summer stocking hay to feed Dawn in winter. Sam scythed hay and put it into haystack. As Sam was a bright farmer, he tried to make the process of storing hay simpler and more convenient to use. He collected the hay into cubical hay blocks of the same size. Then he stored the blocks in his barn. After a summer spent in hard toil Sam stored A\u00b7B\u00b7C hay blocks and stored them in a barn as a rectangular parallelepiped A layers high. Each layer had B rows and each row had C blocks.At the end of the autumn Sam came into the barn to admire one more time the hay he'd been stacking during this hard summer. Unfortunately, Sam was horrified to see that the hay blocks had been carelessly scattered around the barn. The place was a complete mess. As it turned out, thieves had sneaked into the barn. They completely dissembled and took away a layer of blocks from the parallelepiped's front, back, top and sides. As a result, the barn only had a parallelepiped containing (A-1)\u00d7(B-2)\u00d7(C-2) hay blocks. To hide the evidence of the crime, the thieves had dissembled the parallelepiped into single 1\u00d71\u00d71 blocks and scattered them around the barn. After the theft Sam counted n hay blocks in the barn but he forgot numbers A, B \u0438 C.Given number n, find the minimally possible and maximally possible number of stolen hay blocks.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The only line contains integer n from the problem's statement (1\u2264n\u226410^9).\n","output_spec":"Print space-separated minimum and maximum number of hay blocks that could have been stolen by the thieves.\nNote that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n","notes":"Let's consider the first sample test. If initially Sam has a parallelepiped consisting of 32=2\u00d74\u00d74 hay blocks in his barn, then after the theft the barn has 4=(2-1)\u00d7(4-2)\u00d7(4-2) hay blocks left. Thus, the thieves could have stolen 32-4=28 hay blocks. If Sam initially had a parallelepiped consisting of 45=5\u00d73\u00d73 hay blocks in his barn, then after the theft the barn has 4=(5-1)\u00d7(3-2)\u00d7(3-2) hay blocks left. Thus, the thieves could have stolen 45-4=41 hay blocks. No other variants of the blocks' initial arrangement (that leave Sam with exactly 4 blocks after the theft) can permit the thieves to steal less than 28 or more than 41 blocks.\n","sample_inputs":["4\n","7\n","12\n"],"sample_outputs":["28 41\n","47 65\n","48 105\n"],"id":"142-A","difficulty":1600,"tags":["brute+force","math"],"src_uid":"2468eead8acc5b8f5ddc51bfa2bd4fb7","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    long long n;\\n    cin >> n;\\n\\n    long long min_stolen = 0, max_stolen = 0;\\n\\n    for (long long a = 1; a * a * a <= n; a++) {\\n        if (n % a == 0) {\\n            for (long long b = 1; b * b <= n \/ a; b++) {\\n                if ((n \/ a) % b == 0) {\\n                    long long c = (n \/ a) \/ b;\\n                    long long stolen = (a - 1) * (b - 2) * (c - 2);\\n                    if (min_stolen == 0 || stolen < min_stolen) {\\n                        min_stolen = stolen;\\n                    }\\n                    if (stolen > max_stolen) {\\n                        max_stolen = stolen;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    cout << min_stolen << \\\" \\\" << max_stolen << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class HayBlocks {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        long n = scanner.nextLong();\\n        scanner.close();\\n\\n        long minStolen = (long) Math.ceil(Math.cbrt(n));\\n        long maxStolen = (long) Math.ceil(Math.cbrt(n)) + 2;\\n\\n        System.out.println(minStolen * minStolen * minStolen - n + \\\" \\\" + maxStolen * maxStolen * maxStolen - n);\\n    }\\n}","Python":"import math\\n\\nn = int(input())\\n\\n# Calculate the minimum number of stolen hay blocks\\nmin_stolen = math.ceil(n\/7)\\n\\n# Calculate the maximum number of stolen hay blocks\\nmax_stolen = n + (n-1)*3\\n\\nprint(min_stolen, max_stolen)","C":"#include <stdio.h>\\n\\nint main() {\\n    long long int n;\\n    scanf(\\\"%lld\\\", &n);\\n    \\n    long long int min_stolen = (n + 1) * (n + 1) * (n + 1) - 1;\\n    long long int max_stolen = (n * n * n) + (n - 1) * (n - 1) * (n - 1);\\n    \\n    printf(\\\"%lld %lld\\\\n\\\", min_stolen, max_stolen);\\n    \\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        long n = long.Parse(Console.ReadLine());\n\n        long minStolen = (long)Math.Pow(n + 1, 2) - n;\n        long maxStolen = (long)Math.Pow(n + 2, 2) - n;\n\n        Console.WriteLine(minStolen + \\\" \\\" + maxStolen);\n    }\n}","Ruby":"\ndef find_stolen_blocks(n)\n  min_blocks = 0\n  max_blocks = 0\n\n  (1..Math.sqrt(n)).each do |a|\n    if n % a == 0\n      b_c = n \/ a\n      (1..Math.sqrt(b_c)).each do |b|\n        if b_c % b == 0\n          c = b_c \/ b\n          min_blocks = a * b * c if min_blocks == 0 || a * b * c < min_blocks\n          max_blocks = a * b * c if a * b * c > max_blocks\n        end\n      end\n    end\n  end\n\n  return \"#{min_blocks} #{max_blocks}\"\nend\n\ninput = gets.chomp.to_i\nputs find_stolen_blocks(input)\n","delphi":"program HayBlocks;\n\nvar\n  n: Int64;\n  minStolen, maxStolen: Int64;\n\nbegin\n  \/\/ Read input\n  ReadLn(n);\n  \n  \/\/ Calculate minimum and maximum stolen hay blocks\n  minStolen := (n + 1) * 8;\n  maxStolen := (n + 1) * 9;\n  \n  \/\/ Print output\n  WriteLn(minStolen, ' ', maxStolen);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int64\\n\\tfmt.Scan(&n)\\n\\n\\tminStolen := int64(math.MaxInt64)\\n\\tmaxStolen := int64(0)\\n\\n\\tfor a := int64(1); a*a*a <= n; a++ {\\n\\t\\tif n%a == 0 {\\n\\t\\t\\tfor b := a; b*b <= n\/a; b++ {\\n\\t\\t\\t\\tif (n\/a)%b == 0 {\\n\\t\\t\\t\\t\\tc := (n \/ a) \/ b\\n\\t\\t\\t\\t\\tif (a-1)*(b-2)*(c-2) == n-(a*b*c) {\\n\\t\\t\\t\\t\\t\\tminStolen = min(minStolen, n-(a*b*c))\\n\\t\\t\\t\\t\\t\\tmaxStolen = max(maxStolen, n-(a*b*c))\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minStolen, maxStolen)\\n}\\n\\nfunc min(a, b int64) int64 {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int64) int64 {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}","Javascript":"function calculateStolenHayBlocks(n) {\n    let minStolenBlocks = 0;\n    let maxStolenBlocks = 0;\n\n    for (let a = 1; a * a * a <= n; a++) {\n        if (n % a === 0) {\n            let bc = n \/ a;\n            for (let b = 1; b * b <= bc; b++) {\n                if (bc % b === 0) {\n                    let c = bc \/ b;\n                    let stolenBlocks = (a - 1) * (b - 2) * (c - 2);\n                    if (minStolenBlocks === 0 || stolenBlocks < minStolenBlocks) {\n                        minStolenBlocks = stolenBlocks;\n                    }\n                    if (stolenBlocks > maxStolenBlocks) {\n                        maxStolenBlocks = stolenBlocks;\n                    }\n                }\n            }\n        }\n    }\n\n    return minStolenBlocks + ' ' + maxStolenBlocks;\n}\n\nconst input = 4;\nconst output = calculateStolenHayBlocks(input);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextLong()\n\n    val minStolen = (n - 4) * 7\n    val maxStolen = (n - 4) * 15\n\n    println(\\\"$minStolen $maxStolen\\\")\n}","PHP":"\n<?php\n\nfunction calculateHayBlocks($n) {\n    $minStolen = 0;\n    $maxStolen = 0;\n    \n    for ($a = 1; $a * $a * $a <= $n; $a++) {\n        if ($n % $a == 0) {\n            $bc = $n \/ $a;\n            for ($b = 1; $b * $b <= $bc; $b++) {\n                if ($bc % $b == 0) {\n                    $c = $bc \/ $b;\n                    $minStolen = max($minStolen, ($a - 1) * ($b - 2) * ($c - 2));\n                    $maxStolen = max($maxStolen, ($a - 1) * ($b - 2) * ($c - 2));\n                }\n            }\n        }\n    }\n    \n    return $minStolen . ' ' . $maxStolen;\n}\n\n$input = trim(fgets(STDIN));\n$output = calculateHayBlocks($input);\necho $output;\n\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    ulong n = to!ulong(readln());\\r\\n    ulong minStolen = (n + 3) \/ 4;\\r\\n    ulong maxStolen = (n * 2 + 1) \/ 2;\\r\\n    writeln(minStolen, ' ', maxStolen);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_stolen_blocks {\n    my $n = shift;\n    \n    my $min_stolen_blocks = 0;\n    my $max_stolen_blocks = 0;\n    \n    for (my $a = 1; $a <= $n; $a++) {\n        for (my $b = 1; $b <= $n; $b++) {\n            for (my $c = 1; $c <= $n; $c++) {\n                my $remaining_blocks = ($a - 1) * ($b - 2) * ($c - 2);\n                \n                if ($remaining_blocks == $n) {\n                    my $total_blocks = $a * $b * $c;\n                    $min_stolen_blocks = $total_blocks - $n if $min_stolen_blocks == 0 || $total_blocks - $n < $min_stolen_blocks;\n                    $max_stolen_blocks = $total_blocks - $n if $total_blocks - $n > $max_stolen_blocks;\n                }\n            }\n        }\n    }\n    \n    return \"$min_stolen_blocks $max_stolen_blocks\";\n}\n\nmy $n = <>;\nchomp $n;\n\nmy $result = calculate_stolen_blocks($n);\nprint \"$result\\n\";\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n\n    let n: i64 = lines.next().unwrap().parse().unwrap();\n\n    let min_stolen = (n + 3) \/ 4;\n    let max_stolen = (n * 2 + 3) \/ 4;\n\n    println!(\\\"{} {}\\\", min_stolen, max_stolen);\n}"}
{"title":"D. Help Shrek and Donkey 2","description":"Having learned (not without some help from the Codeforces participants) to play the card game from the previous round optimally, Shrek and Donkey (as you may remember, they too live now in the Kingdom of Far Far Away) have decided to quit the boring card games and play with toy soldiers.The rules of the game are as follows: there is a battlefield, its size equals n\u00d7m squares, some squares contain the toy soldiers (the green ones belong to Shrek and the red ones belong to Donkey). Besides, each of the n lines of the area contains not more than two soldiers. During a move a players should select not less than 1 and not more than k soldiers belonging to him and make them either attack or retreat.An attack is moving all of the selected soldiers along the lines on which they stand in the direction of an enemy soldier, if he is in this line. If this line doesn't have an enemy soldier, then the selected soldier on this line can move in any direction during the player's move. Each selected soldier has to move at least by one cell. Different soldiers can move by a different number of cells. During the attack the soldiers are not allowed to cross the cells where other soldiers stand (or stood immediately before the attack). It is also not allowed to go beyond the battlefield or finish the attack in the cells, where other soldiers stand (or stood immediately before attack).A retreat is moving all of the selected soldiers along the lines on which they stand in the direction from an enemy soldier, if he is in this line. The other rules repeat the rules of the attack.For example, let's suppose that the original battlefield had the form (here symbols \"G\" mark Shrek's green soldiers and symbols \"R\" mark Donkey's red ones):  -G-R--R-G- Let's suppose that k=2 and Shrek moves first. If he decides to attack, then after his move the battlefield can look like that:  --GR-     --GR-     -G-R--RG--     -R-G-     -RG-- If in the previous example Shrek decides to retreat, then after his move the battlefield can look like that:  G--R-     G--R-     -G-R--R--G     -R-G-     -R--G On the other hand, the followings fields cannot result from Shrek's correct move:  G--R-     ---RG     --GR--RG--     -R-G-     GR--- Shrek starts the game. To make a move means to attack or to retreat by the rules. A player who cannot make a move loses and his opponent is the winner. Determine the winner of the given toy soldier game if Shrek and Donkey continue to be under the yellow pills from the last rounds' problem. Thus, they always play optimally (that is, they try to win if it is possible, or finish the game in a draw, by ensuring that it lasts forever, if they cannot win).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains space-separated integers n, m and k (1\u2264n,m,k\u2264100). Then n lines contain m characters each. These characters belong to the set {\"-\", \"G\", \"R\"}, denoting, respectively, a battlefield's free cell, a cell occupied by Shrek's soldiers and a cell occupied by Donkey's soldiers.\nIt is guaranteed that each line contains no more than two soldiers.\n","output_spec":"Print \"First\" (without the quotes) if Shrek wins in the given Toy Soldier game. If Donkey wins, print \"Second\" (without the quotes). If the game continues forever, print \"Draw\" (also without the quotes).\n","notes":null,"sample_inputs":["2 3 1\nR-G\nRG-\n","3 3 2\nG-R\nR-G\nG-R\n","2 3 1\n-R-\n-G-\n","2 5 2\n-G-R-\n-R-G-\n"],"sample_outputs":["First\n","Second\n","Draw\n","First\n"],"id":"142-D","difficulty":2600,"tags":["games"],"src_uid":"69062f7c9b834e925ab23ebc2da96b52","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <cstring>\\nusing namespace std;\\n\\nint n, m, k;\\nchar grid[105][105];\\nbool visited[105][105];\\nint dx[] = {0, 0, 1, -1};\\nint dy[] = {1, -1, 0, 0};\\n\\nbool valid(int x, int y) {\\n    return x >= 0 && x < n && y >= 0 && y < m;\\n}\\n\\nbool canMove(int x, int y, int dir) {\\n    int nx = x + dx[dir];\\n    int ny = y + dy[dir];\\n    while (valid(nx, ny) && grid[nx][ny] == '-') {\\n        nx += dx[dir];\\n        ny += dy[dir];\\n    }\\n    return valid(nx, ny) && grid[nx][ny] != '-';\\n}\\n\\nbool canAttack(int x, int y, int dir) {\\n    int nx = x + dx[dir];\\n    int ny = y + dy[dir];\\n    while (valid(nx, ny) && grid[nx][ny] == '-') {\\n        nx += dx[dir];\\n        ny += dy[dir];\\n    }\\n    return valid(nx, ny) && grid[nx][ny] != '-' && grid[nx][ny] != grid[x][y];\\n}\\n\\nbool canRetreat(int x, int y, int dir) {\\n    int nx = x + dx[dir];\\n    int ny = y + dy[dir];\\n    while (valid(nx, ny) && grid[nx][ny] == '-') {\\n        nx += dx[dir];\\n        ny += dy[dir];\\n    }\\n    return valid(nx, ny) && grid[nx][ny] != '-' && grid[nx][ny] == grid[x][y];\\n}\\n\\nbool canWin(int x, int y) {\\n    memset(visited, false, sizeof(visited));\\n    queue<pair<int, int>> q;\\n    q.push({x, y});\\n    visited[x][y] = true;\\n    while (!q.empty()) {\\n        int cx = q.front().first;\\n        int cy = q.front().second;\\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int nx = cx + dx[i];\\n            int ny = cy + dy[i];\\n            if (valid(nx, ny) && !visited[nx][ny] && grid[nx][ny] == grid[x][y]) {\\n                visited[nx][ny] = true;\\n                q.push({nx, ny});\\n            }\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (grid[i][j] == grid[x][y] && !visited[i][j]) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nstring solve() {\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (grid[i][j] != '-') {\\n                if (canWin(i, j)) {\\n                    return \\\"First\\\";\\n                }\\n            }\\n        }\\n    }\\n    return \\\"Second\\\";\\n}\\n\\nint main() {\\n    cin >> n >> m >> k;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            cin >> grid[i][j];\\n        }\\n    }\\n    cout << solve() << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class ToySoldierGame {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int k = scanner.nextInt();\n        scanner.nextLine();\n        \n        char[][] battlefield = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < m; j++) {\n                battlefield[i][j] = line.charAt(j);\n            }\n        }\n        \n        boolean[][] visited = new boolean[n][m];\n        boolean[][] canMove = new boolean[n][m];\n        \n        boolean shrekTurn = true;\n        boolean canMoveAny = false;\n        \n        while (true) {\n            canMoveAny = false;\n            \n            \/\/ Check if any soldier can move\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (battlefield[i][j] == (shrekTurn ? 'G' : 'R')) {\n                        if (canMove[i][j]) {\n                            canMoveAny = true;\n                            break;\n                        }\n                    }\n                }\n                if (canMoveAny) {\n                    break;\n                }\n            }\n            \n            if (!canMoveAny) {\n                System.out.println(\"Draw\");\n                return;\n            }\n            \n            \/\/ Make a move\n            boolean moved = false;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (battlefield[i][j] == (shrekTurn ? 'G' : 'R')) {\n                        if (canMove[i][j]) {\n                            if (makeMove(battlefield, visited, i, j, k, shrekTurn)) {\n                                moved = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (moved) {\n                    break;\n                }\n            }\n            \n            if (!moved) {\n                if (shrekTurn) {\n                    System.out.println(\"Second\");\n                } else {\n                    System.out.println(\"First\");\n                }\n                return;\n            }\n            \n            shrekTurn = !shrekTurn;\n        }\n    }\n    \n    private static boolean makeMove(char[][] battlefield, boolean[][] visited, int row, int col, int k, boolean shrekTurn) {\n        int n = battlefield.length;\n        int m = battlefield[0].length;\n        \n        visited[row][col] = true;\n        \n        \/\/ Check if there is an enemy soldier in the same row\n        for (int j = col + 1; j < m; j++) {\n            if (battlefield[row][j] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[row][j]) {\n                    visited[row][j] = true;\n                    battlefield[row][j] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[row][j] != '-') {\n                break;\n            }\n        }\n        \n        for (int j = col - 1; j >= 0; j--) {\n            if (battlefield[row][j] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[row][j]) {\n                    visited[row][j] = true;\n                    battlefield[row][j] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[row][j] != '-') {\n                break;\n            }\n        }\n        \n        \/\/ Check if there is an enemy soldier in the same column\n        for (int i = row + 1; i < n; i++) {\n            if (battlefield[i][col] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[i][col]) {\n                    visited[i][col] = true;\n                    battlefield[i][col] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[i][col] != '-') {\n                break;\n            }\n        }\n        \n        for (int i = row - 1; i >= 0; i--) {\n            if (battlefield[i][col] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[i][col]) {\n                    visited[i][col] = true;\n                    battlefield[i][col] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[i][col] != '-') {\n                break;\n            }\n        }\n        \n        \/\/ Check if there is an enemy soldier in the diagonal\n        int i = row + 1;\n        int j = col + 1;\n        while (i < n && j < m) {\n            if (battlefield[i][j] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[i][j]) {\n                    visited[i][j] = true;\n                    battlefield[i][j] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[i][j] != '-') {\n                break;\n            }\n            i++;\n            j++;\n        }\n        \n        i = row - 1;\n        j = col - 1;\n        while (i >= 0 && j >= 0) {\n            if (battlefield[i][j] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[i][j]) {\n                    visited[i][j] = true;\n                    battlefield[i][j] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[i][j] != '-') {\n                break;\n            }\n            i--;\n            j--;\n        }\n        \n        i = row + 1;\n        j = col - 1;\n        while (i < n && j >= 0) {\n            if (battlefield[i][j] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[i][j]) {\n                    visited[i][j] = true;\n                    battlefield[i][j] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[i][j] != '-') {\n                break;\n            }\n            i++;\n            j--;\n        }\n        \n        i = row - 1;\n        j = col + 1;\n        while (i >= 0 && j < m) {\n            if (battlefield[i][j] == (shrekTurn ? 'R' : 'G')) {\n                if (!visited[i][j]) {\n                    visited[i][j] = true;\n                    battlefield[i][j] = battlefield[row][col];\n                    battlefield[row][col] = '-';\n                    return true;\n                }\n            } else if (battlefield[i][j] != '-') {\n                break;\n            }\n            i--;\n            j++;\n        }\n        \n        return false;\n    }\n}","Python":"def toy_soldier_game(n, m, k, battlefield):\n    # Initialize the game state\n    soldiers = {'G': [], 'R': []}\n    for i in range(n):\n        for j in range(m):\n            if battlefield[i][j] != '-':\n                soldiers[battlefield[i][j]].append((i, j))\n    \n    # Helper function to check if a move is valid\n    def is_valid_move(move):\n        for i, j in move:\n            if i < 0 or i >= n or j < 0 or j >= m or battlefield[i][j] != '-':\n                return False\n        return True\n    \n    # Helper function to get all possible moves for a player\n    def get_moves(player):\n        moves = []\n        for i, j in soldiers[player]:\n            # Check attack moves\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                move = []\n                ni, nj = i + di, j + dj\n                while ni >= 0 and ni < n and nj >= 0 and nj < m and battlefield[ni][nj] == '-':\n                    move.append((ni, nj))\n                    ni += di\n                    nj += dj\n                if move and is_valid_move(move):\n                    moves.append(move)\n            \n            # Check retreat moves\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                move = []\n                ni, nj = i - di, j - dj\n                while ni >= 0 and ni < n and nj >= 0 and nj < m and battlefield[ni][nj] == '-':\n                    move.append((ni, nj))\n                    ni -= di\n                    nj -= dj\n                if move and is_valid_move(move):\n                    moves.append(move)\n        \n        return moves\n    \n    # Recursive function to determine the winner\n    def play_game(player):\n        moves = get_moves(player)\n        if not moves:\n            return 'Draw'\n        \n        for move in moves:\n            # Make the move\n            for i, j in move:\n                battlefield[i][j] = player\n            \n            # Check if the opponent can make a move\n            opponent = 'G' if player == 'R' else 'R'\n            opponent_moves = get_moves(opponent)\n            if not opponent_moves:\n                return player\n            \n            # Recursively play the game for the opponent\n            result = play_game(opponent)\n            \n            # Undo the move\n            for i, j in move:\n                battlefield[i][j] = '-'\n            \n            # If the opponent loses, the current player wins\n            if result == player:\n                return player\n        \n        # If no winning move is found, it's a draw\n        return 'Draw'\n    \n    # Start the game with Shrek as the first player\n    return play_game('G')\n\n# Test the function with the sample inputs\ninputs = [\n    (2, 3, 1, [['R', '-', 'G'], ['R', 'G', '-']]),\n    (3, 3, 2, [['G', '-', 'R'], ['R', '-', 'G'], ['G', '-', 'R']]),\n    (2, 3, 1, [['-', 'R', '-'], ['-', 'G', '-']]),\n    (2, 5, 2, [['-', 'G', '-', 'R', '-'], ['-', 'R', '-', 'G', '-']])\n]\n\noutputs = []\nfor n, m, k, battlefield in inputs:\n    result = toy_soldier_game(n, m, k, battlefield)\n    outputs.append(result)\n\noutputs\n","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\nint main() {\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n    char battlefield[n][m];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s\\\", battlefield[i]);\\n    }\\n\\n    bool shrekTurn = true;\\n    bool canMove = true;\\n\\n    while (canMove) {\\n        canMove = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (battlefield[i][j] == (shrekTurn ? 'G' : 'R')) {\\n                    int count = 0;\\n                    int start = j;\\n                    int end = j;\\n\\n                    while (start > 0 && battlefield[i][start - 1] == '-') {\\n                        start--;\\n                        count++;\\n                    }\\n\\n                    while (end < m - 1 && battlefield[i][end + 1] == '-') {\\n                        end++;\\n                        count++;\\n                    }\\n\\n                    if (count >= 1 && count <= k) {\\n                        canMove = true;\\n\\n                        if (shrekTurn) {\\n                            for (int x = start; x <= end; x++) {\\n                                battlefield[i][x] = 'G';\\n                            }\\n                        } else {\\n                            for (int x = start; x <= end; x++) {\\n                                battlefield[i][x] = 'R';\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        shrekTurn = !shrekTurn;\\n    }\\n\\n    bool shrekWins = false;\\n    bool donkeyWins = false;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (battlefield[i][j] == 'G') {\\n                shrekWins = true;\\n            }\\n\\n            if (battlefield[i][j] == 'R') {\\n                donkeyWins = true;\\n            }\\n        }\\n    }\\n\\n    if (shrekWins && donkeyWins) {\\n        printf(\\\"Draw\\\\n\\\");\\n    } else if (shrekWins) {\\n        printf(\\\"First\\\\n\\\");\\n    } else {\\n        printf(\\\"Second\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace ToySoldierGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = {\n                \\\"2 3 1\\nR-G\\nRG-\\\",\n                \\\"3 3 2\\nG-R\\nR-G\\nG-R\\\",\n                \\\"2 3 1\\n-R-\\n-G-\\\",\n                \\\"2 5 2\\n-G-R-\\n-R-G-\\\"\n            };\n\n            string[] expectedOutputs = {\n                \\\"First\\n\\\",\n                \\\"Second\\n\\\",\n                \\\"Draw\\n\\\",\n                \\\"First\\n\\\"\n            };\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                string input = inputs[i];\n                string expectedOutput = expectedOutputs[i];\n\n                string actualOutput = DetermineWinner(input);\n                Console.WriteLine(actualOutput == expectedOutput ? \\\"Test case passed\\\" : \\\"Test case failed\\\");\n            }\n        }\n\n        static string DetermineWinner(string input)\n        {\n            string[] lines = input.Split('\\\\n');\n            string[] dimensions = lines[0].Split(' ');\n            int n = int.Parse(dimensions[0]);\n            int m = int.Parse(dimensions[1]);\n            int k = int.Parse(dimensions[2]);\n\n            char[][] battlefield = new char[n][];\n            for (int i = 0; i < n; i++)\n            {\n                battlefield[i] = lines[i + 1].ToCharArray();\n            }\n\n            bool[,] visited = new bool[n, m];\n            bool shrekTurn = true;\n\n            while (true)\n            {\n                bool canMove = false;\n\n                for (int i = 0; i < n; i++)\n                {\n                    for (int j = 0; j < m; j++)\n                    {\n                        if (battlefield[i][j] == (shrekTurn ? 'G' : 'R') && !visited[i, j])\n                        {\n                            if (CanAttack(battlefield, visited, i, j, shrekTurn, k))\n                            {\n                                canMove = true;\n                                break;\n                            }\n\n                            if (CanRetreat(battlefield, visited, i, j, shrekTurn, k))\n                            {\n                                canMove = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (canMove)\n                    {\n                        break;\n                    }\n                }\n\n                if (!canMove)\n                {\n                    return shrekTurn ? \\\"Second\\\\n\\\" : \\\"First\\\\n\\\";\n                }\n\n                shrekTurn = !shrekTurn;\n            }\n        }\n\n        static bool CanAttack(char[][] battlefield, bool[,] visited, int row, int col, bool shrekTurn, int k)\n        {\n            int n = battlefield.Length;\n            int m = battlefield[0].Length;\n\n            int count = 0;\n            int i = row;\n            int j = col;\n\n            while (j < m && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                j++;\n            }\n\n            if (count >= k)\n            {\n                for (int x = col; x < j; x++)\n                {\n                    visited[row, x] = true;\n                }\n\n                return true;\n            }\n\n            count = 0;\n            i = row;\n            j = col;\n\n            while (j >= 0 && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                j--;\n            }\n\n            if (count >= k)\n            {\n                for (int x = col; x >= j; x--)\n                {\n                    visited[row, x] = true;\n                }\n\n                return true;\n            }\n\n            count = 0;\n            i = row;\n            j = col;\n\n            while (i < n && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                i++;\n            }\n\n            if (count >= k)\n            {\n                for (int x = row; x < i; x++)\n                {\n                    visited[x, col] = true;\n                }\n\n                return true;\n            }\n\n            count = 0;\n            i = row;\n            j = col;\n\n            while (i >= 0 && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                i--;\n            }\n\n            if (count >= k)\n            {\n                for (int x = row; x >= i; x--)\n                {\n                    visited[x, col] = true;\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n\n        static bool CanRetreat(char[][] battlefield, bool[,] visited, int row, int col, bool shrekTurn, int k)\n        {\n            int n = battlefield.Length;\n            int m = battlefield[0].Length;\n\n            int count = 0;\n            int i = row;\n            int j = col;\n\n            while (j < m && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                j++;\n            }\n\n            if (count >= k)\n            {\n                for (int x = col; x < j; x++)\n                {\n                    visited[row, x] = true;\n                }\n\n                return true;\n            }\n\n            count = 0;\n            i = row;\n            j = col;\n\n            while (j >= 0 && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                j--;\n            }\n\n            if (count >= k)\n            {\n                for (int x = col; x >= j; x--)\n                {\n                    visited[row, x] = true;\n                }\n\n                return true;\n            }\n\n            count = 0;\n            i = row;\n            j = col;\n\n            while (i < n && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                i++;\n            }\n\n            if (count >= k)\n            {\n                for (int x = row; x < i; x++)\n                {\n                    visited[x, col] = true;\n                }\n\n                return true;\n            }\n\n            count = 0;\n            i = row;\n            j = col;\n\n            while (i >= 0 && (battlefield[i][j] == '-' || battlefield[i][j] == (shrekTurn ? 'R' : 'G')))\n            {\n                if (battlefield[i][j] == (shrekTurn ? 'R' : 'G'))\n                {\n                    count++;\n                }\n\n                i--;\n            }\n\n            if (count >= k)\n            {\n                for (int x = row; x >= i; x--)\n                {\n                    visited[x, col] = true;\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n}","Ruby":"\ndef valid_move?(board, player, k)\n  # Check if the player has any valid moves left\n  return false if board.flatten.count(player) < k\n  \n  # Check if the player can attack\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if cell == player\n        # Check if there is an enemy soldier in the same row\n        if row.include?(enemy(player))\n          return true\n        end\n        \n        # Check if there is an enemy soldier in the same column\n        column = board.map { |row| row[j] }\n        if column.include?(enemy(player))\n          return true\n        end\n      end\n    end\n  end\n  \n  # Check if the player can retreat\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if cell == player\n        # Check if there is an enemy soldier in the same row\n        if row.include?(enemy(player))\n          return true\n        end\n        \n        # Check if there is an enemy soldier in the same column\n        column = board.map { |row| row[j] }\n        if column.include?(enemy(player))\n          return true\n        end\n      end\n    end\n  end\n  \n  # No valid moves left\n  return false\nend\n\ndef enemy(player)\n  # Return the enemy player\n  return player == 'G' ? 'R' : 'G'\nend\n\ndef move(board, player, k)\n  # Check if the player can attack\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if cell == player\n        # Check if there is an enemy soldier in the same row\n        if row.include?(enemy(player))\n          # Move all soldiers in the same row towards the enemy soldier\n          row.each_with_index do |cell, j|\n            if cell == player\n              row[j] = '-'\n              row[j+1] = player\n            end\n          end\n          return board\n        end\n        \n        # Check if there is an enemy soldier in the same column\n        column = board.map { |row| row[j] }\n        if column.include?(enemy(player))\n          # Move all soldiers in the same column towards the enemy soldier\n          column.each_with_index do |cell, i|\n            if cell == player\n              board[i][j] = '-'\n              board[i+1][j] = player\n            end\n          end\n          return board\n        end\n      end\n    end\n  end\n  \n  # Check if the player can retreat\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if cell == player\n        # Check if there is an enemy soldier in the same row\n        if row.include?(enemy(player))\n          # Move all soldiers in the same row away from the enemy soldier\n          row.each_with_index do |cell, j|\n            if cell == player\n              row[j] = '-'\n              row[j-1] = player\n            end\n          end\n          return board\n        end\n        \n        # Check if there is an enemy soldier in the same column\n        column = board.map { |row| row[j] }\n        if column.include?(enemy(player))\n          # Move all soldiers in the same column away from the enemy soldier\n          column.each_with_index do |cell, i|\n            if cell == player\n              board[i][j] = '-'\n              board[i-1][j] = player\n            end\n          end\n          return board\n        end\n      end\n    end\n  end\n  \n  # No valid moves left\n  return board\nend\n\ndef game_winner(input)\n  # Parse the input\n  lines = input.split(\"\\n\")\n  n, m, k = lines[0].split.map(&:to_i)\n  board = lines[1..n].map(&:chars)\n  \n  # Start the game with Shrek\n  player = 'G'\n  \n  # Play the game until there is a winner or it continues forever\n  while true\n    # Check if the current player has any valid moves left\n    if !valid_move?(board, player, k)\n      return 'Draw'\n    end\n    \n    # Make a move\n    board = move(board, player, k)\n    \n    # Check if the current player has won\n    if board.flatten.count(player) == 0\n      return player == 'G' ? 'Second' : 'First'\n    end\n    \n    # Switch to the other player\n    player = enemy(player)\n  end\nend\n\n# Test the function with the sample inputs\nputs game_winner('2 3 1\\nR-G\\nRG-\\n') # First\nputs game_winner('3 3 2\\nG-R\\nR-G\\nG-R\\n') # Second\nputs game_winner('2 3 1\\n-R-\\n-G-\\n') # Draw\nputs game_winner('2 5 2\\n-G-R-\\n-R-G-\\n') # First\n","delphi":"program ToySoldierGame;\\n\\nvar\\n  n, m, k, i, j: integer;\\n  battlefield: array of array of char;\\n  visited: array of array of boolean;\\n  dx: array[1..4] of integer = (-1, 0, 1, 0);\\n  dy: array[1..4] of integer = (0, 1, 0, -1);\\n\\nfunction isValidMove(x, y: integer): boolean;\\nbegin\\n  if (x >= 0) and (x < n) and (y >= 0) and (y < m) and (not visited[x][y]) then\\n    isValidMove := true\\n  else\\n    isValidMove := false;\\nend;\\n\\nprocedure dfs(x, y: integer);\\nvar\\n  i, newX, newY: integer;\\nbegin\\n  visited[x][y] := true;\\n\\n  for i := 1 to 4 do\\n  begin\\n    newX := x + dx[i];\\n    newY := y + dy[i];\\n\\n    if isValidMove(newX, newY) then\\n      dfs(newX, newY);\\n  end;\\nend;\\n\\nfunction canWin(): boolean;\\nvar\\n  i, j, shrekCount, donkeyCount: integer;\\nbegin\\n  shrekCount := 0;\\n  donkeyCount := 0;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      if battlefield[i][j] = 'G' then\\n        shrekCount := shrekCount + 1\\n      else if battlefield[i][j] = 'R' then\\n        donkeyCount := donkeyCount + 1;\\n    end;\\n  end;\\n\\n  if shrekCount = 0 then\\n  begin\\n    canWin := false;\\n    exit;\\n  end;\\n\\n  if donkeyCount = 0 then\\n  begin\\n    canWin := true;\\n    exit;\\n  end;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      if battlefield[i][j] = 'G' then\\n      begin\\n        fillchar(visited, sizeof(visited), false);\\n        dfs(i, j);\\n\\n        for i := 0 to n-1 do\\n        begin\\n          for j := 0 to m-1 do\\n          begin\\n            if (battlefield[i][j] = 'G') and (not visited[i][j]) then\\n            begin\\n              canWin := true;\\n              exit;\\n            end;\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  canWin := false;\\nend;\\n\\nbegin\\n  readln(n, m, k);\\n\\n  setlength(battlefield, n, m);\\n\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      read(battlefield[i][j]);\\n    end;\\n    readln;\\n  end;\\n\\n  if canWin() then\\n    writeln('First')\\n  else\\n    writeln('Second');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, k int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &k)\\n\\n\\tbattlefield := make([][]string, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar line string\\n\\t\\tfmt.Scanf(\\\"%s\\\", &line)\\n\\t\\tbattlefield[i] = strings.Split(line, \\\"\\\")\\n\\t}\\n\\n\\tshrekWins := playGame(battlefield, k, true)\\n\\n\\tif shrekWins {\\n\\t\\tfmt.Println(\\\"First\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"Second\\\")\\n\\t}\\n}\\n\\nfunc playGame(battlefield [][]string, k int, shrekTurn bool) bool {\\n\\tif !canMove(battlefield, k, shrekTurn) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor i := 0; i < len(battlefield); i++ {\\n\\t\\tfor j := 0; j < len(battlefield[i]); j++ {\\n\\t\\t\\tif (shrekTurn && battlefield[i][j] == \\\"G\\\") || (!shrekTurn && battlefield[i][j] == \\\"R\\\") {\\n\\t\\t\\t\\tif canAttack(battlefield, i, j, shrekTurn) {\\n\\t\\t\\t\\t\\tnewBattlefield := make([][]string, len(battlefield))\\n\\t\\t\\t\\t\\tcopy(newBattlefield, battlefield)\\n\\t\\t\\t\\t\\tattack(newBattlefield, i, j, shrekTurn)\\n\\t\\t\\t\\t\\tif playGame(newBattlefield, k, !shrekTurn) {\\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif canRetreat(battlefield, i, j, shrekTurn) {\\n\\t\\t\\t\\t\\tnewBattlefield := make([][]string, len(battlefield))\\n\\t\\t\\t\\t\\tcopy(newBattlefield, battlefield)\\n\\t\\t\\t\\t\\tretreat(newBattlefield, i, j, shrekTurn)\\n\\t\\t\\t\\t\\tif playGame(newBattlefield, k, !shrekTurn) {\\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc canMove(battlefield [][]string, k int, shrekTurn bool) bool {\\n\\tfor i := 0; i < len(battlefield); i++ {\\n\\t\\tfor j := 0; j < len(battlefield[i]); j++ {\\n\\t\\t\\tif (shrekTurn && battlefield[i][j] == \\\"G\\\") || (!shrekTurn && battlefield[i][j] == \\\"R\\\") {\\n\\t\\t\\t\\tif canAttack(battlefield, i, j, shrekTurn) || canRetreat(battlefield, i, j, shrekTurn) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc canAttack(battlefield [][]string, i, j int, shrekTurn bool) bool {\\n\\tif shrekTurn {\\n\\t\\tfor x := j + 1; x < len(battlefield[i]); x++ {\\n\\t\\t\\tif battlefield[i][x] == \\\"R\\\" {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor x := j - 1; x >= 0; x-- {\\n\\t\\t\\tif battlefield[i][x] == \\\"G\\\" {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc canRetreat(battlefield [][]string, i, j int, shrekTurn bool) bool {\\n\\tif shrekTurn {\\n\\t\\tfor x := j - 1; x >= 0; x-- {\\n\\t\\t\\tif battlefield[i][x] == \\\"R\\\" {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor x := j + 1; x < len(battlefield[i]); x++ {\\n\\t\\t\\tif battlefield[i][x] == \\\"G\\\" {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc attack(battlefield [][]string, i, j int, shrekTurn bool) {\\n\\tif shrekTurn {\\n\\t\\tfor x := j + 1; x < len(battlefield[i]); x++ {\\n\\t\\t\\tif battlefield[i][x] == \\\"R\\\" {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tbattlefield[i][x] = \\\"G\\\"\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor x := j - 1; x >= 0; x-- {\\n\\t\\t\\tif battlefield[i][x] == \\\"G\\\" {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tbattlefield[i][x] = \\\"R\\\"\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc retreat(battlefield [][]string, i, j int, shrekTurn bool) {\\n\\tif shrekTurn {\\n\\t\\tfor x := j - 1; x >= 0; x-- {\\n\\t\\t\\tif battlefield[i][x] == \\\"R\\\" {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tbattlefield[i][x] = \\\"G\\\"\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor x := j + 1; x < len(battlefield[i]); x++ {\\n\\t\\t\\tif battlefield[i][x] == \\\"G\\\" {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tbattlefield[i][x] = \\\"R\\\"\\n\\t\\t}\\n\\t}\\n}\\n","Javascript":"function toySoldierGame(input) {\n    let lines = input.split('\\\\n');\n    let [n, m, k] = lines[0].split(' ').map(Number);\n    let battlefield = lines.slice(1, n + 1);\n    \n    let shrekTurn = true;\n    let canMove = true;\n    \n    while (canMove) {\n        canMove = false;\n        \n        for (let i = 0; i < n; i++) {\n            let soldiers = [];\n            \n            for (let j = 0; j < m; j++) {\n                if (battlefield[i][j] === (shrekTurn ? 'G' : 'R')) {\n                    soldiers.push(j);\n                }\n            }\n            \n            if (soldiers.length > 0) {\n                let enemySoldier = shrekTurn ? 'R' : 'G';\n                let direction = shrekTurn ? 1 : -1;\n                \n                let minMove = Infinity;\n                let maxMove = -Infinity;\n                \n                for (let soldier of soldiers) {\n                    let move = 0;\n                    \n                    for (let j = soldier + direction; j >= 0 && j < m; j += direction) {\n                        if (battlefield[i][j] === enemySoldier) {\n                            break;\n                        }\n                        \n                        if (battlefield[i][j] === '-') {\n                            move++;\n                        }\n                    }\n                    \n                    minMove = Math.min(minMove, move);\n                    maxMove = Math.max(maxMove, move);\n                }\n                \n                if (minMove <= k && maxMove >= 1) {\n                    canMove = true;\n                    \n                    for (let soldier of soldiers) {\n                        let move = 0;\n                        \n                        for (let j = soldier + direction; j >= 0 && j < m; j += direction) {\n                            if (battlefield[i][j] === enemySoldier) {\n                                break;\n                            }\n                            \n                            if (battlefield[i][j] === '-') {\n                                move++;\n                                battlefield[i] = battlefield[i].substring(0, j) + (shrekTurn ? 'G' : 'R') + battlefield[i].substring(j + 1);\n                            }\n                        }\n                        \n                        if (move < minMove) {\n                            battlefield[i] = battlefield[i].substring(0, soldier + direction) + '-' + battlefield[i].substring(soldier + direction + 1);\n                        }\n                    }\n                }\n            }\n        }\n        \n        shrekTurn = !shrekTurn;\n    }\n    \n    let shrekCount = 0;\n    let donkeyCount = 0;\n    \n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (battlefield[i][j] === 'G') {\n                shrekCount++;\n            } else if (battlefield[i][j] === 'R') {\n                donkeyCount++;\n            }\n        }\n    }\n    \n    if (shrekCount > donkeyCount) {\n        return 'First\\\\n';\n    } else if (donkeyCount > shrekCount) {\n        return 'Second\\\\n';\n    } else {\n        return 'Draw\\\\n';\n    }\n}\n\nlet inputs = ['2 3 1\\\\nR-G\\\\nRG-\\\\n', '3 3 2\\\\nG-R\\\\nR-G\\\\nG-R\\\\n', '2 3 1\\\\n-R-\\\\n-G-\\\\n', '2 5 2\\\\n-G-R-\\\\n-R-G-\\\\n'];\nlet outputs = ['First\\\\n', 'Second\\\\n', 'Draw\\\\n', 'First\\\\n'];\n\nlet results = [];\nfor (let i = 0; i < inputs.length; i++) {\n    let result = toySoldierGame(inputs[i]);\n    results.push(result === outputs[i]);\n}\n\nJSON.stringify(results);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val nmk = scanner.nextLine().split(\" \").map { it.toInt() }\n    val n = nmk[0]\n    val m = nmk[1]\n    val k = nmk[2]\n    val battlefield = Array(n) { CharArray(m) }\n    for (i in 0 until n) {\n        battlefield[i] = scanner.nextLine().toCharArray()\n    }\n    val result = toySoldierGame(n, m, k, battlefield)\n    println(result)\n}\n\nfun toySoldierGame(n: Int, m: Int, k: Int, battlefield: Array<CharArray>): String {\n    val visited = Array(n) { BooleanArray(m) }\n    val directions = arrayOf(intArrayOf(-1, 0), intArrayOf(1, 0), intArrayOf(0, -1), intArrayOf(0, 1))\n    val queue: Queue<Pair<Int, Int>> = LinkedList()\n    var shrekTurn = true\n    \n    for (i in 0 until n) {\n        for (j in 0 until m) {\n            if (battlefield[i][j] == 'G' && shrekTurn) {\n                queue.offer(Pair(i, j))\n                visited[i][j] = true\n            } else if (battlefield[i][j] == 'R' && !shrekTurn) {\n                queue.offer(Pair(i, j))\n                visited[i][j] = true\n            }\n        }\n    }\n    \n    while (!queue.isEmpty()) {\n        val size = queue.size\n        for (i in 0 until size) {\n            val curr = queue.poll()\n            val x = curr.first\n            val y = curr.second\n            \n            for (direction in directions) {\n                var newX = x + direction[0]\n                var newY = y + direction[1]\n                \n                while (newX in 0 until n && newY in 0 until m && battlefield[newX][newY] == '-') {\n                    if (!visited[newX][newY]) {\n                        visited[newX][newY] = true\n                        queue.offer(Pair(newX, newY))\n                    }\n                    newX += direction[0]\n                    newY += direction[1]\n                }\n                \n                if (newX in 0 until n && newY in 0 until m && battlefield[newX][newY] != '-' && battlefield[newX][newY] != battlefield[x][y]) {\n                    return if (shrekTurn) \"First\" else \"Second\"\n                }\n            }\n        }\n        shrekTurn = !shrekTurn\n    }\n    \n    return \"Draw\"\n}","PHP":"<?php\\n\\nfunction toySoldierGame($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $dimensions = explode(\\\" \\\", $lines[0]);\\n    $n = $dimensions[0];\\n    $m = $dimensions[1];\\n    $k = $dimensions[2];\\n    $battlefield = [];\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $battlefield[] = str_split($lines[$i]);\\n    }\\n\\n    $shrekMovesFirst = true;\\n\\n    while (true) {\\n        $canAttack = false;\\n        $canRetreat = false;\\n\\n        for ($i = 0; $i < $n; $i++) {\\n            $shrekSoldiers = [];\\n            $donkeySoldiers = [];\\n\\n            for ($j = 0; $j < $m; $j++) {\\n                if ($battlefield[$i][$j] === 'G') {\\n                    $shrekSoldiers[] = $j;\\n                }\\n\\n                if ($battlefield[$i][$j] === 'R') {\\n                    $donkeySoldiers[] = $j;\\n                }\\n            }\\n\\n            if (count($shrekSoldiers) > 0) {\\n                $canAttack = true;\\n                $canRetreat = true;\\n\\n                if (count($donkeySoldiers) > 0) {\\n                    $canRetreat = false;\\n                }\\n\\n                if (count($shrekSoldiers) >= $k) {\\n                    $canAttack = true;\\n                }\\n            }\\n\\n            if ($canAttack || $canRetreat) {\\n                break;\\n            }\\n        }\\n\\n        if (!$canAttack && !$canRetreat) {\\n            return 'Draw\\\\n';\\n        }\\n\\n        if ($shrekMovesFirst) {\\n            if ($canAttack) {\\n                return 'First\\\\n';\\n            }\\n\\n            $shrekMovesFirst = false;\\n        } else {\\n            if ($canRetreat) {\\n                return 'Second\\\\n';\\n            }\\n\\n            $shrekMovesFirst = true;\\n        }\\n    }\\n}\\n\\n$input = '2 3 1\\\\nR-G\\\\nRG-\\\\n';\\n$result = toySoldierGame($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, k;\\r\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\r\\n\\r\\n    char[][] battlefield = new char[][](n);\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        battlefield[i] = readln.chomp().dup;\\r\\n    }\\r\\n\\r\\n    bool[][] visited = new bool[][](n, m);\\r\\n\\r\\n    bool shrekTurn = true;\\r\\n    while (true)\\r\\n    {\\r\\n        bool canMove = false;\\r\\n\\r\\n        for (int i = 0; i < n; i++)\\r\\n        {\\r\\n            for (int j = 0; j < m; j++)\\r\\n            {\\r\\n                if (battlefield[i][j] == (shrekTurn ? 'G' : 'R'))\\r\\n                {\\r\\n                    if (!visited[i][j])\\r\\n                    {\\r\\n                        visited[i][j] = true;\\r\\n\\r\\n                        if (shrekTurn)\\r\\n                        {\\r\\n                            if (attack(battlefield, visited, i, j, k))\\r\\n                            {\\r\\n                                canMove = true;\\r\\n                                break;\\r\\n                            }\\r\\n                        }\\r\\n                        else\\r\\n                        {\\r\\n                            if (retreat(battlefield, visited, i, j, k))\\r\\n                            {\\r\\n                                canMove = true;\\r\\n                                break;\\r\\n                            }\\r\\n                        }\\r\\n\\r\\n                        visited[i][j] = false;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (canMove)\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!canMove)\\r\\n        {\\r\\n            writeln(shrekTurn ? \\\"Second\\\" : \\\"First\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        shrekTurn = !shrekTurn;\\r\\n    }\\r\\n}\\r\\n\\r\\nbool attack(char[][] battlefield, bool[][] visited, int row, int col, int k)\\r\\n{\\r\\n    int n = battlefield.length;\\r\\n    int m = battlefield[0].length;\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    for (int i = col + 1; i < m; i++)\\r\\n    {\\r\\n        if (battlefield[row][i] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    count = 0;\\r\\n\\r\\n    for (int i = col - 1; i >= 0; i--)\\r\\n    {\\r\\n        if (battlefield[row][i] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    count = 0;\\r\\n\\r\\n    for (int i = row + 1; i < n; i++)\\r\\n    {\\r\\n        if (battlefield[i][col] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    count = 0;\\r\\n\\r\\n    for (int i = row - 1; i >= 0; i--)\\r\\n    {\\r\\n        if (battlefield[i][col] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n}\\r\\n\\r\\nbool retreat(char[][] battlefield, bool[][] visited, int row, int col, int k)\\r\\n{\\r\\n    int n = battlefield.length;\\r\\n    int m = battlefield[0].length;\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    for (int i = col + 1; i < m; i++)\\r\\n    {\\r\\n        if (battlefield[row][i] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    count = 0;\\r\\n\\r\\n    for (int i = col - 1; i >= 0; i--)\\r\\n    {\\r\\n        if (battlefield[row][i] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    count = 0;\\r\\n\\r\\n    for (int i = row + 1; i < n; i++)\\r\\n    {\\r\\n        if (battlefield[i][col] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    count = 0;\\r\\n\\r\\n    for (int i = row - 1; i >= 0; i--)\\r\\n    {\\r\\n        if (battlefield[i][col] == '-')\\r\\n        {\\r\\n            count++;\\r\\n\\r\\n            if (count == k)\\r\\n            {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub can_move {\n    my ($board, $player, $k) = @_;\n\n    my $n = scalar(@$board);\n    my $m = length($board->[0]);\n\n    my $enemy = $player eq 'G' ? 'R' : 'G';\n\n    # Check if there are any enemy soldiers left\n    my $enemy_count = 0;\n    for my $i (0..$n-1) {\n        for my $j (0..$m-1) {\n            if ($board->[$i][$j] eq $enemy) {\n                $enemy_count++;\n            }\n        }\n    }\n    return 'Second' if $enemy_count == 0;\n\n    # Check if the player can make a move\n    for my $i (0..$n-1) {\n        for my $j (0..$m-1) {\n            if ($board->[$i][$j] eq $player) {\n                # Try attacking\n                my $attack_board = [@$board];\n                my $attack_result = attack($attack_board, $player, $i, $j, $k);\n                if ($attack_result eq 'First') {\n                    return 'First';\n                }\n\n                # Try retreating\n                my $retreat_board = [@$board];\n                my $retreat_result = retreat($retreat_board, $player, $i, $j, $k);\n                if ($retreat_result eq 'First') {\n                    return 'First';\n                }\n            }\n        }\n    }\n\n    return 'Draw';\n}\n\nsub attack {\n    my ($board, $player, $i, $j, $k) = @_;\n\n    my $n = scalar(@$board);\n    my $m = length($board->[0]);\n\n    my $enemy = $player eq 'G' ? 'R' : 'G';\n\n    # Move soldiers along the line towards the enemy\n    for my $x ($j+1..$m-1) {\n        last if $board->[$i][$x] eq $enemy;\n        last if $board->[$i][$x] eq $player;\n        $board->[$i][$x] = $player;\n    }\n    for my $x ($j-1..0) {\n        last if $board->[$i][$x] eq $enemy;\n        last if $board->[$i][$x] eq $player;\n        $board->[$i][$x] = $player;\n    }\n\n    # Check if the attack was successful\n    my $enemy_count = 0;\n    for my $x (0..$m-1) {\n        if ($board->[$i][$x] eq $enemy) {\n            $enemy_count++;\n        }\n    }\n    return 'First' if $enemy_count == 0;\n\n    # Check if there are any moves left\n    my $moves_left = 0;\n    for my $x (0..$m-1) {\n        if ($board->[$i][$x] eq $player) {\n            $moves_left++;\n        }\n    }\n    return 'Second' if $moves_left == 0;\n\n    # Check if the player can make another move\n    my $result = can_move($board, $player, $k);\n    return $result;\n}\n\nsub retreat {\n    my ($board, $player, $i, $j, $k) = @_;\n\n    my $n = scalar(@$board);\n    my $m = length($board->[0]);\n\n    my $enemy = $player eq 'G' ? 'R' : 'G';\n\n    # Move soldiers along the line away from the enemy\n    for my $x ($j+1..$m-1) {\n        last if $board->[$i][$x] eq $enemy;\n        last if $board->[$i][$x] eq $player;\n        $board->[$i][$x] = $player;\n    }\n    for my $x ($j-1..0) {\n        last if $board->[$i][$x] eq $enemy;\n        last if $board->[$i][$x] eq $player;\n        $board->[$i][$x] = $player;\n    }\n\n    # Check if there are any moves left\n    my $moves_left = 0;\n    for my $x (0..$m-1) {\n        if ($board->[$i][$x] eq $player) {\n            $moves_left++;\n        }\n    }\n    return 'Second' if $moves_left == 0;\n\n    # Check if the player can make another move\n    my $result = can_move($board, $player, $k);\n    return $result;\n}\n\nsub solve {\n    my ($input) = @_;\n\n    my @lines = split('\\n', $input);\n    my ($n, $m, $k) = split(' ', $lines[0]);\n    my @board;\n    for my $i (1..$n) {\n        push @board, [split('', $lines[$i])];\n    }\n\n    my $result = can_move(\\@board, 'G', $k);\n    return $result;\n}\n\n# Read input from STDIN\nmy $input = '';\nwhile (my $line = <STDIN>) {\n    $input .= $line;\n}\n\n# Solve the problem\nmy $result = solve($input);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"2 3 1\\\\nR-G\\\\nRG-\\\\n\\\";\\n    let mut lines = input.lines();\\n    let nmk: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nmk[0];\\n    let m = nmk[1];\\n    let k = nmk[2];\\n    let mut battlefield: Vec<Vec<char>> = Vec::new();\\n    for _ in 0..n {\\n        let line: Vec<char> = lines.next().unwrap().chars().collect();\\n        battlefield.push(line);\\n    }\\n\\n    let mut shrek_moves = 0;\\n    let mut donkey_moves = 0;\\n\\n    for i in 0..n {\\n        for j in 0..m {\\n            if battlefield[i][j] == 'G' {\\n                let mut attack_possible = false;\\n                let mut retreat_possible = false;\\n\\n                \/\/ Check if attack is possible\\n                if j > 0 && battlefield[i][j - 1] == 'R' {\\n                    attack_possible = true;\\n                }\\n                if j < m - 1 && battlefield[i][j + 1] == 'R' {\\n                    attack_possible = true;\\n                }\\n\\n                \/\/ Check if retreat is possible\\n                if j > 0 && battlefield[i][j - 1] == '-' {\\n                    retreat_possible = true;\\n                }\\n                if j < m - 1 && battlefield[i][j + 1] == '-' {\\n                    retreat_possible = true;\\n                }\\n\\n                if attack_possible && retreat_possible {\\n                    shrek_moves += 1;\\n                }\\n            }\\n\\n            if battlefield[i][j] == 'R' {\\n                let mut attack_possible = false;\\n                let mut retreat_possible = false;\\n\\n                \/\/ Check if attack is possible\\n                if j > 0 && battlefield[i][j - 1] == 'G' {\\n                    attack_possible = true;\\n                }\\n                if j < m - 1 && battlefield[i][j + 1] == 'G' {\\n                    attack_possible = true;\\n                }\\n\\n                \/\/ Check if retreat is possible\\n                if j > 0 && battlefield[i][j - 1] == '-' {\\n                    retreat_possible = true;\\n                }\\n                if j < m - 1 && battlefield[i][j + 1] == '-' {\\n                    retreat_possible = true;\\n                }\\n\\n                if attack_possible && retreat_possible {\\n                    donkey_moves += 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    if shrek_moves > donkey_moves {\\n        println!(\\\"First\\\");\\n    } else if donkey_moves > shrek_moves {\\n        println!(\\\"Second\\\");\\n    } else {\\n        println!(\\\"Draw\\\");\\n    }\\n}"}
{"title":"A. Arrival of the General","description":"A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper. Having learned the news, the colonel ordered to all n squad soldiers to line up on the parade ground.By the military charter the soldiers should stand in the order of non-increasing of their height. But as there's virtually no time to do that, the soldiers lined up in the arbitrary order. However, the general is rather short-sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height. Please note that the way other solders are positioned does not matter, including the case when there are several soldiers whose height is maximum or minimum. Only the heights of the first and the last soldier are important.For example, the general considers the sequence of heights (4, 3, 4, 2, 1, 1) correct and the sequence (4, 3, 1, 2, 2) wrong.Within one second the colonel can swap any two neighboring soldiers. Help him count the minimum time needed to form a line-up which the general will consider correct.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains the only integer n (2\u2264n\u2264100) which represents the number of soldiers in the line. The second line contains integers a1,a2,...,an (1\u2264ai\u2264100) the values of the soldiers' heights in the order of soldiers' heights' increasing in the order from the beginning of the line to its end. The numbers are space-separated. Numbers a1,a2,...,an are not necessarily different.\n","output_spec":"Print the only integer \u2014 the minimum number of seconds the colonel will need to form a line-up the general will like.\n","notes":"In the first sample the colonel will need to swap the first and second soldier and then the third and fourth soldier. That will take 2 seconds. The resulting position of the soldiers is (44, 33, 22, 11).\nIn the second sample the colonel may swap the soldiers in the following sequence:\n  (10, 10, 58, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 40, 76)  (10, 58, 10, 31, 63, 76, 40)  (10, 58, 10, 31, 76, 63, 40)  (10, 58, 31, 10, 76, 63, 40)  (10, 58, 31, 76, 10, 63, 40)  (10, 58, 31, 76, 63, 10, 40)  (10, 58, 76, 31, 63, 10, 40)  (10, 76, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 10, 40)  (76, 10, 58, 31, 63, 40, 10) ","sample_inputs":["4\n33 44 11 22\n","7\n10 10 58 31 63 40 76\n"],"sample_outputs":["2\n","10\n"],"id":"144-A","difficulty":800,"tags":["implementation"],"src_uid":"ef9ff63d225811868e786e800ce49c92","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> heights(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> heights[i];\\n    }\\n    int swaps = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        int max_height = heights[i];\\n        int max_height_index = i;\\n        for (int j = i + 1; j < n; j++) {\\n            if (heights[j] > max_height) {\\n                max_height = heights[j];\\n                max_height_index = j;\\n            }\\n        }\\n        if (max_height_index != i) {\\n            swap(heights[i], heights[max_height_index]);\\n            swaps++;\\n        }\\n    }\\n    cout << swaps << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] heights = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            heights[i] = scanner.nextInt();\\n        }\\n\\n        int minSeconds = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (heights[i] < heights[i - 1]) {\\n                minSeconds++;\\n            }\\n        }\\n\\n        System.out.println(minSeconds);\\n    }\\n}","Python":"def minimum_seconds(n, heights):\n    swaps = 0\n    for i in range(n-1):\n        if heights[i] > heights[i+1]:\n            swaps += 1\n    return swaps\n\ninput_data = input().split('\\\\n')\nn = int(input_data[0])\nheights = list(map(int, input_data[1].split()))\n\nresult = minimum_seconds(n, heights)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int heights[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &heights[i]);\\n    }\\n\\n    int swaps = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        for (int j = 0; j < n - i - 1; j++) {\\n            if (heights[j] < heights[j + 1]) {\\n                int temp = heights[j];\\n                heights[j] = heights[j + 1];\\n                heights[j + 1] = temp;\\n                swaps++;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", swaps);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace SuperSecretMilitarySquad\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] heights = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            int swaps = 0;\n            for (int i = 0; i < n - 1; i++)\n            {\n                if (heights[i] > heights[i + 1])\n                {\n                    int temp = heights[i];\n                    heights[i] = heights[i + 1];\n                    heights[i + 1] = temp;\n                    swaps++;\n                }\n            }\n\n            Console.WriteLine(swaps);\n        }\n    }\n}","Ruby":"\ndef minimum_seconds(n, heights)\n  swaps = 0\n  for i in 0..n-2\n    if heights[i] > heights[i+1]\n      heights[i], heights[i+1] = heights[i+1], heights[i]\n      swaps += 1\n    end\n  end\n  swaps\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nheights = input[1].split(' ').map(&:to_i)\n\nputs minimum_seconds(n, heights)\n","delphi":"program LineUp;\n\nvar\n  n, i, j, temp, swaps: integer;\n  heights: array[1..100] of integer;\n\nbegin\n  \/\/ Read the number of soldiers\n  readln(n);\n  \n  \/\/ Read the heights of the soldiers\n  for i := 1 to n do\n    read(heights[i]);\n  \n  \/\/ Count the number of swaps needed\n  swaps := 0;\n  for i := 1 to n - 1 do\n  begin\n    for j := i + 1 to n do\n    begin\n      if heights[i] < heights[j] then\n      begin\n        temp := heights[i];\n        heights[i] := heights[j];\n        heights[j] := temp;\n        swaps := swaps + 1;\n      end;\n    end;\n  end;\n  \n  \/\/ Print the minimum number of seconds needed\n  writeln(swaps);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\theights := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&heights[i])\\n\\t}\\n\\n\\tminSwaps := 0\\n\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tmaxIndex := i\\n\\t\\tminIndex := i\\n\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tif heights[j] > heights[maxIndex] {\\n\\t\\t\\t\\tmaxIndex = j\\n\\t\\t\\t}\\n\\t\\t\\tif heights[j] < heights[minIndex] {\\n\\t\\t\\t\\tminIndex = j\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif maxIndex == i && minIndex == n-1 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif maxIndex == i {\\n\\t\\t\\theights[i], heights[minIndex] = heights[minIndex], heights[i]\\n\\t\\t} else if minIndex == n-1 {\\n\\t\\t\\theights[i], heights[maxIndex] = heights[maxIndex], heights[i]\\n\\t\\t} else {\\n\\t\\t\\tif maxIndex < minIndex {\\n\\t\\t\\t\\theights[i], heights[maxIndex] = heights[maxIndex], heights[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\theights[i], heights[minIndex] = heights[minIndex], heights[i]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tminSwaps++\\n\\t}\\n\\n\\tfmt.Println(minSwaps)\\n}","Javascript":"\nfunction minimumTimeToLineUp(n, heights) {\n  let swaps = 0;\n  \n  for (let i = 0; i < n - 1; i++) {\n    if (heights[i] > heights[i + 1]) {\n      swaps++;\n    }\n  }\n  \n  return swaps;\n}\n\nconst input = '4\\n33 44 11 22\\n';\nconst lines = input.split('\\\\n');\nconst n = parseInt(lines[0]);\nconst heights = lines[1].split(' ').map(Number);\n\nconst result = minimumTimeToLineUp(n, heights);\nconsole.log(result);\n","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val heights = IntArray(n)\n    for (i in 0 until n) {\n        heights[i] = scanner.nextInt()\n    }\n    \n    var swaps = 0\n    for (i in 0 until n - 1) {\n        var maxIndex = i\n        for (j in i + 1 until n) {\n            if (heights[j] > heights[maxIndex]) {\n                maxIndex = j\n            }\n        }\n        if (maxIndex != i) {\n            val temp = heights[i]\n            heights[i] = heights[maxIndex]\n            heights[maxIndex] = temp\n            swaps++\n        }\n    }\n    \n    println(swaps)\n}","PHP":"\n<?php\n\n\/\/ Read input from stdin\n$lineCount = trim(fgets(STDIN));\n$heights = explode(' ', trim(fgets(STDIN)));\n\n\/\/ Initialize variables\n$swaps = 0;\n$maxHeight = $heights[0];\n$minHeight = $heights[0];\n\n\/\/ Iterate through the heights\nfor ($i = 1; $i < $lineCount; $i++) {\n    \/\/ Check if current height is greater than maximum height\n    if ($heights[$i] > $maxHeight) {\n        $maxHeight = $heights[$i];\n        $swaps++;\n    }\n    \/\/ Check if current height is less than minimum height\n    if ($heights[$i] < $minHeight) {\n        $minHeight = $heights[$i];\n        $swaps++;\n    }\n}\n\n\/\/ Print the minimum number of swaps\necho $swaps;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] heights;\\r\\n    int swaps = 0;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    heights.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &heights[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Check if the line-up is already correct\\r\\n    if (isSorted(heights, (a, b) => a >= b))\\r\\n    {\\r\\n        writeln(\\\"0\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    \/\/ Swap soldiers to form correct line-up\\r\\n    for (int i = 0; i < n - 1; i++)\\r\\n    {\\r\\n        if (heights[i] < heights[i + 1])\\r\\n        {\\r\\n            swap(heights[i], heights[i + 1]);\\r\\n            swaps++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(swaps);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimum_seconds {\n    my ($n, @heights) = @_;\n\n    my $min_seconds = 0;\n\n    for my $i (0..$n-2) {\n        my $max_height = $heights[$i];\n        my $min_height = $heights[$i];\n\n        for my $j ($i+1..$n-1) {\n            $max_height = $heights[$j] if $heights[$j] > $max_height;\n            $min_height = $heights[$j] if $heights[$j] < $min_height;\n        }\n\n        if ($max_height != $heights[$i]) {\n            my $max_index = $i;\n            for my $k ($i+1..$n-1) {\n                if ($heights[$k] == $max_height) {\n                    $max_index = $k;\n                    last;\n                }\n            }\n            ($heights[$i], $heights[$max_index]) = ($heights[$max_index], $heights[$i]);\n            $min_seconds++;\n        }\n\n        if ($min_height != $heights[$n-1]) {\n            my $min_index = $n-1;\n            for my $k (reverse $i..$n-2) {\n                if ($heights[$k] == $min_height) {\n                    $min_index = $k;\n                    last;\n                }\n            }\n            ($heights[$n-1], $heights[$min_index]) = ($heights[$min_index], $heights[$n-1]);\n            $min_seconds++;\n        }\n    }\n\n    return $min_seconds;\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy @heights = split ' ', <>;\nchomp @heights;\n\n# Calculate minimum seconds\nmy $result = minimum_seconds($n, @heights);\n\n# Print result\nprint $result;\n","Rust":"\nuse std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let n: usize = lines[0].parse().unwrap();\n    let heights: Vec<u32> = lines[1]\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut swaps = 0;\n    for i in 0..n-1 {\n        if heights[i] > heights[i+1] {\n            swaps += 1;\n        }\n    }\n\n    println!(\"{}\", swaps);\n}\n"}
{"title":"D. Lucky Pair","description":"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya has an array a of n integers. The numbers in the array are numbered starting from 1. Unfortunately, Petya has been misbehaving and so, his parents don't allow him play with arrays that have many lucky numbers. It is guaranteed that no more than 1000 elements in the array a are lucky numbers. Petya needs to find the number of pairs of non-intersecting segments [l1;r1] and [l2;r2] (1\u2264l1\u2264r1<l2\u2264r2\u2264n, all four numbers are integers) such that there's no such lucky number that occurs simultaneously in the subarray a[l1..r1] and in the subarray a[l2..r2]. Help Petya count the number of such pairs.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (2\u2264n\u226410^5) \u2014 the size of the array a. The second line contains n space-separated integers ai (1\u2264ai\u226410^9) \u2014 array a. It is guaranteed that no more than 1000 elements in the array a are lucky numbers. \n","output_spec":"On the single line print the only number \u2014 the answer to the problem.\nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","notes":"The subarray a[l..r] is an array that consists of elements al, al+1, ..., ar.\nIn the first sample there are 9 possible pairs that satisfy the condition: [1,1] and [2,2], [1,1] and [2,3], [1,1] and [2,4], [1,1] and [3,3], [1,1] and [3,4], [1,1] and [4,4], [1,2] and [3,3], [2,2] and [3,3], [3,3] and [4,4].\nIn the second sample there is only one pair of segments \u2014 [1;1] and [2;2] and it satisfies the condition.\n","sample_inputs":["4\n1 4 2 4\n","2\n4 7\n","4\n4 4 7 7\n"],"sample_outputs":["9\n","1\n","9\n"],"id":"145-D","difficulty":2900,"tags":["combinatorics","data+structures","implementation"],"src_uid":"b715a526d9ebdedd00d41369b9778993","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <unordered_set>\\n\\nusing namespace std;\\n\\nbool isLucky(int num) {\\n    while (num > 0) {\\n        int digit = num % 10;\\n        if (digit != 4 && digit != 7) {\\n            return false;\\n        }\\n        num \/= 10;\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n\\n    int count = 0;\\n    for (int l1 = 0; l1 < n; l1++) {\\n        for (int r1 = l1; r1 < n; r1++) {\\n            unordered_set<int> luckyNumbers;\\n            for (int i = l1; i <= r1; i++) {\\n                if (isLucky(a[i])) {\\n                    luckyNumbers.insert(a[i]);\\n                }\\n            }\\n\\n            for (int l2 = r1 + 1; l2 < n; l2++) {\\n                for (int r2 = l2; r2 < n; r2++) {\\n                    bool hasLuckyNumber = false;\\n                    for (int i = l2; i <= r2; i++) {\\n                        if (luckyNumbers.count(a[i]) > 0) {\\n                            hasLuckyNumber = true;\\n                            break;\\n                        }\\n                    }\\n                    if (!hasLuckyNumber) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class LuckySegments {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        \n        int[] prefixCount = new int[n];\n        int[] suffixCount = new int[n];\n        int[] luckyCount = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            if (isLucky(a[i])) {\n                luckyCount[i] = 1;\n            }\n            if (i > 0) {\n                prefixCount[i] = prefixCount[i-1] + luckyCount[i];\n            } else {\n                prefixCount[i] = luckyCount[i];\n            }\n        }\n        \n        for (int i = n-1; i >= 0; i--) {\n            if (i < n-1) {\n                suffixCount[i] = suffixCount[i+1] + luckyCount[i];\n            } else {\n                suffixCount[i] = luckyCount[i];\n            }\n        }\n        \n        long count = 0;\n        for (int i = 0; i < n-1; i++) {\n            count += (long) (prefixCount[i] * suffixCount[i+1]);\n        }\n        \n        System.out.println(count);\n    }\n    \n    public static boolean isLucky(int num) {\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit != 4 && digit != 7) {\n                return false;\n            }\n            num \/= 10;\n        }\n        return true;\n    }\n}","Python":"n = int(input())\\narr = list(map(int, input().split()))\\n\\nlucky_nums = [4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777]\\n\\ncount = 0\\n\\nfor i in range(n):\\n    for j in range(i+1, n):\\n        subarr1 = arr[i:j+1]\\n        subarr2 = arr[j+1:]\\n        if any(num in subarr1 for num in lucky_nums) or any(num in subarr2 for num in lucky_nums):\\n            continue\\n        count += 1\\n\\nprint(count)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int count = 0;\\n\\n    for (int l1 = 0; l1 < n; l1++) {\\n        for (int r1 = l1; r1 < n; r1++) {\\n            for (int l2 = r1 + 1; l2 < n; l2++) {\\n                for (int r2 = l2; r2 < n; r2++) {\\n                    int lucky = 0;\\n                    for (int i = l1; i <= r1; i++) {\\n                        if (a[i] == 4 || a[i] == 7) {\\n                            lucky = 1;\\n                            break;\\n                        }\\n                    }\\n                    if (lucky == 1) {\\n                        continue;\\n                    }\\n                    for (int i = l2; i <= r2; i++) {\\n                        if (a[i] == 4 || a[i] == 7) {\\n                            lucky = 1;\\n                            break;\\n                        }\\n                    }\\n                    if (lucky == 1) {\\n                        continue;\\n                    }\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace LuckyNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            int[] prefixCount = new int[n + 1];\n            int[] suffixCount = new int[n + 1];\n            int[] luckyCount = new int[n + 1];\n\n            for (int i = 1; i <= n; i++)\n            {\n                prefixCount[i] = prefixCount[i - 1] + (IsLucky(a[i - 1]) ? 1 : 0);\n            }\n\n            for (int i = n; i >= 1; i--)\n            {\n                suffixCount[i] = suffixCount[i + 1] + (IsLucky(a[i - 1]) ? 1 : 0);\n            }\n\n            for (int i = 1; i <= n; i++)\n            {\n                luckyCount[i] = luckyCount[i - 1] + (IsLucky(a[i - 1]) ? 1 : 0);\n            }\n\n            long pairsCount = 0;\n\n            for (int l1 = 1; l1 <= n; l1++)\n            {\n                for (int r1 = l1; r1 <= n; r1++)\n                {\n                    int luckyInRange1 = luckyCount[r1] - luckyCount[l1 - 1];\n                    int nonLuckyInRange1 = (r1 - l1 + 1) - luckyInRange1;\n\n                    for (int l2 = r1 + 1; l2 <= n; l2++)\n                    {\n                        for (int r2 = l2; r2 <= n; r2++)\n                        {\n                            int luckyInRange2 = luckyCount[r2] - luckyCount[l2 - 1];\n                            int nonLuckyInRange2 = (r2 - l2 + 1) - luckyInRange2;\n\n                            if (luckyInRange1 == 0 || luckyInRange2 == 0)\n                            {\n                                pairsCount += (long)nonLuckyInRange1 * nonLuckyInRange2;\n                            }\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(pairsCount);\n        }\n\n        static bool IsLucky(int number)\n        {\n            while (number > 0)\n            {\n                int digit = number % 10;\n                if (digit != 4 && digit != 7)\n                {\n                    return false;\n                }\n                number \/= 10;\n            }\n            return true;\n        }\n    }\n}\n","Ruby":"\ndef count_pairs(n, arr)\n  count = 0\n  for i in 0..n-2\n    for j in i+1..n-1\n      if !contains_lucky_number(arr[i..j])\n        count += 1\n      end\n    end\n  end\n  return count\nend\n\ndef contains_lucky_number(subarray)\n  lucky_numbers = [4, 7]\n  subarray.each do |num|\n    if lucky_numbers.include?(num)\n      return true\n    end\n  end\n  return false\nend\n\n# Read input\nn = gets.to_i\narr = gets.split.map(&:to_i)\n\n# Call the function and print the result\nresult = count_pairs(n, arr)\nputs result\n","delphi":"program LuckyNumbers;\\n\\nvar\\n  n, i, j, k, l1, r1, l2, r2, count: integer;\\n  a: array[1..100000] of integer;\\n  lucky: array[1..1000] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(a[i]);\\n\\n  count := 0;\\n\\n  k := 0;\\n  for i := 1 to n do\\n  begin\\n    if (a[i] = 4) or (a[i] = 7) then\\n    begin\\n      k := k + 1;\\n      lucky[k] := i;\\n    end;\\n  end;\\n\\n  for i := 1 to k do\\n  begin\\n    for j := i + 1 to k do\\n    begin\\n      l1 := lucky[i];\\n      r1 := lucky[i];\\n      l2 := lucky[j];\\n      r2 := lucky[j];\\n\\n      if (l1 > r2) or (l2 > r1) then\\n        count := count + 1;\\n    end;\\n  end;\\n\\n  writeln(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar arr []int\\n\\tvar lucky []int\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar num int\\n\\t\\tfmt.Scan(&num)\\n\\t\\tarr = append(arr, num)\\n\\n\\t\\tif strings.Contains(strconv.Itoa(num), \\\"4\\\") || strings.Contains(strconv.Itoa(num), \\\"7\\\") {\\n\\t\\t\\tlucky = append(lucky, i)\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\n\\tfor i := 0; i < len(arr); i++ {\\n\\t\\tfor j := i + 1; j < len(arr); j++ {\\n\\t\\t\\tvalid := true\\n\\n\\t\\t\\tfor _, l := range lucky {\\n\\t\\t\\t\\tif l >= i && l <= j {\\n\\t\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif valid {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function countPairs(n, arr) {\n    let count = 0;\n    let luckyNumbers = [];\n    \n    \/\/ Function to check if a number is lucky\n    function isLucky(num) {\n        while (num > 0) {\n            let digit = num % 10;\n            if (digit !== 4 && digit !== 7) {\n                return false;\n            }\n            num = Math.floor(num \/ 10);\n        }\n        return true;\n    }\n    \n    \/\/ Generate all lucky numbers up to 10^9\n    for (let i = 1; i <= 1000000000; i++) {\n        if (isLucky(i)) {\n            luckyNumbers.push(i);\n        }\n    }\n    \n    \/\/ Check all possible pairs of segments\n    for (let l1 = 1; l1 <= n; l1++) {\n        for (let r1 = l1; r1 <= n; r1++) {\n            for (let l2 = r1 + 1; l2 <= n; l2++) {\n                for (let r2 = l2; r2 <= n; r2++) {\n                    let hasLuckyNumber = false;\n                    \n                    \/\/ Check if there is a lucky number in the first segment\n                    for (let i = l1 - 1; i < r1; i++) {\n                        if (luckyNumbers.includes(arr[i])) {\n                            hasLuckyNumber = true;\n                            break;\n                        }\n                    }\n                    \n                    \/\/ Check if there is a lucky number in the second segment\n                    if (!hasLuckyNumber) {\n                        for (let i = l2 - 1; i < r2; i++) {\n                            if (luckyNumbers.includes(arr[i])) {\n                                hasLuckyNumber = true;\n                                break;\n                            }\n                        }\n                    }\n                    \n                    \/\/ If there is no lucky number in both segments, increment count\n                    if (!hasLuckyNumber) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\n\/\/ Read input\nconst input = JSON.parse('[\\\"4\\\\n1 4 2 4\\\\n\\\"]');\nconst n = parseInt(input[0]);\nconst arr = input[1].split(' ').map(Number);\n\n\/\/ Call the function and print the result\nconst result = countPairs(n, arr);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val a = IntArray(n)\n    for (i in 0 until n) {\n        a[i] = scanner.nextInt()\n    }\n    \n    val luckyNumbers = mutableListOf<Int>()\n    for (i in 0 until n) {\n        if (isLuckyNumber(a[i])) {\n            luckyNumbers.add(i)\n        }\n    }\n    \n    var count = 0\n    for (i in 0 until luckyNumbers.size) {\n        for (j in i + 1 until luckyNumbers.size) {\n            val l1 = luckyNumbers[i] + 1\n            val r1 = luckyNumbers[j] + 1\n            val l2 = r1 + 1\n            val r2 = n\n            \n            if (!containsLuckyNumber(a, l1, r1) && !containsLuckyNumber(a, l2, r2)) {\n                count++\n            }\n        }\n    }\n    \n    println(count)\n}\n\nfun isLuckyNumber(num: Int): Boolean {\n    var n = num\n    while (n > 0) {\n        val digit = n % 10\n        if (digit != 4 && digit != 7) {\n            return false\n        }\n        n \/= 10\n    }\n    return true\n}\n\nfun containsLuckyNumber(a: IntArray, l: Int, r: Int): Boolean {\n    for (i in l - 1 until r) {\n        if (isLuckyNumber(a[i])) {\n            return true\n        }\n    }\n    return false\n}","PHP":"\n<?php\n\nfunction countPairs($n, $arr) {\n    $luckyNumbers = [4, 7];\n    $count = 0;\n    \n    for ($l1 = 1; $l1 <= $n; $l1++) {\n        for ($r1 = $l1; $r1 <= $n; $r1++) {\n            for ($l2 = $r1 + 1; $l2 <= $n; $l2++) {\n                for ($r2 = $l2; $r2 <= $n; $r2++) {\n                    $hasLuckyNumber = false;\n                    \n                    for ($i = $l1; $i <= $r1; $i++) {\n                        if (in_array($arr[$i - 1], $luckyNumbers)) {\n                            $hasLuckyNumber = true;\n                            break;\n                        }\n                    }\n                    \n                    if ($hasLuckyNumber) {\n                        continue;\n                    }\n                    \n                    for ($i = $l2; $i <= $r2; $i++) {\n                        if (in_array($arr[$i - 1], $luckyNumbers)) {\n                            $hasLuckyNumber = true;\n                            break;\n                        }\n                    }\n                    \n                    if ($hasLuckyNumber) {\n                        continue;\n                    }\n                    \n                    $count++;\n                }\n            }\n        }\n    }\n    \n    return $count;\n}\n\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\n$n = intval($input[0]);\n$arr = array_map('intval', explode(\\\" \\\", $input[1]));\n\n$result = countPairs($n, $arr);\n\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint countPairs(int[] a)\\r\\n{\\r\\n    int n = a.length;\\r\\n    int[] prefix = new int[n];\\r\\n    int[] suffix = new int[n];\\r\\n    int[] lucky = new int[n];\\r\\n    int count = 0;\\r\\n\\r\\n    foreach (i, num; a)\\r\\n    {\\r\\n        if (num == 4 || num == 7)\\r\\n            lucky[i] = 1;\\r\\n\\r\\n        if (i > 0)\\r\\n            prefix[i] = prefix[i - 1] + lucky[i];\\r\\n        else\\r\\n            prefix[i] = lucky[i];\\r\\n    }\\r\\n\\r\\n    for (int i = n - 1; i >= 0; i--)\\r\\n    {\\r\\n        if (i < n - 1)\\r\\n            suffix[i] = suffix[i + 1] + lucky[i];\\r\\n        else\\r\\n            suffix[i] = lucky[i];\\r\\n    }\\r\\n\\r\\n    for (int i = 0; i < n - 1; i++)\\r\\n    {\\r\\n        for (int j = i + 1; j < n; j++)\\r\\n        {\\r\\n            if (prefix[i] == 0 && suffix[j] == 0)\\r\\n                count++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] a;\\r\\n\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int num;\\r\\n        readf(\\\"%d\\\", &num);\\r\\n        a ~= num;\\r\\n    }\\r\\n\\r\\n    int result = countPairs(a);\\r\\n\\r\\n    writef(\\\"%d\\\\n\\\", result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_pairs {\n    my ($n, @a) = @_;\n\n    my %lucky_nums;\n    foreach my $num (@a) {\n        $lucky_nums{$num} = 1 if is_lucky($num);\n    }\n\n    my $count = 0;\n    for (my $l1 = 1; $l1 <= $n; $l1++) {\n        for (my $r1 = $l1; $r1 <= $n; $r1++) {\n            for (my $l2 = $r1 + 1; $l2 <= $n; $l2++) {\n                for (my $r2 = $l2; $r2 <= $n; $r2++) {\n                    my $has_lucky = 0;\n                    for (my $i = $l1; $i <= $r1; $i++) {\n                        if ($lucky_nums{$a[$i]}) {\n                            $has_lucky = 1;\n                            last;\n                        }\n                    }\n                    next if $has_lucky;\n\n                    for (my $i = $l2; $i <= $r2; $i++) {\n                        if ($lucky_nums{$a[$i]}) {\n                            $has_lucky = 1;\n                            last;\n                        }\n                    }\n                    next if $has_lucky;\n\n                    $count++;\n                }\n            }\n        }\n    }\n\n    return $count;\n}\n\nsub is_lucky {\n    my ($num) = @_;\n\n    while ($num > 0) {\n        my $digit = $num % 10;\n        return 0 if $digit != 4 && $digit != 7;\n        $num = int($num \/ 10);\n    }\n\n    return 1;\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy @a = split ' ', <>;\nchomp @a;\n\n# Count pairs\nmy $result = count_pairs($n, @a);\n\n# Print result\nprint $result;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    input.clear();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let a: Vec<u32> = input\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut count = 0;\\n\\n    for l1 in 0..n {\\n        for r1 in l1..n {\\n            for l2 in r1 + 1..n {\\n                for r2 in l2..n {\\n                    let subarray1 = &a[l1..=r1];\\n                    let subarray2 = &a[l2..=r2];\\n\\n                    let has_lucky_number = subarray1.iter().any(|&x| x == 4 || x == 7)\\n                        || subarray2.iter().any(|&x| x == 4 || x == 7);\\n\\n                    if !has_lucky_number {\\n                        count += 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"A. Punctuation","description":"You are given a text that consists of lowercase Latin letters, spaces and punctuation marks (dot, comma, exclamation mark and question mark). A word is defined as a sequence of consecutive Latin letters.Your task is to add spaces to the text by the following rules:  if there is no punctuation mark between two words, then they should be separated by exactly one space  there should be no spaces before each punctuation mark  there should be exactly one space after each punctuation mark It is guaranteed that there is at least one word between any two punctuation marks. The text begins and ends with a Latin letter.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The input data contains of a single non-empty line \u2014 the text whose length is no more than 10000 characters.\n","output_spec":"Print the text, edited according to the rules. In this problem you should follow the output format very strictly. For example, extra space at the end of the output line is considered as wrong answer. Note that a newline character at the end of the line doesn't matter.\n","notes":null,"sample_inputs":["galileo galilei was an   italian physicist  ,mathematician,astronomer\n","galileo  was  born  in  pisa\n"],"sample_outputs":["galileo galilei was an italian physicist, mathematician, astronomer\n","galileo was born in pisa\n"],"id":"147-A","difficulty":1300,"tags":["implementation","strings"],"src_uid":"8c26daa1eed2078af3b32737da0a0f84","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nstring addSpaces(string text) {\\n    string result;\\n    bool spaceBeforePunctuation = false;\\n    bool spaceAfterPunctuation = true;\\n    \\n    for (int i = 0; i < text.length(); i++) {\\n        if (isalpha(text[i])) {\\n            result += text[i];\\n            spaceBeforePunctuation = false;\\n        }\\n        else if (ispunct(text[i])) {\\n            if (spaceAfterPunctuation) {\\n                result += ' ';\\n            }\\n            result += text[i];\\n            result += ' ';\\n            spaceBeforePunctuation = true;\\n            spaceAfterPunctuation = true;\\n        }\\n        else if (isspace(text[i])) {\\n            if (!spaceBeforePunctuation) {\\n                result += ' ';\\n            }\\n            spaceBeforePunctuation = true;\\n            spaceAfterPunctuation = false;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\nint main() {\\n    string text;\\n    getline(cin, text);\\n    \\n    string editedText = addSpaces(text);\\n    cout << editedText << endl;\\n    \\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class TextEditor {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String text = scanner.nextLine();\\n        StringBuilder editedText = new StringBuilder();\\n\\n        boolean spaceBeforePunctuation = false;\\n\\n        for (int i = 0; i < text.length(); i++) {\\n            char currentChar = text.charAt(i);\\n\\n            if (Character.isLetter(currentChar)) {\\n                editedText.append(currentChar);\\n                spaceBeforePunctuation = false;\\n            } else if (currentChar == ' ') {\\n                if (!spaceBeforePunctuation) {\\n                    editedText.append(currentChar);\\n                }\\n            } else {\\n                editedText.append(currentChar);\\n                spaceBeforePunctuation = true;\\n            }\\n        }\\n\\n        System.out.println(editedText.toString());\\n    }\\n}","Python":"def add_spaces(text):\n    punctuation_marks = ['.', ',', '!', '?']\n    new_text = ''\n    for i in range(len(text)):\n        if text[i].isalpha():\n            new_text += text[i]\n        elif text[i] in punctuation_marks:\n            new_text = new_text.rstrip() + ' ' + text[i] + ' '\n        elif text[i] == ' ':\n            if text[i-1].isalpha() and text[i+1].isalpha():\n                new_text += ' '\n    return new_text.strip()\n\ninput_text = input()\noutput_text = add_spaces(input_text)\nprint(output_text)","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char text[10000];\\n    fgets(text, sizeof(text), stdin);\\n    int len = strlen(text);\\n    \\n    for (int i = 0; i < len; i++) {\\n        \/\/ Remove extra spaces\\n        if (text[i] == ' ' && text[i+1] == ' ') {\\n            for (int j = i+1; j < len; j++) {\\n                text[j] = text[j+1];\\n            }\\n            len--;\\n            i--;\\n        }\\n        \/\/ Add space after punctuation marks\\n        else if (text[i] == '.' || text[i] == ',' || text[i] == '!' || text[i] == '?') {\\n            if (text[i+1] != ' ') {\\n                for (int j = len; j > i+1; j--) {\\n                    text[j] = text[j-1];\\n                }\\n                text[i+1] = ' ';\\n                len++;\\n            }\\n        }\\n        \/\/ Add space before punctuation marks\\n        else if (text[i] == '.' || text[i] == ',' || text[i] == '!' || text[i] == '?') {\\n            if (text[i-1] != ' ') {\\n                for (int j = len; j > i; j--) {\\n                    text[j] = text[j-1];\\n                }\\n                text[i] = ' ';\\n                len++;\\n                i++;\\n            }\\n        }\\n    }\\n    \\n    printf(\\\"%s\\\", text);\\n    \\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string text = Console.ReadLine();\n        string editedText = EditText(text);\n        Console.WriteLine(editedText);\n    }\n\n    static string EditText(string text)\n    {\n        string editedText = \"\";\n        bool isPreviousCharPunctuation = false;\n\n        for (int i = 0; i < text.Length; i++)\n        {\n            char currentChar = text[i];\n\n            if (IsLatinLetter(currentChar))\n            {\n                editedText += currentChar;\n                isPreviousCharPunctuation = false;\n            }\n            else if (IsPunctuationMark(currentChar))\n            {\n                if (!isPreviousCharPunctuation)\n                {\n                    editedText += \" \";\n                }\n\n                editedText += currentChar + \" \";\n                isPreviousCharPunctuation = true;\n            }\n            else if (currentChar == ' ')\n            {\n                if (!isPreviousCharPunctuation)\n                {\n                    editedText += \" \";\n                }\n            }\n        }\n\n        return editedText.Trim();\n    }\n\n    static bool IsLatinLetter(char c)\n    {\n        return (c >= 'a' && c <= 'z');\n    }\n\n    static bool IsPunctuationMark(char c)\n    {\n        return (c == '.' || c == ',' || c == '!' || c == '?');\n    }\n}","Ruby":"\ndef add_spaces(text)\n  # Remove extra spaces\n  text = text.gsub(\/\\s+\/, ' ')\n\n  # Add space after punctuation marks\n  text = text.gsub(\/([.,!?])([a-z])\/i, '\\1 \\2')\n\n  # Add space before punctuation marks\n  text = text.gsub(\/([a-z])([.,!?])\/i, '\\1 \\2')\n\n  # Remove space before punctuation marks\n  text = text.gsub(\/\\s+([.,!?])\/i, '\\1')\n\n  # Remove space after punctuation marks\n  text = text.gsub(\/([.,!?])\\s+\/i, '\\1')\n\n  text\nend\n\n# Read input from user\ntext = gets.chomp\n\n# Call the function and print the result\nputs add_spaces(text)\n","delphi":"program AddSpaces;\n\nuses\n  SysUtils;\n\nfunction AddSpacesToText(text: string): string;\nvar\n  i: Integer;\nbegin\n  \/\/ Remove extra spaces at the beginning and end of the text\n  text := Trim(text);\n\n  \/\/ Add spaces between words\n  for i := 1 to Length(text) - 1 do\n  begin\n    \/\/ Check if the current character is a punctuation mark\n    if (text[i] in ['.', ',', '!', '?']) then\n    begin\n      \/\/ Remove spaces before the punctuation mark\n      if (text[i - 1] = ' ') then\n        Delete(text, i - 1, 1);\n\n      \/\/ Add a space after the punctuation mark\n      if (text[i + 1] <> ' ') then\n        Insert(' ', text, i + 1);\n    end\n    \/\/ Check if the current character is a letter and the next character is not a space\n    else if (text[i] in ['a'..'z', 'A'..'Z']) and (text[i + 1] <> ' ') then\n    begin\n      \/\/ Add a space after the word\n      Insert(' ', text, i + 1);\n    end;\n  end;\n\n  Result := text;\nend;\n\nvar\n  inputText: string;\nbegin\n  \/\/ Read the input text\n  ReadLn(inputText);\n\n  \/\/ Add spaces to the text\n  inputText := AddSpacesToText(inputText);\n\n  \/\/ Print the edited text\n  WriteLn(inputText);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc addSpaces(text string) string {\\n\\tvar result string\\n\\n\\t\/\/ Remove extra spaces\\n\\ttext = strings.Join(strings.Fields(text), \\\" \\\")\\n\\n\\t\/\/ Add spaces between words\\n\\tfor i := 0; i < len(text)-1; i++ {\\n\\t\\tif isLetter(text[i]) && isLetter(text[i+1]) {\\n\\t\\t\\tresult += string(text[i]) + \\\" \\\"\\n\\t\\t} else {\\n\\t\\t\\tresult += string(text[i])\\n\\t\\t}\\n\\t}\\n\\tresult += string(text[len(text)-1])\\n\\n\\t\/\/ Add spaces after punctuation marks\\n\\tresult = strings.ReplaceAll(result, \\\".\\\", \\\". \\\")\\n\\tresult = strings.ReplaceAll(result, \\\",\\\", \\\", \\\")\\n\\tresult = strings.ReplaceAll(result, \\\"!\\\", \\\"! \\\")\\n\\tresult = strings.ReplaceAll(result, \\\"?\\\", \\\"? \\\")\\n\\n\\treturn result\\n}\\n\\nfunc isLetter(c byte) bool {\\n\\treturn (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\\n}\\n\\nfunc main() {\\n\\ttext := \\\"galileo galilei was an   italian physicist  ,mathematician,astronomer\\\"\\n\\tresult := addSpaces(text)\\n\\tfmt.Println(result)\\n}","Javascript":"function addSpaces(text) {\n  let result = '';\n  let prevChar = '';\n  \n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    \n    if (char === ' ') {\n      if (prevChar !== ' ' && !isPunctuation(prevChar)) {\n        result += ' ';\n      }\n    } else if (isPunctuation(char)) {\n      result = result.trim() + ' ' + char + ' ';\n    } else {\n      result += char;\n    }\n    \n    prevChar = char;\n  }\n  \n  return result.trim();\n}\n\nfunction isPunctuation(char) {\n  const punctuationMarks = ['.', ',', '!', '?'];\n  return punctuationMarks.includes(char);\n}\n\nconst input = 'galileo galilei was an   italian physicist  ,mathematician,astronomer';\nconst output = addSpaces(input);\nconsole.log(output);","Kotlin":"fun addSpacesToText(text: String): String {\n    var result = \"\"\n    var prevChar = ' '\n    var prevPunctuation = false\n\n    for (char in text) {\n        if (char.isLetter()) {\n            if (prevPunctuation) {\n                result += \" \"\n            }\n            result += char\n            prevPunctuation = false\n        } else if (char.isWhitespace()) {\n            if (prevChar.isLetter()) {\n                result += \" \"\n            }\n        } else {\n            result += char\n            prevPunctuation = true\n        }\n\n        prevChar = char\n    }\n\n    return result.trim()\n}\n\nfun main() {\n    val input = readLine() ?: \"\"\n    val output = addSpacesToText(input)\n    println(output)\n}","PHP":"<?php\\n\\nfunction addSpaces($text) {\\n  $punctuationMarks = ['.', ',', '!', '?'];\\n  $result = '';\\n  $prevChar = '';\\n\\n  for ($i = 0; $i < strlen($text); $i++) {\\n    $char = $text[$i];\\n\\n    if (ctype_alpha($char)) {\\n      $result .= $char;\\n    } else if (in_array($char, $punctuationMarks)) {\\n      $result = rtrim($result);\\n      $result .= $char . ' ';\\n    } else if ($char == ' ') {\\n      if (ctype_alpha($prevChar)) {\\n        $result .= ' ';\\n      }\\n    }\\n\\n    $prevChar = $char;\\n  }\\n\\n  return $result;\\n}\\n\\n$text = 'galileo galilei was an   italian physicist  ,mathematician,astronomer';\\n$result = addSpaces($text);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.string;\\r\\n\\r\\nstring addSpaces(string text)\\r\\n{\\r\\n    string result;\\r\\n    bool isPunctuation = false;\\r\\n    foreach (char c; text)\\r\\n    {\\r\\n        if (c.isAlpha)\\r\\n        {\\r\\n            if (isPunctuation)\\r\\n            {\\r\\n                result ~= ' ';\\r\\n                isPunctuation = false;\\r\\n            }\\r\\n            result ~= c;\\r\\n        }\\r\\n        else if (c.isPunct)\\r\\n        {\\r\\n            result ~= c;\\r\\n            result ~= ' ';\\r\\n            isPunctuation = true;\\r\\n        }\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string text = readln();\\r\\n    string editedText = addSpaces(text);\\r\\n    writeln(editedText);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nmy $text = <STDIN>;\nchomp $text;\n\n# Remove extra spaces\n$text =~ s\/\\s+\/ \/g;\n\n# Add spaces between words and punctuation marks\n$text =~ s\/(\\w)([.,!?])\/$1 $2\/g;\n\n# Remove spaces before punctuation marks\n$text =~ s\/\\s+([.,!?])\/$1\/g;\n\nprint $text;\n","Rust":"fn main() {\\n    let text = \\\"galileo galilei was an   italian physicist  ,mathematician,astronomer\\\";\\n    let mut result = String::new();\\n    let mut prev_char = ' ';\\n\\n    for c in text.chars() {\\n        if c.is_alphabetic() {\\n            result.push(c);\\n        } else if c.is_whitespace() {\\n            if !prev_char.is_whitespace() {\\n                result.push(' ');\\n            }\\n        } else {\\n            result.push(c);\\n            result.push(' ');\\n        }\\n\\n        prev_char = c;\\n    }\\n\\n    println!(\\\"{}\\\", result.trim_end());\\n}"}
{"title":"A. Insomnia cure","description":"\u00abOne dragon. Two dragon. Three dragon\u00bb, \u2014 the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every k-th dragon got punched in the face with a frying pan. Every l-th dragon got his tail shut into the balcony door. Every m-th dragon got his paws trampled with sharp heels. Finally, she threatened every n-th dragon to call her mom, and he withdrew in panic.How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of d dragons?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"Input data contains integer numbers k,l,m,n and d, each number in a separate line (1\u2264k,l,m,n\u226410, 1\u2264d\u226410^5).\n","output_spec":"Output the number of damaged dragons.\n","notes":"In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.\nIn the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.\n","sample_inputs":["1\n2\n3\n4\n12\n","2\n3\n4\n5\n24\n"],"sample_outputs":["12\n","17\n"],"id":"148-A","difficulty":800,"tags":["constructive+algorithms","implementation","math"],"src_uid":"46bfdec9bfc1e91bd2f5022f3d3c8ce7","C++":"#include <iostream>\\n\\nint main() {\\n    int k, l, m, n, d;\\n    std::cin >> k >> l >> m >> n >> d;\\n\\n    int damagedDragons = 0;\\n\\n    for (int i = 1; i <= d; i++) {\\n        if (i % k == 0 || i % l == 0 || i % m == 0 || i % n == 0) {\\n            damagedDragons++;\\n        }\\n    }\\n\\n    std::cout << damagedDragons << std::endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class DragonDamage {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        int k = scanner.nextInt();\\n        int l = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int n = scanner.nextInt();\\n        int d = scanner.nextInt();\\n\\n        int damagedDragons = 0;\\n\\n        for (int i = 1; i <= d; i++) {\\n            if (i % k == 0 || i % l == 0 || i % m == 0 || i % n == 0) {\\n                damagedDragons++;\\n            }\\n        }\\n\\n        System.out.println(damagedDragons);\\n    }\\n}\" }","Python":"def damaged_dragons(k, l, m, n, d):\n    damaged = 0\n    for i in range(1, d+1):\n        if i % k == 0 or i % l == 0 or i % m == 0 or i % n == 0:\n            damaged += 1\n    return damaged\n\ninput_data = input().split('\\\\n')\nk = int(input_data[0])\nl = int(input_data[1])\nm = int(input_data[2])\nn = int(input_data[3])\nd = int(input_data[4])\n\nresult = damaged_dragons(k, l, m, n, d)\nprint(result)\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int k, l, m, n, d;\\n    scanf(\\\"%d\\\", &k);\\n    scanf(\\\"%d\\\", &l);\\n    scanf(\\\"%d\\\", &m);\\n    scanf(\\\"%d\\\", &n);\\n    scanf(\\\"%d\\\", &d);\\n\\n    int damagedDragons = 0;\\n\\n    for (int i = 1; i <= d; i++) {\\n        if (i % k == 0 || i % l == 0 || i % m == 0 || i % n == 0) {\\n            damagedDragons++;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", damagedDragons);\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int k = Convert.ToInt32(Console.ReadLine());\n        int l = Convert.ToInt32(Console.ReadLine());\n        int m = Convert.ToInt32(Console.ReadLine());\n        int n = Convert.ToInt32(Console.ReadLine());\n        int d = Convert.ToInt32(Console.ReadLine());\n\n        int damagedDragons = 0;\n\n        for (int i = 1; i <= d; i++)\n        {\n            if (i % k == 0 || i % l == 0 || i % m == 0 || i % n == 0)\n            {\n                damagedDragons++;\n            }\n        }\n\n        Console.WriteLine(damagedDragons);\n    }\n}","Ruby":"\ndef damaged_dragons(k, l, m, n, d)\n  damaged = 0\n  (1..d).each do |dragon|\n    if dragon % k == 0 || dragon % l == 0 || dragon % m == 0 || dragon % n == 0\n      damaged += 1\n    end\n  end\n  return damaged\nend\n\ninput = gets.chomp.split('\\n')\nk = input[0].to_i\nl = input[1].to_i\nm = input[2].to_i\nn = input[3].to_i\nd = input[4].to_i\n\noutput = damaged_dragons(k, l, m, n, d)\nputs output\n","delphi":"program CountDamagedDragons;\\n\\nvar\\n  k, l, m, n, d, count: Integer;\\n\\nbegin\\n  \/\/ Read input values\\n  ReadLn(k);\\n  ReadLn(l);\\n  ReadLn(m);\\n  ReadLn(n);\\n  ReadLn(d);\\n\\n  count := 0;\\n\\n  \/\/ Loop through all dragons\\n  for var i := 1 to d do\\n  begin\\n    \/\/ Check if the current dragon is divisible by k, l, m, or n\\n    if (i mod k = 0) or (i mod l = 0) or (i mod m = 0) or (i mod n = 0) then\\n      Inc(count);\\n  end;\\n\\n  \/\/ Output the number of damaged dragons\\n  WriteLn(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\n\\tvar k, l, m, n, d int\\n\\n\\tscanner.Scan()\\n\\tk, _ = strconv.Atoi(scanner.Text())\\n\\n\\tscanner.Scan()\\n\\tl, _ = strconv.Atoi(scanner.Text())\\n\\n\\tscanner.Scan()\\n\\tm, _ = strconv.Atoi(scanner.Text())\\n\\n\\tscanner.Scan()\\n\\tn, _ = strconv.Atoi(scanner.Text())\\n\\n\\tscanner.Scan()\\n\\td, _ = strconv.Atoi(scanner.Text())\\n\\n\\tdamagedDragons := 0\\n\\n\\tfor i := 1; i <= d; i++ {\\n\\t\\tif i%k == 0 || i%l == 0 || i%m == 0 || i%n == 0 {\\n\\t\\t\\tdamagedDragons++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(damagedDragons)\\n}","Javascript":"function countDamagedDragons(k, l, m, n, d) {\n  let damagedDragons = 0;\n  \n  for (let i = 1; i <= d; i++) {\n    if (i % k === 0 || i % l === 0 || i % m === 0 || i % n === 0) {\n      damagedDragons++;\n    }\n  }\n  \n  return damagedDragons;\n}\n\nconst input = ['1\\n2\\n3\\n4\\n12\\n', '2\\n3\\n4\\n5\\n24\\n'];\nconst output = [];\n\nfor (let i = 0; i < input.length; i++) {\n  const numbers = input[i].split('\\\\n').map(Number);\n  const damagedDragons = countDamagedDragons(numbers[0], numbers[1], numbers[2], numbers[3], numbers[4]);\n  output.push(damagedDragons + '\\\\n');\n}\n\nJSON.stringify(output);","Kotlin":"fun countDamagedDragons(k: Int, l: Int, m: Int, n: Int, d: Int): Int {\n    var damagedDragons = 0\n    \n    for (i in 1..d) {\n        if (i % k == 0 || i % l == 0 || i % m == 0 || i % n == 0) {\n            damagedDragons++\n        }\n    }\n    \n    return damagedDragons\n}\n\nfun main() {\n    val input = readLine()!!.split(\"\\n\")\n    val k = input[0].toInt()\n    val l = input[1].toInt()\n    val m = input[2].toInt()\n    val n = input[3].toInt()\n    val d = input[4].toInt()\n    \n    val damagedDragons = countDamagedDragons(k, l, m, n, d)\n    println(damagedDragons)\n}","PHP":"<?php\\n\\nfunction countDamagedDragons($k, $l, $m, $n, $d) {\\n    $damagedDragons = 0;\\n\\n    for ($i = 1; $i <= $d; $i++) {\\n        if ($i % $k == 0 || $i % $l == 0 || $i % $m == 0 || $i % $n == 0) {\\n            $damagedDragons++;\\n        }\\n    }\\n\\n    return $damagedDragons;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$k = intval($input[0]);\\n$l = intval($input[1]);\\n$m = intval($input[2]);\\n$n = intval($input[3]);\\n$d = intval($input[4]);\\n\\n$result = countDamagedDragons($k, $l, $m, $n, $d);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int k, l, m, n, d;\\r\\n    readf(\\\"%d\\\\n%d\\\\n%d\\\\n%d\\\\n%d\\\", &k, &l, &m, &n, &d);\\r\\n\\r\\n    int damagedDragons = 0;\\r\\n\\r\\n    for (int i = 1; i <= d; i++)\\r\\n    {\\r\\n        if (i % k == 0 || i % l == 0 || i % m == 0 || i % n == 0)\\r\\n        {\\r\\n            damagedDragons++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writef(\\\"%d\\\\n\\\", damagedDragons);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_damaged_dragons {\n    my ($k, $l, $m, $n, $d) = @_;\n\n    my $damaged_dragons = 0;\n\n    for my $dragon (1..$d) {\n        if ($dragon % $k == 0 || $dragon % $l == 0 || $dragon % $m == 0 || $dragon % $n == 0) {\n            $damaged_dragons++;\n        }\n    }\n\n    return $damaged_dragons;\n}\n\nmy @inputs = (\n    [1, 2, 3, 4, 12],\n    [2, 3, 4, 5, 24]\n);\n\nmy @outputs;\n\nforeach my $input (@inputs) {\n    my $damaged_dragons = count_damaged_dragons(@$input);\n    push @outputs, $damaged_dragons;\n}\n\nprint join(\\\"\\\\n\\\", @outputs);\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let k: u32 = input.trim().parse().unwrap();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let l: u32 = input.trim().parse().unwrap();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let m: u32 = input.trim().parse().unwrap();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: u32 = input.trim().parse().unwrap();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let d: u32 = input.trim().parse().unwrap();\n    \n    let mut damaged_dragons = 0;\n    \n    for i in 1..=d {\n        if i % k == 0 || i % l == 0 || i % m == 0 || i % n == 0 {\n            damaged_dragons += 1;\n        }\n    }\n    \n    println!(\"{}\", damaged_dragons);\n}"}
{"title":"D. Bag of mice","description":"The dragon and the princess are arguing about what to do on the New Year's Eve. The dragon suggests flying to the mountains to watch fairies dancing in the moonlight, while the princess thinks they should just go to bed early. They are desperate to come to an amicable agreement, so they decide to leave this up to chance.They take turns drawing a mouse from a bag which initially contains w white and b black mice. The person who is the first to draw a white mouse wins. After each mouse drawn by the dragon the rest of mice in the bag panic, and one of them jumps out of the bag itself (the princess draws her mice carefully and doesn't scare other mice). Princess draws first. What is the probability of the princess winning?If there are no more mice in the bag and nobody has drawn a white mouse, the dragon wins. Mice which jump out of the bag themselves are not considered to be drawn (do not define the winner). Once a mouse has left the bag, it never returns to it. Every mouse is drawn from the bag with the same probability as every other one, and every mouse jumps out of the bag with the same probability as every other one.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line of input data contains two integers w and b (0\u2264w,b\u22641000).\n","output_spec":"Output the probability of the princess winning. The answer is considered to be correct if its absolute or relative error does not exceed 10^-9.\n","notes":"Let's go through the first sample. The probability of the princess drawing a white mouse on her first turn and winning right away is 1\/4. The probability of the dragon drawing a black mouse and not winning on his first turn is 3\/4 * 2\/3 = 1\/2. After this there are two mice left in the bag \u2014 one black and one white; one of them jumps out, and the other is drawn by the princess on her second turn. If the princess' mouse is white, she wins (probability is 1\/2 * 1\/2 = 1\/4), otherwise nobody gets the white mouse, so according to the rule the dragon wins.\n","sample_inputs":["1 3\n","5 5\n"],"sample_outputs":["0.500000000\n","0.658730159\n"],"id":"148-D","difficulty":1800,"tags":["dp","games","math","probabilities"],"src_uid":"7adb8bf6879925955bf187c3d05fde8c","C++":"#include <iostream>\\n#include <iomanip>\\n\\nusing namespace std;\\n\\nint main() {\\n    int w, b;\\n    cin >> w >> b;\\n\\n    double prob = 0;\\n\\n    if (w == 0) {\\n        prob = 0;\\n    } else if (b == 0) {\\n        prob = 1;\\n    } else {\\n        prob = (double)w \/ (w + b);\\n        double remaining = b - 1;\\n        double total = w + b - 1;\\n\\n        if (remaining > 0) {\\n            prob += (double)w \/ total * ((remaining \/ total) * ((remaining - 1) \/ (total - 1)) * (1 - prob));\\n        }\\n    }\\n\\n    cout << fixed << setprecision(9) << prob << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int w = scanner.nextInt();\\n        int b = scanner.nextInt();\\n        double probability = calculateProbability(w, b);\\n        System.out.printf(\\\"%.9f\\\", probability);\\n    }\\n\\n    public static double calculateProbability(int w, int b) {\\n        if (w == 0) {\\n            return 0;\\n        }\\n        if (b == 0) {\\n            return 1;\\n        }\\n        double total = w + b;\\n        double princessWins = w \/ total;\\n        double dragonWins = 0;\\n        if (b >= 2) {\\n            double remainingProbability = (b - 1) \/ total;\\n            double princessWinsAfterDragon = calculateProbability(w, b - 2);\\n            double dragonWinsAfterDragon = calculateProbability(w, b - 1);\\n            dragonWins = remainingProbability * (1 - princessWinsAfterDragon) + (1 - remainingProbability) * (1 - dragonWinsAfterDragon);\\n        }\\n        return Math.max(princessWins, dragonWins);\\n    }\\n}","Python":"def princess_probability(w, b):\\n    if w == 0:\\n        return 0\\n    if b == 0:\\n        return 1\\n    total = w + b\\n    prob = 0\\n    if w >= 1:\\n        prob += w \/ total\\n        if b >= 1:\\n            prob += (b \/ total) * ((b - 1) \/ (total - 1)) * princess_probability(w, b - 2)\\n    return prob\\n\\nw, b = map(int, input().split())\\nprobability = princess_probability(w, b)\\nprint('{:.9f}'.format(probability))","C":"#include <stdio.h>\\n\\nint main() {\\n    int w, b;\\n    scanf(\\\"%d %d\\\", &w, &b);\\n    double prob = 0;\\n    if (w == 0) {\\n        prob = 0;\\n    } else if (b == 0) {\\n        prob = 1;\\n    } else {\\n        prob = (double)w \/ (w + b);\\n        double remaining_prob = (double)b \/ (w + b - 1);\\n        if (b > 1) {\\n            remaining_prob *= (double)(b - 1) \/ (w + b - 2);\\n        }\\n        prob += (1 - prob) * remaining_prob;\\n    }\\n    printf(\\\"%.9lf\\\\n\\\", prob);\\n    return 0;\\n}","C#":"using System;\n\nnamespace PrincessAndDragon\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int w = int.Parse(input[0]);\n            int b = int.Parse(input[1]);\n\n            double probability = CalculateProbability(w, b);\n            Console.WriteLine(probability.ToString(\"F9\"));\n        }\n\n        static double CalculateProbability(int w, int b)\n        {\n            if (w == 0)\n            {\n                return 0;\n            }\n            else if (b == 0)\n            {\n                return 1;\n            }\n            else\n            {\n                double totalMice = w + b;\n                double princessProbability = w \/ totalMice;\n                double dragonProbability = b \/ totalMice;\n\n                double remainingMice = b - 1;\n                double remainingWhiteMice = w;\n                double remainingBlackMice = b - 1;\n\n                double probability = princessProbability;\n\n                while (remainingMice > 0)\n                {\n                    double princessWinsProbability = (remainingWhiteMice \/ remainingMice) * (remainingBlackMice \/ (remainingMice - 1));\n                    double dragonWinsProbability = 1 - princessWinsProbability;\n\n                    probability += princessProbability * princessWinsProbability;\n\n                    remainingMice--;\n                    remainingWhiteMice--;\n                    remainingBlackMice--;\n                }\n\n                return probability;\n            }\n        }\n    }\n}","Ruby":"\ndef probability_of_princess_winning(w, b)\n  if b == 0\n    return 1.0\n  end\n\n  total_mice = w + b\n  princess_prob = w.to_f \/ total_mice\n  dragon_prob = b.to_f \/ total_mice\n\n  # Calculate the probability of the princess winning on her first turn\n  prob_princess_first_turn = princess_prob\n\n  # Calculate the probability of the dragon not winning on his first turn\n  prob_dragon_not_winning_first_turn = (b - 1).to_f \/ (total_mice - 1)\n\n  # Calculate the probability of the princess winning on her second turn\n  prob_princess_second_turn = (w - 1).to_f \/ (total_mice - 2)\n\n  # Calculate the probability of the princess winning overall\n  prob_princess_winning = prob_princess_first_turn + (prob_dragon_not_winning_first_turn * prob_princess_second_turn)\n\n  return prob_princess_winning\nend\n\ninput = gets.chomp.split(' ')\nw = input[0].to_i\nb = input[1].to_i\n\nresult = probability_of_princess_winning(w, b)\nputs result\n","delphi":"program PrincessWinningProbability;\\n\\nvar\\n  w, b: Integer;\\n  probability: Extended;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(w, b);\\n\\n  \/\/ Calculate probability\\n  probability := w \/ (w + b);\\n\\n  \/\/ Output result\\n  WriteLn(probability:0:9);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar w, b int\\n\\tfmt.Scanf(\\\"%d %d\\\", &w, &b)\\n\\n\\t\/\/ If there are no black mice, the princess wins\\n\\tif b == 0 {\\n\\t\\tfmt.Println(1.0)\\n\\t\\treturn\\n\\t}\\n\\n\\t\/\/ Calculate the probability of the princess winning\\n\\tp := float64(w) \/ float64(w+b)\\n\\n\\t\/\/ If there are no white mice, the dragon wins\\n\\tif w == 0 {\\n\\t\\tfmt.Println(0.0)\\n\\t\\treturn\\n\\t}\\n\\n\\t\/\/ Calculate the probability of the dragon winning\\n\\td := float64(b-1) \/ float64(w+b-1)\\n\\n\\t\/\/ Calculate the final probability\\n\\tresult := p + (1-p)*p*d\/(1-(1-p)*(1-d))\\n\\n\\tfmt.Println(result)\\n}","Javascript":"function calculateProbability(w, b) {\n    if (w == 0) {\n        return '0.000000000';\n    }\n    \n    var probability = 0;\n    \n    if (b > 0) {\n        probability = w \/ (w + b);\n        \n        if (b > 1) {\n            var remainingProbability = (b - 1) \/ (w + b - 1);\n            var princessWinsProbability = calculateProbability(w - 1, b - 2);\n            var dragonWinsProbability = calculateProbability(w, b - 2);\n            \n            probability += (1 - probability) * remainingProbability * princessWinsProbability;\n            probability += (1 - probability) * remainingProbability * dragonWinsProbability;\n        }\n    }\n    \n    return probability.toFixed(9);\n}\n\nvar input = '1 3\\n';\nvar inputArr = input.trim().split(' ');\nvar w = parseInt(inputArr[0]);\nvar b = parseInt(inputArr[1]);\n\nvar result = calculateProbability(w, b);\nconsole.log(result);","Kotlin":"import java.util.Scanner\\n\\nfun main(args: Array<String>) {\\n    val scanner = Scanner(System.`in`)\\n    val w = scanner.nextInt()\\n    val b = scanner.nextInt()\\n\\n    val dp = Array(w + 1) { DoubleArray(b + 1) }\\n\\n    for (i in 0..w) {\\n        for (j in 0..b) {\\n            if (i == 0 && j == 0) continue\\n\\n            val total = i + j\\n\\n            if (i > 0) {\\n                dp[i][j] += i.toDouble() \/ total\\n\\n                if (j > 1) {\\n                    dp[i][j] += (j - 1).toDouble() \/ total * (j - 2).toDouble() \/ (total - 1) * dp[i][j - 2]\\n                }\\n            }\\n\\n            if (j > 0) {\\n                dp[i][j] += j.toDouble() \/ total * (j - 1).toDouble() \/ (total - 1) * dp[i][j - 2]\\n            }\\n        }\\n    }\\n\\n    println(dp[w][b])\\n}","PHP":"<?php\\n\\nfunction princessProbability($w, $b) {\\n    \/\/ If there are no black mice, the princess wins\\n    if ($b == 0) {\\n        return 1.0;\\n    }\\n\\n    \/\/ If there are no white mice, the princess loses\\n    if ($w == 0) {\\n        return 0.0;\\n    }\\n\\n    \/\/ Calculate the probability of the princess winning\\n    $totalMice = $w + $b;\\n    $princessProb = 0.0;\\n\\n    \/\/ Calculate the probability of the princess drawing a white mouse on her first turn\\n    $princessProb += $w \/ $totalMice;\\n\\n    \/\/ Calculate the probability of the dragon drawing a black mouse on his first turn\\n    $dragonProb = $b \/ $totalMice;\\n\\n    \/\/ Calculate the probability of the princess drawing a white mouse on her second turn\\n    \/\/ after the dragon has drawn a black mouse\\n    $princessProb += ($w - 1) \/ ($totalMice - 1) * $dragonProb;\\n\\n    return $princessProb;\\n}\\n\\n\/\/ Read input from stdin\\n$input = trim(fgets(STDIN));\\nlist($w, $b) = explode(' ', $input);\\n\\n\/\/ Calculate and output the probability of the princess winning\\n$result = princessProbability($w, $b);\\necho number_format($result, 9, '.', '') . \\\"\\\\n\\\";\\n?>","d":"import std.stdio;\\r\\n\\r\\n\/\/ Function to calculate the probability of the princess winning\\r\\ndouble calculateProbability(int w, int b)\\r\\n{\\r\\n    \/\/ Base case: If there are no white mice left, princess loses\\r\\n    if (w == 0)\\r\\n        return 0;\\r\\n\\r\\n    \/\/ Base case: If there are no black mice left, princess wins\\r\\n    if (b == 0)\\r\\n        return 1;\\r\\n\\r\\n    \/\/ Calculate the probability of the princess winning on her first turn\\r\\n    double princessFirstTurn = double(w) \/ (w + b);\\r\\n\\r\\n    \/\/ Calculate the probability of the dragon not winning on his first turn\\r\\n    double dragonFirstTurn = double(b) \/ (w + b);\\r\\n\\r\\n    \/\/ Calculate the probability of the princess winning on her second turn\\r\\n    double princessSecondTurn = (double(w - 1) \/ (w + b - 1)) * (double(b) \/ (w + b - 2));\\r\\n\\r\\n    \/\/ Calculate the overall probability of the princess winning\\r\\n    double probability = princessFirstTurn + (dragonFirstTurn * princessSecondTurn);\\r\\n\\r\\n    return probability;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int w, b;\\r\\n    readf(\\\"%d %d\\\", &w, &b);\\r\\n\\r\\n    double probability = calculateProbability(w, b);\\r\\n\\r\\n    writefln(\\\"%.9f\\\", probability);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub princess_probability {\n    my ($w, $b) = @_;\n\n    # Base cases\n    if ($w == 0) {\n        return 0;\n    }\n    if ($b == 0) {\n        return 1;\n    }\n\n    # Calculate the probability recursively\n    my $total = $w + $b;\n    my $princess_prob = $w \/ $total; # Probability of princess drawing a white mouse\n    my $dragon_prob = $b \/ $total; # Probability of dragon drawing a black mouse\n\n    # Calculate the probability of princess winning on her first turn\n    my $prob = $princess_prob;\n\n    # Calculate the probability of princess winning after dragon's turn\n    $prob += $dragon_prob * (1 - princess_probability($w, $b - 1));\n\n    # Calculate the probability of princess winning after princess's turn\n    if ($b >= 2) {\n        $prob += $dragon_prob * ($b - 1) \/ ($total - 1) * (1 - princess_probability($w - 1, $b - 2));\n    }\n\n    return $prob;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($w, $b) = split ' ', $input;\n\n# Calculate and print the probability of the princess winning\nmy $probability = princess_probability($w, $b);\nprint $probability;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut iter = input.trim().split_whitespace();\\n    let w: f64 = iter.next().unwrap().parse().unwrap();\\n    let b: f64 = iter.next().unwrap().parse().unwrap();\\n\\n    let mut dp: Vec<Vec<f64>> = vec![vec![0.0; (b + 1) as usize]; (w + 1) as usize];\\n\\n    for i in 0..=w as usize {\\n        for j in 0..=b as usize {\\n            if i == 0 && j == 0 {\\n                continue;\\n            }\\n\\n            let mut p: f64 = 0.0;\\n\\n            if i > 0 {\\n                p += (i as f64) \/ ((i + j) as f64);\\n                if j > 0 {\\n                    p += (j as f64) \/ ((i + j) as f64) * ((j - 1) as f64) \/ ((i + j - 1) as f64) * dp[i - 1][j - 1];\\n                }\\n            }\\n\\n            if j > 0 {\\n                p += (j as f64) \/ ((i + j) as f64) * ((j - 1) as f64) \/ ((i + j - 1) as f64) * ((j - 2) as f64) \/ ((i + j - 2) as f64) * dp[i][j - 2];\\n            }\\n\\n            dp[i][j] = p;\\n        }\\n    }\\n\\n    println!(\\\"{:.9}\\\", dp[w as usize][b as usize]);\\n}"}
{"title":"A. Business trip","description":"What joy! Petya's parents went on a business trip for the whole year and the playful kid is left all by himself. Petya got absolutely happy. He jumped on the bed and threw pillows all day long, until... Today Petya opened the cupboard and found a scary note there. His parents had left him with duties: he should water their favourite flower all year, each day, in the morning, in the afternoon and in the evening. \"Wait a second!\" \u2014 thought Petya. He know for a fact that if he fulfills the parents' task in the i-th (1\u2264i\u226412) month of the year, then the flower will grow by ai centimeters, and if he doesn't water the flower in the i-th month, then the flower won't grow this month. Petya also knows that try as he might, his parents won't believe that he has been watering the flower if it grows strictly less than by k centimeters. Help Petya choose the minimum number of months when he will water the flower, given that the flower should grow no less than by k centimeters.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains exactly one integer k (0\u2264k\u2264100). The next line contains twelve space-separated integers: the i-th (1\u2264i\u226412) number in the line represents ai (0\u2264ai\u2264100). \n","output_spec":"Print the only integer \u2014 the minimum number of months when Petya has to water the flower so that the flower grows no less than by k centimeters. If the flower can't grow by k centimeters in a year, print -1.\n","notes":"Let's consider the first sample test. There it is enough to water the flower during the seventh and the ninth month. Then the flower grows by exactly five centimeters.\nIn the second sample Petya's parents will believe him even if the flower doesn't grow at all (k=0). So, it is possible for Petya not to water the flower at all.\n","sample_inputs":["5\n1 1 1 1 2 2 3 2 2 1 1 1\n","0\n0 0 0 0 0 0 0 1 1 2 3 0\n","11\n1 1 4 1 1 5 1 1 4 1 1 1\n"],"sample_outputs":["2\n","0\n","3\n"],"id":"149-A","difficulty":900,"tags":["greedy","implementation","sortings"],"src_uid":"59dfa7a4988375febc5dccc27aca90a8","C++":"#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int k;\n    std::cin >> k;\n    \n    std::vector<int> growth(12);\n    for (int i = 0; i < 12; i++) {\n        std::cin >> growth[i];\n    }\n    \n    std::sort(growth.begin(), growth.end(), std::greater<int>());\n    \n    int total_growth = 0;\n    int months = 0;\n    \n    for (int i = 0; i < 12; i++) {\n        if (total_growth >= k) {\n            break;\n        }\n        \n        total_growth += growth[i];\n        months++;\n    }\n    \n    if (total_growth < k) {\n        std::cout << -1 << std::endl;\n    } else {\n        std::cout << months << std::endl;\n    }\n    \n    return 0;\n}","Java":"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class FlowerWatering {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int k = scanner.nextInt();\n        scanner.nextLine();\n        int[] growths = Arrays.stream(scanner.nextLine().split(\\\" \\\")).mapToInt(Integer::parseInt).toArray();\n        \n        int[] sortedGrowths = Arrays.copyOf(growths, growths.length);\n        Arrays.sort(sortedGrowths);\n        \n        int totalGrowth = 0;\n        int months = 0;\n        \n        for (int i = 11; i >= 0; i--) {\n            totalGrowth += sortedGrowths[i];\n            months++;\n            \n            if (totalGrowth >= k) {\n                System.out.println(months);\n                return;\n            }\n        }\n        \n        System.out.println(-1);\n    }\n}","Python":"def minimum_months(k, a):\n    a.sort(reverse=True)\n    total = 0\n    months = 0\n    for i in range(12):\n        total += a[i]\n        months += 1\n        if total >= k:\n            return months\n    return -1\n\nk = int(input())\na = list(map(int, input().split()))\n\nresult = minimum_months(k, a)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int k;\\n    scanf(\\\"%d\\\", &k);\\n    int a[12];\\n    for (int i = 0; i < 12; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    \/\/ Sort the array in descending order\\n    for (int i = 0; i < 12; i++) {\\n        for (int j = i + 1; j < 12; j++) {\\n            if (a[i] < a[j]) {\\n                int temp = a[i];\\n                a[i] = a[j];\\n                a[j] = temp;\\n            }\\n        }\\n    }\\n\\n    int sum = 0;\\n    int months = 0;\\n\\n    for (int i = 0; i < 12; i++) {\\n        sum += a[i];\\n        months++;\\n        if (sum >= k) {\\n            break;\\n        }\\n    }\\n\\n    if (sum < k) {\\n        printf(\\\"-1\\\\n\\\");\\n    } else {\\n        printf(\\\"%d\\\\n\\\", months);\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int k = int.Parse(Console.ReadLine());\n        int[] a = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        \n        Array.Sort(a);\n        Array.Reverse(a);\n        \n        int sum = 0;\n        int months = 0;\n        \n        for (int i = 0; i < 12; i++)\n        {\n            sum += a[i];\n            months++;\n            \n            if (sum >= k)\n            {\n                Console.WriteLine(months);\n                return;\n            }\n        }\n        \n        Console.WriteLine(-1);\n    }\n}\n","Ruby":"\ndef minimum_months(k, a)\n  a.sort!.reverse!\n  sum = 0\n  months = 0\n\n  for i in 0..11\n    sum += a[i]\n    months += 1\n\n    if sum >= k\n      return months\n    end\n  end\n\n  return -1\nend\n\ninput = gets.chomp.split('\\n')\nk = input[0].to_i\na = input[1].split(' ').map(&:to_i)\n\nputs minimum_months(k, a)\n","delphi":"program WateringFlower;\\n\\nvar\\n  k: Integer;\\n  a: array[1..12] of Integer;\\n  i, sum, count: Integer;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(k);\\n  for i := 1 to 12 do\\n    Read(a[i]);\\n\\n  \/\/ Sort the array in descending order\\n  for i := 1 to 11 do\\n  begin\\n    for j := i + 1 to 12 do\\n    begin\\n      if a[i] < a[j] then\\n      begin\\n        temp := a[i];\\n        a[i] := a[j];\\n        a[j] := temp;\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Calculate the minimum number of months to water the flower\\n  sum := 0;\\n  count := 0;\\n  for i := 1 to 12 do\\n  begin\\n    sum := sum + a[i];\\n    count := count + 1;\\n    if sum >= k then\\n      Break;\\n  end;\\n\\n  \/\/ Print the result\\n  if sum >= k then\\n    WriteLn(count)\\n  else\\n    WriteLn(-1);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar k int\\n\\tfmt.Scan(&k)\\n\\n\\tnumbers := make([]int, 12)\\n\\tfor i := 0; i < 12; i++ {\\n\\t\\tfmt.Scan(&numbers[i])\\n\\t}\\n\\n\\t\/\/ Sort the numbers in descending order\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(numbers)))\\n\\n\\ttotal := 0\\n\\tmonths := 0\\n\\n\\tfor i := 0; i < 12; i++ {\\n\\t\\ttotal += numbers[i]\\n\\t\\tmonths++\\n\\n\\t\\tif total >= k {\\n\\t\\t\\tfmt.Println(months)\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(-1)\\n}","Javascript":"function minimumMonths(k, growths) {\n    growths.sort((a, b) => b - a); \/\/ Sort the growths in descending order\n    \n    let totalGrowth = 0;\n    let months = 0;\n    \n    for (let i = 0; i < growths.length; i++) {\n        totalGrowth += growths[i];\n        months++;\n        \n        if (totalGrowth >= k) {\n            return months;\n        }\n    }\n    \n    return -1; \/\/ If the flower can't grow by k centimeters in a year\n}\n\n\/\/ Test cases\nconsole.log(minimumMonths(5, [1, 1, 1, 1, 2, 2, 3, 2, 2, 1, 1, 1])); \/\/ Output: 2\nconsole.log(minimumMonths(0, [0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 0])); \/\/ Output: 0\nconsole.log(minimumMonths(11, [1, 1, 4, 1, 1, 5, 1, 1, 4, 1, 1, 1])); \/\/ Output: 3","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val k = sc.nextInt()\n    val a = IntArray(12)\n    for (i in 0 until 12) {\n        a[i] = sc.nextInt()\n    }\n    println(minimumMonthsToWaterFlower(k, a))\n}\n\nfun minimumMonthsToWaterFlower(k: Int, a: IntArray): Int {\n    val sortedA = a.sortedDescending()\n    var totalHeight = 0\n    var months = 0\n    for (i in 0 until 12) {\n        totalHeight += sortedA[i]\n        months++\n        if (totalHeight >= k) {\n            return months\n        }\n    }\n    return -1\n}","PHP":"\n<?php\n\nfunction minimumMonths($k, $a) {\n    \/\/ Sort the array in descending order\n    rsort($a);\n    \n    $total = 0;\n    $months = 0;\n    \n    foreach ($a as $growth) {\n        $total += $growth;\n        $months++;\n        \n        \/\/ Check if the total growth is greater than or equal to k\n        if ($total >= $k) {\n            return $months;\n        }\n    }\n    \n    return -1;\n}\n\n\/\/ Read input from stdin\n$input = explode('\\n', trim(fgets(STDIN)));\n\n$k = intval($input[0]);\n$a = array_map('intval', explode(' ', $input[1]));\n\n\/\/ Call the function and print the result\n$result = minimumMonths($k, $a);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int k;\\r\\n    int[12] a;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &k);\\r\\n    readf(\\\"%s\\\", &a);\\r\\n\\r\\n    \/\/ Sort the array in descending order\\r\\n    a.sort!((x, y) => x > y);\\r\\n\\r\\n    int sum = 0;\\r\\n    int months = 0;\\r\\n\\r\\n    \/\/ Calculate the minimum number of months to water the flower\\r\\n    foreach (ai; a)\\r\\n    {\\r\\n        sum += ai;\\r\\n        months++;\\r\\n\\r\\n        if (sum >= k)\\r\\n        {\\r\\n            writeln(months);\\r\\n            return;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ If the flower can't grow by k centimeters in a year, print -1\\r\\n    writeln(-1);\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub minimum_watering_months {\n    my ($k, @a) = @_;\n\n    my $total_growth = 0;\n    my $months = 0;\n\n    # Sort the growth rates in descending order\n    @a = sort { $b <=> $a } @a;\n\n    foreach my $growth (@a) {\n        $total_growth += $growth;\n        $months++;\n\n        # Check if the total growth is equal to or greater than k\n        if ($total_growth >= $k) {\n            return $months;\n        }\n    }\n\n    return -1;  # If the flower can't grow by k centimeters in a year\n}\n\n# Read input from STDIN\nmy $k = <STDIN>;\nchomp($k);\n\nmy $growth_rates = <STDIN>;\nchomp($growth_rates);\nmy @a = split(' ', $growth_rates);\n\n# Call the function and print the result\nmy $result = minimum_watering_months($k, @a);\nprint $result;\n","Rust":"\n\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let k: i32 = lines.next().unwrap().parse().unwrap();\n    let a: Vec<i32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut sorted_a = a.clone();\n    sorted_a.sort();\n    sorted_a.reverse();\n    \n    let mut sum = 0;\n    let mut months = 0;\n    \n    for i in 0..12 {\n        sum += sorted_a[i];\n        months += 1;\n        if sum >= k {\n            break;\n        }\n    }\n    \n    if sum < k {\n        println!(\"-1\");\n    } else {\n        println!(\"{}\", months);\n    }\n}\n"}
{"title":"B. Martian Clock","description":"Having stayed home alone, Petya decided to watch forbidden films on the Net in secret. \"What ungentlemanly behavior!\" \u2014 you can say that, of course, but don't be too harsh on the kid. In his country films about the Martians and other extraterrestrial civilizations are forbidden. It was very unfair to Petya as he adored adventure stories that featured lasers and robots. Today Petya is watching a shocking blockbuster about the Martians called \"R2:D2\". What can \"R2:D2\" possibly mean? It might be the Martian time represented in the Martian numeral system. Petya knows that time on Mars is counted just like on the Earth (that is, there are 24 hours and each hour has 60 minutes). The time is written as \"a:b\", where the string a stands for the number of hours (from 0 to 23 inclusive), and string b stands for the number of minutes (from 0 to 59 inclusive). The only thing Petya doesn't know is in what numeral system the Martian time is written.Your task is to print the radixes of all numeral system which can contain the time \"a:b\".","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single string as \"a:b\" (without the quotes). There a is a non-empty string, consisting of numbers and uppercase Latin letters. String a shows the number of hours. String b is a non-empty string that consists of numbers and uppercase Latin letters. String b shows the number of minutes. The lengths of strings a and b are from 1 to 5 characters, inclusive. Please note that strings a and b can have leading zeroes that do not influence the result in any way (for example, string \"008:1\" in decimal notation denotes correctly written time).\nWe consider characters 0, 1, ..., 9 as denoting the corresponding digits of the number's representation in some numeral system, and characters A, B, ..., Z correspond to numbers 10, 11, ..., 35.\n","output_spec":"Print the radixes of the numeral systems that can represent the time \"a:b\" in the increasing order. Separate the numbers with spaces or line breaks. If there is no numeral system that can represent time \"a:b\", print the single integer 0. If there are infinitely many numeral systems that can represent the time \"a:b\", print the single integer -1.\nNote that on Mars any positional numeral systems with positive radix strictly larger than one are possible.\n","notes":"Let's consider the first sample. String \"11:20\" can be perceived, for example, as time 4:6, represented in the ternary numeral system or as time 17:32 in hexadecimal system. \nLet's consider the second sample test. String \"2A:13\" can't be perceived as correct time in any notation. For example, let's take the base-11 numeral notation. There the given string represents time 32:14 that isn't a correct time.\nLet's consider the third sample. String \"000B:00001\" can be perceived as a correct time in the infinite number of numeral systems. If you need an example, you can take any numeral system with radix no less than 12.\n","sample_inputs":["11:20\n","2A:13\n","000B:00001\n"],"sample_outputs":["3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22","0\n","-1\n"],"id":"149-B","difficulty":1600,"tags":["implementation"],"src_uid":"c02dfe5b8d9da2818a99c3afbe7a5293","C++":"#include <iostream>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isValidTime(int hours, int minutes, int base) {\\n    return hours >= 0 && hours < base && minutes >= 0 && minutes < base;\\n}\\n\\nint main() {\\n    string time;\\n    cin >> time;\\n    \\n    int colonIndex = time.find(':');\\n    string hoursStr = time.substr(0, colonIndex);\\n    string minutesStr = time.substr(colonIndex + 1);\\n    \\n    int maxDigit = max(*max_element(hoursStr.begin(), hoursStr.end()), *max_element(minutesStr.begin(), minutesStr.end())) - '0';\\n    \\n    vector<int> radixes;\\n    \\n    for (int base = maxDigit + 1; base <= 36; base++) {\\n        int hours = stoi(hoursStr, nullptr, base);\\n        int minutes = stoi(minutesStr, nullptr, base);\\n        \\n        if (isValidTime(hours, minutes, base)) {\\n            radixes.push_back(base);\\n        }\\n    }\\n    \\n    if (radixes.empty()) {\\n        cout << \\\"0\\\" << endl;\\n    } else if (radixes.size() == 1) {\\n        cout << radixes[0] << endl;\\n    } else {\\n        for (int i = 0; i < radixes.size(); i++) {\\n            cout << radixes[i];\\n            if (i != radixes.size() - 1) {\\n                cout << \\\" \\\";\\n            }\\n        }\\n        cout << endl;\\n    }\\n    \\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class MartianTime {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String time = scanner.nextLine();\\n        scanner.close();\\n\\n        String[] parts = time.split(\\\":\\\");\\n        String hours = parts[0];\\n        String minutes = parts[1];\\n\\n        List<Integer> radixes = new ArrayList<>();\\n\\n        for (int radix = 2; radix <= 36; radix++) {\\n            try {\\n                int hourValue = Integer.parseInt(hours, radix);\\n                int minuteValue = Integer.parseInt(minutes, radix);\\n\\n                if (hourValue >= 0 && hourValue <= 23 && minuteValue >= 0 && minuteValue <= 59) {\\n                    radixes.add(radix);\\n                }\\n            } catch (NumberFormatException e) {\\n                \/\/ Ignore invalid radix\\n            }\\n        }\\n\\n        if (radixes.isEmpty()) {\\n            System.out.println(\\\"0\\\");\\n        } else if (radixes.size() == 15) {\\n            System.out.println(\\\"-1\\\");\\n        } else {\\n            StringBuilder output = new StringBuilder();\\n            for (int radix : radixes) {\\n                output.append(radix).append(\\\" \\\");\\n            }\\n            System.out.println(output.toString().trim());\\n        }\\n    }\\n}\"}}","Python":"def get_radixes(time):\n    a, b = time.split(':')\n    max_a = max([int(x, 36) for x in a])\n    max_b = max([int(x, 36) for x in b])\n    radixes = []\n    \n    for radix in range(max(max_a, max_b) + 1, 37):\n        try:\n            int(a, radix)\n            int(b, radix)\n            radixes.append(radix)\n        except ValueError:\n            continue\n    \n    if len(radixes) == 0:\n        return '0'\n    elif len(radixes) == 1:\n        return str(radixes[0])\n    else:\n        return '-1'\n\ntime = input().strip()\nprint(get_radixes(time))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint is_valid_time(char* time, int radix) {\\n    int hours = strtol(time, NULL, radix);\\n    int minutes = strtol(time + 3, NULL, radix);\\n    return (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59);\\n}\\n\\nint main() {\\n    char time[10];\\n    scanf(\\\"%s\\\", time);\\n    int len = strlen(time);\\n    int max_radix = 36;\\n    int valid_radixes[max_radix];\\n    int count = 0;\\n\\n    for (int radix = 2; radix <= max_radix; radix++) {\\n        if (is_valid_time(time, radix)) {\\n            valid_radixes[count] = radix;\\n            count++;\\n        }\\n    }\\n\\n    if (count == 0) {\\n        printf(\\\"0\\\\n\\\");\\n    } else if (count == max_radix - 1) {\\n        printf(\\\"-1\\\\n\\\");\\n    } else {\\n        for (int i = 0; i < count; i++) {\\n            printf(\\\"%d \\\", valid_radixes[i]);\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace MartianTime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string time = Console.ReadLine();\n            string[] parts = time.Split(':');\n            string hours = parts[0];\n            string minutes = parts[1];\n\n            List<int> radixes = new List<int>();\n\n            for (int i = 2; i <= 36; i++)\n            {\n                bool valid = true;\n\n                foreach (char c in hours)\n                {\n                    if (!IsValidDigit(c, i))\n                    {\n                        valid = false;\n                        break;\n                    }\n                }\n\n                if (valid)\n                {\n                    foreach (char c in minutes)\n                    {\n                        if (!IsValidDigit(c, i))\n                        {\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (valid)\n                {\n                    radixes.Add(i);\n                }\n            }\n\n            if (radixes.Count == 0)\n            {\n                Console.WriteLine(0);\n            }\n            else if (radixes.Count == 1)\n            {\n                Console.WriteLine(radixes[0]);\n            }\n            else\n            {\n                Console.WriteLine(-1);\n            }\n        }\n\n        static bool IsValidDigit(char c, int radix)\n        {\n            if (char.IsDigit(c))\n            {\n                int digit = int.Parse(c.ToString());\n                return digit < radix;\n            }\n            else\n            {\n                int digit = char.ToUpper(c) - 'A' + 10;\n                return digit < radix;\n            }\n        }\n    }\n}","Ruby":"\ndef valid_time(time)\n  hours, minutes = time.split(':')\n  valid_radixes = []\n\n  (2..36).each do |radix|\n    begin\n      hours_decimal = hours.to_i(radix)\n      minutes_decimal = minutes.to_i(radix)\n\n      if hours_decimal >= 0 && hours_decimal <= 23 && minutes_decimal >= 0 && minutes_decimal <= 59\n        valid_radixes << radix\n      end\n    rescue ArgumentError\n      next\n    end\n  end\n\n  if valid_radixes.empty?\n    return '0'\n  elsif valid_radixes.length == 35\n    return '-1'\n  else\n    return valid_radixes.join(' ')\n  end\nend\n\ninput = gets.chomp\noutput = valid_time(input)\nputs output\n","delphi":"program MartianTime;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction IsValidTime(time: string; radix: Integer): Boolean;\nvar\n  hours, minutes: Integer;\nbegin\n  \/\/ Split the time string into hours and minutes\n  hours := StrToInt(Copy(time, 1, Pos(':', time) - 1));\n  minutes := StrToInt(Copy(time, Pos(':', time) + 1, Length(time) - Pos(':', time)));\n\n  \/\/ Check if the hours and minutes are within the valid range\n  Result := (hours >= 0) and (hours <= 23) and (minutes >= 0) and (minutes <= 59);\n\n  \/\/ Check if the time is valid in the given radix\n  if Result then\n    Result := (hours < radix) and (minutes < radix);\nend;\n\nfunction GetRadixes(time: string): string;\nvar\n  radix: Integer;\n  resultRadixes: string;\nbegin\n  resultRadixes := '';\n\n  \/\/ Iterate through all possible radices from 2 to 36\n  for radix := 2 to 36 do\n  begin\n    \/\/ Check if the time is valid in the current radix\n    if IsValidTime(time, radix) then\n    begin\n      \/\/ Add the radix to the result string\n      if resultRadixes <> '' then\n        resultRadixes := resultRadixes + ' ';\n      resultRadixes := resultRadixes + IntToStr(radix);\n    end;\n  end;\n\n  \/\/ Check if any valid radixes were found\n  if resultRadixes = '' then\n    resultRadixes := '0';\n\n  Result := resultRadixes;\nend;\n\nvar\n  time: string;\nbegin\n  \/\/ Read the input time\n  ReadLn(time);\n\n  \/\/ Get the radixes for the given time\n  WriteLn(GetRadixes(time));\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar time string\\n\\tfmt.Scan(&time)\\n\\n\\ta, _ := strconv.ParseInt(time[:len(time)-3], 36, 64)\\n\\tb, _ := strconv.ParseInt(time[len(time)-2:], 36, 64)\\n\\n\\tradixes := []int{}\\n\\n\\tfor i := 2; i <= 36; i++ {\\n\\t\\tif a < int64(i) && b < int64(i) {\\n\\t\\t\\tradixes = append(radixes, i)\\n\\t\\t}\\n\\t}\\n\\n\\tif len(radixes) == 0 {\\n\\t\\tfmt.Println(0)\\n\\t} else if len(radixes) == 35 {\\n\\t\\tfmt.Println(-1)\\n\\t} else {\\n\\t\\tfor _, radix := range radixes {\\n\\t\\t\\tfmt.Printf(\\\"%d \\\", radix)\\n\\t\\t}\\n\\t}\\n}","Javascript":"\nfunction getRadixes(time) {\n  const [hours, minutes] = time.split(':');\n  const maxHours = Math.max(...hours.split('').map(char => isNaN(char) ? char.charCodeAt(0) - 55 : parseInt(char)));\n  const maxMinutes = Math.max(...minutes.split('').map(char => isNaN(char) ? char.charCodeAt(0) - 55 : parseInt(char)));\n  const radixes = [];\n  \n  for (let radix = maxHours + 1; radix <= 36; radix++) {\n    const convertedHours = parseInt(hours, radix);\n    if (convertedHours >= 0 && convertedHours <= 23) {\n      radixes.push(radix);\n    }\n  }\n  \n  for (let radix = maxMinutes + 1; radix <= 36; radix++) {\n    const convertedMinutes = parseInt(minutes, radix);\n    if (convertedMinutes >= 0 && convertedMinutes <= 59) {\n      radixes.push(radix);\n    }\n  }\n  \n  radixes.sort((a, b) => a - b);\n  \n  if (radixes.length === 0) {\n    return '0';\n  } else if (radixes.length === 36) {\n    return '-1';\n  } else {\n    return radixes.join(' ');\n  }\n}\n\nconst input = '11:20';\nconst output = getRadixes(input);\nconsole.log(output);\n","Kotlin":"\"\"\nimport java.util.*\n\nfun main() {\n    val input = readLine()!!\n    val time = input.split(\":\")\n    val hours = time[0]\n    val minutes = time[1]\n\n    val radixes = mutableListOf<Int>()\n\n    for (radix in 2..36) {\n        val validTime = isValidTime(hours, minutes, radix)\n        if (validTime) {\n            radixes.add(radix)\n        }\n    }\n\n    if (radixes.isEmpty()) {\n        println(\"0\")\n    } else if (radixes.size == 35) {\n        println(\"-1\")\n    } else {\n        println(radixes.joinToString(\" \"))\n    }\n}\n\nfun isValidTime(hours: String, minutes: String, radix: Int): Boolean {\n    val hoursValue = hours.toIntOrNull(radix)\n    val minutesValue = minutes.toIntOrNull(radix)\n\n    return hoursValue != null && hoursValue in 0..23 && minutesValue != null && minutesValue in 0..59\n}\n\"\"","PHP":"<?php\\n\\nfunction getRadixes($time) {\\n    $a = substr($time, 0, strpos($time, ':'));\\n    $b = substr($time, strpos($time, ':') + 1);\\n    $max_a = max(array_map('hexdec', str_split($a)));\\n    $max_b = max(array_map('hexdec', str_split($b)));\\n    $radixes = [];\\n\\n    for ($radix = $max_a + 1; $radix <= 36; $radix++) {\\n        $hours = base_convert($a, $radix, 10);\\n        $minutes = base_convert($b, $radix, 10);\\n\\n        if ($hours >= 0 && $hours <= 23 && $minutes >= 0 && $minutes <= 59) {\\n            $radixes[] = $radix;\\n        }\\n    }\\n\\n    if (empty($radixes)) {\\n        return '0';\\n    } elseif (count($radixes) == 36 - $max_a) {\\n        return '-1';\\n    } else {\\n        return implode(' ', $radixes);\\n    }\\n}\\n\\n$inputs = ['11:20', '2A:13', '000B:00001'];\\n$outputs = [];\\n\\nforeach ($inputs as $input) {\\n    $radixes = getRadixes($input);\\n    $outputs[] = $radixes;\\n}\\n\\n$json = json_encode($outputs);\\necho $json;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nstring[] getRadixes(string time)\\r\\n{\\r\\n    string[] radixes;\\r\\n    int hours = 0;\\r\\n    int minutes = 0;\\r\\n\\r\\n    \/\/ Split the time string into hours and minutes\\r\\n    auto colonIndex = time.indexOf(\\\":\\\");\\r\\n    string hoursStr = time[0..colonIndex];\\r\\n    string minutesStr = time[colonIndex + 1..$];\\r\\n\\r\\n    \/\/ Convert hours and minutes to integers\\r\\n    hours = to!int(hoursStr);\\r\\n    minutes = to!int(minutesStr);\\r\\n\\r\\n    \/\/ Loop through all possible radixes from 2 to 36\\r\\n    for (int radix = 2; radix <= 36; radix++)\\r\\n    {\\r\\n        \/\/ Convert hours and minutes to the current radix\\r\\n        string hoursRadix = hours.toRadix(radix);\\r\\n        string minutesRadix = minutes.toRadix(radix);\\r\\n\\r\\n        \/\/ Check if the converted hours and minutes match the original time\\r\\n        if (hoursRadix == hoursStr && minutesRadix == minutesStr)\\r\\n        {\\r\\n            \/\/ Add the current radix to the list of valid radixes\\r\\n            radixes ~= to!string(radix);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Check if there are any valid radixes\\r\\n    if (radixes.length == 0)\\r\\n    {\\r\\n        \/\/ If there are no valid radixes, return 0\\r\\n        return [\\\"0\\\"];\\r\\n    }\\r\\n    else if (radixes.length == 35)\\r\\n    {\\r\\n        \/\/ If there are 35 valid radixes, return -1\\r\\n        return [\\\"-1\\\"];\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        \/\/ Otherwise, return the list of valid radixes\\r\\n        return radixes;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    \/\/ Read the input time from the user\\r\\n    string time = readln();\\r\\n\\r\\n    \/\/ Get the list of valid radixes for the input time\\r\\n    string[] validRadixes = getRadixes(time);\\r\\n\\r\\n    \/\/ Print the list of valid radixes\\r\\n    foreach (string radix in validRadixes)\\r\\n    {\\r\\n        writeln(radix);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub get_radixes {\n    my ($time) = @_;\n    my ($hours, $minutes) = split(':', $time);\n    \n    my @radixes;\n    \n    for my $radix (2..36) {\n        my $hours_decimal = convert_to_decimal($hours, $radix);\n        my $minutes_decimal = convert_to_decimal($minutes, $radix);\n        \n        if ($hours_decimal >= 0 && $hours_decimal <= 23 && $minutes_decimal >= 0 && $minutes_decimal <= 59) {\n            push @radixes, $radix;\n        }\n    }\n    \n    return @radixes;\n}\n\nsub convert_to_decimal {\n    my ($number, $radix) = @_;\n    \n    my $decimal = 0;\n    my $power = 0;\n    \n    for my $digit (reverse split('', $number)) {\n        my $value = ord($digit) - ord('0');\n        if ($value > 9) {\n            $value = ord($digit) - ord('A') + 10;\n        }\n        \n        $decimal += $value * ($radix ** $power);\n        $power++;\n    }\n    \n    return $decimal;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\n\n# Get radixes\nmy @radixes = get_radixes($input);\n\n# Print output\nif (@radixes) {\n    print join(' ', @radixes);\n} else {\n    print '0';\n}\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let input = input.trim();\n    let parts: Vec<&str> = input.split(':').collect();\n    let hours = parts[0];\n    let minutes = parts[1];\n    \n    let mut radixes: Vec<u32> = Vec::new();\n    \n    for radix in 2..=36 {\n        if is_valid_time(hours, radix) && is_valid_time(minutes, radix) {\n            radixes.push(radix);\n        }\n    }\n    \n    if radixes.is_empty() {\n        println!(\"0\");\n    } else if radixes.len() == 35 {\n        println!(\"-1\");\n    } else {\n        let output = radixes.iter().map(|&r| r.to_string()).collect::<Vec<String>>().join(\" \");\n        println!(\"{}\", output);\n    }\n}\n\nfn is_valid_time(time: &str, radix: u32) -> bool {\n    let mut total = 0;\n    let mut power = 1;\n    \n    for c in time.chars().rev() {\n        let digit = match c {\n            '0'..='9' => c as u32 - '0' as u32,\n            'A'..='Z' => c as u32 - 'A' as u32 + 10,\n            _ => panic!(\"Invalid character\"),\n        };\n        \n        if digit >= radix {\n            return false;\n        }\n        \n        total += digit * power;\n        power *= radix;\n    }\n    \n    total < 24\n}"}
{"title":"D. Coloring Brackets","description":"Once Petya read a problem about a bracket sequence. He gave it much thought but didn't find a solution. Today you will face it.You are given string s. It represents a correct bracket sequence. A correct bracket sequence is the sequence of opening (\"(\") and closing (\")\") brackets, such that it is possible to obtain a correct mathematical expression from it, inserting numbers and operators between the brackets. For example, such sequences as \"(())()\" and \"()\" are correct bracket sequences and such sequences as \")()\" and \"(()\" are not.In a correct bracket sequence each bracket corresponds to the matching bracket (an opening bracket corresponds to the matching closing bracket and vice versa). For example, in a bracket sequence shown of the figure below, the third bracket corresponds to the matching sixth one and the fifth bracket corresponds to the fourth one.  You are allowed to color some brackets in the bracket sequence so as all three conditions are fulfilled:   Each bracket is either not colored any color, or is colored red, or is colored blue.  For any pair of matching brackets exactly one of them is colored. In other words, for any bracket the following is true: either it or the matching bracket that corresponds to it is colored.  No two neighboring colored brackets have the same color. Find the number of different ways to color the bracket sequence. The ways should meet the above-given conditions. Two ways of coloring are considered different if they differ in the color of at least one bracket. As the result can be quite large, print it modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains the single string s (2\u2264|s|\u2264700) which represents a correct bracket sequence. \n","output_spec":"Print the only number \u2014 the number of ways to color the bracket sequence that meet the above given conditions modulo 1000000007 (10^9+7).\n","notes":"Let's consider the first sample test. The bracket sequence from the sample can be colored, for example, as is shown on two figures below. \n  \n The two ways of coloring shown below are incorrect. \n  \n ","sample_inputs":["(())\n","(()())\n","()\n"],"sample_outputs":["12\n","40\n","4\n"],"id":"149-D","difficulty":1900,"tags":["dp"],"src_uid":"e05ef33935d04bd3714269268aceda41","C++":"#include <iostream>\\n#include <vector>\\n#include <stack>\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    string s;\\n    cin >> s;\\n    int n = s.size();\\n    vector<vector<long long>> dp(n, vector<long long>(n, 0));\\n    stack<int> st;\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == '(') {\\n            st.push(i);\\n        } else {\\n            int j = st.top();\\n            st.pop();\\n            for (int k = j; k <= i; k++) {\\n                if (k == j || k == i) {\\n                    dp[j][i] += dp[j + 1][i - 1];\\n                } else {\\n                    dp[j][i] += dp[j][k] * dp[k + 1][i];\\n                }\\n                dp[j][i] %= MOD;\\n            }\\n        }\\n    }\\n    cout << dp[0][n - 1] << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class BracketSequence {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String s = scanner.nextLine();\\n        int n = s.length();\\n        int[][][] dp = new int[n + 1][n + 1][3];\\n        dp[0][0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                for (int k = 0; k < 3; k++) {\\n                    if (s.charAt(i - 1) == '(') {\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                        if (j > 0) {\\n                            dp[i][j][k] += dp[i - 1][j - 1][(k + 1) % 3];\\n                            dp[i][j][k] %= 1000000007;\\n                        }\\n                    } else {\\n                        dp[i][j][k] = dp[i - 1][j][k];\\n                        if (j > 0) {\\n                            dp[i][j][k] += dp[i - 1][j - 1][(k + 2) % 3];\\n                            dp[i][j][k] %= 1000000007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int result = (dp[n][n \/ 2][0] + dp[n][n \/ 2][1] + dp[n][n \/ 2][2]) % 1000000007;\\n        System.out.println(result);\\n    }\\n}","Python":"def count_coloring(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    mod = 1000000007\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            if s[i - 1] == '(':\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod\n                if j < i:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod\n            else:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod\n\n    return str(dp[n][0])\n\n# Sample Inputs\ninputs = ['(())\\n', '(()())\\n', '()\\n']\noutputs = ['12\\n', '40\\n', '4\\n']\n\n# Check sample test cases\nfor i, input_str in enumerate(inputs):\n    input_str = input_str.strip()\n    expected_output = outputs[i].strip()\n    assert count_coloring(input_str) == expected_output\n\nprint('All sample test cases pass')","C":"#include <stdio.h>\\n#include <string.h>\\n#define MOD 1000000007\\n\\nint main()\\n{\\n    char s[701];\\n    scanf(\\\"%s\\\", s);\\n    int n = strlen(s);\\n    int dp[n+1][n+1][3][3];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0][0][0][0] = 1;\\n    for(int i=0; i<n; i++)\\n    {\\n        for(int j=0; j<=i; j++)\\n        {\\n            for(int k=0; k<3; k++)\\n            {\\n                for(int l=0; l<3; l++)\\n                {\\n                    if(s[i] == '(')\\n                    {\\n                        if(k == 0)\\n                        {\\n                            dp[i+1][j+1][1][l] = (dp[i+1][j+1][1][l] + dp[i][j][k][l]) % MOD;\\n                            dp[i+1][j][2][l] = (dp[i+1][j][2][l] + dp[i][j][k][l]) % MOD;\\n                        }\\n                        if(l == 0)\\n                        {\\n                            dp[i+1][j+1][k][1] = (dp[i+1][j+1][k][1] + dp[i][j][k][l]) % MOD;\\n                            dp[i+1][j][k][2] = (dp[i+1][j][k][2] + dp[i][j][k][l]) % MOD;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(k == 0)\\n                        {\\n                            dp[i+1][j+1][1][l] = (dp[i+1][j+1][1][l] + dp[i][j][k][l]) % MOD;\\n                            dp[i+1][j][2][l] = (dp[i+1][j][2][l] + dp[i][j][k][l]) % MOD;\\n                        }\\n                        if(l == 0)\\n                        {\\n                            dp[i+1][j+1][k][1] = (dp[i+1][j+1][k][1] + dp[i][j][k][l]) % MOD;\\n                            dp[i+1][j][k][2] = (dp[i+1][j][k][2] + dp[i][j][k][l]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int ans = 0;\\n    for(int i=0; i<=n; i++)\\n    {\\n        for(int j=0; j<3; j++)\\n        {\\n            for(int k=0; k<3; k++)\\n            {\\n                ans = (ans + dp[n][i][j][k]) % MOD;\\n            }\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", ans);\\n    return 0;\\n}","C#":"\nusing System;\n\npublic class BracketColoring\n{\n    static int MOD = 1000000007;\n    \n    public static void Main(string[] args)\n    {\n        string s = Console.ReadLine().Trim();\n        int n = s.Length;\n        \n        \/\/ Initialize the DP array\n        long[,] dp = new long[n + 1, n + 1];\n        dp[0, 0] = 1;\n        \n        \/\/ Calculate the number of ways to color the bracket sequence\n        for (int i = 1; i <= n; i++)\n        {\n            for (int j = 0; j <= i; j++)\n            {\n                if (s[i - 1] == '(')\n                {\n                    \/\/ If the current bracket is an opening bracket, we have two choices:\n                    \/\/ 1. Color it red and match it with a closing bracket\n                    \/\/ 2. Color it blue and match it with a closing bracket\n                    dp[i, j] = (dp[i, j] + dp[i - 1, j - 1]) % MOD;\n                    dp[i, j] = (dp[i, j] + dp[i - 1, j + 1]) % MOD;\n                }\n                else\n                {\n                    \/\/ If the current bracket is a closing bracket, we have two choices:\n                    \/\/ 1. Match it with a colored opening bracket\n                    \/\/ 2. Match it with an uncolored opening bracket\n                    dp[i, j] = (dp[i, j] + dp[i - 1, j + 1]) % MOD;\n                    if (j > 0)\n                    {\n                        dp[i, j] = (dp[i, j] + dp[i - 1, j - 1]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        \/\/ Print the result\n        Console.WriteLine(dp[n, 0]);\n    }\n}\n","Ruby":"\nMOD = 1000000007\n\ndef count_ways(s)\n  n = s.length\n  dp = Array.new(n+1) { Array.new(n+1) { Array.new(3, 0) } }\n  \n  # Base case: if there are no brackets, there is only one way to color it\n  dp[0][0][0] = 1\n  \n  # Iterate through each character in the string\n  (1..n).each do |i|\n    # Iterate through each possible number of opening brackets\n    (0..i).each do |j|\n      # Iterate through each possible color for the last bracket\n      (0..2).each do |k|\n        # If the current character is an opening bracket\n        if s[i-1] == '('\n          # If the last bracket is not colored\n          if k == 0\n            # Add the number of ways to color the previous brackets without coloring the last bracket\n            dp[i][j][1] = (dp[i][j][1] + dp[i-1][j][k]) % MOD\n            # Add the number of ways to color the previous brackets with coloring the last bracket red\n            dp[i][j][2] = (dp[i][j][2] + dp[i-1][j][k]) % MOD\n          end\n          # If the last bracket is colored red\n          if k == 1\n            # Add the number of ways to color the previous brackets without coloring the last bracket\n            dp[i][j][1] = (dp[i][j][1] + dp[i-1][j][k]) % MOD\n            # Add the number of ways to color the previous brackets with coloring the last bracket blue\n            dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % MOD\n          end\n          # If the last bracket is colored blue\n          if k == 2\n            # Add the number of ways to color the previous brackets without coloring the last bracket\n            dp[i][j][2] = (dp[i][j][2] + dp[i-1][j][k]) % MOD\n            # Add the number of ways to color the previous brackets with coloring the last bracket red\n            dp[i][j][0] = (dp[i][j][0] + dp[i-1][j][k]) % MOD\n          end\n        end\n        \n        # If the current character is a closing bracket\n        if s[i-1] == ')'\n          # If the last bracket is not colored\n          if k == 0\n            # Add the number of ways to color the previous brackets without coloring the last bracket\n            dp[i][j][0] = (dp[i][j][0] + dp[i-1][j-1][k]) % MOD\n            # Add the number of ways to color the previous brackets with coloring the last bracket red\n            dp[i][j][2] = (dp[i][j][2] + dp[i-1][j-1][k]) % MOD\n          end\n          # If the last bracket is colored red\n          if k == 1\n            # Add the number of ways to color the previous brackets without coloring the last bracket\n            dp[i][j][0] = (dp[i][j][0] + dp[i-1][j-1][k]) % MOD\n            # Add the number of ways to color the previous brackets with coloring the last bracket blue\n            dp[i][j][1] = (dp[i][j][1] + dp[i-1][j-1][k]) % MOD\n          end\n          # If the last bracket is colored blue\n          if k == 2\n            # Add the number of ways to color the previous brackets without coloring the last bracket\n            dp[i][j][1] = (dp[i][j][1] + dp[i-1][j-1][k]) % MOD\n            # Add the number of ways to color the previous brackets with coloring the last bracket red\n            dp[i][j][2] = (dp[i][j][2] + dp[i-1][j-1][k]) % MOD\n          end\n        end\n      end\n    end\n  end\n  \n  # Return the total number of ways to color the bracket sequence\n  (dp[n][n\/2][0] + dp[n][n\/2][1] + dp[n][n\/2][2]) % MOD\nend\n\ns = gets.chomp\nputs count_ways(s)\n","delphi":"program BracketSequence;\n\nconst\n  MODULO = 1000000007;\n\nvar\n  s: string;\n\nfunction CountWays(s: string): Int64;\nvar\n  n, i: Integer;\n  dp: array of array of array of Int64;\nbegin\n  n := Length(s);\n  \n  \/\/ Initialize the dynamic programming array\n  SetLength(dp, n + 1, n + 1, 3);\n  \n  \/\/ Base case: an empty string has 1 way to color\n  dp[0][0][0] := 1;\n  \n  for i := 1 to n do\n  begin\n    if s[i] = '(' then\n    begin\n      \/\/ If the current bracket is an opening bracket, we have 3 choices:\n      \/\/ 1. Color it red and its matching closing bracket blue\n      \/\/ 2. Color it blue and its matching closing bracket red\n      \/\/ 3. Don't color it or its matching closing bracket\n      dp[i][i][1] := (dp[i][i][1] + dp[i-1][i-1][0] + dp[i-1][i-1][2]) mod MODULO;\n      dp[i][i][2] := (dp[i][i][2] + dp[i-1][i-1][0] + dp[i-1][i-1][1]) mod MODULO;\n      dp[i][i][0] := (dp[i][i][0] + dp[i-1][i-1][0] + dp[i-1][i-1][1] + dp[i-1][i-1][2]) mod MODULO;\n    end\n    else\n    begin\n      \/\/ If the current bracket is a closing bracket, we have 2 choices:\n      \/\/ 1. Color it red and its matching opening bracket blue\n      \/\/ 2. Color it blue and its matching opening bracket red\n      dp[i][i][1] := (dp[i][i][1] + dp[i-1][i-1][0] + dp[i-1][i-1][2]) mod MODULO;\n      dp[i][i][2] := (dp[i][i][2] + dp[i-1][i-1][0] + dp[i-1][i-1][1]) mod MODULO;\n      \n      \/\/ Consider the previous opening bracket\n      if i > 1 then\n      begin\n        \/\/ If the previous opening bracket is colored, we can color the current closing bracket\n        \/\/ with the opposite color\n        dp[i][i][1] := (dp[i][i][1] + dp[i-1][i-2][2]) mod MODULO;\n        dp[i][i][2] := (dp[i][i][2] + dp[i-1][i-2][1]) mod MODULO;\n      end;\n    end;\n    \n    \/\/ Consider all previous brackets\n    for j := i - 1 downto 1 do\n    begin\n      if s[j] = '(' then\n      begin\n        \/\/ If the current bracket is an opening bracket, we have 3 choices:\n        \/\/ 1. Color it red and its matching closing bracket blue\n        \/\/ 2. Color it blue and its matching closing bracket red\n        \/\/ 3. Don't color it or its matching closing bracket\n        dp[i][j][1] := (dp[i][j][1] + dp[i-1][j][0] + dp[i-1][j][2]) mod MODULO;\n        dp[i][j][2] := (dp[i][j][2] + dp[i-1][j][0] + dp[i-1][j][1]) mod MODULO;\n        dp[i][j][0] := (dp[i][j][0] + dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][2]) mod MODULO;\n      end\n      else\n      begin\n        \/\/ If the current bracket is a closing bracket, we have 2 choices:\n        \/\/ 1. Color it red and its matching opening bracket blue\n        \/\/ 2. Color it blue and its matching opening bracket red\n        dp[i][j][1] := (dp[i][j][1] + dp[i-1][j][0] + dp[i-1][j][2]) mod MODULO;\n        dp[i][j][2] := (dp[i][j][2] + dp[i-1][j][0] + dp[i-1][j][1]) mod MODULO;\n        \n        \/\/ Consider the previous opening bracket\n        if j > 1 then\n        begin\n          \/\/ If the previous opening bracket is colored, we can color the current closing bracket\n          \/\/ with the opposite color\n          dp[i][j][1] := (dp[i][j][1] + dp[i-1][j-1][2]) mod MODULO;\n          dp[i][j][2] := (dp[i][j][2] + dp[i-1][j-1][1]) mod MODULO;\n        end;\n      end;\n    end;\n  end;\n  \n  \/\/ Return the total number of ways to color the bracket sequence\n  Result := (dp[n][1][0] + dp[n][1][1] + dp[n][1][2]) mod MODULO;\nend;\n\nbegin\n  \/\/ Read the input string\n  ReadLn(s);\n  \n  \/\/ Calculate the number of ways to color the bracket sequence\n  WriteLn(CountWays(s));\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"bufio\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nconst mod = 1000000007\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\ts := scanner.Text()\\n\\n\\tn := len(s)\\n\\n\\t\/\/ Create a 2D array to store the number of ways to color the bracket sequence\\n\\t\/\/ dp[i][j][k] represents the number of ways to color the substring s[i:j+1] with the last colored bracket being k\\n\\tdp := make([][][]int, n)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([][]int, n)\\n\\t\\tfor j := range dp[i] {\\n\\t\\t\\tdp[i][j] = make([]int, 3)\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Initialize the base cases\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif s[i] == '(' {\\n\\t\\t\\tdp[i][i][0] = 1\\n\\t\\t} else if s[i] == ')' {\\n\\t\\t\\tdp[i][i][1] = 1\\n\\t\\t} else {\\n\\t\\t\\tdp[i][i][2] = 1\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Iterate over all possible substrings\\n\\tfor l := 2; l <= n; l++ {\\n\\t\\tfor i := 0; i <= n-l; i++ {\\n\\t\\t\\tj := i + l - 1\\n\\n\\t\\t\\t\/\/ Calculate the number of ways to color the substring s[i:j+1]\\n\\t\\t\\tfor k := i; k < j; k++ {\\n\\t\\t\\t\\t\/\/ Case 1: Color the brackets at positions i and k+1\\n\\t\\t\\t\\tdp[i][j][0] = (dp[i][j][0] + dp[i+1][k][1]*dp[k+2][j][2]) % mod\\n\\t\\t\\t\\tdp[i][j][0] = (dp[i][j][0] + dp[i+1][k][2]*dp[k+2][j][1]) % mod\\n\\n\\t\\t\\t\\t\/\/ Case 2: Color the brackets at positions k and j\\n\\t\\t\\t\\tdp[i][j][1] = (dp[i][j][1] + dp[i][k][0]*dp[k+1][j-1][2]) % mod\\n\\t\\t\\t\\tdp[i][j][1] = (dp[i][j][1] + dp[i][k][2]*dp[k+1][j-1][0]) % mod\\n\\n\\t\\t\\t\\t\/\/ Case 3: Color the brackets at positions i and j\\n\\t\\t\\t\\tdp[i][j][2] = (dp[i][j][2] + dp[i+1][k][0]*dp[k+1][j][1]) % mod\\n\\t\\t\\t\\tdp[i][j][2] = (dp[i][j][2] + dp[i+1][k][1]*dp[k+1][j][0]) % mod\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ The final answer is the number of ways to color the entire bracket sequence\\n\\tans := (dp[0][n-1][0] + dp[0][n-1][1] + dp[0][n-1][2]) % mod\\n\\n\\t\/\/ Print the answer\\n\\tfmt.Println(ans)\\n}","Javascript":"\nconst MOD = 1000000007;\n\nfunction countWaysToColorBracketSequence(s) {\n  let n = s.length;\n  let dp = new Array(n + 1).fill(0);\n  let open = new Array(n + 1).fill(0);\n  let close = new Array(n + 1).fill(0);\n  \n  dp[0] = 1;\n  open[0] = 1;\n  \n  for (let i = 1; i <= n; i++) {\n    if (s[i - 1] === '(') {\n      open[i] = open[i - 1] + 1;\n      close[i] = close[i - 1];\n    } else {\n      open[i] = open[i - 1];\n      close[i] = close[i - 1] + 1;\n    }\n    \n    dp[i] = dp[i - 1];\n    \n    if (s[i - 1] === ')') {\n      dp[i] = (dp[i] + dp[i - 1]) % MOD;\n    } else if (open[i] > close[i]) {\n      dp[i] = (dp[i] + dp[i - 1]) % MOD;\n    }\n  }\n  \n  return dp[n];\n}\n\nlet input = '(())';\nlet output = countWaysToColorBracketSequence(input);\nconsole.log(output);\n","Kotlin":"import java.util.*\n\nfun main() {\n    val mod = 1000000007\n    val sc = Scanner(System.`in`)\n    val s = sc.nextLine()\n    val n = s.length\n\n    \/\/ Initialize dp array\n    val dp = Array(n + 1) { LongArray(n + 1) }\n\n    \/\/ Base case: dp[i][i] = 1 for all i\n    for (i in 0 until n) {\n        dp[i][i] = 1\n    }\n\n    \/\/ Fill dp array using bottom-up approach\n    for (len in 2..n) {\n        for (i in 0 until n - len + 1) {\n            val j = i + len - 1\n            dp[i][j] = dp[i + 1][j] + dp[i][j - 1]\n\n            if (s[i] == '(' && s[j] == ')' || s[i] == '[' && s[j] == ']' || s[i] == '{' && s[j] == '}') {\n                dp[i][j] += 1\n            }\n\n            for (k in i + 1 until j) {\n                dp[i][j] += dp[i][k] * dp[k + 1][j]\n                dp[i][j] %= mod\n            }\n        }\n    }\n\n    println(dp[0][n - 1])\n}","PHP":"\n<?php\n\nfunction countBracketColoring($s) {\n    $n = strlen($s);\n    $dp = array_fill(0, $n, array_fill(0, $n, array_fill(0, 3, array_fill(0, 3, 0))));\n    \n    for ($i = 0; $i < $n; $i++) {\n        $dp[$i][$i][0][0] = 1;\n        $dp[$i][$i][1][1] = 1;\n        $dp[$i][$i][2][2] = 1;\n    }\n    \n    for ($len = 2; $len <= $n; $len++) {\n        for ($l = 0; $l + $len - 1 < $n; $l++) {\n            $r = $l + $len - 1;\n            \n            if ($s[$l] == '(' && $s[$r] == ')') {\n                $dp[$l][$r][0][0] = ($dp[$l][$r][0][0] + $dp[$l + 1][$r - 1][0][0] + $dp[$l + 1][$r - 1][0][1] + $dp[$l + 1][$r - 1][0][2]) % 1000000007;\n                $dp[$l][$r][0][1] = ($dp[$l][$r][0][1] + $dp[$l + 1][$r - 1][1][0] + $dp[$l + 1][$r - 1][1][1] + $dp[$l + 1][$r - 1][1][2]) % 1000000007;\n                $dp[$l][$r][0][2] = ($dp[$l][$r][0][2] + $dp[$l + 1][$r - 1][2][0] + $dp[$l + 1][$r - 1][2][1] + $dp[$l + 1][$r - 1][2][2]) % 1000000007;\n                \n                $dp[$l][$r][1][0] = ($dp[$l][$r][1][0] + $dp[$l + 1][$r - 1][0][1] + $dp[$l + 1][$r - 1][0][2]) % 1000000007;\n                $dp[$l][$r][1][1] = ($dp[$l][$r][1][1] + $dp[$l + 1][$r - 1][1][0] + $dp[$l + 1][$r - 1][1][2]) % 1000000007;\n                $dp[$l][$r][1][2] = ($dp[$l][$r][1][2] + $dp[$l + 1][$r - 1][2][0] + $dp[$l + 1][$r - 1][2][1]) % 1000000007;\n                \n                $dp[$l][$r][2][0] = ($dp[$l][$r][2][0] + $dp[$l + 1][$r - 1][0][0] + $dp[$l + 1][$r - 1][0][2]) % 1000000007;\n                $dp[$l][$r][2][1] = ($dp[$l][$r][2][1] + $dp[$l + 1][$r - 1][1][0] + $dp[$l + 1][$r - 1][1][1]) % 1000000007;\n                $dp[$l][$r][2][2] = ($dp[$l][$r][2][2] + $dp[$l + 1][$r - 1][2][0] + $dp[$l + 1][$r - 1][2][1]) % 1000000007;\n            }\n            \n            for ($k = $l; $k < $r; $k++) {\n                for ($i = 0; $i < 3; $i++) {\n                    for ($j = 0; $j < 3; $j++) {\n                        $dp[$l][$r][$i][j] = ($dp[$l][$r][$i][j] + $dp[$l][$k][$i][0] * $dp[$k + 1][$r][0][$j]) % 1000000007;\n                        $dp[$l][$r][$i][j] = ($dp[$l][$r][$i][j] + $dp[$l][$k][$i][1] * $dp[$k + 1][$r][1][$j]) % 1000000007;\n                        $dp[$l][$r][$i][j] = ($dp[$l][$r][$i][j] + $dp[$l][$k][$i][2] * $dp[$k + 1][$r][2][$j]) % 1000000007;\n                    }\n                }\n            }\n        }\n    }\n    \n    return ($dp[0][$n - 1][0][0] + $dp[0][$n - 1][0][1] + $dp[0][$n - 1][0][2] + $dp[0][$n - 1][1][0] + $dp[0][$n - 1][1][1] + $dp[0][$n - 1][1][2] + $dp[0][$n - 1][2][0] + $dp[0][$n - 1][2][1] + $dp[0][$n - 1][2][2]) % 1000000007;\n}\n\n$input = trim(fgets(STDIN));\necho countBracketColoring($input);\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nconst int MOD = 1000000007;\\r\\n\\r\\nint countWays(string s)\\r\\n{\\r\\n    int n = s.length;\\r\\n    int[][] dp = new int[][](n, n);\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        dp[i][i] = 1;\\r\\n    }\\r\\n\\r\\n    for (int len = 2; len <= n; len += 2)\\r\\n    {\\r\\n        for (int i = 0; i < n - len + 1; i++)\\r\\n        {\\r\\n            int j = i + len - 1;\\r\\n\\r\\n            if (s[i] == '(' && s[j] == ')')\\r\\n            {\\r\\n                dp[i][j] = dp[i + 1][j - 1];\\r\\n\\r\\n                for (int k = i + 1; k < j; k += 2)\\r\\n                {\\r\\n                    if (s[k] == '(')\\r\\n                    {\\r\\n                        dp[i][j] = (dp[i][j] + dp[i + 1][k - 1] * dp[k + 1][j]) % MOD;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return dp[0][n - 1];\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string s = readln!string().strip;\\r\\n    int ways = countWays(s);\\r\\n    writeln(ways);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_coloring_ways {\n    my ($bracket_sequence) = @_;\n    \n    my $mod = 1000000007;\n    my $n = length($bracket_sequence);\n    \n    my @dp;\n    $dp[0][0][0] = 1;\n    \n    for (my $i = 1; $i <= $n; $i++) {\n        for (my $j = 0; $j <= $n; $j++) {\n            for (my $k = 0; $k <= $n; $k++) {\n                if ($bracket_sequence[$i-1] eq '(') {\n                    if ($j > 0) {\n                        $dp[$i][$j][$k] = ($dp[$i][$j][$k] + $dp[$i-1][$j-1][$k]) % $mod;\n                    }\n                    if ($k > 0) {\n                        $dp[$i][$j][$k] = ($dp[$i][$j][$k] + $dp[$i-1][$j][$k-1]) % $mod;\n                    }\n                } else {\n                    if ($j > 0) {\n                        $dp[$i][$j][$k] = ($dp[$i][$j][$k] + $dp[$i-1][$j-1][$k+1]) % $mod;\n                    }\n                    if ($k > 0) {\n                        $dp[$i][$j][$k] = ($dp[$i][$j][$k] + $dp[$i-1][$j][$k-1]) % $mod;\n                    }\n                }\n                $dp[$i][$j][$k] = ($dp[$i][$j][$k] + $dp[$i-1][$j][$k]) % $mod;\n            }\n        }\n    }\n    \n    my $result = 0;\n    for (my $j = 0; $j <= $n; $j++) {\n        for (my $k = 0; $k <= $n; $k++) {\n            $result = ($result + $dp[$n][$j][$k]) % $mod;\n        }\n    }\n    \n    return $result;\n}\n\nmy $bracket_sequence = <STDIN>;\nchomp($bracket_sequence);\n\nmy $result = count_coloring_ways($bracket_sequence);\nprint $result;\n","Rust":"```rust\\nuse std::io::{self, BufRead};\\n\\nfn main() {\\n    let stdin = io::stdin();\\n    let mut lines = stdin.lock().lines();\\n\\n    let s = lines.next().unwrap().unwrap();\\n    let n = s.len();\\n\\n    let mut dp = vec![vec![vec![0; 3]; n + 1]; n + 1];\\n\\n    for i in (0..n).rev() {\\n        for j in i + 1..=n {\\n            if s.chars().nth(i).unwrap() == ')' || s.chars().nth(i).unwrap() == '(' {\\n                dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][0]) % 1000000007;\\n                dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][2]) % 1000000007;\\n                dp[i][j][1] = (dp[i][j][1] + dp[i + 1][j][0]) % 1000000007;\\n                dp[i][j][1] = (dp[i][j][1] + dp[i + 1][j][2]) % 1000000007;\\n                dp[i][j][2] = (dp[i][j][2] + dp[i + 1][j][1]) % 1000000007;\\n                dp[i][j][2] = (dp[i][j][2] + dp[i + 1][j][2]) % 1000000007;\\n            }\\n            if s.chars().nth(j - 1).unwrap() == ')' || s.chars().nth(j - 1).unwrap() == '(' {\\n                dp[i][j][0] = (dp[i][j][0] + dp[i][j - 1][1]) % 1000000007;\\n                dp[i][j][0] = (dp[i][j][0] + dp[i][j - 1][2]) % 1000000007;\\n                dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][0]) % 1000000007;\\n                dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][2]) % 1000000007;\\n                dp[i][j][2] = (dp[i][j][2] + dp[i][j - 1][0]) % 1000000007;\\n                dp[i][j][2] = (dp[i][j][2] + dp[i][j - 1][1]) % 1000000007;\\n            }\\n        }\\n    }\\n\\n    let result = (dp[0][n][0] + dp[0][n][1] + dp[0][n][2]) % 1000000007;\\n    println!(\\\"{}\\\", result);\\n}\\n```"}
{"title":"D. Mission Impassable","description":"Market stalls now have the long-awaited game The Colder Scrools V: Nvodsk. The game turned out to be difficult as hell and most students can't complete the last quest (\"We don't go to Nvodsk...\"). That threatened winter exams. The rector already started to wonder whether he should postpone the winter exams till April (in fact, he wanted to complete the quest himself). But all of a sudden a stranger appeared at the door of his office. \"Good afternoon. My name is Chuck and I solve any problems\" \u2014 he said.And here they are sitting side by side but still they can't complete the mission. The thing is, to kill the final boss one should prove one's perfect skills in the art of managing letters. One should be a real magician to do that. And can you imagine what happens when magicians start competing... But let's put it more formally: you are given a string and a set of integers ai. You are allowed to choose any substring that is a palindrome and delete it. At that we receive some number of points equal to ak, where k is the length of the deleted palindrome. For some k, ak=-1, which means that deleting palindrome strings of such length is forbidden. After a substring is deleted, the remaining part \"shifts together\", that is, at no moment of time the string has gaps. The process is repeated while the string has at least one palindrome substring that can be deleted. All gained points are summed up.Determine what maximum number of points can be earned.\"Oh\" \u2014 said Chuck, raising from the chair, \u2014 \"I used to love deleting palindromes, just like you, but one day I took an arrow in the Knee\".","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer l (1\u2264l\u2264150) \u2014 the length of the string.\nThe second line contains exactly l integers ak (-1\u2264ak\u226410^5) \u2014 the points a player gains for deleting.\nThe third line contains exactly l lowercase Latin letters \u2014 the original string from which a player can delete palindromes. The line contains no other characters apart from the newline character at the end of the string.\n","output_spec":"Print a single number \u2014 the maximum number of points one can gain if he plays on the given string.\n","notes":"In the first sample we cannot delete any substring, so the best result is 0. In the second sample we are allowed to delete only those palindromes whose length equals 1, thus, if we delete the whole string, we get 7 points. In the third sample the optimal strategy is: first we delete character c, then string aa, then bb, and the last one aa. At that we get 1+3*5=16 points.\n","sample_inputs":["7\n-1 -1 -1 -1 -1 -1 -1\nabacaba\n","7\n1 -1 -1 -1 -1 -1 -1\nabacaba\n","7\n1 5 -1 -1 -1 -1 10\nabacaba\n"],"sample_outputs":["0\n","7\n","16\n"],"id":"150-D","difficulty":2600,"tags":["dp","strings"],"src_uid":"dfd0814d912a7f2dfe31744ad1c778ae","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cstring>\\nusing namespace std;\\n\\nint dp[155][155];\\n\\nint main() {\\n    int l;\\n    cin >> l;\\n    vector<int> a(l);\\n    string s;\\n    for (int i = 0; i < l; i++) {\\n        cin >> a[i];\\n    }\\n    cin >> s;\\n    memset(dp, 0, sizeof(dp));\\n    for (int len = 1; len <= l; len++) {\\n        for (int i = 0; i + len - 1 < l; i++) {\\n            int j = i + len - 1;\\n            if (len == 1) {\\n                dp[i][j] = a[i];\\n            } else {\\n                dp[i][j] = max(dp[i][j], dp[i][j - 1]);\\n                dp[i][j] = max(dp[i][j], dp[i + 1][j]);\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + a[i] + a[j]);\\n                }\\n            }\\n        }\\n    }\\n    cout << dp[0][l - 1] << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int l = scanner.nextInt();\n        int[] points = new int[l];\n        for (int i = 0; i < l; i++) {\n            points[i] = scanner.nextInt();\n        }\n        \n        String str = scanner.next();\n        \n        int[][] dp = new int[l][l];\n        \n        for (int len = 1; len <= l; len++) {\n            for (int i = 0; i <= l - len; i++) {\n                int j = i + len - 1;\n                \n                if (len == 1) {\n                    dp[i][j] = points[i];\n                } else {\n                    dp[i][j] = Math.max(dp[i][j], dp[i + 1][j]);\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);\n                    \n                    if (str.charAt(i) == str.charAt(j)) {\n                        dp[i][j] = Math.max(dp[i][j], dp[i + 1][j - 1] + points[i]);\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[0][l - 1]);\n    }\n}","Python":"def max_points(l, points, string):\n    dp = [0] * (l + 1)\n    for i in range(1, l + 1):\n        dp[i] = dp[i - 1] + points[i - 1]\n        for j in range(i - 1):\n            if string[j:i] == string[j:i][::-1]:\n                dp[i] = max(dp[i], dp[j] + points[i - 1])\n    return str(dp[l]) + '\\\\n'\n\ninput_data = input().split('\\\\n')\nl = int(input_data[0])\npoints = list(map(int, input_data[1].split()))\nstring = input_data[2]\n\noutput = max_points(l, points, string)\nprint(output)","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\n\\nint isPalindrome(char str[], int start, int end) {\\n    while (start < end) {\\n        if (str[start] != str[end])\\n            return 0;\\n        start++;\\n        end--;\\n    }\\n    return 1;\\n}\\n\\nint maxPoints(char str[], int points[], int n) {\\n    int dp[n];\\n    dp[0] = points[0];\\n\\n    for (int i = 1; i < n; i++) {\\n        dp[i] = points[i];\\n        for (int j = 0; j < i; j++) {\\n            if (isPalindrome(str, j + 1, i))\\n                dp[i] = max(dp[i], dp[j] + points[i]);\\n        }\\n    }\\n\\n    return dp[n - 1];\\n}\\n\\nint main() {\\n    int l;\\n    scanf(\\\"%d\\\", &l);\\n\\n    int points[l];\\n    for (int i = 0; i < l; i++)\\n        scanf(\\\"%d\\\", &points[i]);\\n\\n    char str[l];\\n    scanf(\\\"%s\\\", str);\\n\\n    int result = maxPoints(str, points, l);\\n    printf(\\\"%d\\\\n\\\", result);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace PalindromeGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int l = int.Parse(Console.ReadLine());\n            int[] points = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            string str = Console.ReadLine();\n\n            int[,] dp = new int[l, l];\n\n            for (int len = 1; len <= l; len++)\n            {\n                for (int i = 0; i <= l - len; i++)\n                {\n                    int j = i + len - 1;\n\n                    if (len == 1)\n                    {\n                        dp[i, j] = points[i];\n                    }\n                    else if (len == 2)\n                    {\n                        dp[i, j] = (str[i] == str[j]) ? Math.Max(points[i], points[j]) : Math.Max(points[i], points[j]);\n                    }\n                    else\n                    {\n                        dp[i, j] = Math.Max(dp[i + 1, j], dp[i, j - 1]);\n\n                        if (str[i] == str[j])\n                        {\n                            dp[i, j] = Math.Max(dp[i, j], dp[i + 1, j - 1] + points[i] + points[j]);\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(dp[0, l - 1]);\n        }\n    }\n}","Ruby":"\ndef max_points(l, points, string)\n  # Initialize a 2D array to store the maximum points for each substring\n  dp = Array.new(l) { Array.new(l, 0) }\n\n  # Iterate over the string length\n  (2..l).each do |len|\n    # Iterate over the starting index of the substring\n    (0..l-len).each do |start|\n      # Calculate the ending index of the substring\n      ending = start + len - 1\n\n      # If the substring is a palindrome\n      if string[start] == string[ending]\n        # If the length of the palindrome is forbidden, set the points to -1\n        if points[len-1] == -1\n          dp[start][ending] = -1\n        else\n          # Calculate the points for deleting the palindrome\n          dp[start][ending] = points[len-1]\n        end\n      else\n        # If the substring is not a palindrome, find the maximum points by splitting it into two substrings\n        max_points = 0\n        (start..ending-1).each do |split|\n          max_points = [max_points, dp[start][split] + dp[split+1][ending]].max\n        end\n        dp[start][ending] = max_points\n      end\n    end\n  end\n\n  # Return the maximum points for the whole string\n  dp[0][l-1]\nend\n\n# Read the input\ninput = gets.chomp.split('\\n')\nl = input[0].to_i\npoints = input[1].split(' ').map(&:to_i)\nstring = input[2]\n\n# Call the function and print the result\nputs max_points(l, points, string)\n","delphi":"program MaximumPoints;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction IsPalindrome(s: string): Boolean;\nvar\n  i, j: Integer;\nbegin\n  i := 1;\n  j := Length(s);\n  while i < j do\n  begin\n    if s[i] <> s[j] then\n      Exit(False);\n    Inc(i);\n    Dec(j);\n  end;\n  Result := True;\nend;\n\nfunction MaxPoints(l: Integer; points: array of Integer; s: string): Integer;\nvar\n  i, j, k: Integer;\n  dp: array of Integer;\nbegin\n  SetLength(dp, l + 1);\n  dp[0] := 0;\n  for i := 1 to l do\n  begin\n    dp[i] := -1;\n    for j := 0 to i - 1 do\n    begin\n      if IsPalindrome(Copy(s, j + 1, i - j)) then\n      begin\n        k := Length(Copy(s, j + 1, i - j));\n        if (points[k] <> -1) and (dp[j] <> -1) then\n          dp[i] := Max(dp[i], dp[j] + points[k]);\n      end;\n    end;\n  end;\n  Result := dp[l];\nend;\n\nvar\n  l, i: Integer;\n  points: array of Integer;\n  s: string;\nbegin\n  ReadLn(l);\n  SetLength(points, l);\n  for i := 0 to l - 1 do\n    Read(points[i]);\n  ReadLn;\n  ReadLn(s);\n  WriteLn(MaxPoints(l, points, s));\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar l int\\n\\tfmt.Scan(&l)\\n\\n\\tpoints := make([]int, l)\\n\\tfor i := 0; i < l; i++ {\\n\\t\\tfmt.Scan(&points[i])\\n\\t}\\n\\n\\tvar s string\\n\\tfmt.Scan(&s)\\n\\n\\tmaxPoints := getMaxPoints(l, points, s)\\n\\tfmt.Println(maxPoints)\\n}\\n\\nfunc getMaxPoints(l int, points []int, s string) int {\\n\\tmaxPoints := 0\\n\\n\\tfor i := 0; i < l; i++ {\\n\\t\\tfor j := i; j < l; j++ {\\n\\t\\t\\tsub := s[i : j+1]\\n\\t\\t\\tif isPalindrome(sub) {\\n\\t\\t\\t\\tsubLen := len(sub)\\n\\t\\t\\t\\tif points[subLen-1] != -1 {\\n\\t\\t\\t\\t\\tmaxPoints += points[subLen-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPoints\\n}\\n\\nfunc isPalindrome(s string) bool {\\n\\treturn s == reverseString(s)\\n}\\n\\nfunc reverseString(s string) string {\\n\\tvar sb strings.Builder\\n\\n\\tfor i := len(s) - 1; i >= 0; i-- {\\n\\t\\tsb.WriteByte(s[i])\\n\\t}\\n\\n\\treturn sb.String()\\n}","Javascript":"function getMaxPoints(l, points, string) {\n    let maxPoints = 0;\n    \n    for (let i = 0; i < l; i++) {\n        for (let j = i; j < l; j++) {\n            if (isPalindrome(string, i, j)) {\n                let length = j - i + 1;\n                let point = points[length - 1];\n                \n                if (point !== -1) {\n                    maxPoints += point;\n                    i = j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    return maxPoints;\n}\n\nfunction isPalindrome(string, start, end) {\n    while (start < end) {\n        if (string[start] !== string[end]) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n    \n    return true;\n}\n\n\/\/ Sample inputs\nconst inputs = [\n    { l: 7, points: [-1, -1, -1, -1, -1, -1, -1], string: 'abacaba' },\n    { l: 7, points: [1, -1, -1, -1, -1, -1, -1], string: 'abacaba' },\n    { l: 7, points: [1, 5, -1, -1, -1, -1, 10], string: 'abacaba' }\n];\n\n\/\/ Calculate and print the maximum number of points for each input\nconst outputs = inputs.map(input => getMaxPoints(input.l, input.points, input.string));\nconsole.log(outputs.join('\\\\n'));","Kotlin":"import kotlin.math.max\\n\\nfun main() {\\n    val l = readLine()!!.toInt()\\n    val points = readLine()!!.split(' ').map { it.toInt() }\\n    val string = readLine()!!\\n\\n    val dp = Array(l) { IntArray(l) }\\n\\n    for (len in 1..l) {\\n        for (i in 0 until l - len + 1) {\\n            val j = i + len - 1\\n\\n            if (len == 1) {\\n                dp[i][j] = points[i]\\n            } else {\\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\\n\\n                if (string[i] == string[j]) {\\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + points[i])\\n                }\\n            }\\n        }\\n    }\\n\\n    println(dp[0][l - 1])\\n}","PHP":"\n<?php\n\nfunction isPalindrome($str) {\n    $len = strlen($str);\n    for ($i = 0; $i < $len \/ 2; $i++) {\n        if ($str[$i] != $str[$len - $i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getMaxPoints($l, $points, $string) {\n    $dp = array_fill(0, $l, 0);\n    \n    for ($i = 0; $i < $l; $i++) {\n        $dp[$i] = $points[$i];\n        for ($j = 0; $j < $i; $j++) {\n            if (isPalindrome(substr($string, $j, $i - $j + 1))) {\n                $dp[$i] = max($dp[$i], $dp[$j - 1] + $points[$i]);\n            }\n        }\n    }\n    \n    return $dp[$l - 1];\n}\n\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\n$l = intval($input[0]);\n$points = array_map('intval', explode(' ', $input[1]));\n$string = $input[2];\n\n$result = getMaxPoints($l, $points, $string);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint maxPoints(string s, int[] points) {\\r\\n    int n = s.length;\\r\\n    int[][] dp = new int[n][n];\\r\\n\\r\\n    for (int len = 1; len <= n; len++) {\\r\\n        for (int i = 0; i <= n - len; i++) {\\r\\n            int j = i + len - 1;\\r\\n\\r\\n            if (len == 1) {\\r\\n                dp[i][j] = points[i];\\r\\n            } else {\\r\\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\\r\\n\\r\\n                if (s[i] == s[j]) {\\r\\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + points[i]);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return dp[0][n - 1];\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int l;\\r\\n    readf(\\\"%d\\\", &l);\\r\\n\\r\\n    int[] points = new int[l];\\r\\n    foreach (i; 0..l) {\\r\\n        readf(\\\"%d\\\", &points[i]);\\r\\n    }\\r\\n\\r\\n    string s;\\r\\n    readf(\\\"%s\\\", &s);\\r\\n\\r\\n    int result = maxPoints(s, points);\\r\\n    writef(\\\"%d\\\\n\\\", result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub is_palindrome {\n    my $string = shift;\n    return $string eq reverse $string;\n}\n\nsub max_points {\n    my ($length, $points, $string) = @_;\n\n    my @dp = (0) x ($length + 1);\n\n    for (my $i = 1; $i <= $length; $i++) {\n        my $max_points = -1;\n\n        for (my $j = 0; $j < $i; $j++) {\n            my $substring = substr($string, $j, $i - $j);\n            if (is_palindrome($substring)) {\n                my $substring_length = length($substring);\n                if ($points->[$substring_length - 1] != -1) {\n                    $max_points = max($max_points, $points->[$substring_length - 1] + $dp[$j]);\n                }\n            }\n        }\n\n        $dp[$i] = max($dp[$i - 1], $max_points);\n    }\n\n    return $dp[$length];\n}\n\nsub max {\n    my ($a, $b) = @_;\n    return $a > $b ? $a : $b;\n}\n\n# Read input\nmy $length = <>;\nchomp $length;\n\nmy $points_line = <>;\nchomp $points_line;\nmy @points = split ' ', $points_line;\n\nmy $string = <>;\nchomp $string;\n\n# Calculate and print the maximum number of points\nmy $max_points = max_points($length, \\@points, $string);\nprint $max_points;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let l: usize = input.trim().parse().unwrap();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let points: Vec<i32> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let string: Vec<char> = input.trim().chars().collect();\n\n    let mut dp: Vec<i32> = vec![0; l + 1];\n    for i in 1..=l {\n        dp[i] = dp[i - 1] + points[i - 1];\n        for j in 0..i {\n            let sub = &string[j..i];\n            if is_palindrome(sub) {\n                dp[i] = dp[i].max(dp[j] + points[i - 1]);\n            }\n        }\n    }\n\n    println!(\"{}\", dp[l]);\n}\n\nfn is_palindrome(s: &[char]) -> bool {\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s[i] != s[j] {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}"}
{"title":"A. Marks","description":"Vasya, or Mr. Vasily Petrov is a dean of a department in a local university. After the winter exams he got his hands on a group's gradebook.Overall the group has n students. They received marks for m subjects. Each student got a mark from 1 to 9 (inclusive) for each subject.Let's consider a student the best at some subject, if there is no student who got a higher mark for this subject. Let's consider a student successful, if there exists a subject he is the best at.Your task is to find the number of successful students in the group.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first input line contains two integers n and m (1\u2264n,m\u2264100) \u2014 the number of students and the number of subjects, correspondingly. Next n lines each containing m characters describe the gradebook. Each character in the gradebook is a number from 1 to 9. Note that the marks in a rows are not sepatated by spaces.\n","output_spec":"Print the single number \u2014 the number of successful students in the given group.\n","notes":"In the first sample test the student number 1 is the best at subjects 1 and 3, student 2 is the best at subjects 1 and 2, but student 3 isn't the best at any subject.\nIn the second sample test each student is the best at at least one subject.\n","sample_inputs":["3 3\n223\n232\n112\n","3 5\n91728\n11828\n11111\n"],"sample_outputs":["2\n","3\n"],"id":"152-A","difficulty":900,"tags":["implementation"],"src_uid":"41bdb08253cf5706573f5d469ab0a7b3","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<int>> grades(n, vector<int>(m));\\n    for (int i = 0; i < n; i++) {\\n        string row;\\n        cin >> row;\\n        for (int j = 0; j < m; j++) {\\n            grades[i][j] = row[j] - '0';\\n        }\\n    }\\n    int successfulStudents = 0;\\n    for (int i = 0; i < n; i++) {\\n        bool successful = false;\\n        for (int j = 0; j < m; j++) {\\n            bool best = true;\\n            for (int k = 0; k < n; k++) {\\n                if (grades[k][j] > grades[i][j]) {\\n                    best = false;\\n                    break;\\n                }\\n            }\\n            if (best) {\\n                successful = true;\\n                break;\\n            }\\n        }\\n        if (successful) {\\n            successfulStudents++;\\n        }\\n    }\\n    cout << successfulStudents << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class SuccessfulStudents {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        scanner.nextLine();\\n        int[][] grades = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                grades[i][j] = Character.getNumericValue(line.charAt(j));\\n            }\\n        }\\n        int successfulStudents = 0;\\n        for (int i = 0; i < n; i++) {\\n            boolean isSuccessful = false;\\n            for (int j = 0; j < m; j++) {\\n                boolean isBest = true;\\n                for (int k = 0; k < n; k++) {\\n                    if (grades[k][j] > grades[i][j]) {\\n                        isBest = false;\\n                        break;\\n                    }\\n                }\\n                if (isBest) {\\n                    isSuccessful = true;\\n                    break;\\n                }\\n            }\\n            if (isSuccessful) {\\n                successfulStudents++;\\n            }\\n        }\\n        System.out.println(successfulStudents);\\n    }\\n}","Python":"def count_successful_students(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    gradebook = [list(map(int, line)) for line in input_lines[1:]]\n\n    successful_students = 0\n    for i in range(n):\n        is_successful = False\n        for j in range(m):\n            max_mark = max(gradebook[k][j] for k in range(n))\n            if gradebook[i][j] == max_mark:\n                is_successful = True\n                break\n        if is_successful:\n            successful_students += 1\n\n    return str(successful_students)\n\ninput_str = '3 3\\\\n223\\\\n232\\\\n112\\\\n'\nprint(count_successful_students(input_str))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int marks[n][m];\\n    for (int i = 0; i < n; i++) {\\n        char row[m+1];\\n        scanf(\\\"%s\\\", row);\\n        for (int j = 0; j < m; j++) {\\n            marks[i][j] = row[j] - '0';\\n        }\\n    }\\n    int successful = 0;\\n    for (int i = 0; i < n; i++) {\\n        int isSuccessful = 0;\\n        for (int j = 0; j < m; j++) {\\n            int isBest = 1;\\n            for (int k = 0; k < n; k++) {\\n                if (marks[k][j] > marks[i][j]) {\\n                    isBest = 0;\\n                    break;\\n                }\\n            }\\n            if (isBest) {\\n                isSuccessful = 1;\\n                break;\\n            }\\n        }\\n        if (isSuccessful) {\\n            successful++;\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", successful);\\n    return 0;\\n}","C#":"\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n\n        int[,] gradebook = new int[n, m];\n\n        for (int i = 0; i < n; i++)\n        {\n            string row = Console.ReadLine();\n            for (int j = 0; j < m; j++)\n            {\n                gradebook[i, j] = int.Parse(row[j].ToString());\n            }\n        }\n\n        int successfulStudents = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            bool isSuccessful = false;\n            for (int j = 0; j < m; j++)\n            {\n                bool isBest = true;\n                for (int k = 0; k < n; k++)\n                {\n                    if (gradebook[k, j] > gradebook[i, j])\n                    {\n                        isBest = false;\n                        break;\n                    }\n                }\n                if (isBest)\n                {\n                    isSuccessful = true;\n                    break;\n                }\n            }\n            if (isSuccessful)\n            {\n                successfulStudents++;\n            }\n        }\n\n        Console.WriteLine(successfulStudents);\n    }\n}","Ruby":"\ndef successful_students(gradebook)\n  # Split the input into the number of students and subjects\n  n, m = gradebook.shift.split.map(&:to_i)\n\n  # Initialize a counter for successful students\n  successful_count = 0\n\n  # Iterate through each student's grades\n  gradebook.each do |grades|\n    # Convert the string of grades into an array of integers\n    grades = grades.chars.map(&:to_i)\n\n    # Check if the student is the best at any subject\n    if grades.include?(grades.max)\n      successful_count += 1\n    end\n  end\n\n  # Return the number of successful students\n  successful_count\nend\n\n# Test the function with the sample inputs\nputs successful_students('3 3\\n223\\n232\\n112\\n')\nputs successful_students('3 5\\n91728\\n11828\\n11111\\n')\n","delphi":"program SuccessfulStudents;\n\nvar\n  n, m, i, j, k, maxMark: Integer;\n  gradebook: array of array of Char;\n  successfulStudents: Integer;\n\nbegin\n  \/\/ Read the number of students and subjects\n  ReadLn(n, m);\n  \n  \/\/ Initialize the gradebook array\n  SetLength(gradebook, n, m);\n  \n  \/\/ Read the gradebook\n  for i := 0 to n - 1 do\n  begin\n    for j := 0 to m - 1 do\n    begin\n      Read(gradebook[i, j]);\n    end;\n    ReadLn;\n  end;\n  \n  \/\/ Count the number of successful students\n  successfulStudents := 0;\n  for i := 0 to n - 1 do\n  begin\n    \/\/ Assume the student is successful\n    maxMark := 0;\n    \n    for j := 0 to m - 1 do\n    begin\n      \/\/ Find the maximum mark for the current subject\n      if Ord(gradebook[i, j]) > maxMark then\n      begin\n        maxMark := Ord(gradebook[i, j]);\n      end;\n    end;\n    \n    \/\/ Check if the student is the best at any subject\n    for j := 0 to m - 1 do\n    begin\n      if Ord(gradebook[i, j]) = maxMark then\n      begin\n        successfulStudents := successfulStudents + 1;\n        Break;\n      end;\n    end;\n  end;\n  \n  \/\/ Print the number of successful students\n  WriteLn(successfulStudents);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tgradebook := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%s\\\", &gradebook[i])\\n\\t}\\n\\n\\tsuccessfulStudents := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tisSuccessful := false\\n\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tisBest := true\\n\\n\\t\\t\\tfor k := 0; k < n; k++ {\\n\\t\\t\\t\\tif k != i && gradebook[k][j] > gradebook[i][j] {\\n\\t\\t\\t\\t\\tisBest = false\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif isBest {\\n\\t\\t\\t\\tisSuccessful = true\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif isSuccessful {\\n\\t\\t\\tsuccessfulStudents++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(successfulStudents)\\n}","Javascript":"function countSuccessfulStudents(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const gradebook = lines.slice(1);\n\n  let successfulStudents = 0;\n\n  for (let i = 0; i < n; i++) {\n    let isSuccessful = false;\n\n    for (let j = 0; j < m; j++) {\n      let isBest = true;\n\n      for (let k = 0; k < n; k++) {\n        if (gradebook[k][j] > gradebook[i][j]) {\n          isBest = false;\n          break;\n        }\n      }\n\n      if (isBest) {\n        isSuccessful = true;\n        break;\n      }\n    }\n\n    if (isSuccessful) {\n      successfulStudents++;\n    }\n  }\n\n  return successfulStudents.toString();\n}\n\nconst input1 = '3 3\\\\n223\\\\n232\\\\n112\\\\n';\nconst input2 = '3 5\\\\n91728\\\\n11828\\\\n11111\\\\n';\n\nconst output1 = countSuccessfulStudents(input1);\nconst output2 = countSuccessfulStudents(input2);\n\nconsole.log(output1);\nconsole.log(output2);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    \n    val gradebook = Array(n) { IntArray(m) }\n    for (i in 0 until n) {\n        val marks = scanner.nextLine()\n        for (j in 0 until m) {\n            gradebook[i][j] = marks[j].toString().toInt()\n        }\n    }\n    \n    val successfulStudents = findSuccessfulStudents(gradebook)\n    println(successfulStudents)\n}\n\nfun findSuccessfulStudents(gradebook: Array<IntArray>): Int {\n    val n = gradebook.size\n    val m = gradebook[0].size\n    \n    val maxMarks = IntArray(m)\n    for (j in 0 until m) {\n        var maxMark = 0\n        for (i in 0 until n) {\n            if (gradebook[i][j] > maxMark) {\n                maxMark = gradebook[i][j]\n            }\n        }\n        maxMarks[j] = maxMark\n    }\n    \n    var successfulStudents = 0\n    for (i in 0 until n) {\n        var isSuccessful = false\n        for (j in 0 until m) {\n            if (gradebook[i][j] == maxMarks[j]) {\n                isSuccessful = true\n                break\n            }\n        }\n        if (isSuccessful) {\n            successfulStudents++\n        }\n    }\n    \n    return successfulStudents\n}","PHP":"<?php\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n\\nlist($n, $m) = explode(\\\" \\\", $input[0]);\\n\\n$gradebook = array_slice($input, 1, $n);\\n\\n$successfulStudents = 0;\\n\\nfor ($i = 0; $i < $n; $i++) {\\n    $studentMarks = str_split($gradebook[$i]);\\n    $isSuccessful = false;\\n\\n    for ($j = 0; $j < $m; $j++) {\\n        $currentMark = $studentMarks[$j];\\n        $isBest = true;\\n\\n        for ($k = 0; $k < $n; $k++) {\\n            if ($k != $i && $studentMarks[$j] < $gradebook[$k][$j]) {\\n                $isBest = false;\\n                break;\\n            }\\n        }\\n\\n        if ($isBest) {\\n            $isSuccessful = true;\\n            break;\\n        }\\n    }\\n\\n    if ($isSuccessful) {\\n        $successfulStudents++;\\n    }\\n}\\n\\necho $successfulStudents;\\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] grades = new int[][](n);\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        string line;\\r\\n        readf(\\\"%s\\\", &line);\\r\\n\\r\\n        foreach (char c; line)\\r\\n        {\\r\\n            grades[i] ~= to!int(c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int successfulStudents = 0;\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        bool isSuccessful = false;\\r\\n\\r\\n        for (int j = 0; j < m; j++)\\r\\n        {\\r\\n            bool isBest = true;\\r\\n\\r\\n            for (int k = 0; k < n; k++)\\r\\n            {\\r\\n                if (grades[k][j] > grades[i][j])\\r\\n                {\\r\\n                    isBest = false;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (isBest)\\r\\n            {\\r\\n                isSuccessful = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (isSuccessful)\\r\\n        {\\r\\n            successfulStudents++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(successfulStudents);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_successful_students {\n    my ($input) = @_;\n    my ($n, $m, @grades) = split('\\n', $input);\n    my @students = split('', join('', @grades));\n    my @best_subjects;\n    my %successful_students;\n\n    # Find the best grade for each subject\n    for my $i (0..$m-1) {\n        my $max_grade = 0;\n        for my $j (0..$n-1) {\n            my $grade = substr($students[$j], $i, 1);\n            $max_grade = $grade if $grade > $max_grade;\n        }\n        push @best_subjects, $max_grade;\n    }\n\n    # Find the successful students\n    for my $i (0..$n-1) {\n        my $is_successful = 0;\n        for my $j (0..$m-1) {\n            my $grade = substr($students[$i], $j, 1);\n            if ($grade == $best_subjects[$j]) {\n                $is_successful = 1;\n                last;\n            }\n        }\n        $successful_students{$i+1} = 1 if $is_successful;\n    }\n\n    return scalar keys %successful_students;\n}\n\n# Test the function with the sample inputs\nmy @inputs = (\n    '3 3\\n223\\n232\\n112\\n',\n    '3 5\\n91728\\n11828\\n11111\\n'\n);\n\nmy @outputs;\nforeach my $input (@inputs) {\n    my $output = count_successful_students($input);\n    push @outputs, $output;\n}\n\n# Print the outputs in the required format\nmy $json_output = '[';\nforeach my $output (@outputs) {\n    $json_output .= '{\"version\": \"Perl v5.20.3\", \"source code\": \"'.$source_code.'\"},';\n}\n$json_output =~ s\/,$\/\/;\n$json_output .= ']';\n\nprint $json_output;\n","Rust":"fn main() {\n    let input = [\n        \\\"3 3\\\",\n        \\\"223\\\",\n        \\\"232\\\",\n        \\\"112\\\",\n    ];\n    \n    let mut successful_students = 0;\n    \n    let nm: Vec<usize> = input[0].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n    \n    let gradebook: Vec<Vec<u32>> = input[1..].iter().map(|x| x.chars().map(|c| c.to_digit(10).unwrap()).collect()).collect();\n    \n    for i in 0..n {\n        let mut is_successful = false;\n        for j in 0..m {\n            let current_mark = gradebook[i][j];\n            let mut is_best = true;\n            for k in 0..n {\n                if k != i && gradebook[k][j] > current_mark {\n                    is_best = false;\n                    break;\n                }\n            }\n            if is_best {\n                is_successful = true;\n                break;\n            }\n        }\n        if is_successful {\n            successful_students += 1;\n        }\n    }\n    \n    println!(\\\"{}\\\", successful_students);\n}"}
{"title":"C. Pocket Book","description":"One day little Vasya found mom's pocket book. The book had n names of her friends and unusually enough, each name was exactly m letters long. Let's number the names from 1 to n in the order in which they are written.As mom wasn't home, Vasya decided to play with names: he chose three integers i, j, k (1\u2264i<j\u2264n, 1\u2264k\u2264m), then he took names number i and j and swapped their prefixes of length k. For example, if we take names \"CBDAD\" and \"AABRD\" and swap their prefixes with the length of 3, the result will be names \"AABAD\" and \"CBDRD\".You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers i, j, k independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains two integers n and m (1\u2264n,m\u2264100) \u2014 the number of names and the length of each name, correspondingly. Then n lines contain names, each name consists of exactly m uppercase Latin letters.\n","output_spec":"Print the single number \u2014 the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (10^9+7).\n","notes":"In the first sample Vasya can get the following names in the position number 1: \"AAB\", \"AAA\", \"BAA\" and \"BAB\".\n","sample_inputs":["2 3\nAAB\nBAA\n","4 5\nABABA\nBCGDG\nAAAAA\nYABSA\n"],"sample_outputs":["4\n","216\n"],"id":"152-C","difficulty":1400,"tags":["combinatorics"],"src_uid":"a37df9b239a40473516d1525d56a0da7","C++":"#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<string> names(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> names[i];\\n    }\\n\\n    vector<int> count(m, 0);\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            count[j] += names[i][j] == names[0][j];\\n        }\\n    }\\n\\n    int result = 1;\\n    for (int i = 0; i < m; i++) {\\n        result = (result * (count[i] + 1)) % MOD;\\n    }\\n\\n    cout << result << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        String[] names = new String[n];\n        for (int i = 0; i < n; i++) {\n            names[i] = scanner.nextLine();\n        }\n        \n        int[][] count = new int[m][26];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                count[j][names[i].charAt(j) - 'A']++;\n            }\n        }\n        \n        long result = 1;\n        for (int j = 0; j < m; j++) {\n            int distinct = 0;\n            for (int k = 0; k < 26; k++) {\n                if (count[j][k] > 0) {\n                    distinct++;\n                }\n            }\n            result = (result * distinct) % 1000000007;\n        }\n        \n        System.out.println(result);\n    }\n}","Python":"def count_names(names):\n    n, m = map(int, names[0].split())\n    names = names[1:]\n\n    prefixes = set()\n    for name in names:\n        prefixes.add(name[:m])\n\n    count = 1\n    for prefix in prefixes:\n        count *= len(prefix)\n        count %= 1000000007\n\n    return str(count)\n\ninputs = ['2 3\\\\nAAB\\\\nBAA\\\\n', '4 5\\\\nABABA\\\\nBCGDG\\\\nAAAAA\\\\nYABSA\\\\n']\noutputs = []\n\nfor input_str in inputs:\n    input_list = input_str.strip().split('\\\\n')\n    output = count_names(input_list)\n    outputs.append(output)\n\noutputs = [output + '\\\\n' for output in outputs]\nprint(outputs)","C":"#include <stdio.h>\\n#include <string.h>\\n\\n#define MOD 1000000007\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    char names[n][m+1];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%s\\\", names[i]);\\n    }\\n\\n    int count[m];\\n    memset(count, 0, sizeof(count));\\n\\n    for(int i=1; i<n; i++) {\\n        int diff = 0;\\n        for(int j=0; j<m; j++) {\\n            if(names[i][j] != names[0][j]) {\\n                diff++;\\n            }\\n        }\\n        count[diff]++;\\n    }\\n\\n    long long result = 1;\\n    for(int i=0; i<m; i++) {\\n        result = (result * (count[i]+1)) % MOD;\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", result);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace PocketBook\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            List<string> names = new List<string>();\n            for (int i = 0; i < n; i++)\n            {\n                names.Add(Console.ReadLine());\n            }\n\n            int[,] count = new int[m, 26];\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    count[j, names[i][j] - 'A']++;\n                }\n            }\n\n            long result = 1;\n            for (int j = 0; j < m; j++)\n            {\n                int distinct = 0;\n                for (int k = 0; k < 26; k++)\n                {\n                    if (count[j, k] > 0)\n                    {\n                        distinct++;\n                    }\n                }\n                result = (result * distinct) % 1000000007;\n            }\n\n            Console.WriteLine(result);\n        }\n    }\n}","Ruby":"\ndef factorial(n)\n  return 1 if n == 0\n  (1..n).reduce(:*) % 1000000007\nend\n\ndef count_names(names)\n  n = names.length\n  m = names[0].length\n\n  # Count the frequency of each prefix\n  prefix_freq = Hash.new(0)\n  names.each do |name|\n    (1..m).each do |k|\n      prefix = name[0...k]\n      prefix_freq[prefix] += 1\n    end\n  end\n\n  # Calculate the number of different names\n  result = factorial(n)\n  prefix_freq.each do |prefix, freq|\n    result = (result * factorial(freq)) % 1000000007\n  end\n\n  return result\nend\n\n# Read input\ninput = gets.chomp.split(\"\\n\")\nn, m = input[0].split.map(&:to_i)\nnames = input[1..n]\n\n# Count the number of different names\nresult = count_names(names)\n\n# Print the result\nputs result\n","delphi":"program PocketBook;\\n\\nconst\\n  MOD = 1000000007;\\n\\nvar\\n  n, m, i, j, k, count: Integer;\\n  names: array[1..100] of String;\\n  prefixes: array[1..100] of String;\\n  result: Int64;\\n\\nfunction SwapPrefix(name: String; prefix: String; k: Integer): String;\\nbegin\\n  Result := Copy(prefix, 1, k) + Copy(name, k+1, m-k);\\nend;\\n\\nbegin\\n  ReadLn(n, m);\\n  for i := 1 to n do\\n    ReadLn(names[i]);\\n  result := 0;\\n\\n  for i := 1 to n do\\n  begin\\n    prefixes[i] := Copy(names[i], 1, m);\\n    count := 0;\\n    for j := 1 to n do\\n    begin\\n      for k := 1 to m do\\n      begin\\n        if prefixes[i] <> Copy(names[j], 1, k) then\\n        begin\\n          prefixes[j] := Copy(names[j], 1, k);\\n          Inc(count);\\n        end;\\n      end;\\n    end;\\n    result := (result + count) mod MOD;\\n  end;\\n\\n  WriteLn(result);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nconst mod = 1000000007\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, m := parseInt(nm[0]), parseInt(nm[1])\\n\\n\\tnames := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tnames[i] = scanner.Text()\\n\\t}\\n\\n\\tcount := make([][]int, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tcount[i] = make([]int, 26)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tcount[j][names[i][j]-'A']++\\n\\t\\t}\\n\\t}\\n\\n\\tresult := 1\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\ttemp := 0\\n\\t\\tfor j := 0; j < 26; j++ {\\n\\t\\t\\ttemp += count[i][j]\\n\\t\\t\\ttemp %= mod\\n\\t\\t}\\n\\t\\tresult *= temp\\n\\t\\tresult %= mod\\n\\t}\\n\\n\\tfmt.Println(result)\\n}\\n\\nfunc parseInt(s string) int {\\n\\tvar res int\\n\\tfor _, c := range s {\\n\\t\\tres = res*10 + int(c-'0')\\n\\t}\\n\\treturn res\\n}","Javascript":"function countNames(names) {\n  const mod = 1000000007;\n  const n = names.length;\n  const m = names[0].length;\n  \n  let count = 1;\n  let prefixCounts = new Array(m).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    let prefix = names[i].substring(0, m - 1);\n    let suffix = names[i].substring(m - 1);\n    \n    let prefixCount = 0;\n    for (let j = 0; j < m - 1; j++) {\n      prefixCount = (prefixCount + prefixCounts[j]) % mod;\n    }\n    \n    let suffixCount = (count - prefixCount + mod) % mod;\n    \n    count = (prefixCount + suffixCount) % mod;\n    \n    prefixCounts[suffix.charCodeAt(0) - 65] = (prefixCounts[suffix.charCodeAt(0) - 65] + suffixCount) % mod;\n  }\n  \n  return count;\n}\n\nfunction main(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const names = lines.slice(1, n + 1);\n  \n  const result = countNames(names);\n  \n  return result.toString();\n}\n\nconst input = '2 3\\\\nAAB\\\\nBAA\\\\n';\nconsole.log(main(input));","Kotlin":"import java.util.*\n\nfun main() {\n    val mod = 1000000007\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    val names = Array(n) { \"\" }\n    for (i in 0 until n) {\n        names[i] = scanner.nextLine()\n    }\n    \n    val count = Array(m) { IntArray(26) }\n    for (i in 0 until n) {\n        for (j in 0 until m) {\n            count[j][names[i][j] - 'A']++\n        }\n    }\n    \n    var result = 1L\n    for (j in 0 until m) {\n        var ways = 0L\n        for (k in 0 until 26) {\n            ways += count[j][k].toLong() * (count[j][k] - 1) \/ 2\n            ways %= mod\n        }\n        result = result * ways % mod\n    }\n    \n    println(result)\n}","PHP":"\n<?php\n\nfunction countNames($n, $m, $names) {\n    $mod = 1000000007;\n    $count = 1;\n    \n    for ($i = 0; $i < $m; $i++) {\n        $distinct = [];\n        \n        for ($j = 0; $j < $n; $j++) {\n            $prefix = substr($names[$j], 0, $i + 1);\n            $distinct[$prefix] = true;\n        }\n        \n        $count = ($count * count($distinct)) % $mod;\n    }\n    \n    return $count;\n}\n\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\nlist($n, $m) = explode(\\\" \\\", $input[0]);\n$names = array_slice($input, 1, $n);\n\n$result = countNames($n, $m, $names);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.string;\\r\\n\\r\\nconst int MOD = 1000000007;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    string[] names;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        string name;\\r\\n        readf(\\\"%s\\\", &name);\\r\\n        names ~= name;\\r\\n    }\\r\\n\\r\\n    int[][] prefixCount;\\r\\n    prefixCount.length = m;\\r\\n    foreach (i; 0..m)\\r\\n    {\\r\\n        prefixCount[i].length = 26;\\r\\n    }\\r\\n\\r\\n    foreach (name; names)\\r\\n    {\\r\\n        foreach (i; 0..m)\\r\\n        {\\r\\n            int index = name[i] - 'A';\\r\\n            prefixCount[i][index]++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int result = 1;\\r\\n    foreach (i; 0..m)\\r\\n    {\\r\\n        int count = 0;\\r\\n        foreach (j; 0..26)\\r\\n        {\\r\\n            count += prefixCount[i][j];\\r\\n            prefixCount[i][j] = count;\\r\\n        }\\r\\n\\r\\n        result = (result * (count - i)) % MOD;\\r\\n    }\\r\\n\\r\\n    writeln(result);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_names {\n    my ($n, $m, @names) = @_;\n\n    my $mod = 1000000007;\n    my $count = 1;\n\n    for my $i (1..$m) {\n        my %prefixes;\n        my $distinct = 0;\n\n        for my $j (0..$n-1) {\n            my $prefix = substr($names[$j], 0, $i);\n            $prefixes{$prefix} = 1;\n        }\n\n        $distinct = scalar keys %prefixes;\n        $count = ($count * $distinct) % $mod;\n    }\n\n    return $count;\n}\n\nmy ($n, $m) = split ' ', <>;\nmy @names;\n\nfor (1..$n) {\n    push @names, <>;\n}\n\nmy $result = count_names($n, $m, @names);\nprint $result;\n","Rust":"fn main() {\\n    let modulo = 1000000007;\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let nm: Vec<usize> = input\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nm[0];\\n    let m = nm[1];\\n\\n    let mut names: Vec<String> = Vec::new();\\n    for _ in 0..n {\\n        let mut name = String::new();\\n        std::io::stdin().read_line(&mut name).unwrap();\\n        names.push(name.trim().to_string());\\n    }\\n\\n    let mut count: u64 = 1;\\n    for i in 0..m {\\n        let mut distinct_chars: Vec<char> = Vec::new();\\n        for j in 0..n {\\n            let prefix: String = names[j].chars().take(i + 1).collect();\\n            if !distinct_chars.contains(&prefix.chars().next().unwrap()) {\\n                distinct_chars.push(prefix.chars().next().unwrap());\\n            }\\n        }\\n        count = (count * distinct_chars.len() as u64) % modulo;\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"D. Flatland Fencing","description":"The King of Flatland will organize a knights' tournament! The winner will get half the kingdom and the favor of the princess of legendary beauty and wisdom. The final test of the applicants' courage and strength will be a fencing tournament. The tournament is held by the following rules: the participants fight one on one, the winner (or rather, the survivor) transfers to the next round.Before the battle both participants stand at the specified points on the Ox axis with integer coordinates. Then they make moves in turn. The first participant moves first, naturally. During a move, the first participant can transfer from the point x to any integer point of the interval [x+a; x+b]. The second participant can transfer during a move to any integer point of the interval [x-b; x-a]. That is, the options for the players' moves are symmetric (note that the numbers a and b are not required to be positive, and if a\u22640\u2264b, then staying in one place is a correct move). At any time the participants can be located arbitrarily relative to each other, that is, it is allowed to \"jump\" over the enemy in any direction. A participant wins if he uses his move to transfer to the point where his opponent is.Of course, the princess has already chosen a husband and now she wants to make her sweetheart win the tournament. He has already reached the tournament finals and he is facing the last battle. The princess asks the tournament manager to arrange the tournament finalists in such a way that her sweetheart wins the tournament, considering that both players play optimally. However, the initial location of the participants has already been announced, and we can only pull some strings and determine which participant will be first and which one will be second. But how do we know which participant can secure the victory? Alas, the princess is not learned in the military affairs... Therefore, she asks you to determine how the battle will end considering that both opponents play optimally. Also, if the first player wins, your task is to determine his winning move.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains four space-separated integers \u2014 x1, x2, a and b (x1\u2260x2, a\u2264b, -10^9\u2264x1,x2,a,b\u226410^9) \u2014 coordinates of the points where the first and the second participant start, and the numbers that determine the players' moves, correspondingly.\n","output_spec":"On the first line print the outcome of the battle as \"FIRST\" (without the quotes), if both players play optimally and the first player wins. Print \"SECOND\" (without the quotes) if the second player wins and print \"DRAW\" (without the quotes), if nobody is able to secure the victory.\nIf the first player wins, print on the next line the single integer x \u2014 the coordinate of the point where the first player should transfer to win. The indicated move should be valid, that is, it should meet the following condition: x1+a\u2264x\u2264x1+b. If there are several winning moves, print any of them. If the first participant can't secure the victory, then you do not have to print anything.\n","notes":"In the first sample the first player can win in one move.\nIn the second sample the first participant must go to point 1, where the second participant immediately goes and wins. \nIn the third sample changing the position isn't profitable to either participant, so nobody wins.\n","sample_inputs":["0 2 0 4\n","0 2 1 1\n","0 2 0 1\n"],"sample_outputs":["FIRST\n2\n","SECOND\n","DRAW\n"],"id":"154-D","difficulty":2400,"tags":["games","math"],"src_uid":"4ea8cc3305a0ee2c1e580b43e5bc46c6","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int x1, x2, a, b;\\n    cin >> x1 >> x2 >> a >> b;\\n\\n    if (x1 > x2) {\\n        swap(x1, x2);\\n        swap(a, b);\\n    }\\n\\n    if (x1 + b < x2) {\\n        cout << \\\"FIRST\\\" << endl;\\n        cout << x1 + b << endl;\\n    } else if (x2 + a < x1) {\\n        cout << \\\"SECOND\\\" << endl;\\n    } else {\\n        cout << \\\"DRAW\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class KnightsTournament {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        int x1 = Integer.parseInt(input[0]);\\n        int x2 = Integer.parseInt(input[1]);\\n        int a = Integer.parseInt(input[2]);\\n        int b = Integer.parseInt(input[3]);\\n\\n        if (x1 > x2) {\\n            int temp = x1;\\n            x1 = x2;\\n            x2 = temp;\\n        }\\n\\n        if (a <= 0 && b >= 0) {\\n            System.out.println(\\\"DRAW\\\");\\n        } else if (a > 0) {\\n            int x = x2 - (x2 - x1) % (a + b);\\n            if (x >= x1 + a && x <= x1 + b) {\\n                System.out.println(\\\"FIRST\\\");\\n                System.out.println(x);\\n            } else {\\n                System.out.println(\\\"SECOND\\\");\\n            }\\n        } else {\\n            int x = x1 + (x2 - x1) % (Math.abs(a) + Math.abs(b));\\n            if (x >= x2 + a && x <= x2 + b) {\\n                System.out.println(\\\"SECOND\\\");\\n            } else {\\n                System.out.println(\\\"FIRST\\\");\\n                System.out.println(x);\\n            }\\n        }\\n    }\\n}","Python":"def fencing_tournament(x1, x2, a, b):\n    if a == 0 and b == 0:\n        return 'DRAW'\n    elif a == 0:\n        if x1 == x2:\n            return 'DRAW'\n        elif x1 < x2:\n            return 'SECOND'\n        else:\n            return 'FIRST\\n' + str(x1)\n    elif b == 0:\n        if x1 == x2:\n            return 'DRAW'\n        elif x1 > x2:\n            return 'SECOND'\n        else:\n            return 'FIRST\\n' + str(x1)\n    elif a <= 0 and b >= 0:\n        if x1 + a <= x2 <= x1 + b:\n            return 'FIRST\\n' + str(x2)\n        else:\n            return 'DRAW'\n    elif a > 0 and b >= 0:\n        if x1 + a <= x2 <= x1 + b:\n            return 'FIRST\\n' + str(x2)\n        elif x2 < x1 + a:\n            return 'SECOND'\n        else:\n            return 'FIRST\\n' + str(x1 + a)\n    elif a <= 0 and b < 0:\n        if x1 + b <= x2 <= x1 + a:\n            return 'FIRST\\n' + str(x2)\n        elif x2 > x1 + a:\n            return 'SECOND'\n        else:\n            return 'FIRST\\n' + str(x1 + b)\n    else:\n        if x1 + b <= x2 <= x1 + a:\n            return 'FIRST\\n' + str(x2)\n        else:\n            return 'DRAW'\n\n# Sample Inputs\ninputs = ['0 2 0 4\\n', '0 2 1 1\\n', '0 2 0 1\\n']\n\n# Process each input and print the output\nfor input_str in inputs:\n    x1, x2, a, b = map(int, input_str.strip().split())\n    output = fencing_tournament(x1, x2, a, b)\n    print(output)\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int x1, x2, a, b;\\n    scanf(\\\"%d %d %d %d\\\", &x1, &x2, &a, &b);\\n\\n    if (x1 > x2) {\\n        int temp = x1;\\n        x1 = x2;\\n        x2 = temp;\\n    }\\n\\n    if (x1 + b < x2 - a) {\\n        printf(\\\"FIRST\\\\n%d\\\\n\\\", x1 + b);\\n    } else if (x2 + b < x1 - a) {\\n        printf(\\\"SECOND\\\\n\\\");\\n    } else {\\n        printf(\\\"DRAW\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        int x1 = int.Parse(input[0]);\n        int x2 = int.Parse(input[1]);\n        int a = int.Parse(input[2]);\n        int b = int.Parse(input[3]);\n\n        if (x1 > x2)\n        {\n            int temp = x1;\n            x1 = x2;\n            x2 = temp;\n        }\n\n        if (a <= 0 && b >= 0)\n        {\n            Console.WriteLine(\\\"DRAW\\\");\n            return;\n        }\n\n        if (x2 <= x1 + b && x2 >= x1 + a)\n        {\n            Console.WriteLine(\\\"SECOND\\\");\n            return;\n        }\n\n        if (x1 + a <= x2 && x2 <= x1 + b)\n        {\n            Console.WriteLine(\\\"FIRST\\\");\n            Console.WriteLine(x2);\n            return;\n        }\n\n        Console.WriteLine(\\\"DRAW\\\");\n    }\n}","Ruby":"\ndef fencing_tournament(coordinates)\n  x1, x2, a, b = coordinates.split(' ').map(&:to_i)\n  \n  # Check if the first player can win in one move\n  if (x2 - x1).abs <= b && (x2 - x1).abs >= a\n    return \\\"FIRST\\\\n#{x2}\\\"\n  end\n  \n  # Check if the second player can win in one move\n  if (x1 - x2).abs <= b && (x1 - x2).abs >= a\n    return \\\"SECOND\\\"\n  end\n  \n  # Check if the first player can win by jumping over the second player\n  if (x2 - x1).abs > b && (x2 - x1).abs % (b - a) == 0\n    return \\\"FIRST\\\\n#{x1 + (x2 - x1) \/ (b - a) * a}\\\"\n  end\n  \n  # Check if the second player can win by jumping over the first player\n  if (x1 - x2).abs > b && (x1 - x2).abs % (b - a) == 0\n    return \\\"SECOND\\\"\n  end\n  \n  # If none of the above conditions are met, it's a draw\n  return \\\"DRAW\\\"\nend\n\ninputs = ['0 2 0 4\\n', '0 2 1 1\\n', '0 2 0 1\\n']\noutputs = []\n\ninputs.each do |input|\n  output = fencing_tournament(input)\n  outputs << output\nend\n\noutputs\n","delphi":"program KnightsTournament;\\n\\nvar\\n  x1, x2, a, b: Integer;\\n\\nbegin\\n  Readln(x1, x2, a, b);\\n  \\n  if (x1 + a <= x2) and (x2 <= x1 + b) then\\n  begin\\n    Writeln('FIRST');\\n    Writeln(x2);\\n  end\\n  else if (x2 + a <= x1) and (x1 <= x2 + b) then\\n  begin\\n    Writeln('SECOND');\\n  end\\n  else\\n  begin\\n    Writeln('DRAW');\\n  end;\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar x1, x2, a, b int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &x1, &x2, &a, &b)\\n\\n\\tif x1 > x2 {\\n\\t\\tx1, x2 = x2, x1\\n\\t\\ta, b = -b, -a\\n\\t}\\n\\n\\tif a <= 0 && b >= 0 {\\n\\t\\tfmt.Println(\\\"DRAW\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\tif x2 <= x1+b {\\n\\t\\tfmt.Println(\\\"SECOND\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\tif x2 <= x1+a {\\n\\t\\tfmt.Println(\\\"FIRST\\\")\\n\\t\\tfmt.Println(x1 + a)\\n\\t\\treturn\\n\\t}\\n\\n\\tfmt.Println(\\\"DRAW\\\")\\n}","Javascript":"function fencingTournament(input) {\n    let [x1, x2, a, b] = input.split(' ').map(Number);\n    \n    if (x1 > x2) {\n        [x1, x2] = [x2, x1];\n        [a, b] = [-b, -a];\n    }\n    \n    if (x1 + b < x2) {\n        return 'FIRST\\n' + (x1 + b);\n    } else if (x2 + a > x1) {\n        return 'SECOND\\n';\n    } else {\n        return 'DRAW\\n';\n    }\n}\n\nlet inputs = ['0 2 0 4\\n', '0 2 1 1\\n', '0 2 0 1\\n'];\nlet outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    let result = fencingTournament(inputs[i]);\n    outputs.push(result);\n}\n\nJSON.stringify([{\"version\": \"JavaScript\", \"source code\": fencingTournament.toString()}]);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val x1 = input[0]\n    val x2 = input[1]\n    val a = input[2]\n    val b = input[3]\n\n    val outcome = determineOutcome(x1, x2, a, b)\n    println(outcome)\n}\n\nfun determineOutcome(x1: Int, x2: Int, a: Int, b: Int): String {\n    val distance = Math.abs(x1 - x2)\n\n    \/\/ If the distance is within the range of the second player's moves, the second player wins\n    if (distance in a..b) {\n        return \"SECOND\"\n    }\n\n    \/\/ If the distance is within the range of the first player's moves, the first player wins\n    if (distance in -b..-a) {\n        return \"FIRST\\n${x1 + b}\"\n    }\n\n    \/\/ If the distance is not within the range of either player's moves, it's a draw\n    return \"DRAW\"\n}","PHP":"\n<?php\n\nfunction fencingTournament($x1, $x2, $a, $b) {\n    \/\/ Check if the first player can win in one move\n    if ($x2 >= $x1 + $a && $x2 <= $x1 + $b) {\n        return 'FIRST\\n' . ($x2) . '\\n';\n    }\n    \n    \/\/ Check if the second player can win in one move\n    if ($x1 >= $x2 - $b && $x1 <= $x2 - $a) {\n        return 'SECOND\\n';\n    }\n    \n    \/\/ If neither player can win in one move, it's a draw\n    return 'DRAW\\n';\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$x1 = intval($input[0]);\n$x2 = intval($input[1]);\n$a = intval($input[2]);\n$b = intval($input[3]);\n\n$result = fencingTournament($x1, $x2, $a, $b);\necho $result;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int x1, x2, a, b;\\r\\n    readf(\\\"%d %d %d %d\\\", &x1, &x2, &a, &b);\\r\\n\\r\\n    if (x1 > x2)\\r\\n    {\\r\\n        int temp = x1;\\r\\n        x1 = x2;\\r\\n        x2 = temp;\\r\\n    }\\r\\n\\r\\n    if (x1 + b < x2 - a)\\r\\n    {\\r\\n        writeln(\\\"FIRST\\\");\\r\\n        writeln(x1 + b);\\r\\n    }\\r\\n    else if (x2 + b < x1 - a)\\r\\n    {\\r\\n        writeln(\\\"SECOND\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"DRAW\\\");\\r\\n    }\\r\\n}","perl":"\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($x1, $x2, $a, $b) = split ' ', $input;\n\n# Calculate the winning move\nif ($x1 < $x2) {\n    my $winning_move = $x2 - $b;\n    if ($winning_move >= $x1 + $a) {\n        print \\\"FIRST\\\\n$winning_move\\\\n\\\";\n    } else {\n        print \\\"SECOND\\\\n\\\";\n    }\n} else {\n    my $winning_move = $x2 + $b;\n    if ($winning_move <= $x1 + $a) {\n        print \\\"FIRST\\\\n$winning_move\\\\n\\\";\n    } else {\n        print \\\"SECOND\\\\n\\\";\n    }\n}\n","Rust":"fn main() {\\n    let input = String::from(\\\"0 2 0 4\\\");\\n    let mut iter = input.split_whitespace();\\n    let x1: i64 = iter.next().unwrap().parse().unwrap();\\n    let x2: i64 = iter.next().unwrap().parse().unwrap();\\n    let a: i64 = iter.next().unwrap().parse().unwrap();\\n    let b: i64 = iter.next().unwrap().parse().unwrap();\\n\\n    if x1 > x2 {\\n        let temp = x1;\\n        x1 = x2;\\n        x2 = temp;\\n    }\\n\\n    if a <= 0 && 0 <= b {\\n        println!(\\\"DRAW\\\");\\n        return;\\n    }\\n\\n    if x2 <= x1 + b {\\n        println!(\\\"SECOND\\\");\\n        return;\\n    }\\n\\n    if x2 <= x1 + a {\\n        println!(\\\"FIRST\\\");\\n        println!(\\\"{}\\\", x1 + a);\\n        return;\\n    }\\n\\n    println!(\\\"DRAW\\\");\\n}"}
{"title":"B. Suspects","description":"As Sherlock Holmes was investigating a crime, he identified n suspects. He knows for sure that exactly one of them committed the crime. To find out which one did it, the detective lines up the suspects and numbered them from 1 to n. After that, he asked each one: \"Which one committed the crime?\". Suspect number i answered either \"The crime was committed by suspect number ai\", or \"Suspect number ai didn't commit the crime\". Also, the suspect could say so about himself (ai=i).Sherlock Holmes understood for sure that exactly m answers were the truth and all other answers were a lie. Now help him understand this: which suspect lied and which one told the truth?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m (1\u2264n\u226410^5,0\u2264m\u2264n) \u2014 the total number of suspects and the number of suspects who told the truth. Next n lines contain the suspects' answers. The i-th line contains either \"+ai\" (without the quotes), if the suspect number i says that the crime was committed by suspect number ai, or \"-ai\" (without the quotes), if the suspect number i says that the suspect number ai didn't commit the crime (ai is an integer, 1\u2264ai\u2264n).\nIt is guaranteed that at least one suspect exists, such that if he committed the crime, then exactly m people told the truth.\n","output_spec":"Print n lines. Line number i should contain \"Truth\" if suspect number i has told the truth for sure. Print \"Lie\" if the suspect number i lied for sure and print \"Not defined\" if he could lie and could tell the truth, too, depending on who committed the crime.\n","notes":"The first sample has the single person and he confesses to the crime, and Sherlock Holmes knows that one person is telling the truth. That means that this person is telling the truth.\nIn the second sample there are three suspects and each one denies his guilt. Sherlock Holmes knows that only two of them are telling the truth. Any one of them can be the criminal, so we don't know for any of them, whether this person is telling the truth or not.\nIn the third sample the second and the fourth suspect defend the first and the third one. But only one is telling the truth, thus, the first or the third one is the criminal. Both of them can be criminals, so the second and the fourth one can either be lying or telling the truth. The first and the third one are lying for sure as they are blaming the second and the fourth one.\n","sample_inputs":["1 1\n+1\n","3 2\n-1\n-2\n-3\n","4 1\n+2\n-3\n+4\n-1\n"],"sample_outputs":["Truth\n","Not defined\nNot defined\nNot defined\n","Lie\nNot defined\nLie\nNot defined\n"],"id":"156-B","difficulty":1600,"tags":["constructive+algorithms","data+structures","implementation"],"src_uid":"c761bb69cf1b5a3dbe38d9f5c46e9007","C++":"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> truth(n + 1, 0);\n    vector<int> lie(n + 1, 0);\n\n    for (int i = 1; i <= n; i++) {\n        string answer;\n        cin >> answer;\n\n        int suspect;\n        cin >> suspect;\n\n        if (answer == \"+\") {\n            truth[suspect]++;\n        } else {\n            lie[suspect]++;\n        }\n    }\n\n    vector<string> result(n + 1, \"Not defined\");\n\n    for (int i = 1; i <= n; i++) {\n        if (truth[i] + lie[i] == m && truth[i] > 0) {\n            result[i] = \"Truth\";\n        } else if (truth[i] == 0 && lie[i] == 0) {\n            result[i] = \"Lie\";\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}\n","Java":"import java.util.*;\n\npublic class SherlockHolmes {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        String[] answers = new String[n];\n        for (int i = 0; i < n; i++) {\n            answers[i] = scanner.nextLine();\n        }\n        \n        boolean[] isTruth = new boolean[n];\n        boolean[] isLie = new boolean[n];\n        \n        for (int i = 0; i < n; i++) {\n            int ai = Integer.parseInt(answers[i].substring(1));\n            \n            if (answers[i].charAt(0) == '+') {\n                isTruth[ai - 1] = true;\n            } else {\n                isLie[ai - 1] = true;\n            }\n        }\n        \n        int truthCount = 0;\n        int lieCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (isTruth[i]) {\n                truthCount++;\n            }\n            if (isLie[i]) {\n                lieCount++;\n            }\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        for (int i = 0; i < n; i++) {\n            if (truthCount == m && isTruth[i]) {\n                result.append(\"Truth\\n\");\n            } else if (lieCount == n - m && isLie[i]) {\n                result.append(\"Lie\\n\");\n            } else {\n                result.append(\"Not defined\\n\");\n            }\n        }\n        \n        System.out.println(result.toString());\n    }\n}","Python":"def find_truth(n, m, answers):\n    truth = [False] * n\n    lie = [False] * n\n    for i in range(n):\n        if answers[i][0] == '+':\n            truth[int(answers[i][1:])-1] = True\n        else:\n            lie[int(answers[i][1:])-1] = True\n    \n    for i in range(n):\n        if truth[i] and lie[i]:\n            print('Not defined')\n        elif truth[i]:\n            print('Truth')\n        else:\n            print('Lie')\n\n# Sample Inputs\ninputs = ['1 1\\n+1\\n', '3 2\\n-1\\n-2\\n-3\\n', '4 1\\n+2\\n-3\\n+4\\n-1\\n']\n\nfor input_str in inputs:\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    answers = input_lines[1:]\n    \n    find_truth(n, m, answers)\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int* truth = (int*)malloc((n+1) * sizeof(int));\\n    int* lie = (int*)malloc((n+1) * sizeof(int));\\n    int* count = (int*)malloc((n+1) * sizeof(int));\\n    for (int i = 1; i <= n; i++) {\\n        truth[i] = 0;\\n        lie[i] = 0;\\n        count[i] = 0;\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        char answer[3];\\n        scanf(\\\"%s\\\", answer);\\n        int ai;\\n        sscanf(answer, \\\"%*c%d\\\", &ai);\\n        if (answer[0] == '+') {\\n            truth[ai]++;\\n        } else {\\n            lie[ai]++;\\n        }\\n        count[ai]++;\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        if (truth[i] + lie[i] == m && count[i] == truth[i]) {\\n            printf(\\\"Truth\\\\n\\\");\\n        } else if (truth[i] + lie[i] == m && count[i] == lie[i]) {\\n            printf(\\\"Lie\\\\n\\\");\\n        } else {\\n            printf(\\\"Not defined\\\\n\\\");\\n        }\\n    }\\n    free(truth);\\n    free(lie);\\n    free(count);\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace SherlockHolmes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = new string[] { \\\"1 1\\n+1\\n\\\", \\\"3 2\\n-1\\n-2\\n-3\\n\\\", \\\"4 1\\n+2\\n-3\\n+4\\n-1\\n\\\" };\n            \n            foreach (string input in inputs)\n            {\n                string[] lines = input.Split('\\\\n');\n                string[] nm = lines[0].Split(' ');\n                int n = int.Parse(nm[0]);\n                int m = int.Parse(nm[1]);\n\n                List<int> truthSuspects = new List<int>();\n                List<int> lieSuspects = new List<int>();\n\n                for (int i = 1; i <= n; i++)\n                {\n                    string answer = lines[i];\n                    string[] parts = answer.Split(' ');\n                    string sign = parts[0];\n                    int ai = int.Parse(parts[1]);\n\n                    if (sign == \\\"+\\\" && ai == i)\n                    {\n                        truthSuspects.Add(i);\n                    }\n                    else if (sign == \\\"-\\\" && ai != i)\n                    {\n                        truthSuspects.Add(i);\n                    }\n                    else\n                    {\n                        lieSuspects.Add(i);\n                    }\n                }\n\n                for (int i = 1; i <= n; i++)\n                {\n                    if (truthSuspects.Contains(i))\n                    {\n                        Console.WriteLine(\\\"Truth\\\");\n                    }\n                    else if (lieSuspects.Contains(i))\n                    {\n                        Console.WriteLine(\\\"Lie\\\");\n                    }\n                    else\n                    {\n                        Console.WriteLine(\\\"Not defined\\\");\n                    }\n                }\n\n                Console.WriteLine();\n            }\n        }\n    }\n}\n","Ruby":"\ndef find_truth(n, m, answers)\n  truth = Array.new(n, false)\n  lie = Array.new(n, false)\n  \n  answers.each_with_index do |answer, i|\n    if answer[0] == '+'\n      suspect = answer[1..-1].to_i\n      truth[suspect-1] = true\n    else\n      suspect = answer[1..-1].to_i\n      lie[suspect-1] = true\n    end\n  end\n  \n  result = []\n  \n  truth_count = truth.count(true)\n  lie_count = lie.count(true)\n  \n  if truth_count == m\n    truth.each_with_index do |t, i|\n      result << (t ? 'Truth' : 'Lie')\n    end\n  elsif lie_count == n - m\n    lie.each_with_index do |l, i|\n      result << (l ? 'Lie' : 'Truth')\n    end\n  else\n    result = Array.new(n, 'Not defined')\n  end\n  \n  result\nend\n\ninputs = ['1 1\\n+1\\n', '3 2\\n-1\\n-2\\n-3\\n', '4 1\\n+2\\n-3\\n+4\\n-1\\n']\noutputs = ['Truth\\n', 'Not defined\\nNot defined\\nNot defined\\n', 'Lie\\nNot defined\\nLie\\nNot defined\\n']\n\ninputs.each_with_index do |input, i|\n  n, m = input.split(\"\\n\")[0].split.map(&:to_i)\n  answers = input.split(\"\\n\")[1..-1]\n  \n  output = find_truth(n, m, answers)\n  \n  puts output == outputs[i]\nend\n","delphi":"program SherlockHolmes;\n\nvar\n  n, m, i, ai, countTruth, countLie: Integer;\n  answers: array of String;\n  isTruth, isLie: array of Boolean;\n\nbegin\n  \/\/ Read input\n  ReadLn(n, m);\n  SetLength(answers, n);\n  SetLength(isTruth, n);\n  SetLength(isLie, n);\n  countTruth := 0;\n  countLie := 0;\n  \n  \/\/ Read suspects' answers\n  for i := 0 to n-1 do\n  begin\n    ReadLn(answers[i]);\n    if answers[i][1] = '+' then\n    begin\n      isTruth[i] := True;\n      countTruth := countTruth + 1;\n    end\n    else\n    begin\n      isLie[i] := True;\n      countLie := countLie + 1;\n    end;\n  end;\n  \n  \/\/ Determine the suspects who lied and told the truth\n  for i := 0 to n-1 do\n  begin\n    if countTruth = m then\n    begin\n      if isTruth[i] then\n        WriteLn('Truth')\n      else\n        WriteLn('Lie');\n    end\n    else if countLie = n - m then\n    begin\n      if isLie[i] then\n        WriteLn('Lie')\n      else\n        WriteLn('Truth');\n    end\n    else\n      WriteLn('Not defined');\n  end;\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := scanner.Text()\\n\\tn, _ := strconv.Atoi(string(nm[0]))\\n\\tm, _ := strconv.Atoi(string(nm[2]))\\n\\n\\tanswers := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tanswers[i] = scanner.Text()\\n\\t}\\n\\n\\ttruth := make([]bool, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ttruth[i] = true\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif answers[i][0] == '+' {\\n\\t\\t\\tsuspect, _ := strconv.Atoi(string(answers[i][1]))\\n\\t\\t\\tif truth[suspect-1] {\\n\\t\\t\\t\\ttruth[suspect-1] = true\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttruth[suspect-1] = false\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tsuspect, _ := strconv.Atoi(string(answers[i][1]))\\n\\t\\t\\tif truth[suspect-1] {\\n\\t\\t\\t\\ttruth[suspect-1] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttruth[suspect-1] = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tresult := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif truth[i] {\\n\\t\\t\\tresult[i] = \\\"Truth\\\"\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = \\\"Lie\\\"\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif !truth[i] {\\n\\t\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\t\\tif i != j && result[j] == \\\"Truth\\\" {\\n\\t\\t\\t\\t\\tresult[i] = \\\"Not defined\\\"\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Println(result[i])\\n\\t}\\n}","Javascript":"function findSuspect(n, m, answers) {\n    let truth = new Array(n).fill(0);\n    let lie = new Array(n).fill(0);\n    \n    for(let i = 0; i < n; i++) {\n        let answer = answers[i];\n        let ai = parseInt(answer.substring(1));\n        \n        if(answer[0] === '+') {\n            truth[ai-1]++;\n        } else {\n            lie[ai-1]++;\n        }\n    }\n    \n    let result = [];\n    \n    for(let i = 0; i < n; i++) {\n        if(truth[i] + lie[i] === m) {\n            result.push('Truth');\n        } else if(truth[i] === 0) {\n            result.push('Lie');\n        } else {\n            result.push('Not defined');\n        }\n    }\n    \n    return result.join('\\\\n');\n}\n\nlet inputs = ['1 1\\\\n+1\\\\n', '3 2\\\\n-1\\\\n-2\\\\n-3\\\\n', '4 1\\\\n+2\\\\n-3\\\\n+4\\\\n-1\\\\n'];\nlet outputs = [];\n\nfor(let i = 0; i < inputs.length; i++) {\n    let lines = inputs[i].split('\\\\n');\n    let [n, m] = lines[0].split(' ').map(Number);\n    let answers = lines.slice(1, n+1);\n    \n    outputs.push(findSuspect(n, m, answers));\n}\n\nJSON.stringify({\"version\": \"JavaScript\", \"source code\": outputs})","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n\n    val answers = mutableListOf<String>()\n    for (i in 0 until n) {\n        answers.add(scanner.nextLine())\n    }\n\n    val truth = mutableSetOf<Int>()\n    val lie = mutableSetOf<Int>()\n\n    for (i in 0 until n) {\n        val answer = answers[i]\n        val ai = answer.substring(1).toInt()\n\n        if (answer[0] == '+') {\n            truth.add(ai)\n        } else {\n            lie.add(ai)\n        }\n    }\n\n    val result = mutableListOf<String>()\n    for (i in 1..n) {\n        if (truth.contains(i) && lie.contains(i)) {\n            result.add(\"Not defined\")\n        } else if (truth.contains(i)) {\n            result.add(\"Truth\")\n        } else {\n            result.add(\"Lie\")\n        }\n    }\n\n    for (res in result) {\n        println(res)\n    }\n}","PHP":"\n<?php\n\nfunction findSuspect($input) {\n    $lines = explode('\\n', $input);\n    $nm = explode(' ', $lines[0]);\n    $n = intval($nm[0]);\n    $m = intval($nm[1]);\n    \n    $answers = array();\n    for ($i = 1; $i <= $n; $i++) {\n        $answers[$i] = $lines[$i];\n    }\n    \n    $truth = array();\n    $lie = array();\n    $notDefined = array();\n    \n    for ($i = 1; $i <= $n; $i++) {\n        $answer = $answers[$i];\n        $isTruth = substr($answer, 0, 1) == '+';\n        $suspect = intval(substr($answer, 1));\n        \n        if ($isTruth) {\n            $truth[] = $i;\n        } else {\n            $lie[] = $i;\n        }\n        \n        if ($suspect != $i) {\n            $notDefined[] = $i;\n        }\n    }\n    \n    $output = array();\n    \n    foreach ($truth as $t) {\n        $output[$t] = 'Truth';\n    }\n    \n    foreach ($lie as $l) {\n        $output[$l] = 'Lie';\n    }\n    \n    foreach ($notDefined as $nd) {\n        $output[$nd] = 'Not defined';\n    }\n    \n    $result = '';\n    \n    for ($i = 1; $i <= $n; $i++) {\n        $result .= $output[$i] . '\\n';\n    }\n    \n    return $result;\n}\n\n$input = '1 1\\n+1\\n';\n$output = findSuspect($input);\necho $output;\n\n$input = '3 2\\n-1\\n-2\\n-3\\n';\n$output = findSuspect($input);\necho $output;\n\n$input = '4 1\\n+2\\n-3\\n+4\\n-1\\n';\n$output = findSuspect($input);\necho $output;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[] truth = new int[m];\\r\\n    int[] lie = new int[n - m];\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        char[] input = readln.chomp;\\r\\n        char sign = input[0];\\r\\n        int suspect = to!int(input[1..$]);\\r\\n\\r\\n        if (sign == '+')\\r\\n        {\\r\\n            truth[i] = suspect;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            lie[i - m] = suspect;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for (int i = 1; i <= n; i++)\\r\\n    {\\r\\n        if (truth.canFind(i))\\r\\n        {\\r\\n            writeln(\\\"Truth\\\");\\r\\n        }\\r\\n        else if (lie.canFind(i))\\r\\n        {\\r\\n            writeln(\\\"Lie\\\");\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            writeln(\\\"Not defined\\\");\\r\\n        }\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_truth {\n    my ($n, $m, @answers) = @_;\n\n    my @truth = ();\n    my @lie = ();\n    my @not_defined = ();\n\n    for my $i (0..$n-1) {\n        my $answer = $answers[$i];\n        my ($sign, $suspect) = split('', $answer);\n\n        if ($sign eq '+') {\n            push @truth, $i+1;\n        } else {\n            push @lie, $i+1;\n        }\n    }\n\n    if (@truth == $m) {\n        for my $i (1..$n) {\n            if (grep { $_ == $i } @truth) {\n                push @not_defined, 'Truth';\n            } else {\n                push @not_defined, 'Lie';\n            }\n        }\n    } else {\n        for my $i (1..$n) {\n            if (grep { $_ == $i } @truth) {\n                push @not_defined, 'Not defined';\n            } elsif (grep { $_ == $i } @lie) {\n                push @not_defined, 'Lie';\n            } else {\n                push @not_defined, 'Truth';\n            }\n        }\n    }\n\n    return \\@not_defined;\n}\n\n# Example usage\nmy @answers = ('+1');\nmy $result = find_truth(1, 1, @answers);\nprint join('\\n', @$result);\n\n@answers = ('-1', '-2', '-3');\n$result = find_truth(3, 2, @answers);\nprint join('\\n', @$result);\n\n@answers = ('+2', '-3', '+4', '-1');\n$result = find_truth(4, 1, @answers);\nprint join('\\n', @$result);\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nm: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n    \n    let mut answers: Vec<String> = Vec::new();\n    for _ in 0..n {\n        answers.push(lines.next().unwrap());\n    }\n    \n    let mut truth: Vec<bool> = vec![false; n];\n    let mut lie: Vec<bool> = vec![false; n];\n    \n    for i in 0..n {\n        let ai: usize = answers[i][1..].parse().unwrap();\n        \n        if answers[i].starts_with('+') {\n            truth[ai - 1] = true;\n        } else {\n            lie[ai - 1] = true;\n        }\n    }\n    \n    let mut result: Vec<String> = Vec::new();\n    for i in 0..n {\n        if truth[i] && !lie[i] {\n            result.push(\"Truth\".to_string());\n        } else if !truth[i] && lie[i] {\n            result.push(\"Lie\".to_string());\n        } else {\n            result.push(\"Not defined\".to_string());\n        }\n    }\n    \n    for res in result {\n        println!(\"{}\", res);\n    }\n}"}
{"title":"D. Clues","description":"As Sherlock Holmes was investigating another crime, he found a certain number of clues. Also, he has already found direct links between some of those clues. The direct links between the clues are mutual. That is, the direct link between clues A and B and the direct link between clues B and A is the same thing. No more than one direct link can exist between two clues.Of course Sherlock is able to find direct links between all clues. But it will take too much time and the criminals can use this extra time to hide. To solve the crime, Sherlock needs each clue to be linked to all other clues (maybe not directly, via some other clues). Clues A and B are considered linked either if there is a direct link between them or if there is a direct link between A and some other clue C which is linked to B. Sherlock Holmes counted the minimum number of additional direct links that he needs to find to solve the crime. As it turns out, it equals T.Please count the number of different ways to find exactly T direct links between the clues so that the crime is solved in the end. Two ways to find direct links are considered different if there exist two clues which have a direct link in one way and do not have a direct link in the other way. As the number of different ways can turn out rather big, print it modulo k.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three space-separated integers n,m,k (1\u2264n\u226410^5,0\u2264m\u226410^5, 1\u2264k\u226410^9) \u2014 the number of clues, the number of direct clue links that Holmes has already found and the divisor for the modulo operation.\nEach of next m lines contains two integers a and b (1\u2264a,b\u2264n,a\u2260b), that represent a direct link between clues. It is guaranteed that any two clues are linked by no more than one direct link. Note that the direct links between the clues are mutual.\n","output_spec":"Print the single number \u2014 the answer to the problem modulo k.\n","notes":"The first sample only has two clues and Sherlock hasn't found any direct link between them yet. The only way to solve the crime is to find the link.\nThe second sample has three clues and Sherlock hasn't found any direct links between them. He has to find two of three possible direct links between clues to solve the crime \u2014 there are 3 ways to do it.\nThe third sample has four clues and the detective has already found one direct link between the first and the fourth clue. There are 8 ways to find two remaining clues to solve the crime.\n","sample_inputs":["2 0 1000000000\n","3 0 100\n","4 1 1000000000\n1 4\n"],"sample_outputs":["1\n","3\n","8\n"],"id":"156-D","difficulty":2500,"tags":["combinatorics","graphs"],"src_uid":"b244d5c52acda47c5e8ef92029a9635f","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nconst int MOD = 1000000000;\\n\\nint main() {\\n    int n, m, k;\\n    cin >> n >> m >> k;\\n    vector<vector<int>> adj(n + 1);\\n    vector<int> degree(n + 1);\\n    for (int i = 0; i < m; i++) {\\n        int a, b;\\n        cin >> a >> b;\\n        adj[a].push_back(b);\\n        adj[b].push_back(a);\\n        degree[a]++;\\n        degree[b]++;\\n    }\\n    long long ans = 1;\\n    for (int i = 1; i <= n; i++) {\\n        ans = (ans * degree[i]) % MOD;\\n    }\\n    cout << ans << endl;\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class SherlockHolmes {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        int n = Integer.parseInt(input[0]);\\n        int m = Integer.parseInt(input[1]);\\n        int k = Integer.parseInt(input[2]);\\n\\n        List<Integer>[] graph = new List[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            String[] link = scanner.nextLine().split(\\\" \\\");\\n            int a = Integer.parseInt(link[0]);\\n            int b = Integer.parseInt(link[1]);\\n            graph[a].add(b);\\n            graph[b].add(a);\\n        }\\n\\n        long[] dp = new long[n + 1];\\n        dp[1] = 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = (dp[i - 1] * i) % k;\\n        }\\n\\n        long ans = dp[n];\\n        for (int i = 1; i <= n; i++) {\\n            int size = graph[i].size();\\n            ans = (ans * modInverse(dp[size], k)) % k;\\n        }\\n\\n        System.out.println(ans);\\n    }\\n\\n    private static long modInverse(long a, long m) {\\n        long m0 = m;\\n        long y = 0, x = 1;\\n\\n        if (m == 1)\\n            return 0;\\n\\n        while (a > 1) {\\n            long q = a \/ m;\\n            long t = m;\\n\\n            m = a % m;\\n            a = t;\\n            t = y;\\n\\n            y = x - q * y;\\n            x = t;\\n        }\\n\\n        if (x < 0)\\n            x += m0;\\n\\n        return x;\\n    }\\n}\"}}","Python":"from collections import defaultdict\\n\\ndef solve_crime(n, m, k, links):\\n    # Create adjacency list\\n    adj_list = defaultdict(list)\\n    for a, b in links:\\n        adj_list[a].append(b)\\n        adj_list[b].append(a)\\n    \\n    # Calculate the number of direct links needed\\n    t = n * (n - 1) \/\/ 2 - m\\n    \\n    # Calculate the number of ways to find t direct links\\n    num_ways = pow(n, t, k)\\n    \\n    return num_ways\\n\\n\\n# Read input\\nn, m, k = map(int, input().split())\\nlinks = [tuple(map(int, input().split())) for _ in range(m)]\\n\\n# Solve the crime\\nresult = solve_crime(n, m, k, links)\\n\\n# Print the result\\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXN 100005\\n\\nint parent[MAXN];\\nint size[MAXN];\\n\\nint find(int x) {\\n    if (parent[x] != x) {\\n        parent[x] = find(parent[x]);\\n    }\\n    return parent[x];\\n}\\n\\nvoid union_sets(int a, int b) {\\n    a = find(a);\\n    b = find(b);\\n    if (a != b) {\\n        if (size[a] < size[b]) {\\n            int temp = a;\\n            a = b;\\n            b = temp;\\n        }\\n        parent[b] = a;\\n        size[a] += size[b];\\n    }\\n}\\n\\nint main() {\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n\\n    for (int i = 1; i <= n; i++) {\\n        parent[i] = i;\\n        size[i] = 1;\\n    }\\n\\n    for (int i = 0; i < m; i++) {\\n        int a, b;\\n        scanf(\\\"%d %d\\\", &a, &b);\\n        union_sets(a, b);\\n    }\\n\\n    int components = 0;\\n    for (int i = 1; i <= n; i++) {\\n        if (parent[i] == i) {\\n            components++;\\n        }\\n    }\\n\\n    long long int ans = 1;\\n    for (int i = 0; i < components - 1; i++) {\\n        ans = (ans * n) % k;\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", ans);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace SherlockHolmes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n            int k = int.Parse(input[2]);\n\n            List<int>[] graph = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int a = int.Parse(input[0]);\n                int b = int.Parse(input[1]);\n                graph[a].Add(b);\n                graph[b].Add(a);\n            }\n\n            long[] dp = new long[n + 1];\n            dp[1] = 1;\n\n            for (int i = 2; i <= n; i++)\n            {\n                dp[i] = (dp[i - 1] * i) % k;\n            }\n\n            long result = 1;\n            bool[] visited = new bool[n + 1];\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (!visited[i])\n                {\n                    int count = 0;\n                    DFS(i, graph, visited, ref count);\n                    result = (result * dp[count]) % k;\n                }\n            }\n\n            Console.WriteLine(result);\n        }\n\n        static void DFS(int node, List<int>[] graph, bool[] visited, ref int count)\n        {\n            visited[node] = true;\n            count++;\n\n            foreach (int neighbor in graph[node])\n            {\n                if (!visited[neighbor])\n                {\n                    DFS(neighbor, graph, visited, ref count);\n                }\n            }\n        }\n    }\n}","Ruby":"\n# Read input\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\nk = input[2].to_i\n\n# Initialize adjacency list\nadj_list = Array.new(n+1) { [] }\n\n# Read direct links\nm.times do\n  link = gets.chomp.split(' ')\n  a = link[0].to_i\n  b = link[1].to_i\n  adj_list[a] << b\n  adj_list[b] << a\nend\n\n# Initialize visited array\nvisited = Array.new(n+1, false)\n\n# Function to perform DFS\ndef dfs(node, adj_list, visited)\n  visited[node] = true\n  adj_list[node].each do |neighbor|\n    dfs(neighbor, adj_list, visited) unless visited[neighbor]\n  end\nend\n\n# Count the number of connected components\nconnected_components = 0\n(1..n).each do |node|\n  unless visited[node]\n    dfs(node, adj_list, visited)\n    connected_components += 1\n  end\nend\n\n# Calculate the number of additional direct links needed\nadditional_links = n - connected_components\n\n# Calculate the number of different ways to find the additional links\nways = 1\nadditional_links.times do\n  ways = (ways * 2) % k\nend\n\n# Print the result\nputs ways\n","delphi":"program SherlockHolmes;\n\nvar\n  n, m, k, T, i, j, a, b: Integer;\n  links: array of array of Boolean;\n  visited: array of Boolean;\n  count: Int64;\n\nprocedure DFS(v: Integer);\nvar\n  i: Integer;\nbegin\n  visited[v] := True;\n  for i := 1 to n do\n  begin\n    if (links[v][i]) and (not visited[i]) then\n      DFS(i);\n  end;\nend;\n\nbegin\n  ReadLn(n, m, k);\n  \n  SetLength(links, n + 1);\n  for i := 1 to n do\n    SetLength(links[i], n + 1);\n  \n  for i := 1 to m do\n  begin\n    ReadLn(a, b);\n    links[a][b] := True;\n    links[b][a] := True;\n  end;\n  \n  SetLength(visited, n + 1);\n  \n  T := n * (n - 1) div 2 - m;\n  \n  count := 1;\n  for i := 1 to n do\n  begin\n    if not visited[i] then\n    begin\n      DFS(i);\n      count := (count * 2) mod k;\n    end;\n  end;\n  \n  count := (count * Power(2, T - 1, k)) mod k;\n  \n  WriteLn(count);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tm, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tk, _ := strconv.Atoi(scanner.Text())\\n\\n\\tlinks := make([][]int, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\ta, _ := strconv.Atoi(scanner.Text())\\n\\t\\tscanner.Scan()\\n\\t\\tb, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\\tlinks[a] = append(links[a], b)\\n\\t\\tlinks[b] = append(links[b], a)\\n\\t}\\n\\n\\tcount := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tcount += (n - 1 - len(links[i])) * len(links[i])\\n\\t}\\n\\n\\tcount \/= 2\\n\\tcount += n\\n\\n\\tcount %= k\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function solveCrime(input) {\n  const [n, m, k] = input[0].split(' ').map(Number);\n  const links = new Array(n + 1).fill(0);\n  const mod = 1000000000;\n\n  for (let i = 1; i <= m; i++) {\n    const [a, b] = input[i].split(' ').map(Number);\n    links[a]++;\n    links[b]++;\n  }\n\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    count += (n - 1 - links[i]) * links[i];\n  }\n\n  count \/= 2;\n  count += n;\n\n  return (count % k).toString();\n}\n\nconst input = ['2 0 1000000000\\n', '3 0 100\\n', '4 1 1000000000\\n1 4\\n'];\nconst output = solveCrime(input);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val k = input[2].toLong()\n\n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    val visited = BooleanArray(n + 1)\n    val mod = 1000000007L\n\n    repeat(m) {\n        val (a, b) = readLine()!!.split(\" \").map { it.toInt() }\n        graph[a].add(b)\n        graph[b].add(a)\n    }\n\n    fun dfs(node: Int): Long {\n        visited[node] = true\n        var count = 1L\n        for (neighbor in graph[node]) {\n            if (!visited[neighbor]) {\n                count = (count * dfs(neighbor)) % mod\n            }\n        }\n        return count\n    }\n\n    var result = 1L\n    for (i in 1..n) {\n        if (!visited[i]) {\n            val count = dfs(i)\n            result = (result * count) % mod\n        }\n    }\n\n    result = (result * (k - 1)) % mod\n    println(result)\n}","PHP":"\n<?php\n\nfunction solveCrime($n, $m, $k, $links) {\n    $adjList = array_fill(1, $n, []);\n    $visited = array_fill(1, $n, false);\n    $mod = 1000000000;\n    \n    \/\/ Create adjacency list\n    foreach ($links as $link) {\n        $a = $link[0];\n        $b = $link[1];\n        $adjList[$a][] = $b;\n        $adjList[$b][] = $a;\n    }\n    \n    \/\/ DFS to count connected components\n    $components = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        if (!$visited[$i]) {\n            dfs($i, $adjList, $visited);\n            $components++;\n        }\n    }\n    \n    \/\/ Calculate number of ways to find T direct links\n    $numWays = 1;\n    for ($i = 0; $i < $components; $i++) {\n        $numWays = ($numWays * $n) % $mod;\n    }\n    $numWays = ($numWays - $components + $mod) % $mod;\n    \n    return $numWays;\n}\n\nfunction dfs($node, $adjList, &$visited) {\n    $visited[$node] = true;\n    foreach ($adjList[$node] as $neighbor) {\n        if (!$visited[$neighbor]) {\n            dfs($neighbor, $adjList, $visited);\n        }\n    }\n}\n\n\/\/ Read input\n$input = explode(' ', trim(fgets(STDIN)));\n$n = intval($input[0]);\n$m = intval($input[1]);\n$k = intval($input[2]);\n\n$links = [];\nfor ($i = 0; $i < $m; $i++) {\n    $input = explode(' ', trim(fgets(STDIN)));\n    $a = intval($input[0]);\n    $b = intval($input[1]);\n    $links[] = [$a, $b];\n}\n\n\/\/ Solve the crime\n$result = solveCrime($n, $m, $k, $links);\n\n\/\/ Print the result\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, k;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &k);\\r\\n\\r\\n    \/\/ Create a graph to represent the clues and their direct links\\r\\n    auto graph = new Graph!int();\\r\\n\\r\\n    \/\/ Read the direct links between clues\\r\\n    for (int i = 0; i < m; i++)\\r\\n    {\\r\\n        int a, b;\\r\\n        readf(\\\"%d %d\\\", &a, &b);\\r\\n\\r\\n        \/\/ Add the direct link between clues to the graph\\r\\n        graph.addEdge(a, b);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate the number of additional direct links needed to solve the crime\\r\\n    int additionalLinks = 0;\\r\\n    foreach (int clue; 1 .. n + 1)\\r\\n    {\\r\\n        int existingLinks = graph[clue].length;\\r\\n        int neededLinks = n - existingLinks - 1;\\r\\n\\r\\n        \/\/ Add the number of additional links needed for this clue\\r\\n        additionalLinks += neededLinks;\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate the number of different ways to find the additional links\\r\\n    int ways = pow(2, additionalLinks) % k;\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(ways);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub solve_crime {\\n    my ($n, $m, $k, @links) = @_;\\n    my %clues;\\n    my %direct_links;\\n    my %indirect_links;\\n\\n    # Initialize clues\\n    for my $i (1..$n) {\\n        $clues{$i} = 0;\\n    }\\n\\n    # Process direct links\\n    for my $link (@links) {\\n        my ($a, $b) = split(' ', $link);\\n        $direct_links{$a}{$b} = 1;\\n        $direct_links{$b}{$a} = 1;\\n        $clues{$a}++;\\n        $clues{$b}++;\\n    }\\n\\n    # Process indirect links\\n    for my $i (1..$n) {\\n        for my $j (1..$n) {\\n            next if $i == $j;\\n            next if exists $direct_links{$i}{$j};\\n\\n            my $count = 0;\\n            for my $k (keys %{$direct_links{$i}}) {\\n                $count++ if exists $direct_links{$k}{$j};\\n            }\\n\\n            $indirect_links{$i}{$j} = $count;\\n        }\\n    }\\n\\n    # Calculate the number of ways to find T direct links\\n    my $total_ways = 0;\\n    for my $i (1..$n) {\\n        my $remaining_links = $n - $clues{$i};\\n        my $ways = 1;\\n\\n        for my $j (1..$remaining_links) {\\n            $ways = ($ways * $j) % $k;\\n        }\\n\\n        $total_ways = ($total_ways + $ways) % $k;\\n    }\\n\\n    return $total_ways;\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $m, $k) = split(' ', $input);\\nmy @links;\\n\\nfor (1..$m) {\\n    my $link = <STDIN>;\\n    chomp $link;\\n    push @links, $link;\\n}\\n\\n# Solve the crime\\nmy $result = solve_crime($n, $m, $k, @links);\\n\\n# Print the result\\nprint $result . \\\"\\\\n\\\";\\n","Rust":"fn main() {\\n    let input = \\\"4 1 1000000000\\\\n1 4\\\\n\\\";\\n    let mut lines = input.lines();\\n    let nmk: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nmk[0];\\n    let m = nmk[1];\\n    let k = nmk[2];\\n    let mut adj_list: Vec<Vec<usize>> = vec![vec![]; n + 1];\\n    let mut visited: Vec<bool> = vec![false; n + 1];\\n    let mut count: usize = 0;\\n\\n    for _ in 0..m {\\n        let ab: Vec<usize> = lines\\n            .next()\\n            .unwrap()\\n            .split_whitespace()\\n            .map(|x| x.parse().unwrap())\\n            .collect();\\n        let a = ab[0];\\n        let b = ab[1];\\n        adj_list[a].push(b);\\n        adj_list[b].push(a);\\n    }\\n\\n    for i in 1..=n {\\n        if !visited[i] {\\n            dfs(i, &mut visited, &adj_list);\\n            count += 1;\\n        }\\n    }\\n\\n    let result = mod_pow(2, count - 1, k);\\n    println!(\\\"{}\\\", result);\\n}\\n\\nfn dfs(node: usize, visited: &mut Vec<bool>, adj_list: &Vec<Vec<usize>>) {\\n    visited[node] = true;\\n\\n    for &neighbour in &adj_list[node] {\\n        if !visited[neighbour] {\\n            dfs(neighbour, visited, adj_list);\\n        }\\n    }\\n}\\n\\nfn mod_pow(base: usize, exponent: usize, modulus: usize) -> usize {\\n    if modulus == 1 {\\n        return 0;\\n    }\\n\\n    let mut result = 1;\\n    let mut base = base % modulus;\\n    let mut exponent = exponent;\\n\\n    while exponent > 0 {\\n        if exponent % 2 == 1 {\\n            result = (result * base) % modulus;\\n        }\\n\\n        exponent >>= 1;\\n        base = (base * base) % modulus;\\n    }\\n\\n    result\\n}"}
{"title":"A. Cottage Village","description":"A new cottage village called \u00abFlatville\u00bb is being built in Flatland. By now they have already built in \u00abFlatville\u00bb n square houses with the centres on the \u041ex-axis. The houses' sides are parallel to the coordinate axes. It's known that no two houses overlap, but they can touch each other.The architect bureau, where Peter works, was commissioned to build a new house in \u00abFlatville\u00bb. The customer wants his future house to be on the \u041ex-axis, to be square in shape, have a side t, and touch at least one of the already built houses. For sure, its sides should be parallel to the coordinate axes, its centre should be on the Ox-axis and it shouldn't overlap any of the houses in the village.Peter was given a list of all the houses in \u00abFlatville\u00bb. Would you help him find the amount of possible positions of the new house?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"64 megabytes","input_spec":"The first line of the input data contains numbers n and t (1\u2264n,t\u22641000). Then there follow n lines, each of them contains two space-separated integer numbers: xi ai, where xi \u2014 x-coordinate of the centre of the i-th house, and ai \u2014 length of its side (-1000\u2264xi\u22641000, 1\u2264ai\u22641000).\n","output_spec":"Output the amount of possible positions of the new house.\n","notes":"It is possible for the x-coordinate of the new house to have non-integer value.\n","sample_inputs":["2 2\n0 4\n6 2\n","2 2\n0 4\n5 2\n","2 3\n0 4\n5 2\n"],"sample_outputs":["4\n","3\n","2\n"],"id":"15-A","difficulty":1200,"tags":["implementation","sortings"],"src_uid":"c31fed523230af1f904218b2fe0d663d","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, t;\\n    cin >> n >> t;\\n    vector<pair<int, int>> houses;\\n    for (int i = 0; i < n; i++) {\\n        int x, a;\\n        cin >> x >> a;\\n        houses.push_back(make_pair(x, a));\\n    }\\n    sort(houses.begin(), houses.end());\\n    int count = 2;\\n    for (int i = 1; i < n; i++) {\\n        int distance = houses[i].first - houses[i - 1].first;\\n        if (distance > t)\\n            count += 2;\\n        else if (distance == t)\\n            count++;\\n    }\\n    cout << count << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Flatville {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] inputArr = input.split(\\\" \\\");\n        int n = Integer.parseInt(inputArr[0]);\n        int t = Integer.parseInt(inputArr[1]);\n        \n        List<Integer> houses = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            String houseInput = scanner.nextLine();\n            String[] houseArr = houseInput.split(\\\" \\\");\n            int xi = Integer.parseInt(houseArr[0]);\n            int ai = Integer.parseInt(houseArr[1]);\n            houses.add(xi - ai\/2);\n            houses.add(xi + ai\/2);\n        }\n        \n        Collections.sort(houses);\n        \n        int count = 0;\n        for (int i = 1; i < houses.size(); i += 2) {\n            int gap = houses.get(i) - houses.get(i-1) - 1;\n            count += Math.max(0, gap - t);\n        }\n        \n        System.out.println(count);\n    }\n}","Python":"def possible_positions(input_data):\\n    n, t = map(int, input_data[0].split())\\n    houses = [list(map(int, line.split())) for line in input_data[1:]]\\n    positions = 0\\n\\n    for house in houses:\\n        x, a = house\\n        left = x - a\/2 - t\/2\\n        right = x + a\/2 + t\/2\\n\\n        if left > houses[-1][0] + houses[-1][1]\/2:\\n            positions += 1\\n        elif right < houses[0][0] - houses[0][1]\/2:\\n            positions += 1\\n        elif left > houses[0][0] + houses[0][1]\/2:\\n            positions += 1\\n        elif right < houses[-1][0] - houses[-1][1]\/2:\\n            positions += 1\\n\\n    return str(positions)\\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, t;\\n    scanf(\\\"%d %d\\\", &n, &t);\\n    int x[n], a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d %d\\\", &x[i], &a[i]);\\n    }\\n\\n    int count = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (x[i] - a[i] <= 0 && x[i] + a[i] >= t) {\\n            count++;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace Flatville\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int t = int.Parse(inputArr[1]);\n\n            List<int[]> houses = new List<int[]>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string houseInput = Console.ReadLine();\n                string[] houseInputArr = houseInput.Split(' ');\n                int xi = int.Parse(houseInputArr[0]);\n                int ai = int.Parse(houseInputArr[1]);\n\n                houses.Add(new int[] { xi, ai });\n            }\n\n            int count = 0;\n\n            foreach (int[] house in houses)\n            {\n                int xi = house[0];\n                int ai = house[1];\n\n                if (Math.Abs(xi) - ai \/ 2 <= t \/ 2)\n                {\n                    count++;\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n    }\n}","Ruby":"def possible_positions(input)\n  n, t, *houses = input.split(\"\\n\")\n  n = n.to_i\n  t = t.to_i\n  houses = houses.map { |house| house.split.map(&:to_i) }\n\n  positions = 0\n\n  houses.each do |house|\n    x = house[0]\n    a = house[1]\n\n    left = x - (t \/ 2)\n    right = x + (t \/ 2)\n\n    if left <= -1000 && right >= 1000\n      positions += 2\n    elsif left <= -1000 || right >= 1000\n      positions += 1\n    end\n  end\n\n  positions.to_s\nend\n\ninputs = ['2 2\\n0 4\\n6 2\\n', '2 2\\n0 4\\n5 2\\n', '2 3\\n0 4\\n5 2\\n']\noutputs = []\n\ninputs.each do |input|\n  output = possible_positions(input)\n  outputs << output\nend\n\noutputs.to_json","delphi":"program Flatville;\\n\\nvar\\n  n, t, i, x, a, count: integer;\\n  possiblePositions: integer;\\n\\nbegin\\n  readln(n, t);\\n  possiblePositions := 0;\\n  for i := 1 to n do\\n  begin\\n    readln(x, a);\\n    if (x - a\/2 <= 0) and (x + a\/2 >= t) then\\n      Inc(possiblePositions)\\n    else if (x - a\/2 <= t) and (x + a\/2 >= 0) then\\n      Inc(possiblePositions);\\n  end;\\n  writeln(possiblePositions);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnt := scanner.Text()\\n\\tn, _ := strconv.Atoi(string(nt[0]))\\n\\tt, _ := strconv.Atoi(string(nt[2]))\\n\\n\\thouses := make([][]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\th := scanner.Text()\\n\\t\\tx, _ := strconv.Atoi(string(h[0]))\\n\\t\\ta, _ := strconv.Atoi(string(h[2]))\\n\\t\\thouses[i] = []int{x, a}\\n\\t}\\n\\n\\tpossiblePositions := 0\\n\\n\\tfor _, house := range houses {\\n\\t\\tleft := house[0] - house[1]\/2 - t\/2\\n\\t\\tright := house[0] + house[1]\/2 + t\/2\\n\\n\\t\\tif left > -1000 && right < 1000 {\\n\\t\\t\\tpossiblePositions++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(possiblePositions)\\n}","Javascript":"function countPossiblePositions(input) {\n  const lines = input.split('\\\\n');\n  const [n, t] = lines[0].split(' ').map(Number);\n  const houses = [];\n  \n  for (let i = 1; i <= n; i++) {\n    const [x, a] = lines[i].split(' ').map(Number);\n    houses.push({ x, a });\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < n; i++) {\n    const house = houses[i];\n    const left = house.x - house.a \/ 2;\n    const right = house.x + house.a \/ 2;\n    \n    if (left - t \/ 2 >= -1000 && left - t \/ 2 <= right + t \/ 2) {\n      count++;\n    }\n    \n    if (right + t \/ 2 <= 1000 && right + t \/ 2 >= left - t \/ 2) {\n      count++;\n    }\n  }\n  \n  return count.toString();\n}\n\nconst inputs = ['2 2\\\\n0 4\\\\n6 2\\\\n', '2 2\\\\n0 4\\\\n5 2\\\\n', '2 3\\\\n0 4\\\\n5 2\\\\n'];\nconst outputs = inputs.map(countPossiblePositions);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val t = input[1].toInt()\n\n    val houses = mutableListOf<Pair<Int, Int>>()\n    for (i in 0 until n) {\n        val houseInput = scanner.nextLine().split(\" \")\n        val xi = houseInput[0].toInt()\n        val ai = houseInput[1].toInt()\n        houses.add(Pair(xi, ai))\n    }\n\n    val possiblePositions = findPossiblePositions(houses, t)\n    println(possiblePositions)\n}\n\nfun findPossiblePositions(houses: List<Pair<Int, Int>>, t: Int): Int {\n    var count = 0\n    for (house in houses) {\n        val xi = house.first\n        val ai = house.second\n\n        val left = xi - ai \/ 2 - t\n        val right = xi + ai \/ 2 + t\n\n        if (left <= 0 && right >= 0) {\n            count++\n        }\n    }\n    return count\n}","PHP":"<?php\\n\\nfunction countPossiblePositions($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $firstLine = explode(\\\" \\\", $lines[0]);\\n    $n = intval($firstLine[0]);\\n    $t = intval($firstLine[1]);\\n    $houses = [];\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $houseData = explode(\\\" \\\", $lines[$i]);\\n        $x = intval($houseData[0]);\\n        $a = intval($houseData[1]);\\n        $houses[] = [$x, $a];\\n    }\\n\\n    $possiblePositions = 0;\\n\\n    foreach ($houses as $house) {\\n        $x = $house[0];\\n        $a = $house[1];\\n\\n        $left = $x - ($t \/ 2);\\n        $right = $x + ($t \/ 2);\\n\\n        $validPosition = true;\\n\\n        foreach ($houses as $otherHouse) {\\n            $otherX = $otherHouse[0];\\n            $otherA = $otherHouse[1];\\n\\n            if (($otherX >= $left && $otherX <= $right) || ($otherX + $otherA >= $left && $otherX + $otherA <= $right)) {\\n                $validPosition = false;\\n                break;\\n            }\\n        }\\n\\n        if ($validPosition) {\\n            $possiblePositions++;\\n        }\\n    }\\n\\n    return $possiblePositions;\\n}\\n\\n$input = '2 2\\\\n0 4\\\\n6 2\\\\n';\\n$result = countPossiblePositions($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nstruct House\\r\\n{\\r\\n    int x;\\r\\n    int a;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, t;\\r\\n    readf(\\\"%d %d\\\", &n, &t);\\r\\n\\r\\n    House[] houses;\\r\\n    foreach (_; 0 .. n)\\r\\n    {\\r\\n        int x, a;\\r\\n        readf(\\\"%d %d\\\", &x, &a);\\r\\n        houses ~= House(x, a);\\r\\n    }\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    foreach (house; houses)\\r\\n    {\\r\\n        int left = house.x - house.a \/ 2 - t;\\r\\n        int right = house.x + house.a \/ 2 + t;\\r\\n\\r\\n        if (left <= -1000)\\r\\n            left = -1000;\\r\\n\\r\\n        if (right >= 1000)\\r\\n            right = 1000;\\r\\n\\r\\n        count += right - left + 1;\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_possible_positions {\n    my ($n, $t, @houses) = @_;\n\n    my $count = 0;\n\n    foreach my $house (@houses) {\n        my ($x, $a) = split(' ', $house);\n\n        # Check if the new house can be placed to the left of the current house\n        if ($x - $t\/2 >= -$a\/2) {\n            $count++;\n        }\n\n        # Check if the new house can be placed to the right of the current house\n        if ($x + $t\/2 <= $a\/2) {\n            $count++;\n        }\n    }\n\n    return $count;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\nmy ($n, $t) = split(' ', $input);\n\nmy @houses;\nfor (my $i = 0; $i < $n; $i++) {\n    my $house = <STDIN>;\n    chomp $house;\n    push @houses, $house;\n}\n\n# Call the function to count the possible positions\nmy $result = count_possible_positions($n, $t, @houses);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"2 2\\\\n0 4\\\\n6 2\\\\n\\\";\\n    let mut lines = input.lines();\\n    let first_line = lines.next().unwrap();\\n    let mut values = first_line.split_whitespace();\\n    let n: usize = values.next().unwrap().parse().unwrap();\\n    let t: usize = values.next().unwrap().parse().unwrap();\\n\\n    let mut houses = Vec::new();\\n    for _ in 0..n {\\n        let line = lines.next().unwrap();\\n        let mut values = line.split_whitespace();\\n        let xi: i32 = values.next().unwrap().parse().unwrap();\\n        let ai: i32 = values.next().unwrap().parse().unwrap();\\n        houses.push((xi, ai));\\n    }\\n\\n    let mut count = 0;\\n    for &(xi, ai) in &houses {\\n        if xi - ai \/ 2 <= -t \/ 2 {\\n            count += 1;\\n        }\\n        if xi + ai \/ 2 >= t \/ 2 {\\n            count += 1;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"B. Burning Midnight Oil","description":"One day a highly important task was commissioned to Vasya \u2014 writing a program in a night. The program consists of n lines of code. Vasya is already exhausted, so he works like that: first he writes v lines of code, drinks a cup of tea, then he writes as much as  lines, drinks another cup of tea, then he writes  lines and so on: , , , ...The expression  is regarded as the integral part from dividing number a by number b.The moment the current value  equals 0, Vasya immediately falls asleep and he wakes up only in the morning, when the program should already be finished.Vasya is wondering, what minimum allowable value v can take to let him write not less than n lines of code before he falls asleep.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The input consists of two integers n and k, separated by spaces \u2014 the size of the program in lines and the productivity reduction coefficient, 1\u2264n\u226410^9, 2\u2264k\u226410.\n","output_spec":"Print the only integer \u2014 the minimum value of v that lets Vasya write the program in one night.\n","notes":"In the first sample the answer is v=4. Vasya writes the code in the following portions: first 4 lines, then 2, then 1, and then Vasya falls asleep. Thus, he manages to write 4+2+1=7 lines in a night and complete the task.\nIn the second sample the answer is v=54. Vasya writes the code in the following portions: 54, 6. The total sum is 54+6=60, that's even more than n=59.\n","sample_inputs":["7 2\n","59 9\n"],"sample_outputs":["4\n","54\n"],"id":"165-B","difficulty":1500,"tags":["binary+search","implementation"],"src_uid":"41dfc86d341082dd96e089ac5433dc04","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n\\n    int v = ceil(n \/ (k * (k + 1) \/ 2.0));\\n\\n    cout << v << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class CodeDeveloper {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n\\n        int v = n \/ (k * (k + 1) \/ 2);\\n        int remainingLines = n - (v * (k * (k + 1) \/ 2));\\n\\n        int i = 1;\\n        while (remainingLines > 0) {\\n            remainingLines -= i;\\n            i++;\\n        }\\n\\n        v = v * k + i - 1;\\n\\n        System.out.println(v);\\n    }\\n}\" }","Python":"def minimum_v(n, k):\\n    v = n\\n    while v % k != 0:\\n        v -= 1\\n    return v\\n\\ninput_data = input().split()\\nn = int(input_data[0])\\nk = int(input_data[1])\\n\\nresult = minimum_v(n, k)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int v = n \/ (k * (k + 1) \/ 2);\\n    int remaining = n - (v * (k * (k + 1) \/ 2));\\n    int i = 1;\\n    while (remaining > 0) {\\n        remaining -= i;\\n        i++;\\n    }\\n    printf(\\\"%d\\\\n\\\", v * k + i);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        int n = int.Parse(input[0]);\n        int k = int.Parse(input[1]);\n        \n        int v = (n + k - 1) \/ k;\n        \n        Console.WriteLine(v);\n    }\n}","Ruby":"\ndef minimum_v(n, k)\n  v = n\n  while v > 0\n    sum = 0\n    lines = v\n    while lines > 0\n      sum += lines\n      lines = (lines \/ k).to_i\n    end\n    return v if sum >= n\n    v -= 1\n  end\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nk = input[1].to_i\n\nputs minimum_v(n, k)\n","delphi":"program MinimumV;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nvar\n  n, k, v, lines, sum: Integer;\n\nbegin\n  \/\/ Read input values\n  ReadLn(n, k);\n  \n  \/\/ Initialize variables\n  v := 1;\n  lines := 0;\n  sum := 0;\n  \n  \/\/ Calculate minimum value of v\n  while lines < n do\n  begin\n    sum := sum + v;\n    lines := lines + sum;\n    v := v * k;\n  end;\n  \n  \/\/ Print the result\n  WriteLn(v div k);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\n\\tv := n \/ (k*(k+1)\/2)\\n\\tremainder := n % (k*(k+1)\/2)\\n\\n\\tif remainder > 0 {\\n\\t\\tv++\\n\\t}\\n\\n\\tfmt.Println(v)\\n}","Javascript":"function findMinimumV(lines, k) {\n  let v = 1;\n  let totalLines = 0;\n  \n  while (totalLines < lines) {\n    totalLines += v;\n    v = Math.ceil(v \/ k);\n  }\n  \n  return v;\n}\n\nconst input = '7 2';\nconst [lines, k] = input.split(' ').map(Number);\n\nconst minimumV = findMinimumV(lines, k);\n\nconsole.log(minimumV);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val k = input[1].toInt()\n\n    var v = n \/ k\n    if (n % k != 0) {\n        v++\n    }\n\n    println(v)\n}","PHP":"\n<?php\n\nfunction findMinimumV($n, $k) {\n    $v = 1;\n    $linesWritten = 0;\n    \n    while ($linesWritten < $n) {\n        $linesWritten += $v;\n        $v *= $k;\n    }\n    \n    return $v \/ $k;\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$n = intval($input[0]);\n$k = intval($input[1]);\n\n$result = findMinimumV($n, $k);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    readf(\\\"%d %d\\\", &n, &k);\\r\\n\\r\\n    int v = 1;\\r\\n    int linesWritten = 0;\\r\\n\\r\\n    while (linesWritten < n)\\r\\n    {\\r\\n        linesWritten += v;\\r\\n        v = (v * k) + 1;\\r\\n    }\\r\\n\\r\\n    writeln(linesWritten);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_minimum_v {\n    my ($n, $k) = @_;\n\n    my $v = 1;\n    my $lines_written = 0;\n\n    while ($lines_written < $n) {\n        $lines_written += $v;\n        $v = int($v \/ $k);\n    }\n\n    return $v;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\n# Split input into n and k\nmy ($n, $k) = split(' ', $input);\n\n# Calculate minimum v\nmy $minimum_v = calculate_minimum_v($n, $k);\n\n# Print the result\nprint $minimum_v;\n","Rust":"\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n\n    let input = lines.next().unwrap();\n    let mut input_iter = input.split_whitespace();\n\n    let n: i64 = input_iter.next().unwrap().parse().unwrap();\n    let k: i64 = input_iter.next().unwrap().parse().unwrap();\n\n    let mut v = 1;\n    let mut lines_written = 0;\n\n    while lines_written < n {\n        lines_written += v;\n        v *= k;\n    }\n\n    println!(\"{}\", v \/ k);\n}\n"}
{"title":"B. Polygons","description":"You've got another geometrical task. You are given two non-degenerate polygons A and B as vertex coordinates. Polygon A is strictly convex. Polygon B is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.Your task is to check whether polygon B is positioned strictly inside polygon A. It means that any point of polygon B should be strictly inside polygon A. \"Strictly\" means that the vertex of polygon B cannot lie on the side of the polygon A.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains the only integer n (3\u2264n\u226410^5) \u2014 the number of vertices of polygon A. Then n lines contain pairs of integers xi,yi (|xi|,|yi|\u226410^9) \u2014 coordinates of the i-th vertex of polygon A. The vertices are given in the clockwise order.\nThe next line contains a single integer m (3\u2264m\u22642\u00b710^4) \u2014 the number of vertices of polygon B. Then following m lines contain pairs of integers xj,yj (|xj|,|yj|\u226410^9) \u2014 the coordinates of the j-th vertex of polygon B. The vertices are given in the clockwise order.\nThe coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons A and B are non-degenerate, that polygon A is strictly convex, that polygon B has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.\n","output_spec":"Print on the only line the answer to the problem \u2014 if polygon B is strictly inside polygon A, print \"YES\", otherwise print \"NO\" (without the quotes).\n","notes":null,"sample_inputs":["6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0\n","5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1\n","5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"id":"166-B","difficulty":2100,"tags":["geometry","sortings"],"src_uid":"d9eb0f6f82bd09ea53a1dbbd7242c497","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nstruct Point {\\n    int x, y;\\n};\\n\\nbool isInside(Point A[], int n, Point B[], int m) {\\n    for (int i = 0; i < m; i++) {\\n        bool inside = false;\\n        for (int j = 0; j < n; j++) {\\n            int next = (j + 1) % n;\\n            int crossProduct = (B[i].x - A[j].x) * (A[next].y - A[j].y) - (B[i].y - A[j].y) * (A[next].x - A[j].x);\\n            if (crossProduct == 0) {\\n                return false;\\n            }\\n            if ((A[j].y > B[i].y) != (A[next].y > B[i].y) && B[i].x < (A[next].x - A[j].x) * (B[i].y - A[j].y) \/ (A[next].y - A[j].y) + A[j].x) {\\n                inside = !inside;\\n            }\\n        }\\n        if (!inside) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    Point A[n];\\n    for (int i = 0; i < n; i++) {\\n        cin >> A[i].x >> A[i].y;\\n    }\\n    int m;\\n    cin >> m;\\n    Point B[m];\\n    for (int i = 0; i < m; i++) {\\n        cin >> B[i].x >> B[i].y;\\n    }\\n    if (isInside(A, n, B, m)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read the number of vertices of polygon A\n        int n = scanner.nextInt();\n        \n        \/\/ Read the coordinates of polygon A\n        int[][] polygonA = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            polygonA[i][0] = scanner.nextInt();\n            polygonA[i][1] = scanner.nextInt();\n        }\n        \n        \/\/ Read the number of vertices of polygon B\n        int m = scanner.nextInt();\n        \n        \/\/ Read the coordinates of polygon B\n        int[][] polygonB = new int[m][2];\n        for (int i = 0; i < m; i++) {\n            polygonB[i][0] = scanner.nextInt();\n            polygonB[i][1] = scanner.nextInt();\n        }\n        \n        \/\/ Check if polygon B is strictly inside polygon A\n        boolean isInside = isPolygonInside(polygonA, polygonB);\n        \n        \/\/ Print the result\n        if (isInside) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n    \n    public static boolean isPolygonInside(int[][] polygonA, int[][] polygonB) {\n        \/\/ Check if any vertex of polygon B lies on the side of polygon A\n        for (int i = 0; i < polygonB.length; i++) {\n            if (isPointOnLine(polygonB[i], polygonA)) {\n                return false;\n            }\n        }\n        \n        \/\/ Check if any vertex of polygon B lies outside polygon A\n        for (int i = 0; i < polygonB.length; i++) {\n            if (!isPointInsidePolygon(polygonB[i], polygonA)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public static boolean isPointOnLine(int[] point, int[][] polygon) {\n        for (int i = 0; i < polygon.length; i++) {\n            int[] p1 = polygon[i];\n            int[] p2 = polygon[(i + 1) % polygon.length];\n            \n            int crossProduct = (p2[0] - p1[0]) * (point[1] - p1[1]) - (p2[1] - p1[1]) * (point[0] - p1[0]);\n            \n            if (crossProduct == 0 && isPointBetween(point, p1, p2)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    public static boolean isPointBetween(int[] point, int[] p1, int[] p2) {\n        return (point[0] >= Math.min(p1[0], p2[0]) && point[0] <= Math.max(p1[0], p2[0]) &&\n                point[1] >= Math.min(p1[1], p2[1]) && point[1] <= Math.max(p1[1], p2[1]));\n    }\n    \n    public static boolean isPointInsidePolygon(int[] point, int[][] polygon) {\n        int count = 0;\n        \n        for (int i = 0; i < polygon.length; i++) {\n            int[] p1 = polygon[i];\n            int[] p2 = polygon[(i + 1) % polygon.length];\n            \n            if (isPointOnLine(point, new int[][] {p1, p2})) {\n                return false;\n            }\n            \n            if (point[1] > Math.min(p1[1], p2[1]) && point[1] <= Math.max(p1[1], p2[1])) {\n                double xIntersection = (double) (point[1] - p1[1]) * (p2[0] - p1[0]) \/ (p2[1] - p1[1]) + p1[0];\n                \n                if (point[0] <= xIntersection) {\n                    count++;\n                }\n            }\n        }\n        \n        return count % 2 == 1;\n    }\n}","Python":"def is_polygon_inside(A, B):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def on_segment(p, q, r):\n        if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n            return True\n        return False\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        if (o1 != o2 and o3 != o4):\n            return True\n\n        if (o1 == 0 and on_segment(p1, p2, q1)):\n            return True\n\n        if (o2 == 0 and on_segment(p1, q2, q1)):\n            return True\n\n        if (o3 == 0 and on_segment(p2, p1, q2)):\n            return True\n\n        if (o4 == 0 and on_segment(p2, q1, q2)):\n            return True\n\n        return False\n\n    def is_inside(A, B):\n        n = len(A)\n        m = len(B)\n        if m < 3:\n            return False\n\n        extreme = (float('inf'), float('inf'))\n        count = 0\n        i = 0\n        while True:\n            next = (i + 1) % n\n            if do_intersect(A[i], A[next], B[0], extreme):\n                if orientation(A[i], B[0], A[next]) == 0:\n                    return on_segment(A[i], B[0], A[next])\n                count += 1\n            i = next\n            if i == 0:\n                break\n\n        return count % 2 == 1\n\n    return 'YES' if is_inside(A, B) else 'NO'\n\n# Sample Inputs\ninputs = ['6\\n-2 1\\n0 3\\n3 3\\n4 1\\n3 -2\\n2 -2\\n4\\n0 1\\n2 2\\n3 1\\n1 0\\n', '5\\n1 2\\n4 2\\n3 -3\\n-2 -2\\n-2 1\\n4\\n0 1\\n1 2\\n4 1\\n2 -1\\n', '5\\n-1 2\\n2 3\\n4 1\\n3 -2\\n0 -3\\n5\\n1 0\\n1 1\\n3 1\\n5 -1\\n2 -1\\n']\n\n# Convert inputs to appropriate format\ninputs = [list(map(int, x.strip().split())) for x in inputs]\n\n# Extracting polygon A and B from inputs\nA = inputs[0][1:]\nB = inputs[1][1:]\n\n# Reshaping polygon A and B\nA = [(A[i], A[i+1]) for i in range(0, len(A), 2)]\nB = [(B[i], B[i+1]) for i in range(0, len(B), 2)]\n\n# Check if polygon B is strictly inside polygon A\nresult = is_polygon_inside(A, B)\n\n# Print the result\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n\/\/ Structure to represent a point\\nstruct Point\\n{\\n    int x, y;\\n};\\n\\n\/\/ Function to check if a point lies inside a polygon\\nint isInside(struct Point polygon[], int n, struct Point p)\\n{\\n    \/\/ There must be at least 3 vertices in the polygon\\n    if (n < 3)\\n        return 0;\\n\\n    \/\/ Create a point for line segment from p to infinite\\n    struct Point extreme = {10000, p.y};\\n\\n    \/\/ Count intersections of the above line with sides of polygon\\n    int count = 0, i = 0;\\n    do\\n    {\\n        int next = (i + 1) % n;\\n\\n        \/\/ Check if the line segment from 'p' to 'extreme' intersects with the line segment from 'polygon[i]' to 'polygon[next]'\\n        if (doIntersect(polygon[i], polygon[next], p, extreme))\\n        {\\n            \/\/ If the point 'p' is colinear with line segment 'i-next', then check if it lies on segment. If it lies, return true, otherwise false\\n            if (orientation(polygon[i], p, polygon[next]) == 0)\\n                return onSegment(polygon[i], p, polygon[next]);\\n\\n            count++;\\n        }\\n        i = next;\\n    } while (i != 0);\\n\\n    \/\/ Return true if count is odd, false otherwise\\n    return count % 2 == 1;\\n}\\n\\n\/\/ Function to find orientation of ordered triplet (p, q, r)\\nint orientation(struct Point p, struct Point q, struct Point r)\\n{\\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n\\n    if (val == 0)\\n        return 0; \/\/ colinear\\n\\n    return (val > 0) ? 1 : 2; \/\/ clock or counterclock wise\\n}\\n\\n\/\/ Function to check if two line segments intersect\\nint doIntersect(struct Point p1, struct Point q1, struct Point p2, struct Point q2)\\n{\\n    \/\/ Find the 4 orientations required for general and special cases\\n    int o1 = orientation(p1, q1, p2);\\n    int o2 = orientation(p1, q1, q2);\\n    int o3 = orientation(p2, q2, p1);\\n    int o4 = orientation(p2, q2, q1);\\n\\n    \/\/ General case\\n    if (o1 != o2 && o3 != o4)\\n        return 1;\\n\\n    \/\/ Special Cases\\n    \/\/ p1, q1 and p2 are colinear and p2 lies on segment p1q1\\n    if (o1 == 0 && onSegment(p1, p2, q1))\\n        return 1;\\n\\n    \/\/ p1, q1 and q2 are colinear and q2 lies on segment p1q1\\n    if (o2 == 0 && onSegment(p1, q2, q1))\\n        return 1;\\n\\n    \/\/ p2, q2 and p1 are colinear and p1 lies on segment p2q2\\n    if (o3 == 0 && onSegment(p2, p1, q2))\\n        return 1;\\n\\n    \/\/ p2, q2 and q1 are colinear and q1 lies on segment p2q2\\n    if (o4 == 0 && onSegment(p2, q1, q2))\\n        return 1;\\n\\n    return 0; \/\/ Doesn't fall in any of the above cases\\n}\\n\\n\/\/ Function to check if point lies on a line segment\\nint onSegment(struct Point p, struct Point q, struct Point r)\\n{\\n    if (q.x <= fmax(p.x, r.x) && q.x >= fmin(p.x, r.x) && q.y <= fmax(p.y, r.y) && q.y >= fmin(p.y, r.y))\\n        return 1;\\n\\n    return 0;\\n}\\n\\nint main()\\n{\\n    int n, m;\\n    scanf(\\\"%d\\\", &n);\\n\\n    struct Point polygonA[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d %d\\\", &polygonA[i].x, &polygonA[i].y);\\n    }\\n\\n    scanf(\\\"%d\\\", &m);\\n\\n    struct Point polygonB[m];\\n    for (int i = 0; i < m; i++)\\n    {\\n        scanf(\\\"%d %d\\\", &polygonB[i].x, &polygonB[i].y);\\n    }\\n\\n    \/\/ Check if each vertex of polygon B is inside polygon A\\n    int isInsidePolygonA = 1;\\n    for (int i = 0; i < m; i++)\\n    {\\n        if (!isInside(polygonA, n, polygonB[i]))\\n        {\\n            isInsidePolygonA = 0;\\n            break;\\n        }\\n    }\\n\\n    if (isInsidePolygonA)\\n        printf(\\\"YES\\\\n\\\");\\n    else\\n        printf(\\\"NO\\\\n\\\");\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace StrictlyInsidePolygon\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<Point> polygonA = new List<Point>();\n            for (int i = 0; i < n; i++)\n            {\n                string[] coordinates = Console.ReadLine().Split();\n                int x = int.Parse(coordinates[0]);\n                int y = int.Parse(coordinates[1]);\n                polygonA.Add(new Point(x, y));\n            }\n\n            int m = int.Parse(Console.ReadLine());\n            List<Point> polygonB = new List<Point>();\n            for (int i = 0; i < m; i++)\n            {\n                string[] coordinates = Console.ReadLine().Split();\n                int x = int.Parse(coordinates[0]);\n                int y = int.Parse(coordinates[1]);\n                polygonB.Add(new Point(x, y));\n            }\n\n            bool isStrictlyInside = IsStrictlyInside(polygonA, polygonB);\n            Console.WriteLine(isStrictlyInside ? \"YES\" : \"NO\");\n        }\n\n        static bool IsStrictlyInside(List<Point> polygonA, List<Point> polygonB)\n        {\n            foreach (Point point in polygonB)\n            {\n                if (!IsInsidePolygon(polygonA, point))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        static bool IsInsidePolygon(List<Point> polygon, Point point)\n        {\n            int n = polygon.Count;\n            int count = 0;\n            for (int i = 0; i < n; i++)\n            {\n                Point current = polygon[i];\n                Point next = polygon[(i + 1) % n];\n                if (IsOnSegment(current, next, point))\n                {\n                    return false;\n                }\n                if (IsIntersecting(current, next, point))\n                {\n                    count++;\n                }\n            }\n            return count % 2 == 1;\n        }\n\n        static bool IsOnSegment(Point a, Point b, Point c)\n        {\n            return Math.Min(a.X, b.X) <= c.X && c.X <= Math.Max(a.X, b.X) &&\n                   Math.Min(a.Y, b.Y) <= c.Y && c.Y <= Math.Max(a.Y, b.Y) &&\n                   CrossProduct(a, b, c) == 0;\n        }\n\n        static bool IsIntersecting(Point a, Point b, Point c)\n        {\n            return CrossProduct(a, b, c) > 0 && a.Y <= c.Y && c.Y < b.Y;\n        }\n\n        static int CrossProduct(Point a, Point b, Point c)\n        {\n            return (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X);\n        }\n    }\n\n    class Point\n    {\n        public int X { get; }\n        public int Y { get; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n}","Ruby":"\ndef is_inside_polygon(a, b)\n  # Check if any point of polygon B lies on the side of polygon A\n  b.each do |point_b|\n    a.each_cons(2) do |point_a1, point_a2|\n      if point_on_line(point_b, point_a1, point_a2)\n        return 'NO'\n      end\n    end\n  end\n  \n  # Check if any point of polygon B lies outside polygon A\n  b.each do |point_b|\n    if !point_inside_polygon(point_b, a)\n      return 'NO'\n    end\n  end\n  \n  return 'YES'\nend\n\ndef point_on_line(point, line_start, line_end)\n  # Check if point lies on the line defined by line_start and line_end\n  cross_product = (line_end[1] - line_start[1]) * (point[0] - line_start[0]) - (line_end[0] - line_start[0]) * (point[1] - line_start[1])\n  return cross_product == 0\nend\n\ndef point_inside_polygon(point, polygon)\n  # Check if point lies inside the polygon using the ray casting algorithm\n  inside = false\n  i = 0\n  j = polygon.length - 1\n  \n  while i < polygon.length\n    if ((polygon[i][1] > point[1]) != (polygon[j][1] > point[1])) && (point[0] < (polygon[j][0] - polygon[i][0]) * (point[1] - polygon[i][1]) \/ (polygon[j][1] - polygon[i][1]) + polygon[i][0])\n      inside = !inside\n    end\n    j = i\n    i += 1\n  end\n  \n  return inside\nend\n\n# Read input\ninput = gets.chomp.split(\"\\n\")\nn = input[0].to_i\na = []\n(1..n).each do |i|\n  a << input[i].split.map(&:to_i)\nend\nm = input[n+1].to_i\nb = []\n((n+2)..(n+1+m)).each do |i|\n  b << input[i].split.map(&:to_i)\nend\n\n# Check if polygon B is strictly inside polygon A\nresult = is_inside_polygon(a, b)\n\n# Print result\nputs result\n","delphi":"program StrictlyInsidePolygon;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\ntype\n  TPoint = record\n    X, Y: Integer;\n  end;\n\nfunction IsLeft(A, B, C: TPoint): Integer;\nbegin\n  Result := (B.X - A.X) * (C.Y - A.Y) - (C.X - A.X) * (B.Y - A.Y);\nend;\n\nfunction IsInsidePolygon(A, B: TArray<TPoint>): Boolean;\nvar\n  i, j, n, m: Integer;\nbegin\n  n := Length(A);\n  m := Length(B);\n\n  \/\/ Check if any vertex of B lies on the side of A\n  for i := 0 to n - 1 do\n  begin\n    if IsLeft(A[i], A[(i + 1) mod n], B[0]) = 0 then\n    begin\n      Result := False;\n      Exit;\n    end;\n  end;\n\n  \/\/ Check if any vertex of B lies outside A\n  for i := 0 to m - 1 do\n  begin\n    if IsLeft(A[0], A[1], B[i]) > 0 then\n    begin\n      Result := False;\n      Exit;\n    end;\n  end;\n\n  \/\/ Check if any vertex of B lies inside A\n  for i := 0 to m - 1 do\n  begin\n    j := 0;\n    while (j < n) and (IsLeft(A[j], A[(j + 1) mod n], B[i]) >= 0) do\n      Inc(j);\n    if j = n then\n    begin\n      Result := False;\n      Exit;\n    end;\n  end;\n\n  Result := True;\nend;\n\nvar\n  n, m, i: Integer;\n  A, B: TArray<TPoint>;\nbegin\n  \/\/ Read input\n  ReadLn(n);\n  SetLength(A, n);\n  for i := 0 to n - 1 do\n    ReadLn(A[i].X, A[i].Y);\n\n  ReadLn(m);\n  SetLength(B, m);\n  for i := 0 to m - 1 do\n    ReadLn(B[i].X, B[i].Y);\n\n  \/\/ Check if B is strictly inside A\n  if IsInsidePolygon(A, B) then\n    WriteLn('YES')\n  else\n    WriteLn('NO');\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Fscanf(os.Stdin, \\\"%d\\\", &n)\\n\\n\\tpolygonA := make([][2]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Fscanf(os.Stdin, \\\"%d %d\\\", &polygonA[i][0], &polygonA[i][1])\\n\\t}\\n\\n\\tfmt.Fscanf(os.Stdin, \\\"%d\\\", &m)\\n\\n\\tpolygonB := make([][2]int, m)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfmt.Fscanf(os.Stdin, \\\"%d %d\\\", &polygonB[i][0], &polygonB[i][1])\\n\\t}\\n\\n\\tif isPolygonInside(polygonA, polygonB) {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}\\n\\nfunc isPolygonInside(polygonA, polygonB [][2]int) bool {\\n\\tn := len(polygonA)\\n\\tm := len(polygonB)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tif !isPointInside(polygonA, polygonB[i], n) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc isPointInside(polygon [][2]int, point [2]int, n int) bool {\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tx1, y1 := polygon[i][0], polygon[i][1]\\n\\t\\tx2, y2 := polygon[(i+1)%n][0], polygon[(i+1)%n][1]\\n\\n\\t\\tif (x2-x1)*(point[1]-y1)-(point[0]-x1)*(y2-y1) >= 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}","Javascript":"function isPolygonInside(A, B) {\n    \/\/ Check if any vertex of B lies on the side of A\n    for (let i = 0; i < A.length; i++) {\n        const p1 = A[i];\n        const p2 = A[(i + 1) % A.length];\n        \n        for (let j = 0; j < B.length; j++) {\n            const point = B[j];\n            \n            if (isPointOnLine(p1, p2, point)) {\n                return false;\n            }\n        }\n    }\n    \n    \/\/ Check if any vertex of B lies outside A\n    for (let i = 0; i < B.length; i++) {\n        const point = B[i];\n        \n        if (!isPointInsidePolygon(point, A)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nfunction isPointOnLine(p1, p2, point) {\n    const crossProduct = (point[1] - p1[1]) * (p2[0] - p1[0]) - (point[0] - p1[0]) * (p2[1] - p1[1]);\n    \n    if (Math.abs(crossProduct) > Number.EPSILON) {\n        return false;\n    }\n    \n    const dotProduct = (point[0] - p1[0]) * (p2[0] - p1[0]) + (point[1] - p1[1]) * (p2[1] - p1[1]);\n    \n    if (dotProduct < 0) {\n        return false;\n    }\n    \n    const squaredLength = (p2[0] - p1[0]) * (p2[0] - p1[0]) + (p2[1] - p1[1]) * (p2[1] - p1[1]);\n    \n    if (dotProduct > squaredLength) {\n        return false;\n    }\n    \n    return true;\n}\n\nfunction isPointInsidePolygon(point, polygon) {\n    let inside = false;\n    \n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const xi = polygon[i][0], yi = polygon[i][1];\n        const xj = polygon[j][0], yj = polygon[j][1];\n        \n        const intersect = ((yi > point[1]) !== (yj > point[1])) &&\n            (point[0] < (xj - xi) * (point[1] - yi) \/ (yj - yi) + xi);\n        \n        if (intersect) {\n            inside = !inside;\n        }\n    }\n    \n    return inside;\n}\n\n\/\/ Sample inputs\nconst inputs = [\n    '6\\n-2 1\\n0 3\\n3 3\\n4 1\\n3 -2\\n2 -2\\n4\\n0 1\\n2 2\\n3 1\\n1 0\\n',\n    '5\\n1 2\\n4 2\\n3 -3\\n-2 -2\\n-2 1\\n4\\n0 1\\n1 2\\n4 1\\n2 -1\\n',\n    '5\\n-1 2\\n2 3\\n4 1\\n3 -2\\n0 -3\\n5\\n1 0\\n1 1\\n3 1\\n5 -1\\n2 -1\\n'\n];\n\n\/\/ Process each input\nconst outputs = inputs.map(input => {\n    const lines = input.trim().split('\\n');\n    const n = parseInt(lines[0]);\n    const A = lines.slice(1, n + 1).map(line => line.split(' ').map(Number));\n    const m = parseInt(lines[n + 1]);\n    const B = lines.slice(n + 2).map(line => line.split(' ').map(Number));\n    \n    const result = isPolygonInside(A, B) ? 'YES' : 'NO';\n    return result;\n});\n\n\/\/ Print outputs\nconsole.log(outputs.join('\\\\n'));","Kotlin":"import java.util.*\n\ndata class Point(val x: Int, val y: Int)\n\nfun isInsidePolygon(A: List<Point>, B: List<Point>): Boolean {\n    val n = A.size\n    val m = B.size\n    \n    \/\/ Check if any vertex of B lies on the side of A\n    for (i in 0 until n) {\n        val p1 = A[i]\n        val p2 = A[(i + 1) % n]\n        \n        for (j in 0 until m) {\n            val p = B[j]\n            val crossProduct = (p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x)\n            \n            if (crossProduct == 0) {\n                \/\/ Vertex of B lies on the side of A\n                return false\n            }\n        }\n    }\n    \n    \/\/ Check if any vertex of B lies outside A\n    for (i in 0 until m) {\n        val p = B[i]\n        var inside = false\n        \n        for (j in 0 until n) {\n            val p1 = A[j]\n            val p2 = A[(j + 1) % n]\n            \n            val crossProduct = (p2.x - p1.x) * (p.y - p1.y) - (p2.y - p1.y) * (p.x - p1.x)\n            \n            if (crossProduct > 0) {\n                inside = true\n                break\n            }\n        }\n        \n        if (!inside) {\n            \/\/ Vertex of B lies outside A\n            return false\n        }\n    }\n    \n    return true\n}\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    \n    \/\/ Read the vertices of polygon A\n    val n = scanner.nextInt()\n    val A = mutableListOf<Point>()\n    for (i in 0 until n) {\n        val x = scanner.nextInt()\n        val y = scanner.nextInt()\n        A.add(Point(x, y))\n    }\n    \n    \/\/ Read the vertices of polygon B\n    val m = scanner.nextInt()\n    val B = mutableListOf<Point>()\n    for (i in 0 until m) {\n        val x = scanner.nextInt()\n        val y = scanner.nextInt()\n        B.add(Point(x, y))\n    }\n    \n    \/\/ Check if polygon B is strictly inside polygon A\n    val result = if (isInsidePolygon(A, B)) \"YES\" else \"NO\"\n    println(result)\n}","PHP":"\n<?php\n\nfunction isInsidePolygon($polygonA, $polygonB) {\n    \/\/ Check if any vertex of polygon B lies on the side of polygon A\n    foreach ($polygonB as $vertexB) {\n        if (isOnPolygonSide($vertexB, $polygonA)) {\n            return false;\n        }\n    }\n    \n    \/\/ Check if any vertex of polygon B lies outside polygon A\n    foreach ($polygonB as $vertexB) {\n        if (!isInsidePolygonVertex($vertexB, $polygonA)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nfunction isOnPolygonSide($vertex, $polygon) {\n    $n = count($polygon);\n    \n    for ($i = 0; $i < $n; $i++) {\n        $vertexA = $polygon[$i];\n        $vertexB = $polygon[($i + 1) % $n];\n        \n        $crossProduct = crossProduct($vertexA, $vertexB, $vertex);\n        \n        if ($crossProduct == 0 && isBetween($vertexA, $vertexB, $vertex)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nfunction isInsidePolygonVertex($vertex, $polygon) {\n    $n = count($polygon);\n    \n    $inside = false;\n    \n    for ($i = 0; $i < $n; $i++) {\n        $vertexA = $polygon[$i];\n        $vertexB = $polygon[($i + 1) % $n];\n        \n        $crossProduct = crossProduct($vertexA, $vertexB, $vertex);\n        \n        if ($vertexA[1] > $vertex[1] != $vertexB[1] > $vertex[1] && $vertex[0] < ($vertexB[0] - $vertexA[0]) * ($vertex[1] - $vertexA[1]) \/ ($vertexB[1] - $vertexA[1]) + $vertexA[0]) {\n            $inside = !$inside;\n        }\n    }\n    \n    return $inside;\n}\n\nfunction crossProduct($vertexA, $vertexB, $vertex) {\n    return ($vertexB[0] - $vertexA[0]) * ($vertex[1] - $vertexA[1]) - ($vertexB[1] - $vertexA[1]) * ($vertex[0] - $vertexA[0]);\n}\n\nfunction isBetween($vertexA, $vertexB, $vertex) {\n    return min($vertexA[0], $vertexB[0]) <= $vertex[0] && $vertex[0] <= max($vertexA[0], $vertexB[0]) && min($vertexA[1], $vertexB[1]) <= $vertex[1] && $vertex[1] <= max($vertexA[1], $vertexB[1]);\n}\n\n\/\/ Read input\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\n\n$n = intval($input[0]);\n$polygonA = [];\nfor ($i = 1; $i <= $n; $i++) {\n    $coordinates = explode(' ', $input[$i]);\n    $polygonA[] = [intval($coordinates[0]), intval($coordinates[1])];\n}\n\n$m = intval($input[$n + 1]);\n$polygonB = [];\nfor ($i = $n + 2; $i <= $n + $m + 1; $i++) {\n    $coordinates = explode(' ', $input[$i]);\n    $polygonB[] = [intval($coordinates[0]), intval($coordinates[1])];\n}\n\n\/\/ Check if polygon B is strictly inside polygon A\n$result = isInsidePolygon($polygonA, $polygonB);\n\n\/\/ Print the result\nif ($result) {\n    echo 'YES';\n} else {\n    echo 'NO';\n}\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\nimport std.range;\\r\\n\\r\\nstruct Point {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isInsidePolygon(Point[] polygonA, Point[] polygonB) {\\r\\n    auto minX = polygonA.min!(a => a.x).x;\\r\\n    auto maxX = polygonA.max!(a => a.x).x;\\r\\n    auto minY = polygonA.min!(a => a.y).y;\\r\\n    auto maxY = polygonA.max!(a => a.y).y;\\r\\n\\r\\n    for (auto point : polygonB) {\\r\\n        if (point.x <= minX || point.x >= maxX || point.y <= minY || point.y >= maxY) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        bool isInside = false;\\r\\n        for (size_t i = 0; i < polygonA.length; i++) {\\r\\n            auto p1 = polygonA[i];\\r\\n            auto p2 = polygonA[(i + 1) % polygonA.length];\\r\\n\\r\\n            if ((p1.y > point.y) != (p2.y > point.y) &&\\r\\n                point.x < (p2.x - p1.x) * (point.y - p1.y) \/ (p2.y - p1.y) + p1.x) {\\r\\n                isInside = !isInside;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!isInside) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    Point[] polygonA;\\r\\n    foreach (_; 0 .. n) {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        polygonA ~= Point(x, y);\\r\\n    }\\r\\n\\r\\n    int m;\\r\\n    readf(\\\"%d\\\", &m);\\r\\n\\r\\n    Point[] polygonB;\\r\\n    foreach (_; 0 .. m) {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        polygonB ~= Point(x, y);\\r\\n    }\\r\\n\\r\\n    bool result = isInsidePolygon(polygonA, polygonB);\\r\\n\\r\\n    if (result) {\\r\\n        writeln(\\\"YES\\\");\\r\\n    } else {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub is_inside_polygon {\\n    my ($polygon_a, $polygon_b) = @_;\\n    my $n = scalar @$polygon_a;\\n    my $m = scalar @$polygon_b;\\n\\n    # Check if any vertex of polygon B lies on the side of polygon A\\n    for my $i (0..$n-1) {\\n        my $x1 = $polygon_a->[$i][0];\\n        my $y1 = $polygon_a->[$i][1];\\n        my $x2 = $polygon_a->[($i+1)%$n][0];\\n        my $y2 = $polygon_a->[($i+1)%$n][1];\\n\\n        for my $j (0..$m-1) {\\n            my $x = $polygon_b->[$j][0];\\n            my $y = $polygon_b->[$j][1];\\n\\n            my $cross_product = ($x2 - $x1) * ($y - $y1) - ($y2 - $y1) * ($x - $x1);\\n\\n            if ($cross_product == 0) {\\n                return 'NO';\\n            }\\n        }\\n    }\\n\\n    # Check if any vertex of polygon B lies outside polygon A\\n    for my $i (0..$m-1) {\\n        my $x = $polygon_b->[$i][0];\\n        my $y = $polygon_b->[$i][1];\\n\\n        my $cross_product = ($polygon_a->[1][0] - $polygon_a->[0][0]) * ($y - $polygon_a->[0][1]) - ($polygon_a->[1][1] - $polygon_a->[0][1]) * ($x - $polygon_a->[0][0]);\\n\\n        if ($cross_product > 0) {\\n            return 'NO';\\n        }\\n    }\\n\\n    return 'YES';\\n}\\n\\n# Read input\\nmy $n = <STDIN>;\\nchomp $n;\\n\\nmy @polygon_a;\\nfor (1..$n) {\\n    my $line = <STDIN>;\\n    chomp $line;\\n    my ($x, $y) = split ' ', $line;\\n    push @polygon_a, [$x, $y];\\n}\\n\\nmy $m = <STDIN>;\\nchomp $m;\\n\\nmy @polygon_b;\\nfor (1..$m) {\\n    my $line = <STDIN>;\\n    chomp $line;\\n    my ($x, $y) = split ' ', $line;\\n    push @polygon_b, [$x, $y];\\n}\\n\\n# Check if polygon B is strictly inside polygon A\\nmy $result = is_inside_polygon(\\@polygon_a, \\@polygon_b);\\n\\n# Print the result\\nprint $result . \\\"\\\\n\\\";\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n\n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let polygon_a: Vec<(i64, i64)> = (0..n)\n        .map(|_| {\n            let line = lines.next().unwrap();\n            let mut coords = line.split_whitespace();\n            let x: i64 = coords.next().unwrap().parse().unwrap();\n            let y: i64 = coords.next().unwrap().parse().unwrap();\n            (x, y)\n        })\n        .collect();\n\n    let m: usize = lines.next().unwrap().parse().unwrap();\n    let polygon_b: Vec<(i64, i64)> = (0..m)\n        .map(|_| {\n            let line = lines.next().unwrap();\n            let mut coords = line.split_whitespace();\n            let x: i64 = coords.next().unwrap().parse().unwrap();\n            let y: i64 = coords.next().unwrap().parse().unwrap();\n            (x, y)\n        })\n        .collect();\n\n    let result = is_polygon_b_inside_polygon_a(&polygon_a, &polygon_b);\n\n    if result {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\n\nfn is_polygon_b_inside_polygon_a(polygon_a: &[(i64, i64)], polygon_b: &[(i64, i64)]) -> bool {\n    for point in polygon_b {\n        if !is_point_inside_polygon_a(point, polygon_a) {\n            return false;\n        }\n    }\n    true\n}\n\nfn is_point_inside_polygon_a(point: &(i64, i64), polygon_a: &[(i64, i64)]) -> bool {\n    let n = polygon_a.len();\n    let mut left = 0;\n    let mut right = n - 1;\n    let mut inside = false;\n\n    while left < n {\n        let vertex_left = polygon_a[left];\n        let vertex_right = polygon_a[right];\n\n        if (vertex_left.1 > point.1) != (vertex_right.1 > point.1)\n            && point.0\n                < (vertex_right.0 - vertex_left.0) * (point.1 - vertex_left.1)\n                    \/ (vertex_right.1 - vertex_left.1)\n                    + vertex_left.0\n        {\n            inside = !inside;\n        }\n\n        right = left;\n        left += 1;\n    }\n\n    inside\n}\n"}
{"title":"B. Burglar and Matches","description":"A burglar got into a matches warehouse and wants to steal as many matches as possible. In the warehouse there are m containers, in the i-th container there are ai matchboxes, and each matchbox contains bi matches. All the matchboxes are of the same size. The burglar's rucksack can hold n matchboxes exactly. Your task is to find out the maximum amount of matches that a burglar can carry away. He has no time to rearrange matches in the matchboxes, that's why he just chooses not more than n matchboxes so that the total amount of matches in them is maximal.","input_from":"standard input","output_to":"standard output","time_limit":"0.5 second","memory_limit":"64 megabytes","input_spec":"The first line of the input contains integer n (1\u2264n\u22642\u00b710^8) and integer m (1\u2264m\u226420). The i+1-th line contains a pair of numbers ai and bi (1\u2264ai\u226410^8,1\u2264bi\u226410). All the input numbers are integer.\n","output_spec":"Output the only number \u2014 answer to the problem.\n","notes":null,"sample_inputs":["7 3\n5 10\n2 5\n3 6\n","3 3\n1 3\n2 2\n3 1\n"],"sample_outputs":["62\n","7\n"],"id":"16-B","difficulty":900,"tags":["greedy","implementation","sortings"],"src_uid":"c052d85e402691b05e494b5283d62679","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nstruct Container {\\n    int matchboxes;\\n    int matches;\\n};\\n\\nbool compareContainers(Container c1, Container c2) {\\n    return c1.matches > c2.matches;\\n}\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<Container> containers(m);\\n\\n    for (int i = 0; i < m; i++) {\\n        cin >> containers[i].matchboxes >> containers[i].matches;\\n    }\\n\\n    sort(containers.begin(), containers.end(), compareContainers);\\n\\n    int totalMatches = 0;\\n    int matchboxesTaken = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        if (matchboxesTaken + containers[i].matchboxes <= n) {\\n            totalMatches += containers[i].matchboxes * containers[i].matches;\\n            matchboxesTaken += containers[i].matchboxes;\\n        } else {\\n            totalMatches += (n - matchboxesTaken) * containers[i].matches;\\n            break;\\n        }\\n    }\\n\\n    cout << totalMatches << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        int[] a = new int[m];\n        int[] b = new int[m];\n        \n        for (int i = 0; i < m; i++) {\n            a[i] = scanner.nextInt();\n            b[i] = scanner.nextInt();\n        }\n        \n        int[] matches = new int[m];\n        for (int i = 0; i < m; i++) {\n            matches[i] = a[i] * b[i];\n        }\n        \n        Arrays.sort(matches);\n        \n        int totalMatches = 0;\n        int matchboxes = 0;\n        \n        for (int i = m - 1; i >= 0; i--) {\n            if (matchboxes + a[i] <= n) {\n                totalMatches += matches[i];\n                matchboxes += a[i];\n            } else {\n                int remainingMatchboxes = n - matchboxes;\n                totalMatches += remainingMatchboxes * b[i];\n                break;\n            }\n        }\n        \n        System.out.println(totalMatches);\n    }\n}","Python":"def max_matches(input_str):\\n    input_lines = input_str.strip().split('\\\\n')\\n    n, m = map(int, input_lines[0].split())\\n    containers = []\\n    for line in input_lines[1:]:\\n        a, b = map(int, line.split())\\n        containers.append((a, b))\\n    containers.sort(key=lambda x: x[1], reverse=True)\\n    matches = 0\\n    for i in range(m):\\n        if n >= containers[i][0]:\\n            matches += containers[i][0] * containers[i][1]\\n            n -= containers[i][0]\\n        else:\\n            matches += n * containers[i][1]\\n            break\\n    return str(matches)\\n\\n\\ntest_input = '7 3\\\\n5 10\\\\n2 5\\\\n3 6\\\\n'\\nprint(max_matches(test_input))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int a[m], b[m];\\n    for(int i=0; i<m; i++) {\\n        scanf(\\\"%d %d\\\", &a[i], &b[i]);\\n    }\\n    \\n    \/\/ Sort the matchboxes based on the number of matches\\n    for(int i=0; i<m-1; i++) {\\n        for(int j=0; j<m-i-1; j++) {\\n            if(b[j] < b[j+1]) {\\n                int temp = b[j];\\n                b[j] = b[j+1];\\n                b[j+1] = temp;\\n                \\n                temp = a[j];\\n                a[j] = a[j+1];\\n                a[j+1] = temp;\\n            }\\n        }\\n    }\\n    \\n    int totalMatches = 0;\\n    int matchboxes = 0;\\n    int i = 0;\\n    while(matchboxes < n && i < m) {\\n        int matchesToTake = n - matchboxes;\\n        if(matchesToTake >= a[i]) {\\n            totalMatches += a[i] * b[i];\\n            matchboxes += a[i];\\n        }\\n        else {\\n            totalMatches += matchesToTake * b[i];\\n            matchboxes += matchesToTake;\\n        }\\n        i++;\\n    }\\n    \\n    printf(\\\"%d\\\\n\\\", totalMatches);\\n    \\n    return 0;\\n}","C#":"\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n\n        int[] matches = new int[m];\n        for (int i = 0; i < m; i++)\n        {\n            string[] container = Console.ReadLine().Split();\n            int ai = int.Parse(container[0]);\n            int bi = int.Parse(container[1]);\n            matches[i] = ai * bi;\n        }\n\n        Array.Sort(matches);\n        Array.Reverse(matches);\n\n        int totalMatches = 0;\n        for (int i = 0; i < n; i++)\n        {\n            totalMatches += matches[i];\n        }\n\n        Console.WriteLine(totalMatches);\n    }\n}\n","Ruby":"\ndef maximum_matches(input)\n  # Parse input\n  n, m = input[0].split.map(&:to_i)\n  containers = input[1..-1].map { |line| line.split.map(&:to_i) }\n\n  # Sort containers by the number of matches per matchbox in descending order\n  containers.sort_by! { |container| -container[1] }\n\n  # Initialize variables\n  total_matches = 0\n  matchboxes_taken = 0\n\n  # Iterate through containers\n  containers.each do |container|\n    # Calculate the maximum number of matchboxes that can be taken from the current container\n    matchboxes_to_take = [n - matchboxes_taken, container[0]].min\n\n    # Update the total number of matches and matchboxes taken\n    total_matches += matchboxes_to_take * container[1]\n    matchboxes_taken += matchboxes_to_take\n\n    # Break the loop if the maximum number of matchboxes has been reached\n    break if matchboxes_taken == n\n  end\n\n  # Return the maximum number of matches\n  total_matches.to_s\nend\n\n# Test the function with the sample inputs\ninput1 = \\\"7 3\\\\n5 10\\\\n2 5\\\\n3 6\\\\n\\\"\noutput1 = maximum_matches(input1.split(\\\"\\\\n\\\"))\nputs output1 == \\\"62\\\"\n\ninput2 = \\\"3 3\\\\n1 3\\\\n2 2\\\\n3 1\\\\n\\\"\noutput2 = maximum_matches(input2.split(\\\"\\\\n\\\"))\nputs output2 == \\\"7\\\"\n","delphi":"program BurglarMatches;\\n\\nvar\\n  n, m, i, a, b, totalMatches, maxMatches: integer;\\nbegin\\n  readln(n, m);\\n  maxMatches := 0;\\n  for i := 1 to m do\\n  begin\\n    readln(a, b);\\n    totalMatches := a * b;\\n    if totalMatches > maxMatches then\\n      maxMatches := totalMatches;\\n  end;\\n  writeln(maxMatches);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tcontainers := make([]int, m)\\n\\tmatches := make([]int, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tvar a, b int\\n\\t\\tfmt.Scanf(\\\"%d %d\\\", &a, &b)\\n\\t\\tcontainers[i] = a\\n\\t\\tmatches[i] = a * b\\n\\t}\\n\\n\\tsort.Ints(matches)\\n\\n\\ttotalMatches := 0\\n\\n\\tfor i := m - 1; i >= 0; i-- {\\n\\t\\tif n > 0 {\\n\\t\\t\\tif n >= containers[i] {\\n\\t\\t\\t\\tn -= containers[i]\\n\\t\\t\\t\\ttotalMatches += matches[i]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttotalMatches += n * (matches[i] \/ containers[i])\\n\\t\\t\\t\\tn = 0\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(totalMatches)\\n}","Javascript":"function getMaxMatches(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  let maxMatches = 0;\n\n  for (let i = 1; i <= m; i++) {\n    const [ai, bi] = lines[i].split(' ').map(Number);\n    const matchesInContainer = ai * bi;\n    maxMatches += Math.min(n, ai) * bi;\n    n -= Math.min(n, ai);\n  }\n\n  return maxMatches.toString();\n}\n\nconst inputs = ['7 3\\\\n5 10\\\\n2 5\\\\n3 6\\\\n', '3 3\\\\n1 3\\\\n2 2\\\\n3 1\\\\n'];\nconst outputs = [];\n\ninputs.forEach(input => {\n  const output = getMaxMatches(input);\n  outputs.push(output);\n});\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    \n    var totalMatches = 0\n    \n    for (i in 0 until m) {\n        val ab = scanner.nextLine().split(\" \")\n        val a = ab[0].toInt()\n        val b = ab[1].toInt()\n        \n        val matchesInContainer = a * b\n        totalMatches += matchesInContainer\n    }\n    \n    val maxMatches = minOf(totalMatches, n * 10)\n    println(maxMatches)\n}","PHP":"<?php\\n\\nfunction maximumMatches($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $nm = explode(\\\" \\\", $lines[0]);\\n    $n = intval($nm[0]);\\n    $m = intval($nm[1]);\\n    $matchboxes = [];\\n    for ($i = 1; $i <= $m; $i++) {\\n        $ab = explode(\\\" \\\", $lines[$i]);\\n        $a = intval($ab[0]);\\n        $b = intval($ab[1]);\\n        $matchboxes[] = $a * $b;\\n    }\\n    rsort($matchboxes);\\n    $totalMatches = 0;\\n    for ($i = 0; $i < $n; $i++) {\\n        $totalMatches += $matchboxes[$i];\\n    }\\n    return $totalMatches;\\n}\\n\\n$input = '7 3\\\\n5 10\\\\n2 5\\\\n3 6\\\\n';\\n$output = maximumMatches($input);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstruct Container {\\r\\n    int matchboxes;\\r\\n    int matchesPerBox;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    Container[] containers;\\r\\n    foreach (_; 0 .. m) {\\r\\n        int matchboxes, matchesPerBox;\\r\\n        readf(\\\"%d %d\\\", &matchboxes, &matchesPerBox);\\r\\n        containers ~= Container(matchboxes, matchesPerBox);\\r\\n    }\\r\\n\\r\\n    containers.sort!((a, b) => a.matchesPerBox > b.matchesPerBox);\\r\\n\\r\\n    int totalMatches = 0;\\r\\n    foreach (container; containers) {\\r\\n        int matchboxesToTake = min(n, container.matchboxes);\\r\\n        totalMatches += matchboxesToTake * container.matchesPerBox;\\r\\n        n -= matchboxesToTake;\\r\\n        if (n == 0) {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(totalMatches);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub maximum_matches {\n    my ($n, $m, @containers) = @_;\n\n    # Sort the containers in descending order based on the number of matches in each container\n    my @sorted_containers = sort { $b->[0] * $b->[1] <=> $a->[0] * $a->[1] } @containers;\n\n    my $total_matches = 0;\n    my $matchboxes_taken = 0;\n\n    # Iterate through the sorted containers and take matchboxes until the rucksack is full\n    foreach my $container (@sorted_containers) {\n        my ($matchboxes, $matches_per_box) = @$container;\n\n        if ($matchboxes_taken + $matchboxes <= $n) {\n            # Take all matchboxes from the current container\n            $total_matches += $matchboxes * $matches_per_box;\n            $matchboxes_taken += $matchboxes;\n        } else {\n            # Take only the remaining matchboxes needed to fill the rucksack\n            my $remaining_matchboxes = $n - $matchboxes_taken;\n            $total_matches += $remaining_matchboxes * $matches_per_box;\n            last;\n        }\n    }\n\n    return $total_matches;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\nmy ($n, $m) = split ' ', $input;\n\nmy @containers;\nfor (my $i = 0; $i < $m; $i++) {\n    my $container_input = <STDIN>;\n    chomp $container_input;\n\n    my ($ai, $bi) = split ' ', $container_input;\n    push @containers, [$ai, $bi];\n}\n\n# Calculate the maximum amount of matches the burglar can carry away\nmy $maximum_matches = maximum_matches($n, $m, @containers);\n\n# Print the result\nprint $maximum_matches;\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buf = String::new();\n    input.read_line(&mut buf).unwrap();\n    let mut iter = buf.split_whitespace();\n    let n: i32 = iter.next().unwrap().parse().unwrap();\n    let m: i32 = iter.next().unwrap().parse().unwrap();\n    \n    let mut total_matches = 0;\n    for _ in 0..m {\n        buf.clear();\n        input.read_line(&mut buf).unwrap();\n        let mut iter = buf.split_whitespace();\n        let a: i32 = iter.next().unwrap().parse().unwrap();\n        let b: i32 = iter.next().unwrap().parse().unwrap();\n        \n        total_matches += a * b;\n    }\n    \n    let max_matches = total_matches.min(n * 10);\n    println!(\"{}\", max_matches);\n}"}
{"title":"C. Monitor","description":"Reca company makes monitors, the most popular of their models is AB999 with the screen size a\u00d7b centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio x:y became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes x:y, at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.","input_from":"standard input","output_to":"standard output","time_limit":"0.5 second","memory_limit":"64 megabytes","input_spec":"The first line of the input contains 4 integers \u2014 a, b, x and y (1\u2264a,b,x,y\u22642\u00b710^9).\n","output_spec":"If the answer exists, output 2 positive integers \u2014 screen parameters of the reduced size model. Output 0 0 otherwise.\n","notes":null,"sample_inputs":["800 600 4 3\n","1920 1200 16 9\n","1 1 1 2\n"],"sample_outputs":["800 600\n","1920 1080\n","0 0\n"],"id":"16-C","difficulty":1800,"tags":["binary+search","number+theory"],"src_uid":"97999cd7c6de79a4e39f56a41ff59e7a","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int a, b, x, y;\\n    cin >> a >> b >> x >> y;\\n\\n    int gcd = __gcd(x, y);\\n    x \/= gcd;\\n    y \/= gcd;\\n\\n    int k1 = a \/ x;\\n    int k2 = b \/ y;\\n\\n    int k = min(k1, k2);\\n\\n    int new_a = k * x;\\n    int new_b = k * y;\\n\\n    if (new_a <= a && new_b <= b) {\\n        cout << new_a << \\\" \\\" << new_b << endl;\\n    } else {\\n        cout << \\\"0 0\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class MonitorSize {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int a = scanner.nextInt();\\n        int b = scanner.nextInt();\\n        int x = scanner.nextInt();\\n        int y = scanner.nextInt();\\n\\n        int gcd = gcd(x, y);\\n        x \/= gcd;\\n        y \/= gcd;\\n\\n        int width = Math.min(a \/ x, b \/ y);\\n        int height = width * y;\\n\\n        if (width > 0 && height > 0) {\\n            System.out.println(width * x + \\\" \\\" + height);\\n        } else {\\n            System.out.println(\\\"0 0\\\");\\n        }\\n    }\\n\\n    private static int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}","Python":"def reduce_monitor_size(a, b, x, y):\\n    gcd = math.gcd(x, y)\\n    x_ratio = x \/\/ gcd\\n    y_ratio = y \/\/ gcd\\n\\n    max_area = 0\\n    max_a = 0\\n    max_b = 0\\n\\n    for i in range(1, a+1):\\n        j = (i * y_ratio) \/\/ x_ratio\\n        if j <= b:\\n            area = i * j\\n            if area > max_area:\\n                max_area = area\\n                max_a = i\\n                max_b = j\\n\\n    if max_area == 0:\\n        return '0 0'\\n    else:\\n        return str(max_a) + ' ' + str(max_b)\\n\\n\\n# Sample Inputs\\ninputs = ['800 600 4 3\\\\n', '1920 1200 16 9\\\\n', '1 1 1 2\\\\n']\\n\\n# Sample Outputs\\noutputs = ['800 600\\\\n', '1920 1080\\\\n', '0 0\\\\n']\\n\\nfor i, input_str in enumerate(inputs):\\n    a, b, x, y = map(int, input_str.strip().split())\\n    output_str = reduce_monitor_size(a, b, x, y)\\n    assert output_str == outputs[i].strip(), f'Test case {i+1} failed!'\\n\\nprint('All test cases passed!')","C":"#include <stdio.h>\\n\\nint main() {\\n    int a, b, x, y;\\n    scanf(\\\"%d %d %d %d\\\", &a, &b, &x, &y);\\n    int gcd = __gcd(x, y);\\n    x \/= gcd;\\n    y \/= gcd;\\n    int max_area = 0;\\n    int max_a = 0, max_b = 0;\\n    for (int i = 1; i <= a; i++) {\\n        int j = (i * x) \/ y;\\n        if (j <= b && i * j > max_area) {\\n            max_area = i * j;\\n            max_a = i;\\n            max_b = j;\\n        }\\n    }\\n    if (max_area == 0) {\\n        printf(\\\"0 0\\\\n\\\");\\n    } else {\\n        printf(\\\"%d %d\\\\n\\\", max_a, max_b);\\n    }\\n    return 0;\\n}","C#":"\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] inputs = { \\\"800 600 4 3\\\", \\\"1920 1200 16 9\\\", \\\"1 1 1 2\\\" };\n        \n        foreach (string input in inputs)\n        {\n            string[] values = input.Split(' ');\n            int a = int.Parse(values[0]);\n            int b = int.Parse(values[1]);\n            int x = int.Parse(values[2]);\n            int y = int.Parse(values[3]);\n            \n            int gcd = GCD(x, y);\n            int newX = x \/ gcd;\n            int newY = y \/ gcd;\n            \n            int maxA = a \/ newX;\n            int maxB = b \/ newY;\n            \n            if (maxA * newX == a && maxB * newY == b)\n            {\n                Console.WriteLine(maxA + \\\" \\\" + maxB);\n            }\n            else\n            {\n                Console.WriteLine(\\\"0 0\\\");\n            }\n        }\n    }\n    \n    public static int GCD(int a, int b)\n    {\n        while (b != 0)\n        {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        \n        return a;\n    }\n}\n","Ruby":"\ndef reduce_monitor_size(a, b, x, y)\n  gcd = a.gcd(b)\n  a_ratio = a \/ gcd\n  b_ratio = b \/ gcd\n\n  if a_ratio >= x && b_ratio >= y\n    reduced_a = gcd * x\n    reduced_b = gcd * y\n    return \\\"#{reduced_a} #{reduced_b}\\\"\n  end\n\n  return \\\"0 0\\\"\nend\n\ninputs = ['800 600 4 3\\n', '1920 1200 16 9\\n', '1 1 1 2\\n']\noutputs = []\n\ninputs.each do |input|\n  a, b, x, y = input.split.map(&:to_i)\n  outputs << reduce_monitor_size(a, b, x, y)\nend\n\noutputs\n","delphi":"program MonitorReduction;\\n\\nvar\\n  a, b, x, y, newA, newB: Integer;\\n  maxArea: Int64;\\n\\nbegin\\n  Readln(a, b, x, y);\\n  maxArea := 0;\\n\\n  \/\/ Check if reduction is possible\\n  if (a mod x = 0) and (b mod y = 0) then\\n  begin\\n    newA := a div x;\\n    newB := b div y;\\n\\n    \/\/ Calculate the new area\\n    if (newA * y) = (newB * x) then\\n    begin\\n      maxArea := newA * newB;\\n    end;\\n  end;\\n\\n  \/\/ Output the result\\n  if maxArea > 0 then\\n  begin\\n    Writeln(newA, ' ', newB);\\n  end\\n  else\\n  begin\\n    Writeln('0 0');\\n  end;\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar a, b, x, y int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &a, &b, &x, &y)\\n\\n\\tgcd := math.GCD(x, y)\\n\\tx \/= gcd\\n\\ty \/= gcd\\n\\n\\tratio := math.Min(float64(a)\/float64(x), float64(b)\/float64(y))\\n\\n\\tnewA := int(ratio * float64(x))\\n\\tnewB := int(ratio * float64(y))\\n\\n\\tif newA <= a && newB <= b {\\n\\t\\tfmt.Printf(\\\"%d %d\\\", newA, newB)\\n\\t} else {\\n\\t\\tfmt.Println(\\\"0 0\\\")\\n\\t}\\n}","Javascript":"function findReducedSize(a, b, x, y) {\n    let gcd = function(a, b) {\n        if (b === 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n    \n    let gcdValue = gcd(x, y);\n    let reducedX = x \/ gcdValue;\n    let reducedY = y \/ gcdValue;\n    \n    let maxArea = Math.min(a \/ reducedX, b \/ reducedY);\n    \n    let reducedA = reducedX * maxArea;\n    let reducedB = reducedY * maxArea;\n    \n    if (reducedA <= a && reducedB <= b) {\n        return `${reducedA} ${reducedB}`;\n    } else {\n        return '0 0';\n    }\n}\n\nlet inputs = ['800 600 4 3\\n', '1920 1200 16 9\\n', '1 1 1 2\\n'];\nlet outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i].trim().split(' ');\n    let a = parseInt(input[0]);\n    let b = parseInt(input[1]);\n    let x = parseInt(input[2]);\n    let y = parseInt(input[3]);\n    \n    let result = findReducedSize(a, b, x, y);\n    outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val a = input[0]\n    val b = input[1]\n    val x = input[2]\n    val y = input[3]\n\n    val gcd = gcd(x, y)\n    val newX = x \/ gcd\n    val newY = y \/ gcd\n\n    val maxRatio = minOf(a \/ newX, b \/ newY)\n\n    val newA = newX * maxRatio\n    val newB = newY * maxRatio\n\n    if (newA <= a && newB <= b) {\n        println(\"$newA $newB\")\n    } else {\n        println(\"0 0\")\n    }\n}\n\nfun gcd(a: Int, b: Int): Int {\n    if (b == 0) {\n        return a\n    }\n    return gcd(b, a % b)\n}","PHP":"<?php\\n\\nfunction reduceMonitorSize($a, $b, $x, $y) {\\n    \/\/ Check if the screen parameters can be reduced\\n    if ($a % $x != 0 || $b % $y != 0) {\\n        return '0 0';\\n    }\\n\\n    \/\/ Calculate the reduced screen parameters\\n    $reduceFactor = min($a \/ $x, $b \/ $y);\\n    $reducedA = $x * $reduceFactor;\\n    $reducedB = $y * $reduceFactor;\\n\\n    return $reducedA . ' ' . $reducedB;\\n}\\n\\n\/\/ Read input from stdin\\n$input = explode(' ', trim(fgets(STDIN)));\\n$a = intval($input[0]);\\n$b = intval($input[1]);\\n$x = intval($input[2]);\\n$y = intval($input[3]);\\n\\n\/\/ Call the function and print the result\\n$result = reduceMonitorSize($a, $b, $x, $y);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int a, b, x, y;\\r\\n    readf(\\\"%d %d %d %d\\\", &a, &b, &x, &y);\\r\\n\\r\\n    int gcd = gcd(x, y);\\r\\n    x \/= gcd;\\r\\n    y \/= gcd;\\r\\n\\r\\n    int k1 = a \/ x;\\r\\n    int k2 = b \/ y;\\r\\n\\r\\n    int k = min(k1, k2);\\r\\n\\r\\n    writeln(x * k, \\\" \\\", y * k);\\r\\n}\\r\\n\\r\\nint gcd(int a, int b)\\r\\n{\\r\\n    while (b != 0)\\r\\n    {\\r\\n        int temp = b;\\r\\n        b = a % b;\\r\\n        a = temp;\\r\\n    }\\r\\n\\r\\n    return a;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub reduce_monitor_size {\n    my ($a, $b, $x, $y) = @_;\n\n    # Calculate the greatest common divisor (GCD) of x and y\n    my $gcd = gcd($x, $y);\n\n    # Calculate the reduced size of the monitor\n    my $reduced_a = $a \/ ($x \/ $gcd);\n    my $reduced_b = $b \/ ($y \/ $gcd);\n\n    # Check if the reduced size is valid\n    if ($reduced_a >= 1 && $reduced_b >= 1 && $reduced_a == int($reduced_a) && $reduced_b == int($reduced_b)) {\n        return \"$reduced_a $reduced_b\";\n    } else {\n        return \"0 0\";\n    }\n}\n\nsub gcd {\n    my ($a, $b) = @_;\n\n    while ($b != 0) {\n        my $temp = $b;\n        $b = $a % $b;\n        $a = $temp;\n    }\n\n    return $a;\n}\n\n# Read the input\nmy $input = <STDIN>;\nchomp $input;\nmy ($a, $b, $x, $y) = split ' ', $input;\n\n# Reduce the monitor size\nmy $result = reduce_monitor_size($a, $b, $x, $y);\n\n# Print the result\nprint \"$result\\n\";\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut input = input.trim().split_whitespace();\n    let a: u64 = input.next().unwrap().parse().unwrap();\n    let b: u64 = input.next().unwrap().parse().unwrap();\n    let x: u64 = input.next().unwrap().parse().unwrap();\n    let y: u64 = input.next().unwrap().parse().unwrap();\n\n    let gcd = gcd(x, y);\n    let x_ratio = x \/ gcd;\n    let y_ratio = y \/ gcd;\n\n    let max_ratio = a.min(b).min(a \/ x_ratio).min(b \/ y_ratio);\n\n    let reduced_a = max_ratio * x_ratio;\n    let reduced_b = max_ratio * y_ratio;\n\n    if reduced_a <= a && reduced_b <= b {\n        println!(\"{} {}\", reduced_a, reduced_b);\n    } else {\n        println!(\"0 0\");\n    }\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}"}
{"title":"A. Problem About Equation","description":"A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal. ","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a pair of integers n, b (2\u2264n\u2264100,1\u2264b\u2264100), where n is the total number of friends in the group and b is the current volume of drink in the bottle. The second line contains a sequence of integers a1,a2,...,an (0\u2264ai\u2264100), where ai is the current volume of drink in the i-th mug.\n","output_spec":"Print a single number \"-1\" (without the quotes), if there is no solution. Otherwise, print n float numbers c1,c2,...,cn, where ci is the volume of the drink to add in the i-th mug. Print the numbers with no less than 6 digits after the decimal point, print each ci on a single line. Polycarpus proved that if a solution exists then it is unique.\nRussian locale is installed by default on the testing computer. Make sure that your solution use the point to separate the integer part of a real number from the decimal, not a comma.\n","notes":null,"sample_inputs":["5 50\n1 2 3 4 5\n","2 2\n1 100\n"],"sample_outputs":["12.000000\n11.000000\n10.000000\n9.000000\n8.000000\n","-1\n"],"id":"174-A","difficulty":1100,"tags":["math"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e","C++":"#include <iostream>\\n#include <vector>\\n#include <iomanip>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, b;\\n    cin >> n >> b;\\n    vector<int> mugs(n);\\n    int totalVolume = 0;\\n    for (int i = 0; i < n; i++) {\\n        cin >> mugs[i];\\n        totalVolume += mugs[i];\\n    }\\n    if (totalVolume + b < n || (totalVolume + b) % n != 0) {\\n        cout << -1 << endl;\\n    } else {\\n        double volumeToAdd = (totalVolume + b) \/ n;\\n        cout << fixed << setprecision(6);\\n        for (int i = 0; i < n; i++) {\\n            cout << volumeToAdd - mugs[i] << endl;\\n        }\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int b = scanner.nextInt();\\n        int[] mugs = new int[n];\\n        int totalVolume = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            mugs[i] = scanner.nextInt();\\n            totalVolume += mugs[i];\\n        }\\n\\n        if (totalVolume + b < n || (totalVolume + b) % n != 0) {\\n            System.out.println(-1);\\n            return;\\n        }\\n\\n        double equalVolume = (totalVolume + b) \/ n;\\n\\n        for (int i = 0; i < n; i++) {\\n            double volumeToAdd = equalVolume - mugs[i];\\n            System.out.printf(\\\"%.6f\\\\n\\\", volumeToAdd);\\n        }\\n    }\\n}","Python":"def equal_volume(n, b, volumes):\n    total_volume = sum(volumes)\n    if total_volume + b % n != 0:\n        return '-1'\n    volume_per_mug = (total_volume + b) \/\/ n\n    result = []\n    for volume in volumes:\n        result.append(volume_per_mug - volume)\n    return '\\\\n'.join(['{:.6f}'.format(volume) for volume in result])\n\ninput_data = input().split('\\\\n')\nn, b = map(int, input_data[0].split())\nvolumes = list(map(int, input_data[1].split()))\nprint(equal_volume(n, b, volumes))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, b;\\n    scanf(\\\"%d %d\\\", &n, &b);\\n    int a[n];\\n    int sum = 0;\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n        sum += a[i];\\n    }\\n    if (sum + b < n || (sum + b) % n != 0) {\\n        printf(\\\"-1\\\\n\\\");\\n        return 0;\\n    }\\n    float c[n];\\n    float avg = (float)(sum + b) \/ n;\\n    for (int i = 0; i < n; i++) {\\n        c[i] = avg - a[i];\\n        printf(\\\"%.6f\\\\n\\\", c[i]);\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Linq;\n\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int b = int.Parse(input[1]);\n\n        int[] mugs = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int totalVolume = mugs.Sum();\n        int maxVolume = mugs.Max();\n\n        if ((totalVolume + b) % n != 0)\n        {\n            Console.WriteLine(\"-1\");\n            return;\n        }\n\n        int targetVolume = (totalVolume + b) \/ n;\n\n        double[] volumesToAdd = new double[n];\n        for (int i = 0; i < n; i++)\n        {\n            volumesToAdd[i] = targetVolume - mugs[i];\n        }\n\n        Console.WriteLine(string.Join(\"\\n\", volumesToAdd.Select(v => v.ToString(\"F6\"))));\n    }\n}","Ruby":"\ndef pour_ber_cola(input)\n  # Parse the input\n  n, b = input[0].split.map(&:to_i)\n  volumes = input[1].split.map(&:to_i)\n\n  # Calculate the total volume of drink in the mugs\n  total_volume = volumes.inject(:+)\n\n  # Check if it is possible to pour the remaining drink evenly\n  if (total_volume + b) % n != 0\n    return '-1'\n  end\n\n  # Calculate the volume of drink to add to each mug\n  volume_to_add = (total_volume + b) \/ n\n\n  # Calculate the volume of drink already in each mug\n  volumes_with_added = volumes.map { |volume| volume + volume_to_add }\n\n  # Format the output with 6 decimal places\n  output = volumes_with_added.map { |volume| format('%.6f', volume) }.join('\\n')\n\n  return output\nend\n\n# Test the function with the sample inputs\ninput1 = '5 50\\n1 2 3 4 5\\n'\noutput1 = pour_ber_cola(input1)\nputs output1 # Expected output: '12.000000\\n11.000000\\n10.000000\\n9.000000\\n8.000000\\n'\n\ninput2 = '2 2\\n1 100\\n'\noutput2 = pour_ber_cola(input2)\nputs output2 # Expected output: '-1'\n","delphi":"program BerCola;\\n\\nvar\\n  n, b, i: integer;\\n  a: array[1..100] of integer;\\n  c: array[1..100] of real;\\n  sum: real;\\n\\nbegin\\n  readln(n, b);\\n  for i := 1 to n do\\n    read(a[i]);\\n  sum := 0;\\n  for i := 1 to n do\\n    sum := sum + a[i];\\n  if sum + b < n then\\n    writeln('-1')\\n  else\\n  begin\\n    for i := 1 to n do\\n      c[i] := (sum + b) \/ n - a[i];\\n    for i := 1 to n do\\n      writeln(c[i]:0:6);\\n  end;\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnb := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nb[0])\\n\\tb, _ := strconv.Atoi(nb[1])\\n\\n\\tscanner.Scan()\\n\\tmugs := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\ttotalVolume := 0\\n\\tmaxVolume := 0\\n\\n\\tfor _, mug := range mugs {\\n\\t\\tvolume, _ := strconv.Atoi(mug)\\n\\t\\ttotalVolume += volume\\n\\t\\tif volume > maxVolume {\\n\\t\\t\\tmaxVolume = volume\\n\\t\\t}\\n\\t}\\n\\n\\tif (totalVolume+b)%n != 0 {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\ttargetVolume := (totalVolume + b) \/ n\\n\\n\\tif targetVolume < maxVolume {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor _, mug := range mugs {\\n\\t\\tvolume, _ := strconv.Atoi(mug)\\n\\t\\tfmt.Printf(\\\"%.6f\\\\n\\\", float64(targetVolume-volume))\\n\\t}\\n}","Javascript":"function equalizeVolumes(input) {\n  let [n, b] = input[0].split(' ').map(Number);\n  let volumes = input[1].split(' ').map(Number);\n  \n  let totalVolume = volumes.reduce((a, b) => a + b, 0);\n  let targetVolume = totalVolume + b;\n  \n  if (targetVolume % n !== 0) {\n    return '-1';\n  }\n  \n  let addVolume = (targetVolume - totalVolume) \/ n;\n  let result = [];\n  \n  for (let i = 0; i < n; i++) {\n    let volumeToAdd = addVolume - volumes[i];\n    result.push(volumeToAdd.toFixed(6));\n  }\n  \n  return result.join('\\\\n');\n}\n\nlet input = ['5 50\\\\n1 2 3 4 5\\\\n'];\nconsole.log(equalizeVolumes(input));","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val b = input[1].toInt()\n    \n    val volumes = scanner.nextLine().split(\" \").map { it.toInt() }\n    val totalVolume = volumes.sum()\n    \n    if (totalVolume + b < n || (totalVolume + b) % n != 0) {\n        println(\"-1\")\n    } else {\n        val targetVolume = (totalVolume + b) \/ n\n        val additions = volumes.map { targetVolume - it }\n        additions.forEach { println(\"%.6f\".format(it)) }\n    }\n}","PHP":"<?php\\n\\nfunction equalizeDrinkVolumes($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $params = explode(\\\" \\\", $lines[0]);\\n    $n = intval($params[0]);\\n    $b = intval($params[1]);\\n    $volumes = explode(\\\" \\\", $lines[1]);\\n    $totalVolume = array_sum($volumes);\\n    $targetVolume = ($totalVolume + $b) \/ $n;\\n    $result = [];\\n\\n    foreach ($volumes as $volume) {\\n        $diff = $targetVolume - $volume;\\n        if ($diff < 0) {\\n            return \\\"-1\\\";\\n        }\\n        $result[] = number_format($diff, 6, '.', '');\\n    }\\n\\n    return implode(\\\"\\\\n\\\", $result);\\n}\\n\\n$input = '5 50\\\\n1 2 3 4 5\\\\n';\\necho equalizeDrinkVolumes($input);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, b;\\r\\n    readf(\\\"%d %d\\\", &n, &b);\\r\\n\\r\\n    int[] mugs = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &mugs[i]);\\r\\n    }\\r\\n\\r\\n    int totalVolume = b + mugs.reduce!((a, b) => a + b);\\r\\n    int equalVolume = totalVolume \/ n;\\r\\n\\r\\n    if (totalVolume % n != 0)\\r\\n    {\\r\\n        writeln(\\\"-1\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        writeln(cast(double)(equalVolume - mugs[i]));\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub pour_ber_cola {\\n    my ($n, $b, @mugs) = @_;\\n    my $total_volume = $b + sum(@mugs);\\n    my $avg_volume = $total_volume \/ $n;\\n    my @volumes;\\n\\n    foreach my $mug (@mugs) {\\n        my $volume_diff = $avg_volume - $mug;\\n        if ($volume_diff < 0) {\\n            return -1;\\n        }\\n        push @volumes, sprintf('%.6f', $volume_diff);\\n    }\\n\\n    return join(\\\"\\\\n\\\", @volumes);\\n}\\n\\nsub sum {\\n    my $sum = 0;\\n    foreach my $num (@_) {\\n        $sum += $num;\\n    }\\n    return $sum;\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $b) = split(' ', $input);\\n\\n$input = <STDIN>;\\nchomp $input;\\nmy @mugs = split(' ', $input);\\n\\n# Call the function and print the result\\nmy $result = pour_ber_cola($n, $b, @mugs);\\nprint $result;","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nb: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nb[0];\n    let b = nb[1];\n    \n    let a: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let total_volume: usize = a.iter().sum();\n    \n    if total_volume + b < n || (total_volume + b) % n != 0 {\n        println!(\"-1\");\n        return;\n    }\n    \n    let volume_per_mug = (total_volume + b) \/ n;\n    \n    for i in 0..n {\n        let volume_to_add = volume_per_mug - a[i];\n        println!(\"{:.6}\", volume_to_add as f64);\n    }\n}"}
{"title":"D. Notepad","description":"Nick is attracted by everything unconventional. He doesn't like decimal number system any more, and he decided to study other number systems. A number system with base b caught his attention. Before he starts studying it, he wants to write in his notepad all the numbers of length n without leading zeros in this number system. Each page in Nick's notepad has enough space for c numbers exactly. Nick writes every suitable number only once, starting with the first clean page and leaving no clean spaces. Nick never writes number 0 as he has unpleasant memories about zero divide.Would you help Nick find out how many numbers will be written on the last page.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"64 megabytes","input_spec":"The only input line contains three space-separated integers b, n and c (2\u2264b<10^10^6, 1\u2264n<10^10^6, 1\u2264c\u226410^9). You may consider that Nick has infinite patience, endless amount of paper and representations of digits as characters. The numbers doesn't contain leading zeros.\n","output_spec":"In the only line output the amount of numbers written on the same page as the last number.\n","notes":"In both samples there are exactly 4 numbers of length 3 in binary number system. In the first sample Nick writes 3 numbers on the first page and 1 on the second page. In the second sample all the 4 numbers can be written on the first page.\n","sample_inputs":["2 3 3\n","2 3 4\n"],"sample_outputs":["1","4"],"id":"17-D","difficulty":2400,"tags":["number+theory"],"src_uid":"566adc43d2d6df257c26c5f5495a5745","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    long long b, n, c;\\n    cin >> b >> n >> c;\\n\\n    long long page = 1;\\n    long long count = 0;\\n\\n    while (count < n) {\\n        long long numbers_on_page = min(n - count, c);\\n        count += numbers_on_page;\\n        page++;\\n    }\\n\\n    cout << page - 1 << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        long b = Long.parseLong(input[0]);\\n        long n = Long.parseLong(input[1]);\\n        long c = Long.parseLong(input[2]);\\n\\n        long pagesNeeded = (long) Math.ceil((double) n \/ c);\\n        long numbersOnLastPage = n % c;\\n\\n        if (numbersOnLastPage == 0) {\\n            numbersOnLastPage = c;\\n        }\\n\\n        long totalNumbers = (long) Math.pow(b, n);\\n        long numbersOnPreviousPages = (pagesNeeded - 1) * c;\\n        long numbersOnCurrentPage = totalNumbers - numbersOnPreviousPages;\\n\\n        if (numbersOnCurrentPage > c) {\\n            numbersOnCurrentPage = c;\\n        }\\n\\n        long numbersOnLastPage = numbersOnCurrentPage - numbersOnPreviousPages;\\n\\n        System.out.println(numbersOnLastPage);\\n    }\\n}","Python":"def find_last_page(b, n, c):\\n    total_numbers = b ** n - 1\\n    last_page_numbers = total_numbers % c\\n    return str(last_page_numbers)\\n\\ninput_data = input().split()\\nb = int(input_data[0])\\nn = int(input_data[1])\\nc = int(input_data[2])\\n\\nprint(find_last_page(b, n, c))","C":"#include <stdio.h>\\n\\nint main() {\\n    long long b, n, c;\\n    scanf(\\\"%lld %lld %lld\\\", &b, &n, &c);\\n    long long page = (n + c - 1) \/ c;\\n    long long last_page = n % c;\\n    if (last_page == 0) {\\n        last_page = c;\\n    }\\n    long long numbers_on_last_page = (b - 1) * last_page;\\n    printf(\\\"%lld\\\", numbers_on_last_page);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        long b = long.Parse(input[0]);\n        long n = long.Parse(input[1]);\n        long c = long.Parse(input[2]);\n        \n        long lastPageCount = (n + c - 1) \/ c;\n        long remainingNumbers = n % c;\n        \n        if (remainingNumbers == 0)\n        {\n            remainingNumbers = c;\n        }\n        \n        long lastPageNumbers = (b - 1) * (lastPageCount - 1) + remainingNumbers;\n        \n        Console.WriteLine(lastPageNumbers);\n    }\n}","Ruby":"\ndef find_last_page(b, n, c)\n  total_numbers = b**(n-1) - 1\n  last_page_numbers = total_numbers % c\n  return last_page_numbers\nend\n\ninput = gets.chomp.split(' ').map(&:to_i)\nb = input[0]\nn = input[1]\nc = input[2]\n\noutput = find_last_page(b, n, c)\nputs output\n","delphi":"var\n  b, n, c, lastPage, numbersPerPage, remainingNumbers: Int64;\nbegin\n  \/\/ Read input values\n  ReadLn(b, n, c);\n  \n  \/\/ Calculate the number of numbers per page\n  numbersPerPage := c;\n  \n  \/\/ Calculate the number of pages needed to write all numbers\n  lastPage := 0;\n  remainingNumbers := n;\n  while remainingNumbers > 0 do\n  begin\n    Inc(lastPage);\n    Dec(remainingNumbers, numbersPerPage);\n  end;\n  \n  \/\/ Calculate the number of numbers on the last page\n  if remainingNumbers = 0 then\n    WriteLn(numbersPerPage)\n  else\n    WriteLn(numbersPerPage + remainingNumbers);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar b, n, c int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &b, &n, &c)\\n\\n\\tnumbersPerPage := c\\n\\ttotalNumbers := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tnumbersPerPage *= b\\n\\t\\tif numbersPerPage >= n {\\n\\t\\t\\ttotalNumbers += n\\n\\t\\t\\tbreak\\n\\t\\t} else {\\n\\t\\t\\ttotalNumbers += numbersPerPage\\n\\t\\t}\\n\\t}\\n\\n\\tlastPageNumbers := totalNumbers % c\\n\\n\\tif lastPageNumbers == 0 {\\n\\t\\tlastPageNumbers = c\\n\\t}\\n\\n\\tfmt.Println(lastPageNumbers)\\n}","Javascript":"function findLastPageNumbers(input) {\n  const [b, n, c] = input.split(' ').map(Number);\n  let page = 1;\n  let count = 0;\n\n  while (count < n) {\n    const numbersPerPage = Math.min(c, n - count);\n    const numbersOnPage = Math.pow(b, page) - Math.pow(b, page - 1);\n    const pagesNeeded = Math.ceil(numbersPerPage \/ numbersOnPage);\n    count += numbersPerPage;\n    page += pagesNeeded;\n  }\n\n  return String(Math.pow(b, page - 1));\n}\n\nconst inputs = ['2 3 3\\n', '2 3 4\\n'];\nconst outputs = inputs.map(findLastPageNumbers);\n\nJSON.stringify(outputs);","Kotlin":"import kotlin.math.pow\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toLong() }\\n    val b = input[0]\\n    val n = input[1]\\n    val c = input[2]\\n\\n    val lastPage = (n - 1) \/ c + 1\\n    val numbersOnLastPage = (b.toDouble().pow(n.toInt()) - 1) % c + 1\\n\\n    println(numbersOnLastPage.toInt())\\n}","PHP":"\n<?php\n\nfunction findLastPage($b, $n, $c) {\n    $totalNumbers = pow($b, $n) - 1; \/\/ Total numbers of length n without leading zeros\n    $lastPageNumbers = $totalNumbers % $c; \/\/ Numbers on the last page\n    \n    return $lastPageNumbers;\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$b = intval($input[0]);\n$n = intval($input[1]);\n$c = intval($input[2]);\n\n$result = findLastPage($b, $n, $c);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] input = readln().split;\\r\\n    ulong b = to!ulong(input[0]);\\r\\n    ulong n = to!ulong(input[1]);\\r\\n    ulong c = to!ulong(input[2]);\\r\\n\\r\\n    ulong numbersPerPage = c;\\r\\n    ulong totalPages = (n + numbersPerPage - 1) \/ numbersPerPage;\\r\\n    ulong lastPageNumbers = n % numbersPerPage;\\r\\n\\r\\n    if (lastPageNumbers == 0)\\r\\n    {\\r\\n        lastPageNumbers = numbersPerPage;\\r\\n    }\\r\\n\\r\\n    writeln(lastPageNumbers);\\r\\n}","perl":"\n# Read the input values\nmy $input = <STDIN>;\nchomp $input;\nmy ($b, $n, $c) = split ' ', $input;\n\n# Calculate the number of numbers that can be written on each page\nmy $numbers_per_page = int($c \/ $n);\n\n# Calculate the number of pages needed to write all the numbers\nmy $total_pages = int(($b ** $n) \/ $c) + 1;\n\n# Calculate the number of numbers written on the last page\nmy $numbers_on_last_page = ($b ** $n) % $c;\n\n# If there are no numbers on the last page, set it to the maximum number of numbers per page\n$numbers_on_last_page = $numbers_per_page if $numbers_on_last_page == 0;\n\n# Print the number of numbers on the last page\nprint $numbers_on_last_page;\n","Rust":"fn main() {\\n    let input = String::from(\\\"2 3 3\\\");\\n    let mut input = input.split_whitespace();\\n    let b: u64 = input.next().unwrap().parse().unwrap();\\n    let n: u64 = input.next().unwrap().parse().unwrap();\\n    let c: u64 = input.next().unwrap().parse().unwrap();\\n\\n    let mut page = 1;\\n    let mut count = 0;\\n\\n    while count < n {\\n        let numbers_on_page = (b.pow(page) - 1) * c;\\n        if count + numbers_on_page >= n {\\n            let remaining_numbers = n - count;\\n            let last_page_numbers = remaining_numbers % c;\\n            if last_page_numbers == 0 {\\n                println!(\\\"{}\\\", c);\\n            } else {\\n                println!(\\\"{}\\\", last_page_numbers);\\n            }\\n            break;\\n        }\\n        count += numbers_on_page;\\n        page += 1;\\n    }\\n}"}
{"title":"A. Plant","description":"Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process. Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer n (0\u2264n\u226410^18) \u2014 the number of full years when the plant grew.\nPlease do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.\n","output_spec":"Print a single integer \u2014 the remainder of dividing the number of plants that will point \"upwards\" in n years by 1000000007 (10^9+7).\n","notes":"The first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.\n","sample_inputs":["1\n","2\n"],"sample_outputs":["3\n","10\n"],"id":"185-A","difficulty":1300,"tags":["math"],"src_uid":"782b819eb0bfc86d6f96f15ac09d5085","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    long long n;\\n    cin >> n;\\n    \\n    long long ans = pow(3, n);\\n    \\n    cout << ans % 1000000007 << endl;\\n    \\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class TrianglePlants {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        long n = scanner.nextLong();\\n        long mod = 1000000007;\\n\\n        \/\/ Calculate the number of plants pointing upwards in n years\\n        long result = calculatePlants(n);\\n\\n        \/\/ Print the remainder of dividing the result by mod\\n        System.out.println(result % mod);\\n    }\\n\\n    public static long calculatePlants(long n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n\\n        \/\/ Calculate the number of plants pointing upwards in n-1 years\\n        long prevPlants = calculatePlants(n - 1);\\n\\n        \/\/ Calculate the number of plants pointing upwards in n years\\n        long currPlants = (3 * prevPlants + 1) % 1000000007;\\n\\n        return currPlants;\\n    }\\n}","Python":"def count_triangle_plants(n):\\n    mod = 1000000007\\n    if n == 0:\\n        return 1\\n    elif n % 2 == 0:\\n        return (count_triangle_plants(n-1) * 3 + 1) % mod\\n    else:\\n        return (count_triangle_plants(n-1) * 4 - 1) % mod\\n\\nn = int(input())\\nresult = count_triangle_plants(n)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    long long n;\\n    scanf(\\\"%lld\\\", &n);\\n    long long ans = 1;\\n    for (int i = 0; i < n; i++) {\\n        ans = (ans * 3) % 1000000007;\\n    }\\n    printf(\\\"%lld\\\\n\\\", ans);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace TrianglePlants\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            long n = long.Parse(Console.ReadLine());\n\n            long mod = 1000000007;\n\n            \/\/ Calculate the number of plants that point upwards in n years\n            long result = CalculatePlants(n, mod);\n\n            Console.WriteLine(result);\n        }\n\n        static long CalculatePlants(long n, long mod)\n        {\n            \/\/ Base case: If n is 0, return 1\n            if (n == 0)\n                return 1;\n\n            \/\/ Recursive case: Calculate the number of plants in n-1 years\n            long previousPlants = CalculatePlants(n - 1, mod);\n\n            \/\/ Calculate the number of plants in n years based on the previous year's plants\n            long currentPlants = (3 * previousPlants + 1) % mod;\n\n            return currentPlants;\n        }\n    }\n}\n","Ruby":"\ndef count_triangle_plants(n)\n  return 1 if n == 0\n  return 3 if n == 1\n\n  # Initialize variables\n  a = 1\n  b = 3\n\n  # Calculate the number of plants that point \"upwards\" in n years\n  (2..n).each do |i|\n    temp = b\n    b = (3 * b + a) % 1000000007\n    a = temp\n  end\n\n  return b\nend\n\n# Read input from standard input\nn = gets.chomp.to_i\n\n# Calculate and print the result\nresult = count_triangle_plants(n)\nputs result\n","delphi":"program TrianglePlants;\\n\\nvar\\n  n: Int64;\\n\\nfunction PowerMod(a, b, m: Int64): Int64;\\nvar\\n  res: Int64;\\nbegin\\n  res := 1;\\n  while b > 0 do\\n  begin\\n    if b and 1 = 1 then\\n      res := (res * a) mod m;\\n    a := (a * a) mod m;\\n    b := b shr 1;\\n  end;\\n  Result := res;\\nend;\\n\\nbegin\\n  ReadLn(n);\\n  WriteLn(PowerMod(3, n, 1000000007));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\t\/\/ Initialize the number of plants pointing upwards\\n\\tupwards := 1\\n\\n\\t\/\/ Iterate for n years\\n\\tfor i := 0; i < n; i++ {\\n\\t\\t\/\/ Calculate the number of plants pointing upwards in the next year\\n\\t\\tupwards = (upwards*3 + 1) % 1000000007\\n\\t}\\n\\n\\t\/\/ Print the result\\n\\tfmt.Println(upwards)\\n}","Javascript":"function countTrianglePlants(n) {\n    let mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        dp[i] = (3 * dp[i - 1]) % mod;\n    }\n    \n    let ans = dp[n];\n    for (let i = 1; i <= n; i++) {\n        ans = (ans + dp[i - 1] * dp[n - i]) % mod;\n    }\n    \n    return ans;\n}\n\nlet n = parseInt(readline());\nlet result = countTrianglePlants(n);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextLong()\n    \n    val result = calculateUpwardsPlants(n)\n    println(result)\n}\n\nfun calculateUpwardsPlants(n: Long): Long {\n    val mod = 1000000007L\n    \n    \/\/ Base case\n    if (n == 0L) {\n        return 1L\n    }\n    \n    \/\/ Recursive case\n    val previousPlants = calculateUpwardsPlants(n - 1)\n    val newPlants = (previousPlants * 4) % mod\n    \n    return if (n % 2 == 0L) {\n        (newPlants - 1 + mod) % mod\n    } else {\n        (newPlants + 1) % mod\n    }\n}","PHP":"\n<?php\n\nfunction countUpwardsPlants($n) {\n    $mod = 1000000007;\n    $upwards = 1;\n    $downwards = 0;\n    \n    for ($i = 1; $i <= $n; $i++) {\n        $newUpwards = ($upwards * 3 + $downwards) % $mod;\n        $newDownwards = ($upwards + $downwards) % $mod;\n        \n        $upwards = $newUpwards;\n        $downwards = $newDownwards;\n    }\n    \n    return $upwards;\n}\n\n$input = trim(fgets(STDIN));\n$n = intval($input);\n\n$result = countUpwardsPlants($n);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\n\\r\\nulong countUpwardsPlants(ulong n)\\r\\n{\\r\\n    if (n == 0)\\r\\n        return 1;\\r\\n    else\\r\\n        return (countUpwardsPlants(n-1) * 3 + 1) % 1000000007;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    ulong n;\\r\\n    readf(\\\"%lu\\\", &n);\\r\\n    writeln(countUpwardsPlants(n));\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_upwards_plants {\n    my ($n) = @_;\n    \n    my $mod = 1000000007;\n    my $upwards_plants = 1;\n    \n    for (my $i = 1; $i <= $n; $i++) {\n        $upwards_plants = ($upwards_plants * 3) % $mod;\n    }\n    \n    return $upwards_plants;\n}\n\nmy $n = <STDIN>;\nchomp($n);\n\nmy $result = count_upwards_plants($n);\nprint $result;\n","Rust":"\n\nfn main() {\n    let modulo = 1000000007;\n    let mut n = String::new();\n    std::io::stdin().read_line(&mut n).unwrap();\n    let n: u64 = n.trim().parse().unwrap();\n\n    let mut result = 1;\n    let mut power = 1;\n\n    for _ in 0..n {\n        power = (power * 3) % modulo;\n        result = (result + power) % modulo;\n    }\n\n    println!(\"{}\", result);\n}\n"}
{"title":"B. Mushroom Scientists","description":"As you very well know, the whole Universe traditionally uses three-dimensional Cartesian system of coordinates. In this system each point corresponds to three real coordinates (x,y,z). In this coordinate system, the distance between the center of the Universe and the point is calculated by the following formula: . Mushroom scientists that work for the Great Mushroom King think that the Universe isn't exactly right and the distance from the center of the Universe to a point equals x^a\u00b7y^b\u00b7z^c.To test the metric of mushroom scientists, the usual scientists offered them a task: find such x,y,z (0\u2264x,y,z;\u00a0x+y+z\u2264S), that the distance between the center of the Universe and the point (x,y,z) is maximum possible in the metric of mushroom scientists. The mushroom scientists aren't good at maths, so they commissioned you to do the task.Note that in this problem, it is considered that 0^0=1.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer S (1\u2264S\u226410^3) \u2014 the maximum sum of coordinates of the sought point.\nThe second line contains three space-separated integers a, b, c (0\u2264a,b,c\u226410^3) \u2014 the numbers that describe the metric of mushroom scientists.\n","output_spec":"Print three real numbers \u2014 the coordinates of the point that reaches maximum value in the metrics of mushroom scientists. If there are multiple answers, print any of them that meets the limitations.\nA natural logarithm of distance from the center of the Universe to the given point in the metric of mushroom scientists shouldn't differ from the natural logarithm of the maximum distance by more than 10^-6. We think that ln(0)=-\u221e.\n","notes":null,"sample_inputs":["3\n1 1 1\n","3\n2 0 0\n"],"sample_outputs":["1.0 1.0 1.0\n","3.0 0.0 0.0\n"],"id":"185-B","difficulty":1800,"tags":["math","ternary+search"],"src_uid":"0a9cabb857949e818453ffe411f08f95","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int S, a, b, c;\\n    cin >> S >> a >> b >> c;\\n\\n    double x, y, z;\\n\\n    if (a == 0 && b == 0 && c == 0) {\\n        x = y = z = 0;\\n    } else if (a == 0 && b == 0) {\\n        x = S;\\n        y = z = 0;\\n    } else if (a == 0 && c == 0) {\\n        x = S;\\n        y = 0;\\n        z = S;\\n    } else if (b == 0 && c == 0) {\\n        x = 0;\\n        y = S;\\n        z = S;\\n    } else if (a == 0) {\\n        x = S;\\n        y = z = 0;\\n    } else if (b == 0) {\\n        x = 0;\\n        y = S;\\n        z = 0;\\n    } else if (c == 0) {\\n        x = 0;\\n        y = 0;\\n        z = S;\\n    } else {\\n        double sum = a + b + c;\\n        x = (a \/ sum) * S;\\n        y = (b \/ sum) * S;\\n        z = (c \/ sum) * S;\\n    }\\n\\n    cout.precision(10);\\n    cout << fixed << x << \\\" \\\" << y << \\\" \\\" << z << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int S = scanner.nextInt();\\n        int a = scanner.nextInt();\\n        int b = scanner.nextInt();\\n        int c = scanner.nextInt();\\n\\n        double x, y, z;\\n\\n        if (a == 0 && b == 0 && c == 0) {\\n            x = y = z = 0;\\n        } else if (a == 0 && b == 0) {\\n            x = S;\\n            y = z = 0;\\n        } else if (a == 0 && c == 0) {\\n            x = S;\\n            y = 0;\\n            z = S;\\n        } else if (b == 0 && c == 0) {\\n            x = 0;\\n            y = S;\\n            z = S;\\n        } else if (a == 0) {\\n            x = S;\\n            y = z = 0;\\n        } else if (b == 0) {\\n            x = 0;\\n            y = S;\\n            z = 0;\\n        } else if (c == 0) {\\n            x = 0;\\n            y = 0;\\n            z = S;\\n        } else {\\n            double sum = a + b + c;\\n            x = (a \/ sum) * S;\\n            y = (b \/ sum) * S;\\n            z = (c \/ sum) * S;\\n        }\\n\\n        System.out.println(x + \\\" \\\" + y + \\\" \\\" + z);\\n    }\\n}","Python":"import math\\n\\ndef find_maximum_point(S, a, b, c):\\n    # Calculate the maximum distance\\n    max_distance = math.exp(math.log(S) \/ (a + b + c))\\n    \\n    # Calculate the coordinates\\n    x = max_distance ** (1 \/ a)\\n    y = max_distance ** (1 \/ b)\\n    z = max_distance ** (1 \/ c)\\n    \\n    return f'{x:.6f} {y:.6f} {z:.6f}'\\n\\n# Read input\\nS = int(input())\\na, b, c = map(int, input().split())\\n\\n# Find the maximum point\\nresult = find_maximum_point(S, a, b, c)\\n\\n# Print the result\\nprint(result)","C":"#include <stdio.h>\\n#include <math.h>\\n\\nint main() {\\n    int S, a, b, c;\\n    scanf(\\\"%d\\\", &S);\\n    scanf(\\\"%d %d %d\\\", &a, &b, &c);\\n\\n    double x, y, z;\\n\\n    if (a == 0 && b == 0 && c == 0) {\\n        x = y = z = 0;\\n    } else if (a == 0 && b == 0) {\\n        x = S;\\n        y = z = 0;\\n    } else if (a == 0 && c == 0) {\\n        x = y = 0;\\n        z = S;\\n    } else if (b == 0 && c == 0) {\\n        x = y = 0;\\n        z = S;\\n    } else if (a == 0) {\\n        x = S;\\n        y = z = 0;\\n    } else if (b == 0) {\\n        x = 0;\\n        y = S;\\n        z = 0;\\n    } else if (c == 0) {\\n        x = 0;\\n        y = 0;\\n        z = S;\\n    } else {\\n        double sum = a + b + c;\\n        x = (a \/ sum) * S;\\n        y = (b \/ sum) * S;\\n        z = (c \/ sum) * S;\\n    }\\n\\n    printf(\\\"%.6lf %.6lf %.6lf\\\\n\\\", x, y, z);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string input = Console.ReadLine();\n        int S = int.Parse(input);\n        \n        input = Console.ReadLine();\n        string[] metrics = input.Split(' ');\n        int a = int.Parse(metrics[0]);\n        int b = int.Parse(metrics[1]);\n        int c = int.Parse(metrics[2]);\n        \n        double x, y, z;\n        \n        if (a == 0 && b == 0 && c == 0)\n        {\n            x = y = z = 0;\n        }\n        else if (a == 0 && b == 0)\n        {\n            x = S;\n            y = z = 0;\n        }\n        else if (a == 0 && c == 0)\n        {\n            x = y = 0;\n            z = S;\n        }\n        else if (b == 0 && c == 0)\n        {\n            x = 0;\n            y = z = S;\n        }\n        else if (a == 0)\n        {\n            x = S;\n            y = z = 0;\n        }\n        else if (b == 0)\n        {\n            x = 0;\n            y = S;\n            z = 0;\n        }\n        else if (c == 0)\n        {\n            x = 0;\n            y = 0;\n            z = S;\n        }\n        else\n        {\n            double sum = a + b + c;\n            x = (a \/ sum) * S;\n            y = (b \/ sum) * S;\n            z = (c \/ sum) * S;\n        }\n        \n        Console.WriteLine($\"{x} {y} {z}\");\n    }\n}","Ruby":"def find_maximum_point(input)\n  s, a, b, c = input.split(\"\\n\").map(&:to_i)\n  \n  if a == 0 && b == 0 && c == 0\n    return \"0.0 0.0 0.0\"\n  end\n  \n  if a == 0 && b == 0\n    return \"#{s} 0.0 0.0\"\n  end\n  \n  if a == 0 && c == 0\n    return \"0.0 #{s} 0.0\"\n  end\n  \n  if b == 0 && c == 0\n    return \"0.0 0.0 #{s}\"\n  end\n  \n  if a == 0\n    return \"#{s} 0.0 0.0\"\n  end\n  \n  if b == 0\n    return \"0.0 #{s} 0.0\"\n  end\n  \n  if c == 0\n    return \"0.0 0.0 #{s}\"\n  end\n  \n  x = (s.to_f \/ (a + b + c)) ** (1.0 \/ a)\n  y = (s.to_f \/ (a + b + c)) ** (1.0 \/ b)\n  z = (s.to_f \/ (a + b + c)) ** (1.0 \/ c)\n  \n  return \"#{x.round(6)} #{y.round(6)} #{z.round(6)}\"\nend\n\ninput = '3\\n1 1 1\\n'\nputs find_maximum_point(input)\n\ninput = '3\\n2 0 0\\n'\nputs find_maximum_point(input)\n","delphi":"program MaximumDistance;\n\nvar\n  S, a, b, c: Integer;\n  x, y, z: Real;\n\nbegin\n  \/\/ Read input values\n  Readln(S);\n  Readln(a, b, c);\n  \n  \/\/ Calculate the coordinates of the point\n  x := S \/ (a + b + c);\n  y := x;\n  z := x;\n  \n  \/\/ Print the coordinates\n  Writeln(x:0:1, ' ', y:0:1, ' ', z:0:1);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar S, a, b, c float64\\n\\tfmt.Scan(&S)\\n\\tfmt.Scan(&a, &b, &c)\\n\\n\\t\/\/ Calculate the maximum distance\\n\\tmaxDistance := math.Pow(S, (a+b+c)\/3)\\n\\n\\t\/\/ Print the coordinates\\n\\tfmt.Printf(\\\"%.6f %.6f %.6f\\\\n\\\", maxDistance, 0.0, 0.0)\\n}","Javascript":"const solveProblem = (input) => {\n  const lines = input.split('\\\\n');\n  const S = parseInt(lines[0]);\n  const [a, b, c] = lines[1].split(' ').map(Number);\n\n  let x, y, z;\n\n  if (a === 0 && b === 0 && c === 0) {\n    x = y = z = 0;\n  } else if (a === 0 && b === 0) {\n    x = S;\n    y = z = 0;\n  } else if (a === 0 && c === 0) {\n    x = y = 0;\n    z = S;\n  } else if (b === 0 && c === 0) {\n    x = 0;\n    y = z = S;\n  } else if (a === 0) {\n    x = S;\n    y = z = 0;\n  } else if (b === 0) {\n    x = 0;\n    y = S;\n    z = 0;\n  } else if (c === 0) {\n    x = 0;\n    y = 0;\n    z = S;\n  } else {\n    const sum = a + b + c;\n    x = (a \/ sum) * S;\n    y = (b \/ sum) * S;\n    z = (c \/ sum) * S;\n  }\n\n  return `${x.toFixed(6)} ${y.toFixed(6)} ${z.toFixed(6)}\\\\n`;\n};\n\nconst inputs = ['3\\\\n1 1 1\\\\n', '3\\\\n2 0 0\\\\n'];\nconst outputs = ['1.0 1.0 1.0\\\\n', '3.0 0.0 0.0\\\\n'];\n\nlet results = [];\nfor (let i = 0; i < inputs.length; i++) {\n  const input = inputs[i];\n  const expectedOutput = outputs[i];\n  const actualOutput = solveProblem(input);\n  const result = actualOutput === expectedOutput ? 'pass' : 'fail';\n  results.push(result);\n}\n\nJSON.stringify({ version: process.version, sourceCode: solveProblem.toString(), results });","Kotlin":"import kotlin.math.ln\\n\\nfun main() {\\n    val input = readLine()!!.split(\"\\\\n\")\\n    val s = input[0].toInt()\\n    val abc = input[1].split(\" \").map { it.toInt() }\\n    val a = abc[0]\\n    val b = abc[1]\\n    val c = abc[2]\\n\\n    val x = if (a == 0) s.toDouble() else s.toDouble() \/ (a + 1)\\n    val y = if (b == 0) s.toDouble() else s.toDouble() \/ (b + 1)\\n    val z = if (c == 0) s.toDouble() else s.toDouble() \/ (c + 1)\\n\\n    println(\\\"$x $y $z\\\")\\n}","PHP":"<?php\\n\\nfunction findCoordinates($S, $a, $b, $c) {\\n    \/\/ Calculate the maximum value of x, y, and z\\n    $x = $S;\\n    $y = 0;\\n    $z = 0;\\n\\n    \/\/ If a is greater than 0, set y to the maximum value\\n    if ($a > 0) {\\n        $y = $S;\\n    }\\n\\n    \/\/ If b is greater than 0, set z to the maximum value\\n    if ($b > 0) {\\n        $z = $S;\\n    }\\n\\n    \/\/ If c is greater than 0, set x to the maximum value\\n    if ($c > 0) {\\n        $x = $S;\\n    }\\n\\n    \/\/ Return the coordinates as a string\\n    return $x . ' ' . $y . ' ' . $z;\\n}\\n\\n\/\/ Read the input values\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$S = intval($input[0]);\\nlist($a, $b, $c) = array_map('intval', explode(' ', $input[1]));\\n\\n\/\/ Find the coordinates\\n$coordinates = findCoordinates($S, $a, $b, $c);\\n\\n\/\/ Print the coordinates\\necho $coordinates;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.math;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int S;\\r\\n    int a, b, c;\\r\\n    double x, y, z;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &S);\\r\\n    readf(\\\"%d %d %d\\\", &a, &b, &c);\\r\\n\\r\\n    \/\/ Calculate coordinates\\r\\n    if (a == 0 && b == 0 && c == 0)\\r\\n    {\\r\\n        x = y = z = 0;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        double maxCoord = S \/ (a + b + c);\\r\\n        x = maxCoord * a;\\r\\n        y = maxCoord * b;\\r\\n        z = maxCoord * c;\\r\\n    }\\r\\n\\r\\n    \/\/ Print output\\r\\n    writefln(\\\"%.6f %.6f %.6f\\\", x, y, z);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_maximum_point {\\n    my ($S, $a, $b, $c) = @_;\\n    my $x = 0;\\n    my $y = 0;\\n    my $z = 0;\\n\\n    if ($a == 0 && $b == 0 && $c == 0) {\\n        return \\\"0.0 0.0 0.0\\\";\\n    }\\n\\n    if ($a == 0) {\\n        $x = $S;\\n    }\\n    elsif ($b == 0) {\\n        $y = $S;\\n    }\\n    elsif ($c == 0) {\\n        $z = $S;\\n    }\\n    else {\\n        my $sum = $a + $b + $c;\\n        $x = $S * ($a \/ $sum);\\n        $y = $S * ($b \/ $sum);\\n        $z = $S * ($c \/ $sum);\\n    }\\n\\n    return \\\"$x $y $z\\\";\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($S, $a, $b, $c) = split \/\\\\s+\/, $input;\\n\\n# Find maximum point\\nmy $result = find_maximum_point($S, $a, $b, $c);\\n\\n# Print result\\nprint \\\"$result\\\\n\\\";\\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let s: i32 = lines[0].parse().unwrap();\n    let abc: Vec<i32> = lines[1].split(' ').map(|x| x.parse().unwrap()).collect();\n    \n    let mut x = 0.0;\n    let mut y = 0.0;\n    let mut z = 0.0;\n    \n    if abc[0] != 0 {\n        x = s as f64;\n    } else if abc[1] != 0 {\n        y = s as f64;\n    } else if abc[2] != 0 {\n        z = s as f64;\n    }\n    \n    println!(\"{:.6} {:.6} {:.6}\", x, y, z);\n}"}
{"title":"C. Clever Fat Rat","description":"The Fat Rat and his friend \u0421erealguy have had a bet whether at least a few oats are going to descend to them by some clever construction. The figure below shows the clever construction. A more formal description of the clever construction is as follows. The clever construction consists of n rows with scales. The first row has n scales, the second row has (n-1) scales, the i-th row has (n-i+1) scales, the last row has exactly one scale. Let's number the scales in each row from the left to the right, starting from 1. Then the value of wi,k in kilograms (1\u2264i\u2264n;\u00a01\u2264k\u2264n-i+1) is the weight capacity parameter of the k-th scale in the i-th row. If a body whose mass is not less than wi,k falls on the scale with weight capacity wi,k, then the scale breaks. At that anything that the scale has on it, either falls one level down to the left (if possible) or one level down to the right (if possible). In other words, if the scale wi,k (i<n) breaks, then there are at most two possible variants in which the contents of the scale's pan can fall out: all contents of scale wi,k falls either on scale wi+1,k-1 (if it exists), or on scale wi+1,k (if it exists). If scale wn,1 breaks, then all its contents falls right in the Fat Rat's claws. Please note that the scales that are the first and the last in a row, have only one variant of dropping the contents.Initially, oats are simultaneously put on all scales of the first level. The i-th scale has ai kilograms of oats put on it. After that the scales start breaking and the oats start falling down in some way. You can consider everything to happen instantly. That is, the scale breaks instantly and the oats also fall instantly.The Fat Rat is sure that whatever happens, he will not get the oats from the first level. Cerealguy is sure that there is such a scenario, when the rat gets at least some number of the oats. Help the Fat Rat and the Cerealguy. Determine, which one is right.","input_from":"standard input","output_to":"standard output","time_limit":"2.5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer n (1\u2264n\u226450) \u2014 the number of rows with scales.\nThe next line contains n space-separated integers ai (1\u2264ai\u226410^6) \u2014 the masses of the oats in kilograms.\nThe next n lines contain descriptions of the scales: the i-th line contains (n-i+1) space-separated integers wi,k (1\u2264wi,k\u226410^6) \u2014 the weight capacity parameters for the scales that stand on the i-th row, in kilograms.\n","output_spec":"Print \"Fat Rat\" if the Fat Rat is right, otherwise print \"Cerealguy\".\n","notes":"Notes to the examples: \n  The first example: the scale with weight capacity 2 gets 1. That means that the lower scale don't break.  The second sample: all scales in the top row obviously break. Then the oats fall on the lower row. Their total mass is 4,and that's exactly the weight that the lower scale can \"nearly endure\". So, as 4 \u2265 4, the scale breaks.","sample_inputs":["1\n1\n2\n","2\n2 2\n1 2\n4\n","2\n2 2\n1 2\n5\n"],"sample_outputs":["Fat Rat\n","Cerealguy\n","Fat Rat\n"],"id":"185-C","difficulty":2500,"tags":["dp"],"src_uid":"0a77937c01ac69490f8b478eae77de1d","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n    vector<vector<int>> w(n, vector<int>(n));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n - i; j++) {\\n            cin >> w[i][j];\\n        }\\n    }\\n    vector<vector<int>> dp(n, vector<int>(n));\\n    for (int i = 0; i < n; i++) {\\n        dp[n - 1][i] = a[i];\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n        for (int j = 0; j < n - i; j++) {\\n            dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + a[j + i];\\n        }\\n    }\\n    if (dp[0][0] >= w[0][0]) {\\n        cout << \\\"Cerealguy\\\" << endl;\\n    } else {\\n        cout << \\\"Fat Rat\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] a = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            a[i] = scanner.nextInt();\\n        }\\n        int[][] w = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - i; j++) {\\n                w[i][j] = scanner.nextInt();\\n            }\\n        }\\n        boolean[][] dp = new boolean[n][n];\\n        for (int i = 0; i < n; i++) {\\n            dp[n - 1][i] = true;\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j < n - i; j++) {\\n                if (dp[i + 1][j] && dp[i + 1][j + 1] && a[i] <= w[i][j]) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        if (dp[0][0]) {\\n            System.out.println(\\\"Cerealguy\\\");\\n        } else {\\n            System.out.println(\\\"Fat Rat\\\");\\n        }\\n    }\\n}","Python":"def clever_construction(n, a, weights):\n    for i in range(n-1):\n        for j in range(len(weights[i])-1):\n            if a[i] > weights[i][j]:\n                a[i+1] += a[i] - weights[i][j]\n                a[i] = weights[i][j]\n    \n    if a[n-1] > weights[n-1][0]:\n        return 'Cerealguy'\n    else:\n        return 'Fat Rat'\n\n# Sample Inputs\ninputs = ['1\\n1\\n2\\n', '2\\n2 2\\n1 2\\n4\\n', '2\\n2 2\\n1 2\\n5\\n']\noutputs = ['Fat Rat\\n', 'Cerealguy\\n', 'Fat Rat\\n']\n\n# Convert inputs to appropriate format\ninputs = [x.strip().split('\\n') for x in inputs]\ninputs = [[int(x[0])] + [list(map(int, x[1].split()))] + [list(map(int, y.split())) for y in x[2:]] for x in inputs]\n\n# Check if the function is working correctly\nfor i, input_data in enumerate(inputs):\n    assert clever_construction(*input_data) == outputs[i]\n\n# Print the source code\nprint([{\"version\": \"Python 3\", \"source code\": clever_construction}])","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    int w[n][n];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n - i; j++) {\\n            scanf(\\\"%d\\\", &w[i][j]);\\n        }\\n    }\\n    int dp[n][n];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n - i; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n    for (int i = n - 1; i >= 0; i--) {\\n        for (int j = 0; j < n - i; j++) {\\n            if (i == n - 1) {\\n                dp[i][j] = a[j];\\n            } else {\\n                dp[i][j] = dp[i + 1][j] + dp[i + 1][j + 1];\\n            }\\n            if (dp[i][j] > w[i][j]) {\\n                dp[i][j] = w[i][j];\\n            }\\n        }\\n    }\\n    if (dp[0][0] == a[0]) {\\n        printf(\\\"Fat Rat\\\\n\\\");\\n    } else {\\n        printf(\\\"Cerealguy\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] a = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n        int[][] w = new int[n][];\n        \n        for (int i = 0; i < n; i++)\n        {\n            w[i] = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n        }\n        \n        bool[,] dp = new bool[n, n];\n        \n        for (int i = 0; i < n; i++)\n        {\n            dp[n - 1, i] = true;\n        }\n        \n        for (int i = n - 2; i >= 0; i--)\n        {\n            for (int j = 0; j <= i; j++)\n            {\n                if (dp[i + 1, j] && dp[i + 1, j + 1] && a[j] <= w[i][j])\n                {\n                    dp[i, j] = true;\n                }\n            }\n        }\n        \n        if (dp[0, 0])\n        {\n            Console.WriteLine(\\\"Cerealguy\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"Fat Rat\\\");\n        }\n    }\n}","Ruby":"\ndef clever_construction(n, a, w)\n  # Initialize an array to store the total mass of oats on each scale\n  oats = Array.new(n) { Array.new(n) { 0 } }\n  \n  # Put the initial oats on the first level scales\n  oats[0] = a\n  \n  # Iterate through each row of scales\n  (0...n-1).each do |i|\n    # Iterate through each scale in the current row\n    (0...n-i).each do |k|\n      # Check if the scale can hold the oats\n      if oats[i][k] <= w[i][k]\n        # If the scale can hold the oats, add them to the next level scales\n        oats[i+1][k] += oats[i][k]\n        oats[i+1][k+1] += oats[i][k]\n      end\n    end\n  end\n  \n  # Check if the last scale in the last row can hold the oats\n  if oats[n-1][0] >= w[n-1][0]\n    return 'Cerealguy'\n  else\n    return 'Fat Rat'\n  end\nend\n\n# Read the input\nn = gets.to_i\na = gets.split.map(&:to_i)\nw = Array.new(n) { gets.split.map(&:to_i) }\n\n# Call the function and print the result\nputs clever_construction(n, a, w)\n","delphi":"program FatRatAndCerealguy;\\n\\nvar\\n  n, i, j, k: integer;\\n  a: array[1..50] of integer;\\n  w: array[1..50, 1..50] of integer;\\n  dp: array[1..50, 1..50] of boolean;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(a[i]);\\n  readln;\\n  for i := 1 to n do\\n    for j := 1 to n-i+1 do\\n      read(w[i, j]);\\n\\n  for i := 1 to n do\\n    dp[n, i] := true;\\n\\n  for i := n-1 downto 1 do\\n    for j := 1 to n-i+1 do\\n    begin\\n      dp[i, j] := false;\\n      if dp[i+1, j] and (a[i] >= w[i+1, j]) then\\n        dp[i, j] := true;\\n      if dp[i+1, j+1] and (a[i] >= w[i+1, j+1]) then\\n        dp[i, j] := true;\\n    end;\\n\\n  if dp[1, 1] then\\n    writeln('Cerealguy')\\n  else\\n    writeln('Fat Rat');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar oats []int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar oat int\\n\\t\\tfmt.Scan(&oat)\\n\\t\\toats = append(oats, oat)\\n\\t}\\n\\n\\tvar scales [][]int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar row []int\\n\\t\\tfor j := 0; j < n-i+1; j++ {\\n\\t\\t\\tvar scale int\\n\\t\\t\\tfmt.Scan(&scale)\\n\\t\\t\\trow = append(row, scale)\\n\\t\\t}\\n\\t\\tscales = append(scales, row)\\n\\t}\\n\\n\\tvar dp [][]int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tdp = append(dp, make([]int, n-i+1))\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < n-i+1; j++ {\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\tdp[i][j] = oats[j-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + oats[j-1]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif dp[i][j] > scales[i][j] {\\n\\t\\t\\t\\tfmt.Println(\\\"Cerealguy\\\")\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(\\\"Fat Rat\\\")\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}","Javascript":"function cleverConstruction(n, a, weights) {\n    let oats = a.reduce((sum, val) => sum + val, 0);\n    let maxWeight = 0;\n    \n    for (let i = 0; i < n; i++) {\n        let row = weights[i];\n        let rowMax = Math.max(...row);\n        maxWeight = Math.max(maxWeight, rowMax);\n    }\n    \n    if (oats <= maxWeight) {\n        return 'Fat Rat';\n    } else {\n        return 'Cerealguy';\n    }\n}\n\nlet input = '2\\\\n2 2\\\\n1 2\\\\n';\nlet lines = input.split('\\\\n');\nlet n = parseInt(lines[0]);\nlet a = lines[1].split(' ').map(Number);\nlet weights = [];\nfor (let i = 2; i < lines.length - 1; i++) {\n    weights.push(lines[i].split(' ').map(Number));\n}\n\nlet result = cleverConstruction(n, a, weights);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val a = IntArray(n)\n    for (i in 0 until n) {\n        a[i] = scanner.nextInt()\n    }\n    val w = Array(n) { IntArray(n) }\n    for (i in 0 until n) {\n        for (j in 0 until n - i + 1) {\n            w[i][j] = scanner.nextInt()\n        }\n    }\n    val dp = Array(n) { LongArray(n) }\n    for (i in 0 until n) {\n        dp[n - 1][i] = a[i].toLong()\n    }\n    for (i in n - 2 downTo 0) {\n        for (j in 0 until n - i) {\n            dp[i][j] = Math.max(dp[i + 1][j], dp[i + 1][j + 1]) + a[j + i]\n        }\n    }\n    println(if (dp[0][0] >= w[0][0]) \"Cerealguy\" else \"Fat Rat\")\n}","PHP":"\n<?php\n\nfunction cleverConstruction($n, $a, $weights) {\n    $oats = $a;\n    $rows = count($weights);\n    \n    for ($i = 0; $i < $rows; $i++) {\n        $row = $weights[$i];\n        $nextRow = $weights[$i+1] ?? [];\n        \n        for ($j = 0; $j < count($row); $j++) {\n            $weight = $row[$j];\n            \n            if ($i < $rows - 1) {\n                $leftWeight = $nextRow[$j] ?? 0;\n                $rightWeight = $nextRow[$j+1] ?? 0;\n                \n                $oats[$j] += $weight;\n                \n                if ($oats[$j] >= $leftWeight && $oats[$j] >= $rightWeight) {\n                    return 'Cerealguy';\n                }\n            } else {\n                if ($oats[$j] >= $weight) {\n                    return 'Cerealguy';\n                }\n            }\n        }\n    }\n    \n    return 'Fat Rat';\n}\n\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\n$n = intval($input[0]);\n$a = array_map('intval', explode(' ', $input[1]));\n$weights = [];\n\nfor ($i = 0; $i < $n; $i++) {\n    $weights[] = array_map('intval', explode(' ', $input[$i+2]));\n}\n\n$result = cleverConstruction($n, $a, $weights);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] a;\\r\\n    int[][] w;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    a = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n    w = new int[][](n);\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        w[i] = new int[n - i + 1];\\r\\n        foreach (j; 0..n - i + 1)\\r\\n        {\\r\\n            readf(\\\"%d\\\", &w[i][j]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Check if Fat Rat can get oats\\r\\n    bool fatRatCanGetOats = false;\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        bool[] canBreak = new bool[n - i];\\r\\n        foreach (int j; 0..n - i)\\r\\n        {\\r\\n            if (a[j] >= w[i][j])\\r\\n            {\\r\\n                canBreak[j] = true;\\r\\n                if (j > 0 && canBreak[j - 1])\\r\\n                {\\r\\n                    fatRatCanGetOats = true;\\r\\n                    break;\\r\\n                }\\r\\n                if (j < n - i - 1 && canBreak[j + 1])\\r\\n                {\\r\\n                    fatRatCanGetOats = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (fatRatCanGetOats)\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print result\\r\\n    if (fatRatCanGetOats)\\r\\n    {\\r\\n        writeln(\\\"Fat Rat\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"Cerealguy\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub check_oats {\n    my ($n, $oats, $scales) = @_;\n\n    # Initialize the first level with oats\n    my @levels = ([$oats]);\n\n    # Iterate through each row\n    for my $i (1..$n) {\n        my @row = split(' ', $scales->[$i-1]);\n\n        # Initialize the current level with empty scales\n        my @level = (0) x ($n - $i + 1);\n\n        # Iterate through each scale in the current row\n        for my $k (1..$n-$i+1) {\n            my $weight = $row[$k-1];\n\n            # Check if the scale can hold the oats\n            if ($level[$k-1] + $weight >= $level[$k]) {\n                $level[$k-1] += $weight;\n            } else {\n                $level[$k] += $level[$k-1];\n            }\n        }\n\n        push @levels, \\@level;\n    }\n\n    # Check if the last level can hold the oats\n    if ($levels[$n][0] >= $oats) {\n        return 'Fat Rat';\n    } else {\n        return 'Cerealguy';\n    }\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\n\nmy $oats = <>;\nchomp $oats;\n\nmy @scales;\nfor (1..$n) {\n    my $row = <>;\n    chomp $row;\n    push @scales, $row;\n}\n\n# Check the result\nmy $result = check_oats($n, $oats, \\@scales);\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"2\\\\n2 2\\\\n1 2\\\\n5\\\\n\\\";\\n    let mut lines = input.lines();\\n    let n: usize = lines.next().unwrap().parse().unwrap();\\n    let oats: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n    let mut scales: Vec<Vec<usize>> = Vec::new();\\n    for _ in 0..n {\\n        let row: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n        scales.push(row);\\n    }\\n\\n    let mut total_mass = oats.iter().sum::<usize>();\\n    let mut current_row = 0;\\n    let mut current_scale = 0;\\n\\n    while current_row < n - 1 {\\n        if total_mass >= scales[current_row][current_scale] {\\n            total_mass -= scales[current_row][current_scale];\\n            current_scale = current_scale.min(current_scale + 1);\\n        } else {\\n            current_scale = current_scale.max(current_scale - 1);\\n        }\\n        current_row += 1;\\n    }\\n\\n    if total_mass >= scales[n - 1][0] {\\n        println!(\\\"Cerealguy\\\");\\n    } else {\\n        println!(\\\"Fat Rat\\\");\\n    }\\n}"}
{"title":"A. Cut Ribbon","description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2264n,a,b,c\u22644000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.\n","output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.\n","notes":"In the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.\nIn the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.\n","sample_inputs":["5 5 3 2\n","7 5 5 2\n"],"sample_outputs":["2\n","2\n"],"id":"189-A","difficulty":1300,"tags":["brute+force","dp"],"src_uid":"062a171cc3ea717ea95ede9d7a1c3a43","C++":"#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\nint main() {\\n    int n, a, b, c;\\n    cin >> n >> a >> b >> c;\\n    int dp[n+1];\\n    dp[0] = 0;\\n    for(int i=1; i<=n; i++) {\\n        dp[i] = -1;\\n        if(i-a >= 0 && dp[i-a] != -1)\\n            dp[i] = max(dp[i], dp[i-a]+1);\\n        if(i-b >= 0 && dp[i-b] != -1)\\n            dp[i] = max(dp[i], dp[i-b]+1);\\n        if(i-c >= 0 && dp[i-c] != -1)\\n            dp[i] = max(dp[i], dp[i-c]+1);\\n    }\\n    cout << dp[n] << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class RibbonCutting {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        int n = Integer.parseInt(input[0]);\\n        int a = Integer.parseInt(input[1]);\\n        int b = Integer.parseInt(input[2]);\\n        int c = Integer.parseInt(input[3]);\\n\\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = Integer.MIN_VALUE;\\n            if (i - a >= 0) {\\n                dp[i] = Math.max(dp[i], dp[i - a] + 1);\\n            }\\n            if (i - b >= 0) {\\n                dp[i] = Math.max(dp[i], dp[i - b] + 1);\\n            }\\n            if (i - c >= 0) {\\n                dp[i] = Math.max(dp[i], dp[i - c] + 1);\\n            }\\n        }\\n\\n        System.out.println(dp[n]);\\n    }\\n}\"}\n","Python":"def max_ribbon_pieces(n, a, b, c):\\n    dp = [0] * (n + 1)\\n    for i in range(1, n + 1):\\n        if i >= a:\\n            dp[i] = max(dp[i], dp[i - a] + 1)\\n        if i >= b:\\n            dp[i] = max(dp[i], dp[i - b] + 1)\\n        if i >= c:\\n            dp[i] = max(dp[i], dp[i - c] + 1)\\n    return dp[n]\\n\\ninput_data = input().split()\\nn = int(input_data[0])\\na = int(input_data[1])\\nb = int(input_data[2])\\nc = int(input_data[3])\\n\\nresult = max_ribbon_pieces(n, a, b, c)\\nprint(result)","C":"#include <stdio.h>\\n\\nint max(int a, int b, int c) {\\n    if (a >= b && a >= c) {\\n        return a;\\n    } else if (b >= a && b >= c) {\\n        return b;\\n    } else {\\n        return c;\\n    }\\n}\\n\\nint main() {\\n    int n, a, b, c;\\n    scanf(\\\"%d %d %d %d\\\", &n, &a, &b, &c);\\n\\n    int dp[n+1];\\n    dp[0] = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = -1;\\n        if (i >= a && dp[i-a] != -1) {\\n            dp[i] = max(dp[i], dp[i-a] + 1);\\n        }\\n        if (i >= b && dp[i-b] != -1) {\\n            dp[i] = max(dp[i], dp[i-b] + 1);\\n        }\\n        if (i >= c && dp[i-c] != -1) {\\n            dp[i] = max(dp[i], dp[i-c] + 1);\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", dp[n]);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        int n = int.Parse(input[0]);\n        int a = int.Parse(input[1]);\n        int b = int.Parse(input[2]);\n        int c = int.Parse(input[3]);\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n\n        for (int i = 1; i <= n; i++)\n        {\n            dp[i] = -1;\n\n            if (i - a >= 0 && dp[i - a] != -1)\n                dp[i] = Math.Max(dp[i], dp[i - a] + 1);\n\n            if (i - b >= 0 && dp[i - b] != -1)\n                dp[i] = Math.Max(dp[i], dp[i - b] + 1);\n\n            if (i - c >= 0 && dp[i - c] != -1)\n                dp[i] = Math.Max(dp[i], dp[i - c] + 1);\n        }\n\n        Console.WriteLine(dp[n]);\n    }\n}","Ruby":"def max_ribbon_pieces(input)\n  n, a, b, c = input.split(' ').map(&:to_i)\n  dp = Array.new(n+1, -1)\n  dp[0] = 0\n\n  (1..n).each do |i|\n    if i >= a && dp[i-a] != -1\n      dp[i] = [dp[i], dp[i-a]+1].max\n    end\n    if i >= b && dp[i-b] != -1\n      dp[i] = [dp[i], dp[i-b]+1].max\n    end\n    if i >= c && dp[i-c] != -1\n      dp[i] = [dp[i], dp[i-c]+1].max\n    end\n  end\n\n  dp[n]\nend\n\ninputs = ['5 5 3 2\\n', '7 5 5 2\\n']\noutputs = []\n\ninputs.each do |input|\n  outputs << max_ribbon_pieces(input)\nend\n\noutputs.to_s","delphi":"program RibbonCutting;\\n\\nvar\\n  n, a, b, c, maxPieces: Integer;\\n\\nbegin\\n  ReadLn(n, a, b, c);\\n  maxPieces := 0;\\n\\n  for var i := 0 to n div a do\\n  begin\\n    for var j := 0 to (n - i * a) div b do\\n    begin\\n      var k := (n - i * a - j * b) div c;\\n      if (i * a + j * b + k * c = n) and (i + j + k > maxPieces) then\\n        maxPieces := i + j + k;\\n    end;\\n  end;\\n\\n  WriteLn(maxPieces);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, a, b, c int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &n, &a, &b, &c)\\n\\n\\tsides := []int{a, b, c}\\n\\tsort.Ints(sides)\\n\\n\\tdp := make([]int, n+1)\\n\\tdp[0] = 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tdp[i] = -1\\n\\t\\tfor _, side := range sides {\\n\\t\\t\\tif i-side >= 0 && dp[i-side] != -1 {\\n\\t\\t\\t\\tdp[i] = max(dp[i], dp[i-side]+1)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(dp[n])\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}","Javascript":"function maxRibbonPieces(input) {\n  const [n, a, b, c] = input.split(' ').map(Number);\n  const dp = new Array(n + 1).fill(-Infinity);\n  dp[0] = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (i >= a) dp[i] = Math.max(dp[i], dp[i - a] + 1);\n    if (i >= b) dp[i] = Math.max(dp[i], dp[i - b] + 1);\n    if (i >= c) dp[i] = Math.max(dp[i], dp[i - c] + 1);\n  }\n\n  return dp[n].toString();\n}\n\nconst inputs = ['5 5 3 2\\n', '7 5 5 2\\n'];\nconst outputs = inputs.map(maxRibbonPieces);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.Scanner\\n\\nfun main(args: Array<String>) {\\n    val scanner = Scanner(System.`in`)\\n    val n = scanner.nextInt()\\n    val a = scanner.nextInt()\\n    val b = scanner.nextInt()\\n    val c = scanner.nextInt()\\n\\n    val dp = IntArray(n + 1)\\n    dp[0] = 0\\n\\n    for (i in 1..n) {\\n        dp[i] = -1\\n        if (i - a >= 0 && dp[i - a] != -1) {\\n            dp[i] = maxOf(dp[i], dp[i - a] + 1)\\n        }\\n        if (i - b >= 0 && dp[i - b] != -1) {\\n            dp[i] = maxOf(dp[i], dp[i - b] + 1)\\n        }\\n        if (i - c >= 0 && dp[i - c] != -1) {\\n            dp[i] = maxOf(dp[i], dp[i - c] + 1)\\n        }\\n    }\\n\\n    println(dp[n])\\n}","PHP":"<?php\\n\\nfunction maxRibbonPieces($n, $a, $b, $c) {\\n    $dp = array_fill(0, $n + 1, -1);\\n    $dp[0] = 0;\\n    for ($i = 1; $i <= $n; $i++) {\\n        if ($i - $a >= 0 && $dp[$i - $a] != -1) {\\n            $dp[$i] = max($dp[$i], $dp[$i - $a] + 1);\\n        }\\n        if ($i - $b >= 0 && $dp[$i - $b] != -1) {\\n            $dp[$i] = max($dp[$i], $dp[$i - $b] + 1);\\n        }\\n        if ($i - $c >= 0 && $dp[$i - $c] != -1) {\\n            $dp[$i] = max($dp[$i], $dp[$i - $c] + 1);\\n        }\\n    }\\n    return $dp[$n];\\n}\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$a = intval($input[1]);\\n$b = intval($input[2]);\\n$c = intval($input[3]);\\n\\n$result = maxRibbonPieces($n, $a, $b, $c);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, a, b, c;\\r\\n    readf(\\\"%d %d %d %d\\\", &n, &a, &b, &c);\\r\\n\\r\\n    int maxPieces = 0;\\r\\n    for (int i = 0; i <= n\/a; i++)\\r\\n    {\\r\\n        for (int j = 0; j <= (n - i*a)\/b; j++)\\r\\n        {\\r\\n            int k = (n - i*a - j*b) \/ c;\\r\\n            if (i*a + j*b + k*c == n)\\r\\n            {\\r\\n                maxPieces = max(maxPieces, i + j + k);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxPieces);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub max_ribbon_pieces {\n    my ($n, $a, $b, $c) = @_;\n\n    my $max_pieces = 0;\n\n    for my $i (0..$n\/$a) {\n        for my $j (0..($n-$i*$a)\/$b) {\n            my $k = ($n - $i*$a - $j*$b) \/ $c;\n            if ($i*$a + $j*$b + $k*$c == $n) {\n                $max_pieces = max($max_pieces, $i + $j + $k);\n            }\n        }\n    }\n\n    return $max_pieces;\n}\n\nsub max {\n    my ($a, $b) = @_;\n    return $a > $b ? $a : $b;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $a, $b, $c) = split ' ', $input;\n\n# Calculate and print the maximum number of ribbon pieces\nmy $max_pieces = max_ribbon_pieces($n, $a, $b, $c);\nprint $max_pieces;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut input = input.trim().split_whitespace();\n    let n: usize = input.next().unwrap().parse().unwrap();\n    let a: usize = input.next().unwrap().parse().unwrap();\n    let b: usize = input.next().unwrap().parse().unwrap();\n    let c: usize = input.next().unwrap().parse().unwrap();\n\n    let mut dp = vec![0; n + 1];\n    for i in 1..=n {\n        if i >= a && dp[i - a] + 1 > dp[i] {\n            dp[i] = dp[i - a] + 1;\n        }\n        if i >= b && dp[i - b] + 1 > dp[i] {\n            dp[i] = dp[i - b] + 1;\n        }\n        if i >= c && dp[i - c] + 1 > dp[i] {\n            dp[i] = dp[i - c] + 1;\n        }\n    }\n\n    println!(\"{}\", dp[n]);\n}"}
{"title":"B. Walking in the Rain","description":"In Berland the opposition is going to arrange mass walking on the boulevard. The boulevard consists of n tiles that are lain in a row and are numbered from 1 to n from right to left. The opposition should start walking on the tile number 1 and the finish on the tile number n. During the walk it is allowed to move from right to left between adjacent tiles in a row, and jump over a tile. More formally, if you are standing on the tile number i (i<n-1), you can reach the tiles number i+1 or the tile number i+2 from it (if you stand on the tile number n-1, you can only reach tile number n). We can assume that all the opposition movements occur instantaneously.In order to thwart an opposition rally, the Berland bloody regime organized the rain. The tiles on the boulevard are of poor quality and they are rapidly destroyed in the rain. We know that the i-th tile is destroyed after ai days of rain (on day ai tile isn't destroyed yet, and on day ai+1 it is already destroyed). Of course, no one is allowed to walk on the destroyed tiles! So the walk of the opposition is considered thwarted, if either the tile number 1 is broken, or the tile number n is broken, or it is impossible to reach the tile number n from the tile number 1 if we can walk on undestroyed tiles.The opposition wants to gather more supporters for their walk. Therefore, the more time they have to pack, the better. Help the opposition to calculate how much time they still have and tell us for how many days the walk from the tile number 1 to the tile number n will be possible.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains integer n (1\u2264n\u226410^3) \u2014 the boulevard's length in tiles.\nThe second line contains n space-separated integers ai \u2014 the number of days after which the i-th tile gets destroyed (1\u2264ai\u226410^3). \n","output_spec":"Print a single number \u2014 the sought number of days.\n","notes":"In the first sample the second tile gets destroyed after day three, and the only path left is 1\u21923\u21924. After day five there is a two-tile gap between the first and the last tile, you can't jump over it.\nIn the second sample path 1\u21923\u21925 is available up to day five, inclusive. On day six the last tile is destroyed and the walk is thwarted.\n","sample_inputs":["4\n10 3 5 10\n","5\n10 2 8 3 5\n"],"sample_outputs":["5\n","5\n"],"id":"192-B","difficulty":1100,"tags":["brute+force","implementation"],"src_uid":"d526af933b5afe9abfdf9815e9664144","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> tiles(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> tiles[i];\\n    }\\n    int maxTime = 0;\\n    for (int i = 0; i < n; i++) {\\n        int time = min(tiles[i], min(tiles[i+1], tiles[i+2]));\\n        maxTime = max(maxTime, time);\\n    }\\n    cout << maxTime << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] tiles = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            tiles[i] = scanner.nextInt();\\n        }\\n        int maxTime = 0;\\n        for (int i = 0; i < n; i++) {\\n            int time = Math.min(tiles[i], Math.min(i == 0 ? Integer.MAX_VALUE : tiles[i - 1], i == n - 1 ? Integer.MAX_VALUE : tiles[i + 1]));\\n            maxTime = Math.max(maxTime, time);\\n        }\\n        System.out.println(maxTime);\\n    }\\n}","Python":"\ndef calculate_remaining_days(n, tiles):\n    remaining_days = min(tiles[0], tiles[n-1])\n    for i in range(1, n-1):\n        remaining_days = max(remaining_days, min(tiles[i], tiles[i+1]))\n    return remaining_days\n\ninput_data = input().split('\\n')\nn = int(input_data[0])\ntiles = list(map(int, input_data[1].split()))\n\nresult = calculate_remaining_days(n, tiles)\nprint(result)\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int maxDays = 0;\\n    for (int i = 0; i < n; i++) {\\n        int days = 0;\\n        if (i == 0) {\\n            days = a[i];\\n        } else if (i == n - 1) {\\n            days = a[i - 1];\\n        } else {\\n            days = a[i - 1] < a[i] ? a[i - 1] : a[i];\\n        }\\n        if (days > maxDays) {\\n            maxDays = days;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", maxDays);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace OppositionWalk\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] tiles = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            int maxDays = 0;\n            for (int i = 0; i < n; i++)\n            {\n                maxDays = Math.Max(maxDays, tiles[i]);\n            }\n\n            Console.WriteLine(maxDays);\n        }\n    }\n}\n","Ruby":"\ndef calculate_time(n, tiles)\n  max_time = 0\n  for i in 0..n-1\n    max_time = [max_time, tiles[i]].max\n  end\n  return max_time\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\ntiles = input[1].split(' ').map(&:to_i)\n\noutput = calculate_time(n, tiles)\nputs output\n","delphi":"program OppositionWalk;\\n\\nvar\\n  n, i, maxDays, days: integer;\\n  tiles: array of integer;\\n\\nbegin\\n  \/\/ Read the length of the boulevard\\n  readln(n);\\n\\n  \/\/ Read the number of days after which each tile gets destroyed\\n  SetLength(tiles, n);\\n  for i := 0 to n-1 do\\n    read(tiles[i]);\\n\\n  \/\/ Find the maximum number of days\\n  maxDays := 0;\\n  for i := 0 to n-1 do\\n  begin\\n    if tiles[i] > maxDays then\\n      maxDays := tiles[i];\\n  end;\\n\\n  \/\/ Calculate the number of days the walk will be possible\\n  days := maxDays;\\n  for i := 0 to n-1 do\\n  begin\\n    if (i < n-1) and (tiles[i] + tiles[i+1] > days) then\\n      days := tiles[i] + tiles[i+1];\\n  end;\\n\\n  \/\/ Print the result\\n  writeln(days);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar tiles string\\n\\tfmt.Scan(&tiles)\\n\\n\\ttileDays := strings.Split(tiles, \\\" \\\")\\n\\n\\tmaxDays := 0\\n\\n\\tfor _, days := range tileDays {\\n\\t\\tday := 0\\n\\t\\tfmt.Sscan(days, &day)\\n\\t\\tif day > maxDays {\\n\\t\\t\\tmaxDays = day\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxDays)\\n}","Javascript":"function calculateTime(n, tiles) {\n  let maxTime = 0;\n  for (let i = 0; i < n; i++) {\n    maxTime = Math.max(maxTime, tiles[i]);\n  }\n  return maxTime;\n}\n\nconst input = '4\\n10 3 5 10\\n';\nconst lines = input.split('\\\\n');\nconst n = parseInt(lines[0]);\nconst tiles = lines[1].split(' ').map(Number);\n\nconst result = calculateTime(n, tiles);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val tiles = IntArray(n)\n    for (i in 0 until n) {\n        tiles[i] = scanner.nextInt()\n    }\n    val maxTime = tiles.max()!!\n    val minTime = tiles.min()!!\n    val remainingTime = maxOf(maxTime - 1, n - minTime)\n    println(remainingTime)\n}","PHP":"\n<?php\n\nfunction calculateTime($n, $tiles) {\n    $maxTime = 0;\n    \n    for ($i = 0; $i < $n; $i++) {\n        $maxTime = max($maxTime, min($tiles[$i], $tiles[$i+1]));\n    }\n    \n    return $maxTime;\n}\n\n$input = explode('\\n', '4\\n10 3 5 10\\n');\n$n = intval($input[0]);\n$tiles = array_map('intval', explode(' ', $input[1]));\n\n$result = calculateTime($n, $tiles);\n\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] tiles;\\r\\n    tiles.length = n;\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &tiles[i]);\\r\\n    }\\r\\n\\r\\n    int maxTime = tiles[0];\\r\\n\\r\\n    foreach (i; 1..n)\\r\\n    {\\r\\n        maxTime = max(maxTime, tiles[i]);\\r\\n    }\\r\\n\\r\\n    writeln(maxTime);\\r\\n}","perl":"\n# Read input\nmy $n = <>;\nchomp $n;\nmy $tiles = <>;\nchomp $tiles;\nmy @a = split(' ', $tiles);\n\n# Initialize variables\nmy $max_days = 0;\nmy $current_days = 0;\n\n# Iterate through tiles\nfor (my $i = 0; $i < $n; $i++) {\n    # Check if current tile is destroyed\n    if ($a[$i] <= $current_days) {\n        # If current tile is destroyed, walk is thwarted\n        print $current_days . \\\"\\\\n\\\";\n        exit;\n    }\n    \n    # Update maximum number of days\n    $max_days = max($max_days, $a[$i]);\n    \n    # Increment current days\n    $current_days++;\n    \n    # Reset current days if maximum number of days is reached\n    if ($current_days == $max_days) {\n        $current_days = 0;\n    }\n}\n\n# Print maximum number of days\nprint $max_days . \\\"\\\\n\\\";\n\n# Function to find maximum of two numbers\nsub max {\n    my ($a, $b) = @_;\n    return $a > $b ? $a : $b;\n}\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let mut lines = input.lines();\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let tiles: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut max_days = 0;\n    for i in 0..n {\n        let days = std::cmp::min(tiles[i], tiles[n-1]);\n        max_days = std::cmp::max(max_days, days);\n    }\n    \n    println!(\"{}\", max_days);\n}"}
{"title":"D. Two Segments","description":"Nick has some permutation consisting of p integers from 1 to n. A segment [l,r] (l\u2264r) is a set of elements pi satisfying l\u2264i\u2264r.Nick calls a pair of segments [a0,a1] and [b0,b1] (1\u2264a0\u2264a1<b0\u2264b1\u2264n) good if all their (a1-a0+b1-b0+2) elements, when sorted in ascending order, form an arithmetic progression with a difference of 1. That is, when they sorted in ascending order, the elements are in the form {x,x+1,x+2,...,x+m-1}, for some x and m.Your task is to find the number of distinct pairs of good segments in the given permutation. Two pairs of segments are considered distinct if the sets of elements contained in these pairs of segments are distinct. For example, any segment [l,r] (l<r) can be represented as a pair of segments, as [l,i] and [i+1,r] (l\u2264i\u2264r). As all these pairs consist of the same set of elements, they are considered identical.See the notes accompanying the sample tests for clarification.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains integer n (1\u2264n\u22643\u00b710^5) \u2014 the permutation size. The second line contains n space-separated distinct integers pi, (1\u2264pi\u2264n).\n","output_spec":"Print a single integer \u2014 the number of good pairs of segments of permutation p.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier. \n","notes":"In the first sample the following pairs of segments are good: ([1,1], [2,2]); ([2,2], [3,3]); ([1,2], [3,3]). Pair of segments ([1,1], [2,3]) is by definition equivalent to pair ([1,2], [3,3]), since both of them covers the same set of elements, namely {1,2,3}.\nIn the third sample the following pairs of segments are good: ([4,4], [5,5]); ([3,3],[4,5]); ([2,2],[3,5]); ([1,1],[2,5]); ([3,3],[5,5]); ([2,3],[5,5]); ([1,3],[5,5]); ([2,2],[3,3]); ([1,1],[2,3]); ([1,1],[2,2]). \n","sample_inputs":["3\n1 2 3\n","5\n1 4 5 3 2\n","5\n5 4 3 1 2\n"],"sample_outputs":["3\n","10\n","10\n"],"id":"193-D","difficulty":2900,"tags":["data+structures"],"src_uid":"702ec7a08b8472fa843acb6f2107e583","C++":"#include <iostream>\\n#include <vector>\\n#include <map>\\n#include <algorithm>\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> p(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> p[i];\\n    }\\n\\n    long long ans = 0;\\n    map<int, int> cnt;\\n    vector<int> dp(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        dp[i] = cnt[p[i]];\\n        cnt[p[i]] = i + 1;\\n    }\\n\\n    cnt.clear();\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        ans += dp[i] * 1LL * (cnt[p[i]] - i - 1);\\n        cnt[p[i]] = i;\\n    }\\n\\n    cout << ans << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class GoodSegments {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] permutation = new int[n];\n        for (int i = 0; i < n; i++) {\n            permutation[i] = scanner.nextInt();\n        }\n        \n        long count = 0;\n        for (int a0 = 0; a0 < n; a0++) {\n            for (int a1 = a0; a1 < n; a1++) {\n                for (int b0 = a1 + 1; b0 < n; b0++) {\n                    for (int b1 = b0; b1 < n; b1++) {\n                        if (isGoodSegment(permutation, a0, a1, b0, b1)) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(count);\n    }\n    \n    private static boolean isGoodSegment(int[] permutation, int a0, int a1, int b0, int b1) {\n        Set<Integer> elements = new HashSet<>();\n        for (int i = a0; i <= a1; i++) {\n            elements.add(permutation[i]);\n        }\n        for (int i = b0; i <= b1; i++) {\n            elements.add(permutation[i]);\n        }\n        \n        if (elements.size() != (a1 - a0 + 1) + (b1 - b0 + 1)) {\n            return false;\n        }\n        \n        List<Integer> sortedElements = new ArrayList<>(elements);\n        Collections.sort(sortedElements);\n        \n        int difference = sortedElements.get(1) - sortedElements.get(0);\n        for (int i = 2; i < sortedElements.size(); i++) {\n            if (sortedElements.get(i) - sortedElements.get(i - 1) != difference) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}","Python":"n = int(input())\\npermutation = list(map(int, input().split()))\\n\\n# Initialize counters\\ncount = 0\\nsegment_count = [0] * (n+1)\\n\\n# Iterate through the permutation\\nfor i in range(n):\\n    # Reset segment counter\\n    segment_counter = [0] * (n+1)\\n    distinct_segments = 0\\n    \\n    # Iterate through the remaining elements\\n    for j in range(i, n):\\n        # Update segment counter\\n        segment_counter[permutation[j]] += 1\\n        \\n        # Check if the segment is distinct\\n        if segment_counter[permutation[j]] == 1:\\n            distinct_segments += 1\\n        \\n        # Check if the segments form an arithmetic progression\\n        if distinct_segments == j - i + 1:\\n            count += 1\\n            \\n        # Update segment count\\n        segment_count[permutation[j]] += 1\\n        \\n# Print the count\\nprint(count)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int p[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &p[i]);\\n    }\\n\\n    long long int count = 0;\\n\\n    for (int a0 = 0; a0 < n; a0++) {\\n        int min_a = p[a0];\\n        int max_a = p[a0];\\n\\n        for (int a1 = a0; a1 < n; a1++) {\\n            min_a = (p[a1] < min_a) ? p[a1] : min_a;\\n            max_a = (p[a1] > max_a) ? p[a1] : max_a;\\n\\n            int min_b = p[a1+1];\\n            int max_b = p[a1+1];\\n\\n            for (int b1 = a1+1; b1 < n; b1++) {\\n                min_b = (p[b1] < min_b) ? p[b1] : min_b;\\n                max_b = (p[b1] > max_b) ? p[b1] : max_b;\\n\\n                if (max_a - min_a == b1 - a0 && max_b - min_b == b1 - a0) {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace GoodSegments\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] permutation = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            long count = CountGoodSegments(permutation);\n            Console.WriteLine(count);\n        }\n\n        static long CountGoodSegments(int[] permutation)\n        {\n            int n = permutation.Length;\n            long count = 0;\n\n            \/\/ Calculate prefix sums\n            int[] prefixSums = new int[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                prefixSums[i] = prefixSums[i - 1] + permutation[i - 1];\n            }\n\n            \/\/ Calculate suffix sums\n            int[] suffixSums = new int[n + 1];\n            for (int i = n - 1; i >= 0; i--)\n            {\n                suffixSums[i] = suffixSums[i + 1] + permutation[i];\n            }\n\n            \/\/ Calculate the number of good segments\n            for (int i = 0; i < n; i++)\n            {\n                int leftSum = prefixSums[i];\n                int rightSum = suffixSums[i + 1];\n\n                int leftCount = 0;\n                int rightCount = 0;\n\n                for (int j = i + 1; j < n; j++)\n                {\n                    if (prefixSums[j] - leftSum == leftCount * (leftCount + 1) \/ 2 &&\n                        suffixSums[j + 1] - rightSum == rightCount * (rightCount + 1) \/ 2)\n                    {\n                        count++;\n                    }\n\n                    leftCount++;\n                    rightCount++;\n                }\n            }\n\n            return count;\n        }\n    }\n}\n","Ruby":"\ndef count_good_pairs(n, p)\n  # Initialize variables\n  count = 0\n  prefix = Array.new(n+1, 0)\n  suffix = Array.new(n+1, 0)\n  freq = Array.new(n+1, 0)\n\n  # Calculate prefix and suffix arrays\n  for i in 1..n\n    freq[p[i-1]] += 1\n    prefix[i] = prefix[i-1] + (freq[p[i-1]] == 1 ? 1 : 0)\n  end\n\n  freq = Array.new(n+1, 0)\n\n  for i in (n).downto(1)\n    freq[p[i-1]] += 1\n    suffix[i] = suffix[i+1] + (freq[p[i-1]] == 1 ? 1 : 0)\n  end\n\n  # Calculate the number of good pairs\n  for i in 1..n\n    count += prefix[i] * suffix[i+1]\n  end\n\n  return count\nend\n\n# Read input\ninput = gets.chomp.split(\"\\n\")\nn = input[0].to_i\np = input[1].split.map(&:to_i)\n\n# Call the function and print the result\nputs count_good_pairs(n, p)\n","delphi":"program GoodSegments;\\n\\nvar\\n  n, i, j, k, cnt: integer;\\n  p: array[1..300000] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(p[i]);\\n\\n  cnt := 0;\\n\\n  for i := 1 to n do\\n  begin\\n    j := i;\\n    while (j < n) and (p[j] + 1 = p[j + 1]) do\\n      Inc(j);\\n\\n    k := j;\\n    while (k < n) and (p[k] - 1 = p[k + 1]) do\\n      Inc(k);\\n\\n    cnt := cnt + (j - i + 1) * (k - j + 1);\\n\\n    i := k;\\n  end;\\n\\n  writeln(cnt);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tp := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&p[i])\\n\\t}\\n\\n\\tcount := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := i; j < n; j++ {\\n\\t\\t\\tsubArray := p[i : j+1]\\n\\t\\t\\tsortedArray := make([]int, len(subArray))\\n\\t\\t\\tcopy(sortedArray, subArray)\\n\\t\\t\\tsort.Ints(sortedArray)\\n\\n\\t\\t\\tif isArithmeticProgression(sortedArray) {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}\\n\\nfunc isArithmeticProgression(arr []int) bool {\\n\\tdiff := arr[1] - arr[0]\\n\\n\\tfor i := 2; i < len(arr); i++ {\\n\\t\\tif arr[i]-arr[i-1] != diff {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}","Javascript":"\nfunction countGoodPairs(n, arr) {\n    let count = 0;\n    \n    for (let i = 0; i < n; i++) {\n        let min = arr[i];\n        let max = arr[i];\n        \n        for (let j = i; j < n; j++) {\n            min = Math.min(min, arr[j]);\n            max = Math.max(max, arr[j]);\n            \n            let diff = max - min;\n            let len = j - i + 1;\n            \n            if (diff === len && len > 1) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n\n\/\/ Read input\nconst input = readline().split('\\n');\nconst n = parseInt(input[0]);\nconst arr = input[1].split(' ').map(Number);\n\n\/\/ Call the function and print the result\nconst result = countGoodPairs(n, arr);\nconsole.log(result);\n","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val p = IntArray(n)\n    for (i in 0 until n) {\n        p[i] = scanner.nextInt()\n    }\n    \n    val left = IntArray(n)\n    val right = IntArray(n)\n    val count = IntArray(n + 1)\n    val prefixSum = IntArray(n + 1)\n    \n    for (i in 0 until n) {\n        left[i] = count[p[i]]\n        count[p[i]] = i + 1\n        prefixSum[i + 1] = prefixSum[i] + left[i]\n    }\n    \n    val suffixSum = LongArray(n + 1)\n    for (i in n - 1 downTo 0) {\n        right[i] = count[p[i]]\n        count[p[i]] = n - i\n        suffixSum[i] = suffixSum[i + 1] + right[i]\n    }\n    \n    var result = 0L\n    for (i in 0 until n) {\n        result += prefixSum[right[i]] + suffixSum[left[i]]\n    }\n    \n    println(result)\n}","PHP":"\n<?php\n\nfunction countGoodPairs($n, $p) {\n    $prefix = array_fill(0, $n + 1, 0);\n    $suffix = array_fill(0, $n + 1, 0);\n    $cnt = array_fill(0, $n + 1, 0);\n    \n    for ($i = 1; $i <= $n; $i++) {\n        $prefix[$i] = $prefix[$i - 1] + ($p[$i - 1] == $i);\n    }\n    \n    for ($i = $n; $i >= 1; $i--) {\n        $suffix[$i] = $suffix[$i + 1] + ($p[$i - 1] == $i);\n    }\n    \n    $ans = 0;\n    \n    for ($i = 1; $i <= $n; $i++) {\n        $cnt[$p[$i - 1]]++;\n        $ans += $prefix[$i - 1] * $suffix[$i + 1];\n        $ans += $cnt[$i] * ($cnt[$i] - 1) \/ 2;\n    }\n    \n    return $ans;\n}\n\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\n$n = intval($input[0]);\n$p = array_map('intval', explode(\\\" \\\", $input[1]));\n\n$result = countGoodPairs($n, $p);\n\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] p = new int[n];\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &p[i]);\\r\\n    }\\r\\n\\r\\n    int[] prefix = new int[n];\\r\\n    int[] suffix = new int[n];\\r\\n\\r\\n    prefix[0] = 1;\\r\\n    for (int i = 1; i < n; i++)\\r\\n    {\\r\\n        if (p[i] > p[i - 1])\\r\\n        {\\r\\n            prefix[i] = prefix[i - 1] + 1;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            prefix[i] = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    suffix[n - 1] = 1;\\r\\n    for (int i = n - 2; i >= 0; i--)\\r\\n    {\\r\\n        if (p[i] < p[i + 1])\\r\\n        {\\r\\n            suffix[i] = suffix[i + 1] + 1;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            suffix[i] = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    long long count = 0;\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        count += prefix[i];\\r\\n    }\\r\\n\\r\\n    for (int i = 1; i < n - 1; i++)\\r\\n    {\\r\\n        if (p[i - 1] < p[i + 1])\\r\\n        {\\r\\n            count += min(prefix[i - 1], suffix[i + 1]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_good_segments {\n    my ($n, @p) = @_;\n\n    my @left = (0) x ($n + 1);\n    my @right = (0) x ($n + 1);\n    my @cnt = (0) x ($n + 1);\n\n    my $ans = 0;\n\n    for my $i (1..$n) {\n        $left[$i] = $left[$i - 1] + 1;\n        while ($left[$i] < $i && $p[$left[$i] - 1] < $p[$i - 1] - 1) {\n            $left[$i]++;\n        }\n    }\n\n    for my $i (reverse 1..$n) {\n        $right[$i] = $right[$i + 1] + 1;\n        while ($right[$i] < $n - $i + 1 && $p[$right[$i] + $i - 1] < $p[$i - 1] + $right[$i] + 1) {\n            $right[$i]++;\n        }\n    }\n\n    for my $i (1..$n) {\n        $cnt[$i] = $cnt[$i - 1] + $left[$i];\n    }\n\n    for my $i (1..$n) {\n        $ans += $cnt[$right[$i] + $i - 1] - $cnt[$i - 1];\n    }\n\n    return $ans;\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy @p = split ' ', <>;\nchomp @p;\n\n# Call the function and print the result\nmy $result = count_good_segments($n, @p);\nprint $result;\n","Rust":"use std::collections::HashMap;\n\nfn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: usize = input.trim().parse().unwrap();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let p: Vec<usize> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut prefix: HashMap<usize, usize> = HashMap::new();\n    let mut suffix: HashMap<usize, usize> = HashMap::new();\n    let mut count: HashMap<(usize, usize), usize> = HashMap::new();\n\n    let mut result = 0;\n\n    for i in 0..n {\n        let mut left = 0;\n        let mut right = 0;\n\n        if let Some(&val) = prefix.get(&(p[i] - 1)) {\n            left = val;\n        }\n\n        if let Some(&val) = suffix.get(&(p[i] + 1)) {\n            right = val;\n        }\n\n        let mut temp = 0;\n\n        if let Some(&val) = count.get(&(left, right)) {\n            temp = val;\n        }\n\n        result += temp;\n\n        if let Some(&val) = prefix.get(&p[i]) {\n            prefix.insert(p[i], val + 1);\n        } else {\n            prefix.insert(p[i], 1);\n        }\n\n        if let Some(&val) = suffix.get(&p[i]) {\n            suffix.insert(p[i], val + 1);\n        } else {\n            suffix.insert(p[i], 1);\n        }\n\n        if let Some(&val) = count.get(&(left, right)) {\n            count.insert((left, right), val + 1);\n        } else {\n            count.insert((left, right), 1);\n        }\n    }\n\n    println!(\"{}\", result);\n}"}
{"title":"E. Opening Portals","description":"Pavel plays a famous computer game. A player is responsible for a whole country and he can travel there freely, complete quests and earn experience.This country has n cities connected by m bidirectional roads of different lengths so that it is possible to get from any city to any other one. There are portals in k of these cities. At the beginning of the game all portals are closed. When a player visits a portal city, the portal opens. Strange as it is, one can teleport from an open portal to an open one. The teleportation takes no time and that enables the player to travel quickly between rather remote regions of the country.At the beginning of the game Pavel is in city number 1. He wants to open all portals as quickly as possible. How much time will he need for that?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers n and m (1\u2264n\u226410^5, 0\u2264m\u226410^5) that show how many cities and roads are in the game.\nEach of the next m lines contains the description of a road as three space-separated integers xi, yi, wi (1\u2264xi,yi\u2264n, xi\u2260yi, 1\u2264wi\u226410^9) \u2014 the numbers of the cities connected by the i-th road and the time needed to go from one city to the other one by this road. Any two cities are connected by no more than one road. It is guaranteed that we can get from any city to any other one, moving along the roads of the country.\nThe next line contains integer k (1\u2264k\u2264n) \u2014 the number of portals.\nThe next line contains k space-separated integers p1, p2, ..., pk \u2014 numbers of the cities with installed portals. Each city has no more than one portal.\n","output_spec":"Print a single number \u2014 the minimum time a player needs to open all portals.\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n","notes":"In the second sample the player has to come to city 2, open a portal there, then go to city 3, open a portal there, teleport back to city 2 and finally finish the journey in city 4.\n","sample_inputs":["3 3\n1 2 1\n1 3 1\n2 3 1\n3\n1 2 3\n","4 3\n1 2 1\n2 3 5\n2 4 10\n3\n2 3 4\n","4 3\n1 2 1000000000\n2 3 1000000000\n3 4 1000000000\n4\n1 2 3 4\n"],"sample_outputs":["2\n","16\n","3000000000\n"],"id":"196-E","difficulty":2600,"tags":["dsu","graphs","shortest+paths"],"src_uid":"48378fb3f0469a1fa7a3b1fe1977b6bc","C++":"#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvector<vector<pii>> adjList;\nvector<int> portals;\nvector<long long> dist;\n\nvoid dijkstra(int start) {\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    pq.push({0, start});\n    dist[start] = 0;\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int d = pq.top().first;\n        pq.pop();\n\n        if (d > dist[u]) {\n            continue;\n        }\n\n        for (pii edge : adjList[u]) {\n            int v = edge.first;\n            int w = edge.second;\n\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    adjList.resize(n + 1);\n    dist.resize(n + 1, LLONG_MAX);\n\n    for (int i = 0; i < m; i++) {\n        int x, y, w;\n        cin >> x >> y >> w;\n        adjList[x].push_back({y, w});\n        adjList[y].push_back({x, w});\n    }\n\n    int k;\n    cin >> k;\n\n    portals.resize(k);\n    for (int i = 0; i < k; i++) {\n        cin >> portals[i];\n    }\n\n    dijkstra(1);\n\n    long long minTime = LLONG_MAX;\n    for (int portal : portals) {\n        minTime = min(minTime, dist[portal]);\n    }\n\n    cout << minTime << endl;\n\n    return 0;\n}","Java":"import java.util.*;\n\npublic class PortalGame {\n    static class City {\n        int id;\n        boolean visited;\n        boolean hasPortal;\n        List<Road> roads;\n\n        public City(int id) {\n            this.id = id;\n            this.visited = false;\n            this.hasPortal = false;\n            this.roads = new ArrayList<>();\n        }\n    }\n\n    static class Road {\n        City city1;\n        City city2;\n        int time;\n\n        public Road(City city1, City city2, int time) {\n            this.city1 = city1;\n            this.city2 = city2;\n            this.time = time;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        List<City> cities = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            cities.add(new City(i + 1));\n        }\n\n        for (int i = 0; i < m; i++) {\n            int city1Id = scanner.nextInt();\n            int city2Id = scanner.nextInt();\n            int time = scanner.nextInt();\n\n            City city1 = cities.get(city1Id - 1);\n            City city2 = cities.get(city2Id - 1);\n\n            city1.roads.add(new Road(city1, city2, time));\n            city2.roads.add(new Road(city2, city1, time));\n        }\n\n        int k = scanner.nextInt();\n        for (int i = 0; i < k; i++) {\n            int portalCityId = scanner.nextInt();\n            cities.get(portalCityId - 1).hasPortal = true;\n        }\n\n        int minTime = findMinimumTime(cities);\n        System.out.println(minTime);\n    }\n\n    public static int findMinimumTime(List<City> cities) {\n        PriorityQueue<Road> pq = new PriorityQueue<>((r1, r2) -> r1.time - r2.time);\n\n        City startCity = cities.get(0);\n        startCity.visited = true;\n\n        for (Road road : startCity.roads) {\n            pq.offer(road);\n        }\n\n        int minTime = 0;\n        int numPortalsOpened = startCity.hasPortal ? 1 : 0;\n\n        while (!pq.isEmpty() && numPortalsOpened < cities.size()) {\n            Road road = pq.poll();\n            City nextCity = road.city2;\n\n            if (nextCity.visited) {\n                continue;\n            }\n\n            nextCity.visited = true;\n            minTime += road.time;\n\n            if (nextCity.hasPortal) {\n                numPortalsOpened++;\n            }\n\n            for (Road nextRoad : nextCity.roads) {\n                if (!nextRoad.city2.visited) {\n                    pq.offer(nextRoad);\n                }\n            }\n        }\n\n        return minTime;\n    }\n}","Python":"from heapq import heappop, heappush\\n\\n\\ndef dijkstra(graph, start):\\n    n = len(graph)\\n    dist = [float('inf')] * n\\n    dist[start] = 0\\n    visited = [False] * n\\n    heap = [(0, start)]\\n\\n    while heap:\\n        d, u = heappop(heap)\\n        if visited[u]:\\n            continue\\nn        visited[u] = True\\n\\n        for v, w in graph[u]:\\n            if dist[u] + w < dist[v]:\\n                dist[v] = dist[u] + w\\n                heappush(heap, (dist[v], v))\\n\\n    return dist\\n\\n\\nn, m = map(int, input().split())\\ngraph = [[] for _ in range(n)]\\n\\nfor _ in range(m):\\n    x, y, w = map(int, input().split())\\n    graph[x-1].append((y-1, w))\\n    graph[y-1].append((x-1, w))\\n\\nk = int(input())\\nportals = set(map(int, input().split()))\\n\\nportal_cities = []\\nfor i in range(n):\\n    if i+1 in portals:\\n        portal_cities.append(i)\\n\\n\\ndist_from_start = dijkstra(graph, 0)\\n\\nmin_time = float('inf')\\nfor portal_city in portal_cities:\\n    dist_from_portal = dijkstra(graph, portal_city)\\n    for i in range(n):\\n        if i+1 not in portals:\\n            min_time = min(min_time, dist_from_start[i] + dist_from_portal[i])\\n\\nprint(min_time)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <limits.h>\\n\\n\/\/ Structure to represent a road\\nstruct Road\\n{\\n    int city1;\\n    int city2;\\n    int time;\\n};\\n\\n\/\/ Function to find the minimum time to open all portals\\nint findMinTime(int n, int m, struct Road roads[], int k, int portals[])\\n{\\n    \/\/ Create a matrix to store the minimum time between cities\\n    int minTime[n][n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = 0; j < n; j++)\\n        {\\n            if (i == j)\\n                minTime[i][j] = 0;\\n            else\\n                minTime[i][j] = INT_MAX;\\n        }\\n    }\\n\\n    \/\/ Update the minimum time matrix with the given roads\\n    for (int i = 0; i < m; i++)\\n    {\\n        int city1 = roads[i].city1;\\n        int city2 = roads[i].city2;\\n        int time = roads[i].time;\\n        minTime[city1 - 1][city2 - 1] = time;\\n        minTime[city2 - 1][city1 - 1] = time;\\n    }\\n\\n    \/\/ Use Floyd-Warshall algorithm to find the minimum time between all pairs of cities\\n    for (int k = 0; k < n; k++)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (minTime[i][k] != INT_MAX && minTime[k][j] != INT_MAX && minTime[i][k] + minTime[k][j] < minTime[i][j])\\n                    minTime[i][j] = minTime[i][k] + minTime[k][j];\\n            }\\n        }\\n    }\\n\\n    \/\/ Calculate the minimum time to open all portals\\n    int minPortalTime = INT_MAX;\\n    for (int i = 0; i < k; i++)\\n    {\\n        for (int j = i + 1; j < k; j++)\\n        {\\n            int portal1 = portals[i] - 1;\\n            int portal2 = portals[j] - 1;\\n            if (minTime[portal1][portal2] < minPortalTime)\\n                minPortalTime = minTime[portal1][portal2];\\n        }\\n    }\\n\\n    return minPortalTime;\\n}\\n\\nint main()\\n{\\n    int n, m, k;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n\\n    struct Road roads[m];\\n    for (int i = 0; i < m; i++)\\n    {\\n        scanf(\\\"%d %d %d\\\", &roads[i].city1, &roads[i].city2, &roads[i].time);\\n    }\\n\\n    scanf(\\\"%d\\\", &k);\\n\\n    int portals[k];\\n    for (int i = 0; i < k; i++)\\n    {\\n        scanf(\\\"%d\\\", &portals[i]);\\n    }\\n\\n    int minTime = findMinTime(n, m, roads, k, portals);\\n    printf(\\\"%d\\\\n\\\", minTime);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace PortalGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            List<List<(int, int)>> graph = new List<List<(int, int)>>(n + 1);\n            for (int i = 0; i <= n; i++)\n            {\n                graph.Add(new List<(int, int)>());\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine().Split();\n                int x = int.Parse(input[0]);\n                int y = int.Parse(input[1]);\n                int w = int.Parse(input[2]);\n\n                graph[x].Add((y, w));\n                graph[y].Add((x, w));\n            }\n\n            int k = int.Parse(Console.ReadLine());\n            input = Console.ReadLine().Split();\n            HashSet<int> portals = new HashSet<int>();\n            for (int i = 0; i < k; i++)\n            {\n                portals.Add(int.Parse(input[i]));\n            }\n\n            int[] distances = new int[n + 1];\n            for (int i = 0; i <= n; i++)\n            {\n                distances[i] = int.MaxValue;\n            }\n\n            distances[1] = 0;\n            PriorityQueue<(int, int)> pq = new PriorityQueue<(int, int)>();\n            pq.Enqueue((1, 0));\n\n            while (pq.Count > 0)\n            {\n                (int node, int distance) = pq.Dequeue();\n\n                if (distance > distances[node])\n                {\n                    continue;\n                }\n\n                foreach ((int neighbor, int weight) in graph[node])\n                {\n                    int newDistance = distance + weight;\n\n                    if (newDistance < distances[neighbor])\n                    {\n                        distances[neighbor] = newDistance;\n                        pq.Enqueue((neighbor, newDistance));\n                    }\n                }\n            }\n\n            int minTime = int.MaxValue;\n            foreach (int portal in portals)\n            {\n                minTime = Math.Min(minTime, distances[portal]);\n            }\n\n            Console.WriteLine(minTime);\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable<T>\n    {\n        private List<T> heap;\n\n        public int Count { get { return heap.Count; } }\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public void Enqueue(T item)\n        {\n            heap.Add(item);\n            int i = heap.Count - 1;\n\n            while (i > 0)\n            {\n                int parent = (i - 1) \/ 2;\n\n                if (heap[parent].CompareTo(heap[i]) <= 0)\n                {\n                    break;\n                }\n\n                T temp = heap[parent];\n                heap[parent] = heap[i];\n                heap[i] = temp;\n\n                i = parent;\n            }\n        }\n\n        public T Dequeue()\n        {\n            T item = heap[0];\n            heap[0] = heap[heap.Count - 1];\n            heap.RemoveAt(heap.Count - 1);\n\n            int i = 0;\n            while (true)\n            {\n                int leftChild = 2 * i + 1;\n                int rightChild = 2 * i + 2;\n\n                if (leftChild >= heap.Count)\n                {\n                    break;\n                }\n\n                int minChild = leftChild;\n                if (rightChild < heap.Count && heap[rightChild].CompareTo(heap[leftChild]) < 0)\n                {\n                    minChild = rightChild;\n                }\n\n                if (heap[i].CompareTo(heap[minChild]) <= 0)\n                {\n                    break;\n                }\n\n                T temp = heap[i];\n                heap[i] = heap[minChild];\n                heap[minChild] = temp;\n\n                i = minChild;\n            }\n\n            return item;\n        }\n    }\n}","Ruby":"\n# Read input\nn, m = gets.chomp.split(' ').map(&:to_i)\nroads = []\nm.times do\n  xi, yi, wi = gets.chomp.split(' ').map(&:to_i)\n  roads << [xi, yi, wi]\nend\nk = gets.chomp.to_i\nportals = gets.chomp.split(' ').map(&:to_i)\n\n# Initialize variables\ndistances = Array.new(n+1, Float::INFINITY)\nvisited = Array.new(n+1, false)\ndistances[1] = 0\n\n# Dijkstra's algorithm\nwhile true\n  min_distance = Float::INFINITY\n  min_index = -1\n\n  # Find the city with the minimum distance\n  (1..n).each do |i|\n    if !visited[i] && distances[i] < min_distance\n      min_distance = distances[i]\n      min_index = i\n    end\n  end\n\n  # If all cities have been visited, break the loop\n  break if min_index == -1\n\n  # Mark the city as visited\n  visited[min_index] = true\n\n  # Update distances to neighboring cities\n  roads.each do |road|\n    xi, yi, wi = road\n    if xi == min_index && !visited[yi]\n      distances[yi] = [distances[yi], distances[xi] + wi].min\n    elsif yi == min_index && !visited[xi]\n      distances[xi] = [distances[xi], distances[yi] + wi].min\n    end\n  end\nend\n\n# Calculate the minimum time to open all portals\nmin_time = 0\nportals.each do |portal|\n  min_time = [min_time, distances[portal]].max\nend\n\n# Print the result\nputs min_time\n","delphi":"program PortalGame;\\n\\nvar\\n  n, m, k, i, j, x, y, w, minTime: integer;\\n  portals: array of integer;\\n  roads: array of array of integer;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n, m);\\n  SetLength(roads, m);\\n  for i := 0 to m-1 do\\n  begin\\n    readln(x, y, w);\\n    SetLength(roads[i], 3);\\n    roads[i][0] := x;\\n    roads[i][1] := y;\\n    roads[i][2] := w;\\n  end;\\n  readln(k);\\n  SetLength(portals, k);\\n  for i := 0 to k-1 do\\n    read(portals[i]);\\n\\n  \/\/ Find minimum time\\n  minTime := 0;\\n  for i := 0 to k-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      if (roads[j][0] = portals[i]) or (roads[j][1] = portals[i]) then\\n      begin\\n        if (roads[j][0] = portals[i]) and (roads[j][1] in portals) then\\n          minTime := minTime + roads[j][2]\\n        else if (roads[j][1] = portals[i]) and (roads[j][0] in portals) then\\n          minTime := minTime + roads[j][2];\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Print output\\n  writeln(minTime);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\troads := make([][]int, n+1)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tvar x, y, w int\\n\\t\\tfmt.Scanf(\\\"%d %d %d\\\", &x, &y, &w)\\n\\n\\t\\troads[x] = append(roads[x], y)\\n\\t\\troads[y] = append(roads[y], x)\\n\\t}\\n\\n\\tvar k int\\n\\tfmt.Scanf(\\\"%d\\\", &k)\\n\\n\\tportals := make([]int, k)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &portals[i])\\n\\t}\\n\\n\\tminTime := math.MaxInt64\\n\\n\\tfor _, portal := range portals {\\n\\t\\tvisited := make([]bool, n+1)\\n\\t\\tqueue := make([]int, 0)\\n\\t\\ttime := make([]int, n+1)\\n\\n\\t\\tqueue = append(queue, portal)\\n\\t\\tvisited[portal] = true\\n\\n\\t\\tfor len(queue) > 0 {\\n\\t\\t\\tcurrent := queue[0]\\n\\t\\t\\tqueue = queue[1:]\\n\\n\\t\\t\\tfor _, next := range roads[current] {\\n\\t\\t\\t\\tif !visited[next] {\\n\\t\\t\\t\\t\\tvisited[next] = true\\n\\t\\t\\t\\t\\tqueue = append(queue, next)\\n\\t\\t\\t\\t\\ttime[next] = time[current] + 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttotalTime := 0\\n\\t\\tfor _, t := range time {\\n\\t\\t\\ttotalTime += t\\n\\t\\t}\\n\\n\\t\\tif totalTime < minTime {\\n\\t\\t\\tminTime = totalTime\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minTime)\\n}","Javascript":"\nfunction minTimeToOpenPortals(n, m, roads, k, portals) {\n    \/\/ Create an adjacency list to represent the graph\n    let graph = new Array(n + 1).fill(null).map(() => []);\n    \n    \/\/ Populate the adjacency list with the roads\n    for (let i = 0; i < m; i++) {\n        let [x, y, w] = roads[i];\n        graph[x].push({ city: y, time: w });\n        graph[y].push({ city: x, time: w });\n    }\n    \n    \/\/ Create a set to keep track of visited cities\n    let visited = new Set();\n    \n    \/\/ Create a priority queue to store the cities and their minimum time to reach\n    let pq = new PriorityQueue((a, b) => a.time - b.time);\n    \n    \/\/ Add the starting city to the priority queue with time 0\n    pq.enqueue({ city: 1, time: 0 });\n    \n    \/\/ Initialize the minimum time array with Infinity for all cities\n    let minTime = new Array(n + 1).fill(Infinity);\n    \n    \/\/ Set the minimum time for the starting city to 0\n    minTime[1] = 0;\n    \n    \/\/ Dijkstra's algorithm to find the minimum time to reach each city\n    while (!pq.isEmpty()) {\n        let { city, time } = pq.dequeue();\n        \n        \/\/ Skip if the city has already been visited\n        if (visited.has(city)) continue;\n        \n        \/\/ Mark the city as visited\n        visited.add(city);\n        \n        \/\/ Update the minimum time for each neighboring city\n        for (let neighbor of graph[city]) {\n            let { city: nextCity, time: nextTime } = neighbor;\n            \n            \/\/ Update the minimum time if a shorter path is found\n            if (time + nextTime < minTime[nextCity]) {\n                minTime[nextCity] = time + nextTime;\n                pq.enqueue({ city: nextCity, time: minTime[nextCity] });\n            }\n        }\n    }\n    \n    \/\/ Calculate the total time to open all portals\n    let totalTime = 0;\n    for (let portal of portals) {\n        totalTime += minTime[portal];\n    }\n    \n    return totalTime;\n}\n\n\/\/ Sample inputs\nlet inputs = [\n    { n: 3, m: 3, roads: [[1, 2, 1], [1, 3, 1], [2, 3, 1]], k: 3, portals: [1, 2, 3] },\n    { n: 4, m: 3, roads: [[1, 2, 1], [2, 3, 5], [2, 4, 10]], k: 3, portals: [2, 3, 4] },\n    { n: 4, m: 3, roads: [[1, 2, 1000000000], [2, 3, 1000000000], [3, 4, 1000000000]], k: 4, portals: [1, 2, 3, 4] }\n];\n\n\/\/ Process each input and print the output\nfor (let input of inputs) {\n    let { n, m, roads, k, portals } = input;\n    let result = minTimeToOpenPortals(n, m, roads, k, portals);\n    console.log(result);\n}\n","Kotlin":"import java.util.*\n\ndata class City(val id: Int, val time: Long)\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n    \n    val cities = Array(n + 1) { City(it, Long.MAX_VALUE) }\n    val portals = mutableSetOf<Int>()\n    \n    for (i in 1..m) {\n        val x = scanner.nextInt()\n        val y = scanner.nextInt()\n        val w = scanner.nextLong()\n        \n        cities[x].neighbors.add(City(y, w))\n        cities[y].neighbors.add(City(x, w))\n    }\n    \n    val k = scanner.nextInt()\n    for (i in 1..k) {\n        portals.add(scanner.nextInt())\n    }\n    \n    val queue = PriorityQueue<City>(compareBy { it.time })\n    cities[1].time = 0\n    queue.add(cities[1])\n    \n    while (queue.isNotEmpty()) {\n        val currentCity = queue.poll()\n        \n        for (neighbor in currentCity.neighbors) {\n            val newTime = currentCity.time + neighbor.time\n            if (newTime < cities[neighbor.id].time) {\n                cities[neighbor.id].time = newTime\n                queue.add(cities[neighbor.id])\n            }\n        }\n    }\n    \n    var minTime = Long.MAX_VALUE\n    for (portal in portals) {\n        if (cities[portal].time < minTime) {\n            minTime = cities[portal].time\n        }\n    }\n    \n    println(minTime)\n}\n\n","PHP":"\n<?php\n\nfunction minTimeToOpenPortals($n, $m, $roads, $k, $portals) {\n    \/\/ Create an adjacency list to represent the graph\n    $graph = array_fill(1, $n, []);\n    foreach ($roads as $road) {\n        $x = $road[0];\n        $y = $road[1];\n        $w = $road[2];\n        $graph[$x][] = [$y, $w];\n        $graph[$y][] = [$x, $w];\n    }\n    \n    \/\/ Initialize distances array with infinity values\n    $distances = array_fill(1, $n, INF);\n    \n    \/\/ Initialize visited array\n    $visited = array_fill(1, $n, false);\n    \n    \/\/ Initialize priority queue\n    $pq = new SplPriorityQueue();\n    \n    \/\/ Add the starting city to the priority queue\n    $pq->insert([1, 0], 0);\n    \n    \/\/ Set the distance of the starting city to 0\n    $distances[1] = 0;\n    \n    \/\/ Dijkstra's algorithm\n    while (!$pq->isEmpty()) {\n        $current = $pq->extract();\n        $city = $current[0];\n        $distance = $current[1];\n        \n        \/\/ Skip if already visited\n        if ($visited[$city]) {\n            continue;\n        }\n        \n        \/\/ Mark the current city as visited\n        $visited[$city] = true;\n        \n        \/\/ Check if the current city has a portal\n        if (in_array($city, $portals)) {\n            \/\/ Update the distance to the portal city\n            $distances[$city] = $distance;\n        }\n        \n        \/\/ Explore the neighboring cities\n        foreach ($graph[$city] as $neighbor) {\n            $neighborCity = $neighbor[0];\n            $neighborDistance = $neighbor[1];\n            \n            \/\/ Calculate the new distance to the neighboring city\n            $newDistance = $distance + $neighborDistance;\n            \n            \/\/ Update the distance if it is shorter\n            if ($newDistance < $distances[$neighborCity]) {\n                $distances[$neighborCity] = $newDistance;\n                \n                \/\/ Add the neighboring city to the priority queue\n                $pq->insert([$neighborCity, $newDistance], -$newDistance);\n            }\n        }\n    }\n    \n    \/\/ Calculate the minimum time to open all portals\n    $minTime = 0;\n    foreach ($portals as $portal) {\n        $minTime += $distances[$portal];\n    }\n    \n    return $minTime;\n}\n\n\/\/ Read input\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents(\\\"php:\/\/stdin\\\")));\nlist($n, $m) = explode(\\\" \\\", $input[0]);\n$roads = [];\nfor ($i = 1; $i <= $m; $i++) {\n    $roads[] = array_map('intval', explode(\\\" \\\", $input[$i]));\n}\n$k = intval($input[$m + 1]);\n$portals = array_map('intval', explode(\\\" \\\", $input[$m + 2]));\n\n\/\/ Calculate and print the minimum time to open all portals\necho minTimeToOpenPortals($n, $m, $roads, $k, $portals);\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.functional;\\r\\nimport std.range;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Edge {\\r\\n    int v;\\r\\n    int w;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    auto graph = new Edge[][](n + 1);\\r\\n\\r\\n    foreach (i; 0 .. m) {\\r\\n        int x, y, w;\\r\\n        readf(\\\"%d %d %d\\\", &x, &y, &w);\\r\\n\\r\\n        graph[x] ~= Edge(y, w);\\r\\n        graph[y] ~= Edge(x, w);\\r\\n    }\\r\\n\\r\\n    int k;\\r\\n    readf(\\\"%d\\\", &k);\\r\\n\\r\\n    int[] portals;\\r\\n    foreach (i; 0 .. k) {\\r\\n        int p;\\r\\n        readf(\\\"%d\\\", &p);\\r\\n\\r\\n        portals ~= p;\\r\\n    }\\r\\n\\r\\n    int[] dist = new int[n + 1];\\r\\n    foreach (i; 0 .. n + 1) {\\r\\n        dist[i] = int.max;\\r\\n    }\\r\\n\\r\\n    dist[1] = 0;\\r\\n\\r\\n    auto pq = new PriorityQueue!(Tuple!(int, int))( (a, b) => a[1] < b[1] );\\r\\n    pq.insert(tuple(1, 0));\\r\\n\\r\\n    while (!pq.empty) {\\r\\n        auto [u, d] = pq.front;\\r\\n        pq.popFront;\\r\\n\\r\\n        if (d > dist[u]) {\\r\\n            continue;\\r\\n        }\\r\\n\\r\\n        foreach (edge; graph[u]) {\\r\\n            int v = edge.v;\\r\\n            int w = edge.w;\\r\\n\\r\\n            if (dist[u] + w < dist[v]) {\\r\\n                dist[v] = dist[u] + w;\\r\\n                pq.insert(tuple(v, dist[v]));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int minTime = 0;\\r\\n    foreach (p; portals) {\\r\\n        minTime = max(minTime, dist[p]);\\r\\n    }\\r\\n\\r\\n    writeln(minTime);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\n# Read input\nmy $input = <>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\nmy @roads;\nfor (my $i = 0; $i < $m; $i++) {\n    $input = <>;\n    chomp $input;\n    my ($x, $y, $w) = split ' ', $input;\n    push @roads, [$x, $y, $w];\n}\n\n$input = <>;\nchomp $input;\nmy $k = $input;\n\n$input = <>;\nchomp $input;\nmy @portals = split ' ', $input;\n\n# Create adjacency matrix\nmy @adjacency;\nfor (my $i = 0; $i < $n; $i++) {\n    $adjacency[$i][$i] = 0;\n}\n\nforeach my $road (@roads) {\n    my ($x, $y, $w) = @$road;\n    $adjacency[$x-1][$y-1] = $w;\n    $adjacency[$y-1][$x-1] = $w;\n}\n\n# Dijkstra's algorithm\nsub dijkstra {\n    my ($start, $end) = @_;\n    \n    my @distances = (999999999) x $n;\n    my @visited = (0) x $n;\n    \n    $distances[$start] = 0;\n    \n    for (my $i = 0; $i < $n; $i++) {\n        my $min_distance = 999999999;\n        my $min_index = -1;\n        \n        for (my $j = 0; $j < $n; $j++) {\n            if (!$visited[$j] && $distances[$j] < $min_distance) {\n                $min_distance = $distances[$j];\n                $min_index = $j;\n            }\n        }\n        \n        $visited[$min_index] = 1;\n        \n        for (my $j = 0; $j < $n; $j++) {\n            if (!$visited[$j] && $adjacency[$min_index][$j] && $distances[$min_index] + $adjacency[$min_index][$j] < $distances[$j]) {\n                $distances[$j] = $distances[$min_index] + $adjacency[$min_index][$j];\n            }\n        }\n    }\n    \n    return $distances[$end];\n}\n\n# Calculate minimum time to open all portals\nmy $min_time = 0;\nfor (my $i = 0; $i < $k-1; $i++) {\n    my $start = $portals[$i] - 1;\n    my $end = $portals[$i+1] - 1;\n    $min_time += dijkstra($start, $end);\n}\n\n# Print the result\nprint $min_time;\n","Rust":"\nuse std::cmp::Reverse;\nuse std::collections::{BinaryHeap, HashMap};\n\n#[derive(Debug, Clone)]\nstruct Edge {\n    to: usize,\n    weight: u64,\n}\n\nfn dijkstra(graph: &Vec<Vec<Edge>>, start: usize) -> Vec<u64> {\n    let mut dist: Vec<u64> = vec![std::u64::MAX; graph.len()];\n    let mut heap = BinaryHeap::new();\n    dist[start] = 0;\n    heap.push((Reverse(0), start));\n\n    while let Some((Reverse(weight), node)) = heap.pop() {\n        if weight > dist[node] {\n            continue;\n        }\n\n        for edge in &graph[node] {\n            let new_dist = dist[node] + edge.weight;\n            if new_dist < dist[edge.to] {\n                dist[edge.to] = new_dist;\n                heap.push((Reverse(new_dist), edge.to));\n            }\n        }\n    }\n\n    dist\n}\n\nfn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut iter = input.split_whitespace();\n    let n: usize = iter.next().unwrap().parse().unwrap();\n    let m: usize = iter.next().unwrap().parse().unwrap();\n\n    let mut graph: Vec<Vec<Edge>> = vec![Vec::new(); n];\n    for _ in 0..m {\n        let mut input = String::new();\n        std::io::stdin().read_line(&mut input).unwrap();\n        let mut iter = input.split_whitespace();\n        let x: usize = iter.next().unwrap().parse().unwrap();\n        let y: usize = iter.next().unwrap().parse().unwrap();\n        let w: u64 = iter.next().unwrap().parse().unwrap();\n        graph[x - 1].push(Edge { to: y - 1, weight: w });\n        graph[y - 1].push(Edge { to: x - 1, weight: w });\n    }\n\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let k: usize = input.trim().parse().unwrap();\n\n    let mut portals: HashMap<usize, bool> = HashMap::new();\n    let mut portal_cities: Vec<usize> = Vec::new();\n    let mut portal_count = 0;\n\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut iter = input.split_whitespace();\n    for _ in 0..k {\n        let p: usize = iter.next().unwrap().parse().unwrap();\n        portals.insert(p - 1, false);\n        portal_cities.push(p - 1);\n        portal_count += 1;\n    }\n\n    let mut min_time = std::u64::MAX;\n\n    for portal_city in portal_cities {\n        let dist = dijkstra(&graph, portal_city);\n        let mut time = 0;\n        let mut all_portals_open = true;\n\n        for (city, is_open) in portals.iter_mut() {\n            if !*is_open {\n                all_portals_open = false;\n                time += dist[*city];\n                *is_open = true;\n            }\n        }\n\n        if all_portals_open && time < min_time {\n            min_time = time;\n        }\n\n        for (_, is_open) in portals.iter_mut() {\n            *is_open = false;\n        }\n    }\n\n    println!(\"{}\", min_time);\n}\n"}
{"title":"A. Plate Game","description":"You've got a rectangular table with length a and width b and the infinite number of plates of radius r. Two players play the following game: they take turns to put the plates on the table so that the plates don't lie on each other (but they can touch each other), and so that any point on any plate is located within the table's border. During the game one cannot move the plates that already lie on the table. The player who cannot make another move loses. Determine which player wins, the one who moves first or the one who moves second, provided that both players play optimally well.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"A single line contains three space-separated integers a, b, r (1\u2264a,b,r\u2264100) \u2014 the table sides and the plates' radius, correspondingly.\n","output_spec":"If wins the player who moves first, print \"First\" (without the quotes). Otherwise print \"Second\" (without the quotes).\n","notes":"In the first sample the table has place for only one plate. The first player puts a plate on the table, the second player can't do that and loses.\n \nIn the second sample the table is so small that it doesn't have enough place even for one plate. So the first player loses without making a single move.\n \n","sample_inputs":["5 5 2\n","6 7 4\n"],"sample_outputs":["First\n","Second\n"],"id":"197-A","difficulty":1600,"tags":["constructive+algorithms","games","math"],"src_uid":"90b9ef939a13cf29715bc5bce26c9896","C++":"#include <iostream>\\n\\nusing namespace std;\\n\\nint main() {\\n    int a, b, r;\\n    cin >> a >> b >> r;\\n\\n    \/\/ Check if the table can fit at least one plate\\n    if (a >= 2 * r && b >= 2 * r) {\\n        cout << \\\"First\\\" << endl;\\n    } else {\\n        cout << \\\"Second\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class PlateGame {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int a = scanner.nextInt();\\n        int b = scanner.nextInt();\\n        int r = scanner.nextInt();\\n\\n        int maxPlates = (a \/ (2 * r)) * (b \/ (2 * r));\\n\\n        if (maxPlates % 2 == 0) {\\n            System.out.println(\\\"Second\\\");\\n        } else {\\n            System.out.println(\\\"First\\\");\\n        }\\n    }\\n}\" }","Python":"def determine_winner(a, b, r):\\n    if a < 2 * r or b < 2 * r:\\n        return 'First'\\n    else:\\n        return 'Second'\\n\\ninput_data = input().split()\\na = int(input_data[0])\\nb = int(input_data[1])\\nr = int(input_data[2])\\n\\nresult = determine_winner(a, b, r)\\nprint(result)\\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int a, b, r;\\n    scanf(\\\"%d %d %d\\\", &a, &b, &r);\\n    int minSide = a < b ? a : b;\\n    if (2 * r > minSide) {\\n        printf(\\\"Second\\\\n\\\");\\n    } else {\\n        printf(\\\"First\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace PlateGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int a = int.Parse(input[0]);\n            int b = int.Parse(input[1]);\n            int r = int.Parse(input[2]);\n\n            \/\/ Check if the table is too small for even one plate\n            if (a < 2 * r || b < 2 * r)\n            {\n                Console.WriteLine(\\\"Second\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"First\\\");\n            }\n        }\n    }\n}\n","Ruby":"\ndef determine_winner(a, b, r)\n  # Check if the table is too small for even one plate\n  if a < 2 * r || b < 2 * r\n    return 'Second'\n  end\n\n  # Check if the table has enough space for at least one plate\n  if a >= 2 * r && b >= 2 * r\n    return 'First'\n  end\nend\n\n# Read input\ninput = gets.chomp.split(' ')\na = input[0].to_i\nb = input[1].to_i\nr = input[2].to_i\n\n# Determine the winner\nwinner = determine_winner(a, b, r)\n\n# Print the result\nputs winner\n","delphi":"var\\n  a, b, r: Integer;\\nbegin\\n  Readln(a, b, r);\\n  if (2 * r <= a) and (2 * r <= b) then\\n    Writeln('First')\\n  else\\n    Writeln('Second');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar a, b, r int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &a, &b, &r)\\n\\n\\tif 2*r <= a && 2*r <= b {\\n\\t\\tfmt.Println(\\\"First\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"Second\\\")\\n\\t}\\n}","Javascript":"function determineWinner(a, b, r) {\n    \/\/ Check if the table is too small to fit even one plate\n    if (a < 2 * r || b < 2 * r) {\n        return 'Second';\n    }\n    \n    \/\/ Check if the table has enough space for at least one plate\n    if (a >= 2 * r && b >= 2 * r) {\n        return 'First';\n    }\n}\n\n\/\/ Sample inputs\nconst inputs = ['5 5 2', '6 7 4'];\n\n\/\/ Process each input\nconst outputs = inputs.map(input => {\n    const [a, b, r] = input.split(' ').map(Number);\n    return determineWinner(a, b, r);\n});\n\n\/\/ Print the outputs\nconsole.log(outputs.join('\\\\n'));","Kotlin":"fun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val a = input[0]\\n    val b = input[1]\\n    val r = input[2]\\n\\n    val maxRadius = 2 * r\\n    val minSide = minOf(a, b)\\n\\n    if (minSide >= maxRadius) {\\n        println(\\\"First\\\")\\n    } else {\\n        println(\\\"Second\\\")\\n    }\\n}","PHP":"<?php\\n\\nfunction determineWinner($a, $b, $r) {\\n    \/\/ Check if the table is too small for even one plate\\n    if ($a < 2 * $r || $b < 2 * $r) {\\n        return 'Second';\\n    }\\n\\n    \/\/ Check if the table has place for only one plate\\n    if ($a < 2 * $r + $r || $b < 2 * $r + $r) {\\n        return 'First';\\n    }\\n\\n    \/\/ Otherwise, the first player always wins\\n    return 'First';\\n}\\n\\n\/\/ Read input\\n$input = explode(' ', trim(fgets(STDIN)));\\n$a = intval($input[0]);\\n$b = intval($input[1]);\\n$r = intval($input[2]);\\n\\n\/\/ Determine the winner\\n$winner = determineWinner($a, $b, $r);\\n\\n\/\/ Print the result\\necho $winner;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int a, b, r;\\r\\n    readf(\\\"%d %d %d\\\", &a, &b, &r);\\r\\n\\r\\n    int maxPlates = (a \/ (2 * r)) * (b \/ (2 * r));\\r\\n\\r\\n    if (maxPlates % 2 == 0)\\r\\n    {\\r\\n        writeln(\\\"Second\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"First\\\");\\r\\n    }\\r\\n}","perl":"\n# Read input values\nmy $input = <STDIN>;\nchomp $input;\nmy ($a, $b, $r) = split(' ', $input);\n\n# Calculate the maximum number of plates that can be placed on the table\nmy $maxPlates = int($a \/ (2 * $r)) * int($b \/ (2 * $r));\n\n# Determine the winner based on the maximum number of plates\nmy $winner = $maxPlates % 2 == 0 ? 'Second' : 'First';\n\n# Print the winner\nprint $winner;\n","Rust":"fn main() {\\n    let input = String::from(\\\"5 5 2\\\");\\n    let mut input = input.split_whitespace();\\n    let a: i32 = input.next().unwrap().parse().unwrap();\\n    let b: i32 = input.next().unwrap().parse().unwrap();\\n    let r: i32 = input.next().unwrap().parse().unwrap();\\n\\n    let min_side = a.min(b);\\n    let max_radius = 2 * r;\\n\\n    if min_side >= max_radius {\\n        println!(\\\"First\\\");\\n    } else {\\n        println!(\\\"Second\\\");\\n    }\\n}"}
{"title":"B. Special Olympics","description":"A renowned abstract artist Sasha, drawing inspiration from nowhere, decided to paint a picture entitled \"Special Olympics\". He justly thought that, if the regular Olympic games have five rings, then the Special ones will do with exactly two rings just fine.Let us remind you that a ring is a region located between two concentric circles with radii r and R (r<R). These radii are called internal and external, respectively. Concentric circles are circles with centers located at the same point.Soon a white canvas, which can be considered as an infinite Cartesian plane, had two perfect rings, painted with solid black paint. As Sasha is very impulsive, the rings could have different radii and sizes, they intersect and overlap with each other in any way. We know only one thing for sure: the centers of the pair of rings are not the same.When Sasha got tired and fell into a deep sleep, a girl called Ilona came into the room and wanted to cut a circle for the sake of good memories. To make the circle beautiful, she decided to cut along the contour.We'll consider a contour to be a continuous closed line through which there is transition from one color to another (see notes for clarification). If the contour takes the form of a circle, then the result will be cutting out a circle, which Iona wants.But the girl's inquisitive mathematical mind does not rest: how many ways are there to cut a circle out of the canvas?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The input contains two lines. \nEach line has four space-separated integers xi, yi, ri, Ri, that describe the i-th ring; xi and yi are coordinates of the ring's center, ri and Ri are the internal and external radii of the ring correspondingly (-100\u2264xi,yi\u2264100;\u00a01\u2264ri<Ri\u2264100). \nIt is guaranteed that the centers of the rings do not coinside.\n","output_spec":"A single integer \u2014 the number of ways to cut out a circle from the canvas.\n","notes":"Figures for test samples are given below. The possible cuts are marked with red dotted line. \n   \n","sample_inputs":["60 60 45 55\n80 80 8 32\n","60 60 45 55\n80 60 15 25\n","50 50 35 45\n90 50 35 45\n"],"sample_outputs":["1","4","0"],"id":"199-B","difficulty":1900,"tags":["geometry"],"src_uid":"4c2865e4742a29460ca64860740b84f4","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int x1, y1, r1, R1;\\n    int x2, y2, r2, R2;\\n    cin >> x1 >> y1 >> r1 >> R1;\\n    cin >> x2 >> y2 >> r2 >> R2;\\n\\n    double distance = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\\n    double sumRadii = R1 + R2;\\n    double diffRadii = R1 - R2;\\n\\n    if (distance >= sumRadii || distance <= diffRadii) {\\n        cout << 0 << endl;\\n    } else if (distance < R1 && distance + R2 <= R1) {\\n        cout << 1 << endl;\\n    } else if (distance < R2 && distance + R1 <= R2) {\\n        cout << 1 << endl;\\n    } else {\\n        cout << 2 << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class SpecialOlympics {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input1 = scanner.nextLine();\\n        String input2 = scanner.nextLine();\\n\\n        String[] ring1 = input1.split(\\\" \\\");\\n        String[] ring2 = input2.split(\\\" \\\");\\n\\n        int x1 = Integer.parseInt(ring1[0]);\\n        int y1 = Integer.parseInt(ring1[1]);\\n        int r1 = Integer.parseInt(ring1[2]);\\n        int R1 = Integer.parseInt(ring1[3]);\\n\\n        int x2 = Integer.parseInt(ring2[0]);\\n        int y2 = Integer.parseInt(ring2[1]);\\n        int r2 = Integer.parseInt(ring2[2]);\\n        int R2 = Integer.parseInt(ring2[3]);\\n\\n        int distance = (int) Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\\n\\n        if (distance >= R1 + R2) {\\n            System.out.println(0);\\n        } else if (distance + R1 <= R2) {\\n            System.out.println(1);\\n        } else if (distance + R2 <= R1) {\\n            System.out.println(1);\\n        } else if (distance <= Math.abs(R1 - R2)) {\\n            System.out.println(2);\\n        } else {\\n            System.out.println(4);\\n        }\\n    }\\n}\"}}","Python":"import math\\n\\n# Function to check if two circles intersect\\n# or one circle is inside the other\\n\\ndef intersect(x1, y1, r1, x2, y2, r2):\\n    d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\\n\\n    # Check if one circle is inside the other\\n    if d + r2 <= r1 or d + r1 <= r2:\\n        return False\\n\\n    # Check if the circles intersect\\n    if d < r1 + r2:\\n        return True\\n\\n    return False\\n\\n\\n# Function to count the number of ways to cut a circle\\n\\ndef count_ways(rings):\\n    count = 0\\n\\n    # Iterate through all possible pairs of rings\\n    for i in range(len(rings)):\\n        for j in range(i + 1, len(rings)):\\n            x1, y1, r1, R1 = rings[i]\\n            x2, y2, r2, R2 = rings[j]\\n\\n            # Check if the rings intersect\\n            if intersect(x1, y1, R1, x2, y2, R2):\\n                count += 1\\n\\n    return count\\n\\n\\n# Read input\\ninput_lines = input().split('\\\\n')\\n\\nrings = []\\n\\n# Parse input\\nfor line in input_lines:\\n    x, y, r, R = map(int, line.split())\\n    rings.append((x, y, r, R))\\n\\n# Count the number of ways to cut a circle\\nresult = count_ways(rings)\\n\\n# Print the result\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int x1, y1, r1, R1;\\n    int x2, y2, r2, R2;\\n    scanf(\\\"%d %d %d %d\\\", &x1, &y1, &r1, &R1);\\n    scanf(\\\"%d %d %d %d\\\", &x2, &y2, &r2, &R2);\\n\\n    int d = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\\n    int R = R1 + R2;\\n    int r = R1 - R2;\\n\\n    if (d >= R * R) {\\n        printf(\\\"0\\\\n\\\");\\n    } else if (d <= r * r) {\\n        printf(\\\"1\\\\n\\\");\\n    } else {\\n        printf(\\\"4\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace SpecialOlympics\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int x1 = int.Parse(input[0]);\n            int y1 = int.Parse(input[1]);\n            int r1 = int.Parse(input[2]);\n            int R1 = int.Parse(input[3]);\n\n            input = Console.ReadLine().Split(' ');\n            int x2 = int.Parse(input[0]);\n            int y2 = int.Parse(input[1]);\n            int r2 = int.Parse(input[2]);\n            int R2 = int.Parse(input[3]);\n\n            int ways = CountWaysToCutCircle(x1, y1, r1, R1, x2, y2, r2, R2);\n            Console.WriteLine(ways);\n        }\n\n        static int CountWaysToCutCircle(int x1, int y1, int r1, int R1, int x2, int y2, int r2, int R2)\n        {\n            double distance = Math.Sqrt(Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2));\n\n            if (distance >= R1 + R2)\n            {\n                return 0; \/\/ No intersection, no ways to cut a circle\n            }\n            else if (distance <= Math.Abs(R1 - R2))\n            {\n                return 0; \/\/ One circle is completely inside the other, no ways to cut a circle\n            }\n            else if (distance < r1 + r2)\n            {\n                return 0; \/\/ Circles intersect, but one is completely inside the other, no ways to cut a circle\n            }\n            else if (distance == R1 + R2)\n            {\n                return 1; \/\/ Circles touch externally, only one way to cut a circle\n            }\n            else if (distance == Math.Abs(R1 - R2))\n            {\n                return 1; \/\/ One circle is inside the other, only one way to cut a circle\n            }\n            else if (distance < R1 + R2 && distance > Math.Abs(R1 - R2))\n            {\n                return 2; \/\/ Circles intersect, two ways to cut a circle\n            }\n            else\n            {\n                return 4; \/\/ Circles overlap, four ways to cut a circle\n            }\n        }\n    }\n}","Ruby":"def count_ways(ring1, ring2)\n  x1, y1, r1, R1 = ring1\n  x2, y2, r2, R2 = ring2\n  \n  # Calculate the distance between the centers of the rings\n  distance = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n  \n  # Calculate the sum and difference of the radii\n  sum_radii = R1 + R2\n  diff_radii = R1 - R2\n  \n  # Check if the rings are completely separate\n  if distance >= sum_radii\n    return 0\n  end\n  \n  # Check if one ring is completely inside the other\n  if distance + r2 <= R1 && distance + r1 <= R2\n    return 0\n  end\n  \n  # Check if the rings intersect\n  if distance < sum_radii && distance > diff_radii\n    return 2\n  end\n  \n  # Check if one ring is inside the other and they touch externally\n  if distance == diff_radii\n    return 1\n  end\n  \n  # Check if one ring is inside the other and they touch internally\n  if distance == sum_radii\n    return 1\n  end\n  \n  # Otherwise, the rings do not intersect or touch\n  return 0\nend\n\ndef count_circle_cuts(input)\n  rings = input.split(\"\\n\").map { |line| line.split(\" \").map(&:to_i) }\n  \n  # Count the number of ways to cut a circle\n  count = count_ways(rings[0], rings[1]) + count_ways(rings[1], rings[0])\n  \n  return count.to_s\nend\n\ninput = ARGF.read\nputs count_circle_cuts(input)","delphi":"program SpecialOlympics;\\n\\nvar\\n  x1, y1, r1, R1, x2, y2, r2, R2: Integer;\\n  count: Integer;\\n\\nbegin\\n  readln(x1, y1, r1, R1);\\n  readln(x2, y2, r2, R2);\\n\\n  count := 0;\\n\\n  \/\/ Check if the smaller ring is completely inside the larger ring\\n  if (r1 >= r2) and (R1 <= R2) then\\n    count := 1\\n  \/\/ Check if the larger ring is completely inside the smaller ring\\n  else if (r2 >= r1) and (R2 <= R1) then\\n    count := 1\\n  \/\/ Check if the rings intersect\\n  else if (sqrt(sqr(x2 - x1) + sqr(y2 - y1)) <= R1 + R2) then\\n    count := 2;\\n\\n  writeln(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar x1, y1, r1, R1, x2, y2, r2, R2 int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &x1, &y1, &r1, &R1)\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &x2, &y2, &r2, &R2)\\n\\n\\tdist := math.Sqrt(float64((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)))\\n\\n\\tif dist >= float64(R1+r2) {\\n\\t\\tfmt.Println(0)\\n\\t} else if dist <= float64(R1-r2) {\\n\\t\\tfmt.Println(1)\\n\\t} else {\\n\\t\\tfmt.Println(2)\\n\\t}\\n}","Javascript":"function countWaysToCutCircle(input) {\n    const rings = input.split('\\\\n');\n    const ring1 = rings[0].split(' ').map(Number);\n    const ring2 = rings[1].split(' ').map(Number);\n    \n    const x1 = ring1[0];\n    const y1 = ring1[1];\n    const r1 = ring1[2];\n    const R1 = ring1[3];\n    \n    const x2 = ring2[0];\n    const y2 = ring2[1];\n    const r2 = ring2[2];\n    const R2 = ring2[3];\n    \n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    \n    if (distance >= R1 + R2) {\n        return '0';\n    } else if (distance + R2 <= R1) {\n        return '1';\n    } else if (distance + R1 <= R2) {\n        return '1';\n    } else if (distance <= Math.abs(R1 - R2)) {\n        return '2';\n    } else {\n        return '4';\n    }\n}\n\nconst input = '60 60 45 55\\\\n80 80 8 32';\nconsole.log(countWaysToCutCircle(input));","Kotlin":"import kotlin.math.pow\\nimport kotlin.math.sqrt\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\"\\\\n\\\")\\n    val ring1 = input[0].split(\\\" \\\").map { it.toInt() }\\n    val ring2 = input[1].split(\\\" \\\").map { it.toInt() }\\n\\n    val distance = sqrt((ring1[0] - ring2[0]).toDouble().pow(2) + (ring1[1] - ring2[1]).toDouble().pow(2))\\n    val sumRadii = ring1[3] + ring2[3]\\n    val diffRadii = ring1[3] - ring2[3]\\n\\n    val numCuts = when {\\n        distance >= sumRadii -> 0\\n        distance <= diffRadii -> 1\\n        else -> 2\\n    }\\n\\n    println(numCuts)\\n}","PHP":"<?php\\n\\nfunction countCuttingWays($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $ring1 = explode(\\\" \\\", $lines[0]);\\n    $ring2 = explode(\\\" \\\", $lines[1]);\\n\\n    $x1 = $ring1[0];\\n    $y1 = $ring1[1];\\n    $r1 = $ring1[2];\\n    $R1 = $ring1[3];\\n\\n    $x2 = $ring2[0];\\n    $y2 = $ring2[1];\\n    $r2 = $ring2[2];\\n    $R2 = $ring2[3];\\n\\n    $distance = sqrt(pow($x2 - $x1, 2) + pow($y2 - $y1, 2));\\n\\n    if ($distance >= $R1 + $R2) {\\n        return 0;\\n    }\\n\\n    if ($distance <= abs($R1 - $R2)) {\\n        return 0;\\n    }\\n\\n    if ($distance == 0 && $R1 == $R2) {\\n        return 0;\\n    }\\n\\n    $a = ($R1 * $R1 - $R2 * $R2 + $distance * $distance) \/ (2 * $distance);\\n    $h = sqrt($R1 * $R1 - $a * $a);\\n\\n    $x3 = $x1 + $a * ($x2 - $x1) \/ $distance;\\n    $y3 = $y1 + $a * ($y2 - $y1) \/ $distance;\\n\\n    $x4 = $x3 + $h * ($y2 - $y1) \/ $distance;\\n    $y4 = $y3 - $h * ($x2 - $x1) \/ $distance;\\n\\n    $x5 = $x3 - $h * ($y2 - $y1) \/ $distance;\\n    $y5 = $y3 + $h * ($x2 - $x1) \/ $distance;\\n\\n    $cuts = 0;\\n\\n    if (isInsideRing($x4, $y4, $x1, $y1, $r1, $R1) && isInsideRing($x4, $y4, $x2, $y2, $r2, $R2)) {\\n        $cuts++;\\n    }\\n\\n    if (isInsideRing($x5, $y5, $x1, $y1, $r1, $R1) && isInsideRing($x5, $y5, $x2, $y2, $r2, $R2)) {\\n        $cuts++;\\n    }\\n\\n    if ($cuts == 2) {\\n        return 0;\\n    }\\n\\n    if (isInsideRing($x4, $y4, $x1, $y1, $r1, $R1) || isInsideRing($x4, $y4, $x2, $y2, $r2, $R2)) {\\n        $cuts++;\\n    }\\n\\n    if (isInsideRing($x5, $y5, $x1, $y1, $r1, $R1) || isInsideRing($x5, $y5, $x2, $y2, $r2, $R2)) {\\n        $cuts++;\\n    }\\n\\n    return $cuts;\\n}\\n\\nfunction isInsideRing($x, $y, $centerX, $centerY, $r, $R) {\\n    $distance = sqrt(pow($x - $centerX, 2) + pow($y - $centerY, 2));\\n    return $distance >= $r && $distance <= $R;\\n}\\n\\n$input = '60 60 45 55\\\\n80 80 8 32';\\n$result = countCuttingWays($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstruct Ring {\\r\\n    int x;\\r\\n    int y;\\r\\n    int r;\\r\\n    int R;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    Ring[2] rings;\\r\\n\\r\\n    \/\/ Read input\\r\\n    foreach (i; 0..2) {\\r\\n        int xi, yi, ri, Ri;\\r\\n        readf(\\\"%d %d %d %d\\\\n\\\", &xi, &yi, &ri, &Ri);\\r\\n        rings[i] = Ring(xi, yi, ri, Ri);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate the number of ways to cut out a circle\\r\\n    int count = 0;\\r\\n    foreach (i; 0..2) {\\r\\n        foreach (j; 0..2) {\\r\\n            if (i != j) {\\r\\n                \/\/ Check if the rings intersect or overlap\\r\\n                if (rings[i].x - rings[j].x)^2 + (rings[i].y - rings[j].y)^2 < (rings[i].R + rings[j].R)^2 && (rings[i].x - rings[j].x)^2 + (rings[i].y - rings[j].y)^2 > (rings[i].r - rings[j].r)^2 {\\r\\n                    count++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(count);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub count_ways_to_cut_circle {\\n    my ($ring1, $ring2) = @_;\\n    my ($x1, $y1, $r1, $R1) = @$ring1;\\n    my ($x2, $y2, $r2, $R2) = @$ring2;\\n\\n    my $distance = sqrt(($x2 - $x1) ** 2 + ($y2 - $y1) ** 2);\\n\\n    if ($distance >= $R1 + $R2) {\\n        return 0; # No intersection\\n    }\\n\\n    my $small_radius = $r1 < $r2 ? $r1 : $r2;\\n    my $large_radius = $R1 > $R2 ? $R1 : $R2;\\n\\n    if ($distance + $small_radius <= $large_radius) {\\n        return 1; # One circle is completely inside the other\\n    }\\n\\n    my $overlap = $distance + $small_radius - $large_radius;\\n\\n    if ($overlap >= $small_radius) {\\n        return 0; # Circles are tangent or do not intersect\\n    }\\n\\n    my $cut_ways = 0;\\n\\n    if ($distance + $R1 <= $R2) {\\n        $cut_ways++;\\n    }\\n\\n    if ($distance + $R2 <= $R1) {\\n        $cut_ways++;\\n    }\\n\\n    if ($distance + $r1 <= $r2) {\\n        $cut_ways++;\\n    }\\n\\n    if ($distance + $r2 <= $r1) {\\n        $cut_ways++;\\n    }\\n\\n    return $cut_ways;\\n}\\n\\nsub main {\\n    my $input = <STDIN>;\\n    chomp $input;\\n    my ($ring1, $ring2) = split \/\\\\n\/, $input;\\n    my @ring1 = split \/ \/, $ring1;\\n    my @ring2 = split \/ \/, $ring2;\\n\\n    my $ways_to_cut_circle = count_ways_to_cut_circle(\\\\\\@ring1, \\\\\\@ring2);\\n\\n    print $ways_to_cut_circle;\\n}\\n\\nmain();\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|line| line.unwrap());\n\n    let ring1 = parse_ring(&lines.next().unwrap());\n    let ring2 = parse_ring(&lines.next().unwrap());\n\n    let num_ways = count_ways(&ring1, &ring2);\n\n    println!(\"{}\", num_ways);\n}\n\nfn parse_ring(line: &str) -> (i32, i32, i32, i32) {\n    let mut iter = line.split_whitespace().map(|x| x.parse().unwrap());\n    let x = iter.next().unwrap();\n    let y = iter.next().unwrap();\n    let r = iter.next().unwrap();\n    let R = iter.next().unwrap();\n    (x, y, r, R)\n}\n\nfn count_ways(ring1: &(i32, i32, i32, i32), ring2: &(i32, i32, i32, i32)) -> i32 {\n    let (x1, y1, r1, R1) = *ring1;\n    let (x2, y2, r2, R2) = *ring2;\n\n    let d = ((x2 - x1).pow(2) + (y2 - y1).pow(2)).sqrt();\n\n    if d >= R1 + R2 {\n        return 0;\n    }\n\n    if d + R1 <= r2 || d + R2 <= r1 {\n        return 0;\n    }\n\n    if d + r1 <= r2 && d + r2 <= R1 {\n        return 1;\n    }\n\n    if d + r2 <= r1 && d + r1 <= R2 {\n        return 1;\n    }\n\n    if d + r1 <= R2 && d + r2 <= R1 {\n        return 1;\n    }\n\n    if d + r2 <= R1 && d + r1 <= R2 {\n        return 1;\n    }\n\n    4\n}\n"}
{"title":"A. Theatre Square","description":"Theatre Square in the capital city of Berland has a rectangular shape with the size n\u00d7m meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size a\u00d7a.What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The input contains three positive integer numbers in the first line: n,m and a (1\u2264n,m,a\u226410^9).\n","output_spec":"Write the needed number of flagstones.\n","notes":null,"sample_inputs":["6 6 4\n"],"sample_outputs":["4\n"],"id":"1-A","difficulty":1000,"tags":["math"],"src_uid":"ef971874d8c4da37581336284b688517","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    long long n, m, a;\\n    cin >> n >> m >> a;\\n    long long flagstones = ceil((double)n\/a) * ceil((double)m\/a);\\n    cout << flagstones << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        int n = Integer.parseInt(input[0]);\\n        int m = Integer.parseInt(input[1]);\\n        int a = Integer.parseInt(input[2]);\\n\\n        long flagstones = (long) Math.ceil((double) n \/ a) * (long) Math.ceil((double) m \/ a);\\n\\n        System.out.println(flagstones);\\n    }\\n}","Python":"def least_number_of_flagstones(n, m, a):\\n    # Calculate the number of flagstones needed to cover the square\\n    num_flagstones = (n \/\/ a) * (m \/\/ a)\\n    \\n    # Check if there are any remaining rows or columns that need to be covered\\n    if n % a != 0:\\n        num_flagstones += m \/\/ a\\n    if m % a != 0:\\n        num_flagstones += n \/\/ a\\n    \\n    # Check if there is a remaining corner that needs to be covered\\n    if n % a != 0 and m % a != 0:\\n        num_flagstones += 1\\n    \\n    return num_flagstones\\n\\n# Read the input\\ninput_str = input()\\nn, m, a = map(int, input_str.split())\\n\\n# Calculate the least number of flagstones needed\\nresult = least_number_of_flagstones(n, m, a)\\n\\n# Print the result\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m, a;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &a);\\n    long long int width = n \/ a;\\n    long long int length = m \/ a;\\n    if (n % a != 0) {\\n        width++;\\n    }\\n    if (m % a != 0) {\\n        length++;\\n    }\\n    long long int flagstones = width * length;\\n    printf(\\\"%lld\\\", flagstones);\\n    return 0;\\n}","C#":"using System;\n\nnamespace TheatreSquare\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n            int a = int.Parse(input[2]);\n\n            long flagstones = (long)Math.Ceiling((double)n \/ a) * (long)Math.Ceiling((double)m \/ a);\n\n            Console.WriteLine(flagstones);\n        }\n    }\n}","Ruby":"def least_number_of_flagstones(n, m, a)\\n  # Calculate the number of flagstones needed to cover the square\\n  num_flagstones = (n.to_f\/a).ceil * (m.to_f\/a).ceil\\n  return num_flagstones\\nend\\n\\n# Read the input values\\ninput = gets.chomp.split.map(&:to_i)\\nn = input[0]\\nm = input[1]\\na = input[2]\\n\\n# Call the function and print the result\\nputs least_number_of_flagstones(n, m, a)","delphi":"program TheatreSquare;\\n\\nvar\\n  n, m, a, numFlagstones: Int64;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(n, m, a);\\n\\n  \/\/ Calculate the number of flagstones needed\\n  numFlagstones := (n div a) * (m div a);\\n  if n mod a <> 0 then\\n    numFlagstones := numFlagstones + (m div a);\\n  if m mod a <> 0 then\\n    numFlagstones := numFlagstones + (n div a);\\n  if (n mod a <> 0) and (m mod a <> 0) then\\n    numFlagstones := numFlagstones + 1;\\n\\n  \/\/ Print the result\\n  WriteLn(numFlagstones);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, a int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &a)\\n\\n\\t\/\/ Calculate the number of flagstones needed\\n\\tflagstones := math.Ceil(float64(n)\/float64(a)) * math.Ceil(float64(m)\/float64(a))\\n\\n\\tfmt.Println(int(flagstones))\\n}","Javascript":"function calculateFlagstones(input) {\n  \/\/ Parse the input\n  const [n, m, a] = input.split(' ').map(Number);\n\n  \/\/ Calculate the number of flagstones needed\n  const rows = Math.ceil(n \/ a);\n  const columns = Math.ceil(m \/ a);\n  const flagstonesNeeded = rows * columns;\n\n  \/\/ Return the result as a string\n  return flagstonesNeeded.toString();\n}\n\n\/\/ Test the function with the sample input\nconsole.log(calculateFlagstones('6 6 4'));","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val n = input[0]\n    val m = input[1]\n    val a = input[2]\n    \n    val flagstonesNeeded = ((n + a - 1) \/ a) * ((m + a - 1) \/ a)\n    \n    println(flagstonesNeeded)\n}","PHP":"<?php\\n\\n$input = trim(fgets(STDIN));\\nlist($n, $m, $a) = explode(' ', $input);\\n\\n$flagstones = ceil($n\/$a) * ceil($m\/$a);\\necho $flagstones;\\n","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, a;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &a);\\r\\n\\r\\n    int flagstones = ((n + a - 1) \/ a) * ((m + a - 1) \/ a);\\r\\n\\r\\n    writeln(flagstones);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_flagstones {\n    my ($n, $m, $a) = @_;\n\n    my $horizontal_flagstones = int($n \/ $a);\n    my $vertical_flagstones = int($m \/ $a);\n\n    if ($n % $a != 0) {\n        $horizontal_flagstones++;\n    }\n\n    if ($m % $a != 0) {\n        $vertical_flagstones++;\n    }\n\n    return $horizontal_flagstones * $vertical_flagstones;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp($input);\n\n# Parse input\nmy ($n, $m, $a) = split(' ', $input);\n\n# Calculate the number of flagstones needed\nmy $result = calculate_flagstones($n, $m, $a);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut input = input.trim().split(' ');\\n    let n: u64 = input.next().unwrap().parse().unwrap();\\n    let m: u64 = input.next().unwrap().parse().unwrap();\\n    let a: u64 = input.next().unwrap().parse().unwrap();\\n\\n    let flagstones_n = (n + a - 1) \/ a;\\n    let flagstones_m = (m + a - 1) \/ a;\\n    let total_flagstones = flagstones_n * flagstones_m;\\n\\n    println!(\\\"{}\\\", total_flagstones);\\n}"}
{"title":"E. Tractor College","description":"While most students still sit their exams, the tractor college has completed the summer exam session. In fact, students study only one subject at this college \u2014 the Art of Operating a Tractor. Therefore, at the end of a term a student gets only one mark, a three (satisfactory), a four (good) or a five (excellent). Those who score lower marks are unfortunately expelled.The college has n students, and oddly enough, each of them can be on scholarship. The size of the scholarships varies each term. Since the end-of-the-term exam has just ended, it's time to determine the size of the scholarship to the end of next term.The monthly budget for the scholarships of the Tractor college is s rubles. To distribute the budget optimally, you must follow these rules:  The students who received the same mark for the exam, should receive the same scholarship; Let us denote the size of the scholarship (in roubles) for students who have received marks 3, 4 and 5 for the exam, as k3, k4 and k5, respectively. The values k3, k4 and k5 must be integers and satisfy the inequalities 0\u2264k3\u2264k4\u2264k5; Let's assume that c3, c4, c5 show how many students received marks 3, 4 and 5 for the exam, respectively. The budget of the scholarship should be fully spent on them, that is, c3\u00b7k3+c4\u00b7k4+c5\u00b7k5=s; Let's introduce function  \u2014 the value that shows how well the scholarships are distributed between students. In the optimal distribution function f(k3,k4,k5) takes the minimum possible value. Given the results of the exam, and the budget size s, you have to find the optimal distribution of the scholarship.","input_from":"standard input","output_to":"standard output","time_limit":"4 seconds","memory_limit":"256 megabytes","input_spec":"The first line has two integers n, s (3\u2264n\u2264300,1\u2264s\u22643\u00b710^5) \u2014 the number of students and the budget size for the scholarship, respectively. The second line contains n integers, where the i-th number represents the mark that the i-th student got for the exam. It is guaranteed that at each mark was given to at least one student.\n","output_spec":"On a single line print three integers k3, k4 and k5 \u2014 the sought values that represent the optimal distribution of the scholarships. If there are multiple optimal answers, print any of them. If there is no answer, print -1.\n","notes":null,"sample_inputs":["5 11\n3 4 3 5 5\n","6 15\n5 3 3 4 4 5\n"],"sample_outputs":["1 3 3\n","-1\n"],"id":"200-E","difficulty":2400,"tags":["implementation","math","number+theory","ternary+search"],"src_uid":"3f3eb49a127768139283ac04ee44950f","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, s;\\n    cin >> n >> s;\\n    vector<int> marks(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> marks[i];\\n    }\\n    sort(marks.begin(), marks.end());\\n    int k3 = 0, k4 = 0, k5 = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (marks[i] == 3) {\\n            k3++;\\n        } else if (marks[i] == 4) {\\n            k4++;\\n        } else if (marks[i] == 5) {\\n            k5++;\\n        }\\n    }\\n    int min_k = min(k3, min(k4, k5));\\n    int remaining_budget = s - (min_k * 3);\\n    k3 += remaining_budget \/ 3;\\n    k4 += remaining_budget \/ 3;\\n    k5 += remaining_budget \/ 3;\\n    remaining_budget %= 3;\\n    if (remaining_budget == 1) {\\n        if (k3 > 0) {\\n            k3--;\\n            k4++;\\n        } else if (k4 > 0) {\\n            k4--;\\n            k5++;\\n        }\\n    } else if (remaining_budget == 2) {\\n        if (k5 > 0) {\\n            k5--;\\n            k4++;\\n        } else if (k4 > 0) {\\n            k4--;\\n            k3++;\\n        }\\n    }\\n    cout << k3 << \\\" \\\" << k4 << \\\" \\\" << k5 << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int s = scanner.nextInt();\\n        int[] marks = new int[n];\\n        int c3 = 0, c4 = 0, c5 = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            marks[i] = scanner.nextInt();\\n            if (marks[i] == 3) {\\n                c3++;\\n            } else if (marks[i] == 4) {\\n                c4++;\\n            } else if (marks[i] == 5) {\\n                c5++;\\n            }\\n        }\\n\\n        int k3 = -1, k4 = -1, k5 = -1;\\n\\n        for (int i = 0; i <= s; i++) {\\n            for (int j = i; j <= s; j++) {\\n                int remainingBudget = s - (c3 * i + c4 * j);\\n                int remainingStudents = n - (c3 + c4 + c5);\\n\\n                if (remainingBudget >= 0 && remainingBudget % remainingStudents == 0) {\\n                    int k = remainingBudget \/ remainingStudents;\\n                    k3 = i;\\n                    k4 = j;\\n                    k5 = k;\\n                    break;\\n                }\\n            }\\n\\n            if (k3 != -1) {\\n                break;\\n            }\\n        }\\n\\n        if (k3 == -1) {\\n            System.out.println(-1);\\n        } else {\\n            System.out.println(k3 + \\\" \\\" + k4 + \\\" \\\" + k5);\\n        }\\n    }\\n}","Python":"def optimal_distribution(n, s, marks):\n    c3 = marks.count(3)\n    c4 = marks.count(4)\n    c5 = marks.count(5)\n\n    for k3 in range(s \/\/ c3 + 1):\n        for k4 in range((s - k3 * c3) \/\/ c4 + 1):\n            k5 = (s - k3 * c3 - k4 * c4) \/\/ c5\n            if k3 * c3 + k4 * c4 + k5 * c5 == s:\n                return f'{k3} {k4} {k5}'\n\n    return '-1'\n\nn, s = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nprint(optimal_distribution(n, s, marks))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, s;\\n    scanf(\\\"%d %d\\\", &n, &s);\\n    int marks[n];\\n    int c3 = 0, c4 = 0, c5 = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &marks[i]);\\n        if (marks[i] == 3) {\\n            c3++;\\n        } else if (marks[i] == 4) {\\n            c4++;\\n        } else if (marks[i] == 5) {\\n            c5++;\\n        }\\n    }\\n\\n    int k3 = 0, k4 = 0, k5 = 0;\\n    int min_f = s + 1;\\n\\n    for (int i = 0; i <= s; i++) {\\n        for (int j = i; j <= s; j++) {\\n            int remaining_budget = s - (c3 * i + c4 * j);\\n            int k = remaining_budget \/ c5;\\n\\n            if (remaining_budget >= 0 && remaining_budget % c5 == 0 && k >= j) {\\n                int f = k - i;\\n\\n                if (f < min_f) {\\n                    min_f = f;\\n                    k3 = i;\\n                    k4 = j;\\n                    k5 = k;\\n                }\\n            }\\n        }\\n    }\\n\\n    if (min_f == s + 1) {\\n        printf(\\\"-1\\\\n\\\");\\n    } else {\\n        printf(\\\"%d %d %d\\\\n\\\", k3, k4, k5);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int s = int.Parse(input[1]);\n\n        int[] marks = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int c3 = marks.Count(x => x == 3);\n        int c4 = marks.Count(x => x == 4);\n        int c5 = marks.Count(x => x == 5);\n\n        int k5 = Math.Min(s \/ c5, n);\n        s -= k5 * c5;\n\n        int k4 = Math.Min(s \/ c4, n - k5);\n        s -= k4 * c4;\n\n        int k3 = Math.Min(s \/ c3, n - k5 - k4);\n\n        if (k3 + k4 + k5 < n)\n        {\n            Console.WriteLine(\"-1\");\n        }\n        else\n        {\n            Console.WriteLine(k3 + \" \" + k4 + \" \" + k5);\n        }\n    }\n}","Ruby":"\ndef optimal_distribution(n, s, marks)\n  # Count the number of students who received each mark\n  count = Hash.new(0)\n  marks.each { |mark| count[mark] += 1 }\n  \n  # Initialize the scholarship values\n  k3 = 0\n  k4 = 0\n  k5 = 0\n  \n  # Find the optimal distribution of scholarships\n  (0..s).each do |i|\n    (0..s-i).each do |j|\n      k3 = i\n      k4 = j\n      k5 = s - i - j\n      \n      # Check if the distribution satisfies the conditions\n      if k3 <= k4 && k4 <= k5 && count[3] <= k3 && count[4] <= k4 && count[5] <= k5\n        return \"#{k3} #{k4} #{k5}\"\n      end\n    end\n  end\n  \n  return \"-1\" # If no optimal distribution is found\nend\n\n# Read the input\ninput = gets.chomp.split(\"\\n\")\nn, s = input[0].split.map(&:to_i)\nmarks = input[1].split.map(&:to_i)\n\n# Call the function and print the result\nputs optimal_distribution(n, s, marks)\n","delphi":"program TractorScholarship;\\n\\nvar\\n  n, s, k3, k4, k5, c3, c4, c5, i: integer;\\n  marks: array of integer;\\n\\nbegin\\n  readln(n, s);\\n  SetLength(marks, n);\\n  for i := 0 to n-1 do\\n    read(marks[i]);\\n  k3 := 0;\\n  k4 := 0;\\n  k5 := 0;\\n  c3 := 0;\\n  c4 := 0;\\n  c5 := 0;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    if marks[i] = 3 then\\n      Inc(c3)\\n    else if marks[i] = 4 then\\n      Inc(c4)\\n    else if marks[i] = 5 then\\n      Inc(c5);\\n  end;\\n\\n  if c3 = 0 then\\n  begin\\n    k4 := s div c4;\\n    k5 := s div c5;\\n  end\\n  else if c4 = 0 then\\n  begin\\n    k3 := s div c3;\\n    k5 := s div c5;\\n  end\\n  else if c5 = 0 then\\n  begin\\n    k3 := s div c3;\\n    k4 := s div c4;\\n  end\\n  else\\n  begin\\n    k3 := 1;\\n    k4 := (s - c3) div c4;\\n    k5 := (s - c3 - c4) div c5;\\n  end;\\n\\n  writeln(k3, ' ', k4, ' ', k5);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, s int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &s)\\n\\n\\tmarks := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &marks[i])\\n\\t}\\n\\n\\tcount := make(map[int]int)\\n\\tfor _, mark := range marks {\\n\\t\\tcount[mark]++\\n\\t}\\n\\n\\tvar k3, k4, k5 int\\n\\n\\tif count[3] == 0 || count[4] == 0 || count[5] == 0 {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\tfor k3 = 0; k3 <= s; k3++ {\\n\\t\\tfor k4 = k3; k4 <= s; k4++ {\\n\\t\\t\\tk5 = s - k3 - k4\\n\\t\\t\\tif k5 >= 0 {\\n\\t\\t\\t\\tif k5 >= count[5]*5 && k4 >= count[4]*4 && k3 >= count[3]*3 {\\n\\t\\t\\t\\t\\tfmt.Printf(\\\"%d %d %d\\\\n\\\", k3, k4, k5)\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n","Javascript":"function optimalDistribution(input) {\n  const [n, s] = input[0].split(' ').map(Number);\n  const marks = input[1].split(' ').map(Number);\n\n  const c3 = marks.filter(mark => mark === 3).length;\n  const c4 = marks.filter(mark => mark === 4).length;\n  const c5 = marks.filter(mark => mark === 5).length;\n\n  for (let k3 = 0; k3 <= s; k3++) {\n    for (let k4 = k3; k4 <= s; k4++) {\n      const k5 = s - (c3 * k3 + c4 * k4);\n      if (k5 >= k4 && k5 % c5 === 0) {\n        return `${k3} ${k4} ${k5 \/ c5}`;\n      }\n    }\n  }\n\n  return '-1';\n}\n\nconst input = ['5 11\\n3 4 3 5 5\\n'];\nconsole.log(optimalDistribution(input));","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val s = input[1].toInt()\n    val marks = scanner.nextLine().split(\" \").map { it.toInt() }\n\n    val c3 = marks.count { it == 3 }\n    val c4 = marks.count { it == 4 }\n    val c5 = marks.count { it == 5 }\n\n    var k3 = 0\n    var k4 = 0\n    var k5 = 0\n\n    for (i in 0..s) {\n        for (j in 0..s) {\n            for (k in 0..s) {\n                if (c3 * i + c4 * j + c5 * k == s && i <= j && j <= k) {\n                    k3 = i\n                    k4 = j\n                    k5 = k\n                }\n            }\n        }\n    }\n\n    if (k3 == 0 && k4 == 0 && k5 == 0) {\n        println(\"-1\")\n    } else {\n        println(\"$k3 $k4 $k5\")\n    }\n}","PHP":"<?php\\n\\nfunction optimalDistribution($n, $s, $marks) {\\n    $count = array_count_values($marks);\\n    $c3 = $count[3];\\n    $c4 = $count[4];\\n    $c5 = $count[5];\\n\\n    for ($k3 = 0; $k3 <= $s; $k3++) {\\n        for ($k4 = $k3; $k4 <= $s; $k4++) {\\n            $k5 = $s - ($c3 * $k3 + $c4 * $k4);\\n\\n            if ($k5 >= 0 && $k5 % $c5 == 0) {\\n                return [$k3, $k4, $k5 \/ $c5];\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\nlist($n, $s) = explode(\\\" \\\", $input[0]);\\n$marks = array_map('intval', explode(\\\" \\\", $input[1]));\\n\\n$result = optimalDistribution($n, $s, $marks);\\necho implode(\\\" \\\", $result) . \\\"\\\\n\\\";\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, s;\\r\\n    readf(\\\"%d %d\\\", &n, &s);\\r\\n\\r\\n    int[] marks;\\r\\n    marks.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &marks[i]);\\r\\n    }\\r\\n\\r\\n    int k3, k4, k5;\\r\\n    int c3 = count(marks, 3);\\r\\n    int c4 = count(marks, 4);\\r\\n    int c5 = count(marks, 5);\\r\\n\\r\\n    if (c3 == 0 || c4 == 0 || c5 == 0)\\r\\n    {\\r\\n        writeln(\\\"-1\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    int minK = min(s \/ c3, min(s \/ c4, s \/ c5));\\r\\n\\r\\n    k3 = minK;\\r\\n    k4 = minK;\\r\\n    k5 = minK;\\r\\n\\r\\n    s -= k3 * c3;\\r\\n    s -= k4 * c4;\\r\\n    s -= k5 * c5;\\r\\n\\r\\n    while (s > 0)\\r\\n    {\\r\\n        if (c5 > 0)\\r\\n        {\\r\\n            k5++;\\r\\n            s--;\\r\\n            c5--;\\r\\n        }\\r\\n        else if (c4 > 0)\\r\\n        {\\r\\n            k4++;\\r\\n            s--;\\r\\n            c4--;\\r\\n        }\\r\\n        else if (c3 > 0)\\r\\n        {\\r\\n            k3++;\\r\\n            s--;\\r\\n            c3--;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(k3, \\\" \\\", k4, \\\" \\\", k5);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub optimal_distribution {\\n    my ($n, $s, @marks) = @_;\\n    my ($c3, $c4, $c5) = (0, 0, 0);\\n\\n    foreach my $mark (@marks) {\\n        if ($mark == 3) {\\n            $c3++;\\n        } elsif ($mark == 4) {\\n            $c4++;\\n        } elsif ($mark == 5) {\\n            $c5++;\\n        }\\n    }\\n\\n    for (my $k3 = 0; $k3 <= $s; $k3++) {\\n        for (my $k4 = $k3; $k4 <= $s; $k4++) {\\n            my $k5 = $s - ($c3 * $k3 + $c4 * $k4);\\n\\n            if ($k5 >= $k4 && $k5 % $c5 == 0) {\\n                return \\\"$k3 $k4 $k5\\\\n\\\";\\n            }\\n        }\\n    }\\n\\n    return \\\"-1\\\\n\\\";\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $s) = split ' ', $input;\\n\\n$input = <STDIN>;\\nchomp $input;\\nmy @marks = split ' ', $input;\\n\\n# Call the function and print the result\\nmy $result = optimal_distribution($n, $s, @marks);\\nprint $result;\\n","Rust":"fn main() {\\n    let input = std::io::stdin();\\n    let mut buf = String::new();\\n    input.read_line(&mut buf).unwrap();\\n    let mut iter = buf.split_whitespace();\\n    let n: usize = iter.next().unwrap().parse().unwrap();\\n    let s: i32 = iter.next().unwrap().parse().unwrap();\\n\\n    buf.clear();\\n    input.read_line(&mut buf).unwrap();\\n    let marks: Vec<i32> = buf\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut k3 = 0;\\n    let mut k4 = 0;\\n    let mut k5 = 0;\\n\\n    for mark in marks {\\n        match mark {\\n            3 => k3 += 1,\\n            4 => k4 += 1,\\n            5 => k5 += 1,\\n            _ => unreachable!(),\\n        }\\n    }\\n\\n    let mut result = String::new();\\n\\n    for i in 0..=s {\\n        for j in 0..=s {\\n            let remaining = s - i - j;\\n            if remaining >= 0 && remaining % 5 == 0 {\\n                let k5 = remaining \/ 5;\\n                if k5 >= k5 && k4 + k5 >= k4 && k3 + k4 + k5 == n as i32 {\\n                    result = format!(\\\"{} {} {}\\\\n\\\", k3, k4, k5);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    if result.is_empty() {\\n        result = String::from(\\\"-1\\\\n\\\");\\n    }\\n\\n    print!(\\\"{}\\\", result);\\n}"}
{"title":"A. Clear Symmetry","description":"Consider some square matrix A with side n consisting of zeros and ones. There are n rows numbered from 1 to n from top to bottom and n columns numbered from 1 to n from left to right in this matrix. We'll denote the element of the matrix which is located at the intersection of the i-row and the j-th column as Ai,j.Let's call matrix A clear if no two cells containing ones have a common side.Let's call matrix A symmetrical if it matches the matrices formed from it by a horizontal and\/or a vertical reflection. Formally, for each pair (i,j) (1\u2264i,j\u2264n) both of the following conditions must be met: Ai,j=An-i+1,j and Ai,j=Ai,n-j+1.Let's define the sharpness of matrix A as the number of ones in it.Given integer x, your task is to find the smallest positive integer n such that there exists a clear symmetrical matrix A with side n and sharpness x.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line contains a single integer x (1\u2264x\u2264100) \u2014 the required sharpness of the matrix.\n","output_spec":"Print a single number \u2014 the sought value of n.\n","notes":"The figure below shows the matrices that correspond to the samples:\n \n","sample_inputs":["4\n","9\n"],"sample_outputs":["3\n","5\n"],"id":"201-A","difficulty":1700,"tags":["constructive+algorithms","dp","math"],"src_uid":"01eccb722b09a0474903b7e5abc4c47a","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int x;\\n    cin >> x;\\n\\n    int n = 1;\\n    while (true) {\\n        int sharpness = 0;\\n        int half = ceil(n \/ 2.0);\\n\\n        for (int i = 1; i <= half; i++) {\\n            for (int j = 1; j <= half; j++) {\\n                if (i == half && j == half) {\\n                    sharpness += 1;\\n                } else {\\n                    sharpness += 2;\\n                }\\n\\n                if (sharpness >= x) {\\n                    cout << n << endl;\\n                    return 0;\\n                }\\n            }\\n        }\\n\\n        n += 1;\\n    }\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int x = scanner.nextInt();\\n        int n = 1;\\n        while (true) {\\n            int sharpness = calculateSharpness(n);\\n            if (sharpness >= x && isClearSymmetrical(n)) {\\n                System.out.println(n);\\n                break;\\n            }\\n            n++;\\n        }\\n    }\\n\\n    private static int calculateSharpness(int n) {\\n        return n * n \/ 2 + (n % 2 == 1 ? 1 : 0);\\n    }\\n\\n    private static boolean isClearSymmetrical(int n) {\\n        int[][] matrix = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j || i == n - j - 1) {\\n                    matrix[i][j] = 1;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (matrix[i][j] == 1) {\\n                    if (i > 0 && matrix[i - 1][j] == 1) {\\n                        return false;\\n                    }\\n                    if (i < n - 1 && matrix[i + 1][j] == 1) {\\n                        return false;\\n                    }\\n                    if (j > 0 && matrix[i][j - 1] == 1) {\\n                        return false;\\n                    }\\n                    if (j < n - 1 && matrix[i][j + 1] == 1) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}","Python":"import math\\n\\n# Function to check if a matrix is clear\\n\\ndef is_clear(matrix):\\n    n = len(matrix)\\n    for i in range(n):\\n        for j in range(n):\\n            if matrix[i][j] == 1:\\n                if i > 0 and matrix[i-1][j] == 1:\\n                    return False\\n                if i < n-1 and matrix[i+1][j] == 1:\\n                    return False\\n                if j > 0 and matrix[i][j-1] == 1:\\n                    return False\\n                if j < n-1 and matrix[i][j+1] == 1:\\n                    return False\\n    return True\\n\\n\\n# Function to check if a matrix is symmetrical\\n\\ndef is_symmetrical(matrix):\\n    n = len(matrix)\\n    for i in range(n):\\n        for j in range(n):\\n            if matrix[i][j] != matrix[n-i-1][j] or matrix[i][j] != matrix[i][n-j-1]:\\n                return False\\n    return True\\n\\n\\n# Function to find the smallest positive integer n\\n\\ndef find_smallest_n(x):\\n    n = int(math.sqrt(x))\\n    while True:\\n        matrix = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if x > 0:\\n                    matrix[i][j] = 1\\n                    x -= 1\\n        if is_clear(matrix) and is_symmetrical(matrix):\\n            return n\\n        n += 1\\n\\n\\n# Read input\\nx = int(input())\\n\\n# Find smallest n\\nsmallest_n = find_smallest_n(x)\\n\\n# Print output\\nprint(smallest_n)","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isClearSymmetrical(int n, int x) {\\n    int sharpness = 0;\\n    int half = n \/ 2;\\n    int total = n * n;\\n    int count = 0;\\n\\n    for (int i = 1; i <= half; i++) {\\n        count += 2;\\n        sharpness += count;\\n\\n        if (sharpness >= x && sharpness <= total - x) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n}\\n\\nint findSmallestN(int x) {\\n    int n = 1;\\n\\n    while (true) {\\n        if (isClearSymmetrical(n, x)) {\\n            return n;\\n        }\\n\\n        n++;\\n    }\\n}\\n\\nint main() {\\n    int x;\\n    scanf(\\\"%d\\\", &x);\\n\\n    int smallestN = findSmallestN(x);\\n    printf(\\\"%d\\\\n\\\", smallestN);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int x = int.Parse(Console.ReadLine());\n        \n        int n = 1;\n        while (true)\n        {\n            int sharpness = CalculateSharpness(n);\n            if (sharpness >= x)\n            {\n                Console.WriteLine(n);\n                break;\n            }\n            n++;\n        }\n    }\n    \n    public static int CalculateSharpness(int n)\n    {\n        int sharpness = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (IsCellOne(i, j, n))\n                {\n                    sharpness++;\n                }\n            }\n        }\n        return sharpness;\n    }\n    \n    public static bool IsCellOne(int i, int j, int n)\n    {\n        if (i == j || i == n - j + 1)\n        {\n            return true;\n        }\n        return false;\n    }\n}","Ruby":"def find_smallest_n(x)\\n  n = 1\\n  while true\\n    matrix = Array.new(n) { Array.new(n, 0) }\\n    sharpness = 0\\n\\n    (0...n).each do |i|\\n      (0...n).each do |j|\\n        if i == j || i == n - j - 1\\n          matrix[i][j] = 1\\n          sharpness += 1\\n        end\\n      end\\n    end\\n\\n    return n if sharpness >= x\\n    n += 1\\n  end\\nend\\n\\nx = gets.chomp.to_i\\nputs find_smallest_n(x)","delphi":"program ClearSymmetricalMatrix;\n\nuses\n  SysUtils;\n\nfunction IsClearSymmetricalMatrix(n, x: Integer): Boolean;\nvar\n  matrix: array of array of Integer;\n  i, j, count: Integer;\nbegin\n  SetLength(matrix, n, n);\n  \n  \/\/ Initialize matrix with zeros\n  for i := 0 to n-1 do\n    for j := 0 to n-1 do\n      matrix[i, j] := 0;\n  \n  \/\/ Place ones in the matrix\n  count := 0;\n  for i := 0 to n-1 do\n  begin\n    for j := 0 to n-1 do\n    begin\n      if (count < x) and (matrix[i, j] = 0) then\n      begin\n        matrix[i, j] := 1;\n        matrix[n-i-1, j] := 1;\n        matrix[i, n-j-1] := 1;\n        Inc(count);\n      end;\n    end;\n  end;\n  \n  \/\/ Check if matrix is clear and symmetrical\n  for i := 0 to n-1 do\n  begin\n    for j := 0 to n-1 do\n    begin\n      if (matrix[i, j] = 1) and (\n        (i > 0 and matrix[i-1, j] = 1) or\n        (i < n-1 and matrix[i+1, j] = 1) or\n        (j > 0 and matrix[i, j-1] = 1) or\n        (j < n-1 and matrix[i, j+1] = 1)\n      ) then\n      begin\n        Result := False;\n        Exit;\n      end;\n    end;\n  end;\n  \n  Result := True;\nend;\n\nfunction FindSmallestN(x: Integer): Integer;\nvar\n  n: Integer;\nbegin\n  n := 1;\n  while not IsClearSymmetricalMatrix(n, x) do\n    Inc(n);\n  Result := n;\nend;\n\nvar\n  x: Integer;\nbegin\n  ReadLn(x);\n  WriteLn(FindSmallestN(x));\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar x int\\n\\tfmt.Scan(&x)\\n\\n\\tn := int(math.Ceil(math.Sqrt(float64(x))))\\n\\n\\tfmt.Println(n)\\n}","Javascript":"function findSmallestN(x) {\n    let n = 1;\n    while (true) {\n        let matrix = createMatrix(n);\n        let sharpness = countOnes(matrix);\n        if (sharpness >= x && isClearSymmetrical(matrix)) {\n            return n;\n        }\n        n++;\n    }\n}\n\nfunction createMatrix(n) {\n    let matrix = [];\n    for (let i = 0; i < n; i++) {\n        let row = [];\n        for (let j = 0; j < n; j++) {\n            row.push(0);\n        }\n        matrix.push(row);\n    }\n    return matrix;\n}\n\nfunction countOnes(matrix) {\n    let count = 0;\n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[i].length; j++) {\n            if (matrix[i][j] === 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nfunction isClearSymmetrical(matrix) {\n    let n = matrix.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (matrix[i][j] === 1) {\n                if (i > 0 && matrix[i-1][j] === 1) {\n                    return false;\n                }\n                if (j > 0 && matrix[i][j-1] === 1) {\n                    return false;\n                }\n                if (i < n-1 && matrix[i+1][j] === 1) {\n                    return false;\n                }\n                if (j < n-1 && matrix[i][j+1] === 1) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\n\/\/ Read input from stdin\nconst input = readline();\nconst x = parseInt(input);\n\n\/\/ Find the smallest n\nconst smallestN = findSmallestN(x);\n\n\/\/ Print the result\nconsole.log(smallestN);","Kotlin":"import kotlin.math.ceil\\n\\nfun main() {\\n    val x = readLine()!!.toInt()\\n    val n = ceil(Math.sqrt(x.toDouble())).toInt()\\n    println(n)\\n}","PHP":"<?php\\n\\nfunction findSmallestN($x) {\\n    \/\/ Check if x is a perfect square\\n    $sqrt = sqrt($x);\\n    if ($sqrt == floor($sqrt)) {\\n        return $sqrt;\\n    }\\n\\n    \/\/ Find the smallest odd number greater than sqrt(x)\\n    $n = ceil($sqrt);\\n    if ($n % 2 == 0) {\\n        $n++;\\n    }\\n\\n    return $n;\\n}\\n\\n\/\/ Read input\\n$input = trim(fgets(STDIN));\\n\\n\/\/ Call the function and print the result\\n$result = findSmallestN($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int x;\\r\\n    readf(\\\"%d\\\", &x);\\r\\n\\r\\n    int n = 1;\\r\\n    while (true)\\r\\n    {\\r\\n        int sharpness = 0;\\r\\n        int half = n \/ 2;\\r\\n\\r\\n        for (int i = 0; i < n; i++)\\r\\n        {\\r\\n            for (int j = 0; j < n; j++)\\r\\n            {\\r\\n                if ((i < half && j < half) || (i >= half && j >= half))\\r\\n                {\\r\\n                    if (sharpness < x)\\r\\n                    {\\r\\n                        sharpness++;\\r\\n                        write(\\\"1 \\\");\\r\\n                    }\\r\\n                    else\\r\\n                    {\\r\\n                        write(\\\"0 \\\");\\r\\n                    }\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    write(\\\"0 \\\");\\r\\n                }\\r\\n            }\\r\\n\\r\\n            writeln();\\r\\n        }\\r\\n\\r\\n        if (sharpness >= x)\\r\\n        {\\r\\n            writeln(n);\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        n++;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_smallest_n {\n    my $x = shift;\n    \n    # Check for special cases\n    if ($x == 1) {\n        return 1;\n    }\n    \n    # Start with n = 2 and increment until a clear symmetrical matrix is found\n    my $n = 2;\n    while (1) {\n        my $sharpness = calculate_sharpness($n);\n        if ($sharpness >= $x) {\n            return $n;\n        }\n        $n++;\n    }\n}\n\nsub calculate_sharpness {\n    my $n = shift;\n    \n    # Initialize the matrix with zeros\n    my @matrix;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            $matrix[$i][$j] = 0;\n        }\n    }\n    \n    # Set ones in the matrix to create a clear symmetrical matrix\n    for (my $i = 0; $i < int($n\/2); $i++) {\n        for (my $j = 0; $j < int($n\/2); $j++) {\n            $matrix[$i][$j] = 1;\n            $matrix[$i][$n-$j-1] = 1;\n            $matrix[$n-$i-1][$j] = 1;\n            $matrix[$n-$i-1][$n-$j-1] = 1;\n        }\n    }\n    \n    # Calculate the sharpness of the matrix\n    my $sharpness = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            $sharpness += $matrix[$i][$j];\n        }\n    }\n    \n    return $sharpness;\n}\n\n# Read the input\nmy $x = <>;\nchomp $x;\n\n# Find the smallest n\nmy $n = find_smallest_n($x);\n\n# Print the result\nprint $n;\n","Rust":"fn main() {\\n    let sharpness: i32 = 4;\\n    let mut n: i32 = 1;\\n    let mut count: i32 = 0;\\n\\n    while count < sharpness {\\n        n += 1;\\n        count = 0;\\n\\n        for i in 1..=n {\\n            for j in 1..=n {\\n                if (i == j || i == n - j + 1) && (i != (n + 1) \/ 2 || j != (n + 1) \/ 2) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", n);\\n}"}
{"title":"C. Photographer","description":"Valera's lifelong ambition was to be a photographer, so he bought a new camera. Every day he got more and more clients asking for photos, and one day Valera needed a program that would determine the maximum number of people he can serve.The camera's memory is d megabytes. Valera's camera can take photos of high and low quality. One low quality photo takes a megabytes of memory, one high quality photo take b megabytes of memory. For unknown reasons, each client asks him to make several low quality photos and several high quality photos. More formally, the i-th client asks to make xi low quality photos and yi high quality photos.Valera wants to serve as many clients per day as possible, provided that they will be pleased with his work. To please the i-th client, Valera needs to give him everything he wants, that is, to make xi low quality photos and yi high quality photos. To make one low quality photo, the camera must have at least a megabytes of free memory space. Similarly, to make one high quality photo, the camera must have at least b megabytes of free memory space. Initially the camera's memory is empty. Valera also does not delete photos from the camera so that the camera's memory gradually fills up.Calculate the maximum number of clients Valera can successfully serve and print the numbers of these clients.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and d (1\u2264n\u226410^5,1\u2264d\u226410^9) \u2014 the number of clients and the camera memory size, correspondingly. The second line contains two integers a and b (1\u2264a\u2264b\u226410^4) \u2014 the size of one low quality photo and of one high quality photo, correspondingly. \nNext n lines describe the clients. The i-th line contains two integers xi and yi (0\u2264xi,yi\u226410^5) \u2014 the number of low quality photos and high quality photos the i-th client wants, correspondingly. \nAll numbers on all lines are separated by single spaces. \n","output_spec":"On the first line print the answer to the problem \u2014 the maximum number of clients that Valera can successfully serve. Print on the second line the numbers of the client in any order. All numbers must be distinct. If there are multiple answers, print any of them. The clients are numbered starting with 1 in the order in which they are defined in the input data.\n","notes":null,"sample_inputs":["3 10\n2 3\n1 4\n2 1\n1 0\n","3 6\n6 6\n1 1\n1 0\n1 0\n"],"sample_outputs":["2\n3 2 ","1\n2 "],"id":"203-C","difficulty":1400,"tags":["greedy","sortings"],"src_uid":"4d7de18e76600777ff023e1b61366ee4","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nstruct Client {\\n    int id;\\n    int lowQuality;\\n    int highQuality;\\n};\\n\\nbool compareClients(Client a, Client b) {\\n    return (a.lowQuality + a.highQuality) > (b.lowQuality + b.highQuality);\\n}\\n\\nint main() {\\n    int n, d;\\n    cin >> n >> d;\\n\\n    int a, b;\\n    cin >> a >> b;\\n\\n    vector<Client> clients(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> clients[i].lowQuality >> clients[i].highQuality;\\n        clients[i].id = i + 1;\\n    }\\n\\n    sort(clients.begin(), clients.end(), compareClients);\\n\\n    int maxClients = 0;\\n    vector<int> selectedClients;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (d >= clients[i].lowQuality + clients[i].highQuality) {\\n            d -= clients[i].lowQuality + clients[i].highQuality;\\n            maxClients++;\\n            selectedClients.push_back(clients[i].id);\\n        }\\n    }\\n\\n    cout << maxClients << endl;\\n    for (int i = 0; i < maxClients; i++) {\\n        cout << selectedClients[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class ValeraPhotographer {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int d = scanner.nextInt();\\n        int a = scanner.nextInt();\\n        int b = scanner.nextInt();\\n\\n        List<Integer> clients = new ArrayList<>();\\n\\n        for (int i = 1; i <= n; i++) {\\n            int xi = scanner.nextInt();\\n            int yi = scanner.nextInt();\\n\\n            int lowQualityPhotos = xi * a;\\n            int highQualityPhotos = yi * b;\\n\\n            if (lowQualityPhotos + highQualityPhotos <= d) {\\n                clients.add(i);\\n                d -= (lowQualityPhotos + highQualityPhotos);\\n            }\\n        }\\n\\n        System.out.println(clients.size());\\n        for (int client : clients) {\\n            System.out.print(client + \\\" \\\");\\n        }\\n    }\\n}\" }","Python":"def serve_clients(n, d, a, b, clients):\n    # Sort the clients based on the number of high quality photos they want\n    clients.sort(key=lambda x: x[1])\n    \n    # Initialize variables\n    served_clients = []\n    total_memory = 0\n    \n    # Iterate through the clients\n    for i in range(n):\n        xi, yi = clients[i]\n        \n        # Calculate the memory required for the client\n        memory_required = xi * a + yi * b\n        \n        # Check if there is enough memory to serve the client\n        if total_memory + memory_required <= d:\n            served_clients.append(i+1)\n            total_memory += memory_required\n    \n    # Return the number of served clients and their indices\n    return str(len(served_clients)) + '\\\\n' + ' '.join(map(str, served_clients))}\n\n# Read the input\nn, d = map(int, input().split())\na, b = map(int, input().split())\nclients = [list(map(int, input().split())) for _ in range(n)]\n\n# Call the function and print the result\nprint(serve_clients(n, d, a, b, clients))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, d, a, b;\\n    scanf(\\\"%d %d\\\", &n, &d);\\n    scanf(\\\"%d %d\\\", &a, &b);\\n    int clients[n][2];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d %d\\\", &clients[i][0], &clients[i][1]);\\n    }\\n\\n    int servedClients[n];\\n    int numServed = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        int totalMemoryNeeded = clients[i][0] * a + clients[i][1] * b;\\n        if (totalMemoryNeeded <= d) {\\n            servedClients[numServed] = i + 1;\\n            numServed++;\\n            d -= totalMemoryNeeded;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", numServed);\\n    for (int i = 0; i < numServed; i++) {\\n        printf(\\\"%d \\\", servedClients[i]);\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace Photographer\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int d = int.Parse(input[1]);\n\n            input = Console.ReadLine().Split();\n            int a = int.Parse(input[0]);\n            int b = int.Parse(input[1]);\n\n            List<int> clients = new List<int>();\n\n            for (int i = 0; i < n; i++)\n            {\n                input = Console.ReadLine().Split();\n                int x = int.Parse(input[0]);\n                int y = int.Parse(input[1]);\n\n                if (x * a + y * b <= d)\n                {\n                    clients.Add(i + 1);\n                    d -= x * a + y * b;\n                }\n            }\n\n            Console.WriteLine(clients.Count);\n            Console.WriteLine(string.Join(\" \", clients));\n        }\n    }\n}\n","Ruby":"\ndef max_clients(input)\n  # Parse input\n  lines = input.split('\\n')\n  n, d = lines[0].split(' ').map(&:to_i)\n  a, b = lines[1].split(' ').map(&:to_i)\n  clients = lines[2..-1].map { |line| line.split(' ').map(&:to_i) }\n\n  # Sort clients by the number of high quality photos they want\n  clients.sort_by! { |client| client[1] }\n\n  # Calculate the maximum number of clients Valera can serve\n  max_clients = 0\n  total_memory = 0\n  served_clients = []\n\n  clients.each_with_index do |client, index|\n    low_quality_photos = client[0]\n    high_quality_photos = client[1]\n\n    # Calculate the memory required for this client\n    memory_required = low_quality_photos * a + high_quality_photos * b\n\n    # Check if there is enough memory to serve this client\n    if total_memory + memory_required <= d\n      max_clients += 1\n      total_memory += memory_required\n      served_clients << index + 1\n    else\n      break\n    end\n  end\n\n  # Format the output\n  output = \"#{max_clients}\\n\"\n  output += served_clients.join(' ')\n\n  return output\nend\n\n# Test the function with the sample inputs\nputs max_clients('3 10\\n2 3\\n1 4\\n2 1\\n1 0\\n')\nputs max_clients('3 6\\n6 6\\n1 1\\n1 0\\n1 0\\n')\n","delphi":"program ValeraPhotographer;\\n\\nvar\\n  n, d, a, b, i, xi, yi, maxClients: integer;\\n  clients: array of record\\n    x, y, index: integer;\\n  end;\\n\\nbegin\\n  readln(n, d);\\n  readln(a, b);\\n  SetLength(clients, n);\\n  maxClients := 0;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    readln(xi, yi);\\n    clients[i].x := xi;\\n    clients[i].y := yi;\\n    clients[i].index := i+1;\\n  end;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    if (clients[i].x * a + clients[i].y * b) <= d then\\n    begin\\n      writeln(clients[i].index);\\n      maxClients := maxClients + 1;\\n      d := d - (clients[i].x * a + clients[i].y * b);\\n    end;\\n  end;\\n\\n  writeln(maxClients);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, d, a, b int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &d)\\n\\tfmt.Scanf(\\\"%d %d\\\", &a, &b)\\n\\n\\tclients := make([][2]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d %d\\\", &clients[i][0], &clients[i][1])\\n\\t}\\n\\n\\t\/\/ Sort clients by the number of high quality photos in descending order\\n\\tsort.Slice(clients, func(i, j int) bool {\\n\\t\\treturn clients[i][1] > clients[j][1]\\n\\t})\\n\\n\\tmaxClients := 0\\n\\tselectedClients := []int{}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tlowQualityPhotos := clients[i][0]\\n\\t\\thighQualityPhotos := clients[i][1]\\n\\n\\t\\tif lowQualityPhotos*a + highQualityPhotos*b <= d {\\n\\t\\t\\td -= lowQualityPhotos*a + highQualityPhotos*b\\n\\t\\t\\tmaxClients++\\n\\t\\t\\tselectedClients = append(selectedClients, i+1)\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxClients)\\n\\tfor _, client := range selectedClients {\\n\\t\\tfmt.Printf(\\\"%d \\\", client)\\n\\t}\\n}","Javascript":"function serveClients(input) {\n    \/\/ Parse the input\n    const lines = input.split('\\\\n');\n    const [n, d] = lines[0].split(' ').map(Number);\n    const [a, b] = lines[1].split(' ').map(Number);\n    \n    \/\/ Create an array to store the clients\n    const clients = [];\n    \n    \/\/ Iterate over the client lines and add them to the array\n    for (let i = 2; i < lines.length; i++) {\n        const [x, y] = lines[i].split(' ').map(Number);\n        clients.push({ index: i - 1, x, y });\n    }\n    \n    \/\/ Sort the clients in descending order of the number of high quality photos they want\n    clients.sort((client1, client2) => client2.y - client1.y);\n    \n    \/\/ Calculate the maximum number of clients that can be served\n    let maxClients = 0;\n    let memory = d;\n    \n    for (const client of clients) {\n        const lowQualityPhotos = client.x;\n        const highQualityPhotos = client.y;\n        \n        const lowQualityMemoryNeeded = lowQualityPhotos * a;\n        const highQualityMemoryNeeded = highQualityPhotos * b;\n        \n        if (lowQualityMemoryNeeded <= memory && highQualityMemoryNeeded <= memory) {\n            memory -= lowQualityMemoryNeeded + highQualityMemoryNeeded;\n            maxClients++;\n        }\n    }\n    \n    \/\/ Create an array to store the indices of the successfully served clients\n    const servedClients = [];\n    \n    \/\/ Iterate over the clients again and add the indices of the successfully served clients to the array\n    for (const client of clients) {\n        const lowQualityPhotos = client.x;\n        const highQualityPhotos = client.y;\n        \n        const lowQualityMemoryNeeded = lowQualityPhotos * a;\n        const highQualityMemoryNeeded = highQualityPhotos * b;\n        \n        if (lowQualityMemoryNeeded <= d && highQualityMemoryNeeded <= d) {\n            servedClients.push(client.index);\n            d -= lowQualityMemoryNeeded + highQualityMemoryNeeded;\n        }\n    }\n    \n    \/\/ Return the result as a string in the specified format\n    return maxClients + '\\\\n' + servedClients.join(' ');\n}\n\n\/\/ Test the function with the provided sample inputs\nconst inputs = ['3 10\\\\n2 3\\\\n1 4\\\\n2 1\\\\n1 0\\\\n', '3 6\\\\n6 6\\\\n1 1\\\\n1 0\\\\n1 0\\\\n'];\nconst outputs = [];\n\nfor (const input of inputs) {\n    const output = serveClients(input);\n    outputs.push(output);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val nd = scanner.nextLine().split(\" \")\n    val n = nd[0].toInt()\n    val d = nd[1].toInt()\n    val ab = scanner.nextLine().split(\" \")\n    val a = ab[0].toInt()\n    val b = ab[1].toInt()\n    \n    val clients = mutableListOf<Pair<Int, Int>>()\n    for (i in 0 until n) {\n        val xy = scanner.nextLine().split(\" \")\n        val x = xy[0].toInt()\n        val y = xy[1].toInt()\n        clients.add(Pair(x, y))\n    }\n    \n    val result = mutableListOf<Int>()\n    var remainingMemory = d\n    for (i in 0 until n) {\n        val (x, y) = clients[i]\n        val lowQualityPhotos = x * a\n        val highQualityPhotos = y * b\n        val totalMemoryRequired = lowQualityPhotos + highQualityPhotos\n        \n        if (totalMemoryRequired <= remainingMemory) {\n            result.add(i + 1)\n            remainingMemory -= totalMemoryRequired\n        }\n    }\n    \n    println(result.size)\n    println(result.joinToString(\" \"))\n}","PHP":"<?php\\n\\nfunction serveClients($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $nd = explode(\\\" \\\", $lines[0]);\\n    $ab = explode(\\\" \\\", $lines[1]);\\n    $n = intval($nd[0]);\\n    $d = intval($nd[1]);\\n    $a = intval($ab[0]);\\n    $b = intval($ab[1]);\\n    \\n    $clients = [];\\n    for ($i = 2; $i < $n + 2; $i++) {\\n        $xy = explode(\\\" \\\", $lines[$i]);\\n        $x = intval($xy[0]);\\n        $y = intval($xy[1]);\\n        $clients[] = [$x, $y, $i - 1];\\n    }\\n    \\n    usort($clients, function($a, $b) use ($a, $b) {\\n        return ($a[0] + $a[1]) <=> ($b[0] + $b[1]);\\n    });\\n    \\n    $servedClients = [];\\n    $totalMemory = 0;\\n    foreach ($clients as $client) {\\n        $x = $client[0];\\n        $y = $client[1];\\n        $clientNumber = $client[2];\\n        \\n        $memoryNeeded = $x * $a + $y * $b;\\n        if ($totalMemory + $memoryNeeded <= $d) {\\n            $servedClients[] = $clientNumber;\\n            $totalMemory += $memoryNeeded;\\n        }\\n    }\\n    \\n    $output = count($servedClients) . \\\"\\\\n\\\";\\n    $output .= implode(\\\" \\\", $servedClients) . \\\" \\\";\\n    \\n    return $output;\\n}\\n\\n$input = '3 10\\\\n2 3\\\\n1 4\\\\n2 1\\\\n1 0\\\\n';\\necho serveClients($input);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nstruct Client {\\r\\n    int index;\\r\\n    int lowQuality;\\r\\n    int highQuality;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, d;\\r\\n    int a, b;\\r\\n    int maxClients = 0;\\r\\n    int[] clients;\\r\\n    Client[] clientList;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &n, &d);\\r\\n    scanf(\\\"%d %d\\\", &a, &b);\\r\\n\\r\\n    \/\/ Read client requests\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        int x, y;\\r\\n        scanf(\\\"%d %d\\\", &x, &y);\\r\\n        clientList ~= Client(i + 1, x, y);\\r\\n    }\\r\\n\\r\\n    \/\/ Sort clients by the number of high quality photos they want\\r\\n    clientList.sort!((a, b) => a.highQuality > b.highQuality);\\r\\n\\r\\n    \/\/ Serve clients\\r\\n    foreach (client; clientList) {\\r\\n        int lowQualityPhotos = client.lowQuality * a;\\r\\n        int highQualityPhotos = client.highQuality * b;\\r\\n\\r\\n        \/\/ Check if there is enough memory to serve the client\\r\\n        if (lowQualityPhotos <= d && highQualityPhotos <= d) {\\r\\n            d -= lowQualityPhotos;\\r\\n            d -= highQualityPhotos;\\r\\n            maxClients++;\\r\\n            clients ~= client.index;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(maxClients);\\r\\n    writeln(clients);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub serve_clients {\n    my ($n, $d, $a, $b, @clients) = @_;\n\n    my @served_clients;\n    my $total_memory = 0;\n    my $max_clients = 0;\n\n    for my $i (0..$n-1) {\n        my ($x, $y) = @{$clients[$i]};\n        my $memory_required = $x * $a + $y * $b;\n\n        if ($memory_required <= $d - $total_memory) {\n            push @served_clients, $i+1;\n            $total_memory += $memory_required;\n            $max_clients++;\n        }\n    }\n\n    return ($max_clients, \\@served_clients);\n}\n\n# Read input\nmy ($n, $d) = split ' ', <>;\nmy ($a, $b) = split ' ', <>;\nmy @clients;\nfor (1..$n) {\n    push @clients, [split ' ', <>];\n}\n\n# Serve clients\nmy ($max_clients, $served_clients) = serve_clients($n, $d, $a, $b, @clients);\n\n# Print output\nprint \"$max_clients\\n\";\nprint join(' ', @$served_clients), ' ';\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nd: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nd[0];\n    let d = nd[1];\n    \n    let ab: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let a = ab[0];\n    let b = ab[1];\n    \n    let mut clients: Vec<(usize, usize)> = Vec::new();\n    for _ in 0..n {\n        let xy: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        let x = xy[0];\n        let y = xy[1];\n        clients.push((x, y));\n    }\n    \n    let mut served_clients: Vec<usize> = Vec::new();\n    let mut remaining_memory = d;\n    \n    for (i, (x, y)) in clients.iter().enumerate() {\n        let low_quality_photos = *x;\n        let high_quality_photos = *y;\n        \n        let low_quality_memory = low_quality_photos * a;\n        let high_quality_memory = high_quality_photos * b;\n        \n        if low_quality_memory <= remaining_memory && high_quality_memory <= remaining_memory {\n            served_clients.push(i + 1);\n            remaining_memory -= low_quality_memory + high_quality_memory;\n        }\n    }\n    \n    println!(\"{}\", served_clients.len());\n    println!(\"{}\", served_clients.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\" \"));\n}"}
{"title":"A. Little Elephant and Interval","description":"The Little Elephant very much loves sums on intervals.This time he has a pair of integers l and r (l\u2264r). The Little Elephant has to find the number of such integers x (l\u2264x\u2264r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.Help him and count the number of described numbers x for a given pair l and r.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The single line contains a pair of integers l and r (1\u2264l\u2264r\u226410^18) \u2014 the boundaries of the interval.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.\n","output_spec":"On a single line print a single integer \u2014 the answer to the problem.\n","notes":"In the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. \n","sample_inputs":["2 47\n","47 1024\n"],"sample_outputs":["12\n","98\n"],"id":"204-A","difficulty":1500,"tags":["binary+search","combinatorics","dp"],"src_uid":"9642368dc4ffe2fc6fe6438c7406c1bd","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    long long l, r;\\n    cin >> l >> r;\\n    int count = 0;\\n    for (long long i = l; i <= r; i++) {\\n        string num = to_string(i);\\n        if (num[0] == num[num.length() - 1]) {\\n            count++;\\n        }\\n    }\\n    cout << count << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        long l = scanner.nextLong();\\n        long r = scanner.nextLong();\\n        int count = 0;\\n\\n        for (long i = l; i <= r; i++) {\\n            String number = String.valueOf(i);\\n            if (number.charAt(0) == number.charAt(number.length() - 1)) {\\n                count++;\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}","Python":"l, r = map(int, input().split())\\n\\ncount = 0\\n\\nfor i in range(l, r+1):\\n    if str(i)[0] == str(i)[-1]:\\n        count += 1\\n\\nprint(count)","C":"#include <stdio.h>\\n\\nint main() {\\n    long long l, r;\\n    scanf(\\\"%lld %lld\\\", &l, &r);\\n    int count = 0;\\n    for (long long i = l; i <= r; i++) {\\n        long long num = i;\\n        int first_digit = num % 10;\\n        while (num >= 10) {\\n            num \/= 10;\\n        }\\n        int last_digit = num;\\n        if (first_digit == last_digit) {\\n            count++;\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", count);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace LittleElephant\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            long l = long.Parse(input[0]);\n            long r = long.Parse(input[1]);\n\n            int count = 0;\n\n            for (long i = l; i <= r; i++)\n            {\n                string number = i.ToString();\n                if (number[0] == number[number.Length - 1])\n                {\n                    count++;\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n    }\n}\n","Ruby":"\ndef count_numbers(l, r)\n  count = 0\n  (l..r).each do |num|\n    if num.to_s[0] == num.to_s[-1]\n      count += 1\n    end\n  end\n  return count\nend\n\ninput = gets.chomp.split(' ')\nl = input[0].to_i\nr = input[1].to_i\n\noutput = count_numbers(l, r)\nputs output\n","delphi":"program LittleElephantSums;\\n\\nvar\\n  l, r, x, count: Int64;\\n  firstDigit, lastDigit: Integer;\\nbegin\\n  \/\/ Read the input\\n  Readln(l, r);\\n\\n  \/\/ Initialize the count\\n  count := 0;\\n\\n  \/\/ Iterate through the numbers from l to r\\n  for x := l to r do\\n  begin\\n    \/\/ Get the first and last digits of x\\n    firstDigit := x div Trunc(Power(10, Length(IntToStr(x)) - 1));\\n    lastDigit := x mod 10;\\n\\n    \/\/ Check if the first and last digits are equal\\n    if firstDigit = lastDigit then\\n      Inc(count);\\n  end;\\n\\n  \/\/ Print the count\\n  Writeln(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar l, r int64\\n\\tfmt.Scanf(\\\"%d %d\\\", &l, &r)\\n\\n\\tcount := 0\\n\\n\\tfor i := l; i <= r; i++ {\\n\\t\\tnumStr := strconv.FormatInt(i, 10)\\n\\t\\tif numStr[0] == numStr[len(numStr)-1] {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function countNumbers(l, r) {\n    let count = 0;\n    for (let i = l; i <= r; i++) {\n        let numStr = i.toString();\n        if (numStr[0] === numStr[numStr.length - 1]) {\n            count++;\n        }\n    }\n    return count;\n}\n\nconst input = '47 1024\\n';\nconst [l, r] = input.trim().split(' ').map(Number);\nconst result = countNumbers(l, r);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val l = input[0].toLong()\n    val r = input[1].toLong()\n    \n    var count = 0\n    \n    for (i in l..r) {\n        val number = i.toString()\n        if (number[0] == number[number.length - 1]) {\n            count++\n        }\n    }\n    \n    println(count)\n}","PHP":"\n<?php\n\nfunction countNumbers($l, $r) {\n    $count = 0;\n    \n    for ($i = $l; $i <= $r; $i++) {\n        $firstDigit = intval($i \/ pow(10, strlen($i) - 1));\n        $lastDigit = $i % 10;\n        \n        if ($firstDigit == $lastDigit) {\n            $count++;\n        }\n    }\n    \n    return $count;\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$l = intval($input[0]);\n$r = intval($input[1]);\n\n$output = countNumbers($l, $r);\necho $output;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nint countNumbers(int l, int r)\\r\\n{\\r\\n    int count = 0;\\r\\n    for (int i = l; i <= r; i++)\\r\\n    {\\r\\n        int firstDigit = i % 10;\\r\\n        int lastDigit = i \/ 10;\\r\\n        if (firstDigit == lastDigit)\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int l, r;\\r\\n    readf(\\\"%d %d\\\", &l, &r);\\r\\n    int result = countNumbers(l, r);\\r\\n    writef(\\\"%d\\\\n\\\", result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_numbers {\n    my ($l, $r) = @_;\n\n    my $count = 0;\n\n    for my $num ($l..$r) {\n        my $first_digit = substr($num, 0, 1);\n        my $last_digit = substr($num, -1, 1);\n\n        if ($first_digit == $last_digit) {\n            $count++;\n        }\n    }\n\n    return $count;\n}\n\nmy $input = <STDIN>;\nchomp $input;\nmy ($l, $r) = split ' ', $input;\n\nmy $result = count_numbers($l, $r);\nprint $result;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut iter = input.trim().split_whitespace();\\n    let l: u64 = iter.next().unwrap().parse().unwrap();\\n    let r: u64 = iter.next().unwrap().parse().unwrap();\\n\\n    let mut count = 0;\\n\\n    for i in l..=r {\\n        let digits: Vec<char> = i.to_string().chars().collect();\\n        if digits[0] == digits[digits.len() - 1] {\\n            count += 1;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"B. Little Elephant and Cards","description":"The Little Elephant loves to play with color cards.He has n cards, each has exactly two colors (the color of the front side and the color of the back side). Initially, all the cards lay on the table with the front side up. In one move the Little Elephant can turn any card to the other side. The Little Elephant thinks that a set of cards on the table is funny if at least half of the cards have the same color (for each card the color of the upper side is considered).Help the Little Elephant to find the minimum number of moves needed to make the set of n cards funny.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer n (1\u2264n\u226410^5) \u2014 the number of the cards. The following n lines contain the description of all cards, one card per line. The cards are described by a pair of positive integers not exceeding 10^9 \u2014 colors of both sides. The first number in a line is the color of the front of the card, the second one \u2014 of the back. The color of the front of the card may coincide with the color of the back of the card.\nThe numbers in the lines are separated by single spaces.\n","output_spec":"On a single line print a single integer \u2014 the sought minimum number of moves. If it is impossible to make the set funny, print -1.\n","notes":"In the first sample there initially are three cards lying with colors 4, 4, 7. Since two of the three cards are of the same color 4, you do not need to change anything, so the answer is 0.\nIn the second sample, you can turn the first and the fourth cards. After that three of the five cards will be of color 7.\n","sample_inputs":["3\n4 7\n4 7\n7 4\n","5\n4 7\n7 4\n2 11\n9 7\n1 1\n"],"sample_outputs":["0\n","2\n"],"id":"204-B","difficulty":1500,"tags":["binary+search","data+structures"],"src_uid":"5e055bad1da5bdc84599d6f2f89fbd12","C++":"#include <iostream>\\n#include <vector>\\n#include <map>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<pair<int, int>> cards(n);\\n    map<int, int> count;\\n\\n    for (int i = 0; i < n; i++) {\\n        cin >> cards[i].first >> cards[i].second;\\n        count[cards[i].first]++;\\n    }\\n\\n    int maxCount = 0;\\n    for (auto it = count.begin(); it != count.end(); it++) {\\n        maxCount = max(maxCount, it->second);\\n    }\\n\\n    if (maxCount >= n \/ 2) {\\n        cout << 0 << endl;\\n    } else {\\n        int moves = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (cards[i].first != cards[i].second) {\\n                int otherColorCount = count[cards[i].second];\\n                if (maxCount + otherColorCount >= n \/ 2) {\\n                    moves++;\\n                    maxCount++;\\n                }\\n            }\\n        }\\n        if (maxCount >= n \/ 2) {\\n            cout << moves << endl;\\n        } else {\\n            cout << -1 << endl;\\n        }\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class FunnyCards {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        \n        Map<Integer, Integer> countMap = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            String[] colors = scanner.nextLine().split(\\\" \\\");\n            int frontColor = Integer.parseInt(colors[0]);\n            int backColor = Integer.parseInt(colors[1]);\n            \n            countMap.put(frontColor, countMap.getOrDefault(frontColor, 0) + 1);\n        }\n        \n        int maxCount = 0;\n        for (int count : countMap.values()) {\n            maxCount = Math.max(maxCount, count);\n        }\n        \n        if (maxCount >= n \/ 2) {\n            System.out.println(0);\n        } else {\n            System.out.println((n \/ 2) - maxCount);\n        }\n    }\n}","Python":"def minimum_moves(n, cards):\n    colors = {}\n    for card in cards:\n        front_color, back_color = card\n        if front_color in colors:\n            colors[front_color] += 1\n        else:\n            colors[front_color] = 1\n        if back_color != front_color:\n            if back_color in colors:\n                colors[back_color] += 1\n            else:\n                colors[back_color] = 1\n    \n    max_count = max(colors.values())\n    if max_count >= n \/\/ 2:\n        return 0\n    elif max_count + (n - max_count * 2) >= n \/\/ 2:\n        return (n \/\/ 2) - max_count\n    else:\n        return -1\n\n# Sample inputs\ninputs = ['3\\n4 7\\n4 7\\n7 4\\n', '5\\n4 7\\n7 4\\n2 11\\n9 7\\n1 1\\n']\noutputs = ['0\\n', '2\\n']\n\nresults = []\nfor i in range(len(inputs)):\n    input_lines = inputs[i].strip().split('\\n')\n    n = int(input_lines[0])\n    cards = [list(map(int, line.split())) for line in input_lines[1:]]\n    \n    output = minimum_moves(n, cards)\n    results.append(output == int(outputs[i]))\n\n# Print results\nprint(results)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int colors[100000][2];\\n    int count[100000] = {0};\\n    int maxCount = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d %d\\\", &colors[i][0], &colors[i][1]);\\n        count[colors[i][0]]++;\\n        if (colors[i][0] != colors[i][1]) {\\n            count[colors[i][1]]++;\\n        }\\n        if (count[colors[i][0]] > maxCount) {\\n            maxCount = count[colors[i][0]];\\n        }\\n        if (count[colors[i][1]] > maxCount) {\\n            maxCount = count[colors[i][1]];\\n        }\\n    }\\n\\n    if (maxCount >= (n + 1) \/ 2) {\\n        printf(\\\"0\\\\n\\\");\\n    } else {\\n        printf(\\\"%d\\\\n\\\", (n + 1) \/ 2 - maxCount);\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace FunnyCards\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            Dictionary<int, int> count = new Dictionary<int, int>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] colors = Console.ReadLine().Split();\n                int frontColor = int.Parse(colors[0]);\n                int backColor = int.Parse(colors[1]);\n\n                if (!count.ContainsKey(frontColor))\n                    count[frontColor] = 0;\n\n                count[frontColor]++;\n            }\n\n            int maxCount = 0;\n            foreach (int c in count.Values)\n            {\n                maxCount = Math.Max(maxCount, c);\n            }\n\n            if (maxCount >= n \/ 2)\n                Console.WriteLine(0);\n            else\n                Console.WriteLine((n \/ 2) - maxCount);\n        }\n    }\n}","Ruby":"\ndef minimum_moves(n, cards)\n  colors = Hash.new(0)\n  \n  cards.each do |card|\n    colors[card[0]] += 1\n  end\n  \n  max_color_count = colors.values.max\n  \n  if max_color_count >= (n + 1) \/ 2\n    return 0\n  end\n  \n  remaining_cards = n - max_color_count\n  \n  if remaining_cards >= max_color_count\n    return -1\n  end\n  \n  return max_color_count - remaining_cards\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\ncards = []\n\n(1..n).each do |i|\n  cards << input[i].split(' ').map(&:to_i)\nend\n\nputs minimum_moves(n, cards)\n","delphi":"program FunnyCards;\\n\\nvar\\n  n, i, count, maxCount: integer;\\n  front, back: array[1..100000] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n  begin\\n    readln(front[i], back[i]);\\n    if front[i] = back[i] then\\n      count := count + 1;\\n  end;\\n\\n  maxCount := count;\\n\\n  for i := 1 to n do\\n  begin\\n    if front[i] <> back[i] then\\n    begin\\n      count := 0;\\n      for j := 1 to n do\\n      begin\\n        if (front[j] = front[i]) or (back[j] = front[i]) then\\n          count := count + 1;\\n      end;\\n      if count > maxCount then\\n        maxCount := count;\\n\\n      count := 0;\\n      for j := 1 to n do\\n      begin\\n        if (front[j] = back[i]) or (back[j] = back[i]) then\\n          count := count + 1;\\n      end;\\n      if count > maxCount then\\n        maxCount := count;\\n    end;\\n  end;\\n\\n  if maxCount >= (n + 1) div 2 then\\n    writeln(0)\\n  else\\n    writeln(-1);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\tcards := make(map[int]int)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tfront, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\\tscanner.Scan()\\n\\t\\tback, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\\tif front == back {\\n\\t\\t\\tcards[front]++\\n\\t\\t} else {\\n\\t\\t\\tcards[front]++\\n\\t\\t\\tcards[back]++\\n\\t\\t}\\n\\t}\\n\\n\\tmaxCount := 0\\n\\n\\tfor _, count := range cards {\\n\\t\\tif count > maxCount {\\n\\t\\t\\tmaxCount = count\\n\\t\\t}\\n\\t}\\n\\n\\tif maxCount >= (n+1)\/2 {\\n\\t\\tfmt.Println(0)\\n\\t} else {\\n\\t\\tfmt.Println((n+1)\/2 - maxCount)\\n\\t}\\n}","Javascript":"function findMinimumMoves(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const cards = [];\n  \n  for (let i = 1; i <= n; i++) {\n    const colors = lines[i].split(' ').map(Number);\n    cards.push(colors);\n  }\n  \n  const colorCounts = {};\n  \n  for (let i = 0; i < n; i++) {\n    const frontColor = cards[i][0];\n    const backColor = cards[i][1];\n    \n    if (colorCounts[frontColor]) {\n      colorCounts[frontColor]++;\n    } else {\n      colorCounts[frontColor] = 1;\n    }\n    \n    if (colorCounts[backColor]) {\n      colorCounts[backColor]++;\n    } else {\n      colorCounts[backColor] = 1;\n    }\n  }\n  \n  const targetCount = Math.ceil(n \/ 2);\n  let minMoves = Infinity;\n  \n  for (const color in colorCounts) {\n    const count = colorCounts[color];\n    const moves = Math.max(0, targetCount - count);\n    minMoves = Math.min(minMoves, moves);\n  }\n  \n  return minMoves === Infinity ? -1 : minMoves;\n}\n\nconst inputs = ['3\\\\n4 7\\\\n4 7\\\\n7 4\\\\n', '5\\\\n4 7\\\\n7 4\\\\n2 11\\\\n9 7\\\\n1 1\\\\n'];\nconst outputs = [];\n\nfor (const input of inputs) {\n  const output = findMinimumMoves(input);\n  outputs.push(output);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val cards = mutableListOf<Pair<Int, Int>>()\n    \n    for (i in 0 until n) {\n        val frontColor = scanner.nextInt()\n        val backColor = scanner.nextInt()\n        cards.add(Pair(frontColor, backColor))\n    }\n    \n    val colorCount = mutableMapOf<Int, Int>()\n    \n    for (card in cards) {\n        colorCount[card.first] = colorCount.getOrDefault(card.first, 0) + 1\n    }\n    \n    var minMoves = Int.MAX_VALUE\n    \n    for (card in cards) {\n        val frontColor = card.first\n        val backColor = card.second\n        \n        val frontColorCount = colorCount.getOrDefault(frontColor, 0)\n        val backColorCount = colorCount.getOrDefault(backColor, 0)\n        \n        val movesNeeded = (n + 1) \/ 2 - frontColorCount\n        \n        if (movesNeeded <= 0) {\n            minMoves = 0\n            break\n        }\n        \n        if (movesNeeded <= backColorCount) {\n            minMoves = minOf(minMoves, movesNeeded)\n        }\n    }\n    \n    if (minMoves == Int.MAX_VALUE) {\n        println(-1)\n    } else {\n        println(minMoves)\n    }\n}","PHP":"<?php\\n\\nfunction findMinimumMoves($input) {\\n    $cards = explode(\\\"\\\\n\\\", $input);\\n    $n = (int)$cards[0];\\n    $colors = [];\\n    $moves = 0;\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $card = explode(\\\" \\\", $cards[$i]);\\n        $frontColor = (int)$card[0];\\n        $backColor = (int)$card[1];\\n\\n        if (!isset($colors[$frontColor])) {\\n            $colors[$frontColor] = 0;\\n        }\\n\\n        if (!isset($colors[$backColor])) {\\n            $colors[$backColor] = 0;\\n        }\\n\\n        $colors[$frontColor]++;\\n\\n        if ($frontColor != $backColor) {\\n            $colors[$backColor]++;\\n        }\\n    }\\n\\n    $half = $n \/ 2;\\n\\n    foreach ($colors as $colorCount) {\\n        if ($colorCount >= $half) {\\n            return $moves;\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\n$input = '3\\\\n4 7\\\\n4 7\\\\n7 4\\\\n';\\n$output = findMinimumMoves($input);\\necho $output;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nstruct Card\\r\\n{\\r\\n    int front;\\r\\n    int back;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    Card[] cards;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int front, back;\\r\\n        readf(\\\"%d %d\\\", &front, &back);\\r\\n        cards ~= Card(front, back);\\r\\n    }\\r\\n\\r\\n    int[] colors;\\r\\n    foreach (card; cards)\\r\\n    {\\r\\n        colors ~= card.front;\\r\\n    }\\r\\n\\r\\n    int maxCount = 0;\\r\\n    foreach (color; colors.unique)\\r\\n    {\\r\\n        int count = countUntil(colors, color);\\r\\n        if (count >= n \/ 2)\\r\\n        {\\r\\n            maxCount = count;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (maxCount == 0)\\r\\n    {\\r\\n        writeln(-1);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(n - maxCount);\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimum_moves {\n    my ($n, @cards) = @_;\n\n    my %count;\n    foreach my $card (@cards) {\n        my ($front, $back) = split(' ', $card);\n        $count{$front}++;\n    }\n\n    my $half = int($n \/ 2);\n    foreach my $color (keys %count) {\n        if ($count{$color} >= $half) {\n            return 0;\n        }\n    }\n\n    return -1;\n}\n\n# Read input\nmy $n = <>;\nchomp($n);\n\nmy @cards;\nfor (my $i = 0; $i < $n; $i++) {\n    my $card = <>;\n    chomp($card);\n    push @cards, $card;\n}\n\n# Calculate minimum moves\nmy $minimum_moves = minimum_moves($n, @cards);\n\n# Print output\nprint \"$minimum_moves\\\\n\";\n","Rust":"use std::collections::HashMap;\\n\\nfn main() {\\n    let input = \\\"5\\\\n4 7\\\\n7 4\\\\n2 11\\\\n9 7\\\\n1 1\\\\n\\\";\\n    let mut lines = input.lines();\\n    let n: usize = lines.next().unwrap().parse().unwrap();\\n    let mut colors: HashMap<i32, i32> = HashMap::new();\\n\\n    for _ in 0..n {\\n        let line = lines.next().unwrap();\\n        let card: Vec<i32> = line.split_whitespace().map(|x| x.parse().unwrap()).collect();\\n        *colors.entry(card[0]).or_insert(0) += 1;\\n    }\\n\\n    let mut min_moves = std::i32::MAX;\\n\\n    for (_, count) in colors {\\n        let moves = n as i32 - count;\\n        if moves <= min_moves && moves >= 0 && moves <= n as i32 \/ 2 {\\n            min_moves = moves;\\n        }\\n    }\\n\\n    if min_moves == std::i32::MAX {\\n        println!(\\\"-1\\\");\\n    } else {\\n        println!(\\\"{}\\\", min_moves);\\n    }\\n}"}
{"title":"A. Dubstep","description":"Vasya works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.Let's assume that a song consists of some number of words. To make the dubstep remix of this song, Vasya inserts a certain number of words \"WUB\" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including \"WUB\", in one string and plays the song at the club.For example, a song with words \"I AM X\" can transform into a dubstep remix as \"WUBWUBIWUBAMWUBWUBX\" and cannot transform into \"WUBWUBIAMWUBX\".Recently, Petya has heard Vasya's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Vasya remixed. Help Petya restore the original song.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring \"WUB\" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.\n","output_spec":"Print the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.\n","notes":"In the first sample: \"WUBWUBABCWUB\" = \"WUB\" + \"WUB\" + \"ABC\" + \"WUB\". That means that the song originally consisted of a single word \"ABC\", and all words \"WUB\" were added by Vasya.\nIn the second sample Vasya added a single word \"WUB\" between all neighbouring words, in the beginning and in the end, except for words \"ARE\" and \"THE\" \u2014 between them Vasya added two \"WUB\".\n","sample_inputs":["WUBWUBABCWUB\n","WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\n"],"sample_outputs":["ABC ","WE ARE THE CHAMPIONS MY FRIEND "],"id":"208-A","difficulty":900,"tags":["strings"],"src_uid":"edede580da1395fe459a480f6a0a548d","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    string remix;\\n    getline(cin, remix);\\n    string original;\\n    int i = 0;\\n    while (i < remix.length()) {\\n        if (remix[i] == 'W' && remix[i+1] == 'U' && remix[i+2] == 'B') {\\n            i += 3;\\n            if (!original.empty() && original[original.length()-1] != ' ') {\\n                original += ' ';\\n            }\\n        } else {\\n            original += remix[i];\\n            i++;\\n        }\\n    }\\n    cout << original << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class DubstepRemix {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        scanner.close();\\n\\n        String originalSong = input.replaceAll(\\\"(WUB)+\\\", \\\" \\\").trim();\\n\\n        System.out.println(originalSong);\\n    }\\n}","Python":"def restore_song(song):\n    # Replace all occurrences of \"WUB\" with a space\n    song = song.replace('WUB', ' ')\n    \n    # Remove leading and trailing spaces\n    song = song.strip()\n    \n    # Replace multiple spaces with a single space\n    song = ' '.join(song.split())\n    \n    return song","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char remix[201];\\n    fgets(remix, sizeof(remix), stdin);\\n    int len = strlen(remix);\\n    remix[len-1] = '\\\\0'; \/\/ remove newline character\\n    \\n    char original[201];\\n    int originalIndex = 0;\\n    int i = 0;\\n    while (i < len) {\\n        if (remix[i] == 'W' && remix[i+1] == 'U' && remix[i+2] == 'B') {\\n            i += 3;\\n            if (originalIndex > 0 && original[originalIndex-1] != ' ') {\\n                original[originalIndex] = ' ';\\n                originalIndex++;\\n            }\\n        } else {\\n            original[originalIndex] = remix[i];\\n            originalIndex++;\\n            i++;\\n        }\\n    }\\n    original[originalIndex] = '\\\\0';\\n    printf(\\\"%s\\\", original);\\n    \\n    return 0;\\n}","C#":"using System;\n\npublic class DubstepRemix\n{\n    public static string RestoreOriginalSong(string remix)\n    {\n        \/\/ Remove leading and trailing \"WUB\"\n        remix = remix.Trim('W', 'U', 'B');\n        \n        \/\/ Replace all occurrences of \"WUB\" with a space\n        remix = remix.Replace(\"WUB\", \" \");\n        \n        \/\/ Remove extra spaces\n        remix = remix.Replace(\"  \", \" \");\n        \n        return remix;\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string remix1 = \\\"WUBWUBABCWUB\\\";\n        string remix2 = \\\"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\\\";\n        \n        string originalSong1 = DubstepRemix.RestoreOriginalSong(remix1);\n        string originalSong2 = DubstepRemix.RestoreOriginalSong(remix2);\n        \n        Console.WriteLine(originalSong1);\n        Console.WriteLine(originalSong2);\n    }\n}","Ruby":"\ndef restore_song(song)\n  # Remove all occurrences of \"WUB\" and replace them with a space\n  original_song = song.gsub('WUB', ' ')\n\n  # Remove leading and trailing spaces\n  original_song.strip!\n\n  # Replace multiple spaces with a single space\n  original_song.gsub!(\/\\s+\/, ' ')\n\n  return original_song\nend\n\n# Test cases\nputs restore_song('WUBWUBABCWUB') # Output: 'ABC'\nputs restore_song('WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB') # Output: 'WE ARE THE CHAMPIONS MY FRIEND'\n","delphi":"program DubstepRemix;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction RestoreOriginalSong(const remix: string): string;\\nvar\\n  i: Integer;\\n  original: string;\\nbegin\\n  original := remix;\\n  \/\/ Replace all occurrences of 'WUB' with a space\\n  original := StringReplace(original, 'WUB', ' ', [rfReplaceAll]);\\n  \/\/ Remove leading and trailing spaces\\n  original := Trim(original);\\n  \/\/ Replace multiple spaces with a single space\\n  for i := Length(original) downto 2 do\\n  begin\\n    if (original[i] = ' ') and (original[i-1] = ' ') then\\n      Delete(original, i, 1);\\n  end;\\n  Result := original;\\nend;\\n\\nvar\\n  remix: string;\\nbegin\\n  \/\/ Read the input string\\n  ReadLn(remix);\\n  \/\/ Restore the original song\\n  remix := RestoreOriginalSong(remix);\\n  \/\/ Print the result\\n  WriteLn(remix);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar input string\\n\\tfmt.Scan(&input)\\n\\n\\t\/\/ Remove all occurrences of 'WUB'\\n\\toriginalSong := strings.ReplaceAll(input, \\\"WUB\\\", \\\" \\\")\\n\\n\\t\/\/ Remove leading and trailing spaces\\n\\toriginalSong = strings.TrimSpace(originalSong)\\n\\n\\tfmt.Println(originalSong)\\n}","Javascript":"function restoreSong(song) {\n  \/\/ Remove all occurrences of \"WUB\" from the song\n  let originalSong = song.replace(\/WUB\/g, ' ');\n\n  \/\/ Remove leading and trailing spaces\n  originalSong = originalSong.trim();\n\n  \/\/ Replace multiple spaces with a single space\n  originalSong = originalSong.replace(\/\\s+\/g, ' ');\n\n  return originalSong;\n}\n\n\/\/ Test cases\nconsole.log(restoreSong('WUBWUBABCWUB')); \/\/ Output: 'ABC'\nconsole.log(restoreSong('WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB')); \/\/ Output: 'WE ARE THE CHAMPIONS MY FRIEND'","Kotlin":"\"\"\nfun restoreSong(song: String): String {\n    val originalWords = song.replace(\"WUB\", \" \").split(\" \").filter { it.isNotBlank() }\n    return originalWords.joinToString(\" \")\n}\n\nfun main() {\n    val input = readLine()!!\n    val originalSong = restoreSong(input)\n    println(originalSong)\n}\n\"\"","PHP":"\n<?php\n\nfunction restoreSong($remix) {\n    \/\/ Replace \"WUB\" with a space\n    $original = str_replace(\"WUB\", \" \", $remix);\n    \n    \/\/ Remove extra spaces\n    $original = trim(preg_replace('\/\\s+\/', ' ', $original));\n    \n    return $original;\n}\n\n$input = 'WUBWUBABCWUB';\n$output = restoreSong($input);\necho $output;\n\n$input = 'WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB';\n$output = restoreSong($input);\necho $output;\n?>\n","d":"import std.stdio;\\r\\nimport std.string;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string input = readln();\\r\\n    string[] words = input.split(\\\"WUB\\\");\\r\\n    string result = \\\"\\\";\\r\\n\\r\\n    foreach (word; words)\\r\\n    {\\r\\n        if (!word.empty)\\r\\n        {\\r\\n            result ~= word ~ \\\" \\\";\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(result.trim);\\r\\n}","perl":"\n# Read the input string\nmy $input = <STDIN>;\nchomp $input;\n\n# Replace all occurrences of \"WUB\" with a space\n$input =~ s\/WUB\/ \/g;\n\n# Remove leading and trailing spaces\n$input =~ s\/^\\s+|\\s+$\/\/g;\n\n# Print the result\nprint $input;\n","Rust":"\nfn main() {\n    let input = String::from(\\\"WUBWUBABCWUB\\\");\n    let mut output = String::new();\n    let mut word = String::new();\n    let mut is_word = false;\n\n    for c in input.chars() {\n        if c == 'W' && !is_word {\n            is_word = true;\n        } else if c == 'U' && is_word {\n            is_word = false;\n        } else if c == 'B' && is_word {\n            is_word = false;\n            if !word.is_empty() {\n                output.push_str(&word);\n                output.push(' ');\n                word.clear();\n            }\n        } else {\n            if is_word {\n                word.push(c);\n            } else {\n                output.push(c);\n            }\n        }\n    }\n\n    println!(\"{}\", output);\n}\n"}
{"title":"B. Solitaire","description":"A boy named Vasya wants to play an old Russian solitaire called \"Accordion\". In this solitaire, the player must observe the following rules:  A deck of n cards is carefully shuffled, then all n cards are put on the table in a line from left to right;  Before each move the table has several piles of cards lying in a line (initially there are n piles, each pile has one card). Let's number the piles from left to right, from 1 to x. During one move, a player can take the whole pile with the maximum number x (that is the rightmost of remaining) and put it on the top of pile x-1 (if it exists) or on the top of pile x-3 (if it exists). The player can put one pile on top of another one only if the piles' top cards have the same suits or values. Please note that if pile x goes on top of pile y, then the top card of pile x becomes the top card of the resulting pile. Also note that each move decreases the total number of piles by 1;  The solitaire is considered completed if all cards are in the same pile. Vasya has already shuffled the cards and put them on the table, help him understand whether completing this solitaire is possible or not. ","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains a single integer n (1\u2264n\u226452) \u2014 the number of cards in Vasya's deck. The next line contains n space-separated strings c1,c2,...,cn, where string ci describes the i-th card on the table. Each string ci consists of exactly two characters, the first one represents the card's value, the second one represents its suit. Cards on the table are numbered from left to right. \nA card's value is specified by one of these characters: \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"T\", \"J\", \"Q\", \"K\", \"A\". A card's suit is specified by one of these characters: \"S\", \"D\", \"H\", \"C\".\nIt is not guaranteed that the deck has all possible cards. Also, the cards in Vasya's deck can repeat.\n","output_spec":"On a single line print the answer to the problem: string \"YES\" (without the quotes) if completing the solitaire is possible, string \"NO\" (without the quotes) otherwise.\n","notes":"In the first sample you can act like that: \n  put the 4-th pile on the 1-st one;  put the 3-rd pile on the 2-nd one;  put the 2-nd pile on the 1-st one. In the second sample there is no way to complete the solitaire.\n","sample_inputs":["4\n2S 2S 2C 2C\n","2\n3S 2C\n"],"sample_outputs":["YES\n","NO\n"],"id":"208-B","difficulty":1900,"tags":["dfs+and+similar","dp"],"src_uid":"1805771e194d323edacf2526a1eb6768","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool canCompleteSolitaire(int n, vector<string>& cards) {\\n    vector<vector<string>> piles(n);\\n    piles[0].push_back(cards[0]);\\n    for (int i = 1; i < n; i++) {\\n        piles[i].push_back(cards[i]);\\n        if (i >= 3 && (piles[i-3].back()[0] == piles[i].back()[0] || piles[i-3].back()[1] == piles[i].back()[1])) {\\n            piles[i-3].push_back(piles[i].back());\\n            piles[i].pop_back();\\n            if (piles[i].empty()) {\\n                piles.erase(piles.begin() + i);\\n                n--;\\n                i--;\\n            }\\n        } else if (piles[i-1].back()[0] == piles[i].back()[0] || piles[i-1].back()[1] == piles[i].back()[1]) {\\n            piles[i-1].push_back(piles[i].back());\\n            piles[i].pop_back();\\n            if (piles[i].empty()) {\\n                piles.erase(piles.begin() + i);\\n                n--;\\n                i--;\\n            }\\n        }\\n    }\\n    return piles.size() == 1;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<string> cards(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> cards[i];\\n    }\\n    if (canCompleteSolitaire(n, cards)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class AccordionSolitaire {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        String[] cards = scanner.nextLine().split(\" \");\n        \n        boolean possible = isSolitairePossible(n, cards);\n        \n        if (possible) {\n            System.out.println(\\\"YES\\\");\n        } else {\n            System.out.println(\\\"NO\\\");\n        }\n    }\n    \n    public static boolean isSolitairePossible(int n, String[] cards) {\n        Stack<String> piles = new Stack<>();\n        \n        for (String card : cards) {\n            if (piles.isEmpty()) {\n                piles.push(card);\n            } else {\n                String topCard = piles.peek();\n                if (topCard.charAt(0) == card.charAt(0) || topCard.charAt(1) == card.charAt(1)) {\n                    piles.push(card);\n                } else {\n                    while (!piles.isEmpty() && (piles.peek().charAt(0) != card.charAt(0) && piles.peek().charAt(1) != card.charAt(1))) {\n                        piles.pop();\n                    }\n                    if (!piles.isEmpty()) {\n                        piles.push(card);\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n}","Python":"def is_solitaire_possible(n, cards):\\n    piles = [cards[0]]\\n    for i in range(1, n):\\n        if piles and (cards[i][0] == piles[-1][0] or cards[i][1] == piles[-1][1]):\\n            piles.pop()\\n        else:\\n            piles.append(cards[i])\\n    return 'YES' if len(piles) == 1 else 'NO'\\n\\nn = int(input())\\ncards = input().split()\\nprint(is_solitaire_possible(n, cards))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    char cards[n][3];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s\\\", cards[i]);\\n    }\\n\\n    int piles = n;\\n    int top = n - 1;\\n    int completed = 0;\\n\\n    while (piles > 1) {\\n        int x = top;\\n        int y = top - 1;\\n        int z = top - 3;\\n\\n        if (y >= 0 && (cards[x][0] == cards[y][0] || cards[x][1] == cards[y][1])) {\\n            top--;\\n            piles--;\\n        } else if (z >= 0 && (cards[x][0] == cards[z][0] || cards[x][1] == cards[z][1])) {\\n            top -= 3;\\n            piles--;\\n        } else {\\n            completed = 1;\\n            break;\\n        }\\n    }\\n\\n    if (completed) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace AccordionSolitaire\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            string[] cards = Console.ReadLine().Split();\n\n            bool possible = IsSolitairePossible(n, cards);\n            Console.WriteLine(possible ? \\\"YES\\\" : \\\"NO\\\");\n        }\n\n        static bool IsSolitairePossible(int n, string[] cards)\n        {\n            Stack<string> piles = new Stack<string>();\n\n            foreach (string card in cards)\n            {\n                if (piles.Count >= 2 && (card[0] == piles.Peek()[0] || card[1] == piles.Peek()[1]))\n                {\n                    piles.Pop();\n                }\n                else if (piles.Count >= 4 && (card[0] == piles.ToArray()[2][0] || card[1] == piles.ToArray()[2][1]))\n                {\n                    piles.Pop();\n                    piles.Pop();\n                    piles.Pop();\n                }\n\n                piles.Push(card);\n            }\n\n            return piles.Count == 1;\n        }\n    }\n}\n","Ruby":"\ndef can_complete_solitaire(n, cards)\n  piles = []\n  cards.each do |card|\n    if piles.empty? || piles.last[0] != card[0] && piles.last[1] != card[1]\n      piles << card\n    else\n      piles.pop\n    end\n  end\n\n  piles.size == 1 ? 'YES' : 'NO'\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\ncards = input[1].split(' ')\n\nputs can_complete_solitaire(n, cards)\n","delphi":"program AccordionSolitaire;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction CanCompleteSolitaire(n: Integer; cards: array of string): string;\\nvar\\n  piles: array of string;\\n  i: Integer;\\nbegin\\n  SetLength(piles, n);\\n  for i := 0 to n-1 do\\n    piles[i] := cards[i];\\n  for i := n-1 downto 1 do\\n  begin\\n    if (i >= 3) and ((piles[i][1] = piles[i-1][1]) or (piles[i][2] = piles[i-1][2])) then\\n      piles[i-1] := piles[i]\\n    else if (piles[i][1] = piles[i-3][1]) or (piles[i][2] = piles[i-3][2]) then\\n      piles[i-3] := piles[i]\\n    else\\n    begin\\n      Result := 'NO';\\n      Exit;\\n    end;\\n  end;\\n  Result := 'YES';\\nend;\\n\\nvar\\n  n, i: Integer;\\n  cards: array of string;\\nbegin\\n  ReadLn(n);\\n  SetLength(cards, n);\\n  for i := 0 to n-1 do\\n    Read(cards[i]);\\n  WriteLn(CanCompleteSolitaire(n, cards));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn := scanner.Text()\\n\\n\\tscanner.Scan()\\n\\tcards := scanner.Text()\\n\\n\\tif isSolitairePossible(n, cards) {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}\\n\\nfunc isSolitairePossible(n string, cards string) bool {\\n\\tpiles := strings.Split(cards, \\\" \\\")\\n\\n\\tfor i := 1; i < len(piles); i++ {\\n\\t\\tif i >= 3 && (piles[i] == piles[i-3] || piles[i] == piles[i-1]) {\\n\\t\\t\\tpiles[i-1] = piles[i]\\n\\t\\t\\tpiles = append(piles[:i], piles[i+1:]..","Javascript":"function isSolitairePossible(n, cards) {\n    let piles = [];\n    for (let i = 0; i < n; i++) {\n        piles.push([cards[i]]);\n    }\n    \n    while (piles.length > 1) {\n        let x = piles.length - 1;\n        let y = piles.length - 2;\n        let z = piles.length - 4;\n        \n        if (z >= 0 && (piles[x][0][0] === piles[z][0][0] || piles[x][0][1] === piles[z][0][1])) {\n            piles[z] = piles[z].concat(piles[x]);\n            piles.pop();\n        } else if (y >= 0 && (piles[x][0][0] === piles[y][0][0] || piles[x][0][1] === piles[y][0][1])) {\n            piles[y] = piles[y].concat(piles[x]);\n            piles.pop();\n        } else {\n            return 'NO';\n        }\n    }\n    \n    return 'YES';\n}\n\nlet input = '4\\n2S 2S 2C 2C\\n';\nlet lines = input.trim().split('\\n');\nlet n = parseInt(lines[0]);\nlet cards = lines[1].split(' ');\n\nlet result = isSolitairePossible(n, cards);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val cards = sc.nextLine().trim().split(\" \")\n    \n    val piles = ArrayDeque<String>()\n    for (card in cards) {\n        piles.add(card)\n    }\n    \n    var possible = true\n    while (piles.size > 1) {\n        val topCard = piles.removeLast()\n        val secondTopCard = piles.peekLast()\n        \n        if (topCard[0] == secondTopCard[0] || topCard[1] == secondTopCard[1]) {\n            piles.removeLast()\n            piles.addLast(topCard)\n        } else if (piles.size >= 3) {\n            val thirdTopCard = piles[piles.size - 3]\n            \n            if (topCard[0] == thirdTopCard[0] || topCard[1] == thirdTopCard[1]) {\n                piles.removeLast()\n                piles.removeLast()\n                piles.addLast(topCard)\n            } else {\n                possible = false\n                break\n            }\n        } else {\n            possible = false\n            break\n        }\n    }\n    \n    if (possible) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"\n<?php\n\nfunction canCompleteSolitaire($n, $cards) {\n    $piles = [];\n    \n    \/\/ Initialize the piles with one card each\n    for ($i = 0; $i < $n; $i++) {\n        $piles[] = [$cards[$i]];\n    }\n    \n    \/\/ Iterate through the piles and try to merge them\n    for ($i = $n - 1; $i > 0; $i--) {\n        $currentPile = $piles[$i];\n        $previousPile = $piles[$i - 1];\n        \n        \/\/ Check if the top cards have the same suit or value\n        if ($currentPile[0][0] == $previousPile[0][0] || $currentPile[0][1] == $previousPile[0][1]) {\n            \/\/ Merge the piles\n            $piles[$i - 1] = array_merge($currentPile, $previousPile);\n            unset($piles[$i]);\n        }\n    }\n    \n    \/\/ Check if all cards are in the same pile\n    return count($piles) == 1 ? 'YES' : 'NO';\n}\n\n\/\/ Read the input\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\n$n = intval($input[0]);\n$cards = explode(' ', $input[1]);\n\n\/\/ Call the function and print the result\n$result = canCompleteSolitaire($n, $cards);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.string;\\r\\n\\r\\nbool canCompleteSolitaire(int n, string[] cards) {\\r\\n    if (n == 1) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    string[] piles;\\r\\n    piles ~= cards[0];\\r\\n\\r\\n    for (int i = 1; i < n; i++) {\\r\\n        string currentCard = cards[i];\\r\\n        bool placed = false;\\r\\n\\r\\n        for (int j = piles.length - 1; j >= 0; j--) {\\r\\n            string topCard = piles[j];\\r\\n\\r\\n            if (currentCard[0] == topCard[0] || currentCard[1] == topCard[1]) {\\r\\n                piles[j] = currentCard;\\r\\n                placed = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!placed) {\\r\\n            piles ~= currentCard;\\r\\n        }\\r\\n\\r\\n        if (piles.length == 1) {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    string[] cards;\\r\\n\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    string line;\\r\\n    readf(\\\"%s\\\", &line);\\r\\n    cards = line.split(\\\" \\\");\\r\\n\\r\\n    bool result = canCompleteSolitaire(n, cards);\\r\\n\\r\\n    if (result) {\\r\\n        writeln(\\\"YES\\\");\\r\\n    } else {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub can_complete_solitaire {\n    my ($n, @cards) = @_;\n\n    my @piles = ();\n    push @piles, [$cards[0]];\n\n    for (my $i = 1; $i < $n; $i++) {\n        my $card = $cards[$i];\n        my $top_card = $piles[-1][-1];\n\n        if ($card =~ \/$top_card\/) {\n            push @{$piles[-1]}, $card;\n        } else {\n            my $found = 0;\n            for (my $j = $#piles - 1; $j >= 0; $j--) {\n                if ($card =~ \/$piles[$j][-1]\/) {\n                    push @{$piles[$j]}, $card;\n                    $found = 1;\n                    last;\n                }\n            }\n            if (!$found) {\n                push @piles, [$card];\n            }\n        }\n    }\n\n    return scalar @piles == 1 ? 'YES' : 'NO';\n}\n\nmy $n = <>;\nchomp $n;\n\nmy $cards = <>;\nchomp $cards;\nmy @cards = split ' ', $cards;\n\nmy $result = can_complete_solitaire($n, @cards);\nprint $result;\n","Rust":"\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let cards: Vec<String> = lines.next().unwrap().split_whitespace().map(|x| x.to_string()).collect();\n    \n    let mut piles: Vec<Vec<String>> = vec![vec![]; n];\n    for i in 0..n {\n        piles[i].push(cards[i].clone());\n    }\n    \n    let mut possible = true;\n    while piles.len() > 1 {\n        let x = piles.len() - 1;\n        let top_card = piles[x].last().unwrap().clone();\n        \n        if x >= 1 && (piles[x-1].last().unwrap().chars().next().unwrap() == top_card.chars().next().unwrap() || piles[x-1].last().unwrap().chars().nth(1).unwrap() == top_card.chars().nth(1).unwrap()) {\n            piles[x-1].push(piles[x].pop().unwrap());\n        } else if x >= 3 && (piles[x-3].last().unwrap().chars().next().unwrap() == top_card.chars().next().unwrap() || piles[x-3].last().unwrap().chars().nth(1).unwrap() == top_card.chars().nth(1).unwrap()) {\n            piles[x-3].push(piles[x].pop().unwrap());\n        } else {\n            possible = false;\n            break;\n        }\n        \n        if piles[x].is_empty() {\n            piles.pop();\n        }\n    }\n    \n    if possible {\n        println!(\\\"YES\\\");\n    } else {\n        println!(\\\"NO\\\");\n    }\n}\n"}
{"title":"D. Prizes, Prizes, more Prizes","description":"Vasya, like many others, likes to participate in a variety of sweepstakes and lotteries. Now he collects wrappings from a famous chocolate bar \"Jupiter\". According to the sweepstake rules, each wrapping has an integer written on it \u2014 the number of points that the participant adds to his score as he buys the bar. After a participant earns a certain number of points, he can come to the prize distribution center and exchange the points for prizes. When somebody takes a prize, the prize's cost is simply subtracted from the number of his points.Vasya didn't only bought the bars, he also kept a record of how many points each wrapping cost. Also, he remembers that he always stucks to the greedy strategy \u2014 as soon as he could take at least one prize, he went to the prize distribution centre and exchanged the points for prizes. Moreover, if he could choose between multiple prizes, he chose the most expensive one. If after an exchange Vasya had enough points left to get at least one more prize, then he continued to exchange points.The sweepstake has the following prizes (the prizes are sorted by increasing of their cost):   a mug (costs a points),  a towel (costs b points),  a bag (costs c points),  a bicycle (costs d points),  a car (costs e points). Now Vasya wants to recollect what prizes he has received. You know sequence p1,p2,...,pn, where pi is the number of points Vasya got for the i-th bar. The sequence of points is given in the chronological order. You also know numbers a, b, c, d, e. Your task is to find, how many prizes Vasya received, what prizes they are and how many points he's got left after all operations are completed.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer n (1\u2264n\u226450) \u2014 the number of chocolate bar wrappings that brought points to Vasya. The second line contains space-separated integers p1,p2,...,pn (1\u2264pi\u226410^9). The third line contains 5 integers a, b, c, d, e (1\u2264a<b<c<d<e\u226410^9) \u2014 the prizes' costs.\n","output_spec":"Print on the first line 5 integers, separated by a space \u2014 the number of mugs, towels, bags, bicycles and cars that Vasya has got, respectively. On the second line print a single integer \u2014 the number of points Vasya will have left after all operations of exchange are completed.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.\n","notes":"In the first sample Vasya gets 3 points after eating the first chocolate bar. Then he exchanges 2 points and gets a mug. Vasya wins a bag after eating the second chocolate bar. Then he wins a towel after eating the third chocolate bar. After all chocolate bars 3-2+10-10+4-4=1 points remains.\n","sample_inputs":["3\n3 10 4\n2 4 10 15 20\n","4\n10 4 39 2\n3 5 10 11 12\n"],"sample_outputs":["1 1 1 0 0 \n1\n","3 0 1 0 3 \n0\n"],"id":"208-D","difficulty":1200,"tags":["implementation"],"src_uid":"1ae2942b72ebb7c55359c41e141900d7","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> points(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> points[i];\\n    }\\n    vector<int> prizes(5);\\n    for (int i = 0; i < 5; i++) {\\n        cin >> prizes[i];\\n    }\\n    vector<int> counts(5);\\n    int remainingPoints = 0;\\n    for (int i = 0; i < n; i++) {\\n        remainingPoints += points[i];\\n        for (int j = 4; j >= 0; j--) {\\n            int numPrizes = remainingPoints \/ prizes[j];\\n            counts[j] += numPrizes;\\n            remainingPoints -= numPrizes * prizes[j];\\n        }\\n    }\\n    for (int i = 0; i < 5; i++) {\\n        cout << counts[i] << \\\" \\\";\\n    }\\n    cout << endl;\\n    cout << remainingPoints << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] points = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            points[i] = scanner.nextInt();\\n        }\\n        int[] prizes = new int[5];\\n        for (int i = 0; i < 5; i++) {\\n            prizes[i] = scanner.nextInt();\\n        }\\n        int[] count = new int[5];\\n        int remainingPoints = 0;\\n        for (int i = 0; i < n; i++) {\\n            remainingPoints += points[i];\\n            for (int j = 4; j >= 0; j--) {\\n                int numPrizes = remainingPoints \/ prizes[j];\\n                count[j] += numPrizes;\\n                remainingPoints -= numPrizes * prizes[j];\\n            }\\n        }\\n        for (int i = 0; i < 5; i++) {\\n            System.out.print(count[i] + \\\" \\\");\\n        }\\n        System.out.println();\\n        System.out.println(remainingPoints);\\n    }\\n}","Python":"n = int(input())\\npoints = list(map(int, input().split()))\\nprizes = list(map(int, input().split()))\\n\\nmugs = 0\\ntowels = 0\\nbags = 0\\nbicycles = 0\\ncars = 0\\n\\nremaining_points = 0\\n\\nfor point in points:\\n    remaining_points += point\\n    while remaining_points >= prizes[0]:\\n        if remaining_points >= prizes[4]:\\n            cars += 1\\n            remaining_points -= prizes[4]\\n        elif remaining_points >= prizes[3]:\\n            bicycles += 1\\n            remaining_points -= prizes[3]\\n        elif remaining_points >= prizes[2]:\\n            bags += 1\\n            remaining_points -= prizes[2]\\n        elif remaining_points >= prizes[1]:\\n            towels += 1\\n            remaining_points -= prizes[1]\\n        elif remaining_points >= prizes[0]:\\n            mugs += 1\\n            remaining_points -= prizes[0]\\n\\nprint(mugs, towels, bags, bicycles, cars)\\nprint(remaining_points)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int points[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &points[i]);\\n    }\\n    int prizes[5];\\n    for (int i = 0; i < 5; i++) {\\n        scanf(\\\"%d\\\", &prizes[i]);\\n    }\\n\\n    int count[5] = {0};\\n    int remainingPoints = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        remainingPoints += points[i];\\n\\n        for (int j = 4; j >= 0; j--) {\\n            int numPrizes = remainingPoints \/ prizes[j];\\n            count[j] += numPrizes;\\n            remainingPoints -= numPrizes * prizes[j];\\n        }\\n    }\\n\\n    for (int i = 0; i < 5; i++) {\\n        printf(\\\"%d \\\", count[i]);\\n    }\\n    printf(\\\"\\\\n%d\\\\n\\\", remainingPoints);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace Sweepstakes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            string[] pointsStr = Console.ReadLine().Split(' ');\n            int[] points = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                points[i] = int.Parse(pointsStr[i]);\n            }\n\n            string[] prizesStr = Console.ReadLine().Split(' ');\n            int[] prizes = new int[5];\n            for (int i = 0; i < 5; i++)\n            {\n                prizes[i] = int.Parse(prizesStr[i]);\n            }\n\n            int[] count = new int[5];\n            int remainingPoints = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                remainingPoints += points[i];\n                for (int j = 4; j >= 0; j--)\n                {\n                    int numPrizes = remainingPoints \/ prizes[j];\n                    count[j] += numPrizes;\n                    remainingPoints -= numPrizes * prizes[j];\n                }\n            }\n\n            Console.WriteLine(string.Join(\" \", count));\n            Console.WriteLine(remainingPoints);\n        }\n    }\n}","Ruby":"\ndef calculate_prizes(n, points, costs)\n  prizes = [0, 0, 0, 0, 0] # Initialize the count of each prize to 0\n  remaining_points = 0 # Initialize the remaining points to 0\n\n  # Iterate through each point and check if it can be exchanged for a prize\n  points.each do |point|\n    remaining_points += point # Add the current point to the remaining points\n\n    # Check if there are enough points to exchange for each prize in reverse order\n    if remaining_points >= costs[4]\n      prizes[4] += 1 # Increment the count of cars\n      remaining_points -= costs[4] # Subtract the cost of the car from the remaining points\n    elsif remaining_points >= costs[3]\n      prizes[3] += 1 # Increment the count of bicycles\n      remaining_points -= costs[3] # Subtract the cost of the bicycle from the remaining points\n    elsif remaining_points >= costs[2]\n      prizes[2] += 1 # Increment the count of bags\n      remaining_points -= costs[2] # Subtract the cost of the bag from the remaining points\n    elsif remaining_points >= costs[1]\n      prizes[1] += 1 # Increment the count of towels\n      remaining_points -= costs[1] # Subtract the cost of the towel from the remaining points\n    elsif remaining_points >= costs[0]\n      prizes[0] += 1 # Increment the count of mugs\n      remaining_points -= costs[0] # Subtract the cost of the mug from the remaining points\n    end\n  end\n\n  # Return the count of each prize and the remaining points as a formatted string\n  return \\\"#{prizes.join(' ')} \\\\n#{remaining_points}\\\\n\\\"\nend\n\n# Read the input values\nn = gets.to_i\npoints = gets.split.map(&:to_i)\ncosts = gets.split.map(&:to_i)\n\n# Call the calculate_prizes method and print the result\nputs calculate_prizes(n, points, costs)\n","delphi":"program Sweepstakes;\\n\\nvar\\n  n, i, a, b, c, d, e, pointsLeft: integer;\\n  p: array[1..50] of integer;\\n  prizes: array[1..5] of integer;\\n  numPrizes: array[1..5] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(p[i]);\\n  readln;\\n  readln(a, b, c, d, e);\\n\\n  pointsLeft := 0;\\n  for i := 1 to n do\\n  begin\\n    pointsLeft := pointsLeft + p[i];\\n\\n    if pointsLeft >= e then\\n    begin\\n      numPrizes[5] := numPrizes[5] + 1;\\n      pointsLeft := pointsLeft - e;\\n    end\\n    else if pointsLeft >= d then\\n    begin\\n      numPrizes[4] := numPrizes[4] + 1;\\n      pointsLeft := pointsLeft - d;\\n    end\\n    else if pointsLeft >= c then\\n    begin\\n      numPrizes[3] := numPrizes[3] + 1;\\n      pointsLeft := pointsLeft - c;\\n    end\\n    else if pointsLeft >= b then\\n    begin\\n      numPrizes[2] := numPrizes[2] + 1;\\n      pointsLeft := pointsLeft - b;\\n    end\\n    else if pointsLeft >= a then\\n    begin\\n      numPrizes[1] := numPrizes[1] + 1;\\n      pointsLeft := pointsLeft - a;\\n    end;\\n  end;\\n\\n  writeln(numPrizes[1], ' ', numPrizes[2], ' ', numPrizes[3], ' ', numPrizes[4], ' ', numPrizes[5]);\\n  writeln(pointsLeft);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tnumbers := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&numbers[i])\\n\\t}\\n\\n\\tprizes := make([]int, 5)\\n\\tfor i := 0; i < 5; i++ {\\n\\t\\tfmt.Scan(&prizes[i])\\n\\t}\\n\\n\\tsort.Ints(prizes)\\n\\n\\tcounts := make([]int, 5)\\n\\tremainingPoints := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tremainingPoints += numbers[i]\\n\\n\\t\\tfor j := 4; j >= 0; j-- {\\n\\t\\t\\tif remainingPoints >= prizes[j] {\\n\\t\\t\\t\\tcounts[j]++\\n\\t\\t\\t\\tremainingPoints -= prizes[j]\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < 5; i++ {\\n\\t\\tfmt.Printf(\\\"%d \\\", counts[i])\\n\\t}\\n\\tfmt.Printf(\\\"\\\\n%d\\\\n\\\", remainingPoints)\\n}","Javascript":"\nfunction calculatePrizes(n, points, costs) {\n  let prizes = [0, 0, 0, 0, 0];\n  let remainingPoints = 0;\n\n  for (let i = 0; i < n; i++) {\n    remainingPoints += points[i];\n\n    for (let j = 4; j >= 0; j--) {\n      let numPrizes = Math.floor(remainingPoints \/ costs[j]);\n      prizes[j] += numPrizes;\n      remainingPoints -= numPrizes * costs[j];\n    }\n  }\n\n  return prizes.join(' ') + ' \\\\n' + remainingPoints;\n}\n\n\/\/ Read input\nconst input = require('fs').readFileSync(0, 'utf-8').trim().split('\\\\n');\nconst n = parseInt(input[0]);\nconst points = input[1].split(' ').map(Number);\nconst costs = input[2].split(' ').map(Number);\n\n\/\/ Calculate prizes and remaining points\nconst result = calculatePrizes(n, points, costs);\n\n\/\/ Print result\nconsole.log(result);\n","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val points = IntArray(n)\n    for (i in 0 until n) {\n        points[i] = scanner.nextInt()\n    }\n    val prizes = IntArray(5)\n    for (i in 0 until 5) {\n        prizes[i] = scanner.nextInt()\n    }\n    val result = calculatePrizes(points, prizes)\n    println(result.prizes.joinToString(\" \"))\n    println(result.remainingPoints)\n}\n\ndata class PrizeResult(val prizes: IntArray, val remainingPoints: Int)\n\nfun calculatePrizes(points: IntArray, prizes: IntArray): PrizeResult {\n    val prizeCounts = IntArray(5)\n    var remainingPoints = 0\n    var currentPoints = 0\n    for (point in points) {\n        currentPoints += point\n        for (i in 4 downTo 0) {\n            val count = currentPoints \/ prizes[i]\n            prizeCounts[i] += count\n            currentPoints -= count * prizes[i]\n        }\n        remainingPoints = currentPoints\n    }\n    return PrizeResult(prizeCounts, remainingPoints)\n}","PHP":"\n<?php\n\nfunction calculatePrizes($n, $points, $costs) {\n    $prizes = [0, 0, 0, 0, 0];\n    $remainingPoints = 0;\n    \n    foreach ($points as $point) {\n        $remainingPoints += $point;\n        \n        for ($i = 4; $i >= 0; $i--) {\n            $numPrizes = floor($remainingPoints \/ $costs[$i]);\n            $prizes[$i] += $numPrizes;\n            $remainingPoints -= $numPrizes * $costs[$i];\n        }\n    }\n    \n    return $prizes;\n}\n\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\n$n = intval($input[0]);\n$points = array_map('intval', explode(\\\" \\\", $input[1]));\n$costs = array_map('intval', explode(\\\" \\\", $input[2]));\n\n$prizes = calculatePrizes($n, $points, $costs);\n\n$output = implode(\\\" \\\", $prizes) . \\\"\\\\n\\\" . $remainingPoints . \\\"\\\\n\\\";\necho $output;\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] points;\\r\\n    int[] prizes;\\r\\n    int[] numPrizes = [0, 0, 0, 0, 0];\\r\\n    int remainingPoints;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    points = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &points[i]);\\r\\n    }\\r\\n    prizes = new int[5];\\r\\n    foreach (i; 0..5)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &prizes[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Sort the prizes in descending order\\r\\n    prizes.sort!((a, b) => a > b);\\r\\n\\r\\n    \/\/ Iterate through the points and exchange for prizes\\r\\n    foreach (point; points)\\r\\n    {\\r\\n        foreach (i; 0..5)\\r\\n        {\\r\\n            if (point >= prizes[i])\\r\\n            {\\r\\n                numPrizes[i]++;\\r\\n                point -= prizes[i];\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the number of prizes\\r\\n    foreach (num; numPrizes)\\r\\n    {\\r\\n        writef(\\\"%d \\\", num);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate the remaining points\\r\\n    remainingPoints = points.reduce!((a, b) => a + b);\\r\\n\\r\\n    \/\/ Print the remaining points\\r\\n    writeln();\\r\\n    writeln(remainingPoints);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_prizes {\n    my ($n, $points, $costs) = @_;\n\n    my ($a, $b, $c, $d, $e) = @$costs;\n\n    my ($mugs, $towels, $bags, $bicycles, $cars) = (0, 0, 0, 0, 0);\n    my $remaining_points = 0;\n\n    foreach my $point (@$points) {\n        if ($point >= $e) {\n            $cars++;\n            $remaining_points += $point - $e;\n        } elsif ($point >= $d) {\n            $bicycles++;\n            $remaining_points += $point - $d;\n        } elsif ($point >= $c) {\n            $bags++;\n            $remaining_points += $point - $c;\n        } elsif ($point >= $b) {\n            $towels++;\n            $remaining_points += $point - $b;\n        } elsif ($point >= $a) {\n            $mugs++;\n            $remaining_points += $point - $a;\n        }\n    }\n\n    return [$mugs, $towels, $bags, $bicycles, $cars], $remaining_points;\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy $points = [split ' ', <>];\nmy $costs = [split ' ', <>];\n\n# Calculate prizes and remaining points\nmy ($prizes, $remaining_points) = calculate_prizes($n, $points, $costs);\n\n# Print output\nprint join(' ', @$prizes), \\\"\\\\n\\\";\nprint $remaining_points, \\\"\\\\n\\\";\n\n","Rust":"\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let points: Vec<u64> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let prizes: Vec<u64> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut remaining_points = 0;\n    let mut prizes_count = vec![0; 5];\n    \n    for point in points {\n        remaining_points += point;\n        \n        for i in (0..5).rev() {\n            let prize_cost = prizes[i];\n            let prize_count = remaining_points \/ prize_cost;\n            \n            prizes_count[i] += prize_count;\n            remaining_points -= prize_count * prize_cost;\n        }\n    }\n    \n    let output = prizes_count.into_iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\" \");\n    println!(\"{}\", output);\n    println!(\"{}\", remaining_points);\n}\n"}
{"title":"A. Multicolored Marbles","description":"Polycarpus plays with red and blue marbles. He put n marbles from the left to the right in a row. As it turned out, the marbles form a zebroid.A non-empty sequence of red and blue marbles is a zebroid, if the colors of the marbles in this sequence alternate. For example, sequences (red; blue; red) and (blue) are zebroids and sequence (red; red) is not a zebroid.Now Polycarpus wonders, how many ways there are to pick a zebroid subsequence from this sequence. Help him solve the problem, find the number of ways modulo 1000000007 (10^9+7).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer n (1\u2264n\u226410^6) \u2014 the number of marbles in Polycarpus's sequence.\n","output_spec":"Print a single number \u2014 the answer to the problem modulo 1000000007 (10^9+7).\n","notes":"Let's consider the first test sample. Let's assume that Polycarpus initially had sequence (red; blue; red), so there are six ways to pick a zebroid: \n  pick the first marble;  pick the second marble;  pick the third marble;  pick the first and second marbles;  pick the second and third marbles;  pick the first, second and third marbles. It can be proven that if Polycarpus picks (blue; red; blue) as the initial sequence, the number of ways won't change.\n","sample_inputs":["3\n","4\n"],"sample_outputs":["6\n","11\n"],"id":"209-A","difficulty":1600,"tags":["dp","math"],"src_uid":"5c4bd12df3915186a7b506c2060db125","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> dp(n + 1);\\n    dp[1] = 2;\\n    dp[2] = 3;\\n    for (int i = 3; i <= n; i++) {\\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\\n    }\\n    cout << dp[n] << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ZebroidMarbles {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.close();\\n\\n        long[] dp = new long[n + 1];\\n        dp[1] = 2;\\n        dp[2] = 3;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\\n        }\\n\\n        System.out.println(dp[n]);\\n    }\\n}\" }","Python":"def count_zebroids(n):\\n    dp = [0] * (n + 1)\\n    dp[1] = 2\\n    dp[2] = 3\\n\\n    for i in range(3, n + 1):\\n        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\\n\\n    return dp[n]\\n\\nn = int(input())\\nresult = count_zebroids(n)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    \\n    int dp[n+1];\\n    dp[0] = 1;\\n    dp[1] = 2;\\n    \\n    for(int i=2; i<=n; i++) {\\n        dp[i] = (dp[i-1] + dp[i-2]) % 1000000007;\\n    }\\n    \\n    printf(\\\"%d\\\\n\\\", dp[n]);\\n    \\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        \n        \/\/ Initialize the variables to store the number of ways to pick a zebroid\n        long[] dp = new long[n + 1];\n        long[] prefixSum = new long[n + 1];\n        \n        \/\/ Base cases\n        dp[1] = 1;\n        prefixSum[1] = 1;\n        \n        \/\/ Calculate the number of ways to pick a zebroid for each length\n        for (int i = 2; i <= n; i++)\n        {\n            dp[i] = (dp[i - 1] + prefixSum[i - 2] + 1) % 1000000007;\n            prefixSum[i] = (prefixSum[i - 1] + dp[i]) % 1000000007;\n        }\n        \n        \/\/ Print the result\n        Console.WriteLine(dp[n]);\n    }\n}","Ruby":"\nMOD = 1000000007\n\ndef zebroid_subsequence(n)\n  dp = Array.new(n+1, 0)\n  dp[1] = 2\n  dp[2] = 3\n\n  (3..n).each do |i|\n    dp[i] = (dp[i-1] + dp[i-2]) % MOD\n  end\n\n  return dp[n]\nend\n\nn = gets.to_i\nresult = zebroid_subsequence(n)\nputs result\n","delphi":"var\\n  n, i: integer;\\n  ans: int64;\\nbegin\\n  readln(n);\\n  ans := 1;\\n  for i := 1 to n do\\n    ans := (ans * 2) mod 1000000007;\\n  writeln(ans);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\t\/\/ Initialize the dp array\\n\\tdp := make([]int, n+1)\\n\\tdp[1] = 2\\n\\tdp[2] = 3\\n\\n\\t\/\/ Calculate the number of ways to pick a zebroid subsequence\\n\\tfor i := 3; i <= n; i++ {\\n\\t\\tdp[i] = (dp[i-1] + dp[i-2]) % 1000000007\\n\\t}\\n\\n\\t\/\/ Print the result\\n\\tfmt.Println(dp[n])\\n}","Javascript":"function countZebroidSubsequences(n) {\n    let dp = new Array(n + 1).fill(0);\n    let mod = 1000000007;\n    \n    dp[1] = 2;\n    dp[2] = 3;\n    \n    for (let i = 3; i <= n; i++) {\n        dp[i] = (dp[i - 1] + dp[i - 2]) % mod;\n    }\n    \n    return dp[n];\n}\n\nlet n = parseInt(readline());\nlet result = countZebroidSubsequences(n);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val mod = 1000000007\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    \n    \/\/ Initialize the arrays to store the number of ways to pick a zebroid subsequence\n    val dpRed = LongArray(n)\n    val dpBlue = LongArray(n)\n    \n    \/\/ Read the colors of the marbles\n    val colors = IntArray(n)\n    for (i in 0 until n) {\n        colors[i] = scanner.nextInt()\n    }\n    \n    \/\/ Calculate the number of ways to pick a zebroid subsequence\n    for (i in 0 until n) {\n        if (colors[i] == 1) {\n            dpRed[i] = (dpRed.getOrElse(i - 1) { 0 } + dpBlue.getOrElse(i - 1) { 0 } + 1) % mod\n            dpBlue[i] = dpBlue.getOrElse(i - 1) { 0 }\n        } else {\n            dpRed[i] = dpRed.getOrElse(i - 1) { 0 }\n            dpBlue[i] = (dpRed.getOrElse(i - 1) { 0 } + dpBlue.getOrElse(i - 1) { 0 } + 1) % mod\n        }\n    }\n    \n    \/\/ Calculate the total number of ways to pick a zebroid subsequence\n    val totalWays = (dpRed[n - 1] + dpBlue[n - 1]) % mod\n    \n    \/\/ Print the result\n    println(totalWays)\n}","PHP":"<?php\\n\\nfunction countZebroidSubsequences($n) {\\n    $mod = 1000000007;\\n    $dp = array();\\n    $dp[0] = 1;\\n    $dp[1] = 2;\\n\\n    for ($i = 2; $i <= $n; $i++) {\\n        $dp[$i] = ($dp[$i-1] + $dp[$i-2]) % $mod;\\n    }\\n\\n    return $dp[$n];\\n}\\n\\n$input = trim(fgets(STDIN));\\n$n = intval($input);\\n\\n$result = countZebroidSubsequences($n);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int mod = 1000000007;\\r\\n\\r\\n    int[] dp = new int[n + 1];\\r\\n    dp[0] = 1;\\r\\n    dp[1] = 2;\\r\\n\\r\\n    for (int i = 2; i <= n; i++)\\r\\n    {\\r\\n        dp[i] = (dp[i - 1] + dp[i - 2]) % mod;\\r\\n    }\\r\\n\\r\\n    writeln(to!string(dp[n]));\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_zebroid_subsequences {\n    my ($n) = @_;\n    \n    my $mod = 1000000007;\n    \n    # Initialize the dynamic programming array\n    my @dp = (0) x ($n + 1);\n    \n    # Base cases\n    $dp[1] = 2;\n    $dp[2] = 3;\n    \n    # Calculate the number of zebroid subsequences\n    for (my $i = 3; $i <= $n; $i++) {\n        $dp[$i] = ($dp[$i-1] + $dp[$i-2]) % $mod;\n    }\n    \n    return $dp[$n];\n}\n\n# Read the input\nmy $n = <STDIN>;\nchomp $n;\n\n# Calculate the number of zebroid subsequences\nmy $result = count_zebroid_subsequences($n);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\\n    let modulo = 1000000007;\\n\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    let mut dp = vec![0; n + 1];\\n    dp[1] = 2;\\n\\n    for i in 2..=n {\\n        dp[i] = (dp[i - 1] + dp[i - 2]) % modulo;\\n    }\\n\\n    println!(\\\"{}\\\", dp[n]);\\n}"}
{"title":"C. Trails and Glades","description":"Vasya went for a walk in the park. The park has n glades, numbered from 1 to n. There are m trails between the glades. The trails are numbered from 1 to m, where the i-th trail connects glades xi and yi. The numbers of the connected glades may be the same (xi=yi), which means that a trail connects a glade to itself. Also, two glades may have several non-intersecting trails between them.Vasya is on glade 1, he wants to walk on all trails of the park exactly once, so that he can eventually return to glade 1. Unfortunately, Vasya does not know whether this walk is possible or not. Help Vasya, determine whether the walk is possible or not. If such walk is impossible, find the minimum number of trails the authorities need to add to the park in order to make the described walk possible.Vasya can shift from one trail to another one only on glades. He can move on the trails in both directions. If Vasya started going on the trail that connects glades a and b, from glade a, then he must finish this trail on glade b.","input_from":"standard input","output_to":"standard output","time_limit":"4 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m (1\u2264n\u226410^6;\u00a00\u2264m\u226410^6) \u2014 the number of glades in the park and the number of trails in the park, respectively. Next m lines specify the trails. The i-th line specifies the i-th trail as two space-separated numbers, xi, yi (1\u2264xi,yi\u2264n) \u2014 the numbers of the glades connected by this trail.\n","output_spec":"Print the single integer \u2014 the answer to the problem. If Vasya's walk is possible without adding extra trails, print 0, otherwise print the minimum number of trails the authorities need to add to the park in order to make Vasya's walk possible. \n","notes":"In the first test case the described walk is possible without building extra trails. For example, let's first go on the first trail, then on the second one, and finally on the third one.\nIn the second test case the described walk is impossible without adding extra trails. To make the walk possible, it is enough to add one trail, for example, between glades number one and two.\n","sample_inputs":["3 3\n1 2\n2 3\n3 1\n","2 5\n1 1\n1 2\n1 2\n2 2\n1 2\n"],"sample_outputs":["0\n","1\n"],"id":"209-C","difficulty":2400,"tags":["constructive+algorithms","dsu","graphs","greedy"],"src_uid":"55591193f2dae9e04f0b9890aaa02575","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <unordered_set>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    vector<int> inDegree(n + 1, 0);\\n    vector<int> outDegree(n + 1, 0);\\n    unordered_set<int> glades;\\n\\n    for (int i = 0; i < m; i++) {\\n        int x, y;\\n        cin >> x >> y;\\n        inDegree[y]++;\\n        outDegree[x]++;\\n        glades.insert(x);\\n        glades.insert(y);\\n    }\\n\\n    bool possible = true;\\n    int extraTrails = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        if (inDegree[i] != outDegree[i]) {\\n            possible = false;\\n            extraTrails += abs(inDegree[i] - outDegree[i]);\\n        }\\n    }\\n\\n    if (possible) {\\n        cout << 0 << endl;\\n    } else {\\n        cout << extraTrails << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class ParkWalk {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            graph.get(x).add(y);\n            graph.get(y).add(x);\n        }\n        \n        boolean[] visited = new boolean[n + 1];\n        int connectedComponents = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (!visited[i]) {\n                dfs(i, graph, visited);\n                connectedComponents++;\n            }\n        }\n        \n        if (connectedComponents == 1) {\n            System.out.println(0);\n        } else {\n            System.out.println(connectedComponents - 1);\n        }\n    }\n    \n    private static void dfs(int node, List<List<Integer>> graph, boolean[] visited) {\n        visited[node] = true;\n        \n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, graph, visited);\n            }\n        }\n    }\n}","Python":"def is_walk_possible(n, m, trails):\n    glades = set()\n    for trail in trails:\n        glades.add(trail[0])\n        glades.add(trail[1])\n    \n    if len(glades) != n:\n        return '1'\n    else:\n        return '0'\n\n# Sample Inputs\ninputs = ['3 3\\n1 2\\n2 3\\n3 1\\n', '2 5\\n1 1\\n1 2\\n1 2\\n2 2\\n1 2\\n']\n\n# Extracting inputs\nn, m = map(int, inputs[0].split())\ntrails = [list(map(int, trail.split())) for trail in inputs[1:]]\n\n# Calling the function\noutput = is_walk_possible(n, m, trails)\n\n# Printing the output\nprint(output)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_N 1000000\\n\\nint parent[MAX_N + 1];\\nint rank[MAX_N + 1];\\n\\nvoid make_set(int v) {\\n    parent[v] = v;\\n    rank[v] = 0;\\n}\\n\\nint find_set(int v) {\\n    if (v == parent[v])\\n        return v;\\n    return parent[v] = find_set(parent[v]);\\n}\\n\\nvoid union_sets(int a, int b) {\\n    a = find_set(a);\\n    b = find_set(b);\\n    if (a != b) {\\n        if (rank[a] < rank[b])\\n            parent[a] = b;\\n        else\\n            parent[b] = a;\\n        if (rank[a] == rank[b])\\n            rank[a]++;\\n    }\\n}\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n\\n    for (int i = 1; i <= n; i++) {\\n        make_set(i);\\n    }\\n\\n    int extra_trails = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        int x, y;\\n        scanf(\\\"%d %d\\\", &x, &y);\\n\\n        if (find_set(x) != find_set(y)) {\\n            union_sets(x, y);\\n        } else {\\n            extra_trails++;\\n        }\\n    }\\n\\n    if (extra_trails == 0) {\\n        printf(\\\"0\\\\n\\\");\\n    } else {\\n        printf(\\\"%d\\\\n\\\", extra_trails);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace ParkWalk\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            List<int>[] trails = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                trails[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine().Split();\n                int x = int.Parse(input[0]);\n                int y = int.Parse(input[1]);\n\n                trails[x].Add(y);\n                trails[y].Add(x);\n            }\n\n            bool[] visited = new bool[n + 1];\n            int connectedComponents = 0;\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (!visited[i])\n                {\n                    DFS(i, trails, visited);\n                    connectedComponents++;\n                }\n            }\n\n            if (connectedComponents == 1)\n            {\n                Console.WriteLine(0);\n            }\n            else\n            {\n                Console.WriteLine(connectedComponents - 1);\n            }\n        }\n\n        static void DFS(int node, List<int>[] trails, bool[] visited)\n        {\n            visited[node] = true;\n\n            foreach (int neighbor in trails[node])\n            {\n                if (!visited[neighbor])\n                {\n                    DFS(neighbor, trails, visited);\n                }\n            }\n        }\n    }\n}","Ruby":"\ndef possible_walk(n, m, trails)\n  # Create an adjacency list to represent the trails\n  adjacency_list = Array.new(n) { [] }\n  trails.each do |trail|\n    x, y = trail\n    adjacency_list[x-1] << y-1\n    adjacency_list[y-1] << x-1\n  end\n\n  # Perform a depth-first search to check if all trails can be visited\n  visited = Array.new(n, false)\n  dfs(adjacency_list, visited, 0)\n\n  # Check if all glades have been visited\n  if visited.all?\n    return 0\n  else\n    # Count the number of unvisited glades\n    unvisited_glades = visited.count(false)\n    # Calculate the minimum number of trails needed to connect all glades\n    return unvisited_glades - 1\n  end\nend\n\ndef dfs(adjacency_list, visited, glade)\n  visited[glade] = true\n  adjacency_list[glade].each do |neighbour|\n    dfs(adjacency_list, visited, neighbour) unless visited[neighbour]\n  end\nend\n\n# Parse the input\ninput = gets.chomp.split(\"\\n\")\nn, m = input[0].split.map(&:to_i)\ntrails = input[1..m].map { |trail| trail.split.map(&:to_i) }\n\n# Call the function and print the result\nputs possible_walk(n, m, trails)\n","delphi":"program ParkWalk;\\n\\nvar\\n  n, m, i, x, y: integer;\\n  glades: array of integer;\\n  trails: array of array of integer;\\n  visited: array of boolean;\\n  possible: boolean;\\n\\nprocedure DFS(v: integer);\\nvar\\n  i: integer;\\nbegin\\n  visited[v] := true;\\n  for i := 0 to Length(trails[v]) - 1 do\\n  begin\\n    if not visited[trails[v][i]] then\\n      DFS(trails[v][i]);\\n  end;\\nend;\\n\\nbegin\\n  ReadLn(n, m);\\n  SetLength(glades, n + 1);\\n  SetLength(trails, n + 1);\\n  SetLength(visited, n + 1);\\n\\n  for i := 1 to m do\\n  begin\\n    ReadLn(x, y);\\n    SetLength(trails[x], Length(trails[x]) + 1);\\n    trails[x][Length(trails[x]) - 1] := y;\\n    if x <> y then\\n    begin\\n      SetLength(trails[y], Length(trails[y]) + 1);\\n      trails[y][Length(trails[y]) - 1] := x;\\n    end;\\n  end;\\n\\n  DFS(1);\\n\\n  possible := true;\\n  for i := 1 to n do\\n  begin\\n    if not visited[i] then\\n    begin\\n      possible := false;\\n      Break;\\n    end;\\n  end;\\n\\n  if possible then\\n    WriteLn('0')\\n  else\\n    WriteLn('1');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tm, _ := strconv.Atoi(scanner.Text())\\n\\n\\tglades := make([]int, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tx, _ := strconv.Atoi(scanner.Text())\\n\\t\\tscanner.Scan()\\n\\t\\ty, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\\tglades[x]++\\n\\t\\tglades[y]++\\n\\t}\\n\\n\\tpossible := true\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif glades[i] == 0 {\\n\\t\\t\\tpossible = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif possible {\\n\\t\\tfmt.Println(0)\\n\\t} else {\\n\\t\\tfmt.Println(1)\\n\\t}\\n}","Javascript":"function isWalkPossible(n, m, trails) {\n    let graph = new Array(n + 1).fill(0).map(() => new Array());\n    let inDegree = new Array(n + 1).fill(0);\n    \n    for (let i = 0; i < m; i++) {\n        let [x, y] = trails[i];\n        graph[x].push(y);\n        inDegree[y]++;\n    }\n    \n    let queue = [];\n    let visited = new Array(n + 1).fill(false);\n    \n    queue.push(1);\n    visited[1] = true;\n    \n    while (queue.length > 0) {\n        let node = queue.shift();\n        \n        for (let i = 0; i < graph[node].length; i++) {\n            let neighbor = graph[node][i];\n            inDegree[neighbor]--;\n            \n            if (!visited[neighbor] && inDegree[neighbor] === 0) {\n                queue.push(neighbor);\n                visited[neighbor] = true;\n            }\n        }\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nfunction solveProblem(input) {\n    let lines = input.split('\\\\n');\n    let [n, m] = lines[0].split(' ').map(Number);\n    let trails = [];\n    \n    for (let i = 1; i <= m; i++) {\n        let [x, y] = lines[i].split(' ').map(Number);\n        trails.push([x, y]);\n    }\n    \n    let result = isWalkPossible(n, m, trails);\n    return result.toString();\n}\n\nlet inputs = ['3 3\\\\n1 2\\\\n2 3\\\\n3 1\\\\n', '2 5\\\\n1 1\\\\n1 2\\\\n1 2\\\\n2 2\\\\n1 2\\\\n'];\nlet outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    let output = solveProblem(inputs[i]);\n    outputs.push(output);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    \n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    val inDegree = IntArray(n + 1)\n    \n    for (i in 0 until m) {\n        val trail = scanner.nextLine().split(\" \")\n        val x = trail[0].toInt()\n        val y = trail[1].toInt()\n        \n        graph[x].add(y)\n        inDegree[y]++\n    }\n    \n    val queue: Queue<Int> = LinkedList()\n    queue.add(1)\n    \n    var count = 0\n    var extraTrails = 0\n    \n    while (!queue.isEmpty()) {\n        val glade = queue.poll()\n        count++\n        \n        for (nextGlade in graph[glade]) {\n            inDegree[nextGlade]--\n            \n            if (inDegree[nextGlade] == 0) {\n                queue.add(nextGlade)\n            } else {\n                extraTrails++\n            }\n        }\n    }\n    \n    if (count == n) {\n        println(0)\n    } else {\n        println(extraTrails)\n    }\n}","PHP":"\n<?php\n\nfunction isWalkPossible($n, $m, $trails) {\n    $graph = array_fill(1, $n, []);\n    $inDegree = array_fill(1, $n, 0);\n    $outDegree = array_fill(1, $n, 0);\n    \n    foreach ($trails as $trail) {\n        $x = $trail[0];\n        $y = $trail[1];\n        \n        $graph[$x][] = $y;\n        $inDegree[$y]++;\n        $outDegree[$x]++;\n    }\n    \n    $start = 1;\n    $end = 1;\n    \n    for ($i = 1; $i <= $n; $i++) {\n        if ($inDegree[$i] == $outDegree[$i]) {\n            continue;\n        } else if ($inDegree[$i] == $outDegree[$i] + 1) {\n            $start = $i;\n        } else if ($inDegree[$i] + 1 == $outDegree[$i]) {\n            $end = $i;\n        } else {\n            return 1;\n        }\n    }\n    \n    $visited = array_fill(1, $n, false);\n    dfs($start, $graph, $visited);\n    \n    for ($i = 1; $i <= $n; $i++) {\n        if (!$visited[$i] && $outDegree[$i] > 0) {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nfunction dfs($node, $graph, &$visited) {\n    $visited[$node] = true;\n    \n    foreach ($graph[$node] as $neighbor) {\n        if (!$visited[$neighbor]) {\n            dfs($neighbor, $graph, $visited);\n        }\n    }\n}\n\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents(\\\"php:\/\/stdin\\\")));\nlist($n, $m) = explode(\\\" \\\", $input[0]);\n$trails = [];\n\nfor ($i = 1; $i <= $m; $i++) {\n    list($x, $y) = explode(\\\" \\\", $input[$i]);\n    $trails[] = [$x, $y];\n}\n\n$result = isWalkPossible($n, $m, $trails);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] trails = new int[][];\\r\\n    for (int i = 0; i < m; i++)\\r\\n    {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        trails ~= [x, y];\\r\\n    }\\r\\n\\r\\n    int[] glades = new int[](n, 0);\\r\\n    foreach (trail; trails)\\r\\n    {\\r\\n        glades[trail[0] - 1]++;\\r\\n        glades[trail[1] - 1]++;\\r\\n    }\\r\\n\\r\\n    bool possible = true;\\r\\n    foreach (count; glades)\\r\\n    {\\r\\n        if (count % 2 != 0)\\r\\n        {\\r\\n            possible = false;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (possible)\\r\\n    {\\r\\n        writeln(\\\"0\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        int oddCount = glades.count!(x => x % 2 != 0);\\r\\n        writeln((oddCount \/ 2) + 1);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_min_trails {\n    my ($n, $m, @trails) = @_;\n\n    my %glades;\n    foreach my $trail (@trails) {\n        my ($x, $y) = split(' ', $trail);\n        $glades{$x}++;\n        $glades{$y}++;\n    }\n\n    my $odd_glades = 0;\n    foreach my $glade (keys %glades) {\n        $odd_glades++ if $glades{$glade} % 2 != 0;\n    }\n\n    if ($odd_glades == 0 || $odd_glades == 2) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split(' ', $input);\nmy @trails;\nfor (my $i = 0; $i < $m; $i++) {\n    my $trail = <STDIN>;\n    chomp $trail;\n    push @trails, $trail;\n}\n\n# Call the function and print the result\nmy $result = find_min_trails($n, $m, @trails);\nprint $result;\n","Rust":"use std::collections::HashSet;\\n\\nfn main() {\\n    let input = \\\"2 5\\\\n1 1\\\\n1 2\\\\n1 2\\\\n2 2\\\\n1 2\\\\n\\\";\\n    let mut lines = input.lines();\\n    let nm: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nm[0];\\n    let m = nm[1];\\n\\n    let mut graph: Vec<Vec<usize>> = vec![vec![]; n + 1];\\n    let mut in_degrees: Vec<usize> = vec![0; n + 1];\\n\\n    for _ in 0..m {\\n        let trail: Vec<usize> = lines\\n            .next()\\n            .unwrap()\\n            .split_whitespace()\\n            .map(|x| x.parse().unwrap())\\n            .collect();\\n        let x = trail[0];\\n        let y = trail[1];\\n\\n        graph[x].push(y);\\n        graph[y].push(x);\\n        in_degrees[x] += 1;\\n        in_degrees[y] += 1;\\n    }\\n\\n    let mut visited: HashSet<usize> = HashSet::new();\\n    let mut stack: Vec<usize> = vec![1];\\n\\n    while let Some(node) = stack.pop() {\\n        visited.insert(node);\\n\\n        for &neighbour in &graph[node] {\\n            if !visited.contains(&neighbour) {\\n                stack.push(neighbour);\\n            }\\n        }\\n    }\\n\\n    let mut odd_degrees = 0;\\n    for i in 1..=n {\\n        if in_degrees[i] % 2 != 0 {\\n            odd_degrees += 1;\\n        }\\n    }\\n\\n    let answer = if visited.len() == n && odd_degrees <= 2 { 0 } else { 1 };\\n    println!(\\\"{}\\\", answer);\\n}"}
{"title":"A. Game","description":"Furik and Rubik love playing computer games. Furik has recently found a new game that greatly interested Rubik. The game consists of n parts and to complete each part a player may probably need to complete some other ones. We know that the game can be fully completed, that is, its parts do not form cyclic dependencies. Rubik has 3 computers, on which he can play this game. All computers are located in different houses. Besides, it has turned out that each part of the game can be completed only on one of these computers. Let's number the computers with integers from 1 to 3. Rubik can perform the following actions:   Complete some part of the game on some computer. Rubik spends exactly 1 hour on completing any part on any computer.  Move from the 1-st computer to the 2-nd one. Rubik spends exactly 1 hour on that.  Move from the 1-st computer to the 3-rd one. Rubik spends exactly 2 hours on that.  Move from the 2-nd computer to the 1-st one. Rubik spends exactly 2 hours on that.  Move from the 2-nd computer to the 3-rd one. Rubik spends exactly 1 hour on that.  Move from the 3-rd computer to the 1-st one. Rubik spends exactly 1 hour on that.  Move from the 3-rd computer to the 2-nd one. Rubik spends exactly 2 hours on that. Help Rubik to find the minimum number of hours he will need to complete all parts of the game. Initially Rubik can be located at the computer he considers necessary. ","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains integer n (1\u2264n\u2264200) \u2014 the number of game parts. The next line contains n integers, the i-th integer \u2014 ci (1\u2264ci\u22643) represents the number of the computer, on which you can complete the game part number i. \nNext n lines contain descriptions of game parts. The i-th line first contains integer ki (0\u2264ki\u2264n-1), then ki distinct integers ai,j (1\u2264ai,j\u2264n;\u00a0ai,j\u2260i) \u2014 the numbers of parts to complete before part i.\nNumbers on all lines are separated by single spaces. You can assume that the parts of the game are numbered from 1 to n in some way. It is guaranteed that there are no cyclic dependencies between the parts of the game.\n","output_spec":"On a single line print the answer to the problem.\n","notes":"Note to the second sample: before the beginning of the game the best strategy is to stand by the third computer. First we complete part 5. Then we go to the 1-st computer and complete parts 3 and 4. Then we go to the 2-nd computer and complete parts 1 and 2. In total we get 1+1+2+1+2, which equals 7 hours.\n","sample_inputs":["1\n1\n0\n","5\n2 2 1 1 3\n1 5\n2 5 1\n2 5 4\n1 5\n0\n"],"sample_outputs":["1\n","7\n"],"id":"213-A","difficulty":1700,"tags":["dfs+and+similar","greedy"],"src_uid":"be42e213ff43e303e475d77a9560367f","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <algorithm>\\nusing namespace std;\\n\\nconst int INF = 1e9;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> computer(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> computer[i];\\n    }\\n    vector<vector<int>> dependencies(n);\\n    for (int i = 0; i < n; i++) {\\n        int k;\\n        cin >> k;\\n        for (int j = 0; j < k; j++) {\\n            int x;\\n            cin >> x;\\n            dependencies[i].push_back(x - 1);\\n        }\\n    }\\n    vector<int> dp(n, INF);\\n    dp[0] = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (computer[i] == computer[j]) {\\n                dp[i] = min(dp[i], dp[j] + 1);\\n            } else if (computer[i] != computer[j] && dp[j] != INF) {\\n                if (computer[i] == 1 && computer[j] == 2) {\\n                    dp[i] = min(dp[i], dp[j] + 2);\\n                } else if (computer[i] == 1 && computer[j] == 3) {\\n                    dp[i] = min(dp[i], dp[j] + 1);\\n                } else if (computer[i] == 2 && computer[j] == 1) {\\n                    dp[i] = min(dp[i], dp[j] + 1);\\n                } else if (computer[i] == 2 && computer[j] == 3) {\\n                    dp[i] = min(dp[i], dp[j] + 2);\\n                } else if (computer[i] == 3 && computer[j] == 1) {\\n                    dp[i] = min(dp[i], dp[j] + 2);\\n                } else if (computer[i] == 3 && computer[j] == 2) {\\n                    dp[i] = min(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n    }\\n    int ans = *max_element(dp.begin(), dp.end());\\n    cout << ans << endl;\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.Scanner;\\n\\npublic class GameCompletion {\\n\\n    static int n;\\n    static int[] computers;\\n    static ArrayList<Integer>[] dependencies;\\n    static int[] time;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        computers = new int[n + 1];\\n        dependencies = new ArrayList[n + 1];\\n        time = new int[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            computers[i] = scanner.nextInt();\\n            dependencies[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            int k = scanner.nextInt();\\n            for (int j = 0; j < k; j++) {\\n                int dependency = scanner.nextInt();\\n                dependencies[i].add(dependency);\\n            }\\n        }\\n\\n        int minHours = Integer.MAX_VALUE;\\n\\n        for (int startComputer = 1; startComputer <= 3; startComputer++) {\\n            int hours = calculateHours(startComputer);\\n            minHours = Math.min(minHours, hours);\\n        }\\n\\n        System.out.println(minHours);\\n    }\\n\\n    public static int calculateHours(int startComputer) {\\n        int[] visited = new int[n + 1];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(startComputer);\\n        visited[startComputer] = 1;\\n        int hours = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int currentComputer = queue.poll();\\n\\n            for (int i = 1; i <= n; i++) {\\n                if (computers[i] == currentComputer && visited[i] == 0) {\\n                    boolean canComplete = true;\\n                    for (int dependency : dependencies[i]) {\\n                        if (visited[dependency] == 0) {\\n                            canComplete = false;\\n                            break;\\n                        }\\n                    }\\n\\n                    if (canComplete) {\\n                        queue.add(i);\\n                        visited[i] = 1;\\n                        hours += time[i];\\n                    }\\n                }\\n            }\\n\\n            if (queue.isEmpty()) {\\n                for (int i = 1; i <= n; i++) {\\n                    if (visited[i] == 0) {\\n                        queue.add(i);\\n                        visited[i] = 1;\\n                        hours += time[i];\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return hours;\\n    }\\n}\"}}","Python":"from collections import defaultdict\\n\\ndef dfs(v, graph, visited, order):\\n    visited[v] = True\\n    for u in graph[v]:\\n        if not visited[u]:\\n            dfs(u, graph, visited, order)\\n    order.append(v)\\n\\ndef main():\\n    n = int(input())\\n    computers = list(map(int, input().split()))\\n    graph = defaultdict(list)\\n    for i in range(n):\\n        dependencies = list(map(int, input().split()))[1:]\\n        for d in dependencies:\\n            graph[d].append(i+1)\\n    visited = [False] * (n+1)\\n    order = []\\n    for i in range(1, n+1):\\n        if not visited[i]:\\n            dfs(i, graph, visited, order)\\n    dp = [0] * (n+1)\\n    for v in order[::-1]:\\n        dp[v] = max(dp[u] for u in graph[v]) + 1\\n    result = max(dp)\\n    print(result)\\n\\n\\nif __name__ == '__main__':\\n    main()\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define INF 1000000000\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int c[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &c[i]);\\n    }\\n    int k[n], a[n][n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &k[i]);\\n        for (int j = 0; j < k[i]; j++) {\\n            scanf(\\\"%d\\\", &a[i][j]);\\n        }\\n    }\\n    int dp[n][8];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < 8; j++) {\\n            dp[i][j] = INF;\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        dp[i][1 << c[i] - 1] = 1;\\n    }\\n    for (int mask = 0; mask < 8; mask++) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k[i]; j++) {\\n                dp[a[i][j] - 1][mask | (1 << c[i] - 1)] = fmin(dp[a[i][j] - 1][mask | (1 << c[i] - 1)], dp[i][mask] + 1);\\n            }\\n        }\\n    }\\n    int ans = INF;\\n    for (int i = 0; i < n; i++) {\\n        ans = fmin(ans, dp[i][7]);\\n    }\\n    printf(\\\"%d\\\\n\\\", ans);\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace GameCompletion\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] computers = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            List<int>[] dependencies = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                dependencies[i] = new List<int>();\n                string[] parts = Console.ReadLine().Split();\n                int k = int.Parse(parts[0]);\n                for (int j = 1; j <= k; j++)\n                {\n                    dependencies[i].Add(int.Parse(parts[j]));\n                }\n            }\n\n            int[] completionTimes = new int[4];\n            for (int i = 1; i <= n; i++)\n            {\n                int computer = computers[i - 1];\n                int maxTime = 0;\n                foreach (int dependency in dependencies[i])\n                {\n                    maxTime = Math.Max(maxTime, completionTimes[dependency]);\n                }\n                completionTimes[i] = maxTime + 1;\n                if (computer == 1)\n                {\n                    completionTimes[i] = Math.Min(completionTimes[i], completionTimes[i - 1] + 1);\n                }\n                else if (computer == 2)\n                {\n                    completionTimes[i] = Math.Min(completionTimes[i], completionTimes[i - 1] + 2);\n                }\n                else if (computer == 3)\n                {\n                    completionTimes[i] = Math.Min(completionTimes[i], completionTimes[i - 1] + 2);\n                    completionTimes[i] = Math.Min(completionTimes[i], completionTimes[i - 2] + 1);\n                }\n            }\n\n            Console.WriteLine(completionTimes[n]);\n        }\n    }\n}\n","Ruby":"\ndef minimum_hours(n, computers, parts)\n  # Create a hash to store the dependencies for each part\n  dependencies = Hash.new { |h, k| h[k] = [] }\n  \n  # Populate the dependencies hash\n  parts.each_with_index do |part, i|\n    k = part[0]\n    dependencies[i+1] = part[1..k]\n  end\n  \n  # Create a hash to store the completion time for each computer\n  completion_time = {1 => 0, 2 => 0, 3 => 0}\n  \n  # Iterate through each part and calculate the completion time for each computer\n  (1..n).each do |part|\n    computer = computers[part-1]\n    max_time = 0\n    \n    # Find the maximum completion time among the dependencies\n    dependencies[part].each do |dependency|\n      max_time = [max_time, completion_time[dependency]].max\n    end\n    \n    # Update the completion time for the current part and computer\n    completion_time[part] = max_time + 1\n    \n    # Update the completion time for the current computer\n    if computer == 1\n      completion_time[2] = [completion_time[2], completion_time[part] + 1].max\n      completion_time[3] = [completion_time[3], completion_time[part] + 2].max\n    elsif computer == 2\n      completion_time[1] = [completion_time[1], completion_time[part] + 2].max\n      completion_time[3] = [completion_time[3], completion_time[part] + 1].max\n    elsif computer == 3\n      completion_time[1] = [completion_time[1], completion_time[part] + 1].max\n      completion_time[2] = [completion_time[2], completion_time[part] + 2].max\n    end\n  end\n  \n  # Find the maximum completion time among all computers\n  max_completion_time = completion_time.values.max\n  \n  return max_completion_time\nend\n\n# Parse the input\ninput = ['1\\n1\\n0\\n', '5\\n2 2 1 1 3\\n1 5\\n2 5 1\\n2 5 4\\n1 5\\n0\\n']\nn = input[0].to_i\ncomputers = input[1].split.map(&:to_i)\nparts = input[2..-1].map { |line| line.split.map(&:to_i) }\n\n# Call the function and print the result\nresult = minimum_hours(n, computers, parts)\nputs result\n","delphi":"program GameCompletion;\\n\\nvar\\n  n, i, j, k, minHours, currentHours: integer;\\n  computers: array[1..3] of integer;\\n  parts: array[1..200] of record\\n    computer: integer;\\n    dependencies: array[1..200] of integer;\\n    numDependencies: integer;\\n  end;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n);\\n  for i := 1 to n do\\n    read(computers[i]);\\n  readln;\\n  for i := 1 to n do\\n  begin\\n    read(parts[i].numDependencies);\\n    for j := 1 to parts[i].numDependencies do\\n      read(parts[i].dependencies[j]);\\n    readln;\\n  end;\\n\\n  \/\/ Initialize variables\\n  minHours := MaxInt;\\n\\n  \/\/ Try all possible starting computers\\n  for i := 1 to 3 do\\n  begin\\n    currentHours := 0;\\n\\n    \/\/ Complete all parts\\n    for j := 1 to n do\\n    begin\\n      \/\/ Check if part j can be completed on current computer\\n      if computers[j] = i then\\n      begin\\n        \/\/ Check if there are any dependencies\\n        if parts[j].numDependencies > 0 then\\n        begin\\n          \/\/ Complete all dependencies first\\n          for k := 1 to parts[j].numDependencies do\\n          begin\\n            \/\/ Check if dependency k can be completed on current computer\\n            if computers[parts[j].dependencies[k]] = i then\\n              continue;\\n\\n            \/\/ Move to the computer where dependency k can be completed\\n            if i = 1 then\\n              currentHours := currentHours + 1\\n            else if i = 2 then\\n              currentHours := currentHours + 2\\n            else\\n              currentHours := currentHours + 3;\\n\\n            \/\/ Update current computer\\n            i := computers[parts[j].dependencies[k]];\\n          end;\\n        end;\\n\\n        \/\/ Complete part j on current computer\\n        currentHours := currentHours + 1;\\n      end\\n      else\\n      begin\\n        \/\/ Move to the computer where part j can be completed\\n        if i = 1 then\\n          currentHours := currentHours + 1\\n        else if i = 2 then\\n          currentHours := currentHours + 2\\n        else\\n          currentHours := currentHours + 3;\\n\\n        \/\/ Update current computer\\n        i := computers[j];\\n\\n        \/\/ Complete part j on current computer\\n        currentHours := currentHours + 1;\\n      end;\\n    end;\\n\\n    \/\/ Update minimum hours\\n    if currentHours < minHours then\\n      minHours := currentHours;\\n  end;\\n\\n  \/\/ Print the answer\\n  writeln(minHours);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\tscanner.Scan()\\n\\tcomputers := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\tdependencies := make([][]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tdetails := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\tk, _ := strconv.Atoi(details[0])\\n\\n\\t\\tdependencies[i] = make([]int, k)\\n\\n\\t\\tfor j := 1; j <= k; j++ {\\n\\t\\t\\tdependency, _ := strconv.Atoi(details[j])\\n\\t\\t\\tdependencies[i][j-1] = dependency\\n\\t\\t}\\n\\t}\\n\\n\\tcompleted := make([]bool, n)\\n\\thours := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif !completed[i] {\\n\\t\\t\\tcurrentComputer, _ := strconv.Atoi(computers[i])\\n\\t\\t\\thours += 1\\n\\n\\t\\t\\tfor _, dependency := range dependencies[i] {\\n\\t\\t\\t\\tif !completed[dependency-1] {\\n\\t\\t\\t\\t\\tdependencyComputer, _ := strconv.Atoi(computers[dependency-1])\\n\\n\\t\\t\\t\\t\\tif currentComputer == dependencyComputer {\\n\\t\\t\\t\\t\\t\\thours += 1\\n\\t\\t\\t\\t\\t} else if currentComputer == 1 && dependencyComputer == 2 || currentComputer == 2 && dependencyComputer == 1 {\\n\\t\\t\\t\\t\\t\\thours += 2\\n\\t\\t\\t\\t\\t} else if currentComputer == 1 && dependencyComputer == 3 || currentComputer == 3 && dependencyComputer == 1 {\\n\\t\\t\\t\\t\\t\\thours += 2\\n\\t\\t\\t\\t\\t} else if currentComputer == 2 && dependencyComputer == 3 || currentComputer == 3 && dependencyComputer == 2 {\\n\\t\\t\\t\\t\\t\\thours += 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted[i] = true\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(hours)\\n}","Javascript":"function findMinimumHours(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const computers = lines[1].split(' ').map(Number);\n  const parts = [];\n  for (let i = 0; i < n; i++) {\n    const dependencies = lines[i + 2].split(' ').map(Number);\n    parts.push(dependencies.slice(1));\n  }\n\n  const dp = Array(n).fill(Infinity);\n  dp[0] = 1;\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < parts[i].length; j++) {\n      dp[i] = Math.min(dp[i], dp[parts[i][j] - 1] + 1);\n    }\n  }\n\n  let minHours = Infinity;\n  for (let i = 0; i < 3; i++) {\n    let hours = 0;\n    for (let j = 0; j < n; j++) {\n      if (computers[j] === i + 1) {\n        hours += dp[j];\n      } else {\n        hours += 2 * dp[j];\n      }\n    }\n    minHours = Math.min(minHours, hours);\n  }\n\n  return minHours.toString();\n}\n\nconst input = '5\\\\n2 2 1 1 3\\\\n1 5\\\\n2 5 1\\\\n2 5 4\\\\n1 5\\\\n0\\\\n';\nconsole.log(findMinimumHours(input));","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val computers = IntArray(n)\n    for (i in 0 until n) {\n        computers[i] = sc.nextInt()\n    }\n    val dependencies = Array(n) { mutableListOf<Int>() }\n    for (i in 0 until n) {\n        val k = sc.nextInt()\n        for (j in 0 until k) {\n            dependencies[i].add(sc.nextInt() - 1)\n        }\n    }\n    val dp = IntArray(n)\n    for (i in n - 1 downTo 0) {\n        for (j in dependencies[i]) {\n            dp[j] = maxOf(dp[j], dp[i] + 1)\n        }\n    }\n    var maxTime = 0\n    for (i in 0 until n) {\n        maxTime = maxOf(maxTime, dp[i])\n    }\n    var totalTime = 0\n    for (i in 0 until n) {\n        totalTime += computers[i]\n    }\n    totalTime += maxTime\n    println(totalTime)\n}","PHP":"\n<?php\n\nfunction findMinHours($n, $computers, $parts) {\n    $completed = array_fill(0, $n, false); \/\/ array to keep track of completed parts\n    $hours = 0; \/\/ variable to store the total number of hours\n    \n    \/\/ function to check if all parts are completed\n    function allCompleted($completed) {\n        foreach ($completed as $part) {\n            if (!$part) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \/\/ function to complete a part and its dependencies\n    function completePart($part, $computers, &$completed) {\n        if ($completed[$part]) {\n            return;\n        }\n        \n        \/\/ complete the dependencies first\n        foreach ($computers[$part] as $dependency) {\n            completePart($dependency, $computers, $completed);\n        }\n        \n        \/\/ complete the part on the required computer\n        $completed[$part] = true;\n    }\n    \n    \/\/ find the computer with the maximum number of parts\n    $maxComputer = array_count_values($computers);\n    $maxComputer = array_search(max($maxComputer), $maxComputer);\n    \n    \/\/ complete the parts on the maxComputer first\n    for ($i = 0; $i < $n; $i++) {\n        if ($computers[$i] == $maxComputer) {\n            completePart($i, $computers, $completed);\n            $hours++;\n        }\n    }\n    \n    \/\/ complete the remaining parts on other computers\n    while (!allCompleted($completed)) {\n        $hours += 2; \/\/ move from 1st computer to 3rd computer\n        $hours += 1; \/\/ move from 3rd computer to 2nd computer\n        \n        for ($i = 0; $i < $n; $i++) {\n            if (!$completed[$i]) {\n                completePart($i, $computers, $completed);\n                $hours++;\n            }\n        }\n    }\n    \n    return $hours;\n}\n\n\/\/ Sample inputs\n$n = 5;\n$computers = [2, 2, 1, 1, 3];\n$parts = [\n    [1, 5],\n    [2, 5, 1],\n    [2, 5, 4],\n    [1, 5],\n    [0]\n];\n\n\/\/ Call the function and print the output\n$output = findMinHours($n, $computers, $parts);\necho $output;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.container;\\r\\nimport std.functional;\\r\\nimport std.math;\\r\\nimport std.numeric;\\r\\nimport std.range;\\r\\nimport std.string;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] computers;\\r\\n    readf(\\\"%s\\\", &computers);\\r\\n\\r\\n    int[][] dependencies;\\r\\n    dependencies.length = n;\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        int k;\\r\\n        readf(\\\"%d\\\", &k);\\r\\n\\r\\n        dependencies[i].length = k;\\r\\n\\r\\n        foreach (j; 0..k)\\r\\n        {\\r\\n            int dep;\\r\\n            readf(\\\"%d\\\", &dep);\\r\\n\\r\\n            dependencies[i][j] = dep;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[] completionTimes;\\r\\n    completionTimes.length = n;\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        int maxTime = 0;\\r\\n\\r\\n        foreach (j; 0..dependencies[i].length)\\r\\n        {\\r\\n            int dep = dependencies[i][j];\\r\\n            maxTime = max(maxTime, completionTimes[dep - 1]);\\r\\n        }\\r\\n\\r\\n        completionTimes[i] = maxTime + 1;\\r\\n    }\\r\\n\\r\\n    int maxTime = 0;\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        int comp = computers[i];\\r\\n\\r\\n        if (comp == 1)\\r\\n        {\\r\\n            maxTime = max(maxTime, completionTimes[i]);\\r\\n        }\\r\\n        else if (comp == 2)\\r\\n        {\\r\\n            maxTime = max(maxTime, completionTimes[i] + 2);\\r\\n        }\\r\\n        else if (comp == 3)\\r\\n        {\\r\\n            maxTime = max(maxTime, completionTimes[i] + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxTime);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_minimum_hours {\\n    my ($n, $computers, $parts) = @_;\\n    my @completed = (0) x $n;\\n    my @queue = ();\\n    my @time = (0) x 3;\\n    my $total_time = 0;\\n\\n    for my $i (0..$n-1) {\\n        my $computer = $computers->[$i];\\n        if ($computer == 1) {\\n            push @queue, $i;\\n        }\\n    }\\n\\n    while (@queue) {\\n        my $part = shift @queue;\\n        my $computer = $computers->[$part];\\n        my $time_required = $time[$computer-1];\\n\\n        $completed[$part] = 1;\\n        $total_time += $time_required;\\n\\n        for my $dependency (@{$parts->[$part]}) {\\n            next if $completed[$dependency];\\n\\n            my $dependency_computer = $computers->[$dependency];\\n            my $dependency_time = $time[$dependency_computer-1];\\n\\n            if ($dependency_time < $time_required) {\\n                $time[$dependency_computer-1] = $time_required;\\n            }\\n\\n            my $dependency_completed = 1;\\n            for my $predecessor (@{$parts->[$dependency]}) {\\n                $dependency_completed = 0 unless $completed[$predecessor];\\n            }\\n\\n            if ($dependency_completed) {\\n                push @queue, $dependency;\\n            }\\n        }\\n    }\\n\\n    return $total_time;\\n}\\n\\n# Sample inputs\\nmy $input1 = \\\"1\\\\n1\\\\n0\\\\n\\\";\\nmy $input2 = \\\"5\\\\n2 2 1 1 3\\\\n1 5\\\\n2 5 1\\\\n2 5 4\\\\n1 5\\\\n0\\\\n\\\";\\n\\n# Parse inputs\\nmy @inputs = ($input1, $input2);\\nmy ($n, $computers, $parts) = parse_input(@inputs);\\n\\n# Find minimum hours\\nmy $minimum_hours = find_minimum_hours($n, $computers, $parts);\\n\\n# Print output\\nprint \\\"$minimum_hours\\\\n\\\";\\n\\nsub parse_input {\\n    my (@inputs) = @_;\\n    my $n = 0;\\n    my @computers = ();\\n    my @parts = ();\\n\\n    for my $input (@inputs) {\\n        my @lines = split \/\\\\n\/, $input;\\n        $n = shift @lines;\\n\\n        my @computer_line = split \/ \/, shift @lines;\\n        push @computers, \\@computer_line;\\n\\n        my @part_lines = ();\\n        for my $line (@lines) {\\n            my @part_line = split \/ \/, $line;\\n            push @part_lines, \\@part_line;\\n        }\\n        push @parts, \\@part_lines;\\n    }\\n\\n    return ($n, \\@computers, \\@parts);\\n}\\n","Rust":"use std::collections::HashMap;\\n\\nfn main() {\\n    let input = \\\"5\\\\n2 2 1 1 3\\\\n1 5\\\\n2 5 1\\\\n2 5 4\\\\n1 5\\\\n0\\\\n\\\";\\n    let parts = parse_input(input);\\n    let result = find_minimum_hours(parts);\\n    println!(\\\"{}\\\", result);\\n}\\n\\nfn parse_input(input: &str) -> Vec<Vec<usize>> {\\n    let mut lines = input.lines();\\n    let n: usize = lines.next().unwrap().parse().unwrap();\\n    let computers: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n    let mut parts = vec![vec![]; n];\\n    for i in 0..n {\\n        let dependencies: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n        parts[i] = dependencies;\\n    }\\n    parts\\n}\\n\\nfn find_minimum_hours(parts: Vec<Vec<usize>>) -> usize {\\n    let n = parts.len();\\n    let mut dp: HashMap<(usize, usize, usize), usize> = HashMap::new();\\n    dp.insert((0, 0, 0), 0);\\n    for i in 0..n {\\n        for j in 0..3 {\\n            for k in 0..3 {\\n                if dp.contains_key(&(i, j, k)) {\\n                    let hours = dp[&(i, j, k)];\\n                    let computer = parts[i][j] - 1;\\n                    let next_computer = parts[i][k] - 1;\\n                    let next_hours = hours + if computer == next_computer {\\n                        1\\n                    } else if computer == 0 && next_computer == 1 {\\n                        2\\n                    } else if computer == 0 && next_computer == 2 {\\n                        3\\n                    } else if computer == 1 && next_computer == 0 {\\n                        3\\n                    } else if computer == 1 && next_computer == 2 {\\n                        1\\n                    } else if computer == 2 && next_computer == 0 {\\n                        2\\n                    } else if computer == 2 && next_computer == 1 {\\n                        3\\n                    } else {\\n                        unreachable!();\\n                    };\\n                    dp.entry((i + 1, k, 0)).and_modify(|x| *x = (*x).min(next_hours)).or_insert(next_hours);\\n                }\\n            }\\n        }\\n    }\\n    let mut min_hours = usize::max_value();\\n    for j in 0..3 {\\n        for k in 0..3 {\\n            if dp.contains_key(&(n, j, k)) {\\n                min_hours = min_hours.min(dp[&(n, j, k)]);\\n            }\\n        }\\n    }\\n    min_hours\\n}\\n"}
{"title":"B. Numbers","description":"Furik loves writing all sorts of problems, especially such that he can't solve himself. You've got one of his problems, the one Furik gave to Rubik. And Rubik asks you to solve it.There is integer n and array a, consisting of ten integers, indexed by numbers from 0 to 9. Your task is to count the number of positive integers with the following properties:  the number's length does not exceed n;  the number doesn't have leading zeroes;  digit i (0\u2264i\u22649) occurs in the number at least a[i] times. ","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains integer n (1\u2264n\u2264100). The next line contains 10 integers a[0], a[1], ..., a[9] (0\u2264a[i]\u2264100) \u2014 elements of array a. The numbers are separated by spaces.\n","output_spec":"On a single line print the remainder of dividing the answer to the problem by 1000000007 (10^9+7).\n","notes":"In the first sample number 9 meets the requirements.\nIn the second sample number 10 meets the requirements.\nIn the third sample numbers 10, 110, 210, 120, 103 meet the requirements. There are other suitable numbers, 36 in total.\n","sample_inputs":["1\n0 0 0 0 0 0 0 0 0 1\n","2\n1 1 0 0 0 0 0 0 0 0\n","3\n1 1 0 0 0 0 0 0 0 0\n"],"sample_outputs":["1\n","1\n","36\n"],"id":"213-B","difficulty":1900,"tags":["combinatorics","dp"],"src_uid":"c1b5169a5c3b1bd4a2f1df1069ee7755","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> a(10);\\n    for (int i = 0; i < 10; i++) {\\n        cin >> a[i];\\n    }\\n\\n    vector<vector<int>> dp(n + 1, vector<int>(10));\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < 10; j++) {\\n            for (int k = a[j]; k <= i; k++) {\\n                dp[i][j] = (dp[i][j] + dp[i - k][j - 1]) % MOD;\\n            }\\n        }\\n    }\\n\\n    int ans = 0;\\n    for (int i = 1; i <= n; i++) {\\n        ans = (ans + dp[i][9]) % MOD;\\n    }\\n\\n    cout << ans << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] a = new int[10];\\n        for (int i = 0; i < 10; i++) {\\n            a[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        long[][] dp = new long[n + 1][1024];\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int mask = 0; mask < 1024; mask++) {\\n                for (int digit = 0; digit < 10; digit++) {\\n                    if ((mask & (1 << digit)) != 0) {\\n                        dp[i][mask] += dp[i - 1][mask ^ (1 << digit)];\\n                    }\\n                }\\n                dp[i][mask] %= 1000000007;\\n            }\\n        }\\n\\n        long result = 0;\\n        for (int mask = 0; mask < 1024; mask++) {\\n            boolean valid = true;\\n            for (int digit = 0; digit < 10; digit++) {\\n                if (Integer.bitCount(mask) < a[digit]) {\\n                    valid = false;\\n                    break;\\n                }\\n            }\\n            if (valid) {\\n                result += dp[n][mask];\\n                result %= 1000000007;\\n            }\\n        }\\n\\n        System.out.println(result);\\n    }\\n}","Python":"def count_numbers(n, a):\n    MOD = 1000000007\n    dp = [[0] * 10 for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(10):\n            for k in range(a[j], i + 1):\n                dp[i][j] = (dp[i][j] + dp[i - k][j - 1]) % MOD\n\n    total_count = 0\n    for i in range(1, n + 1):\n        for j in range(10):\n            total_count = (total_count + dp[i][j]) % MOD\n\n    return str(total_count)\n\ninputs = ['1\\n0 0 0 0 0 0 0 0 0 1\\n', '2\\n1 1 0 0 0 0 0 0 0 0\\n', '3\\n1 1 0 0 0 0 0 0 0 0\\n']\noutputs = ['1\\n', '1\\n', '36\\n']\n\nresults = []\nfor i in range(len(inputs)):\n    n, a = map(int, inputs[i].split('\\\\n')[:-1])\n    a = list(map(int, a.split()))\n    output = count_numbers(n, a)\n    results.append(output == outputs[i])\n\njson_output = [{\"version\": \"Python 3\", \"source code\": count_numbers}]\njson.dumps(json_output)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MOD 1000000007\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[10];\\n    for (int i = 0; i < 10; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    long long dp[101][10];\\n    memset(dp, 0, sizeof(dp));\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < 10; j++) {\\n            if (i == 1 && j == 0) {\\n                dp[i][j] = 0;\\n            } else if (i == 1 && j > 0) {\\n                dp[i][j] = 1;\\n            } else {\\n                for (int k = 0; k <= a[j]; k++) {\\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % MOD;\\n                }\\n            }\\n        }\\n    }\\n\\n    long long ans = 0;\\n    for (int i = 0; i < 10; i++) {\\n        ans = (ans + dp[n][i]) % MOD;\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", ans);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string input = Console.ReadLine();\n        int n = int.Parse(input);\n\n        input = Console.ReadLine();\n        string[] aStr = input.Split(' ');\n        int[] a = new int[10];\n        for (int i = 0; i < 10; i++)\n        {\n            a[i] = int.Parse(aStr[i]);\n        }\n\n        long[,] dp = new long[n + 1, 1024];\n        dp[0, 0] = 1;\n\n        for (int i = 1; i <= n; i++)\n        {\n            for (int mask = 0; mask < 1024; mask++)\n            {\n                for (int digit = 0; digit < 10; digit++)\n                {\n                    if ((mask & (1 << digit)) != 0)\n                    {\n                        dp[i, mask] += dp[i - 1, mask ^ (1 << digit)];\n                    }\n                }\n            }\n        }\n\n        long result = 0;\n        for (int mask = 0; mask < 1024; mask++)\n        {\n            bool valid = true;\n            for (int digit = 0; digit < 10; digit++)\n            {\n                if (a[digit] > 0 && ((mask & (1 << digit)) == 0))\n                {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid)\n            {\n                result += dp[n, mask];\n            }\n        }\n\n        long mod = 1000000007;\n        result %= mod;\n\n        Console.WriteLine(result);\n    }\n}","Ruby":"\ndef count_numbers(n, a)\n  dp = Array.new(n+1) { Array.new(10, 0) }\n  dp[0][0] = 1\n\n  (1..n).each do |i|\n    (0..9).each do |j|\n      (j..9).each do |k|\n        dp[i][j] = (dp[i][j] + dp[i-1][k]) % 1000000007 if a[k] > 0\n      end\n    end\n  end\n\n  count = 0\n  (1..n).each do |i|\n    (1..9).each do |j|\n      count = (count + dp[i][j]) % 1000000007 if a[j] > 0\n    end\n  end\n\n  return count.to_s\nend\n\ninputs = ['1\\n0 0 0 0 0 0 0 0 0 1\\n', '2\\n1 1 0 0 0 0 0 0 0 0\\n', '3\\n1 1 0 0 0 0 0 0 0 0\\n']\noutputs = ['1\\n', '1\\n', '36\\n']\n\nresults = []\ninputs.each_with_index do |input, index|\n  n, a = input.split(\"\\n\")\n  a = a.split(\" \").map(&:to_i)\n  result = count_numbers(n.to_i, a)\n  results << (result == outputs[index])\nend\n\nresults.to_s\n","delphi":"program FurikProblem;\n\nvar\n  n: Integer;\n  a: array[0..9] of Integer;\n  count: Int64;\n\nfunction CountNumbers(length: Integer; digitCounts: array of Integer; currentNumber: Integer): Int64;\nvar\n  i: Integer;\nbegin\n  if length = 0 then\n  begin\n    Result := 1;\n    Exit;\n  end;\n\n  Result := 0;\n\n  for i := currentNumber to 9 do\n  begin\n    if digitCounts[i] < a[i] then\n    begin\n      digitCounts[i] := digitCounts[i] + 1;\n      Result := Result + CountNumbers(length - 1, digitCounts, i);\n      digitCounts[i] := digitCounts[i] - 1;\n    end;\n  end;\nend;\n\nbegin\n  ReadLn(n);\n\n  for i := 0 to 9 do\n    Read(a[i]);\n\n  count := 0;\n\n  for i := 1 to n do\n  begin\n    count := count + CountNumbers(i, a, 0);\n  end;\n\n  WriteLn(count mod 1000000007);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\ta := make([]int, 10)\\n\\tfor i := 0; i < 10; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\ta[i], _ = strconv.Atoi(scanner.Text())\\n\\t}\\n\\n\\tcount := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tcount += countNumbers(i, a, 0)\\n\\t}\\n\\n\\tfmt.Println(count % 1000000007)\\n}\\n\\nfunc countNumbers(n int, a []int, digit int) int {\\n\\tif n == 0 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tcount := 0\\n\\n\\tfor i := digit; i < 10; i++ {\\n\\t\\tif a[i] > 0 {\\n\\t\\t\\ta[i]--\\n\\t\\t\\tcount += countNumbers(n-1, a, i)\\n\\t\\t\\ta[i]++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}","Javascript":"function countNumbers(n, a) {\n    const mod = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j <= 9; j++) {\n            if (a[j] <= i) {\n                dp[i] = (dp[i] + dp[i - a[j]]) % mod;\n            }\n        }\n    }\n\n    return dp[n];\n}\n\nconst inputs = ['1\\n0 0 0 0 0 0 0 0 0 1\\n', '2\\n1 1 0 0 0 0 0 0 0 0\\n', '3\\n1 1 0 0 0 0 0 0 0 0\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    const lines = inputs[i].split('\\\\n');\n    const n = parseInt(lines[0]);\n    const a = lines[1].split(' ').map(Number);\n    const result = countNumbers(n, a);\n    outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val a = IntArray(10)\n    for (i in 0 until 10) {\n        a[i] = scanner.nextInt()\n    }\n    val dp = Array(n + 1) { LongArray(1024) }\n    dp[0][0] = 1\n    for (i in 1..n) {\n        for (mask in 0 until 1024) {\n            for (digit in 0 until 10) {\n                if (a[digit] > 0 && (mask and (1 shl digit)) == 0) {\n                    dp[i][mask or (1 shl digit)] = (dp[i][mask or (1 shl digit)] + dp[i - 1][mask]) % 1000000007\n                }\n            }\n        }\n    }\n    var result = 0L\n    for (mask in 0 until 1024) {\n        if (Integer.bitCount(mask) >= a.sum()) {\n            result = (result + dp[n][mask]) % 1000000007\n        }\n    }\n    println(result)\n}","PHP":"\n<?php\n\nfunction countNumbers($n, $a) {\n    $mod = 1000000007;\n    $dp = array_fill(0, $n + 1, array_fill(0, 10, 0));\n    $dp[0][0] = 1;\n\n    for ($i = 1; $i <= $n; $i++) {\n        for ($j = 0; $j <= 9; $j++) {\n            for ($k = $a[$j]; $k <= $i; $k++) {\n                $dp[$i][$j] = ($dp[$i][$j] + $dp[$i - $k][$j - 1]) % $mod;\n            }\n        }\n    }\n\n    $result = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        for ($j = 1; $j <= 9; $j++) {\n            $result = ($result + $dp[$i][$j]) % $mod;\n        }\n    }\n\n    return $result;\n}\n\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents(\\\"php:\/\/stdin\\\")));\n$n = intval($input[0]);\n$a = array_map('intval', explode(\\\" \\\", $input[1]));\n\n$output = countNumbers($n, $a);\necho $output;\n?>\n","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint countNumbers(int n, int[] a)\\r\\n{\\r\\n    int[][] dp = new int[][](n + 1, 10);\\r\\n    dp[0][0] = 1;\\r\\n\\r\\n    for (int i = 1; i <= n; i++)\\r\\n    {\\r\\n        for (int j = 1; j <= 9; j++)\\r\\n        {\\r\\n            for (int k = a[j]; k <= i; k++)\\r\\n            {\\r\\n                dp[i][j] += dp[i - k][j - 1];\\r\\n                dp[i][j] %= 1000000007;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int result = 0;\\r\\n\\r\\n    for (int i = 0; i <= n; i++)\\r\\n    {\\r\\n        result += dp[i][9];\\r\\n        result %= 1000000007;\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] a = new int[10];\\r\\n\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    for (int i = 0; i < 10; i++)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    int answer = countNumbers(n, a);\\r\\n\\r\\n    writeln(to!string(answer));\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_numbers {\n    my ($n, @a) = @_;\n\n    my $mod = 1000000007;\n    my @dp;\n    $dp[0][0] = 1;\n\n    for my $i (1..$n) {\n        for my $j (0..9) {\n            for my $k ($a[$j]..$i) {\n                $dp[$i][$j] += $dp[$i-$k][$j-1] % $mod;\n            }\n        }\n    }\n\n    my $result = 0;\n    for my $i (0..9) {\n        $result += $dp[$n][$i] % $mod;\n    }\n\n    return $result % $mod;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, @a) = split ' ', $input;\n\n# Call the function and print the result\nmy $result = count_numbers($n, @a);\nprint $result;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    input.clear();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let a: Vec<usize> = input\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut dp = vec![vec![0; n + 1]; 10];\\n\\n    for i in 0..10 {\\n        dp[i][0] = 1;\\n        for j in 1..=n {\\n            for k in a[i]..=j {\\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % 1000000007;\\n            }\\n        }\\n    }\\n\\n    let mut result = 0;\\n    for i in 0..=n {\\n        result = (result + dp[9][i]) % 1000000007;\\n    }\\n\\n    println!(\\\"{}\\\", result);\\n}"}
{"title":"A. System of Equations","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a system of equations:  You should count, how many there are pairs of integers (a,b) (0\u2264a,b) which satisfy the system.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"A single line contains two integers n,m (1\u2264n,m\u22641000) \u2014 the parameters of the system. The numbers on the line are separated by a space.\n","output_spec":"On a single line print the answer to the problem.\n","notes":"In the first sample the suitable pair is integers (3,0). In the second sample the suitable pair is integers (3,5). In the third sample there is no suitable pair.\n","sample_inputs":["9 3\n","14 28\n","4 20\n"],"sample_outputs":["1\n","1\n","0\n"],"id":"214-A","difficulty":800,"tags":["brute+force"],"src_uid":"03caf4ddf07c1783e42e9f9085cc6efd","C++":"#include <iostream>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    int count = 0;\\n\\n    for (int a = 0; a <= n; a++) {\\n        for (int b = 0; b <= m; b++) {\\n            if ((a * a + b) == n && (a + b * b) == m) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class SystemOfEquations {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int count = 0;\\n\\n        for (int a = 0; a <= n; a++) {\\n            for (int b = 0; b <= m; b++) {\\n                if ((a * a + b) == n && (a + b * b) == m) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}","Python":"def count_pairs(n, m):\\n    count = 0\\n    for a in range(n+1):\\n        for b in range(m+1):\\n            if a**2 + b == n and a + b**2 == m:\\n                count += 1\\n    return count\\n\\ninput_data = ['9 3\\\\n', '14 28\\\\n', '4 20\\\\n']\\noutput_data = []\\n\\nfor data in input_data:\\n    n, m = map(int, data.strip().split())\\n    result = count_pairs(n, m)\\n    output_data.append(str(result) + '\\\\n')\\n\\noutput = [{'version': 'Python 3', 'source code': 'def count_pairs(n, m):\\n    count = 0\\n    for a in range(n+1):\\n        for b in range(m+1):\\n            if a**2 + b == n and a + b**2 == m:\\n                count += 1\\n    return count\\n\\ninput_data = ['9 3\\\\n', '14 28\\\\n', '4 20\\\\n']\\noutput_data = []\\n\\nfor data in input_data:\\n    n, m = map(int, data.strip().split())\\n    result = count_pairs(n, m)\\n    output_data.append(str(result) + '\\\\n')\\n\\noutput = ' + str(output_data) + '}']\\nprint(output)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int count = 0;\\n    for (int a = 0; a <= n; a++) {\\n        for (int b = 0; b <= m; b++) {\\n            if ((a*a + b) == n && (a + b*b) == m) {\\n                count++;\\n            }\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", count);\\n    return 0;\\n}","C#":"using System;\n\nnamespace MathProblem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = { \\\"9 3\\\", \\\"14 28\\\", \\\"4 20\\\" };\n            \n            foreach (string input in inputs)\n            {\n                string[] parameters = input.Split(' ');\n                int n = int.Parse(parameters[0]);\n                int m = int.Parse(parameters[1]);\n                \n                int count = 0;\n                \n                for (int a = 0; a <= n; a++)\n                {\n                    for (int b = 0; b <= m; b++)\n                    {\n                        if (a * a + b == n && a + b * b == m)\n                        {\n                            count++;\n                        }\n                    }\n                }\n                \n                Console.WriteLine(count);\n            }\n        }\n    }\n}","Ruby":"\ndef count_pairs(n, m)\n  count = 0\n  (0..n).each do |a|\n    (0..m).each do |b|\n      if a**2 + b == n && a + b**2 == m\n        count += 1\n      end\n    end\n  end\n  return count\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\n\noutput = count_pairs(n, m)\nputs output\n","delphi":"program SystemOfEquations;\\n\\nvar\\n  n, m, count: Integer;\\n  a, b: Integer;\\nbegin\\n  \/\/ Read input\\n  ReadLn(n, m);\\n  \\n  \/\/ Initialize count\\n  count := 0;\\n  \\n  \/\/ Loop through all possible values of a and b\\n  for a := 0 to n do\\n  begin\\n    for b := 0 to m do\\n    begin\\n      \/\/ Check if the pair (a, b) satisfies the system of equations\\n      if (a + b * b = n) and (a * a + b = m) then\\n      begin\\n        \/\/ Increment count if the pair satisfies the system\\n        count := count + 1;\\n      end;\\n    end;\\n  end;\\n  \\n  \/\/ Print the answer\\n  WriteLn(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tcount := 0\\n\\n\\tfor a := 0; a <= n; a++ {\\n\\t\\tfor b := 0; b <= m; b++ {\\n\\t\\t\\tif a*a+b == n && a+b*b == m {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function countPairs(input) {\n  const [n, m] = input.split(' ').map(Number);\n  let count = 0;\n\n  for (let a = 0; a <= n; a++) {\n    for (let b = 0; b <= m; b++) {\n      if (a * a + b === n && a + b * b === m) {\n        count++;\n      }\n    }\n  }\n\n  return count.toString();\n}\n\nconst inputs = ['9 3\\n', '14 28\\n', '4 20\\n'];\nconst outputs = inputs.map(countPairs);\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val m = input[1]\\n\\n    var count = 0\\n\\n    for (a in 0..n) {\\n        for (b in 0..m) {\\n            if (a * a + b == n && a + b * b == m) {\\n                count++\\n            }\\n        }\\n    }\\n\\n    println(count)\\n}","PHP":"<?php\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$m = intval($input[1]);\\n\\n$count = 0;\\n\\nfor ($a = 0; $a <= $n; $a++) {\\n    for ($b = 0; $b <= $m; $b++) {\\n        if (($a + $b * $b) == $n && ($a * $a + $b) == $m) {\\n            $count++;\\n        }\\n    }\\n}\\n\\necho $count;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    for (int a = 0; a <= n; a++)\\r\\n    {\\r\\n        for (int b = 0; b <= m; b++)\\r\\n        {\\r\\n            if ((a * a) + b == n && a + (b * b) == m)\\r\\n            {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_pairs {\n    my ($n, $m) = @_;\n\n    my $count = 0;\n\n    for my $a (0..$n) {\n        for my $b (0..$m) {\n            if (($a + $b) ** 2 + $a == $n && ($a + $b) ** 2 - $b == $m) {\n                $count++;\n            }\n        }\n    }\n\n    return $count;\n}\n\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\nmy $result = count_pairs($n, $m);\nprint $result;\n","Rust":"fn main() {\\n    let input = String::from(\\\"9 3\\\");\\n    let mut iter = input.split_whitespace();\\n    let n: i32 = iter.next().unwrap().parse().unwrap();\\n    let m: i32 = iter.next().unwrap().parse().unwrap();\\n\\n    let mut count = 0;\\n\\n    for a in 0..=n {\\n        for b in 0..=m {\\n            if a*a + b == n && a + b*b == m {\\n                count += 1;\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"B. Hometask","description":"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?You are given a set of digits, your task is to find the maximum integer that you can make from these digits. The made number must be divisible by 2, 3, 5 without a residue. It is permitted to use not all digits from the set, it is forbidden to use leading zeroes.Each digit is allowed to occur in the number the same number of times it occurs in the set.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"A single line contains a single integer n (1\u2264n\u2264100000) \u2014 the number of digits in the set. The second line contains n digits, the digits are separated by a single space. \n","output_spec":"On a single line print the answer to the problem. If such number does not exist, then you should print -1.\n","notes":"In the first sample there is only one number you can make \u2014 0. In the second sample the sought number is 5554443330. In the third sample it is impossible to make the required number.\n","sample_inputs":["1\n0\n","11\n3 4 5 4 5 3 5 3 4 4 0\n","8\n3 2 5 1 5 2 2 3\n"],"sample_outputs":["0\n","5554443330\n","-1\n"],"id":"214-B","difficulty":1600,"tags":["brute+force","constructive+algorithms","greedy","math"],"src_uid":"b263917e47e1c84340bcb1c77999fd7e","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isDivisible(vector<int>& digits, int num) {\\n    int sum = 0;\\n    for (int digit : digits) {\\n        sum += digit;\\n    }\\n    return sum % num == 0;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> digits(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> digits[i];\\n    }\\n    sort(digits.rbegin(), digits.rend());\\n    if (digits[0] == 0) {\\n        cout << 0 << endl;\\n        return 0;\\n    }\\n    if (!isDivisible(digits, 2) || !isDivisible(digits, 3) || !isDivisible(digits, 5)) {\\n        cout << -1 << endl;\\n        return 0;\\n    }\\n    for (int digit : digits) {\\n        cout << digit;\\n    }\\n    cout << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        String[] digits = scanner.nextLine().split(\\\" \\\");\n        \n        int[] count = new int[10];\n        int sum = 0;\n        \n        for (String digit : digits) {\n            int num = Integer.parseInt(digit);\n            count[num]++;\n            sum += num;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        \n        if (count[0] == 0) {\n            System.out.println(-1);\n            return;\n        }\n        \n        if (sum % 3 == 0) {\n            for (int i = 9; i >= 0; i--) {\n                for (int j = 0; j < count[i]; j++) {\n                    result.append(i);\n                }\n            }\n            \n            System.out.println(result);\n            return;\n        }\n        \n        int remainder = sum % 3;\n        int remove1 = -1;\n        int remove2 = -1;\n        \n        if (remainder == 1) {\n            if (count[1] > 0) {\n                remove1 = 1;\n            } else if (count[4] > 0) {\n                remove1 = 4;\n            } else if (count[7] > 0) {\n                remove1 = 7;\n            } else if (count[2] > 1) {\n                remove1 = 2;\n                remove2 = 2;\n            } else if (count[5] > 1) {\n                remove1 = 5;\n                remove2 = 5;\n            } else if (count[8] > 1) {\n                remove1 = 8;\n                remove2 = 8;\n            } else {\n                System.out.println(-1);\n                return;\n            }\n        } else if (remainder == 2) {\n            if (count[2] > 0) {\n                remove1 = 2;\n            } else if (count[5] > 0) {\n                remove1 = 5;\n            } else if (count[8] > 0) {\n                remove1 = 8;\n            } else if (count[1] > 1) {\n                remove1 = 1;\n                remove2 = 1;\n            } else if (count[4] > 1) {\n                remove1 = 4;\n                remove2 = 4;\n            } else if (count[7] > 1) {\n                remove1 = 7;\n                remove2 = 7;\n            } else {\n                System.out.println(-1);\n                return;\n            }\n        }\n        \n        for (int i = 9; i >= 0; i--) {\n            if (i != remove1 && i != remove2) {\n                for (int j = 0; j < count[i]; j++) {\n                    result.append(i);\n                }\n            }\n        }\n        \n        System.out.println(result);\n    }\n}","Python":"def find_max_number(n, digits):\n    count = [0] * 10\n    total = 0\n    \n    for digit in digits:\n        count[int(digit)] += 1\n        total += int(digit)\n    \n    if count[0] == 0:\n        return -1\n    \n    if total % 3 != 0:\n        for i in range(1, 10):\n            if count[i] > 0 and i % 3 == total % 3:\n                count[i] -= 1\n                total -= i\n                break\n    \n    result = \"\"\n    \n    for i in range(9, -1, -1):\n        result += str(i) * count[i]\n    \n    return result\n\n# Read input\nn = int(input())\ndigits = input().split()\n\n# Call the function and print the result\nprint(find_max_number(n, digits))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint compare(const void *a, const void *b) {\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int digits[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &digits[i]);\\n    }\\n    qsort(digits, n, sizeof(int), compare);\\n    int sum = 0;\\n    for (int i = 0; i < n; i++) {\\n        sum += digits[i];\\n    }\\n    if (sum == 0) {\\n        printf(\\\"0\\\\n\\\");\\n        return 0;\\n    }\\n    if (digits[n-1] != 0 || sum % 3 != 0) {\\n        printf(\\\"-1\\\\n\\\");\\n        return 0;\\n    }\\n    for (int i = n-1; i >= 0; i--) {\\n        printf(\\\"%d\\\", digits[i]);\\n    }\\n    printf(\\\"\\\\n\\\");\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        List<int> digits = Console.ReadLine().Split().Select(int.Parse).ToList();\n        \n        int[] count = new int[10];\n        foreach (int digit in digits)\n        {\n            count[digit]++;\n        }\n        \n        int sum = digits.Sum();\n        if (sum % 3 != 0 || !digits.Contains(0))\n        {\n            Console.WriteLine(-1);\n            return;\n        }\n        \n        List<int> result = new List<int>();\n        for (int i = 9; i >= 0; i--)\n        {\n            while (count[i] > 0)\n            {\n                result.Add(i);\n                count[i]--;\n            }\n        }\n        \n        Console.WriteLine(string.Join(\"\", result));\n    }\n}","Ruby":"\ndef find_max_number(n, digits)\n  # Check if the sum of digits is divisible by 3\n  sum = digits.sum\n  return -1 if sum % 3 != 0\n\n  # Sort the digits in descending order\n  digits.sort!.reverse!\n\n  # Check if there is at least one even digit\n  even_digit = digits.find { |digit| digit % 2 == 0 }\n  return -1 if even_digit.nil?\n\n  # Build the maximum number\n  max_number = digits.join('').to_i\n\n  # Check if the maximum number is divisible by 5\n  return -1 if max_number % 5 != 0\n\n  max_number\nend\n\n# Read input\nn = gets.to_i\ndigits = gets.split.map(&:to_i)\n\n# Find the maximum number\nmax_number = find_max_number(n, digits)\n\n# Print the result\nputs max_number\n","delphi":"program MaximumInteger;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction IsDivisibleBy2(num: string): Boolean;\\nvar\\n  lastDigit: Integer;\\nbegin\\n  lastDigit := StrToInt(num[length(num)]);\\n  Result := (lastDigit mod 2 = 0);\\nend;\\n\\nfunction IsDivisibleBy3(num: string): Boolean;\\nvar\\n  i, sum: Integer;\\nbegin\\n  sum := 0;\\n  for i := 1 to length(num) do\\n    sum := sum + StrToInt(num[i]);\\n  Result := (sum mod 3 = 0);\\nend;\\n\\nfunction IsDivisibleBy5(num: string): Boolean;\\nvar\\n  lastDigit: Integer;\\nbegin\\n  lastDigit := StrToInt(num[length(num)]);\\n  Result := (lastDigit = 0) or (lastDigit = 5);\\nend;\\n\\nfunction FindMaximumInteger(n: Integer; digits: array of Integer): string;\\nvar\\n  i, j: Integer;\\n  num: string;\\nbegin\\n  Result := '-1';\\n  for i := n downto 1 do\\n  begin\\n    num := '';\\n    for j := 0 to n-1 do\\n      num := num + IntToStr(digits[j]);\\n    if (IsDivisibleBy2(num) and IsDivisibleBy3(num) and IsDivisibleBy5(num)) then\\n    begin\\n      Result := num;\\n      Exit;\\n    end;\\n    NextPermutation(digits);\\n  end;\\nend;\\n\\nvar\\n  n, i: Integer;\\n  digits: array of Integer;\\nbegin\\n  ReadLn(n);\\n  SetLength(digits, n);\\n  for i := 0 to n-1 do\\n    Read(digits[i]);\\n  WriteLn(FindMaximumInteger(n, digits));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tdigits := make([]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&digits[i])\\n\\t}\\n\\n\\t\/\/ Sort the digits in descending order\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(digits)))\\n\\n\\t\/\/ Check if the sum of digits is divisible by 3\\n\\tsum := 0\\n\\tfor _, digit := range digits {\\n\\t\\tsum += digit\\n\\t}\\n\\tif sum%3 != 0 {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\t\/\/ Check if there is at least one even digit\\n\\tevenDigit := -1\\n\\tfor _, digit := range digits {\\n\\t\\tif digit%2 == 0 {\\n\\t\\t\\tevenDigit = digit\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ If there is no even digit, it is impossible to make the required number\\n\\tif evenDigit == -1 {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\t\/\/ Build the maximum number\\n\\tmaxNumber := strconv.Itoa(evenDigit)\\n\\tfor _, digit := range digits {\\n\\t\\tif digit != evenDigit {\\n\\t\\t\\tmaxNumber += strconv.Itoa(digit)\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxNumber)\\n}","Javascript":"function findMaxNumber(n, digits) {\n    let count = new Array(10).fill(0);\n    let sum = 0;\n    \n    for (let i = 0; i < n; i++) {\n        let digit = parseInt(digits[i]);\n        count[digit]++;\n        sum += digit;\n    }\n    \n    if (count[0] === 0 || sum % 3 !== 0) {\n        return '-1';\n    }\n    \n    let result = '';\n    \n    for (let i = 9; i >= 0; i--) {\n        result += i.toString().repeat(count[i]);\n    }\n    \n    return result;\n}\n\n\/\/ Sample inputs\nlet inputs = [\n    { n: 1, digits: [0] },\n    { n: 11, digits: [3, 4, 5, 4, 5, 3, 5, 3, 4, 4, 0] },\n    { n: 8, digits: [3, 2, 5, 1, 5, 2, 2, 3] }\n];\n\nlet outputs = [];\n\nfor (let input of inputs) {\n    let result = findMaxNumber(input.n, input.digits);\n    outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val digits = IntArray(n)\n    for (i in 0 until n) {\n        digits[i] = scanner.nextInt()\n    }\n    val result = findMaxDivisibleNumber(digits)\n    println(result)\n}\n\nfun findMaxDivisibleNumber(digits: IntArray): String {\n    val count = IntArray(10)\n    for (digit in digits) {\n        count[digit]++\n    }\n    val divisibleByTwo = intArrayOf(0, 2, 4, 6, 8)\n    val divisibleByThree = intArrayOf(0, 3, 6, 9)\n    val divisibleByFive = intArrayOf(0, 5)\n    val sum = digits.sum()\n    if (sum == 0) {\n        return \"0\"\n    }\n    if (sum % 3 != 0) {\n        return \"-1\"\n    }\n    val result = StringBuilder()\n    for (i in 9 downTo 0) {\n        while (count[i] > 0) {\n            if (i in divisibleByTwo && (sum - i) % 3 == 0) {\n                result.append(i)\n                count[i]--\n                sum -= i\n            } else if (i in divisibleByThree && (sum - i) % 3 == 0) {\n                result.append(i)\n                count[i]--\n                sum -= i\n            } else if (i in divisibleByFive && (sum - i) % 3 == 0) {\n                result.append(i)\n                count[i]--\n                sum -= i\n            } else {\n                count[i]--\n            }\n        }\n    }\n    if (result.isEmpty()) {\n        return \"-1\"\n    }\n    return result.toString()\n}","PHP":"<?php\\n\\nfunction findMaxNumber($n, $digits) {\\n    \/\/ Count the frequency of each digit\\n    $frequency = array_count_values($digits);\\n\\n    \/\/ Check if there are enough digits to form a number divisible by 2, 3, and 5\\n    if (!isset($frequency[0]) || $frequency[0] < 1) {\\n        return -1;\\n    }\\n    if (!isset($frequency[2]) || $frequency[2] < 1) {\\n        return -1;\\n    }\\n    if (!isset($frequency[5]) || $frequency[5] < 1) {\\n        return -1;\\n    }\\n\\n    \/\/ Remove one occurrence of each required digit\\n    $frequency[0]--;\\n    $frequency[2]--;\\n    $frequency[5]--;\\n\\n    \/\/ Sort the remaining digits in descending order\\n    arsort($frequency);\\n\\n    \/\/ Construct the maximum number\\n    $maxNumber = \\\"\\\";\\n    foreach ($frequency as $digit => $count) {\\n        $maxNumber .= str_repeat($digit, $count);\\n    }\\n\\n    return $maxNumber;\\n}\\n\\n\/\/ Read input\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n$n = intval($input[0]);\\n$digits = array_map('intval', explode(\\\" \\\", $input[1]));\\n\\n\/\/ Find the maximum number\\n$maxNumber = findMaxNumber($n, $digits);\\n\\n\/\/ Print the result\\necho $maxNumber . \\\"\\\\n\\\";\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] digits;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int digit;\\r\\n        readf(\\\"%d\\\", &digit);\\r\\n        digits ~= digit;\\r\\n    }\\r\\n\\r\\n    int[] maxNumber;\\r\\n    foreach (digit; digits)\\r\\n    {\\r\\n        maxNumber ~= digit;\\r\\n    }\\r\\n\\r\\n    maxNumber.sortDesc();\\r\\n\\r\\n    int sum = maxNumber.reduce!((a, b) => a + b);\\r\\n\\r\\n    if (sum % 3 == 0 && maxNumber[$-1] % 2 == 0 && maxNumber.contains(0))\\r\\n    {\\r\\n        writeln(maxNumber.join);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(-1);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_max_number {\n    my ($n, $digits) = @_;\n\n    # Count the frequency of each digit\n    my %freq;\n    foreach my $digit (@$digits) {\n        $freq{$digit}++;\n    }\n\n    # Check if there are enough digits to form a number divisible by 2, 3, and 5\n    if ($freq{0} && $freq{2} && $freq{4} && $freq{6} && $freq{8}) {\n        # Remove the used digits from the frequency count\n        $freq{0}--;\n        $freq{2}--;\n        $freq{4}--;\n        $freq{6}--;\n        $freq{8}--;\n\n        # Construct the maximum number divisible by 2, 3, and 5\n        my $max_number = '0';\n        foreach my $digit (9, 7, 5, 3, 1) {\n            if ($freq{$digit}) {\n                $max_number .= $digit x $freq{$digit};\n            }\n        }\n\n        return $max_number;\n    }\n\n    return -1;\n}\n\n# Read input\nmy $n = <>;\nchomp($n);\nmy $digits = <>;\nchomp($digits);\nmy @digits = split(' ', $digits);\n\n# Find the maximum number\nmy $max_number = find_max_number($n, \\@digits);\n\n# Print the result\nprint \"$max_number\\n\";\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    input.clear();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let digits: Vec<u32> = input\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut count: [usize; 10] = [0; 10];\\n    for digit in &digits {\\n        count[*digit as usize] += 1;\\n    }\\n\\n    let mut number: Vec<u32> = Vec::new();\\n    for i in (0..10).rev() {\\n        if i % 2 == 0 {\\n            for _ in 0..count[i] {\\n                number.push(i as u32);\\n            }\\n        }\\n    }\\n\\n    let sum: u32 = number.iter().sum();\\n\\n    if sum % 3 == 0 && number.contains(&0) {\\n        number.sort();\\n        number.reverse();\\n        let result: String = number\\n            .iter()\\n            .map(|x| x.to_string())\\n            .collect();\\n        println!(\\\"{}\\\", result);\\n    } else {\\n        println!(\\\"-1\\\");\\n    }\\n}"}
{"title":"A. Bicycle Chain","description":"Vasya's bicycle chain drive consists of two parts: n stars are attached to the pedal axle, m stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.We know that the i-th star on the pedal axle has ai (0<a1<a2<...<an) teeth, and the j-th star on the rear wheel axle has bj (0<b1<b2<...<bm) teeth. Any pair (i,j) (1\u2264i\u2264n;\u00a01\u2264j\u2264m) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (i,j) has a gear ratio, equal to the value .Since Vasya likes integers, he wants to find such gears (i,j), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all \"integer\" gears (i,j) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains integer n (1\u2264n\u226450) \u2014 the number of stars on the bicycle's pedal axle. The second line contains n integers a1,a2,...,an (1\u2264ai\u226410^4) in the order of strict increasing.\nThe third input line contains integer m (1\u2264m\u226450) \u2014 the number of stars on the rear wheel axle. The fourth line contains m integers b1,b2,...,bm (1\u2264bi\u226410^4) in the order of strict increasing.\nIt is guaranteed that there exists at least one gear (i,j), that its gear ratio is an integer. The numbers on the lines are separated by spaces.\n","output_spec":"Print the number of \"integer\" gears with the maximum ratio among all \"integer\" gears.\n","notes":"In the first sample the maximum \"integer\" gear ratio equals 3. There are two gears that have such gear ratio. For one of them a1=4,b1=12, and for the other a2=5,b3=15.\n","sample_inputs":["2\n4 5\n3\n12 13 15\n","4\n1 2 3 4\n5\n10 11 12 13 14\n"],"sample_outputs":["2\n","1\n"],"id":"215-A","difficulty":900,"tags":["brute+force","implementation"],"src_uid":"102667eaa3aee012fef70f4192464674","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n    cin >> m;\\n    vector<int> b(m);\\n    for (int i = 0; i < m; i++) {\\n        cin >> b[i];\\n    }\\n\\n    int maxRatio = 0;\\n    int count = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (b[j] % a[i] == 0) {\\n                int ratio = b[j] \/ a[i];\\n                if (ratio > maxRatio) {\\n                    maxRatio = ratio;\\n                    count = 1;\\n                } else if (ratio == maxRatio) {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class BicycleChainDrive {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        \n        int m = scanner.nextInt();\n        int[] b = new int[m];\n        for (int i = 0; i < m; i++) {\n            b[i] = scanner.nextInt();\n        }\n        \n        int maxRatio = 0;\n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (b[j] % a[i] == 0) {\n                    int ratio = b[j] \/ a[i];\n                    if (ratio > maxRatio) {\n                        maxRatio = ratio;\n                        count = 1;\n                    } else if (ratio == maxRatio) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(count);\n    }\n}","Python":"def find_integer_gears(n, a, m, b):\\n    max_ratio = 0\\n    count = 0\\n    for i in range(n):\\n        for j in range(m):\\n            if b[j] % a[i] == 0:\\n                ratio = b[j] \/\/ a[i]\\n                if ratio > max_ratio:\\n                    max_ratio = ratio\\n                    count = 1\\n                elif ratio == max_ratio:\\n                    count += 1\\n    return str(count)\\n\\ninput_data = input().split('\\\\n')\\nn = int(input_data[0])\\na = list(map(int, input_data[1].split()))\\nm = int(input_data[2])\\nb = list(map(int, input_data[3].split()))\\n\\nprint(find_integer_gears(n, a, m, b))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    scanf(\\\"%d\\\", &m);\\n    int b[m];\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%d\\\", &b[i]);\\n    }\\n\\n    int max_ratio = 0;\\n    int count = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (b[j] % a[i] == 0) {\\n                int ratio = b[j] \/ a[i];\\n                if (ratio > max_ratio) {\\n                    max_ratio = ratio;\\n                    count = 1;\\n                } else if (ratio == max_ratio) {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace BicycleChain\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] pedalAxle = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n            int m = int.Parse(Console.ReadLine());\n            int[] rearAxle = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            int maxRatio = 0;\n            int count = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (rearAxle[j] % pedalAxle[i] == 0)\n                    {\n                        int ratio = rearAxle[j] \/ pedalAxle[i];\n                        if (ratio > maxRatio)\n                        {\n                            maxRatio = ratio;\n                            count = 1;\n                        }\n                        else if (ratio == maxRatio)\n                        {\n                            count++;\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n    }\n}","Ruby":"\n# Read input\nn = gets.to_i\na = gets.split.map(&:to_i)\nm = gets.to_i\nb = gets.split.map(&:to_i)\n\n# Initialize variables\nmax_ratio = 0\ncount = 0\n\n# Iterate through all possible gear combinations\n(0...n).each do |i|\n  (0...m).each do |j|\n    # Calculate gear ratio\n    ratio = b[j].to_f \/ a[i].to_f\n    \n    # Check if gear ratio is an integer\n    if ratio % 1 == 0\n      # Update maximum gear ratio and count\n      if ratio > max_ratio\n        max_ratio = ratio\n        count = 1\n      elsif ratio == max_ratio\n        count += 1\n      end\n    end\n  end\nend\n\n# Print the number of gears with maximum ratio\nputs count\n","delphi":"program BicycleChain;\\n\\nvar\\n  n, m, i, j, maxRatio, count: integer;\\n  a, b: array[1..50] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(a[i]);\\n  readln;\\n  readln(m);\\n  for i := 1 to m do\\n    read(b[i]);\\n\\n  maxRatio := 0;\\n  count := 0;\\n\\n  for i := 1 to n do\\n  begin\\n    for j := 1 to m do\\n    begin\\n      if (b[j] mod a[i] = 0) and (b[j] div a[i] > maxRatio) then\\n      begin\\n        maxRatio := b[j] div a[i];\\n        count := 1;\\n      end\\n      else if (b[j] mod a[i] = 0) and (b[j] div a[i] = maxRatio) then\\n        count := count + 1;\\n    end;\\n  end;\\n\\n  writeln(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scan(&n)\\n\\n\\ta := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&a[i])\\n\\t}\\n\\n\\tfmt.Scan(&m)\\n\\n\\tb := make([]int, m)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfmt.Scan(&b[i])\\n\\t}\\n\\n\\tmaxRatio := 0\\n\\tcount := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif b[j]%a[i] == 0 {\\n\\t\\t\\t\\tratio := b[j] \/ a[i]\\n\\t\\t\\t\\tif ratio > maxRatio {\\n\\t\\t\\t\\t\\tmaxRatio = ratio\\n\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\t\\t} else if ratio == maxRatio {\\n\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function findIntegerGears(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const a = lines[1].split(' ').map(Number);\n  const m = parseInt(lines[2]);\n  const b = lines[3].split(' ').map(Number);\n\n  let maxRatio = 0;\n  let count = 0;\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (b[j] % a[i] === 0) {\n        const ratio = b[j] \/ a[i];\n        if (ratio > maxRatio) {\n          maxRatio = ratio;\n          count = 1;\n        } else if (ratio === maxRatio) {\n          count++;\n        }\n      }\n    }\n  }\n\n  return count.toString();\n}\n\nconst input = '2\\\\n4 5\\\\n3\\\\n12 13 15\\\\n';\nconsole.log(findIntegerGears(input));","Kotlin":"import java.util.*\n\nfun main() {\n    val input = Scanner(System.`in`)\n    val n = input.nextInt()\n    val a = IntArray(n)\n    for (i in 0 until n) {\n        a[i] = input.nextInt()\n    }\n    val m = input.nextInt()\n    val b = IntArray(m)\n    for (i in 0 until m) {\n        b[i] = input.nextInt()\n    }\n    \n    var maxRatio = 0\n    var count = 0\n    \n    for (i in 0 until n) {\n        for (j in 0 until m) {\n            if (b[j] % a[i] == 0) {\n                val ratio = b[j] \/ a[i]\n                if (ratio > maxRatio) {\n                    maxRatio = ratio\n                    count = 1\n                } else if (ratio == maxRatio) {\n                    count++\n                }\n            }\n        }\n    }\n    \n    println(count)\n}","PHP":"<?php\\n\\n\/\/ Read input\\n$stdin = fopen('php:\/\/stdin', 'r');\\n$n = intval(fgets($stdin));\\n$a = array_map('intval', explode(' ', fgets($stdin)));\\n$m = intval(fgets($stdin));\\n$b = array_map('intval', explode(' ', fgets($stdin)));\\n\\n\/\/ Find maximum gear ratio\\n$maxRatio = 0;\\n$maxCount = 0;\\n\\nfor ($i = 0; $i < $n; $i++) {\\n    for ($j = 0; $j < $m; $j++) {\\n        if ($b[$j] % $a[$i] == 0) {\\n            $ratio = $b[$j] \/ $a[$i];\\n            if ($ratio > $maxRatio) {\\n                $maxRatio = $ratio;\\n                $maxCount = 1;\\n            } elseif ($ratio == $maxRatio) {\\n                $maxCount++;\\n            }\\n        }\\n    }\\n}\\n\\n\/\/ Print output\\necho $maxCount;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] a;\\r\\n    int m;\\r\\n    int[] b;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    a = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    readf(\\\"%d\\\", &m);\\r\\n    b = new int[m];\\r\\n    foreach (i; 0..m)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &b[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Find maximum gear ratio\\r\\n    int maxRatio = 0;\\r\\n    int maxRatioCount = 0;\\r\\n\\r\\n    foreach (ai; a)\\r\\n    {\\r\\n        foreach (bj; b)\\r\\n        {\\r\\n            int ratio = bj \/ ai;\\r\\n\\r\\n            if (bj % ai == 0 && ratio >= maxRatio)\\r\\n            {\\r\\n                if (ratio > maxRatio)\\r\\n                {\\r\\n                    maxRatio = ratio;\\r\\n                    maxRatioCount = 1;\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    maxRatioCount++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print output\\r\\n    writeln(maxRatioCount);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\n# Read input\nmy $n = <>;\nmy @a = split ' ', <>;\nmy $m = <>;\nmy @b = split ' ', <>;\n\n# Initialize variables\nmy $max_ratio = 0;\nmy $count = 0;\n\n# Iterate through all possible gear combinations\nfor my $i (0..$n-1) {\n    for my $j (0..$m-1) {\n        # Calculate gear ratio\n        my $ratio = $b[$j] \/ $a[$i];\n        \n        # Check if gear ratio is an integer\n        if ($ratio == int($ratio)) {\n            # Check if gear ratio is greater than current maximum\n            if ($ratio > $max_ratio) {\n                $max_ratio = $ratio;\n                $count = 1;\n            } elsif ($ratio == $max_ratio) {\n                $count++;\n            }\n        }\n    }\n}\n\n# Print the number of gears with maximum ratio\nprint \"$count\\\\n\";\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    input.clear();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let a: Vec<usize> = input\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    input.clear();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let m: usize = input.trim().parse().unwrap();\\n\\n    input.clear();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let b: Vec<usize> = input\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut max_ratio = 0;\\n    let mut count = 0;\\n\\n    for i in 0..n {\\n        for j in 0..m {\\n            if b[j] % a[i] == 0 {\\n                let ratio = b[j] \/ a[i];\\n                if ratio > max_ratio {\\n                    max_ratio = ratio;\\n                    count = 1;\\n                } else if ratio == max_ratio {\\n                    count += 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"A. Ice Skating","description":"Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.We assume that Bajtek can only heap up snow drifts at integer coordinates.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of input contains a single integer n (1\u2264n\u2264100) \u2014 the number of snow drifts. Each of the following n lines contains two integers xi and yi (1\u2264xi,yi\u22641000) \u2014 the coordinates of the i-th snow drift.\nNote that the north direction coin\u0441ides with the direction of Oy axis, so the east direction coin\u0441ides with the direction of the Ox axis. All snow drift's locations are distinct.\n","output_spec":"Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.\n","notes":null,"sample_inputs":["2\n2 1\n1 2\n","2\n2 1\n4 1\n"],"sample_outputs":["1\n","0\n"],"id":"217-A","difficulty":1200,"tags":["brute+force","dfs+and+similar","dsu","graphs"],"src_uid":"cb4dbff31d967c3dab8fe0495eb871dc","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\nusing namespace std;\\n\\nstruct Point {\\n    int x, y;\\n};\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<Point> snowDrifts(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> snowDrifts[i].x >> snowDrifts[i].y;\\n    }\\n    int minX = snowDrifts[0].x, maxX = snowDrifts[0].x;\\n    int minY = snowDrifts[0].y, maxY = snowDrifts[0].y;\\n    for (int i = 1; i < n; i++) {\\n        minX = min(minX, snowDrifts[i].x);\\n        maxX = max(maxX, snowDrifts[i].x);\\n        minY = min(minY, snowDrifts[i].y);\\n        maxY = max(maxY, snowDrifts[i].y);\\n    }\\n    int numSnowDrifts = max(maxX - minX, maxY - minY) + 1;\\n    cout << numSnowDrifts - n << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class SnowDrifts {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] drifts = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            drifts[i][0] = scanner.nextInt();\n            drifts[i][1] = scanner.nextInt();\n        }\n        \n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        int count = n;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (find(parent, i) != find(parent, j)) {\n                    union(parent, i, j);\n                    count--;\n                }\n            }\n        }\n        \n        System.out.println(count - 1);\n    }\n    \n    private static int find(int[] parent, int i) {\n        if (parent[i] != i) {\n            parent[i] = find(parent, parent[i]);\n        }\n        return parent[i];\n    }\n    \n    private static void union(int[] parent, int i, int j) {\n        int rootI = find(parent, i);\n        int rootJ = find(parent, j);\n        parent[rootJ] = rootI;\n    }\n}","Python":"def create_snow_drifts(n, coordinates):\n    x_values = set()\n    y_values = set()\n    \n    for coordinate in coordinates:\n        x_values.add(coordinate[0])\n        y_values.add(coordinate[1])\n    \n    min_snow_drifts = max(len(x_values), len(y_values)) - n\n    \n    return str(min_snow_drifts)\n\nn = int(input())\ncoordinates = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    coordinates.append((x, y))\n\nprint(create_snow_drifts(n, coordinates))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int x[n], y[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d %d\\\", &x[i], &y[i]);\\n    }\\n    int count = 0;\\n    for (int i = 0; i < n; i++) {\\n        int flag = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (i != j && (x[i] == x[j] || y[i] == y[j])) {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag == 0) {\\n            count++;\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", count);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace SnowDrifts\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<int[]> snowDrifts = new List<int[]>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] coordinates = Console.ReadLine().Split();\n                int x = int.Parse(coordinates[0]);\n                int y = int.Parse(coordinates[1]);\n                snowDrifts.Add(new int[] { x, y });\n            }\n\n            int minSnowDrifts = GetMinSnowDrifts(snowDrifts);\n            Console.WriteLine(minSnowDrifts);\n        }\n\n        static int GetMinSnowDrifts(List<int[]> snowDrifts)\n        {\n            int minSnowDrifts = 0;\n\n            \/\/ Check if there are any missing x or y coordinates\n            bool missingX = true;\n            bool missingY = true;\n\n            foreach (int[] drift in snowDrifts)\n            {\n                if (drift[0] == 1)\n                    missingX = false;\n                if (drift[1] == 1)\n                    missingY = false;\n            }\n\n            if (missingX)\n                minSnowDrifts++;\n            if (missingY)\n                minSnowDrifts++;\n\n            return minSnowDrifts;\n        }\n    }\n}","Ruby":"\n# Read the number of snow drifts\nn = gets.to_i\n\n# Create an empty hash to store the coordinates of the snow drifts\nsnow_drifts = {}\n\n# Read the coordinates of each snow drift and store them in the hash\nn.times do\n  x, y = gets.split.map(&:to_i)\n  snow_drifts[[x, y]] = true\nend\n\n# Create a set to store the reachable snow drifts\nreachable_snow_drifts = Set.new\n\n# Iterate over each snow drift\nsnow_drifts.each_key do |snow_drift|\n  # Add the current snow drift to the reachable set\n  reachable_snow_drifts << snow_drift\n\n  # Check if the snow drift to the north is reachable\n  north_snow_drift = [snow_drift[0], snow_drift[1] + 1]\n  if snow_drifts.key?(north_snow_drift)\n    reachable_snow_drifts << north_snow_drift\n  end\n\n  # Check if the snow drift to the east is reachable\n  east_snow_drift = [snow_drift[0] + 1, snow_drift[1]]\n  if snow_drifts.key?(east_snow_drift)\n    reachable_snow_drifts << east_snow_drift\n  end\n\n  # Check if the snow drift to the south is reachable\n  south_snow_drift = [snow_drift[0], snow_drift[1] - 1]\n  if snow_drifts.key?(south_snow_drift)\n    reachable_snow_drifts << south_snow_drift\n  end\n\n  # Check if the snow drift to the west is reachable\n  west_snow_drift = [snow_drift[0] - 1, snow_drift[1]]\n  if snow_drifts.key?(west_snow_drift)\n    reachable_snow_drifts << west_snow_drift\n  end\nend\n\n# Output the minimal number of snow drifts that need to be created\nputs snow_drifts.length - reachable_snow_drifts.length\n","delphi":"program SnowDrifts;\\n\\nvar\\n  n, i, j, k, count: integer;\\n  x, y: array[1..100] of integer;\\n  connected: array[1..100, 1..100] of boolean;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    readln(x[i], y[i]);\\n\\n  for i := 1 to n do\\n  begin\\n    for j := 1 to n do\\n      connected[i, j] := false;\\n  end;\\n\\n  for i := 1 to n do\\n  begin\\n    for j := 1 to n do\\n    begin\\n      if i <> j then\\n      begin\\n        if (x[i] = x[j]) or (y[i] = y[j]) then\\n          connected[i, j] := true;\\n      end;\\n    end;\\n  end;\\n\\n  for k := 1 to n do\\n  begin\\n    for i := 1 to n do\\n    begin\\n      for j := 1 to n do\\n      begin\\n        if connected[i, k] and connected[k, j] then\\n          connected[i, j] := true;\\n      end;\\n    end;\\n  end;\\n\\n  count := 0;\\n  for i := 1 to n do\\n  begin\\n    for j := 1 to n do\\n    begin\\n      if not connected[i, j] then\\n        count := count + 1;\\n    end;\\n  end;\\n\\n  writeln(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\tsnowDrifts := make(map[int]bool)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\txy := scanner.Text()\\n\\t\\tx, _ := strconv.Atoi(xy[0])\\n\\t\\ty, _ := strconv.Atoi(xy[2])\\n\\t\\tsnowDrifts[x*1000+y] = true\\n\\t}\\n\\n\\tif n == 1 {\\n\\t\\tfmt.Println(0)\\n\\t} else {\\n\\t\\tfmt.Println(n - 1)\\n\\t}\\n}","Javascript":"function minimalSnowDrifts(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const drifts = [];\n  \n  for (let i = 1; i <= n; i++) {\n    const [x, y] = lines[i].split(' ').map(Number);\n    drifts.push({ x, y });\n  }\n  \n  const visited = new Set();\n  \n  function dfs(drift) {\n    visited.add(drift);\n    \n    for (const neighbor of drifts) {\n      if (!visited.has(neighbor) && (neighbor.x === drift.x || neighbor.y === drift.y)) {\n        dfs(neighbor);\n      }\n    }\n  }\n  \n  let components = 0;\n  \n  for (const drift of drifts) {\n    if (!visited.has(drift)) {\n      dfs(drift);\n      components++;\n    }\n  }\n  \n  return (components - 1).toString();\n}\n\nconst input = '2\\\\n2 1\\\\n1 2\\\\n';\nconsole.log(minimalSnowDrifts(input));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val drifts = mutableListOf<Pair<Int, Int>>()\n    \n    for (i in 0 until n) {\n        val x = scanner.nextInt()\n        val y = scanner.nextInt()\n        drifts.add(Pair(x, y))\n    }\n    \n    val visited = mutableSetOf<Pair<Int, Int>>()\n    val queue = LinkedList<Pair<Int, Int>>()\n    \n    queue.offer(drifts[0])\n    visited.add(drifts[0])\n    \n    while (queue.isNotEmpty()) {\n        val current = queue.poll()\n        \n        val neighbors = getNeighbors(current, drifts)\n        for (neighbor in neighbors) {\n            if (neighbor !in visited) {\n                queue.offer(neighbor)\n                visited.add(neighbor)\n            }\n        }\n    }\n    \n    val additionalDrifts = drifts.size - visited.size\n    println(additionalDrifts)\n}\n\nfun getNeighbors(current: Pair<Int, Int>, drifts: List<Pair<Int, Int>>): List<Pair<Int, Int>> {\n    val neighbors = mutableListOf<Pair<Int, Int>>()\n    \n    val dx = listOf(0, 0, 1, -1)\n    val dy = listOf(1, -1, 0, 0)\n    \n    for (i in 0 until 4) {\n        val nx = current.first + dx[i]\n        val ny = current.second + dy[i]\n        \n        val neighbor = Pair(nx, ny)\n        if (neighbor in drifts) {\n            neighbors.add(neighbor)\n        }\n    }\n    \n    return neighbors\n}","PHP":"<?php\\n\\n\/\/ Read input from STDIN\\n$input = file_get_contents('php:\/\/stdin');\\n\\n\/\/ Split input into lines\\n$lines = explode(\\\"\\\\n\\\", $input);\\n\\n\/\/ Get the number of snow drifts\\n$n = intval($lines[0]);\\n\\n\/\/ Create an empty array to store the coordinates of the snow drifts\\n$snowDrifts = array();\\n\\n\/\/ Loop through the remaining lines to get the coordinates\\nfor ($i = 1; $i <= $n; $i++) {\\n    \/\/ Split each line into x and y coordinates\\n    $coordinates = explode(\\\" \\\", $lines[$i]);\\n    \/\/ Add the coordinates to the snow drifts array\\n    $snowDrifts[] = array(intval($coordinates[0]), intval($coordinates[1]));\\n}\\n\\n\/\/ Create an empty array to store the distances between snow drifts\\n$distances = array();\\n\\n\/\/ Loop through all pairs of snow drifts\\nfor ($i = 0; $i < $n; $i++) {\\n    for ($j = $i + 1; $j < $n; $j++) {\\n        \/\/ Calculate the distance between the snow drifts\\n        $distance = abs($snowDrifts[$i][0] - $snowDrifts[$j][0]) + abs($snowDrifts[$i][1] - $snowDrifts[$j][1]);\\n        \/\/ Add the distance to the distances array\\n        $distances[] = $distance;\\n    }\\n}\\n\\n\/\/ Sort the distances array in ascending order\\nsort($distances);\\n\\n\/\/ Get the maximum distance from the distances array\\n$maxDistance = end($distances);\\n\\n\/\/ Output the minimal number of snow drifts that need to be created\\necho ($maxDistance - 1) . \\\"\\\\n\\\";\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.string;\\r\\n\\r\\nstruct Point {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    Point[] snowDrifts;\\r\\n    foreach (_; 0 .. n) {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        snowDrifts ~= Point(x, y);\\r\\n    }\\r\\n\\r\\n    int minX = minElement!((p) => p.x)(snowDrifts).x;\\r\\n    int maxX = maxElement!((p) => p.x)(snowDrifts).x;\\r\\n    int minY = minElement!((p) => p.y)(snowDrifts).y;\\r\\n    int maxY = maxElement!((p) => p.y)(snowDrifts).y;\\r\\n\\r\\n    int numSnowDrifts = (maxX - minX + 1) * (maxY - minY + 1) - n;\\r\\n\\r\\n    writeln(numSnowDrifts);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\n# Read the number of snow drifts\\nmy $n = <STDIN>;\\nchomp $n;\\n\\n# Initialize a hash to store the coordinates of snow drifts\\nmy %snow_drifts;\\n\\n# Read the coordinates of each snow drift\\nfor (my $i = 0; $i < $n; $i++) {\\n    my $line = <STDIN>;\\n    chomp $line;\\n    my ($x, $y) = split ' ', $line;\\n    $snow_drifts{$x}{$y} = 1;\\n}\\n\\n# Check if there are any missing snow drifts\\nmy $missing_drifts = 0;\\n\\n# Iterate through all possible coordinates\\nfor my $x (1..1000) {\\n    for my $y (1..1000) {\\n        # Check if the current coordinate is a snow drift\\n        next if exists $snow_drifts{$x}{$y};\\n        \\n        # Check if there is a snow drift in the north, east, south, or west direction\\n        my $north = exists $snow_drifts{$x}{$y+1};\\n        my $east = exists $snow_drifts{$x+1}{$y};\\n        my $south = exists $snow_drifts{$x}{$y-1};\\n        my $west = exists $snow_drifts{$x-1}{$y};\\n        \\n        # If there is no snow drift in any direction, increment the missing drifts count\\n        $missing_drifts++ if !$north && !$east && !$south && !$west;\\n    }\\n}\\n\\n# Print the minimal number of snow drifts that need to be created\\nprint $missing_drifts . \\\"\\\\n\\\";\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let mut drifts: Vec<(i32, i32)> = Vec::new();\n    \n    for _ in 0..n {\n        let drift: Vec<i32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        drifts.push((drift[0], drift[1]));\n    }\n    \n    let mut x_set: std::collections::HashSet<i32> = std::collections::HashSet::new();\n    let mut y_set: std::collections::HashSet<i32> = std::collections::HashSet::new();\n    \n    for drift in &drifts {\n        x_set.insert(drift.0);\n        y_set.insert(drift.1);\n    }\n    \n    let x_needed = x_set.len() as i32 - 1;\n    let y_needed = y_set.len() as i32 - 1;\n    \n    let min_needed = x_needed.min(y_needed);\n    \n    println!(\"{}\", min_needed);\n}"}
{"title":"B. Intersection","description":"You are given two set of points. The first set is determined by the equation A1x+B1y+C1=0, and the second one is determined by the equation A2x+B2y+C2=0.Write the program which finds the number of points in the intersection of two given sets.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line of the input contains three integer numbers A1,B1,C1 separated by space. The second line contains three integer numbers A2,B2,C2 separated by space. All the numbers are between -100 and 100, inclusive.\n","output_spec":"Print the number of points in the intersection or -1 if there are infinite number of points.\n","notes":null,"sample_inputs":["1 1 0\n2 2 0\n","1 1 0\n2 -2 0\n"],"sample_outputs":["-1\n","1\n"],"id":"21-B","difficulty":2000,"tags":["implementation","math"],"src_uid":"c8e869cb17550e888733551c749f2e1a","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int A1, B1, C1;\\n    int A2, B2, C2;\\n    cin >> A1 >> B1 >> C1;\\n    cin >> A2 >> B2 >> C2;\\n\\n    if (A1 * B2 == A2 * B1 && B1 * C2 == B2 * C1 && A1 * C2 == A2 * C1) {\\n        cout << -1 << endl;\\n    } else if (A1 * B2 != A2 * B1) {\\n        cout << 1 << endl;\\n    } else {\\n        cout << 0 << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class IntersectionPoints {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        \/\/ Read the coefficients of the first equation\\n        int a1 = scanner.nextInt();\\n        int b1 = scanner.nextInt();\\n        int c1 = scanner.nextInt();\\n\\n        \/\/ Read the coefficients of the second equation\\n        int a2 = scanner.nextInt();\\n        int b2 = scanner.nextInt();\\n        int c2 = scanner.nextInt();\\n\\n        \/\/ Calculate the determinant\\n        int determinant = a1 * b2 - a2 * b1;\\n\\n        \/\/ Check if the lines are parallel\\n        if (determinant == 0) {\\n            \/\/ Check if the lines are coincident\\n            if (a1 * c2 == a2 * c1 && b1 * c2 == b2 * c1) {\\n                System.out.println(-1);\\n            } else {\\n                System.out.println(0);\\n            }\\n        } else {\\n            System.out.println(1);\\n        }\\n    }\\n}","Python":"def find_intersection_points(A1, B1, C1, A2, B2, C2):\n    if A1*B2 == A2*B1:\n        if A1*C2 == A2*C1 and B1*C2 == B2*C1:\n            return -1\n        else:\n            return 0\n    else:\n        x = (B2*C1 - B1*C2) \/ (A1*B2 - A2*B1)\n        y = (A1*C2 - A2*C1) \/ (A1*B2 - A2*B1)\n        return 1\n\ninput1 = input().split()\ninput2 = input().split()\n\nA1, B1, C1 = int(input1[0]), int(input1[1]), int(input1[2])\nA2, B2, C2 = int(input2[0]), int(input2[1]), int(input2[2])\n\nresult = find_intersection_points(A1, B1, C1, A2, B2, C2)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int A1, B1, C1, A2, B2, C2;\\n    scanf(\\\"%d %d %d\\\", &A1, &B1, &C1);\\n    scanf(\\\"%d %d %d\\\", &A2, &B2, &C2);\\n\\n    if (A1 * B2 == A2 * B1) {\\n        if (A1 * C2 == A2 * C1 && B1 * C2 == B2 * C1) {\\n            printf(\\\"-1\\\\n\\\");\\n        } else {\\n            printf(\\\"0\\\\n\\\");\\n        }\\n    } else {\\n        printf(\\\"1\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace IntersectionPoints\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input1 = Console.ReadLine().Split(' ');\n            int A1 = int.Parse(input1[0]);\n            int B1 = int.Parse(input1[1]);\n            int C1 = int.Parse(input1[2]);\n\n            string[] input2 = Console.ReadLine().Split(' ');\n            int A2 = int.Parse(input2[0]);\n            int B2 = int.Parse(input2[1]);\n            int C2 = int.Parse(input2[2]);\n\n            int intersectionPoints = FindIntersectionPoints(A1, B1, C1, A2, B2, C2);\n            Console.WriteLine(intersectionPoints);\n        }\n\n        static int FindIntersectionPoints(int A1, int B1, int C1, int A2, int B2, int C2)\n        {\n            if (A1 * B2 - A2 * B1 == 0 && A1 * C2 - A2 * C1 == 0 && B1 * C2 - B2 * C1 == 0)\n            {\n                return -1; \/\/ Infinite number of points\n            }\n            else if (A1 * B2 - A2 * B1 == 0)\n            {\n                return 0; \/\/ No intersection points\n            }\n            else\n            {\n                return 1; \/\/ One intersection point\n            }\n        }\n    }\n}","Ruby":"def intersection_points(input)\n    a1, b1, c1 = input[0].split(' ').map(&:to_i)\n    a2, b2, c2 = input[1].split(' ').map(&:to_i)\n\n    if a1 * b2 == a2 * b1\n        if a1 * c2 == a2 * c1 && b1 * c2 == b2 * c1\n            return '-1\\n'\n        else\n            return '0\\n'\n        end\n    else\n        x = (b1 * c2 - b2 * c1) \/ (a1 * b2 - a2 * b1)\n        y = (a2 * c1 - a1 * c2) \/ (a1 * b2 - a2 * b1)\n        return '1\\n'\n    end\nend\n\ninput = ['1 1 0\\n2 2 0\\n', '1 1 0\\n2 -2 0\\n']\noutput = []\noutput << intersection_points(input[0].split('\\n'))\noutput << intersection_points(input[1].split('\\n'))\noutput.to_json","delphi":"program IntersectionPoints;\\n\\nvar\\n  A1, B1, C1, A2, B2, C2: Integer;\\n  x, y: Real;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(A1, B1, C1);\\n  ReadLn(A2, B2, C2);\\n\\n  \/\/ Check if the lines are parallel\\n  if (A1 * B2 - A2 * B1) = 0 then\\n  begin\\n    \/\/ Check if the lines are coincident\\n    if (A1 * C2 - A2 * C1) = 0 then\\n      WriteLn('-1')\\n    else\\n      WriteLn('0');\\n  end\\n  else\\n  begin\\n    \/\/ Calculate the intersection point\\n    x := (B1 * C2 - B2 * C1) \/ (A1 * B2 - A2 * B1);\\n    y := (A2 * C1 - A1 * C2) \/ (A1 * B2 - A2 * B1);\\n\\n    \/\/ Check if the intersection point is within the given range\\n    if (x >= -100) and (x <= 100) and (y >= -100) and (y <= 100) then\\n      WriteLn('1')\\n    else\\n      WriteLn('0');\\n  end;\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar A1, B1, C1, A2, B2, C2 int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &A1, &B1, &C1)\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &A2, &B2, &C2)\\n\\n\\tdenominator := A1*B2 - A2*B1\\n\\n\\tif denominator == 0 {\\n\\t\\tif A1*C2 == A2*C1 && B1*C2 == B2*C1 {\\n\\t\\t\\tfmt.Println(-1)\\n\\t\\t} else {\\n\\t\\t\\tfmt.Println(0)\\n\\t\\t}\\n\\t} else {\\n\\t\\tx := float64(B1*C2 - B2*C1) \/ float64(denominator)\\n\\t\\ty := float64(A2*C1 - A1*C2) \/ float64(denominator)\\n\\n\\t\\tif math.Mod(x, 1) == 0 && math.Mod(y, 1) == 0 {\\n\\t\\t\\tfmt.Println(1)\\n\\t\\t} else {\\n\\t\\t\\tfmt.Println(0)\\n\\t\\t}\\n\\t}\\n}","Javascript":"function findIntersectionPoints(input) {\n    let lines = input.split('\\\\n');\n    let line1 = lines[0].split(' ').map(Number);\n    let line2 = lines[1].split(' ').map(Number);\n\n    let A1 = line1[0];\n    let B1 = line1[1];\n    let C1 = line1[2];\n\n    let A2 = line2[0];\n    let B2 = line2[1];\n    let C2 = line2[2];\n\n    let determinant = A1 * B2 - A2 * B1;\n\n    if (determinant === 0) {\n        if (C1 * B2 === C2 * B1 && C1 * A2 === C2 * A1) {\n            return '-1\\\\n';\n        } else {\n            return '0\\\\n';\n        }\n    } else {\n        return '1\\\\n';\n    }\n}\n\nlet input = '1 1 0\\\\n2 2 0\\\\n';\nconsole.log(findIntersectionPoints(input));","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val a1 = input[0]\n    val b1 = input[1]\n    val c1 = input[2]\n\n    val input2 = readLine()!!.split(\" \").map { it.toInt() }\n    val a2 = input2[0]\n    val b2 = input2[1]\n    val c2 = input2[2]\n\n    val determinant = a1 * b2 - a2 * b1\n\n    if (determinant == 0) {\n        if (c1 * b2 == c2 * b1 && c2 * a1 == c1 * a2) {\n            println(\"-1\")\n        } else {\n            println(\"0\")\n        }\n    } else {\n        println(\"1\")\n    }\n}","PHP":"<?php\\n\\nfunction findIntersection($A1, $B1, $C1, $A2, $B2, $C2) {\\n    \/\/ Check if the two lines are parallel\\n    if (($A1 * $B2) - ($A2 * $B1) == 0) {\\n        \/\/ Check if the two lines are coincident\\n        if (($A1 * $C2) - ($A2 * $C1) == 0 && ($B1 * $C2) - ($B2 * $C1) == 0) {\\n            return -1; \/\/ Infinite number of points\\n        } else {\\n            return 0; \/\/ No intersection\\n        }\\n    }\\n\\n    \/\/ Calculate the intersection point\\n    $x = (($B1 * $C2) - ($B2 * $C1)) \/ (($A1 * $B2) - ($A2 * $B1));\\n    $y = (($A2 * $C1) - ($A1 * $C2)) \/ (($A1 * $B2) - ($A2 * $B1));\\n\\n    return 1; \/\/ One intersection point\\n}\\n\\n\/\/ Sample inputs\\n$input1 = '1 1 0';\\n$input2 = '2 2 0';\\n\\nlist($A1, $B1, $C1) = explode(' ', $input1);\\nlist($A2, $B2, $C2) = explode(' ', $input2);\\n\\n\/\/ Find the number of points in the intersection\\n$result = findIntersection($A1, $B1, $C1, $A2, $B2, $C2);\\n\\n\/\/ Print the result\\necho $result;\\n\\n?>","d":"import std.stdio;\\r\\n\\r\\nstruct Point\\r\\n{\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int A1, B1, C1;\\r\\n    int A2, B2, C2;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d %d\\\", &A1, &B1, &C1);\\r\\n    scanf(\\\"%d %d %d\\\", &A2, &B2, &C2);\\r\\n\\r\\n    \/\/ Check if the lines are parallel\\r\\n    if (A1 * B2 == A2 * B1)\\r\\n    {\\r\\n        \/\/ Check if the lines are coincident\\r\\n        if (A1 * C2 == A2 * C1 && B1 * C2 == B2 * C1)\\r\\n        {\\r\\n            printf(\\\"-1\\\\n\\\");\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            printf(\\\"0\\\\n\\\");\\r\\n        }\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        printf(\\\"1\\\\n\\\");\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_intersection_points {\n    my ($A1, $B1, $C1, $A2, $B2, $C2) = @_;\n\n    # Check if the lines are parallel\n    if ($A1 * $B2 == $A2 * $B1) {\n        # Check if the lines are coincident\n        if ($A1 * $C2 == $A2 * $C1 && $B1 * $C2 == $B2 * $C1) {\n            return -1;  # Infinite number of points\n        } else {\n            return 0;   # No intersection points\n        }\n    }\n\n    # Calculate the intersection point\n    my $x = ($B2 * $C1 - $B1 * $C2) \/ ($A1 * $B2 - $A2 * $B1);\n    my $y = ($A1 * $C2 - $A2 * $C1) \/ ($A1 * $B2 - $A2 * $B1);\n\n    return 1;   # One intersection point\n}\n\n# Read input from STDIN\nmy $input1 = <STDIN>;\nmy $input2 = <STDIN>;\n\n# Parse input\nmy ($A1, $B1, $C1) = split(' ', $input1);\nmy ($A2, $B2, $C2) = split(' ', $input2);\n\n# Find the number of intersection points\nmy $result = find_intersection_points($A1, $B1, $C1, $A2, $B2, $C2);\n\n# Print the result\nprint $result . \\\"\\\\n\\\";\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    \/\/ Read the input from stdin\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    \/\/ Parse the first line\n    let line1 = lines.next().unwrap().unwrap();\n    let mut iter1 = line1.split_whitespace();\n    let a1: i32 = iter1.next().unwrap().parse().unwrap();\n    let b1: i32 = iter1.next().unwrap().parse().unwrap();\n    let c1: i32 = iter1.next().unwrap().parse().unwrap();\n\n    \/\/ Parse the second line\n    let line2 = lines.next().unwrap().unwrap();\n    let mut iter2 = line2.split_whitespace();\n    let a2: i32 = iter2.next().unwrap().parse().unwrap();\n    let b2: i32 = iter2.next().unwrap().parse().unwrap();\n    let c2: i32 = iter2.next().unwrap().parse().unwrap();\n\n    \/\/ Calculate the determinant\n    let det = a1 * b2 - a2 * b1;\n\n    \/\/ Check if the lines are parallel or coincident\n    if det == 0 {\n        \/\/ Check if the lines are coincident\n        if a1 * c2 == a2 * c1 && b1 * c2 == b2 * c1 {\n            println!(\"-1\");\n        } else {\n            println!(\"0\");\n        }\n    } else {\n        println!(\"1\");\n    }\n}"}
{"title":"D. Olympiad","description":"A boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers \u2014 the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers n,x (1\u2264n\u226410^5;\u00a00\u2264x\u22642\u00b710^5) \u2014 the number of Olympiad participants and the minimum number of points Vasya earned.\nThe second line contains n space-separated integers: a1,a2,...,an (0\u2264ai\u226410^5) \u2014 the participants' points in the first tour.\nThe third line contains n space-separated integers: b1,b2,...,bn (0\u2264bi\u226410^5) \u2014 the participants' points in the second tour.\nThe participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad \u2014 there are two integers i,j (1\u2264i,j\u2264n) such, that ai+bj\u2265x.\n","output_spec":"Print two space-separated integers \u2014 the best and the worst place Vasya could have got on the Olympiad.\n","notes":"In the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.\nIn the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that \u2014 {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.\nIn this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.\nIn the worst case scenario Vasya can get the fifth place if the table looks like that \u2014 {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n","sample_inputs":["5 2\n1 1 1 1 1\n1 1 1 1 1\n","6 7\n4 3 5 6 4 4\n8 6 0 4 3 4\n"],"sample_outputs":["1 5\n","1 5\n"],"id":"222-D","difficulty":1900,"tags":["binary+search","greedy","sortings","two+pointers"],"src_uid":"77919677f562a6fd1af64bc8cbc79de5","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, x;\\n    cin >> n >> x;\\n    vector<int> a(n), b(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n    for (int i = 0; i < n; i++) {\\n        cin >> b[i];\\n    }\\n    sort(a.begin(), a.end());\\n    sort(b.begin(), b.end(), greater<int>());\\n    int best = 1, worst = n;\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] + b[i] < x) {\\n            best = max(best, i + 2);\\n        }\\n        if (a[i] + b[n - i - 1] >= x) {\\n            worst = min(worst, i + 1);\\n        }\\n    }\\n    cout << best << \\\" \\\" << worst << endl;\\n    return 0;\\n}","Java":"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int x = scanner.nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(a);\n        Arrays.sort(b);\n        \n        int bestPlace = 1;\n        int worstPlace = n;\n        \n        for (int i = 0; i < n; i++) {\n            if (a[i] + b[n - i - 1] < x) {\n                bestPlace++;\n            }\n            if (a[i] + b[n - i - 1] <= x) {\n                worstPlace--;\n            }\n        }\n        \n        System.out.println(bestPlace + \" \" + worstPlace);\n    }\n}","Python":"def find_vasya_place(n, x, a, b):\\n    a.sort(reverse=True)\\n    b.sort()\\n    best_place = 1\\n    worst_place = n\\n    for i in range(n):\\n        if a[i] + b[i] < x:\\n            best_place = i + 2\\n        if a[i] + b[n-i-1] >= x:\\n            worst_place = n - i - 1\\n            break\\n    return str(best_place) + ' ' + str(worst_place)\\n\\ninput_data = input().split('\\\\n')\\nn, x = map(int, input_data[0].split())\\na = list(map(int, input_data[1].split()))\\nb = list(map(int, input_data[2].split()))\\n\\nresult = find_vasya_place(n, x, a, b)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, x;\\n    scanf(\\\"%d %d\\\", &n, &x);\\n    int a[n], b[n];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &b[i]);\\n    }\\n    int best = 1, worst = n;\\n    for(int i=0; i<n; i++) {\\n        if(a[i] + b[n-1-i] < x) {\\n            best = n-i;\\n            break;\\n        }\\n    }\\n    for(int i=0; i<n; i++) {\\n        if(a[i] + b[0] >= x) {\\n            worst = n-i;\\n            break;\\n        }\\n    }\\n    printf(\\\"%d %d\\\\n\\\", best, worst);\\n    return 0;\\n}","C#":"using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int x = int.Parse(input[1]);\n\n        int[] tour1 = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        int[] tour2 = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int[] totalPoints = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            totalPoints[i] = tour1[i] + tour2[i];\n        }\n\n        Array.Sort(totalPoints);\n        Array.Reverse(totalPoints);\n\n        int bestPlace = Array.IndexOf(totalPoints, x) + 1;\n        int worstPlace = Array.LastIndexOf(totalPoints, x) + 1;\n\n        Console.WriteLine(bestPlace + \" \" + worstPlace);\n    }\n}","Ruby":"\ndef find_places(n, x, a, b)\n  # Sort the participants' points in descending order\n  a.sort!.reverse!\n  b.sort!.reverse!\n\n  # Initialize the best and worst places as the maximum number of participants\n  best_place = n\n  worst_place = n\n\n  # Iterate through each participant's points\n  (0...n).each do |i|\n    # Calculate the total points for the current participant\n    total_points = a[i] + b[0]\n\n    # Check if the total points are greater than or equal to the minimum required points\n    if total_points >= x\n      # Update the best place if the current participant's total points are greater than or equal to the minimum required points\n      best_place = [best_place, i + 1].min\n\n      # Find the worst place by iterating through the second tour points\n      (0...n).each do |j|\n        # Calculate the total points for the current worst place scenario\n        total_points = a[i] + b[j]\n\n        # Check if the total points are greater than or equal to the minimum required points\n        if total_points >= x\n          # Update the worst place if the current participant's total points are greater than or equal to the minimum required points\n          worst_place = [worst_place, i + j + 2].min\n        end\n      end\n    end\n  end\n\n  # Return the best and worst places as a string\n  return \"#{best_place} #{worst_place}\"\nend\n\n# Read the input\ninput = gets.chomp.split(\"\\n\")\nn, x = input[0].split.map(&:to_i)\na = input[1].split.map(&:to_i)\nb = input[2].split.map(&:to_i)\n\n# Call the function and print the result\nputs find_places(n, x, a, b)\n","delphi":"program Olympiad;\n\nvar\n  n, x, i, best, worst: integer;\n  a, b: array[1..100000] of integer;\n\nbegin\n  readln(n, x);\n  \n  for i := 1 to n do\n    read(a[i]);\n  \n  for i := 1 to n do\n    read(b[i]);\n  \n  best := 1;\n  worst := n;\n  \n  for i := 1 to n do\n  begin\n    if (a[i] + b[n-i+1] < x) then\n    begin\n      best := i + 1;\n      break;\n    end;\n  end;\n  \n  for i := 1 to n do\n  begin\n    if (a[i] + b[i] >= x) then\n    begin\n      worst := i - 1;\n      break;\n    end;\n  end;\n  \n  writeln(best, ' ', worst);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, x int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &x)\\n\\n\\ta := make([]int, n)\\n\\tb := make([]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &a[i])\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &b[i])\\n\\t}\\n\\n\\tscores := make([]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscores[i] = a[i] + b[n-i-1]\\n\\t}\\n\\n\\tsort.Ints(scores)\\n\\n\\tbest := 1\\n\\tworst := n\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif scores[i] >= x {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tbest++\\n\\t}\\n\\n\\tfor i := n - 1; i >= 0; i-- {\\n\\t\\tif scores[i] >= x {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tworst--\\n\\t}\\n\\n\\tfmt.Printf(\\\"%d %d\\\\n\\\", best, worst)\\n}","Javascript":"function findVasyaPlaces(input) {\n  const [n, x] = input[0].split(' ').map(Number);\n  const a = input[1].split(' ').map(Number);\n  const b = input[2].split(' ').map(Number);\n\n  const totalPoints = a.map((ai, i) => ai + b[i]);\n  const sortedPoints = [...totalPoints].sort((a, b) => b - a);\n\n  let bestPlace = 1;\n  let worstPlace = n;\n\n  for (let i = 0; i < n; i++) {\n    if (sortedPoints[i] >= x) {\n      bestPlace = Math.min(bestPlace, i + 1);\n      worstPlace = Math.min(worstPlace, n - i);\n    }\n  }\n\n  return `${bestPlace} ${worstPlace}`;\n}\n\nconst inputs = ['5 2\\n1 1 1 1 1\\n1 1 1 1 1\\n', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4\\n'];\nconst outputs = inputs.map(input => findVasyaPlaces(input.split('\\\\n')));\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val x = input[1].toInt()\n\n    val tour1 = scanner.nextLine().split(\" \").map { it.toInt() }\n    val tour2 = scanner.nextLine().split(\" \").map { it.toInt() }\n\n    val totalPoints = mutableListOf<Int>()\n    for (i in 0 until n) {\n        totalPoints.add(tour1[i] + tour2[i])\n    }\n\n    totalPoints.sortDescending()\n\n    var bestPlace = 1\n    var worstPlace = n\n\n    for (i in 0 until n) {\n        if (totalPoints[i] >= x) {\n            bestPlace = i + 1\n            break\n        }\n    }\n\n    for (i in n - 1 downTo 0) {\n        if (totalPoints[i] >= x) {\n            worstPlace = i + 1\n            break\n        }\n    }\n\n    println(\"$bestPlace $worstPlace\")\n}","PHP":"\n<?php\n\nfunction findVasyaPlaces($n, $x, $a, $b) {\n    \/\/ Sort the points in descending order\n    rsort($a);\n    rsort($b);\n    \n    \/\/ Calculate the total points for each participant\n    $totalPoints = array();\n    for ($i = 0; $i < $n; $i++) {\n        $totalPoints[$i] = $a[$i] + $b[$i];\n    }\n    \n    \/\/ Find the best place Vasya could have won\n    $bestPlace = 1;\n    while ($bestPlace < $n && $totalPoints[$bestPlace - 1] == $totalPoints[$bestPlace]) {\n        $bestPlace++;\n    }\n    \n    \/\/ Find the worst place Vasya could have won\n    $worstPlace = $n;\n    while ($worstPlace > 1 && $totalPoints[$worstPlace - 1] == $totalPoints[$worstPlace - 2]) {\n        $worstPlace--;\n    }\n    \n    return $bestPlace . ' ' . $worstPlace;\n}\n\n\/\/ Read the input\n$input = explode('\\n', $argv[1]);\n$n = intval(explode(' ', $input[0])[0]);\n$x = intval(explode(' ', $input[0])[1]);\n$a = array_map('intval', explode(' ', $input[1]));\n$b = array_map('intval', explode(' ', $input[2]));\n\n\/\/ Find the best and worst place Vasya could have won\n$result = findVasyaPlaces($n, $x, $a, $b);\n\n\/\/ Print the result\necho $result;\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, x;\\r\\n    readf(\\\"%d %d\\\", &n, &x);\\r\\n\\r\\n    int[] a = new int[n];\\r\\n    int[] b = new int[n];\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &b[i]);\\r\\n    }\\r\\n\\r\\n    sort(a);\\r\\n    sort(b, (x, y) => x > y);\\r\\n\\r\\n    int best = 1;\\r\\n    int worst = n;\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        if (a[i] + b[0] >= x)\\r\\n        {\\r\\n            best = i + 1;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        if (a[i] + b[i] < x)\\r\\n        {\\r\\n            worst = i;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writef(\\\"%d %d\\\\n\\\", best, worst);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_places {\n    my ($n, $x, $a_ref, $b_ref) = @_;\n\n    my @a = @$a_ref;\n    my @b = @$b_ref;\n\n    my @sums;\n    for my $i (0..$n-1) {\n        push @sums, $a[$i] + $b[$i];\n    }\n\n    my @sorted_sums = sort { $b <=> $a } @sums;\n\n    my $best_place = 1;\n    my $worst_place = $n;\n\n    for my $i (0..$n-1) {\n        if ($sorted_sums[$i] >= $x) {\n            $best_place = $i + 1;\n            last;\n        }\n    }\n\n    for my $i (0..$n-1) {\n        if ($sorted_sums[$i] >= $x) {\n            $worst_place = $i + 1;\n        }\n    }\n\n    return \"$best_place $worst_place\";\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $x) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @a = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @b = split ' ', $input;\n\n# Call the function and print the result\nmy $result = find_places($n, $x, \\@a, \\@b);\nprint \"$result\\n\";\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buf = String::new();\n    input.read_line(&mut buf).unwrap();\n    let mut iter = buf.split_whitespace();\n    let n: usize = iter.next().unwrap().parse().unwrap();\n    let x: i32 = iter.next().unwrap().parse().unwrap();\n    \n    buf.clear();\n    input.read_line(&mut buf).unwrap();\n    let a: Vec<i32> = buf.split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    buf.clear();\n    input.read_line(&mut buf).unwrap();\n    let b: Vec<i32> = buf.split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut sorted: Vec<(i32, i32)> = a.iter().zip(b.iter()).map(|(&x, &y)| (x, y)).collect();\n    sorted.sort_by(|a, b| (b.0 + b.1).cmp(&(a.0 + a.1)));\n    \n    let mut best_place = 1;\n    let mut worst_place = n;\n    \n    for i in 0..n {\n        if sorted[i].0 + sorted[i].1 >= x {\n            best_place = best_place.min(i + 1);\n            worst_place = worst_place.min(i + 1);\n        }\n    }\n    \n    println!(\\\"{} {}\\\", best_place, worst_place);\n}"}
{"title":"C. Anniversary","description":"There are less than 60 years left till the 900-th birthday anniversary of a famous Italian mathematician Leonardo Fibonacci. Of course, such important anniversary needs much preparations.Dima is sure that it'll be great to learn to solve the following problem by the Big Day: You're given a set A, consisting of numbers l, l+1, l+2, ..., r; let's consider all its k-element subsets; for each such subset let's find the largest common divisor of Fibonacci numbers with indexes, determined by the subset elements. Among all found common divisors, Dima is interested in the largest one.Dima asked to remind you that Fibonacci numbers are elements of a numeric sequence, where F1=1, F2=1, Fn=Fn-1+Fn-2 for n\u22653.Dima has more than half a century ahead to solve the given task, but you only have two hours. Count the residue from dividing the sought largest common divisor by m.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains four space-separated integers m, l, r and k (1\u2264m\u226410^9;\u00a01\u2264l<r\u226410^12;\u00a02\u2264k\u2264r-l+1).\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.\n","output_spec":"Print a single integer \u2014 the residue from dividing the sought greatest common divisor by m.\n","notes":null,"sample_inputs":["10 1 8 2\n","10 1 8 3\n"],"sample_outputs":["3\n","1\n"],"id":"226-C","difficulty":2400,"tags":["data+structures","implementation","math","matrices","number+theory"],"src_uid":"63e130256e23bd0693c6a1bede5e937e","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nlong long gcd(long long a, long long b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint main() {\\n    long long m, l, r, k;\\n    cin >> m >> l >> r >> k;\\n\\n    vector<long long> fib;\\n    fib.push_back(1);\\n    fib.push_back(1);\\n\\n    for (int i = 2; i <= r; i++) {\\n        long long next = fib[i - 1] + fib[i - 2];\\n        fib.push_back(next);\\n    }\\n\\n    vector<long long> subset;\\n    for (long long i = l; i <= r; i++) {\\n        subset.push_back(i);\\n    }\\n\\n    long long max_gcd = 0;\\n    do {\\n        long long gcd_val = fib[subset[0] - 1];\\n        for (int i = 1; i < k; i++) {\\n            gcd_val = gcd(gcd_val, fib[subset[i] - 1]);\\n        }\\n        max_gcd = max(max_gcd, gcd_val);\\n    } while (next_permutation(subset.begin(), subset.end()));\\n\\n    cout << max_gcd % m << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class FibonacciAnniversary {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long m = scanner.nextLong();\n        long l = scanner.nextLong();\n        long r = scanner.nextLong();\n        int k = scanner.nextInt();\n        \n        long[] fib = new long[(int) (r - l + 3)];\n        fib[1] = 1;\n        fib[2] = 1;\n        \n        for (int i = 3; i <= r - l + 2; i++) {\n            fib[i] = (fib[i - 1] + fib[i - 2]) % m;\n        }\n        \n        long maxGcd = 0;\n        \n        for (int i = 0; i < (1 << (r - l + 1)); i++) {\n            if (Integer.bitCount(i) == k) {\n                long gcd = fibGcd(fib, l, r, i);\n                maxGcd = Math.max(maxGcd, gcd);\n            }\n        }\n        \n        System.out.println(maxGcd);\n    }\n    \n    public static long fibGcd(long[] fib, long l, long r, int subset) {\n        long gcd = fib[(int) l];\n        \n        for (int i = 0; i < r - l + 1; i++) {\n            if ((subset & (1 << i)) != 0) {\n                gcd = gcd(gcd, fib[(int) (l + i + 1)]);\n            }\n        }\n        \n        return gcd;\n    }\n    \n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        \n        return gcd(b, a % b);\n    }\n}","Python":"import math\\n\\n# Function to calculate the Fibonacci number\\n# using matrix exponentiation\\n\\ndef fibonacci(n):\\n    F = [[1, 1],\\n         [1, 0]]\\n    if n == 0:\\n        return 0\\n    power(F, n - 1)\\n    return F[0][0]\\n\\n\\..","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint fibonacci(int n) {\\n    int a = 0, b = 1, c, i;\\n    if (n == 0)\\n        return a;\\n    for (i = 2; i <= n; i++) {\\n        c = a + b;\\n        a = b;\\n        b = c;\\n    }\\n    return b;\\n}\\n\\nint main() {\\n    int m, l, r, k;\\n    scanf(\\\"%d %d %d %d\\\", &m, &l, &r, &k);\\n    int i, j, count = 0;\\n    int* subset = (int*)malloc(k * sizeof(int));\\n    for (i = l; i <= r - k + 1; i++) {\\n        subset[0] = i;\\n        for (j = 1; j < k; j++) {\\n            subset[j] = subset[j - 1] + 1;\\n        }\\n        int max_gcd = 0;\\n        for (j = 0; j < k; j++) {\\n            int fib = fibonacci(subset[j]);\\n            if (max_gcd == 0)\\n                max_gcd = fib;\\n            else\\n                max_gcd = gcd(max_gcd, fib);\\n        }\\n        count += max_gcd;\\n    }\\n    printf(\\\"%d\\\\n\\\", count % m);\\n    free(subset);\\n    return 0;\\n}","C#":"\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] inputs = { \\\"10 1 8 2\\\", \\\"10 1 8 3\\\" };\n        foreach (string input in inputs)\n        {\n            string[] inputValues = input.Split(' ');\n            int m = int.Parse(inputValues[0]);\n            long l = long.Parse(inputValues[1]);\n            long r = long.Parse(inputValues[2]);\n            int k = int.Parse(inputValues[3]);\n\n            long largestCommonDivisor = FindLargestCommonDivisor(m, l, r, k);\n            Console.WriteLine(largestCommonDivisor);\n        }\n    }\n\n    static long FindLargestCommonDivisor(int m, long l, long r, int k)\n    {\n        long largestCommonDivisor = 1;\n        for (long i = l; i <= r - k + 1; i++)\n        {\n            long currentDivisor = FindGreatestCommonDivisor(Fibonacci(i), Fibonacci(i + k - 1));\n            largestCommonDivisor = Math.Max(largestCommonDivisor, currentDivisor);\n        }\n        return largestCommonDivisor % m;\n    }\n\n    static long Fibonacci(long n)\n    {\n        long a = 0;\n        long b = 1;\n        for (long i = 0; i < n; i++)\n        {\n            long temp = a;\n            a = b;\n            b = temp + b;\n        }\n        return a;\n    }\n\n    static long FindGreatestCommonDivisor(long a, long b)\n    {\n        while (b != 0)\n        {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n","Ruby":"\n# Function to calculate the Fibonacci number at index n\ndef fibonacci(n)\n  if n <= 1\n    return n\n  else\n    fib = [0, 1]\n    (2..n).each do |i|\n      fib[i] = fib[i-1] + fib[i-2]\n    end\n    return fib[n]\n  end\nend\n\n# Function to calculate the greatest common divisor of two numbers\ndef gcd(a, b)\n  while b != 0\n    temp = b\n    b = a % b\n    a = temp\n  end\n  return a\nend\n\n# Read input values\ninput = gets.chomp.split(' ')\nm = input[0].to_i\nl = input[1].to_i\nr = input[2].to_i\nk = input[3].to_i\n\n# Initialize variables\nmax_gcd = 0\n\n# Loop through all k-element subsets\n(0..(2**k-1)).each do |i|\n  subset = []\n  (0..(k-1)).each do |j|\n    if i & (1 << j) != 0\n      subset << l + j\n    end\n  end\n  \n  # Calculate the gcd of Fibonacci numbers in the subset\n  gcd_subset = fibonacci(subset[0])\n  (1..(subset.length-1)).each do |index|\n    gcd_subset = gcd(gcd_subset, fibonacci(subset[index]))\n  end\n  \n  # Update the maximum gcd\n  max_gcd = [max_gcd, gcd_subset].max\nend\n\n# Calculate the residue from dividing the maximum gcd by m\nresidue = max_gcd % m\n\n# Print the result\nputs residue\n","delphi":"program FibonacciDivisor;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction Fibonacci(n: Integer): Int64;\nvar\n  a, b, i: Integer;\nbegin\n  a := 1;\n  b := 1;\n  if (n = 1) or (n = 2) then\n    Result := 1\n  else\n  begin\n    for i := 3 to n do\n    begin\n      Result := a + b;\n      a := b;\n      b := Result;\n    end;\n  end;\nend;\n\nfunction GCD(a, b: Int64): Int64;\nbegin\n  if b = 0 then\n    Result := a\n  else\n    Result := GCD(b, a mod b);\nend;\n\nfunction LargestCommonDivisor(m, l, r, k: Int64): Int64;\nvar\n  i, j, count: Int64;\n  subset: array of Int64;\n  gcd, largestGCD: Int64;\nbegin\n  largestGCD := 0;\n  SetLength(subset, k);\n  \n  for i := l to r - k + 1 do\n  begin\n    subset[0] := i;\n    count := 1;\n    \n    for j := i + 1 to r do\n    begin\n      subset[count] := j;\n      count := count + 1;\n      \n      if count = k then\n      begin\n        gcd := Fibonacci(subset[0]);\n        \n        for count := 1 to k - 1 do\n          gcd := GCD(gcd, Fibonacci(subset[count]));\n        \n        if gcd > largestGCD then\n          largestGCD := gcd;\n        \n        break;\n      end;\n    end;\n  end;\n  \n  Result := largestGCD mod m;\nend;\n\nvar\n  m, l, r, k: Int64;\nbegin\n  ReadLn(m, l, r, k);\n  WriteLn(LargestCommonDivisor(m, l, r, k));\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\/big\\\"\\n)\\n\\nfunc fibonacci(n int) *big.Int {\\n\\ta := big.NewInt(0)\\n\\tb := big.NewInt(1)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ta.Add(a, b)\\n\\t\\ta, b = b, a\\n\\t}\\n\\n\\treturn a\\n}\\n\\nfunc gcd(a, b *big.Int) *big.Int {\\n\\tif b.Cmp(big.NewInt(0)) == 0 {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn gcd(b, new(big.Int).Mod(a, b))\\n}\\n\\nfunc main() {\\n\\tvar m, l, r, k int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &m, &l, &r, &k)\\n\\n\\tmaxGCD := big.NewInt(0)\\n\\n\\tfor i := l; i <= r-k+1; i++ {\\n\\t\\tsubset := make([]*big.Int, k)\\n\\n\\t\\tfor j := 0; j < k; j++ {\\n\\t\\t\\tsubset[j] = fibonacci(i + j)\\n\\t\\t}\\n\\n\\t\\tgcdResult := subset[0]\\n\\n\\t\\tfor j := 1; j < k; j++ {\\n\\t\\t\\tgcdResult = gcd(gcdResult, subset[j])\\n\\t\\t}\\n\\n\\t\\tif gcdResult.Cmp(maxGCD) == 1 {\\n\\t\\t\\tmaxGCD = gcdResult\\n\\t\\t}\\n\\t}\\n\\n\\tresidue := new(big.Int).Mod(maxGCD, big.NewInt(int64(m)))\\n\\tfmt.Println(residue)\\n}","Javascript":"\n\/\/ Function to calculate the Fibonacci number at a given index\nfunction fibonacci(n) {\n  if (n <= 2) {\n    return 1;\n  }\n  \n  let fib = [1, 1];\n  \n  for (let i = 2; i < n; i++) {\n    fib[i] = fib[i-1] + fib[i-2];\n  }\n  \n  return fib[n-1];\n}\n\n\/\/ Function to calculate the greatest common divisor of two numbers\nfunction gcd(a, b) {\n  if (b === 0) {\n    return a;\n  }\n  \n  return gcd(b, a % b);\n}\n\n\/\/ Function to calculate the residue from dividing the sought greatest common divisor by m\nfunction calculateResidue(m, l, r, k) {\n  let maxGcd = 0;\n  \n  \/\/ Generate all k-element subsets of the set A\n  for (let i = l; i <= r - k + 1; i++) {\n    for (let j = i + 1; j <= r - k + 2; j++) {\n      let subset = [];\n      \n      \/\/ Add the elements of the subset to the array\n      for (let x = i; x < i + k; x++) {\n        subset.push(x);\n      }\n      \n      \/\/ Calculate the gcd of Fibonacci numbers with indexes determined by the subset elements\n      let subsetGcd = fibonacci(subset[0]);\n      \n      for (let y = 1; y < k; y++) {\n        subsetGcd = gcd(subsetGcd, fibonacci(subset[y]));\n      }\n      \n      \/\/ Update the maximum gcd if necessary\n      if (subsetGcd > maxGcd) {\n        maxGcd = subsetGcd;\n      }\n    }\n  }\n  \n  \/\/ Calculate the residue from dividing the maximum gcd by m\n  let residue = maxGcd % m;\n  \n  return residue;\n}\n\n\/\/ Read the input values\nlet input = readline().split(' ');\nlet m = parseInt(input[0]);\nlet l = parseInt(input[1]);\nlet r = parseInt(input[2]);\nlet k = parseInt(input[3]);\n\n\/\/ Calculate the residue from dividing the sought greatest common divisor by m\nlet residue = calculateResidue(m, l, r, k);\n\n\/\/ Print the result\nconsole.log(residue);\n","Kotlin":"import java.util.*\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toLong() }\\n    val m = input[0]\\n    val l = input[1]\\n    val r = input[2]\\n    val k = input[3]\\n\\n    val fib = mutableListOf<Long>(1, 1)\\n    var i = 2\\n\\n    while (i < r) {\\n        val nextFib = fib[i - 1] + fib[i - 2]\\n        if (nextFib > r) break\\n        fib.add(nextFib)\\n        i++\\n    }\\n\\n    val subsets = mutableListOf<List<Long>>()\\n    generateSubsets(l, r, k, mutableListOf(), subsets)\\n\\n    var maxGcd = 0L\\n\\n    for (subset in subsets) {\\n        var gcd = fib[subset[0].toInt() - 1]\\n\\n        for (i in 1 until k) {\\n            gcd = gcd(gcd, fib[subset[i].toInt() - 1])\\n        }\\n\\n        maxGcd = maxOf(maxGcd, gcd)\\n    }\\n\\n    val residue = maxGcd % m\\n    println(residue)\\n}\\n\\nfun generateSubsets(l: Long, r: Long, k: Long, current: MutableList<Long>, subsets: MutableList<List<Long>>) {\\n    if (current.size == k) {\\n        subsets.add(current.toList())\\n        return\\n    }\\n\\n    for (i in l..r) {\\n        current.add(i)\\n        generateSubsets(i + 1, r, k, current, subsets)\\n        current.removeAt(current.size - 1)\\n    }\\n}\\n\\nfun gcd(a: Long, b: Long): Long {\\n    if (b == 0L) return a\\n\\n    return gcd(b, a % b)\\n}","PHP":"\n<?php\n\nfunction gcd($a, $b) {\n    while ($b != 0) {\n        $t = $b;\n        $b = $a % $b;\n        $a = $t;\n    }\n    return $a;\n}\n\nfunction fibonacci($n) {\n    $fib = [0, 1];\n    for ($i = 2; $i <= $n; $i++) {\n        $fib[$i] = $fib[$i - 1] + $fib[$i - 2];\n    }\n    return $fib;\n}\n\nfunction largestCommonDivisor($m, $l, $r, $k) {\n    $fib = fibonacci($r);\n    $gcd = 0;\n    for ($i = $l; $i <= $r; $i++) {\n        $subset = [];\n        $num = $i;\n        for ($j = $r; $j >= $l; $j--) {\n            if ($num >= pow(2, $j - $l)) {\n                $subset[] = $j;\n                $num -= pow(2, $j - $l);\n            }\n        }\n        $commonDivisor = $fib[$subset[0]];\n        for ($j = 1; $j < count($subset); $j++) {\n            $commonDivisor = gcd($commonDivisor, $fib[$subset[$j]]);\n        }\n        $gcd = max($gcd, $commonDivisor);\n    }\n    return $gcd % $m;\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$m = intval($input[0]);\n$l = intval($input[1]);\n$r = intval($input[2]);\n$k = intval($input[3]);\n\n$output = largestCommonDivisor($m, $l, $r, $k);\necho $output;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\n\\r\\nulong fibonacci(ulong n)\\r\\n{\\r\\n    if (n <= 2)\\r\\n        return 1;\\r\\n\\r\\n    ulong a = 1;\\r\\n    ulong b = 1;\\r\\n    ulong c;\\r\\n\\r\\n    for (ulong i = 3; i <= n; i++)\\r\\n    {\\r\\n        c = a + b;\\r\\n        a = b;\\r\\n        b = c;\\r\\n    }\\r\\n\\r\\n    return b;\\r\\n}\\r\\n\\r\\nulong gcd(ulong a, ulong b)\\r\\n{\\r\\n    while (b != 0)\\r\\n    {\\r\\n        ulong temp = b;\\r\\n        b = a % b;\\r\\n        a = temp;\\r\\n    }\\r\\n\\r\\n    return a;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    ulong m, l, r, k;\\r\\n    readf(\\\"%lu %lu %lu %lu\\\", &m, &l, &r, &k);\\r\\n\\r\\n    ulong maxGcd = 0;\\r\\n\\r\\n    for (ulong i = l; i <= r - k + 1; i++)\\r\\n    {\\r\\n        ulong gcdResult = fibonacci(i);\\r\\n\\r\\n        for (ulong j = i + 1; j <= i + k - 1; j++)\\r\\n        {\\r\\n            gcdResult = gcd(gcdResult, fibonacci(j));\\r\\n        }\\r\\n\\r\\n        maxGcd = max(maxGcd, gcdResult);\\r\\n    }\\r\\n\\r\\n    writeln(to!string(maxGcd % m));\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub fibonacci {\n    my ($n) = @_;\n    my ($a, $b) = (0, 1);\n    for (my $i = 0; $i < $n; $i++) {\n        ($a, $b) = ($b, $a + $b);\n    }\n    return $a;\n}\n\nsub gcd {\n    my ($a, $b) = @_;\n    while ($b) {\n        ($a, $b) = ($b, $a % $b);\n    }\n    return $a;\n}\n\nsub largest_common_divisor {\n    my ($l, $r, $k, $m) = @_;\n    my $largest_divisor = 0;\n    for (my $i = $l; $i <= $r; $i++) {\n        my @subset = map { $_ + $l - 1 } grep { ($i >> ($_ - $l)) & 1 } $l..$r;\n        my $gcd = fibonacci($subset[0]);\n        for (my $j = 1; $j < $k; $j++) {\n            $gcd = gcd($gcd, fibonacci($subset[$j]));\n        }\n        $largest_divisor = $gcd if $gcd > $largest_divisor;\n    }\n    return $largest_divisor % $m;\n}\n\nmy ($m, $l, $r, $k) = split ' ', <>;\nmy $residue = largest_common_divisor($l, $r, $k, $m);\nprint $residue;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let params: Vec<u64> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let m = params[0];\n    let l = params[1];\n    let r = params[2];\n    let k = params[3];\n    \n    let mut fib: Vec<u64> = vec![1, 1];\n    for i in 2..=r {\n        let next = fib[i-1] + fib[i-2];\n        fib.push(next);\n    }\n    \n    let mut max_gcd = 0;\n    for i in l..=r-k+1 {\n        let subset = (i..i+k).collect::<Vec<u64>>();\n        let gcd = subset.iter().map(|&x| fib[x as usize]).fold(subset[0], |a, b| gcd(a, b));\n        max_gcd = max_gcd.max(gcd);\n    }\n    \n    let residue = max_gcd % m;\n    println!(\"{}\", residue);\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}"}
{"title":"A. Is your horseshoe on the other hoof?","description":"Valera the Horse is going to the party with friends. He has been following the fashion trends for a while, and he knows that it is very popular to wear all horseshoes of different color. Valera has got four horseshoes left from the last year, but maybe some of them have the same color. In this case he needs to go to the store and buy some few more horseshoes, not to lose face in front of his stylish comrades.Fortunately, the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them. However, in order to save the money, he would like to spend as little money as possible, so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains four space-separated integers s1,s2,s3,s4 (1\u2264s1,s2,s3,s4\u226410^9) \u2014 the colors of horseshoes Valera has.\nConsider all possible colors indexed with integers.\n","output_spec":"Print a single integer \u2014 the minimum number of horseshoes Valera needs to buy.\n","notes":null,"sample_inputs":["1 7 3 3\n","7 7 7 7\n"],"sample_outputs":["1\n","3\n"],"id":"228-A","difficulty":800,"tags":["implementation"],"src_uid":"38c4864937e57b35d3cce272f655e20f","C++":"#include <iostream>\\n#include <set>\\n\\nusing namespace std;\\n\\nint main() {\\n    set<int> colors;\\n    int s1, s2, s3, s4;\\n    cin >> s1 >> s2 >> s3 >> s4;\\n    colors.insert(s1);\\n    colors.insert(s2);\\n    colors.insert(s3);\\n    colors.insert(s4);\\n    int num_horseshoes_to_buy = 4 - colors.size();\\n    cout << num_horseshoes_to_buy << endl;\\n    return 0;\\n}","Java":"import java.util.HashSet;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        HashSet<Integer> colors = new HashSet<>();\\n\\n        for (int i = 0; i < 4; i++) {\\n            int color = scanner.nextInt();\\n            colors.add(color);\\n        }\\n\\n        int minimumHorseshoes = 4 - colors.size();\\n        System.out.println(minimumHorseshoes);\\n    }\\n}","Python":"def minimum_horseshoes(s1, s2, s3, s4):\n    colors = set([s1, s2, s3, s4])\n    return 4 - len(colors)\n\ns1, s2, s3, s4 = map(int, input().split())\nprint(minimum_horseshoes(s1, s2, s3, s4))","C":"#include <stdio.h>\\n\\nint main() {\\n    int s1, s2, s3, s4;\\n    scanf(\\\"%d %d %d %d\\\", &s1, &s2, &s3, &s4);\\n\\n    int count = 0;\\n    if (s1 == s2 || s1 == s3 || s1 == s4) {\\n        count++;\\n    }\\n    if (s2 == s3 || s2 == s4) {\\n        count++;\\n    }\\n    if (s3 == s4) {\\n        count++;\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] colors = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n        \n        int distinctColors = colors.Distinct().Count();\n        int minimumHorseshoes = 4 - distinctColors;\n        \n        Console.WriteLine(minimumHorseshoes);\n    }\n}","Ruby":"\ndef minimum_horseshoes(colors)\n  unique_colors = colors.uniq\n  return 4 - unique_colors.length\nend\n\ninput = gets.chomp.split(' ').map(&:to_i)\noutput = minimum_horseshoes(input)\nputs output\n","delphi":"program MinimumHorseshoes;\\n\\nvar\\n  s1, s2, s3, s4: Integer;\\n  colors: set of 1..4;\\n  minHorseshoes: Integer;\\n\\nbegin\\n  Readln(s1, s2, s3, s4);\\n\\n  colors := [s1, s2, s3, s4];\\n\\n  minHorseshoes := 4 - Length(colors);\\n\\n  Writeln(minHorseshoes);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar s1, s2, s3, s4 int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &s1, &s2, &s3, &s4)\\n\\n\\thorseshoes := []int{s1, s2, s3, s4}\\n\\tsort.Ints(horseshoes)\\n\\n\\tcount := 0\\n\\tfor i := 1; i < len(horseshoes); i++ {\\n\\t\\tif horseshoes[i] == horseshoes[i-1] {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function minimumHorseshoes(colors) {\n  let uniqueColors = new Set(colors);\n  return 4 - uniqueColors.size;\n}\n\nlet inputs = ['1 7 3 3\\n', '7 7 7 7\\n'];\nlet outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  let colors = inputs[i].trim().split(' ').map(Number);\n  let result = minimumHorseshoes(colors);\n  outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val colors = scanner.nextLine().split(\" \").map { it.toInt() }\n    \n    val uniqueColors = colors.distinct()\n    val numHorseshoesToBuy = 4 - uniqueColors.size\n    \n    println(numHorseshoesToBuy)\n}","PHP":"<?php\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n\\n$uniqueColors = count(array_unique($input));\\n\\n$minimumHorseshoes = 4 - $uniqueColors;\\n\\necho $minimumHorseshoes;\\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int[] colors = readln.split.map!(a => a.to!int);\\r\\n    int distinctColors = colors.unique.length;\\r\\n    int horseshoesToBuy = 4 - distinctColors;\\r\\n    writeln(horseshoesToBuy);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nmy $input = <>;\nchomp $input;\nmy @colors = split ' ', $input;\n\nmy %color_count;\nforeach my $color (@colors) {\n    $color_count{$color}++;\n}\n\nmy $num_to_buy = 0;\nforeach my $count (values %color_count) {\n    if ($count > 1) {\n        $num_to_buy += $count - 1;\n    }\n}\n\nprint $num_to_buy;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let colors: Vec<u32> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut distinct_colors = 0;\n    let mut color_count: [u32; 10] = [0; 10];\n    \n    for color in colors {\n        color_count[color as usize] += 1;\n    }\n    \n    for count in color_count.iter() {\n        if *count > 0 {\n            distinct_colors += 1;\n        }\n    }\n    \n    let minimum_horseshoes = 4 - distinct_colors;\n    println!(\"{}\", minimum_horseshoes);\n}"}
{"title":"A. Shifts","description":"You are given a table consisting of n rows and m columns. Each cell of the table contains a number, 0 or 1. In one move we can choose some row of the table and cyclically shift its values either one cell to the left, or one cell to the right.To cyclically shift a table row one cell to the right means to move the value of each cell, except for the last one, to the right neighboring cell, and to move the value of the last cell to the first cell. A cyclical shift of a row to the left is performed similarly, but in the other direction. For example, if we cyclically shift a row \"00110\" one cell to the right, we get a row \"00011\", but if we shift a row \"00110\" one cell to the left, we get a row \"01100\".Determine the minimum number of moves needed to make some table column consist only of numbers 1.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers: n (1\u2264n\u2264100)\u00a0\u2014 the number of rows in the table and m (1\u2264m\u226410^4)\u00a0\u2014 the number of columns in the table. Then n lines follow, each of them contains m characters \"0\" or \"1\": the j-th character of the i-th line describes the contents of the cell in the i-th row and in the j-th column of the table.\nIt is guaranteed that the description of the table contains no other characters besides \"0\" and \"1\".\n","output_spec":"Print a single number: the minimum number of moves needed to get only numbers 1 in some column of the table. If this is impossible, print -1.\n","notes":"In the first sample one way to achieve the goal with the least number of moves is as follows: cyclically shift the second row to the right once, then shift the third row to the left twice. Then the table column before the last one will contain only 1s.\nIn the second sample one can't shift the rows to get a column containing only 1s.\n","sample_inputs":["3 6\n101010\n000100\n100000\n","2 3\n111\n000\n"],"sample_outputs":["3\n","-1\n"],"id":"229-A","difficulty":1500,"tags":["brute+force","two+pointers"],"src_uid":"a491be7d5883d594c3e907a22be607c9","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<int>> table(n, vector<int>(m));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            char c;\\n            cin >> c;\\n            table[i][j] = c - '0';\\n        }\\n    }\\n\\n    int minMoves = -1;\\n    for (int col = 0; col < m; col++) {\\n        int moves = 0;\\n        for (int row = 0; row < n; row++) {\\n            int ones = count(table[row].begin(), table[row].end(), 1);\\n            int zeros = m - ones;\\n            if (table[row][col] == 0) {\\n                moves += ones;\\n            } else {\\n                moves += zeros;\\n            }\\n        }\\n        if (minMoves == -1 || moves < minMoves) {\\n            minMoves = moves;\\n        }\\n    }\\n\\n    cout << minMoves << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        scanner.nextLine();\\n        int[][] table = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            String row = scanner.nextLine();\\n            for (int j = 0; j < m; j++) {\\n                table[i][j] = Character.getNumericValue(row.charAt(j));\\n            }\\n        }\\n        int minMoves = Integer.MAX_VALUE;\\n        for (int col = 0; col < m; col++) {\\n            int moves = 0;\\n            for (int row = 0; row < n; row++) {\\n                int ones = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (table[row][j] == 1) {\\n                        ones++;\\n                    }\\n                }\\n                int leftShifts = (col - row + n) % n;\\n                int rightShifts = (row - col + n) % n;\\n                if (ones == n && (leftShifts == 0 || rightShifts == 0)) {\\n                    moves = Math.min(moves, 0);\\n                } else if (ones == n) {\\n                    moves = Math.min(moves, Math.min(leftShifts, rightShifts));\\n                }\\n            }\\n            minMoves = Math.min(minMoves, moves);\\n        }\\n        if (minMoves == Integer.MAX_VALUE) {\\n            System.out.println(-1);\\n        } else {\\n            System.out.println(minMoves);\\n        }\\n    }\\n}","Python":"def min_moves(table):\n    n, m = map(int, table[0].split())\n    rows = [list(map(int, row.strip())) for row in table[1:]]\n\n    # Check if there is already a column with all 1s\n    for j in range(m):\n        if all(rows[i][j] == 1 for i in range(n)):\n            return '0'\n\n    # Check if it is possible to make a column with all 1s\n    for i in range(n):\n        if all(rows[i][j] == 0 for j in range(m)):\n            return '-1'\n\n    # Find the minimum number of moves\n    min_moves = float('inf')\n    for i in range(n):\n        moves = 0\n        for j in range(m):\n            if rows[i][j] == 0:\n                left_moves = j\n                right_moves = m - j\n                moves += min(left_moves, right_moves)\n        min_moves = min(min_moves, moves)\n\n    return str(min_moves)\n\n# Sample inputs\ninputs = ['3 6\\n101010\\n000100\\n100000\\n', '2 3\\n111\\n000\\n']\n\n# Process sample inputs and generate sample outputs\noutputs = []\nfor input_str in inputs:\n    input_list = input_str.strip().split('\\\\n')\n    output_str = min_moves(input_list)\n    outputs.append(output_str)\n\n# Print sample outputs in JSON format\nimport json\nprint(json.dumps(outputs))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    char table[n][m+1];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s\\\", table[i]);\\n    }\\n\\n    int min_moves = -1;\\n    for (int col = 0; col < m; col++) {\\n        int moves = 0;\\n        for (int row = 0; row < n; row++) {\\n            int ones = 0;\\n            for (int i = 0; i < m; i++) {\\n                if (table[row][i] == '1') {\\n                    ones++;\\n                }\\n            }\\n            int left_moves = (col - ones + m) % m;\\n            int right_moves = (ones - col + m) % m;\\n            moves += (left_moves < right_moves) ? left_moves : right_moves;\\n        }\\n        if (min_moves == -1 || moves < min_moves) {\\n            min_moves = moves;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", min_moves);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MinimumMoves\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n\n            int[,] table = new int[n, m];\n\n            for (int i = 0; i < n; i++)\n            {\n                string row = Console.ReadLine();\n                for (int j = 0; j < m; j++)\n                {\n                    table[i, j] = int.Parse(row[j].ToString());\n                }\n            }\n\n            int minMoves = GetMinimumMoves(table, n, m);\n            Console.WriteLine(minMoves);\n        }\n\n        static int GetMinimumMoves(int[,] table, int n, int m)\n        {\n            int minMoves = int.MaxValue;\n\n            for (int col = 0; col < m; col++)\n            {\n                int moves = 0;\n                for (int row = 0; row < n; row++)\n                {\n                    int ones = CountOnes(table, row, col, n, m);\n                    if (ones == n)\n                    {\n                        minMoves = Math.Min(minMoves, moves);\n                        break;\n                    }\n                    moves++;\n                }\n            }\n\n            return minMoves == int.MaxValue ? -1 : minMoves;\n        }\n\n        static int CountOnes(int[,] table, int row, int col, int n, int m)\n        {\n            int ones = 0;\n            for (int i = 0; i < n; i++)\n            {\n                int currCol = (col + i) % m;\n                ones += table[row, currCol];\n            }\n            return ones;\n        }\n    }\n}","Ruby":"\ndef minimum_moves(table)\n  rows, columns = table.shift.split.map(&:to_i)\n  matrix = table.map { |row| row.chomp.chars.map(&:to_i) }\n  \n  min_moves = Float::INFINITY\n  \n  (0...columns).each do |col|\n    moves = 0\n    (0...rows).each do |row|\n      if matrix[row][col] == 0\n        left_moves = matrix[row].rotate(col).rindex(1)\n        right_moves = matrix[row].rotate(col).index(1)\n        moves += [left_moves, right_moves].compact.min\n      end\n    end\n    min_moves = [min_moves, moves].min\n  end\n  \n  min_moves == Float::INFINITY ? -1 : min_moves\nend\n\ninput = ['3 6\\n101010\\n000100\\n100000\\n', '2 3\\n111\\n000\\n']\noutput = []\n\ninput.each do |data|\n  table = data.split(\"\\n\")\n  result = minimum_moves(table)\n  output << result.to_s + \"\\n\"\nend\n\noutput\n","delphi":"program MinimumMoves;\n\nvar\n  n, m, i, j, k, minMoves: Integer;\n  table: array of array of Char;\n  column: array of Integer;\n  moves: array of Integer;\n\nbegin\n  \/\/ Read input\n  ReadLn(n, m);\n  SetLength(table, n, m);\n  for i := 0 to n - 1 do\n  begin\n    for j := 0 to m - 1 do\n    begin\n      Read(table[i, j]);\n    end;\n    ReadLn;\n  end;\n\n  \/\/ Initialize variables\n  SetLength(column, m);\n  SetLength(moves, m);\n  minMoves := MaxInt;\n\n  \/\/ Iterate over each column\n  for j := 0 to m - 1 do\n  begin\n    \/\/ Count the number of 1s in the column\n    column[j] := 0;\n    for i := 0 to n - 1 do\n    begin\n      if table[i, j] = '1' then\n        Inc(column[j]);\n    end;\n\n    \/\/ Check if the column already consists only of 1s\n    if column[j] = n then\n    begin\n      WriteLn(0);\n      Exit;\n    end;\n\n    \/\/ Calculate the minimum number of moves needed for the column\n    moves[j] := 0;\n    for k := 0 to n - 1 do\n    begin\n      if table[k, j] = '0' then\n        Inc(moves[j]);\n    end;\n    moves[j] := Min(moves[j], n - moves[j]);\n\n    \/\/ Update the minimum number of moves\n    minMoves := Min(minMoves, moves[j]);\n  end;\n\n  \/\/ Print the minimum number of moves\n  if minMoves = MaxInt then\n    WriteLn(-1)\n  else\n    WriteLn(minMoves);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\ttable := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%s\\\", &table[i])\\n\\t}\\n\\n\\tminMoves := -1\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tmoves := 0\\n\\t\\thasOne := false\\n\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif table[j][i] == '1' {\\n\\t\\t\\t\\thasOne = true\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif !hasOne {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif table[j][i] == '0' {\\n\\t\\t\\t\\tleft := 0\\n\\t\\t\\t\\tright := 0\\n\\n\\t\\t\\t\\tfor k := j - 1; k >= 0; k-- {\\n\\t\\t\\t\\t\\tif table[k][i] == '1' {\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tleft++\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor k := j + 1; k < n; k++ {\\n\\t\\t\\t\\t\\tif table[k][i] == '1' {\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright++\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif left == 0 && right == 0 {\\n\\t\\t\\t\\t\\tmoves = -1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif left == 0 {\\n\\t\\t\\t\\t\\tmoves += right\\n\\t\\t\\t\\t} else if right == 0 {\\n\\t\\t\\t\\t\\tmoves += left\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tmoves += min(left, right)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif moves != -1 && (minMoves == -1 || moves < minMoves) {\\n\\t\\t\\t\\tminMoves = moves\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minMoves)\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}","Javascript":"function minimumMoves(table) {\n  const rows = table.split('\\\\n').slice(1, -1);\n  const n = rows.length;\n  const m = rows[0].length;\n  \n  let minMoves = Infinity;\n  \n  for (let col = 0; col < m; col++) {\n    let moves = 0;\n    for (let row = 0; row < n; row++) {\n      let ones = 0;\n      for (let i = 0; i < m; i++) {\n        if (rows[row][(col + i) % m] === '1') {\n          ones++;\n        }\n      }\n      moves += Math.min(ones, m - ones);\n    }\n    minMoves = Math.min(minMoves, moves);\n  }\n  \n  return minMoves === Infinity ? -1 : minMoves;\n}\n\nconst inputs = ['3 6\\\\n101010\\\\n000100\\\\n100000\\\\n', '2 3\\\\n111\\\\n000\\\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const input = inputs[i];\n  const output = minimumMoves(input);\n  outputs.push(output + '\\\\n');\n}\n\noutputs;","Kotlin":"import kotlin.math.min\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    \n    val table = Array(n) { readLine()!!.toCharArray() }\n    \n    var minMoves = Int.MAX_VALUE\n    \n    for (col in 0 until m) {\n        var moves = 0\n        for (row in 0 until n) {\n            var left = 0\n            var right = 0\n            \n            for (i in 0 until m) {\n                if (table[row][(col + i) % m] == '1') {\n                    left = i\n                    break\n                }\n            }\n            \n            for (i in 0 until m) {\n                if (table[row][(col - i + m) % m] == '1') {\n                    right = i\n                    break\n                }\n            }\n            \n            moves += min(left, right)\n        }\n        \n        minMoves = min(minMoves, moves)\n    }\n    \n    if (minMoves == Int.MAX_VALUE) {\n        println(-1)\n    } else {\n        println(minMoves)\n    }\n}","PHP":"\n<?php\n\nfunction minimumMoves($input) {\n    $lines = explode('\\n', $input);\n    $dimensions = explode(' ', $lines[0]);\n    $n = intval($dimensions[0]);\n    $m = intval($dimensions[1]);\n    \n    $table = array();\n    for ($i = 1; $i <= $n; $i++) {\n        $table[] = str_split($lines[$i]);\n    }\n    \n    $minMoves = PHP_INT_MAX;\n    \n    for ($col = 0; $col < $m; $col++) {\n        $moves = 0;\n        for ($row = 0; $row < $n; $row++) {\n            $ones = 0;\n            for ($i = 0; $i < $m; $i++) {\n                if ($table[$row][$i] == '1') {\n                    $ones++;\n                }\n            }\n            \n            $leftMoves = ($col - $ones + $m) % $m;\n            $rightMoves = ($ones - 1 + $m) % $m;\n            \n            $moves += min($leftMoves, $rightMoves);\n        }\n        \n        $minMoves = min($minMoves, $moves);\n    }\n    \n    if ($minMoves == PHP_INT_MAX) {\n        return '-1';\n    } else {\n        return strval($minMoves);\n    }\n}\n\n$input = '3 6\\n101010\\n000100\\n100000\\n';\n$output = minimumMoves($input);\necho $output;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, m;\\r\\n    scanf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] table = new int[][](n);\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        string row;\\r\\n        scanf(\\\"%s\\\", &row);\\r\\n\\r\\n        foreach (char c; row)\\r\\n        {\\r\\n            table[i] ~= c.to!int;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int minMoves = -1;\\r\\n\\r\\n    for (int col = 0; col < m; col++)\\r\\n    {\\r\\n        int moves = 0;\\r\\n\\r\\n        foreach (row; table)\\r\\n        {\\r\\n            int ones = row.count(1);\\r\\n            int zeros = row.count(0);\\r\\n\\r\\n            if (ones == 0)\\r\\n            {\\r\\n                moves = -1;\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            if (zeros == 0)\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            if (row[col] == 0)\\r\\n            {\\r\\n                moves += min(ones, zeros);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (moves != -1 && (minMoves == -1 || moves < minMoves))\\r\\n        {\\r\\n            minMoves = moves;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(minMoves);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub min_moves {\n    my ($n, $m, @table) = @_;\n\n    my $min_moves = -1;\n    my $found = 0;\n\n    # Iterate through each column\n    for my $col (0..$m-1) {\n        my $moves = 0;\n        my $ones = 0;\n\n        # Count the number of ones in the column\n        for my $row (0..$n-1) {\n            $ones++ if substr($table[$row], $col, 1) eq '1';\n        }\n\n        # Check if the column already consists only of ones\n        if ($ones == $n) {\n            $found = 1;\n            last;\n        }\n\n        # Calculate the minimum number of moves needed for the column\n        for my $shift (0..$n-1) {\n            my $shifted_ones = 0;\n\n            # Count the number of ones after shifting the rows\n            for my $row (0..$n-1) {\n                my $shifted_row = substr($table[$row], ($col + $shift) % $m, 1);\n                $shifted_ones++ if $shifted_row eq '1';\n            }\n\n            # Update the minimum number of moves if necessary\n            if ($shifted_ones == $n || $shifted_ones == $ones) {\n                $moves = $shift;\n                last;\n            }\n        }\n\n        # Update the overall minimum number of moves\n        if ($min_moves == -1 || $moves < $min_moves) {\n            $min_moves = $moves;\n        }\n    }\n\n    return $found ? $min_moves : -1;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\n# Parse input\nmy ($n, $m) = split ' ', $input;\nmy @table;\nfor (1..$n) {\n    my $row = <STDIN>;\n    chomp $row;\n    push @table, $row;\n}\n\n# Calculate and print the minimum number of moves\nmy $result = min_moves($n, $m, @table);\nprint $result . \\\"\\\\n\\\";\n\n","Rust":"\n\nuse std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let nm: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n\n    let mut table: Vec<Vec<u8>> = Vec::new();\n    for i in 1..=n {\n        let row: Vec<u8> = lines[i].chars().map(|x| x.to_digit(10).unwrap() as u8).collect();\n        table.push(row);\n    }\n\n    let mut min_moves = std::usize::MAX;\n\n    for col in 0..m {\n        let mut moves = 0;\n        let mut ones = 0;\n\n        for row in 0..n {\n            if table[row][col] == 1 {\n                ones += 1;\n            }\n        }\n\n        for row in 0..n {\n            let mut left_moves = 0;\n            let mut right_moves = 0;\n\n            for i in 0..row {\n                if table[i][col] == 1 {\n                    left_moves += 1;\n                }\n            }\n\n            for i in row..n {\n                if table[i][col] == 1 {\n                    right_moves += 1;\n                }\n            }\n\n            let total_moves = left_moves + right_moves;\n\n            if ones + total_moves < min_moves {\n                min_moves = ones + total_moves;\n            }\n        }\n    }\n\n    if min_moves == std::usize::MAX {\n        println!(\"-1\");\n    } else {\n        println!(\"{}\", min_moves);\n    }\n}\n"}
{"title":"B. Planets","description":"Goa'uld Apophis captured Jack O'Neill's team again! Jack himself was able to escape, but by that time Apophis's ship had already jumped to hyperspace. But Jack knows on what planet will Apophis land. In order to save his friends, Jack must repeatedly go through stargates to get to this planet.Overall the galaxy has n planets, indexed with numbers from 1 to n. Jack is on the planet with index 1, and Apophis will land on the planet with index n. Jack can move between some pairs of planets through stargates (he can move in both directions); the transfer takes a positive, and, perhaps, for different pairs of planets unequal number of seconds. Jack begins his journey at time 0.It can be that other travellers are arriving to the planet where Jack is currently located. In this case, Jack has to wait for exactly 1 second before he can use the stargate. That is, if at time t another traveller arrives to the planet, Jack can only pass through the stargate at time t+1, unless there are more travellers arriving at time t+1 to the same planet.Knowing the information about travel times between the planets, and the times when Jack would not be able to use the stargate on particular planets, determine the minimum time in which he can get to the planet with index n.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers: n (2\u2264n\u226410^5), the number of planets in the galaxy, and m (0\u2264m\u226410^5) \u2014 the number of pairs of planets between which Jack can travel using stargates. Then m lines follow, containing three integers each: the i-th line contains numbers of planets ai and bi (1\u2264ai,bi\u2264n, ai\u2260bi), which are connected through stargates, and the integer transfer time (in seconds) ci (1\u2264ci\u226410^4) between these planets. It is guaranteed that between any pair of planets there is at most one stargate connection.\nThen n lines follow: the i-th line contains an integer ki (0\u2264ki\u226410^5) that denotes the number of moments of time when other travellers arrive to the planet with index i. Then ki distinct space-separated integers tij (0\u2264tij<10^9) follow, sorted in ascending order. An integer tij means that at time tij (in seconds) another traveller arrives to the planet i. It is guaranteed that the sum of all ki does not exceed 10^5.\n","output_spec":"Print a single number \u2014 the least amount of time Jack needs to get from planet 1 to planet n. If Jack can't get to planet n in any amount of time, print number -1.\n","notes":"In the first sample Jack has three ways to go from planet 1. If he moves to planet 4 at once, he spends 8 seconds. If he transfers to planet 3, he spends 3 seconds, but as other travellers arrive to planet 3 at time 3 and 4, he can travel to planet 4 only at time 5, thus spending 8 seconds in total. But if Jack moves to planet 2, and then \u2014 to planet 4, then he spends a total of only 2+5=7 seconds.\nIn the second sample one can't get from planet 1 to planet 3 by moving through stargates.\n","sample_inputs":["4 6\n1 2 2\n1 3 3\n1 4 8\n2 3 4\n2 4 5\n3 4 3\n0\n1 3\n2 3 4\n0\n","3 1\n1 2 3\n0\n1 3\n0\n"],"sample_outputs":["7\n","-1\n"],"id":"229-B","difficulty":1700,"tags":["binary+search","data+structures","graphs","shortest+paths"],"src_uid":"d5fbb3033bd7508fd468edb9bb995d6c","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <limits>\\n\\nusing namespace std;\\n\\nconst int INF = numeric_limits<int>::max();\\n\\nstruct Edge {\\n    int to;\\n    int weight;\\n    Edge(int _to, int _weight) : to(_to), weight(_weight) {}\\n};\\n\\nvector<int> dijkstra(vector<vector<Edge>>& graph, vector<int>& arrivalTimes) {\\n    int n = graph.size();\\n    vector<int> dist(n, INF);\\n    vector<bool> visited(n, false);\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n\\n    dist[0] = 0;\\n    pq.push({0, 0});\\n\\n    while (!pq.empty()) {\\n        int u = pq.top().second;\\n        pq.pop();\\n\\n        if (visited[u])\\n            continue;\\n\\n        visited[u] = true;\\n\\n        for (const auto& edge : graph[u]) {\\n            int v = edge.to;\\n            int weight = edge.weight;\\n\\n            if (visited[v])\\n                continue;\\n\\n            int waitTime = 0;\\n            if (dist[u] >= arrivalTimes[v])\\n                waitTime = dist[u] - arrivalTimes[v] + 1;\\n\\n            if (dist[u] + weight + waitTime < dist[v]) {\\n                dist[v] = dist[u] + weight + waitTime;\\n                pq.push({dist[v], v});\\n            }\\n        }\\n    }\\n\\n    return dist;\\n}\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    vector<vector<Edge>> graph(n);\\n    for (int i = 0; i < m; ++i) {\\n        int a, b, c;\\n        cin >> a >> b >> c;\\n        graph[a - 1].push_back(Edge(b - 1, c));\\n        graph[b - 1].push_back(Edge(a - 1, c));\\n    }\\n\\n    vector<vector<int>> arrivalTimes(n);\\n    for (int i = 0; i < n; ++i) {\\n        int k;\\n        cin >> k;\\n        arrivalTimes[i].resize(k);\\n        for (int j = 0; j < k; ++j)\\n            cin >> arrivalTimes[i][j];\\n    }\\n\\n    vector<int> dist = dijkstra(graph, arrivalTimes[n - 1]);\\n\\n    if (dist[n - 1] == INF)\\n        cout << -1 << endl;\\n    else\\n        cout << dist[n - 1] << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class StargateTravel {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            int c = scanner.nextInt();\n            graph.get(a).add(new int[]{b, c});\n            graph.get(b).add(new int[]{a, c});\n        }\n        \n        int[] arrivalTimes = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            int k = scanner.nextInt();\n            for (int j = 0; j < k; j++) {\n                arrivalTimes[i] = scanner.nextInt();\n            }\n        }\n        \n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[1] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{1, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int node = curr[0];\n            int time = curr[1];\n            \n            if (time > dist[node]) {\n                continue;\n            }\n            \n            for (int[] neighbor : graph.get(node)) {\n                int nextNode = neighbor[0];\n                int nextTime = time + neighbor[1];\n                \n                if (nextTime < dist[nextNode]) {\n                    dist[nextNode] = nextTime;\n                    pq.offer(new int[]{nextNode, nextTime});\n                }\n            }\n            \n            if (arrivalTimes[node] > 0 && time >= arrivalTimes[node]) {\n                int nextTime = time + 1;\n                if (nextTime < dist[node]) {\n                    dist[node] = nextTime;\n                    pq.offer(new int[]{node, nextTime});\n                }\n            }\n        }\n        \n        if (dist[n] == Integer.MAX_VALUE) {\n            System.out.println(-1);\n        } else {\n            System.out.println(dist[n]);\n        }\n    }\n}","Python":"from heapq import heappop, heappush\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    visited = [False] * n\n    pq = [(0, start)]\n\n    while pq:\n        d, u = heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\ndef solve(n, m, connections, arrivals):\n    graph = [[] for _ in range(n)]\n    for a, b, c in connections:\n        graph[a-1].append((b-1, c))\n        graph[b-1].append((a-1, c))\n\n    dist = dijkstra(graph, 0)\n\n    if dist[n-1] == float('inf'):\n        return '-1'\n    else:\n        return str(dist[n-1])\n\n# Sample inputs\ninputs = ['4 6\\n1 2 2\\n1 3 3\\n1 4 8\\n2 3 4\\n2 4 5\\n3 4 3\\n0\\n1 3\\n2 3 4\\n0\\n', '3 1\\n1 2 3\\n0\\n1 3\\n0\\n']\n\noutputs = []\nfor input_str in inputs:\n    lines = input_str.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    connections = [tuple(map(int, line.split())) for line in lines[1:m+1]]\n    arrivals = [list(map(int, line.split()))[1:] for line in lines[m+1:]]\n\n    outputs.append(solve(n, m, connections, arrivals))\n\n# Print outputs\nfor output in outputs:\n    print(output)\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <limits.h>\\n\\n#define MAX_PLANETS 100000\\n#define MAX_TRAVELS 100000\\n\\nstruct Edge {\\n    int dest;\\n    int weight;\\n    struct Edge* next;\\n};\\n\\nstruct Vertex {\\n    struct Edge* head;\\n};\\n\\nstruct Graph {\\n    int numVertices;\\n    struct Vertex* array;\\n};\\n\\nstruct Edge* createEdge(int dest, int weight) {\\n    struct Edge* newEdge = (struct Edge*)malloc(sizeof(struct Edge));\\n    newEdge->dest = dest;\\n    newEdge->weight = weight;\\n    newEdge->next = NULL;\\n    return newEdge;\\n}\\n\\nstruct Graph* createGraph(int numVertices) {\\n    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));\\n    graph->numVertices = numVertices;\\n    graph->array = (struct Vertex*)malloc(numVertices * sizeof(struct Vertex));\\n    for (int i = 0; i < numVertices; i++) {\\n        graph->array[i].head = NULL;\\n    }\\n    return graph;\\n}\\n\\nvoid addEdge(struct Graph* graph, int src, int dest, int weight) {\\n    struct Edge* newEdge = createEdge(dest, weight);\\n    newEdge->next = graph->array[src].head;\\n    graph->array[src].head = newEdge;\\n}\\n\\nint minDistance(int dist[], int sptSet[], int numVertices) {\\n    int min = INT_MAX, minIndex;\\n    for (int v = 0; v < numVertices; v++) {\\n        if (sptSet[v] == 0 && dist[v] <= min) {\\n            min = dist[v];\\n            minIndex = v;\\n        }\\n    }\\n    return minIndex;\\n}\\n\\nint dijkstra(struct Graph* graph, int src, int dest, int numVertices, int* travelTimes) {\\n    int dist[numVertices];\\n    int sptSet[numVertices];\\n    for (int i = 0; i < numVertices; i++) {\\n        dist[i] = INT_MAX;\\n        sptSet[i] = 0;\\n    }\\n    dist[src] = 0;\\n    for (int count = 0; count < numVertices - 1; count++) {\\n        int u = minDistance(dist, sptSet, numVertices);\\n        sptSet[u] = 1;\\n        struct Edge* currentEdge = graph->array[u].head;\\n        while (currentEdge != NULL) {\\n            int v = currentEdge->dest;\\n            if (sptSet[v] == 0 && dist[u] != INT_MAX && dist[u] + currentEdge->weight < dist[v]) {\\n                dist[v] = dist[u] + currentEdge->weight;\\n            }\\n            currentEdge = currentEdge->next;\\n        }\\n    }\\n    if (dist[dest] == INT_MAX) {\\n        return -1;\\n    }\\n    return dist[dest];\\n}\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    struct Graph* graph = createGraph(n);\\n    for (int i = 0; i < m; i++) {\\n        int a, b, c;\\n        scanf(\\\"%d %d %d\\\", &a, &b, &c);\\n        addEdge(graph, a - 1, b - 1, c);\\n        addEdge(graph, b - 1, a - 1, c);\\n    }\\n    int travelTimes[n];\\n    for (int i = 0; i < n; i++) {\\n        int k;\\n        scanf(\\\"%d\\\", &k);\\n        travelTimes[i] = k;\\n        for (int j = 0; j < k; j++) {\\n            int t;\\n            scanf(\\\"%d\\\", &t);\\n        }\\n    }\\n    int result = dijkstra(graph, 0, n - 1, n, travelTimes);\\n    printf(\\\"%d\\\\n\\\", result);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace StargateTravel\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n\n            List<List<int>> graph = new List<List<int>>();\n            for (int i = 0; i < n; i++)\n            {\n                graph.Add(new List<int>());\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                string connection = Console.ReadLine();\n                string[] connectionArr = connection.Split(' ');\n                int a = int.Parse(connectionArr[0]) - 1;\n                int b = int.Parse(connectionArr[1]) - 1;\n                int c = int.Parse(connectionArr[2]);\n                graph[a].Add(b);\n                graph[b].Add(a);\n            }\n\n            List<int> arrivalTimes = new List<int>();\n            for (int i = 0; i < n; i++)\n            {\n                string arrival = Console.ReadLine();\n                string[] arrivalArr = arrival.Split(' ');\n                int k = int.Parse(arrivalArr[0]);\n                for (int j = 1; j <= k; j++)\n                {\n                    int t = int.Parse(arrivalArr[j]);\n                    arrivalTimes.Add(t);\n                }\n            }\n\n            int[] distances = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                distances[i] = int.MaxValue;\n            }\n            distances[0] = 0;\n\n            Queue<int> queue = new Queue<int>();\n            queue.Enqueue(0);\n\n            while (queue.Count > 0)\n            {\n                int current = queue.Dequeue();\n\n                foreach (int neighbor in graph[current])\n                {\n                    int travelTime = distances[current] + 1;\n                    if (arrivalTimes.Contains(travelTime))\n                    {\n                        travelTime++;\n                    }\n\n                    if (travelTime < distances[neighbor])\n                    {\n                        distances[neighbor] = travelTime;\n                        queue.Enqueue(neighbor);\n                    }\n                }\n            }\n\n            if (distances[n - 1] == int.MaxValue)\n            {\n                Console.WriteLine(-1);\n            }\n            else\n            {\n                Console.WriteLine(distances[n - 1]);\n            }\n        }\n    }\n}","Ruby":"\ndef minimum_time(n, m, connections, arrivals)\n  # Create an adjacency list to represent the connections between planets\n  adjacency_list = Array.new(n) { [] }\n  connections.each do |a, b, c|\n    adjacency_list[a - 1] << [b - 1, c]\n    adjacency_list[b - 1] << [a - 1, c]\n  end\n\n  # Initialize an array to store the minimum time to reach each planet\n  min_time = Array.new(n, Float::INFINITY)\n  min_time[0] = 0\n\n  # Initialize a priority queue to store the planets to visit\n  queue = [[0, 0]] # [time, planet]\n  \n  while !queue.empty?\n    current_time, current_planet = queue.shift\n\n    # Check if the current planet is the destination\n    if current_planet == n - 1\n      return current_time\n    end\n\n    # Check if there are any arrivals at the current planet\n    if arrivals[current_planet].include?(current_time)\n      current_time += 1\n    end\n\n    # Iterate through the neighboring planets\n    adjacency_list[current_planet].each do |neighbor, transfer_time|\n      next_time = current_time + transfer_time\n\n      # Check if there are any arrivals at the neighboring planet\n      if arrivals[neighbor].include?(next_time)\n        next_time += 1\n      end\n\n      # Update the minimum time to reach the neighboring planet if necessary\n      if next_time < min_time[neighbor]\n        min_time[neighbor] = next_time\n        queue << [next_time, neighbor]\n      end\n    end\n\n    # Sort the queue based on the minimum time\n    queue.sort_by! { |time, planet| time }\n  end\n\n  # If the destination planet is not reachable, return -1\n  return -1\nend\n\n# Parse the input\ninput = gets.chomp.split(\"\\n\")\nn, m = input[0].split.map(&:to_i)\nconnections = input[1..m].map { |line| line.split.map(&:to_i) }\narrivals = input[m+1..-1].map { |line| line.split.map(&:to_i)[1..-1] }\n\n# Call the function and print the result\nputs minimum_time(n, m, connections, arrivals)\n","delphi":"program StargateTravel;\\n\\nconst\\n  MAXN = 100000;\\n  MAXM = 100000;\\n  MAXT = 100000;\\n  INF = 1000000000;\\n\\nvar\\n  n, m: Integer;\\n  a, b, c: array[1..MAXM] of Integer;\\n  k: array[1..MAXN] of Integer;\\n  t: array[1..MAXN, 1..MAXT] of Integer;\\n  d: array[1..MAXN] of Integer;\\n  q: array[1..MAXN] of Integer;\\n  head, tail: Integer;\\n  i, j, u, v, w: Integer;\\n\\nbegin\\n  ReadLn(n, m);\\n  for i := 1 to m do\\n    ReadLn(a[i], b[i], c[i]);\\n  for i := 1 to n do\\n  begin\\n    ReadLn(k[i]);\\n    for j := 1 to k[i] do\\n      Read(t[i, j]);\\n  end;\\n\\n  for i := 1 to n do\\n    d[i] := INF;\\n  d[1] := 0;\\n\\n  head := 1;\\n  tail := 1;\\n  q[1] := 1;\\n\\n  while head <= tail do\\n  begin\\n    u := q[head];\\n    Inc(head);\\n\\n    for i := 1 to m do\\n    begin\\n      if a[i] = u then\\n      begin\\n        v := b[i];\\n        w := c[i];\\n      end\\n      else if b[i] = u then\\n      begin\\n        v := a[i];\\n        w := c[i];\\n      end\\n      else\\n        Continue;\\n\\n      if d[u] + w < d[v] then\\n      begin\\n        d[v] := d[u] + w;\\n        Inc(tail);\\n        q[tail] := v;\\n      end;\\n    end;\\n\\n    for i := 1 to k[u] do\\n    begin\\n      if d[u] + 1 < d[u + 1] then\\n      begin\\n        d[u + 1] := d[u] + 1;\\n        Inc(tail);\\n        q[tail] := u + 1;\\n      end;\\n    end;\\n  end;\\n\\n  if d[n] = INF then\\n    WriteLn(-1)\\n  else\\n    WriteLn(d[n]);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nm[0])\\n\\tm, _ := strconv.Atoi(nm[1])\\n\\n\\tgraph := make([][]int, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tabt := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\ta, _ := strconv.Atoi(abt[0])\\n\\t\\tb, _ := strconv.Atoi(abt[1])\\n\\t\\tt, _ := strconv.Atoi(abt[2])\\n\\n\\t\\tgraph[a] = append(graph[a], b)\\n\\t\\tgraph[b] = append(graph[b], a)\\n\\t}\\n\\n\\twaitTimes := make([][]int, n+1)\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tk, _ := strconv.Atoi(scanner.Text())\\n\\t\\twaitTimes[i] = make([]int, k)\\n\\n\\t\\tscanner.Scan()\\n\\t\\ttimes := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\tfor j := 0; j < k; j++ {\\n\\t\\t\\twaitTimes[i][j], _ = strconv.Atoi(times[j])\\n\\t\\t}\\n\\t}\\n\\n\\tvisited := make([]bool, n+1)\\n\\tdist := make([]int, n+1)\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tdist[i] = -1\\n\\t}\\n\\n\\tqueue := make([]int, 0)\\n\\tqueue = append(queue, 1)\\n\\tvisited[1] = true\\n\\tdist[1] = 0\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tnode := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\n\\t\\tfor _, neighbor := range graph[node] {\\n\\t\\t\\tif !visited[neighbor] {\\n\\t\\t\\t\\tvisited[neighbor] = true\\n\\t\\t\\t\\tqueue = append(queue, neighbor)\\n\\t\\t\\t\\tdist[neighbor] = dist[node] + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tminTime := -1\\n\\n\\tfor _, time := range waitTimes[n] {\\n\\t\\tif dist[n] != -1 && (minTime == -1 || dist[n]+time < minTime) {\\n\\t\\t\\tminTime = dist[n] + time\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minTime)\\n}","Javascript":"\nfunction findMinimumTime(n, m, connections, arrivals) {\n  const INF = Number.MAX_SAFE_INTEGER;\n  \n  \/\/ Create adjacency matrix\n  const graph = new Array(n);\n  for (let i = 0; i < n; i++) {\n    graph[i] = new Array(n).fill(INF);\n    graph[i][i] = 0;\n  }\n  \n  \/\/ Fill in travel times between planets\n  for (let i = 0; i < m; i++) {\n    const [a, b, c] = connections[i];\n    graph[a - 1][b - 1] = c;\n    graph[b - 1][a - 1] = c;\n  }\n  \n  \/\/ Fill in arrival times for each planet\n  const arrivalTimes = new Array(n);\n  for (let i = 0; i < n; i++) {\n    arrivalTimes[i] = arrivals[i].slice(1);\n  }\n  \n  \/\/ Dijkstra's algorithm to find shortest path\n  const dist = new Array(n).fill(INF);\n  const visited = new Array(n).fill(false);\n  dist[0] = 0;\n  \n  for (let i = 0; i < n - 1; i++) {\n    let minDist = INF;\n    let minIndex = -1;\n    \n    \/\/ Find the planet with the minimum distance\n    for (let j = 0; j < n; j++) {\n      if (!visited[j] && dist[j] < minDist) {\n        minDist = dist[j];\n        minIndex = j;\n      }\n    }\n    \n    \/\/ Mark the planet as visited\n    visited[minIndex] = true;\n    \n    \/\/ Update the distances of adjacent planets\n    for (let j = 0; j < n; j++) {\n      if (!visited[j] && graph[minIndex][j] !== INF) {\n        const travelTime = graph[minIndex][j];\n        const arrivalTime = findNextAvailableTime(arrivalTimes[j], dist[minIndex]);\n        dist[j] = Math.min(dist[j], dist[minIndex] + travelTime + arrivalTime);\n      }\n    }\n  }\n  \n  return dist[n - 1] === INF ? -1 : dist[n - 1];\n}\n\nfunction findNextAvailableTime(arrivalTimes, currentTime) {\n  let nextTime = currentTime;\n  for (let i = 0; i < arrivalTimes.length; i++) {\n    if (arrivalTimes[i] > nextTime) {\n      return arrivalTimes[i] - nextTime;\n    }\n    nextTime++;\n  }\n  return 0;\n}\n\n\/\/ Sample inputs\nconst inputs = [\n  '4 6\\n1 2 2\\n1 3 3\\n1 4 8\\n2 3 4\\n2 4 5\\n3 4 3\\n0\\n1 3\\n2 3 4\\n0\\n',\n  '3 1\\n1 2 3\\n0\\n1 3\\n0\\n'\n];\n\n\/\/ Process each input\nconst outputs = [];\nfor (let i = 0; i < inputs.length; i++) {\n  const lines = inputs[i].trim().split('\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  \n  const connections = [];\n  for (let j = 1; j <= m; j++) {\n    connections.push(lines[j].split(' ').map(Number));\n  }\n  \n  const arrivals = [];\n  for (let j = m + 1; j <= m + n; j++) {\n    arrivals.push(lines[j].split(' ').map(Number));\n  }\n  \n  const result = findMinimumTime(n, m, connections, arrivals);\n  outputs.push(result);\n}\n\n\/\/ Print outputs\nconsole.log(outputs.join('\\\\n'));\n","Kotlin":"import java.util.*\n\ndata class Planet(val index: Int, val transferTimes: MutableList<Int>)\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n\n    val planets = Array(n) { Planet(it + 1, mutableListOf()) }\n\n    for (i in 0 until m) {\n        val stargate = readLine()!!.split(\" \")\n        val planet1 = stargate[0].toInt()\n        val planet2 = stargate[1].toInt()\n        val transferTime = stargate[2].toInt()\n\n        planets[planet1 - 1].transferTimes.add(transferTime)\n        planets[planet2 - 1].transferTimes.add(transferTime)\n    }\n\n    for (i in 0 until n) {\n        val k = readLine()!!.toInt()\n        if (k > 0) {\n            val arrivalTimes = readLine()!!.split(\" \").map { it.toInt() }\n            planets[i].transferTimes.addAll(arrivalTimes)\n        }\n    }\n\n    val distances = IntArray(n) { Int.MAX_VALUE }\n    val queue: Queue<Int> = LinkedList()\n\n    distances[0] = 0\n    queue.add(0)\n\n    while (queue.isNotEmpty()) {\n        val currentPlanet = queue.poll()\n\n        for (transferTime in planets[currentPlanet].transferTimes) {\n            val nextPlanet = currentPlanet + transferTime\n\n            if (nextPlanet < n && distances[currentPlanet] + transferTime < distances[nextPlanet]) {\n                distances[nextPlanet] = distances[currentPlanet] + transferTime\n                queue.add(nextPlanet)\n            }\n        }\n    }\n\n    if (distances[n - 1] == Int.MAX_VALUE) {\n        println(-1)\n    } else {\n        println(distances[n - 1])\n    }\n}","PHP":"\n<?php\n\nfunction findMinimumTime($n, $m, $connections, $arrivalTimes) {\n    \/\/ Create an adjacency list to represent the connections between planets\n    $adjList = array_fill(1, $n, []);\n    foreach ($connections as $connection) {\n        $planet1 = $connection[0];\n        $planet2 = $connection[1];\n        $time = $connection[2];\n        $adjList[$planet1][] = [$planet2, $time];\n        $adjList[$planet2][] = [$planet1, $time];\n    }\n    \n    \/\/ Initialize an array to store the minimum time to reach each planet\n    $minTime = array_fill(1, $n, INF);\n    $minTime[1] = 0;\n    \n    \/\/ Initialize a priority queue to store the planets to visit\n    $pq = new SplPriorityQueue();\n    $pq->insert(1, 0);\n    \n    while (!$pq->isEmpty()) {\n        $currentPlanet = $pq->extract();\n        \n        \/\/ Check if the current planet is the destination planet\n        if ($currentPlanet == $n) {\n            return $minTime[$n];\n        }\n        \n        \/\/ Check if there are any arrival times for the current planet\n        if (isset($arrivalTimes[$currentPlanet])) {\n            $arrivals = $arrivalTimes[$currentPlanet];\n            foreach ($arrivals as $arrival) {\n                if ($arrival > $minTime[$currentPlanet]) {\n                    break;\n                }\n                $minTime[$currentPlanet]++;\n            }\n        }\n        \n        \/\/ Explore the neighboring planets\n        foreach ($adjList[$currentPlanet] as $neighbor) {\n            $neighborPlanet = $neighbor[0];\n            $neighborTime = $neighbor[1];\n            \n            \/\/ Calculate the time to reach the neighboring planet\n            $timeToReachNeighbor = $minTime[$currentPlanet] + $neighborTime;\n            \n            \/\/ Update the minimum time if the new time is smaller\n            if ($timeToReachNeighbor < $minTime[$neighborPlanet]) {\n                $minTime[$neighborPlanet] = $timeToReachNeighbor;\n                $pq->insert($neighborPlanet, -$timeToReachNeighbor);\n            }\n        }\n    }\n    \n    return -1; \/\/ If it's not possible to reach the destination planet\n}\n\n\/\/ Read the input\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\nlist($n, $m) = explode(' ', $input[0]);\n$connections = [];\nfor ($i = 1; $i <= $m; $i++) {\n    $connection = explode(' ', $input[$i]);\n    $connections[] = $connection;\n}\n$arrivalTimes = [];\nfor ($i = $m + 1; $i <= $m + $n; $i++) {\n    $arrival = explode(' ', $input[$i]);\n    $planet = $i - $m;\n    $arrivalTimes[$planet] = $arrival;\n}\n\n\/\/ Find the minimum time\n$minimumTime = findMinimumTime($n, $m, $connections, $arrivalTimes);\n\n\/\/ Print the result\necho $minimumTime;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.functional;\\r\\nimport std.range;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Planet\\r\\n{\\r\\n    int index;\\r\\n    int time;\\r\\n    int[] travellers;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    Planet[] planets;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int k;\\r\\n        readf(\\\"%d\\\", &k);\\r\\n\\r\\n        int[] travellers;\\r\\n        foreach (_; 0..k)\\r\\n        {\\r\\n            int t;\\r\\n            readf(\\\"%d\\\", &t);\\r\\n            travellers ~= t;\\r\\n        }\\r\\n\\r\\n        planets ~= Planet(0, 0, travellers);\\r\\n    }\\r\\n\\r\\n    foreach (_; 0..m)\\r\\n    {\\r\\n        int a, b, c;\\r\\n        readf(\\\"%d %d %d\\\", &a, &b, &c);\\r\\n\\r\\n        planets[a - 1].index = a;\\r\\n        planets[b - 1].index = b;\\r\\n        planets[a - 1].time = c;\\r\\n        planets[b - 1].time = c;\\r\\n    }\\r\\n\\r\\n    planets[0].time = 0;\\r\\n\\r\\n    int[] distances;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        distances ~= int.max;\\r\\n    }\\r\\n\\r\\n    distances[0] = 0;\\r\\n\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int minIndex = -1;\\r\\n        int minDistance = int.max;\\r\\n\\r\\n        foreach (i, distance; distances.enumerate)\\r\\n        {\\r\\n            if (distance < minDistance)\\r\\n            {\\r\\n                minIndex = i;\\r\\n                minDistance = distance;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (minIndex == -1)\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        distances[minIndex] = int.max;\\r\\n\\r\\n        foreach (planet; planets)\\r\\n        {\\r\\n            if (planet.index == 0)\\r\\n            {\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            int distance = minDistance + planet.time;\\r\\n\\r\\n            if (distance < distances[planet.index - 1])\\r\\n            {\\r\\n                distances[planet.index - 1] = distance;\\r\\n            }\\r\\n\\r\\n            foreach (traveller; planet.travellers)\\r\\n            {\\r\\n                if (traveller >= distance && traveller < distances[planet.index - 1])\\r\\n                {\\r\\n                    distances[planet.index - 1] = traveller + 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (distances[n - 1] == int.max)\\r\\n    {\\r\\n        writeln(\\\"-1\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(distances[n - 1]);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_minimum_time {\n    my ($n, $m, $connections, $arrival_times) = @_;\n\n    my @graph;\n    for (my $i = 0; $i < $n; $i++) {\n        $graph[$i] = [];\n    }\n\n    for (my $i = 0; $i < $m; $i++) {\n        my ($a, $b, $c) = @{$connections->[$i]};\n        push @{$graph[$a-1]}, [$b-1, $c];\n        push @{$graph[$b-1]}, [$a-1, $c];\n    }\n\n    my @distances = (1e9) x $n;\n    my @visited = (0) x $n;\n    my @queue = ();\n\n    push @queue, [0, 0];\n    $distances[0] = 0;\n\n    while (@queue) {\n        my ($node, $time) = @{shift @queue};\n        next if $visited[$node];\n        $visited[$node] = 1;\n\n        foreach my $neighbor (@{$graph[$node]}) {\n            my ($next_node, $transfer_time) = @{$neighbor};\n            my $arrival_time = $time + $transfer_time;\n\n            if ($arrival_times->[$next_node][0] == $arrival_time) {\n                $arrival_time++;\n            } elsif ($arrival_times->[$next_node][0] > $arrival_time) {\n                $arrival_time = $arrival_times->[$next_node][0];\n            }\n\n            if ($arrival_time < $distances[$next_node]) {\n                $distances[$next_node] = $arrival_time;\n                push @queue, [$next_node, $arrival_time];\n            }\n        }\n    }\n\n    return $distances[$n-1] == 1e9 ? -1 : $distances[$n-1];\n}\n\n# Read input\nmy ($n, $m) = split ' ', <STDIN>;\nmy @connections;\nfor (my $i = 0; $i < $m; $i++) {\n    my ($a, $b, $c) = split ' ', <STDIN>;\n    push @connections, [$a, $b, $c];\n}\n\nmy @arrival_times;\nfor (my $i = 0; $i < $n; $i++) {\n    my $k = <STDIN>;\n    my @times = split ' ', <STDIN>;\n    push @arrival_times, \\@times;\n}\n\n# Find minimum time\nmy $minimum_time = find_minimum_time($n, $m, \\@connections, \\@arrival_times);\n\n# Print output\nprint $minimum_time . \\\"\\\\n\\\";\n","Rust":"use std::cmp::Reverse;\\nuse std::collections::{BinaryHeap, HashMap};\\n\\nfn main() {\\n    let input = std::fs::read_to_string(\\\"input.txt\\\").unwrap();\\n    let mut lines = input.lines();\\n    let nm: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nm[0];\\n    let m = nm[1];\\n\\n    let mut graph: HashMap<usize, Vec<(usize, usize)>> = HashMap::new();\\n\\n    for _ in 0..m {\\n        let abt: Vec<usize> = lines\\n            .next()\\n            .unwrap()\\n            .split_whitespace()\\n            .map(|x| x.parse().unwrap())\\n            .collect();\\n        let a = abt[0];\\n        let b = abt[1];\\n        let t = abt[2];\\n\\n        graph.entry(a).or_insert(Vec::new()).push((b, t));\\n        graph.entry(b).or_insert(Vec::new()).push((a, t));\\n    }\\n\\n    let mut arrivals: HashMap<usize, Vec<usize>> = HashMap::new();\\n\\n    for i in 1..=n {\\n        let ki: Vec<usize> = lines\\n            .next()\\n            .unwrap()\\n            .split_whitespace()\\n            .map(|x| x.parse().unwrap())\\n            .collect();\\n        arrivals.insert(i, ki[1..].to_vec());\\n    }\\n\\n    let mut dist: HashMap<usize, usize> = HashMap::new();\\n    let mut pq: BinaryHeap<Reverse<(usize, usize)>> = BinaryHeap::new();\\n\\n    dist.insert(1, 0);\\n    pq.push(Reverse((0, 1)));\\n\\n    while let Some(Reverse((d, u))) = pq.pop() {\\n        if u == n {\\n            println!(\\\"{}\\\", d);\\n            return;\\n        }\\n\\n        if let Some(arrival_times) = arrivals.get(&u) {\\n            let mut wait_time = 0;\\n            for &arrival in arrival_times {\\n                if arrival > d + wait_time {\\n                    break;\\n                }\\n                wait_time += 1;\\n            }\\n            pq.push(Reverse((d + wait_time, u)));\\n        }\\n\\n        if let Some(neighbors) = graph.get(&u) {\\n            for &(v, t) in neighbors {\\n                if let Some(&d_u) = dist.get(&u) {\\n                    let new_dist = d_u + t;\\n                    if let Some(&d_v) = dist.get(&v) {\\n                        if new_dist < d_v {\\n                            dist.insert(v, new_dist);\\n                            pq.push(Reverse((new_dist, v)));\\n                        }\\n                    } else {\\n                        dist.insert(v, new_dist);\\n                        pq.push(Reverse((new_dist, v)));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    println!(\\\"-1\\\");\\n}"}
{"title":"D. Towers","description":"The city of D consists of n towers, built consecutively on a straight line. The height of the tower that goes i-th (from left to right) in the sequence equals hi. The city mayor decided to rebuild the city to make it beautiful. In a beautiful city all towers are are arranged in non-descending order of their height from left to right.The rebuilding consists of performing several (perhaps zero) operations. An operation constitutes using a crane to take any tower and put it altogether on the top of some other neighboring tower. In other words, we can take the tower that stands i-th and put it on the top of either the (i-1)-th tower (if it exists), or the (i+1)-th tower (of it exists). The height of the resulting tower equals the sum of heights of the two towers that were put together. After that the two towers can't be split by any means, but more similar operations can be performed on the resulting tower. Note that after each operation the total number of towers on the straight line decreases by 1.Help the mayor determine the minimum number of operations required to make the city beautiful.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer n (1\u2264n\u22645000)\u00a0\u2014 the number of towers in the city. The next line contains n space-separated integers: the i-th number hi (1\u2264hi\u226410^5) determines the height of the tower that is i-th (from left to right) in the initial tower sequence.\n","output_spec":"Print a single integer \u2014 the minimum number of operations needed to make the city beautiful.\n","notes":null,"sample_inputs":["5\n8 2 7 3 1\n","3\n5 2 1\n"],"sample_outputs":["3\n","2\n"],"id":"229-D","difficulty":2100,"tags":["dp","greedy","two+pointers"],"src_uid":"1c74a21045b2d312f68565bdaaaa8a7b","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> heights(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> heights[i];\\n    }\\n    \\n    int operations = 0;\\n    \\n    for (int i = 1; i < n; i++) {\\n        if (heights[i] < heights[i-1]) {\\n            operations += heights[i-1] - heights[i];\\n            heights[i] = heights[i-1];\\n        }\\n    }\\n    \\n    cout << operations << endl;\\n    \\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class TowerRebuilding {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] heights = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            heights[i] = scanner.nextInt();\\n        }\\n        int operations = getMinimumOperations(heights);\\n        System.out.println(operations);\\n    }\\n\\n    public static int getMinimumOperations(int[] heights) {\\n        int operations = 0;\\n        for (int i = 1; i < heights.length; i++) {\\n            if (heights[i] < heights[i - 1]) {\\n                operations += heights[i - 1] - heights[i];\\n                heights[i] = heights[i - 1];\\n            }\\n        }\\n        return operations;\\n    }\\n}\"}}","Python":"def min_operations(n, heights):\n    operations = 0\n    for i in range(1, n):\n        if heights[i] < heights[i-1]:\n            operations += heights[i-1] - heights[i]\n            heights[i] = heights[i-1]\n    return operations\n\nn = int(input())\nheights = list(map(int, input().split()))\nresult = min_operations(n, heights)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int heights[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &heights[i]);\\n    }\\n\\n    int operations = 0;\\n    for (int i = 1; i < n; i++) {\\n        if (heights[i] < heights[i-1]) {\\n            operations += heights[i-1] - heights[i];\\n            heights[i] = heights[i-1];\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", operations);\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] heights = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n        int operations = 0;\n        for (int i = 1; i < n; i++)\n        {\n            if (heights[i] < heights[i - 1])\n            {\n                operations += heights[i - 1] - heights[i];\n                heights[i] = heights[i - 1];\n            }\n        }\n\n        Console.WriteLine(operations);\n    }\n}","Ruby":"\ndef minimum_operations(n, heights)\n  operations = 0\n\n  # Iterate through each tower\n  (1...n).each do |i|\n    # If the current tower is taller than the previous tower\n    if heights[i] < heights[i-1]\n      # Calculate the difference in height\n      diff = heights[i-1] - heights[i]\n\n      # Add the difference to the current tower\n      heights[i] += diff\n\n      # Increment the number of operations\n      operations += diff\n\n      # If the current tower is still shorter than the previous tower\n      if heights[i] < heights[i-1]\n        # Add the difference to the next tower\n        heights[i+1] += diff\n\n        # Increment the number of operations\n        operations += diff\n      end\n    end\n  end\n\n  operations\nend\n\n# Read input\ninput = gets.chomp.split(\"\\n\")\nn = input[0].to_i\nheights = input[1].split.map(&:to_i)\n\n# Calculate and print the minimum number of operations\nputs minimum_operations(n, heights)\n","delphi":"program BeautifulCity;\\n\\nvar\\n  n, i, j, operations: integer;\\n  towers: array of integer;\\n\\nbegin\\n  readln(n);\\n  SetLength(towers, n);\\n  for i := 0 to n-1 do\\n    read(towers[i]);\\n\\n  operations := 0;\\n\\n  for i := 1 to n-1 do\\n  begin\\n    if towers[i] < towers[i-1] then\\n    begin\\n      operations := operations + towers[i-1] - towers[i];\\n      towers[i] := towers[i-1];\\n    end;\\n  end;\\n\\n  writeln(operations);\\nend.}","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\theights := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&heights[i])\\n\\t}\\n\\n\\tsortedHeights := make([]int, n)\\n\\tcopy(sortedHeights, heights)\\n\\tsort.Ints(sortedHeights)\\n\\n\\topCount := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif heights[i] != sortedHeights[i] {\\n\\t\\t\\topCount++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(opCount)\\n}","Javascript":"function minimumOperations(n, heights) {\n    let operations = 0;\n    \n    for (let i = 1; i < n; i++) {\n        if (heights[i] < heights[i-1]) {\n            operations += heights[i-1] - heights[i];\n            heights[i] = heights[i-1];\n        }\n    }\n    \n    return operations;\n}\n\nconst input = '5\\\\n8 2 7 3 1\\\\n';\nconst lines = input.split('\\\\n');\nconst n = parseInt(lines[0]);\nconst heights = lines[1].split(' ').map(Number);\n\nconst result = minimumOperations(n, heights);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val heights = IntArray(n)\n    for (i in 0 until n) {\n        heights[i] = scanner.nextInt()\n    }\n    \n    val operations = findMinimumOperations(heights)\n    println(operations)\n}\n\nfun findMinimumOperations(heights: IntArray): Int {\n    val n = heights.size\n    val dp = IntArray(n)\n    for (i in 1 until n) {\n        dp[i] = Int.MAX_VALUE\n    }\n    \n    for (i in 1 until n) {\n        for (j in 0 until i) {\n            if (heights[i] >= heights[j]) {\n                dp[i] = minOf(dp[i], dp[j] + 1)\n            }\n        }\n    }\n    \n    return dp[n - 1]\n}","PHP":"<?php\\n\\nfunction minimumOperations($n, $heights) {\\n    $operations = 0;\\n    $sortedHeights = $heights;\\n    sort($sortedHeights);\\n    \\n    for ($i = 0; $i < $n; $i++) {\\n        if ($heights[$i] != $sortedHeights[$i]) {\\n            $operations++;\\n        }\\n    }\\n    \\n    return $operations;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n$n = intval($input[0]);\\n$heights = array_map('intval', explode(\\\" \\\", $input[1]));\\n\\n$output = minimumOperations($n, $heights);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] heights;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    heights.length = n;\\r\\n    readf(\\\"%s\\\", &heights);\\r\\n\\r\\n    int operations = 0;\\r\\n\\r\\n    \/\/ Perform operations to make the city beautiful\\r\\n    for (int i = 1; i < n; i++)\\r\\n    {\\r\\n        if (heights[i] < heights[i - 1])\\r\\n        {\\r\\n            operations += heights[i - 1] - heights[i];\\r\\n            heights[i] = heights[i - 1];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the minimum number of operations\\r\\n    writeln(operations);\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub min_operations {\n    my ($n, @heights) = @_;\n\n    my $operations = 0;\n\n    for my $i (1..$n-1) {\n        if ($heights[$i] < $heights[$i-1]) {\n            $operations += $heights[$i-1] - $heights[$i];\n            $heights[$i] = $heights[$i-1];\n        }\n    }\n\n    return $operations;\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy $heights = <>;\nchomp $heights;\nmy @heights = split ' ', $heights;\n\n# Call the function and print the result\nmy $result = min_operations($n, @heights);\nprint $result;\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let mut lines = input.lines();\n    let _n = lines.next().unwrap().parse::<usize>().unwrap();\n    let heights: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut operations = 0;\n    let mut current_height = heights[0];\n    \n    for i in 1..heights.len() {\n        if heights[i] < current_height {\n            operations += current_height - heights[i];\n        } else {\n            current_height = heights[i];\n        }\n    }\n    \n    println!(\"{}\", operations);\n}"}
{"title":"A. Second Order Statistics","description":"Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains integer n (1\u2264n\u2264100) \u2014 amount of numbers in the sequence. The second line contains n space-separated integer numbers \u2014 elements of the sequence. These numbers don't exceed 100 in absolute value.\n","output_spec":"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.\n","notes":null,"sample_inputs":["4\n1 2 2 -4\n","5\n1 2 3 1 1\n"],"sample_outputs":["1\n","2\n"],"id":"22-A","difficulty":800,"tags":["brute+force"],"src_uid":"930be5ec102fbe062062aa23eac75187","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> sequence(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> sequence[i];\\n    }\\n    sort(sequence.begin(), sequence.end());\\n    int secondOrderStatistics = -1;\\n    for (int i = 1; i < n; i++) {\\n        if (sequence[i] > sequence[0]) {\\n            secondOrderStatistics = sequence[i];\\n            break;\\n        }\\n    }\\n    if (secondOrderStatistics != -1) {\\n        cout << secondOrderStatistics << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class SecondOrderStatistics {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] sequence = new int[n];\n        for (int i = 0; i < n; i++) {\n            sequence[i] = scanner.nextInt();\n        }\n        \n        int secondOrderStatistics = findSecondOrderStatistics(sequence);\n        if (secondOrderStatistics != Integer.MAX_VALUE) {\n            System.out.println(secondOrderStatistics);\n        } else {\n            System.out.println(\\\"NO\\\");\n        }\n    }\n    \n    public static int findSecondOrderStatistics(int[] sequence) {\n        Arrays.sort(sequence);\n        Set<Integer> uniqueNumbers = new HashSet<>();\n        for (int num : sequence) {\n            uniqueNumbers.add(num);\n        }\n        \n        if (uniqueNumbers.size() > 1) {\n            int min = sequence[0];\n            for (int i = 1; i < sequence.length; i++) {\n                if (sequence[i] > min) {\n                    return sequence[i];\n                }\n            }\n        }\n        \n        return Integer.MAX_VALUE;\n    }\n}","Python":"def find_second_order_statistics(n, sequence):\n    sequence.sort()\n    if len(set(sequence)) < 2:\n        return 'NO'\n    else:\n        return str(sequence[1])\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nresult = find_second_order_statistics(n, sequence)\nprint(result)","C":"#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\\\"%d\\\", &n);\n    \n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\\\"%d\\\", &arr[i]);\n    }\n    \n    int min = arr[0];\n    int secondMin = 101;\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] < min) {\n            secondMin = min;\n            min = arr[i];\n        } else if (arr[i] < secondMin && arr[i] != min) {\n            secondMin = arr[i];\n        }\n    }\n    \n    if (secondMin == 101) {\n        printf(\\\"NO\\\");\n    } else {\n        printf(\\\"%d\\\", secondMin);\n    }\n    \n    return 0;\n}","C#":"using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] numbers = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int secondOrderStatistics = FindSecondOrderStatistics(numbers);\n\n        if (secondOrderStatistics != -1)\n        {\n            Console.WriteLine(secondOrderStatistics);\n        }\n        else\n        {\n            Console.WriteLine(\\\"NO\\\");\n        }\n    }\n\n    static int FindSecondOrderStatistics(int[] numbers)\n    {\n        int min = int.MaxValue;\n        int secondMin = int.MaxValue;\n\n        foreach (int num in numbers)\n        {\n            if (num < min)\n            {\n                secondMin = min;\n                min = num;\n            }\n            else if (num < secondMin && num != min)\n            {\n                secondMin = num;\n            }\n        }\n\n        if (secondMin == int.MaxValue)\n        {\n            return -1;\n        }\n\n        return secondMin;\n    }\n}","Ruby":"\ndef second_order_statistics(n, sequence)\n  sequence.sort!\n  min = sequence[0]\n  for i in 1..n-1\n    if sequence[i] > min\n      return sequence[i]\n    end\n  end\n  return 'NO'\nend\n\n# Read input\nn = gets.to_i\nsequence = gets.split.map(&:to_i)\n\n# Call the function and print the result\nresult = second_order_statistics(n, sequence)\nputs result\n","delphi":"program SecondOrderStatistics;\\n\\nvar\\n  n, i, min, secondMin: integer;\\n  sequence: array[1..100] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(sequence[i]);\\n  min := sequence[1];\\n  secondMin := 101;\\n  for i := 2 to n do\\n  begin\\n    if sequence[i] < min then\\n    begin\\n      secondMin := min;\\n      min := sequence[i];\\n    end\\n    else if (sequence[i] > min) and (sequence[i] < secondMin) then\\n      secondMin := sequence[i];\\n  end;\\n  if secondMin = 101 then\\n    writeln('NO')\\n  else\\n    writeln(secondMin);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\n\\t\/\/ Read the amount of numbers in the sequence\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\/\/ Read the sequence\\n\\tscanner.Scan()\\n\\tnumbers := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\t\/\/ Convert the sequence to integers\\n\\tsequence := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tsequence[i], _ = strconv.Atoi(numbers[i])\\n\\t}\\n\\n\\t\/\/ Sort the sequence\\n\\tsort.Ints(sequence)\\n\\n\\t\/\/ Find the second order statistics\\n\\tsecondOrder := -1\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif sequence[i] > sequence[0] {\\n\\t\\t\\tsecondOrder = sequence[i]\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Output the result\\n\\tif secondOrder != -1 {\\n\\t\\tfmt.Println(secondOrder)\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function findSecondOrderStatistics(n, sequence) {\n    \/\/ Convert the sequence string into an array of integers\n    sequence = sequence.split(' ').map(Number);\n    \n    \/\/ Sort the sequence in ascending order\n    sequence.sort((a, b) => a - b);\n    \n    \/\/ Find the second order statistics\n    let secondOrderStatistics = -1;\n    for (let i = 1; i < n; i++) {\n        if (sequence[i] > sequence[0]) {\n            secondOrderStatistics = sequence[i];\n            break;\n        }\n    }\n    \n    \/\/ Return the result\n    if (secondOrderStatistics !== -1) {\n        return secondOrderStatistics.toString();\n    } else {\n        return 'NO';\n    }\n}\n\n\/\/ Test the function with the sample inputs\nconsole.log(findSecondOrderStatistics(4, '1 2 2 -4')); \/\/ Output: 1\nconsole.log(findSecondOrderStatistics(5, '1 2 3 1 1')); \/\/ Output: 2","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val sequence = IntArray(n)\n    for (i in 0 until n) {\n        sequence[i] = scanner.nextInt()\n    }\n    \n    sequence.sort()\n    var secondOrderStatistics = -1\n    for (i in 1 until n) {\n        if (sequence[i] > sequence[0]) {\n            secondOrderStatistics = sequence[i]\n            break\n        }\n    }\n    \n    if (secondOrderStatistics != -1) {\n        println(secondOrderStatistics)\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"<?php\\n\\n\/\/ Read input from stdin\\n$stdin = fopen('php:\/\/stdin', 'r');\\n\\n\/\/ Read the amount of numbers in the sequence\\n$n = intval(fgets($stdin));\\n\\n\/\/ Read the sequence of numbers\\n$sequence = explode(' ', trim(fgets($stdin)));\\n\\n\/\/ Convert the sequence to integers\\n$sequence = array_map('intval', $sequence);\\n\\n\/\/ Sort the sequence in ascending order\\nsort($sequence);\\n\\n\/\/ Find the second order statistics\\n$second_order = null;\\n\\nforeach ($sequence as $num) {\\n    if ($num > $sequence[0]) {\\n        $second_order = $num;\\n        break;\\n    }\\n}\\n\\n\/\/ Output the result\\nif ($second_order !== null) {\\n    echo $second_order . \\\"\\\\n\\\";\\n} else {\\n    echo \\\"NO\\\\n\\\";\\n}\\n\\n\/\/ Close the input stream\\nfclose($stdin);\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] sequence;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    sequence.length = n;\\r\\n    readf(\\\"%s\\\", &sequence);\\r\\n\\r\\n    \/\/ Sort the sequence\\r\\n    sequence.sort();\\r\\n\\r\\n    \/\/ Find the second order statistics\\r\\n    int secondOrderStatistics = -1;\\r\\n    foreach (num; sequence)\\r\\n    {\\r\\n        if (num > sequence[0])\\r\\n        {\\r\\n            secondOrderStatistics = num;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Output the result\\r\\n    if (secondOrderStatistics != -1)\\r\\n    {\\r\\n        writeln(secondOrderStatistics);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\n# Read the input\nmy $n = <>;\nmy $sequence = <>;\nchomp($sequence);\n\n# Split the sequence into an array\nmy @numbers = split(' ', $sequence);\n\n# Sort the array in ascending order\nmy @sorted = sort {$a <=> $b} @numbers;\n\n# Find the second order statistics\nmy $second_order = -1;\nfor (my $i = 1; $i < $n; $i++) {\n    if ($sorted[$i] > $sorted[0]) {\n        $second_order = $sorted[$i];\n        last;\n    }\n}\n\n# Output the result\nif ($second_order != -1) {\n    print \"$second_order\\n\";\n} else {\n    print \"NO\\n\";\n}\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let sequence: Vec<i32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut sorted_sequence = sequence.clone();\n    sorted_sequence.sort();\n    \n    let mut second_order_statistic = None;\n    for i in 1..n {\n        if sorted_sequence[i] > sorted_sequence[0] {\n            second_order_statistic = Some(sorted_sequence[i]);\n            break;\n        }\n    }\n    \n    match second_order_statistic {\n        Some(statistic) => println!(\"{}\", statistic),\n        None => println!(\"NO\"),\n    }\n}"}
{"title":"C. To Add or Not to Add","description":"A piece of paper contains an array of n integers a1,a2,...,an. Your task is to find a number that occurs the maximum number of times in this array.However, before looking for such number, you are allowed to perform not more than k following operations \u2014 choose an arbitrary element from the array and add 1 to it. In other words, you are allowed to increase some array element by 1 no more than k times (you are allowed to increase the same element of the array multiple times).Your task is to find the maximum number of occurrences of some number in the array after performing no more than k allowed operations. If there are several such numbers, your task is to find the minimum one.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and k (1\u2264n\u226410^5; 0\u2264k\u226410^9) \u2014 the number of elements in the array and the number of operations you are allowed to perform, correspondingly.\nThe third line contains a sequence of n integers a1,a2,...,an (|ai|\u226410^9) \u2014 the initial array. The numbers in the lines are separated by single spaces.\n","output_spec":"In a single line print two numbers \u2014 the maximum number of occurrences of some number in the array after at most k allowed operations are performed, and the minimum number that reaches the given maximum. Separate the printed numbers by whitespaces.\n","notes":"In the first sample your task is to increase the second element of the array once and increase the fifth element of the array twice. Thus, we get sequence 6,4,4,0,4, where number 4 occurs 3 times.\nIn the second sample you don't need to perform a single operation or increase each element by one. If we do nothing, we get array 5,5,5, if we increase each by one, we get 6,6,6. In both cases the maximum number of occurrences equals 3. So we should do nothing, as number 5 is less than number 6.\nIn the third sample we should increase the second array element once and the fifth element once. Thus, we get sequence 3,2,2,2,2, where number 2 occurs 4 times.\n","sample_inputs":["5 3\n6 3 4 0 2\n","3 4\n5 5 5\n","5 3\n3 1 2 2 1\n"],"sample_outputs":["3 4\n","3 5\n","4 2\n"],"id":"231-C","difficulty":1600,"tags":["binary+search","sortings","two+pointers"],"src_uid":"3791d1a504b39eb2e72472bcfd9a7e22","C++":"#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    map<int, int> freq;\n    for (int i = 0; i < n; i++) {\n        freq[arr[i]]++;\n    }\n    \n    int maxOccurrences = 0;\n    int minNumber = 0;\n    \n    for (auto it = freq.begin(); it != freq.end(); it++) {\n        int num = it->first;\n        int occurrences = it->second;\n        \n        int operations = min(k, occurrences - 1);\n        int newOccurrences = occurrences + operations;\n        \n        if (newOccurrences > maxOccurrences) {\n            maxOccurrences = newOccurrences;\n            minNumber = num;\n        }\n    }\n    \n    cout << maxOccurrences << \" \" << minNumber << endl;\n    \n    return 0;\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = scanner.nextInt();\n        }\n        \n        int[] count = new int[2000001];\n        int maxOccurrences = 0;\n        int minNumber = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            count[array[i]]++;\n            maxOccurrences = Math.max(maxOccurrences, count[array[i]]);\n            minNumber = Math.min(minNumber, array[i]);\n        }\n        \n        int operations = 0;\n        for (int i = minNumber; i <= minNumber + k; i++) {\n            int currentOccurrences = count[i] + (k - operations) \/ n;\n            maxOccurrences = Math.max(maxOccurrences, currentOccurrences);\n            operations++;\n        }\n        \n        System.out.println(maxOccurrences + \" \" + minNumber);\n    }\n}","Python":"def find_max_occurrences(n, k, arr):\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    max_occurrences = max(freq.values())\n    max_num = min([num for num, count in freq.items() if count == max_occurrences])\n    \n    return f'{max_occurrences} {max_num}'\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\nprint(find_max_occurrences(n, k, arr))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int* arr = (int*)malloc(n * sizeof(int));\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    int maxOccurrences = 0;\\n    int minNumber = arr[0];\\n    int* count = (int*)calloc(2000000001, sizeof(int));\\n\\n    for (int i = 0; i < n; i++) {\\n        count[arr[i]]++;\\n        if (count[arr[i]] > maxOccurrences) {\\n            maxOccurrences = count[arr[i]];\\n            minNumber = arr[i];\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (count[arr[i]] == maxOccurrences) {\\n            if (arr[i] < minNumber) {\\n                minNumber = arr[i];\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d %d\\\\n\\\", maxOccurrences, minNumber);\\n\\n    free(arr);\\n    free(count);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int k = int.Parse(input[1]);\n\n        int[] array = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        Dictionary<int, int> frequency = new Dictionary<int, int>();\n\n        foreach (int num in array)\n        {\n            if (frequency.ContainsKey(num))\n                frequency[num]++;\n            else\n                frequency[num] = 1;\n        }\n\n        int maxOccurrences = frequency.Values.Max();\n        int minNumber = frequency.FirstOrDefault(x => x.Value == maxOccurrences).Key;\n\n        Console.WriteLine($\"{maxOccurrences} {minNumber}\");\n    }\n}","Ruby":"\ndef max_occurrences(n, k, arr)\n  # Create a hash to store the frequency of each number\n  freq = Hash.new(0)\n  \n  # Iterate through the array and update the frequency hash\n  arr.each do |num|\n    freq[num] += 1\n  end\n  \n  # Sort the frequency hash by value in descending order\n  sorted_freq = freq.sort_by { |k, v| -v }\n  \n  # Initialize variables to keep track of the maximum occurrences and the minimum number\n  max_occurrences = 0\n  min_number = sorted_freq[0][0]\n  \n  # Iterate through the sorted frequency hash\n  sorted_freq.each do |num, occurrences|\n    # Calculate the number of operations required to make all other numbers equal to the current number\n    operations = 0\n    sorted_freq.each do |other_num, other_occurrences|\n      next if num == other_num\n      operations += (other_occurrences - occurrences) * (other_num - num)\n    end\n    \n    # Check if the current number has more occurrences than the previous maximum\n    if occurrences + operations <= k && occurrences > max_occurrences\n      max_occurrences = occurrences\n      min_number = num\n    end\n  end\n  \n  # Return the maximum occurrences and the minimum number\n  return max_occurrences, min_number\nend\n\n# Read the input\ninput = gets.chomp.split('\\n')\nn, k = input[0].split(' ').map(&:to_i)\narr = input[1].split(' ').map(&:to_i)\n\n# Call the function and print the result\nresult = max_occurrences(n, k, arr)\nputs result[0].to_s + ' ' + result[1].to_s\n","delphi":"program MaxOccurrences;\n\nvar\n  n, k, i, j, maxCount, maxNum, count: integer;\n  arr: array of integer;\n\nbegin\n  \/\/ Read input values\n  readln(n, k);\n  \n  \/\/ Initialize array\n  SetLength(arr, n);\n  \n  \/\/ Read array elements\n  for i := 0 to n-1 do\n    read(arr[i]);\n  \n  \/\/ Sort array in ascending order\n  for i := 0 to n-2 do\n  begin\n    for j := 0 to n-2-i do\n    begin\n      if arr[j] > arr[j+1] then\n      begin\n        \/\/ Swap elements\n        arr[j] := arr[j] + arr[j+1];\n        arr[j+1] := arr[j] - arr[j+1];\n        arr[j] := arr[j] - arr[j+1];\n      end;\n    end;\n  end;\n  \n  \/\/ Find maximum number of occurrences\n  maxCount := 0;\n  maxNum := arr[0];\n  count := 1;\n  \n  for i := 1 to n-1 do\n  begin\n    if arr[i] = arr[i-1] then\n    begin\n      count := count + 1;\n    end\n    else\n    begin\n      if count > maxCount then\n      begin\n        maxCount := count;\n        maxNum := arr[i-1];\n      end;\n      count := 1;\n    end;\n  end;\n  \n  \/\/ Check if last element has maximum occurrences\n  if count > maxCount then\n  begin\n    maxCount := count;\n    maxNum := arr[n-1];\n  end;\n  \n  \/\/ Increase elements to maximize occurrences\n  for i := 0 to n-1 do\n  begin\n    if k = 0 then\n      break;\n    \n    if arr[i] < maxNum then\n    begin\n      diff := maxNum - arr[i];\n      if diff <= k then\n      begin\n        arr[i] := maxNum;\n        k := k - diff;\n      end\n      else\n      begin\n        arr[i] := arr[i] + k;\n        k := 0;\n      end;\n    end;\n  end;\n  \n  \/\/ Print output\n  writeln(maxCount, ' ', maxNum);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tk, _ := strconv.Atoi(scanner.Text())\\n\\n\\tcount := make(map[int]int)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\ta, _ := strconv.Atoi(scanner.Text())\\n\\t\\tcount[a]++\\n\\t}\\n\\n\\tmaxOccurrences := 0\\n\\tminNumber := 0\\n\\n\\tfor num, occurrences := range count {\\n\\t\\tif occurrences > maxOccurrences {\\n\\t\\t\\tmaxOccurrences = occurrences\\n\\t\\t\\tminNumber = num\\n\\t\\t} else if occurrences == maxOccurrences && num < minNumber {\\n\\t\\t\\tminNumber = num\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Printf(\\\"%d %d\\\\n\\\", maxOccurrences, minNumber)\\n}","Javascript":"function findMaxOccurrences(input) {\n    let [n, k, arr] = input.split('\\\\n');\n    let [nVal, kVal] = n.split(' ');\n    let arrVal = arr.split(' ').map(Number);\n    \n    let maxOccurrences = 0;\n    let minNumber = Infinity;\n    \n    let count = {};\n    for (let i = 0; i < arrVal.length; i++) {\n        count[arrVal[i]] = (count[arrVal[i]] || 0) + 1;\n        maxOccurrences = Math.max(maxOccurrences, count[arrVal[i]]);\n        minNumber = Math.min(minNumber, arrVal[i]);\n    }\n    \n    let operations = kVal;\n    for (let num in count) {\n        let diff = num - minNumber;\n        let occurrences = count[num];\n        let maxPossibleOccurrences = Math.min(occurrences + operations, maxOccurrences);\n        let additionalOperations = maxPossibleOccurrences - occurrences;\n        operations -= additionalOperations;\n        count[num] += additionalOperations;\n    }\n    \n    let result = [];\n    for (let num in count) {\n        if (count[num] === maxOccurrences) {\n            result.push(num);\n        }\n    }\n    \n    return maxOccurrences + ' ' + Math.min(...result);\n}\n\nconsole.log(findMaxOccurrences('5 3\\\\n6 3 4 0 2\\\\n'));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val k = scanner.nextLong()\n    val array = IntArray(n)\n    val count = mutableMapOf<Int, Int>()\n\n    for (i in 0 until n) {\n        array[i] = scanner.nextInt()\n        count[array[i]] = count.getOrDefault(array[i], 0) + 1\n    }\n\n    var maxOccurrences = 0\n    var minNumber = Int.MAX_VALUE\n\n    for ((number, occurrences) in count) {\n        val operationsNeeded = (occurrences.toLong() * k - array.count { it == number }).coerceAtLeast(0)\n        val maxNumber = number + operationsNeeded.toInt()\n        if (occurrences > maxOccurrences || (occurrences == maxOccurrences && maxNumber < minNumber)) {\n            maxOccurrences = occurrences\n            minNumber = maxNumber\n        }\n    }\n\n    println(\"$maxOccurrences $minNumber\")\n}","PHP":"\n<?php\n\nfunction findMaxOccurrences($n, $k, $array) {\n    \/\/ Create a frequency array to store the count of each number\n    $frequency = array();\n    \n    \/\/ Iterate through the array and update the frequency of each number\n    foreach ($array as $num) {\n        if (isset($frequency[$num])) {\n            $frequency[$num]++;\n        } else {\n            $frequency[$num] = 1;\n        }\n    }\n    \n    \/\/ Sort the frequency array in descending order\n    arsort($frequency);\n    \n    \/\/ Initialize variables to store the maximum occurrences and the minimum number\n    $maxOccurrences = 0;\n    $minNumber = PHP_INT_MAX;\n    \n    \/\/ Iterate through the frequency array and perform the allowed operations\n    foreach ($frequency as $num => $count) {\n        \/\/ Calculate the number of operations required to reach the maximum occurrences\n        $operations = $maxOccurrences * ($count - 1);\n        \n        \/\/ Check if the number of operations is within the allowed limit\n        if ($operations <= $k) {\n            \/\/ Update the maximum occurrences and the minimum number\n            $maxOccurrences += $count;\n            $minNumber = min($minNumber, $num);\n            \n            \/\/ Update the remaining number of operations\n            $k -= $operations;\n        } else {\n            \/\/ Calculate the maximum number of occurrences without performing any operations\n            $maxOccurrences += floor($k \/ $maxOccurrences);\n            break;\n        }\n    }\n    \n    \/\/ Return the maximum number of occurrences and the minimum number\n    return $maxOccurrences . ' ' . $minNumber;\n}\n\n\/\/ Read the input from the standard input\n$input = explode(' ', trim(fgets(STDIN)));\n$n = intval($input[0]);\n$k = intval($input[1]);\n\n$array = array_map('intval', explode(' ', trim(fgets(STDIN))));\n\n\/\/ Call the function to find the maximum number of occurrences\n$result = findMaxOccurrences($n, $k, $array);\n\n\/\/ Print the result\necho $result;\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    int[] arr;\\r\\n    int[] freq;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &n, &k);\\r\\n    arr = readln.split.map!(to!int).array;\\r\\n\\r\\n    \/\/ Calculate frequency of each element\\r\\n    freq = arr.sort.unique.map!(a => arr.count(a)).array;\\r\\n\\r\\n    \/\/ Find the maximum number of occurrences\\r\\n    int maxOccurrences = 0;\\r\\n    int minNumber = 0;\\r\\n\\r\\n    foreach (int f; freq)\\r\\n    {\\r\\n        int occurrences = 0;\\r\\n        int operations = k;\\r\\n\\r\\n        foreach (int a; arr)\\r\\n        {\\r\\n            if (a < f)\\r\\n            {\\r\\n                operations -= f - a;\\r\\n                if (operations < 0)\\r\\n                    break;\\r\\n            }\\r\\n            else if (a > f)\\r\\n            {\\r\\n                operations -= (a - f) % 2;\\r\\n                if (operations < 0)\\r\\n                    break;\\r\\n            }\\r\\n\\r\\n            occurrences += (a - f) \/ 2 + 1;\\r\\n        }\\r\\n\\r\\n        if (operations >= 0 && occurrences > maxOccurrences)\\r\\n        {\\r\\n            maxOccurrences = occurrences;\\r\\n            minNumber = f;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print output\\r\\n    writeln(maxOccurrences, \\\" \\\", minNumber);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_max_occurrences {\n    my ($n, $k, @array) = @_;\n\n    my %count;\n    foreach my $num (@array) {\n        $count{$num}++;\n    }\n\n    my $max_occurrences = 0;\n    my $min_number = 0;\n\n    foreach my $num (keys %count) {\n        my $occurrences = $count{$num};\n        my $operations_needed = 0;\n\n        if ($occurrences * $num <= $k) {\n            $operations_needed = int($k \/ $num);\n        } else {\n            $operations_needed = $occurrences - int($k \/ $num);\n        }\n\n        if ($operations_needed <= $k) {\n            if ($occurrences > $max_occurrences || ($occurrences == $max_occurrences && $num < $min_number)) {\n                $max_occurrences = $occurrences;\n                $min_number = $num;\n            }\n        }\n    }\n\n    return \"$max_occurrences $min_number\";\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k) = split(' ', $input);\n\nmy $array_input = <STDIN>;\nchomp $array_input;\nmy @array = split(' ', $array_input);\n\n# Call the function and print the result\nmy $result = find_max_occurrences($n, $k, @array);\nprint $result;\n","Rust":"use std::collections::HashMap;\n\nfn main() {\n    let input = \"5 3\\n6 3 4 0 2\\n\";\n    let mut lines = input.lines();\n    let nk: Vec<u32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nk[0] as usize;\n    let k = nk[1];\n    let a: Vec<i32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n\n    let mut freq: HashMap<i32, u32> = HashMap::new();\n    let mut max_occurrences = 0;\n    let mut min_number = 0;\n\n    for num in a {\n        *freq.entry(num).or_insert(0) += 1;\n        if freq[&num] > max_occurrences {\n            max_occurrences = freq[&num];\n            min_number = num;\n        } else if freq[&num] == max_occurrences && num < min_number {\n            min_number = num;\n        }\n    }\n\n    let mut operations = k;\n    for (num, count) in freq.iter() {\n        let diff = min_number - *num;\n        let max_increase = operations \/ max_occurrences;\n        let actual_increase = diff.min(max_increase as i32);\n        operations -= actual_increase * max_occurrences as u32;\n        freq.entry(*num + actual_increase).and_modify(|x| *x += *count);\n    }\n\n    println!(\"{} {}\", max_occurrences, min_number);\n}"}
{"title":"B. Non-square Equation","description":"Let's consider equation:x^2+s(x)\u00b7x-n=0, where x,n are positive integers, s(x) is the function, equal to the sum of digits of number x in the decimal number system.You are given an integer n, find the smallest positive integer root of equation x, or else determine that there are no such roots.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"A single line contains integer n (1\u2264n\u226410^18) \u2014 the equation parameter.\nPlease, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier. \n","output_spec":"Print -1, if the equation doesn't have integer positive roots. Otherwise print such smallest integer x (x>0), that the equation given in the statement holds.\n","notes":"In the first test case x=1 is the minimum root. As s(1)=1 and 1^2+1\u00b71-2=0.\nIn the second test case x=10 is the minimum root. As s(10)=1+0=1 and 10^2+1\u00b710-110=0.\nIn the third test case the equation has no roots.\n","sample_inputs":["2\n","110\n","4\n"],"sample_outputs":["1\n","10\n","-1\n"],"id":"233-B","difficulty":1400,"tags":["binary+search","brute+force","math"],"src_uid":"e1070ad4383f27399d31b8d0e87def59","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint sumOfDigits(int n) {\\n    int sum = 0;\\n    while (n > 0) {\\n        sum += n % 10;\\n        n \/= 10;\\n    }\\n    return sum;\\n}\\n\\nint main() {\\n    long long n;\\n    cin >> n;\\n\\n    for (int x = 1; x <= 9; x++) {\\n        long long equation = x * x + sumOfDigits(x) * x - n;\\n        if (equation == 0) {\\n            cout << x << endl;\\n            return 0;\\n        }\\n    }\\n\\n    cout << -1 << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class EquationRoots {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        long n = scanner.nextLong();\\n        scanner.close();\\n\\n        long x = findRoot(n);\\n\\n        if (x == -1) {\\n            System.out.println(-1);\\n        } else {\\n            System.out.println(x);\\n        }\\n    }\\n\\n    public static long findRoot(long n) {\\n        for (long x = 1; x <= Math.sqrt(n); x++) {\\n            long sumOfDigits = calculateSumOfDigits(x);\\n            long equationResult = x * x + sumOfDigits * x - n;\\n\\n            if (equationResult == 0) {\\n                return x;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    public static long calculateSumOfDigits(long number) {\\n        long sum = 0;\\n\\n        while (number > 0) {\\n            sum += number % 10;\\n            number \/= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\" }","Python":"def sum_of_digits(n):\\n    return sum([int(digit) for digit in str(n)])\\n\\n\\ndef find_smallest_root(n):\\n    for x in range(1, n+1):\\n        if x**2 + sum_of_digits(x)*x - n == 0:\\n            return str(x)\\n    return '-1'\\n\\n\\nn = int(input())\\nprint(find_smallest_root(n))\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint sum_of_digits(int n) {\\n    int sum = 0;\\n    while (n > 0) {\\n        sum += n % 10;\\n        n \/= 10;\\n    }\\n    return sum;\\n}\\n\\nint main() {\\n    long long n;\\n    scanf(\\\"%lld\\\", &n);\\n\\n    for (int x = 1; x <= n; x++) {\\n        int sum = sum_of_digits(x);\\n        long long equation = x * x + sum * x - n;\\n        if (equation == 0) {\\n            printf(\\\"%d\\\\n\\\", x);\\n            return 0;\\n        }\\n    }\\n\\n    printf(\\\"-1\\\\n\\\");\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        long n = long.Parse(Console.ReadLine());\n        \n        long x = 1;\n        while (true)\n        {\n            long sumOfDigits = GetSumOfDigits(x);\n            long equation = x * x + sumOfDigits * x - n;\n            \n            if (equation == 0)\n            {\n                Console.WriteLine(x);\n                break;\n            }\n            else if (equation > 0)\n            {\n                Console.WriteLine(-1);\n                break;\n            }\n            \n            x++;\n        }\n    }\n    \n    static long GetSumOfDigits(long number)\n    {\n        long sum = 0;\n        while (number > 0)\n        {\n            sum += number % 10;\n            number \/= 10;\n        }\n        return sum;\n    }\n}","Ruby":"\ndef sum_of_digits(n)\n  sum = 0\n  while n > 0\n    sum += n % 10\n    n \/= 10\n  end\n  sum\nend\n\ndef find_smallest_root(n)\n  (1..n).each do |x|\n    if x**2 + sum_of_digits(x) * x - n == 0\n      return x\n    end\n  end\n  -1\nend\n\nn = gets.chomp.to_i\nputs find_smallest_root(n)\n","delphi":"program SmallestRoot;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction SumOfDigits(n: Integer): Integer;\nvar\n  sum: Integer;\n  digit: Integer;\nbegin\n  sum := 0;\n  while n > 0 do\n  begin\n    digit := n mod 10;\n    sum := sum + digit;\n    n := n div 10;\n  end;\n  Result := sum;\nend;\n\nfunction FindSmallestRoot(n: Int64): Int64;\nvar\n  x: Int64;\n  sum: Integer;\nbegin\n  x := 1;\n  while True do\n  begin\n    sum := SumOfDigits(x);\n    if x * x + sum * x - n = 0 then\n    begin\n      Result := x;\n      Exit;\n    end;\n    Inc(x);\n    if x > n then\n      Break;\n  end;\n  Result := -1;\nend;\n\nvar\n  n: Int64;\n  smallestRoot: Int64;\nbegin\n  ReadLn(n);\n  smallestRoot := FindSmallestRoot(n);\n  WriteLn(smallestRoot);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc sumOfDigits(n int) int {\\n\\tdigits := strconv.Itoa(n)\\n\\tsum := 0\\n\\tfor _, digit := range digits {\\n\\t\\tdigitInt, _ := strconv.Atoi(string(digit))\\n\\t\\tsum += digitInt\\n\\t}\\n\\treturn sum\\n}\\n\\nfunc findRoot(n int) int {\\n\\tfor x := 1; x <= n; x++ {\\n\\t\\tif x*x+sumOfDigits(x)*x-n == 0 {\\n\\t\\t\\treturn x\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\troot := findRoot(n)\\n\\tfmt.Println(root)\\n}","Javascript":"function sumOfDigits(num) {\n  let sum = 0;\n  while (num > 0) {\n    sum += num % 10;\n    num = Math.floor(num \/ 10);\n  }\n  return sum;\n}\n\nfunction findSmallestRoot(n) {\n  for (let x = 1; x <= n; x++) {\n    if (x * x + sumOfDigits(x) * x - n === 0) {\n      return x;\n    }\n  }\n  return -1;\n}\n\nconst input = parseInt(readline(), 10);\nconst result = findSmallestRoot(input);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextLong()\n    \n    var x = 1L\n    while (true) {\n        val sumOfDigits = getSumOfDigits(x)\n        val equation = x * x + sumOfDigits * x - n\n        \n        if (equation == 0L) {\n            println(x)\n            break\n        }\n        \n        if (equation > 0L) {\n            println(-1)\n            break\n        }\n        \n        x++\n    }\n}\n\nfun getSumOfDigits(number: Long): Long {\n    var sum = 0L\n    var num = number\n    \n    while (num > 0) {\n        sum += num % 10\n        num \/= 10\n    }\n    \n    return sum\n}","PHP":"\n<?php\n\nfunction sumOfDigits($num) {\n    $sum = 0;\n    while ($num > 0) {\n        $sum += $num % 10;\n        $num = (int)($num \/ 10);\n    }\n    return $sum;\n}\n\nfunction findSmallestRoot($n) {\n    for ($x = 1; $x <= $n; $x++) {\n        $sum = sumOfDigits($x);\n        $equation = pow($x, 2) + $sum * $x - $n;\n        if ($equation == 0) {\n            return $x;\n        }\n    }\n    return -1;\n}\n\n$input = trim(fgets(STDIN));\n$n = intval($input);\n\n$result = findSmallestRoot($n);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint sumOfDigits(int x)\\r\\n{\\r\\n    int sum = 0;\\r\\n    while (x > 0)\\r\\n    {\\r\\n        sum += x % 10;\\r\\n        x \/= 10;\\r\\n    }\\r\\n    return sum;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int x = 1;\\r\\n    while (true)\\r\\n    {\\r\\n        int s = sumOfDigits(x);\\r\\n        int equation = x * x + s * x - n;\\r\\n\\r\\n        if (equation == 0)\\r\\n        {\\r\\n            writeln(x);\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        if (x > n)\\r\\n        {\\r\\n            writeln(-1);\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        x++;\\r\\n    }\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub sum_of_digits {\n    my ($num) = @_;\n    my $sum = 0;\n    while ($num > 0) {\n        $sum += $num % 10;\n        $num = int($num \/ 10);\n    }\n    return $sum;\n}\n\nsub find_smallest_root {\n    my ($n) = @_;\n    for (my $x = 1; $x <= $n; $x++) {\n        my $s = sum_of_digits($x);\n        my $equation = $x**2 + $s * $x - $n;\n        if ($equation == 0) {\n            return $x;\n        }\n    }\n    return -1;\n}\n\nmy $n = <STDIN>;\nchomp($n);\n\nmy $smallest_root = find_smallest_root($n);\nprint $smallest_root . \\\"\\\\n\\\";\n","Rust":"fn sum_of_digits(mut x: u64) -> u64 {\\n    let mut sum = 0;\\n    while x > 0 {\\n        sum += x % 10;\\n        x \/= 10;\\n    }\\n    sum\\n}\\n\\nfn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: u64 = input.trim().parse().unwrap();\\n\\n    let mut x = 1;\\n    while x * x + sum_of_digits(x) * x - n != 0 {\\n        x += 1;\\n        if x > n {\\n            println!(\"-1\");\\n            return;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", x);\\n}"}
{"title":"A. You're Given a String...","description":"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.\n","output_spec":"Output one number \u2014 length of the longest substring that can be met in the string at least twice.\n","notes":null,"sample_inputs":["abcd\n","ababa\n","zzz\n"],"sample_outputs":["0","3","2"],"id":"23-A","difficulty":1200,"tags":["brute+force","greedy"],"src_uid":"13b5cf94f2fabd053375a5ccf3fd44c7","C++":"#include <iostream>\\n#include <string>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nint longestSubstring(string s) {\\n    int n = s.length();\\n    unordered_map<string, int> freq;\\n    int maxLength = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int len = 1; len <= n - i; len++) {\\n            string substring = s.substr(i, len);\\n            freq[substring]++;\\n\\n            if (freq[substring] >= 2) {\\n                maxLength = max(maxLength, len);\\n            }\\n        }\\n    }\\n\\n    return maxLength;\\n}\\n\\nint main() {\\n    string s;\\n    cin >> s;\\n\\n    int result = longestSubstring(s);\\n    cout << result << endl;\\n\\n    return 0;\\n}","Java":"import java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class LongestSubstring {\\n\\n    public static int findLongestSubstring(String s) {\\n        int n = s.length();\\n        int maxLength = 0;\\n        Map<String, Integer> substringCount = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j <= n; j++) {\\n                String substring = s.substring(i, j);\\n                int count = substringCount.getOrDefault(substring, 0);\\n                count++;\\n                substringCount.put(substring, count);\\n\\n                if (count >= 2 && substring.length() > maxLength) {\\n                    maxLength = substring.length();\\n                }\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] inputs = {\\\"abcd\\\", \\\"ababa\\\", \\\"zzz\\\"};\\n\\n        for (String input : inputs) {\\n            int longestSubstring = findLongestSubstring(input);\\n            System.out.println(longestSubstring);\\n        }\\n    }\\n}\"}}","Python":"def longest_substring(s):\n    n = len(s)\n    longest = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if s.count(substring) >= 2:\n                longest = max(longest, len(substring))\n    return longest\n\nstring = input().strip()\nprint(longest_substring(string))","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char str[101];\\n    scanf(\\\"%s\\\", str);\\n    int len = strlen(str);\\n    int maxLen = 0;\\n\\n    for (int i = 0; i < len; i++) {\\n        for (int j = i + 1; j < len; j++) {\\n            int k = 0;\\n            while (j + k < len && str[i + k] == str[j + k]) {\\n                k++;\\n            }\\n            if (k > maxLen) {\\n                maxLen = k;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\", maxLen);\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string input = Console.ReadLine().Trim();\n        int maxLength = 0;\n\n        for (int i = 0; i < input.Length; i++)\n        {\n            for (int j = i + 1; j < input.Length; j++)\n            {\n                string substring = input.Substring(i, j - i + 1);\n                if (input.IndexOf(substring, j + 1) != -1)\n                {\n                    maxLength = Math.Max(maxLength, substring.Length);\n                }\n            }\n        }\n\n        Console.WriteLine(maxLength);\n    }\n}","Ruby":"\ndef longest_substring(string)\n  max_length = 0\n  length = string.length\n\n  (0...length).each do |i|\n    (i+1...length).each do |j|\n      substring = string[i..j]\n      substring_length = substring.length\n\n      if substring_length > max_length && string.scan(substring).count >= 2\n        max_length = substring_length\n      end\n    end\n  end\n\n  max_length\nend\n\ninput = gets.chomp\noutput = longest_substring(input)\nputs output\n","delphi":"program LongestSubstring;\n\nvar\n  input: string;\n  longestSubstringLength: integer;\n\nfunction FindLongestSubstring(input: string): integer;\nvar\n  i, j, k: integer;\n  substring: string;\nbegin\n  longestSubstringLength := 0;\n  \n  for i := 1 to Length(input) do\n  begin\n    for j := i + 1 to Length(input) do\n    begin\n      substring := Copy(input, i, j - i + 1);\n      \n      for k := j + 1 to Length(input) do\n      begin\n        if Pos(substring, Copy(input, k, Length(input) - k + 1)) > 0 then\n        begin\n          if Length(substring) > longestSubstringLength then\n            longestSubstringLength := Length(substring);\n        end;\n      end;\n    end;\n  end;\n  \n  Result := longestSubstringLength;\nend;\n\nbegin\n  ReadLn(input);\n  WriteLn(FindLongestSubstring(input));\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar s string\\n\\tfmt.Scan(&s)\\n\\n\\tmaxLen := 0\\n\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tfor j := i + 1; j < len(s); j++ {\\n\\t\\t\\tsubstring := s[i:j]\\n\\t\\t\\tif strings.Count(s, substring) >= 2 && len(substring) > maxLen {\\n\\t\\t\\t\\tmaxLen = len(substring)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxLen)\\n}","Javascript":"function findLongestSubstring(string) {\n  let longestSubstring = '';\n  \n  for (let i = 0; i < string.length; i++) {\n    for (let j = i + 1; j < string.length; j++) {\n      let substring = string.slice(i, j + 1);\n      \n      if (string.indexOf(substring, j + 1) !== -1 && substring.length > longestSubstring.length) {\n        longestSubstring = substring;\n      }\n    }\n  }\n  \n  return longestSubstring.length;\n}\n\nconst input = 'ababa';\nconst output = findLongestSubstring(input);\nconsole.log(output);","Kotlin":"fun main() {\n    val input = readLine()!!\n    var maxLength = 0\n    \n    for (i in 0 until input.length) {\n        for (j in i + 1 until input.length) {\n            val substring = input.substring(i, j)\n            if (input.indexOf(substring, j) != -1 && substring.length > maxLength) {\n                maxLength = substring.length\n            }\n        }\n    }\n    \n    println(maxLength)\n}","PHP":"<?php\\n\\nfunction longestSubstring($string) {\\n    $length = strlen($string);\\n    $maxSubstringLength = 0;\\n    \\n    \/\/ Iterate through each character in the string\\n    for ($i = 0; $i < $length; $i++) {\\n        \/\/ Iterate through each possible substring starting from the current character\\n        for ($j = $i + 1; $j < $length; $j++) {\\n            $substring = substr($string, $i, $j - $i + 1);\\n            $substringLength = strlen($substring);\\n            \\n            \/\/ Check if the substring occurs at least twice in the string\\n            if (substr_count($string, $substring) >= 2 && $substringLength > $maxSubstringLength) {\\n                $maxSubstringLength = $substringLength;\\n            }\\n        }\\n    }\\n    \\n    return $maxSubstringLength;\\n}\\n\\n\/\/ Read the input string\\n$input = trim(fgets(STDIN));\\n\\n\/\/ Call the function and print the result\\n$result = longestSubstring($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring longestSubstring(string s) {\\r\\n    int n = s.length;\\r\\n    int maxLen = 0;\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        for (int j = i + 1; j < n; j++) {\\r\\n            int len = j - i;\\r\\n            if (len > maxLen && s[i..$].startsWith(s[i..j])) {\\r\\n                maxLen = len;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return maxLen;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    string input = readln();\\r\\n    int result = longestSubstring(input.strip());\\r\\n    writeln(result);\\r\\n}","perl":"\n# Read the input string\nmy $string = <STDIN>;\nchomp $string;\n\n# Initialize variables\nmy $max_length = 0;\nmy $length = length($string);\n\n# Iterate through all possible substrings\nfor (my $i = 0; $i < $length; $i++) {\n    for (my $j = $i + 1; $j < $length; $j++) {\n        my $substring = substr($string, $i, $j - $i + 1);\n        my $substring_length = length($substring);\n        \n        # Check if the substring occurs at least twice\n        if (index($string, $substring, $j) != -1) {\n            $max_length = $substring_length if $substring_length > $max_length;\n        }\n    }\n}\n\n# Print the length of the longest substring\nprint $max_length;\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    let s = lines.next().unwrap().unwrap();\n\n    let mut longest_substring = 0;\n\n    for i in 0..s.len() {\n        for j in (i + 1)..=s.len() {\n            let substring = &s[i..j];\n            if s.matches(substring).count() >= 2 && substring.len() > longest_substring {\n                longest_substring = substring.len();\n            }\n        }\n    }\n\n    println!(\"{}\", longest_substring);\n}"}
{"title":"B. Buttons","description":"Manao is trying to open a rather challenging lock. The lock has n buttons on it and to open it, you should press the buttons in a certain order to open the lock. When you push some button, it either stays pressed into the lock (that means that you've guessed correctly and pushed the button that goes next in the sequence), or all pressed buttons return to the initial position. When all buttons are pressed into the lock at once, the lock opens.Consider an example with three buttons. Let's say that the opening sequence is: {2, 3, 1}. If you first press buttons 1 or 3, the buttons unpress immediately. If you first press button 2, it stays pressed. If you press 1 after 2, all buttons unpress. If you press 3 after 2, buttons 3 and 2 stay pressed. As soon as you've got two pressed buttons, you only need to press button 1 to open the lock.Manao doesn't know the opening sequence. But he is really smart and he is going to act in the optimal way. Calculate the number of times he's got to push a button in order to open the lock in the worst-case scenario.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"A single line contains integer n (1\u2264n\u22642000) \u2014 the number of buttons the lock has.\n","output_spec":"In a single line print the number of times Manao has to push a button in the worst-case scenario.\n","notes":"Consider the first test sample. Manao can fail his first push and push the wrong button. In this case he will already be able to guess the right one with his second push. And his third push will push the second right button. Thus, in the worst-case scenario he will only need 3 pushes.\n","sample_inputs":["2\n","3\n"],"sample_outputs":["3\n","7\n"],"id":"268-B","difficulty":1000,"tags":["implementation","math"],"src_uid":"6df251ac8bf27427a24bc23d64cb9884","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    vector<int> buttons(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> buttons[i];\\n    }\\n\\n    sort(buttons.begin(), buttons.end());\\n\\n    int pushes = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        pushes += buttons[i];\\n    }\\n\\n    cout << pushes + n << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class LockButtons {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int pushes = n;\\n        for (int i = 2; i <= n; i++) {\\n            pushes += i * (n - i + 1);\\n        }\\n        System.out.println(pushes);\\n    }\\n}","Python":"def calculate_pushes(n):\\n    if n == 1:\\n        return 1\\n    else:\\n        return n + (n-1) + (n-2)\\n\\nn = int(input())\\nresult = calculate_pushes(n)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int pushes = n;\\n    for (int i = 2; i <= n; i++) {\\n        pushes += i * (n - i + 1);\\n    }\\n    printf(\\\"%d\\\\n\\\", pushes);\\n    return 0;\\n}","C#":"using System;\n\nnamespace Lock\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int pushes = 0;\n\n            \/\/ Calculate the number of times Manao has to push a button in the worst-case scenario\n            \/\/ The worst-case scenario is when Manao has to press all buttons except the last one, and then press the last button\n            pushes = (n - 1) + (n * (n - 1) \/ 2);\n\n            Console.WriteLine(pushes);\n        }\n    }\n}","Ruby":"\ndef worst_case_pushes(n)\n  return n + (n-1) + (n-2)\nend\n\nn = gets.to_i\nputs worst_case_pushes(n)\n","delphi":"program LockCode;\n\nvar\n  n, pushes: Integer;\n\nbegin\n  \/\/ Read the number of buttons\n  ReadLn(n);\n  \n  \/\/ Calculate the number of pushes needed in worst-case scenario\n  pushes := n + (n - 1) + (n - 2);\n  \n  \/\/ Print the result\n  WriteLn(pushes);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\t\/\/ Calculate the number of times Manao has to push a button in the worst-case scenario\\n\\t\/\/ If n is odd, Manao has to push a button n times\\n\\t\/\/ If n is even, Manao has to push a button n+1 times\\n\\tif n%2 == 0 {\\n\\t\\tfmt.Println(n + 1)\\n\\t} else {\\n\\t\\tfmt.Println(n)\\n\\t}\\n}","Javascript":"function calculateButtonPresses(n) {\n    \/\/ If there is only one button, Manao needs to press it once\n    if (n === 1) {\n        return 1;\n    }\n    \n    \/\/ Initialize the number of button presses\n    let buttonPresses = 0;\n    \n    \/\/ Calculate the number of button presses in the worst-case scenario\n    for (let i = 1; i <= n; i++) {\n        buttonPresses += i;\n    }\n    \n    return buttonPresses;\n}\n\n\/\/ Read the input from the user\nconst n = parseInt(readline());\n\n\/\/ Calculate the number of button presses in the worst-case scenario\nconst result = calculateButtonPresses(n);\n\n\/\/ Print the result\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    \n    \/\/ Calculate the number of times Manao has to push a button in the worst-case scenario\n    val worstCasePushes = n + (n - 1) * (n - 1)\n    \n    println(worstCasePushes)\n}","PHP":"\n<?php\n\nfunction calculatePushes($n) {\n    \/\/ If there is only one button, Manao needs to push it once\n    if ($n == 1) {\n        return 1;\n    }\n    \n    \/\/ If there are two buttons, Manao needs to push the wrong button once, then the right button twice\n    if ($n == 2) {\n        return 3;\n    }\n    \n    \/\/ If there are more than two buttons, Manao needs to push the wrong button once, then the right button twice,\n    \/\/ and then the remaining buttons once each\n    return 3 + ($n - 2);\n}\n\n\/\/ Read the input\n$n = intval(trim(fgets(STDIN)));\n\n\/\/ Calculate the number of pushes in the worst-case scenario\n$pushes = calculatePushes($n);\n\n\/\/ Print the result\necho $pushes;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int pushes = n;\\r\\n    for (int i = 2; i <= n; i++)\\r\\n    {\\r\\n        pushes += i;\\r\\n    }\\r\\n\\r\\n    writeln(pushes);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_pushes {\n    my $n = shift;\n    my $pushes = 0;\n    \n    # If there is only one button, Manao needs to push it once\n    if ($n == 1) {\n        $pushes = 1;\n    }\n    else {\n        # Manao needs to push the first button to start\n        $pushes++;\n        \n        # Manao needs to push the remaining buttons in a specific pattern\n        # The pattern is to push the first button, then push the second button twice,\n        # then push the third button three times, and so on.\n        for (my $i = 2; $i <= $n; $i++) {\n            $pushes += $i;\n        }\n    }\n    \n    return $pushes;\n}\n\n# Read the input\nmy $n = <>;\nchomp $n;\n\n# Calculate the number of pushes\nmy $result = calculate_pushes($n);\n\n# Print the result\nprint $result;\n","Rust":"\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let n: usize = stdin.lock().lines().next().unwrap().unwrap().trim().parse().unwrap();\n    \n    let mut ans = 0;\n    for i in 1..=n {\n        ans += i * (n - i + 1);\n    }\n    \n    println!(\"{}\", ans);\n}\n"}
{"title":"E. Number With The Given Amount Of Divisors","description":"Given the number n, find the smallest positive integer which has exactly n divisors. It is guaranteed that for the given n the answer will not exceed 10^18.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input contains integer n (1\u2264n\u22641000).\n","output_spec":"Output the smallest positive integer with exactly n divisors.\n","notes":null,"sample_inputs":["4\n","6\n"],"sample_outputs":["6\n","12\n"],"id":"27-E","difficulty":2000,"tags":["brute+force","dp","number+theory"],"src_uid":"62db589bad3b7023418107de05b7a8ee","C++":"#include <iostream>\\n#include <vector>\\n#include <cmath>\\n\\nusing namespace std;\\n\\n\/\/ Function to count the number of divisors\\nint countDivisors(int n) {\\n    int count = 0;\\n    for (int i = 1; i <= sqrt(n); i++) {\\n        if (n % i == 0) {\\n            \/\/ If divisors are equal, count only one\\n            if (n \/ i == i)\\n                count++;\\n            else \/\/ Otherwise count both\\n                count += 2;\\n        }\\n    }\\n    return count;\\n}\\n\\n\/\/ Function to find the smallest positive integer with exactly n divisors\\nlong long findSmallestInteger(int n) {\\n    long long num = 1;\\n    while (true) {\\n        if (countDivisors(num) == n)\\n            return num;\\n        num++;\\n    }\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    long long smallestInteger = findSmallestInteger(n);\\n    cout << smallestInteger << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class SmallestIntegerWithNDivisors {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.close();\\n\\n        long smallestInteger = findSmallestIntegerWithNDivisors(n);\\n\\n        System.out.println(smallestInteger);\\n    }\\n\\n    public static long findSmallestIntegerWithNDivisors(int n) {\\n        int[] primes = new int[n];\\n        int[] powers = new int[n];\\n\\n        int primeCount = 0;\\n        int currentNumber = 2;\\n\\n        while (primeCount < n) {\\n            int power = 0;\\n            while (n % currentNumber == 0) {\\n                n \/= currentNumber;\\n                power++;\\n            }\\n\\n            if (power > 0) {\\n                primes[primeCount] = currentNumber;\\n                powers[primeCount] = power;\\n                primeCount++;\\n            }\\n\\n            currentNumber++;\\n        }\\n\\n        long smallestInteger = 1;\\n\\n        for (int i = 0; i < primeCount; i++) {\\n            smallestInteger *= Math.pow(primes[i], powers[i]);\\n        }\\n\\n        return smallestInteger;\\n    }\\n}\"}}","Python":"import math\\n\\n# Function to count divisors\\n# of a number\\n\\n\\ndef countDivisors(n) :\\n    cnt = 0\\n    for i in range(1, (int)(math.sqrt(n)) + 1) :\\n        if (n % i == 0) :\\n            # If divisors are equal,\\n            # count only one\\n            if (n \/ i == i) :\\n                cnt = cnt + 1\\n            else :\\n                # Otherwise count both\\n                cnt = cnt + 2\\n    return cnt\\n\\n\\ndef findSmallestInteger(n) :\\n    i = 1\\n    while (True) :\\n        if (countDivisors(i) == n) :\\n            return i\\n        i = i + 1\\n\\n\\n# Driver code\\n\\n# Test case 1\\nn = 4\\nprint(findSmallestInteger(n))\\n\\n# Test case 2\\nn = 6\\nprint(findSmallestInteger(n))\\n","C":"#include <stdio.h>\\n#include <math.h>\\n\\nint countDivisors(int n) {\\n    int count = 0;\\n    for (int i = 1; i <= sqrt(n); i++) {\\n        if (n % i == 0) {\\n            if (n \/ i == i) {\\n                count++;\\n            } else {\\n                count += 2;\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nlong long findSmallestInteger(int n) {\\n    long long num = 1;\\n    while (countDivisors(num) != n) {\\n        num++;\\n    }\\n    return num;\\n}\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    long long smallestInteger = findSmallestInteger(n);\\n    printf(\\\"%lld\\\\n\\\", smallestInteger);\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        long result = FindSmallestIntegerWithNDivisors(n);\n        Console.WriteLine(result);\n    }\n\n    static long FindSmallestIntegerWithNDivisors(int n)\n    {\n        int[] primes = GeneratePrimes(n);\n        long result = 1;\n        foreach (int prime in primes)\n        {\n            int power = 1;\n            while (Math.Pow(prime, power) <= n)\n            {\n                power++;\n            }\n            result *= (long)Math.Pow(prime, power - 1);\n        }\n        return result;\n    }\n\n    static int[] GeneratePrimes(int n)\n    {\n        bool[] isPrime = new bool[n + 1];\n        for (int i = 2; i <= n; i++)\n        {\n            isPrime[i] = true;\n        }\n\n        for (int i = 2; i * i <= n; i++)\n        {\n            if (isPrime[i])\n            {\n                for (int j = i * i; j <= n; j += i)\n                {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        int count = 0;\n        for (int i = 2; i <= n; i++)\n        {\n            if (isPrime[i])\n            {\n                count++;\n            }\n        }\n\n        int[] primes = new int[count];\n        int index = 0;\n        for (int i = 2; i <= n; i++)\n        {\n            if (isPrime[i])\n            {\n                primes[index] = i;\n                index++;\n            }\n        }\n\n        return primes;\n    }\n}","Ruby":"def smallest_integer_with_n_divisors(n)\\n  i = 1\\n  while true\\n    count = 0\\n    (1..i).each do |num|\\n      count += 1 if i % num == 0\\n      break if count > n\\n    end\\n    return i if count == n\\n    i += 1\\n  end\\nend\\n\\nn = gets.chomp.to_i\\nputs smallest_integer_with_n_divisors(n)","delphi":"program SmallestIntegerWithNDivisors;\\n\\nvar\\n  n, i, count, num: Int64;\\n\\nbegin\\n  \/\/ Read the value of n\\n  ReadLn(n);\\n\\n  \/\/ Initialize the count of divisors and the number\\n  count := 0;\\n  num := 1;\\n\\n  \/\/ Loop until we find a number with n divisors\\n  while count < n do\\n  begin\\n    \/\/ Increment the number\\n    Inc(num);\\n\\n    \/\/ Reset the count of divisors\\n    count := 0;\\n\\n    \/\/ Count the divisors of the current number\\n    for i := 1 to num do\\n    begin\\n      if num mod i = 0 then\\n        Inc(count);\\n    end;\\n  end;\\n\\n  \/\/ Output the smallest positive integer with exactly n divisors\\n  WriteLn(num);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\t\/\/ Find the smallest prime number with n-1 divisors\\n\\tprime := smallestPrime(n - 1)\\n\\n\\t\/\/ Calculate the power of the prime number\\n\\tpower := int(math.Ceil(float64(n) \/ float64(prime-1)))\\n\\n\\t\/\/ Calculate the smallest positive integer with exactly n divisors\\n\\tresult := int(math.Pow(float64(prime), float64(power)))\\n\\n\\tfmt.Println(result)\\n}\\n\\n\/\/ Function to find the smallest prime number with n divisors\\nfunc smallestPrime(n int) int {\\n\\t\/\/ Initialize the smallest prime number\\n\\tprime := 2\\n\\n\\t\/\/ Iterate through all numbers starting from 2\\n\\tfor i := 2; i <= n; i++ {\\n\\t\\t\/\/ Check if the number is prime\\n\\t\\tif isPrime(i) {\\n\\t\\t\\tprime = i\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn prime\\n}\\n\\n\/\/ Function to check if a number is prime\\nfunc isPrime(n int) bool {\\n\\t\/\/ Check if the number is divisible by any number less than itself\\n\\tfor i := 2; i < n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}","Javascript":"function smallestIntegerWithNDivisors(n) {\n    let count = 0;\n    let num = 1;\n    \n    while (true) {\n        let divisors = 0;\n        \n        for (let i = 1; i <= Math.sqrt(num); i++) {\n            if (num % i === 0) {\n                divisors++;\n                \n                if (num \/ i !== i) {\n                    divisors++;\n                }\n            }\n        }\n        \n        if (divisors === n) {\n            return num;\n        }\n        \n        num++;\n    }\n}\n\nconst input = parseInt(readline(), 10);\nconst result = smallestIntegerWithNDivisors(input);\nconsole.log(result);","Kotlin":"fun smallestIntegerWithNDivisors(n: Int): Long {\n    var num = 1L\n    var count = 0\n    var i = 1\n    \n    while (count < n) {\n        count = 0\n        num++\n        i = 1\n        \n        while (i * i <= num) {\n            if (num % i == 0) {\n                count += 2\n                if (i * i == num) {\n                    count--\n                }\n            }\n            i++\n        }\n    }\n    \n    return num\n}\n\nfun main() {\n    val n = readLine()!!.toInt()\n    val result = smallestIntegerWithNDivisors(n)\n    println(result)\n}","PHP":"<?php\\n\\nfunction smallestIntegerWithNDivisors($n) {\\n    $count = 0;\\n    $num = 1;\\n    while (true) {\\n        $divisors = 0;\\n        for ($i = 1; $i <= sqrt($num); $i++) {\\n            if ($num % $i == 0) {\\n                if ($num \/ $i == $i) {\\n                    $divisors++;\\n                } else {\\n                    $divisors += 2;\\n                }\\n            }\\n        }\\n        if ($divisors == $n) {\\n            return $num;\\n        }\\n        $num++;\\n    }\\n}\\n\\n$input = trim(fgets(STDIN));\\n$result = smallestIntegerWithNDivisors($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.math;\\r\\n\\r\\nulong smallestIntegerWithNDivisors(int n)\\r\\n{\\r\\n    ulong result = 1;\\r\\n    int count = 0;\\r\\n    int i = 2;\\r\\n    while (count < n)\\r\\n    {\\r\\n        int exponent = 0;\\r\\n        while (n % i == 0)\\r\\n        {\\r\\n            n \/= i;\\r\\n            exponent++;\\r\\n        }\\r\\n        count = (exponent + 1) * count;\\r\\n        result *= pow(i, exponent);\\r\\n        i++;\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    ulong smallestInteger = smallestIntegerWithNDivisors(n);\\r\\n    writeln(smallestInteger);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub smallest_integer_with_n_divisors {\n    my $n = shift;\n    \n    my $num = 1;\n    my $count = 0;\n    \n    while (1) {\n        my $divisors = count_divisors($num);\n        if ($divisors == $n) {\n            return $num;\n        }\n        $num++;\n    }\n}\n\nsub count_divisors {\n    my $num = shift;\n    \n    my $count = 0;\n    for (my $i = 1; $i <= sqrt($num); $i++) {\n        if ($num % $i == 0) {\n            $count++;\n            if ($num \/ $i != $i) {\n                $count++;\n            }\n        }\n    }\n    \n    return $count;\n}\n\n# Read input from STDIN\nmy $n = <STDIN>;\nchomp $n;\n\n# Call the function and print the result\nmy $result = smallest_integer_with_n_divisors($n);\nprint $result;\n","Rust":"fn smallest_integer_with_n_divisors(n: u64) -> u64 {\\n    let mut num = 1;\\n    let mut count = 0;\\n    let mut i = 1;\\n\\n    while count < n {\\n        count = 0;\\n        num += 1;\\n\\n        for j in 1..=num {\\n            if num % j == 0 {\\n                count += 1;\\n            }\\n        }\\n    }\\n\\n    num\\n}\\n\\nfn main() {\\n    let n: u64 = 4;\\n    let result = smallest_integer_with_n_divisors(n);\\n    println!(\\\"{}\\\", result);\\n}"}
{"title":"D. Yet Another Number Game","description":"Since most contestants do not read this part, I have to repeat that Bitlandians are quite weird. They have their own jobs, their own working method, their own lives, their own sausages and their own games!Since you are so curious about Bitland, I'll give you the chance of peeking at one of these games.BitLGM and BitAryo are playing yet another of their crazy-looking genius-needed Bitlandish games. They've got a sequence of n non-negative integers a1,a2,...,an. The players make moves in turns. BitLGM moves first. Each player can and must do one of the two following actions in his turn:  Take one of the integers (we'll denote it as ai). Choose integer x (1\u2264x\u2264ai). And then decrease ai by x, that is, apply assignment: ai=ai-x.  Choose integer x . And then decrease all ai by x, that is, apply assignment: ai=ai-x, for all i. The player who cannot make a move loses.You're given the initial sequence a1,a2,...,an. Determine who wins, if both players plays optimally well and if BitLGM and BitAryo start playing the described game in this sequence.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (1\u2264n\u22643).\nThe next line contains n integers a1,a2,...,an (0\u2264ai<300).\n","output_spec":"Write the name of the winner (provided that both players play optimally well). Either \"BitLGM\" or \"BitAryo\" (without the quotes).\n","notes":null,"sample_inputs":["2\n1 1\n","2\n1 2\n","3\n1 2 1\n"],"sample_outputs":["BitLGM\n","BitAryo\n","BitLGM\n"],"id":"282-D","difficulty":2100,"tags":["dp","games"],"src_uid":"7a33b4f94082c7ef80d7e87b58497fa7","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstring winner(int n, vector<int>& a) {\\n    int xorSum = 0;\\n    for (int i = 0; i < n; i++) {\\n        xorSum ^= a[i];\\n    }\\n    if (xorSum == 0) {\\n        return \\\"BitAryo\\\";\\n    } else {\\n        return \\\"BitLGM\\\";\\n    }\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n    string result = winner(n, a);\\n    cout << result << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class BitlandishGame {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] sequence = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            sequence[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        String winner = determineWinner(sequence);\\n        System.out.println(winner);\\n    }\\n\\n    public static String determineWinner(int[] sequence) {\\n        int xorSum = 0;\\n        for (int num : sequence) {\\n            xorSum ^= num;\\n        }\\n\\n        if (xorSum == 0) {\\n            return \\\"BitAryo\\\";\\n        } else {\\n            return \\\"BitLGM\\\";\\n        }\\n    }\\n}\" }","Python":"def determine_winner(n, a):\n    # Check if the sum of all integers is even\n    if sum(a) % 2 == 0:\n        return 'BitAryo'\n    else:\n        return 'BitLGM'\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Determine the winner\nwinner = determine_winner(n, a)\n\n# Print the winner\nprint(winner)\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    int xor_sum = 0;\\n    for(int i=0; i<n; i++) {\\n        xor_sum ^= a[i];\\n    }\\n    int max_element = 0;\\n    for(int i=0; i<n; i++) {\\n        if(a[i] > max_element) {\\n            max_element = a[i];\\n        }\\n    }\\n    if(xor_sum == 0) {\\n        printf(\\\"BitAryo\\\\n\\\");\\n    } else {\\n        if(max_element == 1) {\\n            if(n % 2 == 0) {\\n                printf(\\\"BitAryo\\\\n\\\");\\n            } else {\\n                printf(\\\"BitLGM\\\\n\\\");\\n            }\\n        } else {\\n            printf(\\\"BitLGM\\\\n\\\");\\n        }\\n    }\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] sequence = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int xorSum = sequence.Aggregate(0, (current, num) => current ^ num);\n\n        if (xorSum == 0 || sequence.All(num => num % 2 == 0))\n        {\n            Console.WriteLine(\\\"BitAryo\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"BitLGM\\\");\n        }\n    }\n}\n","Ruby":"\ndef winner(n, a)\n  # Check if the sum of all integers is even\n  sum = a.reduce(:+)\n  if sum % 2 == 0\n    return 'BitAryo'\n  else\n    return 'BitLGM'\n  end\nend\n\n# Read input\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\na = input[1].split(' ').map(&:to_i)\n\n# Call the winner function and print the result\nputs winner(n, a)\n","delphi":"program BitlandishGame;\\n\\nvar\\n  n, i, ai, xorSum: Integer;\\n  a: array of Integer;\\n\\nbegin\\n  ReadLn(n);\\n  SetLength(a, n);\\n  xorSum := 0;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    Read(ai);\\n    a[i] := ai;\\n    xorSum := xorSum xor ai;\\n  end;\\n\\n  if xorSum = 0 then\\n    WriteLn('BitAryo')\\n  else\\n    WriteLn('BitLGM');\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar nums []int\\n\\tvar input string\\n\\tfmt.Scan(&input)\\n\\n\\tfor _, num := range strings.Split(input, \\\" \\\") {\\n\\t\\tnumInt, _ := strconv.Atoi(num)\\n\\t\\tnums = append(nums, numInt)\\n\\t}\\n\\n\\twinner := determineWinner(nums)\\n\\tfmt.Println(winner)\\n}\\n\\nfunc determineWinner(nums []int) string {\\n\\tbitLGM := true\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif nums[i] > 1 {\\n\\t\\t\\tbitLGM = !bitLGM\\n\\t\\t}\\n\\t}\\n\\n\\tif bitLGM {\\n\\t\\treturn \\\"BitLGM\\\"\\n\\t} else {\\n\\t\\treturn \\\"BitAryo\\\"\\n\\t}\\n}","Javascript":"function determineWinner(n, arr) {\n    let xorSum = 0;\n    for (let i = 0; i < n; i++) {\n        xorSum ^= arr[i];\n    }\n    \n    if (xorSum === 0) {\n        return 'BitAryo';\n    } else {\n        return 'BitLGM';\n    }\n}\n\nconst input = '2\\n1 1\\n';\nconst lines = input.split('\\\\n');\nconst n = parseInt(lines[0]);\nconst arr = lines[1].split(' ').map(Number);\n\nconst winner = determineWinner(n, arr);\nconsole.log(winner);","Kotlin":"fun main() {\\n    val n = readLine()!!.toInt()\\n    val sequence = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    var xorSum = 0\\n    for (num in sequence) {\\n        xorSum = xorSum xor num\\n    }\\n\\n    if (xorSum == 0 || n % 2 == 0) {\\n        println(\\\"BitAryo\\\")\\n    } else {\\n        println(\\\"BitLGM\\\")\\n    }\\n}","PHP":"\n<?php\n\nfunction determineWinner($n, $sequence) {\n    \/\/ Check if the sum of all integers in the sequence is even\n    $sum = array_sum($sequence);\n    if ($sum % 2 == 0) {\n        \/\/ If the sum is even, BitAryo wins\n        return 'BitAryo';\n    } else {\n        \/\/ If the sum is odd, BitLGM wins\n        return 'BitLGM';\n    }\n}\n\n\/\/ Read input from stdin\n$input = explode('\\n', trim(fgets(STDIN)));\n$n = intval($input[0]);\n$sequence = array_map('intval', explode(' ', $input[1]));\n\n\/\/ Determine the winner\n$winner = determineWinner($n, $sequence);\n\n\/\/ Print the winner\necho $winner;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring determineWinner(int[] a) {\\r\\n    int n = a.length;\\r\\n    int xorSum = a.reduce!((a, b) => a ^ b);\\r\\n    bool allZero = a.all!(x => x == 0);\\r\\n\\r\\n    if (allZero || xorSum == 0) {\\r\\n        return \\\"BitAryo\\\";\\r\\n    }\\r\\n\\r\\n    return \\\"BitLGM\\\";\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    int[] a;\\r\\n\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    a = new int[n];\\r\\n\\r\\n    foreach (i; 0..n) {\\r\\n        readf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    string winner = determineWinner(a);\\r\\n    writeln(winner);\\r\\n}","perl":"\n# Read the input\nmy $n = <>;\nchomp $n;\nmy $sequence = <>;\nchomp $sequence;\n\n# Split the sequence into an array of integers\nmy @numbers = split ' ', $sequence;\n\n# Calculate the XOR of all the numbers\nmy $xor = 0;\nforeach my $number (@numbers) {\n    $xor ^= $number;\n}\n\n# Determine the winner based on the XOR result\nif ($xor == 0) {\n    print 'BitAryo\\n';\n} else {\n    print 'BitLGM\\n';\n}\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buf = String::new();\n    input.read_line(&mut buf).unwrap();\n    let n: usize = buf.trim().parse().unwrap();\n    \n    buf.clear();\n    input.read_line(&mut buf).unwrap();\n    let mut nums: Vec<usize> = buf\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    \n    let mut xor_sum = 0;\n    for num in &nums {\n        xor_sum ^= num;\n    }\n    \n    let mut moves = 0;\n    for num in &nums {\n        let diff = xor_sum ^ num;\n        if diff <= num {\n            moves += 1;\n        }\n    }\n    \n    if moves % 2 == 0 {\n        println!(\"BitAryo\");\n    } else {\n        println!(\"BitLGM\");\n    }\n}"}
{"title":"B. pSort","description":"One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i-j|=di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains positive integer n (1\u2264n\u2264100) \u2014 the number of cells in the array. The second line contains n distinct integers from 1 to n \u2014 permutation. The last line contains n integers from 1 to n \u2014 favourite numbers of the cells.\n","output_spec":"If the given state is reachable in the described game, output YES, otherwise NO.\n","notes":null,"sample_inputs":["5\n5 4 3 2 1\n1 1 1 1 1\n","7\n4 3 5 1 2 7 6\n4 6 6 1 6 6 1\n","7\n4 2 5 1 3 7 6\n4 6 6 1 6 6 1\n"],"sample_outputs":["YES\n","NO\n","YES\n"],"id":"28-B","difficulty":1600,"tags":["dfs+and+similar","dsu","graphs"],"src_uid":"c4b7265ff4332225c0d5617c3233a910","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isReachable(vector<int>& permutation, vector<int>& favorites) {\\n    int n = permutation.size();\\n    vector<int> visited(n, 0);\\n\\n    for (int i = 0; i < n; i++) {\\n        if (visited[i]) continue;\\n\\n        int curr = i;\\n        visited[curr] = 1;\\n\\n        while (true) {\\n            int next = curr + favorites[curr];\\n\\n            if (next >= 0 && next < n && !visited[next]) {\\n                visited[next] = 1;\\n                swap(permutation[curr], permutation[next]);\\n                curr = next;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        if (permutation[i] != i + 1) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    vector<int> permutation(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> permutation[i];\\n    }\\n\\n    vector<int> favorites(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> favorites[i];\\n    }\\n\\n    if (isReachable(permutation, favorites)) {\\n        cout << \\\"YES\\\" << endl;\\n    }\\n    else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] permutation = new int[n];\n        int[] favouriteNumbers = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            permutation[i] = scanner.nextInt();\n        }\n        \n        for (int i = 0; i < n; i++) {\n            favouriteNumbers[i] = scanner.nextInt();\n        }\n        \n        boolean[] visited = new boolean[n];\n        boolean reachable = dfs(permutation, favouriteNumbers, visited, 0);\n        \n        if (reachable) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n    \n    public static boolean dfs(int[] permutation, int[] favouriteNumbers, boolean[] visited, int index) {\n        if (index < 0 || index >= permutation.length || visited[index]) {\n            return false;\n        }\n        \n        visited[index] = true;\n        \n        if (permutation[index] == index + 1) {\n            return true;\n        }\n        \n        int favouriteNumber = favouriteNumbers[index];\n        \n        if (dfs(permutation, favouriteNumbers, visited, index + favouriteNumber) || dfs(permutation, favouriteNumbers, visited, index - favouriteNumber)) {\n            return true;\n        }\n        \n        visited[index] = false;\n        return false;\n    }\n}","Python":"def is_reachable(n, permutation, favourites):\n    visited = [False] * n\n    queue = [0]\n    visited[0] = True\n\n    while queue:\n        current = queue.pop(0)\n        if permutation[current] == current + 1:\n            return 'YES'\n        for i in range(n):\n            if not visited[i] and abs(current - i) == favourites[current]:\n                visited[i] = True\n                queue.append(i)\n\n    return 'NO'\n\ninputs = ['5\\n5 4 3 2 1\\n1 1 1 1 1\\n', '7\\n4 3 5 1 2 7 6\\n4 6 6 1 6 6 1\\n', '7\\n4 2 5 1 3 7 6\\n4 6 6 1 6 6 1\\n']\noutputs = ['YES\\n', 'NO\\n', 'YES\\n']\n\nfor i, input_str in enumerate(inputs):\n    input_lines = input_str.strip().split('\\n')\n    n = int(input_lines[0])\n    permutation = list(map(int, input_lines[1].split()))\n    favourites = list(map(int, input_lines[2].split()))\n\n    output = is_reachable(n, permutation, favourites)\n    assert output == outputs[i]\n\nprint('All test cases pass')","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isReachable(int n, int* permutation, int* favourites) {\\n    int visited[n];\\n    for (int i = 0; i < n; i++) {\\n        visited[i] = 0;\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        int current = permutation[i];\\n        visited[current - 1] = 1;\\n\\n        int left = current - favourites[current - 1];\\n        int right = current + favourites[current - 1];\\n\\n        if (left >= 1 && visited[left - 1] == 1) {\\n            return false;\\n        }\\n\\n        if (right <= n && visited[right - 1] == 1) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n\\n    int permutation[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &permutation[i]);\\n    }\\n\\n    int favourites[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &favourites[i]);\\n    }\\n\\n    if (isReachable(n, permutation, favourites)) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace CellGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] permutation = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n            int[] favouriteNumbers = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            bool reachable = IsStateReachable(n, permutation, favouriteNumbers);\n\n            if (reachable)\n            {\n                Console.WriteLine(\\\"YES\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"NO\\\");\n            }\n        }\n\n        static bool IsStateReachable(int n, int[] permutation, int[] favouriteNumbers)\n        {\n            List<int> cells = new List<int>(n);\n            for (int i = 0; i < n; i++)\n            {\n                cells.Add(i + 1);\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                int currentCell = permutation[i];\n                int favouriteNumber = favouriteNumbers[currentCell - 1];\n\n                for (int j = 0; j < n; j++)\n                {\n                    if (Math.Abs(i - j) == favouriteNumber && cells[j] == currentCell)\n                    {\n                        int temp = cells[i];\n                        cells[i] = cells[j];\n                        cells[j] = temp;\n                        break;\n                    }\n                }\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                if (cells[i] != permutation[i])\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}","Ruby":"\ndef reachable_state(n, permutation, favourite_numbers)\n  # Create an array to keep track of the current state of the cells\n  current_state = (1..n).to_a\n\n  # Iterate through each cell in the permutation\n  permutation.each_with_index do |cell, index|\n    # Check if the current state of the cell matches the desired state\n    if current_state[index] != cell\n      # Find the favourite number of the current cell\n      favourite_number = favourite_numbers[index]\n\n      # Iterate through each cell in the current state\n      current_state.each_with_index do |current_cell, current_index|\n        # Check if the current cell can be swapped with the current state\n        if (current_index - index).abs == favourite_number\n          # Swap the values of the current cell and the desired cell\n          current_state[index], current_state[current_index] = current_state[current_index], current_state[index]\n\n          # Check if the current state matches the desired state\n          return 'YES' if current_state == permutation\n\n          # Break out of the loop since a valid swap has been made\n          break\n        end\n      end\n    end\n  end\n\n  # If no valid swaps were made and the current state does not match the desired state, return 'NO'\n  'NO'\nend\n\n# Parse the input\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\npermutation = input[1].split(' ').map(&:to_i)\nfavourite_numbers = input[2].split(' ').map(&:to_i)\n\n# Call the function and print the result\nputs reachable_state(n, permutation, favourite_numbers)\n","delphi":"Here is a possible implementation in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar permutation string\\n\\tfmt.Scan(&permutation)\\n\\n\\tvar favourites string\\n\\tfmt.Scan(&favourites)\\n\\n\\tpermutationArr := strings.Split(permutation, \\\" \\\")\\n\\tfavouritesArr := strings.Split(favourites, \\\" \\\")\\n\\n\\treachable := isReachable(n, permutationArr, favouritesArr)\\n\\n\\tif reachable {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}\\n\\nfunc isReachable(n int, permutation []string, favourites []string) bool {\\n\\tvisited := make([]bool, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvisited[i] = false\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif !visited[i] {\\n\\t\\t\\tvisited[i] = true\\n\\t\\t\\tj := i\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tj = (j + 1) % n\\n\\t\\t\\t\\tif visited[j] {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[j] = true\\n\\t\\t\\t\\tif abs(i-j) == atoi(favourites[i]) {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif !visited[i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc abs(x int) int {\\n\\tif x < 0 {\\n\\t\\treturn -x\\n\\t}\\n\\treturn x\\n}\\n\\nfunc atoi(s string) int {\\n\\tvar res int\\n\\tfor _, c := range s {\\n\\t\\tres = res*10 + int(c-'0')\\n\\t}\\n\\treturn res\\n}","Javascript":"function isReachable(n, permutation, favorites) {\n    let visited = new Array(n).fill(false);\n    let queue = [];\n    \n    visited[permutation[0] - 1] = true;\n    queue.push(permutation[0] - 1);\n    \n    while (queue.length > 0) {\n        let currentCell = queue.shift();\n        \n        if (currentCell === permutation[n - 1] - 1) {\n            return 'YES';\n        }\n        \n        let favoriteNumber = favorites[currentCell];\n        \n        if (currentCell - favoriteNumber >= 0 && !visited[currentCell - favoriteNumber]) {\n            visited[currentCell - favoriteNumber] = true;\n            queue.push(currentCell - favoriteNumber);\n        }\n        \n        if (currentCell + favoriteNumber < n && !visited[currentCell + favoriteNumber]) {\n            visited[currentCell + favoriteNumber] = true;\n            queue.push(currentCell + favoriteNumber);\n        }\n    }\n    \n    return 'NO';\n}\n\nlet input = '7\\\\n4 3 5 1 2 7 6\\\\n4 6 6 1 6 6 1\\\\n';\nlet lines = input.trim().split('\\\\n');\nlet n = parseInt(lines[0]);\nlet permutation = lines[1].split(' ').map(Number);\nlet favorites = lines[2].split(' ').map(Number);\n\nlet result = isReachable(n, permutation, favorites);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val permutation = IntArray(n)\n    for (i in 0 until n) {\n        permutation[i] = sc.nextInt()\n    }\n    val favouriteNumbers = IntArray(n)\n    for (i in 0 until n) {\n        favouriteNumbers[i] = sc.nextInt()\n    }\n    val visited = BooleanArray(n)\n    val queue: Queue<Int> = LinkedList()\n    queue.add(0)\n    visited[0] = true\n    while (!queue.isEmpty()) {\n        val currentCell = queue.poll()\n        val currentNumber = permutation[currentCell]\n        val favouriteNumber = favouriteNumbers[currentCell]\n        if (currentCell + favouriteNumber < n && !visited[currentCell + favouriteNumber]) {\n            visited[currentCell + favouriteNumber] = true\n            queue.add(currentCell + favouriteNumber)\n        }\n        if (currentCell - favouriteNumber >= 0 && !visited[currentCell - favouriteNumber]) {\n            visited[currentCell - favouriteNumber] = true\n            queue.add(currentCell - favouriteNumber)\n        }\n    }\n    var reachable = true\n    for (i in 0 until n) {\n        if (!visited[i]) {\n            reachable = false\n            break\n        }\n    }\n    if (reachable) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"\n<?php\n\nfunction isReachable($n, $permutation, $favouriteNumbers) {\n    $visited = array_fill(0, $n, false);\n    $queue = [];\n    \n    \/\/ Start from the first cell\n    $queue[] = 0;\n    $visited[0] = true;\n    \n    while (!empty($queue)) {\n        $currentCell = array_shift($queue);\n        \n        \/\/ Check if the current cell matches the desired permutation\n        if ($currentCell == $permutation[$currentCell]) {\n            return 'YES';\n        }\n        \n        \/\/ Find the neighbouring cells that can be swapped with the current cell\n        $neighbours = [];\n        $di = $favouriteNumbers[$currentCell];\n        \n        if ($currentCell - $di >= 0) {\n            $neighbours[] = $currentCell - $di;\n        }\n        \n        if ($currentCell + $di < $n) {\n            $neighbours[] = $currentCell + $di;\n        }\n        \n        \/\/ Visit the neighbouring cells if they haven't been visited before\n        foreach ($neighbours as $neighbour) {\n            if (!$visited[$neighbour]) {\n                $visited[$neighbour] = true;\n                $queue[] = $neighbour;\n            }\n        }\n    }\n    \n    return 'NO';\n}\n\n\/\/ Read input\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\n$n = intval($input[0]);\n$permutation = array_map('intval', explode(' ', $input[1]));\n$favouriteNumbers = array_map('intval', explode(' ', $input[2]));\n\n\/\/ Check if the given state is reachable\n$result = isReachable($n, $permutation, $favouriteNumbers);\n\n\/\/ Output the result\necho $result;\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nbool isReachable(int[] permutation, int[] favouriteNumbers)\\r\\n{\\r\\n    int n = permutation.length;\\r\\n    int[] cells = new int[n];\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        cells[i] = i + 1;\\r\\n    }\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        int currentCell = permutation[i];\\r\\n        int favouriteNumber = favouriteNumbers[currentCell - 1];\\r\\n\\r\\n        for (int j = 0; j < n; j++)\\r\\n        {\\r\\n            if (abs(currentCell - (j + 1)) == favouriteNumber)\\r\\n            {\\r\\n                swap(cells[currentCell - 1], cells[j]);\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return cells == permutation;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] permutation = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &permutation[i]);\\r\\n    }\\r\\n\\r\\n    int[] favouriteNumbers = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &favouriteNumbers[i]);\\r\\n    }\\r\\n\\r\\n    if (isReachable(permutation, favouriteNumbers))\\r\\n    {\\r\\n        writeln(\\\"YES\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub is_reachable_state {\n    my ($n, $permutation, $favourite_numbers) = @_;\n\n    my @cells = (1..$n);\n\n    for my $i (0..$n-1) {\n        my $current_cell = $permutation->[$i];\n        my $favourite_number = $favourite_numbers->[$current_cell-1];\n\n        for my $j (0..$n-1) {\n            next if $i == $j;\n\n            my $other_cell = $permutation->[$j];\n            my $difference = abs($i - $j);\n\n            if ($difference == $favourite_number && $cells[$j] == $current_cell) {\n                ($cells[$i], $cells[$j]) = ($cells[$j], $cells[$i]);\n                last;\n            }\n        }\n    }\n\n    for my $i (0..$n-1) {\n        return 'NO' if $cells[$i] != $permutation->[$i];\n    }\n\n    return 'YES';\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @permutation = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @favourite_numbers = split ' ', $input;\n\n# Check if the given state is reachable\nmy $result = is_reachable_state($n, \\@permutation, \\@favourite_numbers);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: usize = input.trim().parse().unwrap();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let permutation: Vec<usize> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let favourite_numbers: Vec<usize> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut visited = vec![false; n];\n    let mut queue = std::collections::VecDeque::new();\n    queue.push_back(0);\n\n    while let Some(current) = queue.pop_front() {\n        visited[current] = true;\n\n        let left = current.checked_sub(favourite_numbers[current]);\n        let right = current.checked_add(favourite_numbers[current]);\n\n        if left.is_some() && !visited[left.unwrap()] {\n            queue.push_back(left.unwrap());\n        }\n\n        if right.is_some() && !visited[right.unwrap()] {\n            queue.push_back(right.unwrap());\n        }\n    }\n\n    let reachable = visited.iter().enumerate().all(|(i, &v)| v || permutation[i] == i + 1);\n\n    if reachable {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"C. Bath Queue","description":"There are n students living in the campus. Every morning all students wake up at the same time and go to wash. There are m rooms with wash basins. The i-th of these rooms contains ai wash basins. Every student independently select one the rooms with equal probability and goes to it. After all students selected their rooms, students in each room divide into queues by the number of wash basins so that the size of the largest queue is the least possible. Calculate the expected value of the size of the largest queue among all rooms.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two positive integers n and m (1\u2264n,m\u226450) \u2014 the amount of students and the amount of rooms. The second line contains m integers a1,a2,... ,am (1\u2264ai\u226450). ai means the amount of wash basins in the i-th room.\n","output_spec":"Output single number: the expected value of the size of the largest queue. Your answer must have an absolute or relative error less than 10^-9.\n","notes":null,"sample_inputs":["1 1\n2\n","2 2\n1 1\n","2 3\n1 1 1\n","7 5\n1 1 2 3 1\n"],"sample_outputs":["1.00000000000000000000\n","1.50000000000000000000\n","1.33333333333333350000\n","2.50216960000000070000\n"],"id":"28-C","difficulty":2200,"tags":["combinatorics","dp","probabilities"],"src_uid":"c2b3b577c2bcb3a2a8cb48700c637270","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<int> a(m);\\n    for (int i = 0; i < m; i++) {\\n        cin >> a[i];\\n    }\\n\\n    int maxBasins = *max_element(a.begin(), a.end());\\n    double ans = 0;\\n\\n    for (int i = 1; i <= maxBasins; i++) {\\n        double prob = 1;\\n        for (int j = 0; j < m; j++) {\\n            prob *= min(i, a[j]) \/ (double)a[j];\\n        }\\n        ans += prob;\\n    }\\n\\n    cout.precision(20);\\n    cout << ans << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Arrays;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int[] rooms = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            rooms[i] = scanner.nextInt();\\n        }\\n        Arrays.sort(rooms);\\n        double[][] dp = new double[m + 1][n + 1];\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                for (int k = 0; k <= rooms[i - 1] && k <= j; k++) {\\n                    dp[i][j] += dp[i - 1][j - k] \/ (rooms[i - 1] + 1);\\n                }\\n            }\\n        }\\n        double ans = 0;\\n        for (int i = 0; i <= n; i++) {\\n            ans += dp[m][i] * i;\\n        }\\n        System.out.printf(\\\"%.10f\\\", ans);\\n    }\\n}","Python":"import itertools\\n\\n# Function to calculate the expected value of the size of the largest queue\\n\\ndef calculate_expected_value(n, m, a):\\n    total_combinations = list(itertools.combinations(range(m), n))\\n    total_probabilities = []\\n    for combination in total_combinations:\\n        probabilities = []\\n        for i in range(m):\\n            if i in combination:\\n                probabilities.append(1\/a[i])\\n            else:\\n                probabilities.append(0)\\n        total_probabilities.append(probabilities)\\n    expected_value = 0\\n    for probabilities in total_probabilities:\\n        max_queue_size = max(probabilities)\\n        expected_value += max_queue_size\\n    expected_value \/= len(total_probabilities)\\n    return expected_value\\n\\n\\n# Sample Inputs\\ninputs = ['1 1\\\\n2\\\\n', '2 2\\\\n1 1\\\\n', '2 3\\\\n1 1 1\\\\n', '7 5\\\\n1 1 2 3 1\\\\n']\\n\\n# Parsing Inputs\\nfor input_str in inputs:\\n    input_lines = input_str.strip().split('\\\\n')\\n    n, m = map(int, input_lines[0].split())\\n    a = list(map(int, input_lines[1].split()))\\n\\n    # Calculating Expected Value\\n    expected_value = calculate_expected_value(n, m, a)\\n\\n    # Printing Output\\n    print('%.20f' % expected_value)\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint compare(const void *a, const void *b) {\\n    return (*(int*)a - *(int*)b);\\n}\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int a[m];\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    qsort(a, m, sizeof(int), compare);\\n    double dp[n + 1][m + 1];\\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= m; j++) {\\n            dp[i][j] = 0;\\n        }\\n    }\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= m; j++) {\\n            for (int k = 0; k <= i; k++) {\\n                dp[i][j] += dp[i - k][j - 1] * (k <= a[j - 1] ? 1.0 \/ a[j - 1] : 1.0 \/ a[j - 1] * (k - a[j - 1] + 1) \/ k);\\n            }\\n        }\\n    }\\n    double ans = 0;\\n    for (int i = 1; i <= n; i++) {\\n        ans += dp[n][m] - dp[n][i - 1];\\n    }\\n    printf(\\\"%.10lf\\\\n\\\", ans);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace CampusWash\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            int[] rooms = new int[m];\n            input = Console.ReadLine().Split();\n            for (int i = 0; i < m; i++)\n            {\n                rooms[i] = int.Parse(input[i]);\n            }\n\n            double result = CalculateExpectedValue(n, m, rooms);\n            Console.WriteLine(result.ToString(\"F9\"));\n        }\n\n        static double CalculateExpectedValue(int n, int m, int[] rooms)\n        {\n            int totalBasins = 0;\n            foreach (int basinCount in rooms)\n            {\n                totalBasins += basinCount;\n            }\n\n            double[,] dp = new double[n + 1, totalBasins + 1];\n            dp[0, 0] = 1;\n\n            for (int i = 1; i <= n; i++)\n            {\n                for (int j = 1; j <= totalBasins; j++)\n                {\n                    for (int k = 0; k < m; k++)\n                    {\n                        if (j >= rooms[k])\n                        {\n                            dp[i, j] += dp[i - 1, j - rooms[k]] \/ m;\n                        }\n                    }\n                }\n            }\n\n            double expectedValue = 0;\n            for (int j = 1; j <= totalBasins; j++)\n            {\n                expectedValue += dp[n, j] * (dp[n, j] - dp[n, j - 1]);\n            }\n\n            return expectedValue;\n        }\n    }\n}\n","Ruby":"\n# Function to calculate the expected value of the size of the largest queue\ndef calculate_expected_value(n, m, a)\n  # Calculate the total number of wash basins\n  total_basins = a.sum\n\n  # Initialize the dp array with all zeros\n  dp = Array.new(n + 1) { Array.new(total_basins + 1, 0) }\n\n  # Base case: If there is only one student, the expected value is the number of wash basins\n  (1..total_basins).each do |i|\n    dp[1][i] = i\n  end\n\n  # Calculate the expected value for each number of students and number of wash basins\n  (2..n).each do |i|\n    (1..total_basins).each do |j|\n      # Initialize the minimum expected value to a large number\n      min_expected = Float::INFINITY\n\n      # Iterate over all possible number of wash basins in the current room\n      (1..m).each do |k|\n        # If the number of wash basins in the current room is greater than the current number of wash basins,\n        # update the minimum expected value\n        if a[k-1] > j\n          min_expected = [min_expected, dp[i-1][j]].min\n        else\n          # Calculate the expected value for the current number of students and number of wash basins\n          expected = (1..a[k-1]).sum { |x| [dp[i-1][j-x], x].max } \/ a[k-1].to_f\n          min_expected = [min_expected, expected].min\n        end\n      end\n\n      # Update the dp array with the minimum expected value\n      dp[i][j] = min_expected\n    end\n  end\n\n  # Return the expected value for n students and total_basins wash basins\n  dp[n][total_basins]\nend\n\n# Read the input values\ninput = gets.chomp.split(\"\\n\")\nn, m = input[0].split.map(&:to_i)\na = input[1].split.map(&:to_i)\n\n# Calculate and print the expected value of the size of the largest queue\nputs calculate_expected_value(n, m, a)\n","delphi":"program CampusWash;\n\nvar\n  n, m, i, j, k, maxQueue, totalBasins: Integer;\n  a: array[1..50] of Integer;\n  dp: array[1..50, 1..50] of Extended;\n\nfunction max(a, b: Integer): Integer;\nbegin\n  if a > b then\n    Result := a\n  else\n    Result := b;\nend;\n\nfunction expectedValue(n, m: Integer): Extended;\nvar\n  i, j, k: Integer;\n  sum: Extended;\nbegin\n  for i := 1 to m do\n    totalBasins := totalBasins + a[i];\n  \n  for i := 1 to m do\n    dp[1, i] := 1;\n  \n  for i := 2 to n do\n  begin\n    for j := 1 to m do\n    begin\n      sum := 0;\n      for k := 1 to m do\n      begin\n        if a[k] >= a[j] then\n          sum := sum + dp[i-1, k];\n        else\n          sum := sum + dp[i-1, k] * (a[k] \/ a[j]);\n      end;\n      dp[i, j] := sum \/ m;\n    end;\n  end;\n  \n  maxQueue := 0;\n  for i := 1 to m do\n  begin\n    sum := 0;\n    for j := 1 to n do\n      sum := sum + dp[j, i];\n    maxQueue := max(maxQueue, Ceil(sum));\n  end;\n  \n  Result := maxQueue;\nend;\n\nbegin\n  ReadLn(n, m);\n  for i := 1 to m do\n    Read(a[i]);\n  \n  WriteLn(expectedValue(n, m):0:9);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nm[0])\\n\\tm, _ := strconv.Atoi(nm[1])\\n\\n\\tscanner.Scan()\\n\\trooms := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\ttotalBasins := 0\\n\\tmaxBasins := 0\\n\\n\\tfor _, room := range rooms {\\n\\t\\tbasins, _ := strconv.Atoi(room)\\n\\t\\ttotalBasins += basins\\n\\t\\tif basins > maxBasins {\\n\\t\\t\\tmaxBasins = basins\\n\\t\\t}\\n\\t}\\n\\n\\texpectedValue := float64(totalBasins) \/ float64(m)\\n\\n\\tif expectedValue > float64(maxBasins) {\\n\\t\\texpectedValue = float64(maxBasins)\\n\\t}\\n\\n\\tfmt.Printf(\\\"%.10f\\\\n\\\", expectedValue)\\n}","Javascript":"function calculateExpectedValue(input) {\n    const lines = input.split('\\\\n');\n    const [n, m] = lines[0].split(' ').map(Number);\n    const a = lines[1].split(' ').map(Number);\n    \n    const totalBasins = a.reduce((acc, curr) => acc + curr, 0);\n    const dp = Array.from({ length: n + 1 }, () => Array(totalBasins + 1).fill(0));\n    dp[0][0] = 1;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = n; j >= 1; j--) {\n            for (let k = totalBasins; k >= a[i - 1]; k--) {\n                dp[j][k] += dp[j - 1][k - a[i - 1]];\n            }\n        }\n    }\n    \n    let ans = 0;\n    for (let i = 1; i <= totalBasins; i++) {\n        let sum = 0;\n        for (let j = 1; j <= n; j++) {\n            sum += dp[j][i];\n        }\n        ans += sum \/ n;\n    }\n    \n    return ans.toFixed(20);\n}\n\nconst inputs = ['1 1\\\\n2\\\\n', '2 2\\\\n1 1\\\\n', '2 3\\\\n1 1 1\\\\n', '7 5\\\\n1 1 2 3 1\\\\n'];\nconst outputs = inputs.map(calculateExpectedValue);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \").map { it.toInt() }\n    val n = nm[0]\n    val m = nm[1]\n    val a = scanner.nextLine().split(\" \").map { it.toInt() }\n\n    val totalBasins = a.sum()\n    val dp = Array(n + 1) { DoubleArray(totalBasins + 1) }\n    dp[0][0] = 1.0\n\n    for (i in 1..n) {\n        for (j in 1..totalBasins) {\n            for (k in 0 until m) {\n                if (j >= a[k]) {\n                    dp[i][j] += dp[i - 1][j - a[k]]\n                }\n            }\n            dp[i][j] \/= m.toDouble()\n        }\n    }\n\n    var ans = 0.0\n    for (i in 1..totalBasins) {\n        ans += dp[n][i] * (dp[n][i] - dp[n][i - 1])\n    }\n\n    println(\"%.10f\".format(ans))\n}","PHP":"<?php\\n\\nfunction calculateExpectedValue($n, $m, $rooms) {\\n    $totalBasins = array_sum($rooms);\\n    $probabilities = array();\\n\\n    \/\/ Calculate the probability of each room being selected\\n    foreach ($rooms as $room) {\\n        $probabilities[] = $room \/ $totalBasins;\\n    }\\n\\n    \/\/ Calculate the expected value\\n    $expectedValue = 0;\\n    for ($i = 1; $i <= $n; $i++) {\\n        $currentValue = 0;\\n\\n        \/\/ Calculate the probability of having a queue of size $i\\n        foreach ($probabilities as $probability) {\\n            $currentValue += pow($probability, $i);\\n        }\\n\\n        $expectedValue += $i * ($currentValue - $expectedValue);\\n    }\\n\\n    return number_format($expectedValue, 20);\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    [1, 1, [2]],\\n    [2, 2, [1, 1]],\\n    [2, 3, [1, 1, 1]],\\n    [7, 5, [1, 1, 2, 3, 1]],\\n];\\n\\n\/\/ Calculate and print the expected values\\nforeach ($inputs as $input) {\\n    $n = $input[0];\\n    $m = $input[1];\\n    $rooms = $input[2];\\n\\n    $expectedValue = calculateExpectedValue($n, $m, $rooms);\\n    echo $expectedValue . \\\"\\\\n\\\";\\n}\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\r\\n        \\\"1 1\\\\n2\\\\n\\\",\\r\\n        \\\"2 2\\\\n1 1\\\\n\\\",\\r\\n        \\\"2 3\\\\n1 1 1\\\\n\\\",\\r\\n        \\\"7 5\\\\n1 1 2 3 1\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    string[] outputs = [\\r\\n        \\\"1.00000000000000000000\\\\n\\\",\\r\\n        \\\"1.50000000000000000000\\\\n\\\",\\r\\n        \\\"1.33333333333333350000\\\\n\\\",\\r\\n        \\\"2.50216960000000070000\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    foreach (i, input; inputs)\\r\\n    {\\r\\n        writeln(\\\"Input:\\\");\\r\\n        writeln(input);\\r\\n\\r\\n        writeln(\\\"Expected Output:\\\");\\r\\n        writeln(outputs[i]);\\r\\n\\r\\n        writeln(\\\"Actual Output:\\\");\\r\\n        writeln(calculateExpectedValue(input));\\r\\n\\r\\n        writeln();\\r\\n    }\\r\\n}\\r\\n\\r\\nstring calculateExpectedValue(string input)\\r\\n{\\r\\n    auto lines = input.splitter().array;\\r\\n    auto nm = lines[0].split;\\r\\n    auto n = nm[0].to!int;\\r\\n    auto m = nm[1].to!int;\\r\\n    auto a = lines[1].split.map!(x => x.to!int).array;\\r\\n\\r\\n    auto totalBasins = a.sum;\\r\\n    auto maxQueueSize = totalBasins \/ n;\\r\\n\\r\\n    double expectedValue = 0;\\r\\n\\r\\n    foreach (i, roomBasins; a)\\r\\n    {\\r\\n        auto roomProbability = roomBasins \/ totalBasins;\\r\\n        auto roomQueueSize = roomBasins \/ maxQueueSize;\\r\\n\\r\\n        expectedValue += roomProbability * roomQueueSize;\\r\\n    }\\r\\n\\r\\n    return expectedValue.to!string;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_expected_value {\n    my ($n, $m, @a) = @_;\n\n    my $total_basins = 0;\n    foreach my $basins (@a) {\n        $total_basins += $basins;\n    }\n\n    my $expected_value = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n        my $prob = 1;\n        for (my $j = 0; $j < $m; $j++) {\n            my $room_prob = $a[$j] \/ $total_basins;\n            my $queue_size = int($n * $room_prob);\n            if ($queue_size < $i) {\n                $prob *= ($n - $queue_size) \/ $n;\n            } else {\n                $prob *= ($n - $queue_size + 1) \/ $n;\n            }\n        }\n        $expected_value += $i * (1 - $prob);\n    }\n\n    return sprintf('%.20f', $expected_value);\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\nmy $rooms_input = <STDIN>;\nchomp $rooms_input;\nmy @a = split ' ', $rooms_input;\n\n# Calculate and print the expected value\nmy $expected_value = calculate_expected_value($n, $m, @a);\nprint $expected_value;\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n\n    let nm: Vec<usize> = lines[0].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n\n    let a: Vec<usize> = lines[1].split_whitespace().map(|x| x.parse().unwrap()).collect();\n\n    let mut dp = vec![vec![0.0; n + 1]; m + 1];\n    dp[0][0] = 1.0;\n\n    for i in 1..=m {\n        for j in 0..=n {\n            for k in 0..=a[i - 1].min(j) {\n                dp[i][j] += dp[i - 1][j - k] * choose(j, k) * choose(n - j + a[i - 1] - k, a[i - 1] - k);\n            }\n        }\n    }\n\n    let mut ans = 0.0;\n    for i in 1..=n {\n        let mut sum = 0.0;\n        for j in 1..=m {\n            sum += dp[m][i] - dp[j - 1][i];\n        }\n        ans += sum * i as f64;\n    }\n\n    println!(\"{:.10}\", ans);\n}\n\nfn choose(n: usize, k: usize) -> f64 {\n    let mut res = 1.0;\n    for i in 0..k {\n        res *= (n - i) as f64 \/ (i + 1) as f64;\n    }\n    res\n}"}
{"title":"B. Codeforces World Finals","description":"The king Copa often has been reported about the Codeforces site, which is rapidly getting more and more popular among the brightest minds of the humanity, who are using it for training and competing. Recently Copa understood that to conquer the world he needs to organize the world Codeforces tournament. He hopes that after it the brightest minds will become his subordinates, and the toughest part of conquering the world will be completed.The final round of the Codeforces World Finals 20YY is scheduled for DD.MM.YY, where DD is the day of the round, MM is the month and YY are the last two digits of the year. Bob is lucky to be the first finalist form Berland. But there is one problem: according to the rules of the competition, all participants must be at least 18 years old at the moment of the finals. Bob was born on BD.BM.BY. This date is recorded in his passport, the copy of which he has already mailed to the organizers. But Bob learned that in different countries the way, in which the dates are written, differs. For example, in the US the month is written first, then the day and finally the year. Bob wonders if it is possible to rearrange the numbers in his date of birth so that he will be at least 18 years old on the day DD.MM.YY. He can always tell that in his motherland dates are written differently. Help him.According to another strange rule, eligible participant must be born in the same century as the date of the finals. If the day of the finals is participant's 18-th birthday, he is allowed to participate. As we are considering only the years from 2001 to 2099 for the year of the finals, use the following rule: the year is leap if it's number is divisible by four.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains the date DD.MM.YY, the second line contains the date BD.BM.BY. It is guaranteed that both dates are correct, and YY and BY are always in [01;99].\nIt could be that by passport Bob was born after the finals. In this case, he can still change the order of numbers in date.\n","output_spec":"If it is possible to rearrange the numbers in the date of birth so that Bob will be at least 18 years old on the DD.MM.YY, output YES. In the other case, output NO. \nEach number contains exactly two digits and stands for day, month or year in a date. Note that it is permitted to rearrange only numbers, not digits.\n","notes":null,"sample_inputs":["01.01.98\n01.01.80\n","20.10.20\n10.02.30\n","28.02.74\n28.02.64\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"id":"30-B","difficulty":1700,"tags":["implementation"],"src_uid":"5418c98fe362909f7b28f95225837d33","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isLeapYear(int year) {\\n    if (year % 400 == 0) {\\n        return true;\\n    }\\n    if (year % 100 == 0) {\\n        return false;\\n    }\\n    if (year % 4 == 0) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\nbool isValidDate(int day, int month, int year) {\\n    if (month < 1 || month > 12) {\\n        return false;\\n    }\\n    if (day < 1 || day > 31) {\\n        return false;\\n    }\\n    if (month == 2) {\\n        if (isLeapYear(year)) {\\n            return day <= 29;\\n        } else {\\n            return day <= 28;\\n        }\\n    }\\n    if (month == 4 || month == 6 || month == 9 || month == 11) {\\n        return day <= 30;\\n    }\\n    return true;\\n}\\n\\nbool canParticipate(string finalsDate, string birthDate) {\\n    int finalsDay, finalsMonth, finalsYear;\\n    int birthDay, birthMonth, birthYear;\\n    sscanf(finalsDate.c_str(), \\\"%d.%d.%d\\\", &finalsDay, &finalsMonth, &finalsYear);\\n    sscanf(birthDate.c_str(), \\\"%d.%d.%d\\\", &birthDay, &birthMonth, &birthYear);\\n    if (!isValidDate(finalsDay, finalsMonth, finalsYear) || !isValidDate(birthDay, birthMonth, birthYear)) {\\n        return false;\\n    }\\n    if (finalsYear - birthYear < 18) {\\n        return false;\\n    }\\n    if (finalsYear - birthYear == 18) {\\n        if (finalsMonth < birthMonth) {\\n            return false;\\n        }\\n        if (finalsMonth == birthMonth && finalsDay < birthDay) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    string finalsDate, birthDate;\\n    cin >> finalsDate >> birthDate;\\n    if (canParticipate(finalsDate, birthDate)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Arrays;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String finalDate = scanner.nextLine();\\n        String birthDate = scanner.nextLine();\\n\\n        String[] finalDateParts = finalDate.split(\\\".\\\");\\n        String[] birthDateParts = birthDate.split(\\\".\\\");\\n\\n        int finalDay = Integer.parseInt(finalDateParts[0]);\\n        int finalMonth = Integer.parseInt(finalDateParts[1]);\\n        int finalYear = Integer.parseInt(finalDateParts[2]);\\n\\n        int birthDay = Integer.parseInt(birthDateParts[0]);\\n        int birthMonth = Integer.parseInt(birthDateParts[1]);\\n        int birthYear = Integer.parseInt(birthDateParts[2]);\\n\\n        int[] birthDateDigits = {birthDay, birthMonth, birthYear};\\n        Arrays.sort(birthDateDigits);\\n\\n        if (birthYear < finalYear && finalYear - birthYear >= 18 && finalMonth >= birthDateDigits[1] && finalDay >= birthDateDigits[0]) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n}","Python":"def rearrange_dates(finals_date, birth_date):\n    finals_day, finals_month, finals_year = map(int, finals_date.split('.'))\n    birth_day, birth_month, birth_year = map(int, birth_date.split('.'))\n    \n    # Check if birth year is in the same century as finals year\n    if finals_year \/\/ 100 != birth_year \/\/ 100:\n        return 'NO'\n    \n    # Check if birth year is after finals year\n    if birth_year > finals_year:\n        return 'NO'\n    \n    # Check if birth year is the same as finals year and birth month is after finals month\n    if birth_year == finals_year and birth_month > finals_month:\n        return 'NO'\n    \n    # Check if birth year is the same as finals year, birth month is the same as finals month, and birth day is after finals day\n    if birth_year == finals_year and birth_month == finals_month and birth_day > finals_day:\n        return 'NO'\n    \n    # Check if birth year is the same as finals year and the difference in months is less than 18\n    if birth_year == finals_year and finals_month - birth_month < 18:\n        return 'NO'\n    \n    # Check if birth year is the same as finals year, the difference in months is 18, and birth day is after finals day\n    if birth_year == finals_year and finals_month - birth_month == 18 and birth_day > finals_day:\n        return 'NO'\n    \n    return 'YES'\n\nfinals_date = input()\nbirth_date = input()\nprint(rearrange_dates(finals_date, birth_date))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdbool.h>\\n\\nbool isLeapYear(int year) {\\n    if (year % 4 == 0) {\\n        if (year % 100 == 0) {\\n            if (year % 400 == 0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        else\\n            return true;\\n    }\\n    else\\n        return false;\\n}\\n\\nint main() {\\n    int finalsDay, finalsMonth, finalsYear;\\n    int birthDay, birthMonth, birthYear;\\n    scanf(\\\"%d.%d.%d\\\", &finalsDay, &finalsMonth, &finalsYear);\\n    scanf(\\\"%d.%d.%d\\\", &birthDay, &birthMonth, &birthYear);\\n\\n    if (finalsYear - birthYear < 18) {\\n        printf(\\\"NO\\\\n\\\");\\n        return 0;\\n    }\\n\\n    if (finalsYear - birthYear == 18) {\\n        if (finalsMonth < birthMonth) {\\n            printf(\\\"NO\\\\n\\\");\\n            return 0;\\n        }\\n        if (finalsMonth == birthMonth && finalsDay < birthDay) {\\n            printf(\\\"NO\\\\n\\\");\\n            return 0;\\n        }\\n    }\\n\\n    if (finalsYear - birthYear == 18 && finalsMonth == birthMonth && finalsDay == birthDay) {\\n        printf(\\\"YES\\\\n\\\");\\n        return 0;\\n    }\\n\\n    if (finalsYear - birthYear == 18 && finalsMonth > birthMonth) {\\n        printf(\\\"YES\\\\n\\\");\\n        return 0;\\n    }\\n\\n    if (finalsYear - birthYear == 18 && finalsMonth == birthMonth && finalsDay > birthDay) {\\n        printf(\\\"YES\\\\n\\\");\\n        return 0;\\n    }\\n\\n    if (finalsYear - birthYear == 19) {\\n        if (finalsMonth > birthMonth) {\\n            printf(\\\"YES\\\\n\\\");\\n            return 0;\\n        }\\n        if (finalsMonth == birthMonth && finalsDay >= birthDay) {\\n            printf(\\\"YES\\\\n\\\");\\n            return 0;\\n        }\\n    }\\n\\n    if (finalsYear - birthYear > 19) {\\n        printf(\\\"YES\\\\n\\\");\\n        return 0;\\n    }\\n\\n    printf(\\\"NO\\\\n\\\");\\n    return 0;\\n}","C#":"\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split('.');\n        int finalsDay = int.Parse(input[0]);\n        int finalsMonth = int.Parse(input[1]);\n        int finalsYear = int.Parse(input[2]);\n\n        input = Console.ReadLine().Split('.');\n        int birthDay = int.Parse(input[0]);\n        int birthMonth = int.Parse(input[1]);\n        int birthYear = int.Parse(input[2]);\n\n        bool isLeapYear = finalsYear % 4 == 0;\n\n        if (birthYear > finalsYear || (birthYear == finalsYear && birthMonth > finalsMonth) || (birthYear == finalsYear && birthMonth == finalsMonth && birthDay > finalsDay))\n        {\n            \/\/ Bob was born after the finals, rearrange the numbers\n            int temp = birthDay;\n            birthDay = finalsDay;\n            finalsDay = temp;\n\n            temp = birthMonth;\n            birthMonth = finalsMonth;\n            finalsMonth = temp;\n\n            temp = birthYear;\n            birthYear = finalsYear;\n            finalsYear = temp;\n        }\n\n        if (birthYear + 18 < finalsYear)\n        {\n            Console.WriteLine(\"YES\");\n        }\n        else if (birthYear + 18 == finalsYear)\n        {\n            if (birthMonth < finalsMonth)\n            {\n                Console.WriteLine(\"YES\");\n            }\n            else if (birthMonth == finalsMonth && birthDay <= finalsDay)\n            {\n                Console.WriteLine(\"YES\");\n            }\n            else\n            {\n                Console.WriteLine(\"NO\");\n            }\n        }\n        else\n        {\n            Console.WriteLine(\"NO\");\n        }\n    }\n}\n","Ruby":"\ndef rearrange_dates(finals_date, birth_date)\n  finals_day, finals_month, finals_year = finals_date.split('.').map(&:to_i)\n  birth_day, birth_month, birth_year = birth_date.split('.').map(&:to_i)\n\n  # Check if birth year is in the same century as finals year\n  if finals_year - birth_year >= 0 && finals_year - birth_year <= 99\n    # Check if birth year is a leap year\n    leap_year = birth_year % 4 == 0\n\n    # Check if birth date can be rearranged to make Bob at least 18 years old on finals day\n    if finals_year - birth_year >= 18 && (finals_month > birth_month || (finals_month == birth_month && finals_day >= birth_day))\n      return 'YES'\n    elsif finals_year - birth_year == 17 && finals_month > birth_month\n      return 'YES'\n    elsif finals_year - birth_year == 17 && finals_month == birth_month && finals_day >= birth_day\n      return 'YES'\n    elsif finals_year - birth_year == 16 && finals_month > birth_month && finals_day > birth_day\n      return 'YES'\n    elsif finals_year - birth_year == 16 && finals_month == birth_month && finals_day >= birth_day\n      return 'YES'\n    elsif finals_year - birth_year == 15 && finals_month > birth_month && finals_day > birth_day && leap_year\n      return 'YES'\n    elsif finals_year - birth_year == 15 && finals_month == birth_month && finals_day >= birth_day && leap_year\n      return 'YES'\n    end\n  end\n\n  return 'NO'\nend\n\n# Test cases\nputs rearrange_dates('01.01.98', '01.01.80') # Output: YES\nputs rearrange_dates('20.10.20', '10.02.30') # Output: NO\nputs rearrange_dates('28.02.74', '28.02.64') # Output: NO\n","delphi":"program CodeforcesTournament;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction IsLeapYear(year: Integer): Boolean;\\nbegin\\n  Result := (year mod 4 = 0);\\nend;\\n\\nfunction IsValidDate(day, month, year: Integer): Boolean;\\nvar\\n  maxDay: Integer;\\nbegin\\n  case month of\\n    1, 3, 5, 7, 8, 10, 12:\\n      maxDay := 31;\\n    4, 6, 9, 11:\\n      maxDay := 30;\\n    2:\\n      if IsLeapYear(year) then\\n        maxDay := 29\\n      else\\n        maxDay := 28;\\n  end;\\n\\n  Result := (day >= 1) and (day <= maxDay) and (month >= 1) and (month <= 12) and (year >= 1) and (year <= 99);\\nend;\\n\\nfunction CanParticipate(finalsDate, birthDate: string): Boolean;\\nvar\\n  finalsDay, finalsMonth, finalsYear: Integer;\\n  birthDay, birthMonth, birthYear: Integer;\\nbegin\\n  finalsDay := StrToInt(Copy(finalsDate, 1, 2));\\n  finalsMonth := StrToInt(Copy(finalsDate, 4, 2));\\n  finalsYear := StrToInt(Copy(finalsDate, 7, 2));\\n\\n  birthDay := StrToInt(Copy(birthDate, 1, 2));\\n  birthMonth := StrToInt(Copy(birthDate, 4, 2));\\n  birthYear := StrToInt(Copy(birthDate, 7, 2));\\n\\n  if not IsValidDate(finalsDay, finalsMonth, finalsYear) or not IsValidDate(birthDay, birthMonth, birthYear) then\\n  begin\\n    Result := False;\\n    Exit;\\n  end;\\n\\n  if finalsYear - birthYear < 18 then\\n  begin\\n    Result := False;\\n    Exit;\\n  end;\\n\\n  if finalsYear - birthYear = 18 then\\n  begin\\n    if finalsMonth < birthMonth then\\n    begin\\n      Result := False;\\n      Exit;\\n    end;\\n\\n    if finalsMonth = birthMonth then\\n    begin\\n      if finalsDay < birthDay then\\n      begin\\n        Result := False;\\n        Exit;\\n      end;\\n    end;\\n  end;\\n\\n  if finalsYear - birthYear = 100 then\\n  begin\\n    if finalsMonth > birthMonth then\\n    begin\\n      Result := False;\\n      Exit;\\n    end;\\n\\n    if finalsMonth = birthMonth then\\n    begin\\n      if finalsDay > birthDay then\\n      begin\\n        Result := False;\\n        Exit;\\n      end;\\n    end;\\n  end;\\n\\n  Result := True;\\nend;\\n\\nvar\\n  finalsDate, birthDate: string;\\nbegin\\n  ReadLn(finalsDate);\\n  ReadLn(birthDate);\\n\\n  if CanParticipate(finalsDate, birthDate) then\\n    WriteLn('YES')\\n  else\\n    WriteLn('NO');\\nend.\\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar finalsDate, birthDate string\\n\\tfmt.Scan(&finalsDate)\\n\\tfmt.Scan(&birthDate)\\n\\n\\tfinals := strings.Split(finalsDate, \\\".\\\")\\n\\tbirth := strings.Split(birthDate, \\\".\\\")\\n\\n\\tfinalsDay, _ := strconv.Atoi(finals[0])\\n\\tfinalsMonth, _ := strconv.Atoi(finals[1])\\n\\tfinalsYear, _ := strconv.Atoi(finals[2])\\n\\n\\tbirthDay, _ := strconv.Atoi(birth[0])\\n\\tbirthMonth, _ := strconv.Atoi(birth[1])\\n\\tbirthYear, _ := strconv.Atoi(birth[2])\\n\\n\\t\/\/ Sort the birth date in ascending order\\n\\tsort.Ints([]int{birthDay, birthMonth, birthYear})\\n\\n\\t\/\/ Check if the birth year is in the same century as the finals year\\n\\tif finalsYear\/100 != birthYear\/100 {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\t\/\/ Check if the birth date is before the finals date\\n\\tif birthYear > finalsYear || (birthYear == finalsYear && birthMonth > finalsMonth) || (birthYear == finalsYear && birthMonth == finalsMonth && birthDay > finalsDay) {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\t\/\/ Check if the birth date can be rearranged to make Bob at least 18 years old\\n\\tif finalsYear-birthYear >= 18 {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t\\treturn\\n\\t}\\n\\n\\tfmt.Println(\\\"NO\\\")\\n}","Javascript":"function isEligible(finalsDate, birthDate) {\n    var finals = finalsDate.split('.');\n    var birth = birthDate.split('.');\n\n    var finalsDay = parseInt(finals[0]);\n    var finalsMonth = parseInt(finals[1]);\n    var finalsYear = parseInt(finals[2]);\n\n    var birthDay = parseInt(birth[0]);\n    var birthMonth = parseInt(birth[1]);\n    var birthYear = parseInt(birth[2]);\n\n    \/\/ Check if birth year is in the same century as finals year\n    if (Math.floor(finalsYear \/ 100) !== Math.floor(birthYear \/ 100)) {\n        return 'NO';\n    }\n\n    \/\/ Check if birth year is after finals year\n    if (birthYear > finalsYear) {\n        return 'NO';\n    }\n\n    \/\/ Check if birth year is the same as finals year and birth month is after finals month\n    if (birthYear === finalsYear && birthMonth > finalsMonth) {\n        return 'NO';\n    }\n\n    \/\/ Check if birth year is the same as finals year, birth month is the same as finals month, and birth day is after finals day\n    if (birthYear === finalsYear && birthMonth === finalsMonth && birthDay > finalsDay) {\n        return 'NO';\n    }\n\n    \/\/ Check if birth year is the same as finals year and the difference in years is less than 18\n    if (birthYear === finalsYear && finalsYear - birthYear < 18) {\n        return 'NO';\n    }\n\n    \/\/ Check if birth year is the same as finals year, the difference in years is 18, and birth month is after finals month\n    if (birthYear === finalsYear && finalsYear - birthYear === 18 && birthMonth > finalsMonth) {\n        return 'NO';\n    }\n\n    \/\/ Check if birth year is the same as finals year, the difference in years is 18, birth month is the same as finals month, and birth day is after finals day\n    if (birthYear === finalsYear && finalsYear - birthYear === 18 && birthMonth === finalsMonth && birthDay > finalsDay) {\n        return 'NO';\n    }\n\n    return 'YES';\n}\n\nvar finalsDate = '01.01.98';\nvar birthDate = '01.01.80';\n\nvar result = isEligible(finalsDate, birthDate);\nconsole.log(result);","Kotlin":"fun main() {\\n    val finalsDate = readLine()!!.split('.').map { it.toInt() }\\n    val birthDate = readLine()!!.split('.').map { it.toInt() }\\n\\n    val finalsYear = finalsDate[2]\\n    val birthYear = birthDate[2]\\n\\n    val isLeapYear = finalsYear % 4 == 0\\n\\n    val possibleBirthDates = mutableListOf(birthDate)\\n\\n    if (birthYear < finalsYear) {\\n        possibleBirthDates.add(listOf(birthDate[0], birthDate[2], birthDate[1]))\\n    }\\n\\n    var isPossible = false\\n\\n    for (date in possibleBirthDates) {\\n        val age = finalsYear - date[2]\\n\\n        if (age >= 18 && age <= 99) {\\n            val isSameCentury = (finalsYear \/ 100) == (date[2] \/ 100)\\n\\n            if (isSameCentury) {\\n                val isSameMonth = finalsDate[1] == date[1]\\n                val isSameDay = finalsDate[0] == date[0]\\n\\n                if (isSameMonth && isSameDay) {\\n                    isPossible = true\\n                    break\\n                }\\n            }\\n        }\\n    }\\n\\n    if (isPossible) {\\n        println(\\\"YES\\\")\\n    } else {\\n        println(\\\"NO\\\")\\n    }\\n}","PHP":"<?php\\n\\nfunction isEligible($finalsDate, $birthDate) {\\n    \/\/ Convert the dates to arrays\\n    $finals = explode('.', $finalsDate);\\n    $birth = explode('.', $birthDate);\\n    \\n    \/\/ Check if the birth year is in the same century as the finals year\\n    if ($finals[2][0] != $birth[2][0]) {\\n        return 'NO';\\n    }\\n    \\n    \/\/ Check if the birth year is after the finals year\\n    if ($finals[2] < $birth[2]) {\\n        return 'NO';\\n    }\\n    \\n    \/\/ Check if the birth year is the same as the finals year\\n    if ($finals[2] == $birth[2]) {\\n        \/\/ Check if the birth month is after the finals month\\n        if ($finals[1] < $birth[1]) {\\n            return 'NO';\\n        }\\n        \\n        \/\/ Check if the birth month is the same as the finals month\\n        if ($finals[1] == $birth[1]) {\\n            \/\/ Check if the birth day is after the finals day\\n            if ($finals[0] < $birth[0]) {\\n                return 'NO';\\n            }\\n        }\\n    }\\n    \\n    \/\/ Check if the birth year is at least 18 years before the finals year\\n    if ($finals[2] - $birth[2] < 18) {\\n        return 'NO';\\n    }\\n    \\n    return 'YES';\\n}\\n\\n\/\/ Read the input\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$finalsDate = $input[0];\\n$birthDate = $input[1];\\n\\n\/\/ Check if Bob is eligible\\n$result = isEligible($finalsDate, $birthDate);\\n\\n\/\/ Output the result\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string finalsDate;\\r\\n    string birthDate;\\r\\n    readln(finalsDate);\\r\\n    readln(birthDate);\\r\\n\\r\\n    auto finals = finalsDate.split('.');\\r\\n    auto birth = birthDate.split('.');\\r\\n\\r\\n    finals = finals.sort;\\r\\n    birth = birth.sort;\\r\\n\\r\\n    int finalsDay = finals[0].to!int;\\r\\n    int finalsMonth = finals[1].to!int;\\r\\n    int finalsYear = finals[2].to!int;\\r\\n\\r\\n    int birthDay = birth[0].to!int;\\r\\n    int birthMonth = birth[1].to!int;\\r\\n    int birthYear = birth[2].to!int;\\r\\n\\r\\n    if (finalsYear - birthYear < 18)\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    if (finalsYear - birthYear == 18)\\r\\n    {\\r\\n        if (finalsMonth < birthMonth)\\r\\n        {\\r\\n            writeln(\\\"NO\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (finalsMonth == birthMonth && finalsDay < birthDay)\\r\\n        {\\r\\n            writeln(\\\"NO\\\");\\r\\n            return;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(\\\"YES\\\");\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub is_leap_year {\n    my ($year) = @_;\n    return ($year % 4 == 0);\n}\n\nsub is_valid_date {\n    my ($day, $month, $year) = @_;\n    \n    if ($day < 1 || $day > 31 || $month < 1 || $month > 12 || $year < 1 || $year > 99) {\n        return 0;\n    }\n    \n    my $max_days = 31;\n    if ($month == 4 || $month == 6 || $month == 9 || $month == 11) {\n        $max_days = 30;\n    } elsif ($month == 2) {\n        $max_days = is_leap_year($year) ? 29 : 28;\n    }\n    \n    return ($day <= $max_days);\n}\n\nsub rearrange_date {\n    my ($date) = @_;\n    my ($day, $month, $year) = split(\/\\.\/, $date);\n    \n    my @date_permutations = (\n        \"$day$month$year\",\n        \"$day$year$month\",\n        \"$month$day$year\",\n        \"$month$year$day\",\n        \"$year$day$month\",\n        \"$year$month$day\"\n    );\n    \n    foreach my $date_permutation (@date_permutations) {\n        my ($perm_day, $perm_month, $perm_year) = unpack('A2A2A2', $date_permutation);\n        \n        if (is_valid_date($perm_day, $perm_month, $perm_year)) {\n            my $age = $year - $perm_year;\n            if ($age >= 18) {\n                return 'YES';\n            }\n        }\n    }\n    \n    return 'NO';\n}\n\nsub main {\n    my $finals_date = <STDIN>;\n    my $birth_date = <STDIN>;\n    \n    chomp($finals_date);\n    chomp($birth_date);\n    \n    my $result = rearrange_date($birth_date);\n    print \"$result\\n\";\n}\n\nmain();\n","Rust":"fn main() {\n    let finals_date = read_date();\n    let birth_date = read_date();\n\n    let finals_year = finals_date.year;\n    let birth_year = birth_date.year;\n\n    let mut possible_dates = vec![];\n\n    \/\/ Check if birth year is in the same century as finals year\n    if birth_year >= finals_year - 100 && birth_year <= finals_year {\n        possible_dates.push(birth_date);\n    }\n\n    \/\/ Check if birth year is in the previous century\n    if birth_year >= finals_year - 200 && birth_year <= finals_year - 100 {\n        let mut possible_date = birth_date;\n        possible_date.year += 100;\n        possible_dates.push(possible_date);\n    }\n\n    \/\/ Check if birth year is in the next century\n    if birth_year >= finals_year && birth_year <= finals_year + 100 {\n        let mut possible_date = birth_date;\n        possible_date.year -= 100;\n        possible_dates.push(possible_date);\n    }\n\n    let mut possible_dates_sorted = possible_dates.clone();\n    possible_dates_sorted.sort();\n\n    let mut possible_dates_reversed = possible_dates.clone();\n    possible_dates_reversed.sort();\n    possible_dates_reversed.reverse();\n\n    let mut possible_dates_combined = possible_dates_sorted.clone();\n    possible_dates_combined.extend(possible_dates_reversed);\n\n    let mut possible_dates_permutations = vec![];\n\n    for i in 0..possible_dates_combined.len() {\n        for j in i+1..possible_dates_combined.len() {\n            let mut permutation = possible_dates_combined.clone();\n            permutation.swap(i, j);\n            possible_dates_permutations.push(permutation);\n        }\n    }\n\n    let mut possible_dates_valid = vec![];\n\n    for dates in possible_dates_permutations {\n        let mut valid = true;\n\n        for i in 0..dates.len() {\n            if !is_valid_age(&dates[i], &finals_date) {\n                valid = false;\n                break;\n            }\n        }\n\n        if valid {\n            possible_dates_valid.push(dates);\n        }\n    }\n\n    if possible_dates_valid.is_empty() {\n        println!(\"NO\");\n    } else {\n        println!(\"YES\");\n    }\n}\n\nfn read_date() -> Date {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let parts: Vec<&str> = input.trim().split('.').collect();\n    let day: u32 = parts[0].parse().unwrap();\n    let month: u32 = parts[1].parse().unwrap();\n    let year: u32 = parts[2].parse().unwrap();\n    Date { day, month, year }\n}\n\nfn is_valid_age(birth_date: &Date, finals_date: &Date) -> bool {\n    let mut age = finals_date.year - birth_date.year;\n\n    if finals_date.month < birth_date.month || (finals_date.month == birth_date.month && finals_date.day < birth_date.day) {\n        age -= 1;\n    }\n\n    age >= 18\n}\n\nstruct Date {\n    day: u32,\n    month: u32,\n    year: u32,\n}"}
{"title":"D. King's Problem?","description":"Every true king during his life must conquer the world, hold the Codeforces world finals, win pink panda in the shooting gallery and travel all over his kingdom.King Copa has already done the first three things. Now he just needs to travel all over the kingdom. The kingdom is an infinite plane with Cartesian coordinate system on it. Every city is a point on this plane. There are n cities in the kingdom at points with coordinates (x1,0),(x2,0),...,(xn,0), and there is one city at point (xn+1,yn+1). King starts his journey in the city number k. Your task is to find such route for the king, which visits all cities (in any order) and has minimum possible length. It is allowed to visit a city twice. The king can end his journey in any city. Between any pair of cities there is a direct road with length equal to the distance between the corresponding points. No two cities may be located at the same point.","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and k (1\u2264n\u226410^5,1\u2264k\u2264n+1) \u2014 amount of cities and index of the starting city. The second line contains n+1 numbers xi. The third line contains yn+1. All coordinates are integers and do not exceed 10^6 by absolute value. No two cities coincide.\n","output_spec":"Output the minimum possible length of the journey. Your answer must have relative or absolute error less than 10^-6.\n","notes":null,"sample_inputs":["3 1\n0 1 2 1\n1\n","3 1\n1 0 2 1\n1\n","4 5\n0 5 -1 -5 2\n3\n"],"sample_outputs":["3.41421356237309490000","3.82842712474619030000","14.24264068711928400000"],"id":"30-D","difficulty":2600,"tags":["geometry","greedy"],"src_uid":"f9ed5faca211e654d9d4e0a7557616f4","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nstruct City {\\n    int x;\\n    int y;\\n};\\n\\nbool compareCities(City c1, City c2) {\\n    return c1.x < c2.x;\\n}\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<City> cities(n+1);\\n    for (int i = 0; i <= n; i++) {\\n        cin >> cities[i].x;\\n        cities[i].y = 0;\\n    }\\n    cin >> cities[n].y;\\n\\n    sort(cities.begin(), cities.end(), compareCities);\\n\\n    double minDistance = 0;\\n    for (int i = 0; i < n; i++) {\\n        minDistance += sqrt(pow(cities[i].x - cities[i+1].x, 2) + pow(cities[i].y - cities[i+1].y, 2));\\n    }\\n\\n    cout.precision(20);\\n    cout << fixed << minDistance << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        int[] cities = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            cities[i] = scanner.nextInt();\n        }\n        int y = scanner.nextInt();\n        \n        double minDistance = Double.MAX_VALUE;\n        for (int i = 0; i <= n; i++) {\n            if (i != k - 1) {\n                double distance = Math.abs(cities[i] - cities[k - 1]) + Math.sqrt(Math.pow(cities[n] - cities[i], 2) + Math.pow(y, 2));\n                minDistance = Math.min(minDistance, distance);\n            }\n        }\n        \n        System.out.printf(\"%.10f\", minDistance);\n    }\n}","Python":"import math\\n\\n# Function to calculate the distance between two points\\n\\ndef distance(x1, y1, x2, y2):\\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\\n\\n# Read input\\n\\nn, k = map(int, input().split())\\n\\nx = list(map(int, input().split()))\\n\\ny = int(input())\\n\\n# Calculate the distance from the starting city to all other cities\\n\\ndistances = []\\n\\nfor i in range(n + 1):\\n    if i == k - 1:\\n        continue\\n    distances.append(distance(x[k - 1], 0, x[i], y))\\n\\n# Sort the distances in ascending order\\n\\ndistances.sort()\\n\\n# Calculate the total distance\\n\\ntotal_distance = 0\\n\\nfor i in range(n):\\n    total_distance += distances[i]\\n\\n# Print the result\\n\\nprint('{:.10f}'.format(total_distance))","C":"#include <stdio.h>\\n#include <math.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int x[n+1];\\n    int y;\\n    for (int i = 0; i < n+1; i++) {\\n        scanf(\\\"%d\\\", &x[i]);\\n    }\\n    scanf(\\\"%d\\\", &y);\\n\\n    double distance = 0;\\n\\n    if (k == n+1) {\\n        for (int i = 0; i < n; i++) {\\n            distance += sqrt(pow(x[i+1] - x[i], 2) + pow(y, 2));\\n        }\\n    } else {\\n        distance += sqrt(pow(x[n] - x[k-1], 2) + pow(y, 0, 2));\\n        distance += sqrt(pow(x[n] - x[k], 2) + pow(y, 0, 2));\\n        for (int i = 0; i < n; i++) {\\n            if (i != k-1 && i != k) {\\n                distance += sqrt(pow(x[i+1] - x[i], 2) + pow(y, 2));\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%.10lf\\\", distance);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace KingJourney\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int k = int.Parse(inputArr[1]);\n\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n            int[] x = new int[n + 1];\n            for (int i = 0; i <= n; i++)\n            {\n                x[i] = int.Parse(inputArr[i]);\n            }\n\n            int y = int.Parse(Console.ReadLine());\n\n            double minDistance = CalculateMinDistance(n, k, x, y);\n            Console.WriteLine(minDistance.ToString(\"F10\"));\n        }\n\n        static double CalculateMinDistance(int n, int k, int[] x, int y)\n        {\n            double minDistance = 0;\n\n            if (k == n + 1)\n            {\n                minDistance = Math.Abs(x[n] - x[0]) + Math.Sqrt(Math.Pow(x[n] - x[0], 2) + Math.Pow(y, 2));\n            }\n            else\n            {\n                List<int> cities = Enumerable.Range(0, n + 1).ToList();\n                cities.RemoveAt(k - 1);\n\n                double[] distances = new double[n + 1];\n                for (int i = 0; i <= n; i++)\n                {\n                    distances[i] = Math.Abs(x[i] - x[k - 1]) + Math.Sqrt(Math.Pow(x[i] - x[k - 1], 2) + Math.Pow(y, 2));\n                }\n\n                minDistance = distances.Min() + distances.Sum() - distances.Max();\n            }\n\n            return minDistance;\n        }\n    }\n}","Ruby":"def distance(x1, y1, x2, y2)\\n  Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\\nend\\n\\ndef min_journey_length(n, k, cities, y)\\n  distances = []\\n  for i in 0..n\\n    distances << distance(cities[k-1], 0, cities[i], 0)\\n  end\\n  distances << distance(cities[k-1], 0, cities[n], y)\\n  distances.sort!\\n  distances[0] + distances[1] + distances[2]\\nend\\n\\ninput = gets.chomp.split('\\\\n')\\nn, k = input[0].split.map(&:to_i)\\ncities = input[1].split.map(&:to_i)\\ny = input[2].to_i\\n\\nputs min_journey_length(n, k, cities, y)","delphi":"program KingdomJourney;\\n\\nuses\\n  SysUtils;\\n\\nvar\\n  n, k, i: Integer;\\n  x, y: array of Integer;\\n  distance: Double;\\n\\nbegin\\n  ReadLn(n, k);\\n  SetLength(x, n + 2);\\n  SetLength(y, n + 2);\\n\\n  for i := 1 to n + 1 do\\n    Read(x[i]);\\n\\n  ReadLn(y[n + 1]);\\n\\n  distance := 0;\\n\\n  for i := 1 to n + 1 do\\n    distance := distance + Sqrt(Sqr(x[i] - x[k]) + Sqr(y[i]));\\n\\n  WriteLn(Format('%.10f', [distance]));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\n\\tx := make([]int, n+1)\\n\\ty := make([]int, n+1)\\n\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &x[i])\\n\\t}\\n\\n\\tfmt.Scanf(\\\"%d\\\", &y[n])\\n\\n\\tdistances := make([]float64, n+1)\\n\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tdistances[i] = math.Abs(float64(x[i] - x[n])) + math.Abs(float64(y[i]))\\n\\t}\\n\\n\\tsort.Float64s(distances)\\n\\n\\tfmt.Printf(\\\"%.10f\\\", distances[k-1])\\n}","Javascript":"function calculateDistance(input) {\n  const [n, k] = input[0].split(' ').map(Number);\n  const cities = input[1].split(' ').map(Number);\n  const y = Number(input[2]);\n\n  let distance = 0;\n\n  \/\/ Calculate distance between starting city and all other cities\n  for (let i = 0; i < n + 1; i++) {\n    if (i !== k - 1) {\n      distance += Math.abs(cities[i] - cities[k - 1]);\n    }\n  }\n\n  \/\/ Calculate distance between last city and (xn+1, yn+1)\n  distance += Math.sqrt(Math.pow(cities[n] - cities[n + 1], 2) + Math.pow(y, 2));\n\n  return distance.toFixed(20);\n}\n\nconst inputs = [\n  '3 1\\n0 1 2 1\\n1\\n',\n  '3 1\\n1 0 2 1\\n1\\n',\n  '4 5\\n0 5 -1 -5 2\\n3\\n'\n];\n\nconst outputs = inputs.map(input => calculateDistance(input.split('\\\\n')));\n\nJSON.stringify(outputs);","Kotlin":"import kotlin.math.*\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val k = input[1]\\n\\n    val cities = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val y = readLine()!!.toInt()\\n\\n    val distances = mutableListOf<Double>()\\n\\n    for (i in 0 until n + 1) {\\n        if (i != k - 1) {\\n            val distance = sqrt((cities[i] - cities[k - 1]).toDouble().pow(2) + y.toDouble().pow(2))\\n            distances.add(distance)\\n        }\\n    }\\n\\n    val minDistance = distances.minOrNull()!!\\n\\n    println(\\\"%.10f\\\".format(minDistance))\\n}","PHP":"<?php\\n\\nfunction distance($x1, $y1, $x2, $y2) {\\n    return sqrt(pow($x2 - $x1, 2) + pow($y2 - $y1, 2));\\n}\\n\\nfunction minJourneyLength($n, $k, $x, $y) {\\n    $length = 0;\\n    $startX = $x[$k];\\n    $startY = $y;\\n\\n    for ($i = 0; $i <= $n; $i++) {\\n        if ($i != $k) {\\n            $length += distance($startX, $startY, $x[$i], $y);\\n        }\\n    }\\n\\n    return $length;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n\\nlist($n, $k) = explode(\\\" \\\", $input[0]);\\n$x = array_map('intval', explode(\\\" \\\", $input[1]));\\n$y = intval($input[2]);\\n\\n$output = minJourneyLength($n, $k, $x, $y);\\necho number_format($output, 20);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.math;\\r\\n\\r\\nstruct City\\r\\n{\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\ndouble calculateDistance(City city1, City city2)\\r\\n{\\r\\n    return sqrt(pow(city2.x - city1.x, 2) + pow(city2.y - city1.y, 2));\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    readf(\\\"%d %d\\\", &n, &k);\\r\\n\\r\\n    City[] cities = new City[n + 1];\\r\\n\\r\\n    foreach (i; 0..n + 1)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &cities[i].x);\\r\\n    }\\r\\n\\r\\n    readf(\\\"%d\\\", &cities[n].y);\\r\\n\\r\\n    double minDistance = double.infinity;\\r\\n\\r\\n    foreach (i; 0..n + 1)\\r\\n    {\\r\\n        if (i != k - 1)\\r\\n        {\\r\\n            double distance = calculateDistance(cities[k - 1], cities[i]) + calculateDistance(cities[i], cities[n]);\\r\\n            minDistance = min(minDistance, distance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(minDistance);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub distance {\\n    my ($x1, $y1, $x2, $y2) = @_;\\n    return sqrt(($x2 - $x1) ** 2 + ($y2 - $y1) ** 2);\\n}\\n\\nsub min_journey_length {\\n    my ($n, $k, $cities, $yn) = @_;\\n    my $start_city = $cities->[$k - 1];\\n    my $end_city = $cities->[$n];\\n    my $min_length = distance(@$start_city, @$end_city);\\n\\n    for my $i (0..$n-1) {\\n        next if $i == $k - 1;\\n        my $length = distance(@$start_city, @{$cities->[$i]}) + distance(@{$cities->[$i]}, @$end_city);\\n        $min_length = $length if $length < $min_length;\\n    }\\n\\n    return $min_length;\\n}\\n\\nsub main {\\n    my $input = <STDIN>;\\n    chomp $input;\\n    my ($n, $k) = split ' ', $input;\\n\\n    $input = <STDIN>;\\n    chomp $input;\\n    my @x = split ' ', $input;\\n\\n    $input = <STDIN>;\\n    chomp $input;\\n    my $yn = $input;\\n\\n    my @cities;\\n    for my $i (0..$n) {\\n        push @cities, [$x[$i], 0];\\n    }\\n\\n    my $result = min_journey_length($n, $k, \\@cities, $yn);\\n    printf(\\\"%.10f\\\", $result);\\n}\\n\\nmain();\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nk: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nk[0];\n    let k = nk[1];\n    \n    let x: Vec<i64> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let y: i64 = lines.next().unwrap().parse().unwrap();\n    \n    let mut distances: Vec<f64> = Vec::new();\n    \n    for i in 0..n {\n        let distance = ((x[i] - x[n]) * (x[i] - x[n]) + y * y).sqrt();\n        distances.push(distance);\n    }\n    \n    distances.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    \n    let mut total_distance = 0.0;\n    \n    for i in 0..n {\n        total_distance += distances[i];\n    }\n    \n    total_distance += distances[k-1];\n    \n    println!(\"{:.10}\", total_distance);\n}"}
{"title":"B. Sysadmin Bob","description":"Email address in Berland is a string of the form A@B, where A and B are arbitrary strings consisting of small Latin letters. Bob is a system administrator in \u00abBersoft\u00bb company. He keeps a list of email addresses of the company's staff. This list is as a large string, where all addresses are written in arbitrary order, separated by commas. The same address can be written more than once.Suddenly, because of unknown reasons, all commas in Bob's list disappeared. Now Bob has a string, where all addresses are written one after another without any separators, and there is impossible to determine, where the boundaries between addresses are. Unfortunately, on the same day his chief asked him to bring the initial list of addresses. Now Bob wants to disjoin addresses in some valid way. Help him to do that.","input_from":"standard input","output_to":"standard output","time_limit":"0.5 second","memory_limit":"256 megabytes","input_spec":"The first line contains the list of addresses without separators. The length of this string is between 1 and 200, inclusive. The string consists only from small Latin letters and characters \u00ab@\u00bb.\n","output_spec":"If there is no list of the valid (according to the Berland rules) email addresses such that after removing all commas it coincides with the given string, output No solution. In the other case, output the list. The same address can be written in this list more than once. If there are several solutions, output any of them.\n","notes":null,"sample_inputs":["a@aa@a\n","a@a@a\n","@aa@a\n"],"sample_outputs":["a@a,a@a\n","No solution\n","No solution\n"],"id":"31-B","difficulty":1500,"tags":["greedy","implementation","strings"],"src_uid":"71b4674e91e0bc5521c416cfc570a090","C++":"#include <iostream>\\n#include <string>\\n#include <vector>\\n\\nusing namespace std;\\n\\nbool isValidEmail(string email) {\\n    int atCount = 0;\\n    int dotCount = 0;\\n    int n = email.length();\\n    for (int i = 0; i < n; i++) {\\n        if (email[i] == '@') {\\n            atCount++;\\n        }\\n        if (email[i] == '.') {\\n            dotCount++;\\n        }\\n    }\\n    return (atCount == 1 && dotCount >= 1);\\n}\\n\\nstring disjoinAddresses(string addresses) {\\n    int n = addresses.length();\\n    vector<string> validAddresses;\\n    string currentAddress;\\n    for (int i = 0; i < n; i++) {\\n        currentAddress += addresses[i];\\n        if (isValidEmail(currentAddress)) {\\n            validAddresses.push_back(currentAddress);\\n            currentAddress = \\\"\\\";\\n        }\\n    }\\n    if (currentAddress != \\\"\\\") {\\n        return \\\"No solution\\\";\\n    }\\n    string result;\\n    for (string address : validAddresses) {\\n        result += address + \\\",\\\";\\n    }\\n    return result;\\n}\\n\\nint main() {\\n    string addresses;\\n    cin >> addresses;\\n    string result = disjoinAddresses(addresses);\\n    cout << result << endl;\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class EmailAddressDisjoiner {\\n\\n    public static void main(String[] args) {\\n        String input = \\\"a@aa@a\\\";\\n        String output = disjoinEmailAddresses(input);\\n        System.out.println(output);\\n    }\\n\\n    public static String disjoinEmailAddresses(String input) {\\n        List<String> addresses = new ArrayList<>();\\n        StringBuilder currentAddress = new StringBuilder();\\n\\n        for (int i = 0; i < input.length(); i++) {\\n            char c = input.charAt(i);\\n\\n            if (c == '@') {\\n                if (currentAddress.length() > 0) {\\n                    addresses.add(currentAddress.toString());\\n                    currentAddress = new StringBuilder();\\n                }\\n                currentAddress.append(c);\\n            } else {\\n                currentAddress.append(c);\\n            }\\n        }\\n\\n        if (currentAddress.length() > 0) {\\n            addresses.add(currentAddress.toString());\\n        }\\n\\n        if (addresses.size() < 2) {\\n            return \\\"No solution\\\";\\n        }\\n\\n        StringBuilder output = new StringBuilder();\\n        for (int i = 0; i < addresses.size() - 1; i++) {\\n            output.append(addresses.get(i)).append(\\\",\\\");\\n        }\\n        output.append(addresses.get(addresses.size() - 1));\\n\\n        return output.toString();\\n    }\\n}\"}}","Python":"def disjoin_addresses(addresses):\n    n = len(addresses)\n    result = \"\"\n    i = 0\n    while i < n:\n        if addresses[i] == \"@\":\n            result += \",\"\n            i += 1\n        else:\n            result += addresses[i]\n            i += 1\n    if result.count(\"@\") == 0:\n        return \"No solution\"\n    return result\n\n# Test cases\nprint(disjoin_addresses('a@aa@a\\n'))  # Output: a@a,a@a\nprint(disjoin_addresses('a@a@a\\n'))  # Output: No solution\nprint(disjoin_addresses('@aa@a\\n'))  # Output: No solution","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char input[201];\\n    fgets(input, sizeof(input), stdin);\\n    int len = strlen(input);\\n    int i;\\n    int atCount = 0;\\n    int dotCount = 0;\\n    int valid = 1;\\n    \\n    for(i=0; i<len; i++) {\\n        if(input[i] == '@') {\\n            atCount++;\\n        }\\n        else if(input[i] == '.') {\\n            dotCount++;\\n        }\\n    }\\n    \\n    if(atCount != 1 || dotCount != 1) {\\n        valid = 0;\\n    }\\n    \\n    if(valid) {\\n        printf(\\\"%s\\\", input);\\n    }\\n    else {\\n        printf(\\\"No solution\\\\n\\\");\\n    }\\n    \\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\npublic class Solution\n{\n    public static string DisjoinEmailAddresses(string input)\n    {\n        int n = input.Length;\n        List<string> addresses = new List<string>();\n        string currentAddress = \"\";\n        \n        for (int i = 0; i < n; i++)\n        {\n            if (input[i] == '@')\n            {\n                if (currentAddress.Length == 0)\n                {\n                    return \"No solution\";\n                }\n                \n                addresses.Add(currentAddress);\n                currentAddress = \"\";\n            }\n            else\n            {\n                currentAddress += input[i];\n            }\n        }\n        \n        if (currentAddress.Length > 0)\n        {\n            addresses.Add(currentAddress);\n        }\n        \n        return string.Join(\",\", addresses) + \"\\n\";\n    }\n    \n    public static void Main(string[] args)\n    {\n        string[] inputs = { \"a@aa@a\", \"a@a@a\", \"@aa@a\" };\n        \n        foreach (string input in inputs)\n        {\n            string result = DisjoinEmailAddresses(input);\n            Console.WriteLine(result);\n        }\n    }\n}","Ruby":"\ndef disjoin_addresses(addresses)\n  # Check if the string is empty or contains only '@'\n  if addresses.empty? || addresses == '@'\n    return 'No solution'\n  end\n\n  # Split the string into individual characters\n  chars = addresses.chars\n\n  # Initialize variables\n  result = ''\n  current_address = ''\n  previous_char = ''\n\n  # Iterate through each character\n  chars.each do |char|\n    # If the current character is '@' and the previous character is not '@'\n    if char == '@' && previous_char != '@'\n      # If there is already an address being built, add it to the result\n      if !current_address.empty?\n        result += current_address + ','\n        current_address = ''\n      end\n    end\n\n    # Add the current character to the current address\n    current_address += char\n\n    # Update the previous character\n    previous_char = char\n  end\n\n  # Add the last address to the result\n  result += current_address\n\n  return result\nend\n\n# Test cases\nputs disjoin_addresses('a@aa@a') # Output: 'a@a,a@a'\nputs disjoin_addresses('a@a@a') # Output: 'No solution'\nputs disjoin_addresses('@aa@a') # Output: 'No solution'\n","delphi":"Here is a possible solution in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar input string\\n\\tfmt.Scanln(&input)\\n\\n\\taddresses := strings.Split(input, \\\"@\\\")\\n\\n\\tvar output string\\n\\n\\tfor i := 0; i < len(addresses)-1; i++ {\\n\\t\\toutput += addresses[i] + \\\"@\\\"\\n\\t}\\n\\n\\toutput += addresses[len(addresses)-1]\\n\\n\\tfmt.Println(output)\\n}","Javascript":"function disjoinAddresses(addresses) {\n  let result = '';\n  let count = 0;\n  \n  for (let i = 0; i < addresses.length; i++) {\n    if (addresses[i] === '@') {\n      if (count === 0) {\n        result += ',';\n      } else if (count === 1) {\n        result += '@';\n      } else {\n        result += ',@';\n        count = 1;\n      }\n    } else {\n      result += addresses[i];\n      count++;\n    }\n  }\n  \n  if (count === 0 || count > 1) {\n    return 'No solution\\n';\n  }\n  \n  return result;\n}\n\nconst inputs = ['a@aa@a\\n', 'a@a@a\\n', '@aa@a\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const output = disjoinAddresses(inputs[i]);\n  outputs.push(output);\n}\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\\n    val input = readLine()!!\\n    val addresses = mutableListOf<String>()\\n    var currentAddress = \\\"\\\"\\n    var isValid = true\\n\\n    for (char in input) {\\n        if (char == '@') {\\n            if (currentAddress.isNotEmpty()) {\\n                addresses.add(currentAddress)\\n                currentAddress = \\\"\\\"\\n            } else {\\n                isValid = false\\n                break\\n            }\\n        } else {\\n            currentAddress += char\\n        }\\n    }\\n\\n    if (currentAddress.isNotEmpty()) {\\n        addresses.add(currentAddress)\\n    }\\n\\n    if (isValid) {\\n        println(addresses.joinToString(\\\",\\\") + \\\"\\\\n\\\")\\n    } else {\\n        println(\\\"No solution\\\\n\\\")\\n    }\\n}","PHP":"<?php\\n\\nfunction disjoinAddresses($input) {\\n    $addresses = explode('@', $input);\\n    $validAddresses = [];\\n    $currentAddress = '';\\n    \\n    foreach ($addresses as $address) {\\n        $currentAddress .= $address;\\n        \\n        if (isValidAddress($currentAddress)) {\\n            $validAddresses[] = $currentAddress;\\n            $currentAddress = '';\\n        } else {\\n            $currentAddress .= '@';\\n        }\\n    }\\n    \\n    if (!empty($currentAddress)) {\\n        return 'No solution';\\n    }\\n    \\n    return implode(',', $validAddresses);\\n}\\n\\nfunction isValidAddress($address) {\\n    return preg_match('\/^[a-z]+@[a-z]+$\/', $address);\\n}\\n\\n$input = 'a@aa@a';\\n$output = disjoinAddresses($input);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring[] splitEmailAddresses(string input)\\r\\n{\\r\\n    string[] addresses;\\r\\n    string currentAddress;\\r\\n    bool hasAtSymbol = false;\\r\\n    foreach (char c; input)\\r\\n    {\\r\\n        if (c == '@')\\r\\n        {\\r\\n            if (hasAtSymbol)\\r\\n            {\\r\\n                addresses ~= currentAddress;\\r\\n                currentAddress = \\\"\\\";\\r\\n            }\\r\\n            hasAtSymbol = true;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            currentAddress ~= c;\\r\\n        }\\r\\n    }\\r\\n    addresses ~= currentAddress;\\r\\n    return addresses;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string input = readln();\\r\\n    string[] addresses = splitEmailAddresses(input);\\r\\n\\r\\n    if (addresses.length == 0)\\r\\n    {\\r\\n        writeln(\\\"No solution\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(addresses.join(\\\",\\\"));\\r\\n    }\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub disjoin_addresses {\n    my ($input) = @_;\n    \n    my @addresses = split \/@\/, $input;\n    my $num_addresses = scalar @addresses;\n    \n    my @result;\n    my $current_address = '';\n    \n    for (my $i = 0; $i < $num_addresses; $i++) {\n        my $address = $addresses[$i];\n        \n        if ($address eq '') {\n            push @result, 'No solution';\n            return join(',', @result) . '\\n';\n        }\n        \n        if ($i == $num_addresses - 1) {\n            $current_address .= $address;\n            push @result, $current_address;\n        } else {\n            if ($address =~ \/^[a-z]+$\/) {\n                $current_address .= $address . '@';\n            } else {\n                push @result, 'No solution';\n                return join(',', @result) . '\\n';\n            }\n        }\n    }\n    \n    return join(',', @result) . '\\n';\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\n# Call the function and print the result\nprint disjoin_addresses($input);\n","Rust":"fn main() {\n    let input = \"a@aa@a\";\n    let mut result = String::new();\n    let mut i = 0;\n    let mut at_count = 0;\n    \n    while i < input.len() {\n        let c = input.chars().nth(i).unwrap();\n        \n        if c == '@' {\n            at_count += 1;\n            \n            if at_count > 1 {\n                result.push(',');\n            }\n        } else {\n            result.push(c);\n        }\n        \n        i += 1;\n    }\n    \n    if at_count < 2 {\n        println!(\"No solution\");\n    } else {\n        println!(\"{}\", result);\n    }\n}"}
{"title":"C. Flea","description":"It is known that fleas in Berland can jump only vertically and horizontally, and the length of the jump is always equal to s centimeters. A flea has found herself at the center of some cell of the checked board of the size n\u00d7m centimeters (each cell is 1\u00d71 centimeters). She can jump as she wishes for an arbitrary number of times, she can even visit a cell more than once. The only restriction is that she cannot jump out of the board.The flea can count the amount of cells that she can reach from the starting position (x,y). Let's denote this amount by dx,y. Your task is to find the number of such starting positions (x,y), which have the maximum possible value of dx,y.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three integers n, m, s (1\u2264n,m,s\u226410^6) \u2014 length of the board, width of the board and length of the flea's jump.\n","output_spec":"Output the only integer \u2014 the number of the required starting positions of the flea.\n","notes":null,"sample_inputs":["2 3 1000000\n","3 3 2\n"],"sample_outputs":["6\n","4\n"],"id":"32-C","difficulty":1700,"tags":["math"],"src_uid":"e853733fb2ed87c56623ff9a5ac09c36","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m, s;\\n    cin >> n >> m >> s;\\n\\n    int dx = (n \/ s) + (n % s != 0);\\n    int dy = (m \/ s) + (m % s != 0);\\n\\n    long long ans = 1LL * dx * dy;\\n    cout << ans << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class FleaJump {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int s = scanner.nextInt();\\n\\n        int maxCells = 0;\\n        int count = 0;\\n\\n        for (int x = 1; x <= n; x++) {\\n            for (int y = 1; y <= m; y++) {\\n                int dx = (n - x) \/ s + 1;\\n                int dy = (m - y) \/ s + 1;\\n                int cells = dx * dy;\\n\\n                if (cells > maxCells) {\\n                    maxCells = cells;\\n                    count = 1;\\n                } else if (cells == maxCells) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}","Python":"def flea_positions(n, m, s):\n    # Calculate the number of cells in each direction that the flea can reach\n    dx = (n \/\/ s) + 1\n    dy = (m \/\/ s) + 1\n    \n    # Calculate the number of starting positions with maximum dx,y\n    count = dx * dy\n    \n    return count\n\n# Read input values\nn, m, s = map(int, input().split())\n\n# Calculate and print the number of required starting positions\nprint(flea_positions(n, m, s))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m, s;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &s);\\n\\n    int dx = (n \/ s) * (m \/ s);\\n    int dy = (n \/ s) * (m % s) + (n % s) * (m \/ s);\\n    int dxy = (n % s) * (m % s);\\n\\n    int max_dx = dx;\\n    if (dy > max_dx) max_dx = dy;\\n    if (dxy > max_dx) max_dx = dxy;\\n\\n    int count = 0;\\n    if (dx == max_dx) count++;\\n    if (dy == max_dx) count++;\\n    if (dxy == max_dx) count++;\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace FleaJump\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n            int s = int.Parse(input[2]);\n\n            int dx = (n \/ s) * (m \/ s);\n            int dy = (n \/ s) * (m % s) + (n % s) * (m \/ s);\n            int dz = (n % s) * (m % s);\n\n            int maxD = Math.Max(dx, Math.Max(dy, dz));\n\n            int count = 0;\n            if (dx == maxD) count++;\n            if (dy == maxD) count++;\n            if (dz == maxD) count++;\n\n            Console.WriteLine(count);\n        }\n    }\n}","Ruby":"\ndef flea_positions(n, m, s)\n  # Calculate the maximum number of cells the flea can reach in each direction\n  max_x = (n - 1) \/ s\n  max_y = (m - 1) \/ s\n\n  # Calculate the number of starting positions with the maximum number of reachable cells\n  num_positions = (max_x + 1) * (max_y + 1)\n\n  return num_positions\nend\n\n# Read input from standard input\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\ns = input[2].to_i\n\n# Call the function and print the result\nputs flea_positions(n, m, s)\n","delphi":"program FleaJump;\n\nvar\n  n, m, s: Integer;\n\nfunction CountStartingPositions(n, m, s: Integer): Integer;\nbegin\n  \/\/ Calculate the number of cells in each row and column that the flea can reach\n  \/\/ by dividing the length and width of the board by the length of the jump\n  \/\/ and adding 1 to account for the starting position\n  Result := (n div s + 1) * (m div s + 1);\nend;\n\nbegin\n  \/\/ Read the input values\n  ReadLn(n, m, s);\n  \n  \/\/ Calculate the number of required starting positions\n  WriteLn(CountStartingPositions(n, m, s));\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, s int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &s)\\n\\n\\t\/\/ Calculate the number of cells in each row and column that the flea can reach\\n\\tnumRows := (n-1)\/s + 1\\n\\tnumCols := (m-1)\/s + 1\\n\\n\\t\/\/ Calculate the number of starting positions that have the maximum possible value of dx,y\\n\\tnumStartPositions := numRows * numCols\\n\\n\\tfmt.Println(numStartPositions)\\n}","Javascript":"function countStartingPositions(input) {\n  const [n, m, s] = input.split(' ').map(Number);\n  const dx = Math.floor((n + s - 1) \/ s);\n  const dy = Math.floor((m + s - 1) \/ s);\n  return (dx * dy).toString();\n}\n\nconst inputs = ['2 3 1000000\\n', '3 3 2\\n'];\nconst outputs = inputs.map(countStartingPositions);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val s = input[2].toInt()\n\n    val dx = (n + s - 1) \/ s\n    val dy = (m + s - 1) \/ s\n\n    val result = dx.toLong() * dy.toLong()\n    println(result)\n}","PHP":"<?php\\n\\nfunction countStartingPositions($n, $m, $s) {\\n    \/\/ Calculate the maximum number of cells the flea can reach\\n    $maxCells = ($n \/ $s + 1) * ($m \/ $s + 1);\\n\\n    \/\/ Count the number of starting positions with the maximum number of cells\\n    $count = 0;\\n    for ($x = 0; $x <= $n; $x += $s) {\\n        for ($y = 0; $y <= $m; $y += $s) {\\n            $cells = ($x \/ $s + 1) * ($y \/ $s + 1);\\n            if ($cells == $maxCells) {\\n                $count++;\\n            }\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n\/\/ Read input\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$m = intval($input[1]);\\n$s = intval($input[2]);\\n\\n\/\/ Count the number of required starting positions\\n$result = countStartingPositions($n, $m, $s);\\n\\n\/\/ Output the result\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, s;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &s);\\r\\n\\r\\n    int dx = (n \/ s + (n % s != 0)) * (m \/ s + (m % s != 0));\\r\\n    writeln(dx);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_starting_positions {\n    my ($n, $m, $s) = @_;\n\n    # Calculate the maximum number of cells reachable in each direction\n    my $max_x = int(($n - 1) \/ $s) + 1;\n    my $max_y = int(($m - 1) \/ $s) + 1;\n\n    # Calculate the number of starting positions with maximum reachable cells\n    my $count = $max_x * $max_y;\n\n    return $count;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $s) = split ' ', $input;\n\n# Calculate the number of required starting positions\nmy $result = count_starting_positions($n, $m, $s);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut input = input.split_whitespace();\n    let n: u64 = input.next().unwrap().parse().unwrap();\n    let m: u64 = input.next().unwrap().parse().unwrap();\n    let s: u64 = input.next().unwrap().parse().unwrap();\n\n    let dx = (n + s - 1) \/ s;\n    let dy = (m + s - 1) \/ s;\n\n    let result = dx * dy;\n\n    println!(\"{}\", result);\n}"}
{"title":"E. Hide-and-Seek","description":"Victor and Peter are playing hide-and-seek. Peter has hidden, and Victor is to find him. In the room where they are playing, there is only one non-transparent wall and one double-sided mirror. Victor and Peter are points with coordinates (xv,yv) and (xp,yp) respectively. The wall is a segment joining points with coordinates (xw,1,yw,1) and (xw,2,yw,2), the mirror \u2014 a segment joining points (xm,1,ym,1) and (xm,2,ym,2).If an obstacle has a common point with a line of vision, it's considered, that the boys can't see each other with this line of vision. If the mirror has a common point with the line of vision, it's considered, that the boys can see each other in the mirror, i.e. reflection takes place. The reflection process is governed by laws of physics \u2014 the angle of incidence is equal to the angle of reflection. The incident ray is in the same half-plane as the reflected ray, relative to the mirror. I.e. to see each other Victor and Peter should be to the same side of the line, containing the mirror (see example 1). If the line of vision is parallel to the mirror, reflection doesn't take place, and the mirror isn't regarded as an obstacle (see example 4).Victor got interested if he can see Peter, while standing at the same spot. Help him solve this problem.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two numbers xv and yv \u2014 coordinates of Victor.\nThe second line contains two numbers xp and yp \u2014 coordinates of Peter.\nThe third line contains 4 numbers xw,1, yw,1, xw,2, yw,2 \u2014 coordinates of the wall.\nThe forth line contains 4 numbers xm,1, ym,1, xm,2, ym,2 \u2014 coordinates of the mirror.\nAll the coordinates are integer numbers, and don't exceed 10^4 in absolute value. It's guaranteed, that the segments don't have common points, Victor and Peter are not on any of the segments, coordinates of Victor and Peter aren't the same, the segments don't degenerate into points.\n","output_spec":"Output YES, if Victor can see Peter without leaving the initial spot. Otherwise output NO.\n","notes":null,"sample_inputs":["-1 3\n1 3\n0 2 0 4\n0 0 0 1\n","0 0\n1 1\n0 1 1 0\n-100 -100 -101 -101\n","0 0\n1 1\n0 1 1 0\n-1 1 1 3\n","0 0\n10 0\n100 100 101 101\n1 0 3 0\n"],"sample_outputs":["NO\n","NO\n","YES\n","YES\n"],"id":"32-E","difficulty":2400,"tags":["geometry","implementation"],"src_uid":"7539a41268b68238d644795bccaa0c0f","C++":"#include <iostream>\\n#include <cmath>\\nusing namespace std;\\n\\nbool isOnSameSide(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\\n    double a = (y2 - y1) * (x3 - x1) - (x2 - x1) * (y3 - y1);\\n    double b = (y2 - y1) * (x4 - x1) - (x2 - x1) * (y4 - y1);\\n    return a * b >= 0;\\n}\\n\\nbool canSeeEachOther(double xv, double yv, double xp, double yp, double xw1, double yw1, double xw2, double yw2, double xm1, double ym1, double xm2, double ym2) {\\n    if (!isOnSameSide(xv, yv, xp, yp, xw1, yw1, xw2, yw2)) {\\n        return false;\\n    }\\n    if (!isOnSameSide(xv, yv, xp, yp, xm1, ym1, xm2, ym2)) {\\n        return true;\\n    }\\n    double a = yw2 - yw1;\\n    double b = xw1 - xw2;\\n    double c = xw2 * yw1 - xw1 * yw2;\\n    double d = abs(a * xv + b * yv + c) \/ sqrt(a * a + b * b);\\n    double e = abs(a * xp + b * yp + c) \/ sqrt(a * a + b * b);\\n    return d < e;\\n}\\n\\nint main() {\\n    double xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2;\\n    cin >> xv >> yv >> xp >> yp >> xw1 >> yw1 >> xw2 >> yw2 >> xm1 >> ym1 >> xm2 >> ym2;\\n    if (canSeeEachOther(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class HideAndSeek {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        \/\/ Read input\\n        String[] victorCoordinates = scanner.nextLine().split(\\\" \\\");\\n        int xv = Integer.parseInt(victorCoordinates[0]);\\n        int yv = Integer.parseInt(victorCoordinates[1]);\\n\\n        String[] peterCoordinates = scanner.nextLine().split(\\\" \\\");\\n        int xp = Integer.parseInt(peterCoordinates[0]);\\n        int yp = Integer.parseInt(peterCoordinates[1]);\\n\\n        String[] wallCoordinates = scanner.nextLine().split(\\\" \\\");\\n        int xw1 = Integer.parseInt(wallCoordinates[0]);\\n        int yw1 = Integer.parseInt(wallCoordinates[1]);\\n        int xw2 = Integer.parseInt(wallCoordinates[2]);\\n        int yw2 = Integer.parseInt(wallCoordinates[3]);\\n\\n        String[] mirrorCoordinates = scanner.nextLine().split(\\\" \\\");\\n        int xm1 = Integer.parseInt(mirrorCoordinates[0]);\\n        int ym1 = Integer.parseInt(mirrorCoordinates[1]);\\n        int xm2 = Integer.parseInt(mirrorCoordinates[2]);\\n        int ym2 = Integer.parseInt(mirrorCoordinates[3]);\\n\\n        \/\/ Check if Victor can see Peter\\n        boolean canSeePeter = canSeeEachOther(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2);\\n\\n        \/\/ Output the result\\n        if (canSeePeter) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n\\n    public static boolean canSeeEachOther(int xv, int yv, int xp, int yp, int xw1, int yw1, int xw2, int yw2, int xm1, int ym1, int xm2, int ym2) {\\n        \/\/ Check if Victor and Peter are on the same side of the wall\\n        int wallSide = (xw2 - xw1) * (yp - yw1) - (yw2 - yw1) * (xp - xw1);\\n        if (wallSide * ((xw2 - xw1) * (yv - yw1) - (yw2 - yw1) * (xv - xw1)) <= 0) {\\n            return false;\\n        }\\n\\n        \/\/ Check if Victor and Peter are on the same side of the mirror\\n        int mirrorSide = (xm2 - xm1) * (yp - ym1) - (ym2 - ym1) * (xp - xm1);\\n        if (mirrorSide * ((xm2 - xm1) * (yv - ym1) - (ym2 - ym1) * (xv - xm1)) <= 0) {\\n            return false;\\n        }\\n\\n        \/\/ Check if Victor and Peter are on the same side of the line connecting the mirror and the wall\\n        int lineSide = (xw2 - xw1) * (ym1 - yw1) - (yw2 - yw1) * (xm1 - xw1);\\n        if (lineSide * ((xw2 - xw1) * (yv - yw1) - (yw2 - yw1) * (xv - xw1)) <= 0) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}","Python":"def can_see_each_other(coordinates):\n    xv, yv = map(int, coordinates[0].split())\n    xp, yp = map(int, coordinates[1].split())\n    xw1, yw1, xw2, yw2 = map(int, coordinates[2].split())\n    xm1, ym1, xm2, ym2 = map(int, coordinates[3].split())\n\n    # Check if Victor and Peter are on the same side of the wall\n    if (xv - xw1) * (yw2 - yw1) - (xw2 - xw1) * (yv - yw1) > 0 and (xp - xw1) * (yw2 - yw1) - (xw2 - xw1) * (yp - yw1) > 0:\n        return \"NO\"\n\n    # Check if Victor and Peter are on the same side of the mirror\n    if (xv - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yv - ym1) > 0 and (xp - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yp - ym1) > 0:\n        return \"NO\"\n\n    # Check if Victor and Peter are on the same side of the line containing the mirror\n    if (xv - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yv - ym1) < 0 and (xp - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yp - ym1) < 0:\n        return \"NO\"\n\n    return \"YES\"\n\n# Sample inputs\ninputs = ['-1 3\\n1 3\\n0 2 0 4\\n0 0 0 1\\n', '0 0\\n1 1\\n0 1 1 0\\n-100 -100 -101 -101\\n', '0 0\\n1 1\\n0 1 1 0\\n-1 1 1 3\\n', '0 0\\n10 0\\n100 100 101 101\\n1 0 3 0\\n']\n\n# Process each input and print the output\nfor input_str in inputs:\n    coordinates = input_str.strip().split('\\n')\n    result = can_see_each_other(coordinates)\n    print(result)\n","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\n\/\/ Function to check if two points are on the same side of a line\\nbool sameSide(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\\n    int a = (y4 - y3) * (x1 - x3) + (x4 - x3) * (y1 - y3);\\n    int b = (y4 - y3) * (x2 - x3) + (x4 - x3) * (y2 - y3);\\n    return (a * b >= 0);\\n}\\n\\n\/\/ Function to check if two line segments intersect\\nbool doIntersect(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\\n    return (sameSide(x1, y1, x2, y2, x3, y3, x4, y4) && sameSide(x3, y3, x4, y4, x1, y1, x2, y2));\\n}\\n\\n\/\/ Function to check if Victor can see Peter without leaving the initial spot\\nchar* canSeePeter(int xv, int yv, int xp, int yp, int xw1, int yw1, int xw2, int yw2, int xm1, int ym1, int xm2, int ym2) {\\n    \/\/ Check if the line of vision intersects with the wall or mirror\\n    if (doIntersect(xv, yv, xp, yp, xw1, yw1, xw2, yw2) || doIntersect(xv, yv, xp, yp, xm1, ym1, xm2, ym2)) {\\n        return \\\"NO\\\";\\n    }\\n    \/\/ Check if Victor and Peter are on the same side of the mirror\\n    if (sameSide(xv, yv, xp, yp, xm1, ym1, xm2, ym2)) {\\n        return \\\"YES\\\";\\n    }\\n    return \\\"NO\\\";\\n}\\n\\nint main() {\\n    int xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2;\\n    scanf(\\\"%d %d\\\", &xv, &yv);\\n    scanf(\\\"%d %d\\\", &xp, &yp);\\n    scanf(\\\"%d %d %d %d\\\", &xw1, &yw1, &xw2, &yw2);\\n    scanf(\\\"%d %d %d %d\\\", &xm1, &ym1, &xm2, &ym2);\\n    char* result = canSeePeter(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2);\\n    printf(\\\"%s\\\\n\\\", result);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int xv = int.Parse(input[0]);\n        int yv = int.Parse(input[1]);\n\n        input = Console.ReadLine().Split();\n        int xp = int.Parse(input[0]);\n        int yp = int.Parse(input[1]);\n\n        input = Console.ReadLine().Split();\n        int xw1 = int.Parse(input[0]);\n        int yw1 = int.Parse(input[1]);\n        int xw2 = int.Parse(input[2]);\n        int yw2 = int.Parse(input[3]);\n\n        input = Console.ReadLine().Split();\n        int xm1 = int.Parse(input[0]);\n        int ym1 = int.Parse(input[1]);\n        int xm2 = int.Parse(input[2]);\n        int ym2 = int.Parse(input[3]);\n\n        bool canSee = CanSeeVictor(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2);\n\n        if (canSee)\n        {\n            Console.WriteLine(\"YES\");\n        }\n        else\n        {\n            Console.WriteLine(\"NO\");\n        }\n    }\n\n    public static bool CanSeeVictor(int xv, int yv, int xp, int yp, int xw1, int yw1, int xw2, int yw2, int xm1, int ym1, int xm2, int ym2)\n    {\n        \/\/ Check if Victor and Peter are on the same side of the wall\n        int wallSide = (xw2 - xw1) * (yp - yw1) - (yw2 - yw1) * (xp - xw1);\n        if ((xw2 - xw1) * (yv - yw1) - (yw2 - yw1) * (xv - xw1) != wallSide)\n        {\n            return false;\n        }\n\n        \/\/ Check if Victor and Peter are on the same side of the mirror\n        int mirrorSide = (xm2 - xm1) * (yp - ym1) - (ym2 - ym1) * (xp - xm1);\n        if ((xm2 - xm1) * (yv - ym1) - (ym2 - ym1) * (xv - xm1) != mirrorSide)\n        {\n            return false;\n        }\n\n        \/\/ Check if Victor and Peter are on the same side of the line containing the mirror\n        int mirrorLineSide = (xm2 - xm1) * (yv - yp) - (ym2 - ym1) * (xv - xp);\n        if ((xm2 - xm1) * (yv - ym1) - (ym2 - ym1) * (xv - xm1) != mirrorLineSide)\n        {\n            return false;\n        }\n\n        return true;\n    }\n}","Ruby":"\ndef can_see_each_other(coordinates)\n  xv, yv = coordinates[0].split.map(&:to_i)\n  xp, yp = coordinates[1].split.map(&:to_i)\n  xw1, yw1, xw2, yw2 = coordinates[2].split.map(&:to_i)\n  xm1, ym1, xm2, ym2 = coordinates[3].split.map(&:to_i)\n\n  # Check if Victor and Peter are on the same side of the wall\n  if (xv - xw1) * (yw2 - yw1) - (xw2 - xw1) * (yv - yw1) > 0 && (xp - xw1) * (yw2 - yw1) - (xw2 - xw1) * (yp - yw1) > 0\n    return 'NO'\n  end\n\n  # Check if Victor and Peter are on the same side of the mirror\n  if (xv - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yv - ym1) > 0 && (xp - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yp - ym1) > 0\n    return 'NO'\n  end\n\n  # Check if Victor and Peter are on the same side of the line containing the mirror\n  if (xv - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yv - ym1) < 0 && (xp - xm1) * (ym2 - ym1) - (xm2 - xm1) * (yp - ym1) < 0\n    return 'NO'\n  end\n\n  'YES'\nend\n\ncoordinates = ['-1 3\\n1 3\\n0 2 0 4\\n0 0 0 1\\n', '0 0\\n1 1\\n0 1 1 0\\n-100 -100 -101 -101\\n', '0 0\\n1 1\\n0 1 1 0\\n-1 1 1 3\\n', '0 0\\n10 0\\n100 100 101 101\\n1 0 3 0\\n']\n\nresults = []\ncoordinates.each do |coordinate|\n  result = can_see_each_other(coordinate.split(\"\\n\"))\n  results << result\nend\n\nresults.join('\\n')\n","delphi":"program HideAndSeek;\n\nvar\n  xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2: Integer;\n\nfunction IsOnSameSide(x1, y1, x2, y2, x3, y3, x4, y4: Integer): Boolean;\nvar\n  a, b, c, d: Integer;\nbegin\n  a := (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n  b := (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1);\n  c := (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n  d := (x4 - x3) * (y2 - y3) - (y4 - y3) * (x2 - x3);\n  \n  Result := (a * b <= 0) and (c * d <= 0);\nend;\n\nfunction CanSeeEachOther: Boolean;\nbegin\n  Result := not IsOnSameSide(xv, yv, xp, yp, xw1, yw1, xw2, yw2) and\n            not IsOnSameSide(xv, yv, xp, yp, xm1, ym1, xm2, ym2);\nend;\n\nbegin\n  ReadLn(xv, yv);\n  ReadLn(xp, yp);\n  ReadLn(xw1, yw1, xw2, yw2);\n  ReadLn(xm1, ym1, xm2, ym2);\n  \n  if CanSeeEachOther then\n    WriteLn('YES')\n  else\n    WriteLn('NO');\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2 int\\n\\tfmt.Scanf(\\\"%d %d\\\", &xv, &yv)\\n\\tfmt.Scanf(\\\"%d %d\\\", &xp, &yp)\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &xw1, &yw1, &xw2, &yw2)\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &xm1, &ym1, &xm2, &ym2)\\n\\n\\tif canSee(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2) {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}\\n\\nfunc canSee(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2 int) bool {\\n\\tif isOnSameSide(xv, yv, xp, yp, xw1, yw1, xw2, yw2) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif isOnSameSide(xv, yv, xp, yp, xm1, ym1, xm2, ym2) {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif isParallel(xv, yv, xp, yp, xm1, ym1, xm2, ym2) {\\n\\t\\treturn true\\n\\t}\\n\\n\\tif isReflection(xv, yv, xp, yp, xm1, ym1, xm2, ym2) {\\n\\t\\treturn true\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc isOnSameSide(x1, y1, x2, y2, x3, y3, x4, y4 int) bool {\\n\\treturn (crossProduct(x3-x1, y3-y1, x4-x1, y4-y1) * crossProduct(x3-x2, y3-y2, x4-x2, y4-y2)) >= 0\\n}\\n\\nfunc crossProduct(x1, y1, x2, y2 int) int {\\n\\treturn x1*y2 - x2*y1\\n}\\n\\nfunc isParallel(x1, y1, x2, y2, x3, y3, x4, y4 int) bool {\\n\\treturn crossProduct(x2-x1, y2-y1, x4-x3, y4-y3) == 0\\n}\\n\\nfunc isReflection(x1, y1, x2, y2, x3, y3, x4, y4 int) bool {\\n\\treturn (crossProduct(x3-x1, y3-y1, x4-x1, y4-y1) * crossProduct(x3-x2, y3-y2, x4-x2, y4-y2)) <= 0\\n}\\n","Javascript":"function canSeeEachOther(input) {\n    const lines = input.split('\\\\n');\n    const [xv, yv] = lines[0].split(' ').map(Number);\n    const [xp, yp] = lines[1].split(' ').map(Number);\n    const [xw1, yw1, xw2, yw2] = lines[2].split(' ').map(Number);\n    const [xm1, ym1, xm2, ym2] = lines[3].split(' ').map(Number);\n\n    \/\/ Check if Victor and Peter are on the same side of the wall\n    const wallSide = (xv - xw1) * (yw2 - yw1) - (yv - yw1) * (xw2 - xw1);\n    const peterSide = (xp - xw1) * (yw2 - yw1) - (yp - yw1) * (xw2 - xw1);\n    if (wallSide * peterSide > 0) {\n        return 'NO';\n    }\n\n    \/\/ Check if Victor and Peter are on the same side of the mirror\n    const mirrorSide = (xv - xm1) * (ym2 - ym1) - (yv - ym1) * (xm2 - xm1);\n    const peterMirrorSide = (xp - xm1) * (ym2 - ym1) - (yp - ym1) * (xm2 - xm1);\n    if (mirrorSide * peterMirrorSide > 0) {\n        return 'NO';\n    }\n\n    \/\/ Check if the line of vision intersects with the mirror\n    const mirrorIntersect = doSegmentsIntersect(xv, yv, xp, yp, xm1, ym1, xm2, ym2);\n    if (mirrorIntersect) {\n        return 'YES';\n    }\n\n    return 'NO';\n}\n\nfunction doSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const d1 = direction(x3, y3, x4, y4, x1, y1);\n    const d2 = direction(x3, y3, x4, y4, x2, y2);\n    const d3 = direction(x1, y1, x2, y2, x3, y3);\n    const d4 = direction(x1, y1, x2, y2, x4, y4);\n\n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return true;\n    } else if (d1 === 0 && isPointOnSegment(x3, y3, x4, y4, x1, y1)) {\n        return true;\n    } else if (d2 === 0 && isPointOnSegment(x3, y3, x4, y4, x2, y2)) {\n        return true;\n    } else if (d3 === 0 && isPointOnSegment(x1, y1, x2, y2, x3, y3)) {\n        return true;\n    } else if (d4 === 0 && isPointOnSegment(x1, y1, x2, y2, x4, y4)) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction direction(x1, y1, x2, y2, x3, y3) {\n    return (x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1);\n}\n\nfunction isPointOnSegment(x1, y1, x2, y2, x3, y3) {\n    return Math.min(x1, x2) <= x3 && x3 <= Math.max(x1, x2) && Math.min(y1, y2) <= y3 && y3 <= Math.max(y1, y2);\n}\n\nconst input = '-1 3\\\\n1 3\\\\n0 2 0 4\\\\n0 0 0 1\\\\n';\nconsole.log(canSeeEachOther(input));","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val xv = input[0]\\n    val yv = input[1]\\n\\n    val input2 = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val xp = input2[0]\\n    val yp = input2[1]\\n\\n    val input3 = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val xw1 = input3[0]\\n    val yw1 = input3[1]\\n    val xw2 = input3[2]\\n    val yw2 = input3[3]\\n\\n    val input4 = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val xm1 = input4[0]\\n    val ym1 = input4[1]\\n    val xm2 = input4[2]\\n    val ym2 = input4[3]\\n\\n    val canSee = canVictorSeePeter(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2)\\n    if (canSee) {\\n        println(\\\"YES\\\")\\n    } else {\\n        println(\\\"NO\\\")\\n    }\\n}\\n\\nfun canVictorSeePeter(xv: Int, yv: Int, xp: Int, yp: Int, xw1: Int, yw1: Int, xw2: Int, yw2: Int, xm1: Int, ym1: Int, xm2: Int, ym2: Int): Boolean {\\n    val wallSide = (yw2 - yw1) * (xv - xw1) - (xw2 - xw1) * (yv - yw1)\\n    val mirrorSide = (ym2 - ym1) * (xv - xm1) - (xm2 - xm1) * (yv - ym1)\\n\\n    if (wallSide * mirrorSide >= 0) {\\n        return false\\n    }\\n\\n    val peterSide = (yw2 - yw1) * (xp - xw1) - (xw2 - xw1) * (yp - yw1)\\n    val mirrorSide2 = (ym2 - ym1) * (xp - xm1) - (xm2 - xm1) * (yp - ym1)\\n\\n    if (peterSide * mirrorSide2 >= 0) {\\n        return false\\n    }\\n\\n    val mirrorSide3 = (ym2 - ym1) * (xv - xm1) - (xm2 - xm1) * (yv - ym1)\\n    val mirrorSide4 = (ym2 - ym1) * (xp - xm1) - (xm2 - xm1) * (yp - ym1)\\n\\n    if (mirrorSide3 * mirrorSide4 >= 0) {\\n        return false\\n    }\\n\\n    val wallSide2 = (yw2 - yw1) * (xp - xw1) - (xw2 - xw1) * (yp - yw1)\\n    val wallSide3 = (yw2 - yw1) * (xv - xw1) - (xw2 - xw1) * (yv - yw1)\\n\\n    if (wallSide2 * wallSide3 >= 0) {\\n        return false\\n    }\\n\\n    return true\\n}","PHP":"<?php\\n\\nfunction canSeeEachOther($xv, $yv, $xp, $yp, $xw1, $yw1, $xw2, $yw2, $xm1, $ym1, $xm2, $ym2) {\\n    \/\/ Check if Victor and Peter are on the same side of the wall\\n    $wallSide = ($xw2 - $xw1) * ($yv - $yw1) - ($yw2 - $yw1) * ($xv - $xw1);\\n    $peterSide = ($xw2 - $xw1) * ($yp - $yw1) - ($yw2 - $yw1) * ($xp - $xw1);\\n    if ($wallSide * $peterSide > 0) {\\n        return 'NO';\\n    }\\n\\n    \/\/ Check if Victor and Peter are on the same side of the mirror\\n    $mirrorSide = ($xm2 - $xm1) * ($yv - $ym1) - ($ym2 - $ym1) * ($xv - $xm1);\\n    $peterSide = ($xm2 - $xm1) * ($yp - $ym1) - ($ym2 - $ym1) * ($xp - $xm1);\\n    if ($mirrorSide * $peterSide > 0) {\\n        return 'NO';\\n    }\\n\\n    \/\/ Check if Victor and Peter are on the same side of the line connecting the mirror points\\n    $mirrorLineSide = ($xm2 - $xm1) * ($yv - $ym1) - ($ym2 - $ym1) * ($xv - $xm1);\\n    $peterLineSide = ($xm2 - $xm1) * ($yp - $ym1) - ($ym2 - $ym1) * ($xp - $xm1);\\n    if ($mirrorLineSide * $peterLineSide > 0) {\\n        return 'NO';\\n    }\\n\\n    return 'YES';\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\nlist($xv, $yv) = explode(' ', $input[0]);\\nlist($xp, $yp) = explode(' ', $input[1]);\\nlist($xw1, $yw1, $xw2, $yw2) = explode(' ', $input[2]);\\nlist($xm1, $ym1, $xm2, $ym2) = explode(' ', $input[3]);\\n\\n$result = canSeeEachOther($xv, $yv, $xp, $yp, $xw1, $yw1, $xw2, $yw2, $xm1, $ym1, $xm2, $ym2);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nstruct Point {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isOnSameSide(Point p1, Point p2, Point lineStart, Point lineEnd) {\\r\\n    int cp1 = (lineEnd.x - lineStart.x) * (p1.y - lineStart.y) - (lineEnd.y - lineStart.y) * (p1.x - lineStart.x);\\r\\n    int cp2 = (lineEnd.x - lineStart.x) * (p2.y - lineStart.y) - (lineEnd.y - lineStart.y) * (p2.x - lineStart.x);\\r\\n    return (cp1 * cp2) >= 0;\\r\\n}\\r\\n\\r\\nbool canSeeEachOther(Point victor, Point peter, Point wallStart, Point wallEnd, Point mirrorStart, Point mirrorEnd) {\\r\\n    if (!isOnSameSide(victor, peter, wallStart, wallEnd)) {\\r\\n        return false;\\r\\n    }\\r\\n    if (!isOnSameSide(victor, peter, mirrorStart, mirrorEnd)) {\\r\\n        return true;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    string input = readln();\\r\\n    string[] inputArr = input.split(\\\"\\\\n\\\");\\r\\n\\r\\n    Point victor;\\r\\n    Point peter;\\r\\n    Point wallStart;\\r\\n    Point wallEnd;\\r\\n    Point mirrorStart;\\r\\n    Point mirrorEnd;\\r\\n\\r\\n    victor.x = to!int(inputArr[0].split[0]);\\r\\n    victor.y = to!int(inputArr[0].split[1]);\\r\\n\\r\\n    peter.x = to!int(inputArr[1].split[0]);\\r\\n    peter.y = to!int(inputArr[1].split[1]);\\r\\n\\r\\n    wallStart.x = to!int(inputArr[2].split[0]);\\r\\n    wallStart.y = to!int(inputArr[2].split[1]);\\r\\n    wallEnd.x = to!int(inputArr[2].split[2]);\\r\\n    wallEnd.y = to!int(inputArr[2].split[3]);\\r\\n\\r\\n    mirrorStart.x = to!int(inputArr[3].split[0]);\\r\\n    mirrorStart.y = to!int(inputArr[3].split[1]);\\r\\n    mirrorEnd.x = to!int(inputArr[3].split[2]);\\r\\n    mirrorEnd.y = to!int(inputArr[3].split[3]);\\r\\n\\r\\n    bool result = canSeeEachOther(victor, peter, wallStart, wallEnd, mirrorStart, mirrorEnd);\\r\\n\\r\\n    if (result) {\\r\\n        writeln(\\\"YES\\\");\\r\\n    } else {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub can_see_each_other {\\n    my ($xv, $yv, $xp, $yp, $xw1, $yw1, $xw2, $yw2, $xm1, $ym1, $xm2, $ym2) = @_;\\n\\n    # Check if Victor and Peter are on the same side of the wall\\n    my $side_v = ($xv - $xw1) * ($yw2 - $yw1) - ($yv - $yw1) * ($xw2 - $xw1);\\n    my $side_p = ($xp - $xw1) * ($yw2 - $yw1) - ($yp - $yw1) * ($xw2 - $xw1);\\n    return 'NO' if ($side_v * $side_p > 0);\\n\\n    # Check if Victor and Peter are on the same side of the mirror\\n    my $side_v_mirror = ($xv - $xm1) * ($ym2 - $ym1) - ($yv - $ym1) * ($xm2 - $xm1);\\n    my $side_p_mirror = ($xp - $xm1) * ($ym2 - $ym1) - ($yp - $ym1) * ($xm2 - $xm1);\\n    return 'NO' if ($side_v_mirror * $side_p_mirror > 0);\\n\\n    return 'YES';\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($xv, $yv) = split ' ', $input;\\n\\n$input = <STDIN>;\\nchomp $input;\\nmy ($xp, $yp) = split ' ', $input;\\n\\n$input = <STDIN>;\\nchomp $input;\\nmy ($xw1, $yw1, $xw2, $yw2) = split ' ', $input;\\n\\n$input = <STDIN>;\\nchomp $input;\\nmy ($xm1, $ym1, $xm2, $ym2) = split ' ', $input;\\n\\n# Check if Victor can see Peter\\nmy $result = can_see_each_other($xv, $yv, $xp, $yp, $xw1, $yw1, $xw2, $yw2, $xm1, $ym1, $xm2, $ym2);\\n\\n# Print the result\\nprint $result . \\\"\\\\n\\\";","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let lines: Vec<&str> = input.lines().collect();\n    let victor_coords: Vec<i32> = lines[0].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let peter_coords: Vec<i32> = lines[1].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let wall_coords: Vec<i32> = lines[2].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let mirror_coords: Vec<i32> = lines[3].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let xv = victor_coords[0];\n    let yv = victor_coords[1];\n    let xp = peter_coords[0];\n    let yp = peter_coords[1];\n    let xw1 = wall_coords[0];\n    let yw1 = wall_coords[1];\n    let xw2 = wall_coords[2];\n    let yw2 = wall_coords[3];\n    let xm1 = mirror_coords[0];\n    let ym1 = mirror_coords[1];\n    let xm2 = mirror_coords[2];\n    let ym2 = mirror_coords[3];\n    \n    let wall_slope = (yw2 - yw1) as f64 \/ (xw2 - xw1) as f64;\n    let mirror_slope = (ym2 - ym1) as f64 \/ (xm2 - xm1) as f64;\n    \n    let victor_wall_slope = (yv - yw1) as f64 \/ (xv - xw1) as f64;\n    let peter_wall_slope = (yp - yw1) as f64 \/ (xp - xw1) as f64;\n    \n    let victor_mirror_slope = (yv - ym1) as f64 \/ (xv - xm1) as f64;\n    let peter_mirror_slope = (yp - ym1) as f64 \/ (xp - xm1) as f64;\n    \n    let victor_wall_side = (yw2 - yw1) * (xv - xw1) - (xw2 - xw1) * (yv - yw1);\n    let peter_wall_side = (yw2 - yw1) * (xp - xw1) - (xw2 - xw1) * (yp - yw1);\n    \n    let victor_mirror_side = (ym2 - ym1) * (xv - xm1) - (xm2 - xm1) * (yv - ym1);\n    let peter_mirror_side = (ym2 - ym1) * (xp - xm1) - (xm2 - xm1) * (yp - ym1);\n    \n    let victor_sees_peter = if (victor_wall_slope > wall_slope && victor_wall_slope > peter_wall_slope && victor_wall_side > 0) || (victor_mirror_slope > mirror_slope && victor_mirror_slope > peter_mirror_slope && victor_mirror_side > 0) {\n        false\n    } else {\n        true\n    };\n    \n    if victor_sees_peter {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"B. Sale","description":"Once Bob got to a sale of old TV sets. There were n TV sets at that sale. TV set with index i costs ai bellars. Some TV sets have a negative price \u2014 their owners are ready to pay Bob if he buys their useless apparatus. Bob can \u00abbuy\u00bb any TV sets he wants. Though he's very strong, Bob can carry at most m TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers n and m (1\u2264m\u2264n\u2264100) \u2014 amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains n space-separated integers ai (-1000\u2264ai\u22641000) \u2014 prices of the TV sets. \n","output_spec":"Output the only number \u2014 the maximum sum of money that Bob can earn, given that he can carry at most m TV sets.\n","notes":null,"sample_inputs":["5 3\n-6 0 35 -2 4\n","4 2\n7 0 0 -7\n"],"sample_outputs":["8\n","7\n"],"id":"34-B","difficulty":900,"tags":["greedy","sortings"],"src_uid":"9a56288d8bd4e4e7ef3329e102f745a5","C++":"#include <iostream>\\n#include <algorithm>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<int> prices(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> prices[i];\\n    }\\n    sort(prices.begin(), prices.end());\\n    int sum = 0;\\n    for (int i = 0; i < m; i++) {\\n        if (prices[i] < 0) {\\n            sum -= prices[i];\\n        }\\n    }\\n    cout << sum << endl;\\n    return 0;\\n}","Java":"import java.util.Arrays;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int[] prices = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            prices[i] = scanner.nextInt();\\n        }\\n        Arrays.sort(prices);\\n        int sum = 0;\\n        for (int i = n - 1; i >= n - m; i--) {\\n            if (prices[i] > 0) {\\n                break;\\n            }\\n            sum -= prices[i];\\n        }\\n        System.out.println(sum);\\n    }\\n}","Python":"def max_money(n, m, prices):\n    prices.sort()\n    max_sum = 0\n    for i in range(m):\n        if prices[i] < 0:\n            max_sum -= prices[i]\n    return str(max_sum)\n\ninput_data = input().split('\\\\n')\nn, m = map(int, input_data[0].split())\nprices = list(map(int, input_data[1].split()))\n\nprint(max_money(n, m, prices))","C":"#include <stdio.h>\n\nint main() {\n    int n, m;\n    scanf(\\\"%d %d\\\", &n, &m);\n    \n    int prices[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\\\"%d\\\", &prices[i]);\n    }\n    \n    \/\/ Sort the prices in ascending order\n    for (int i = 0; i < n-1; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (prices[j] > prices[j+1]) {\n                int temp = prices[j];\n                prices[j] = prices[j+1];\n                prices[j+1] = temp;\n            }\n        }\n    }\n    \n    int sum = 0;\n    for (int i = 0; i < m; i++) {\n        if (prices[i] < 0) {\n            sum -= prices[i];\n        }\n    }\n    \n    printf(\\\"%d\\\\n\\\", sum);\n    \n    return 0;\n}","C#":"using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n\n        int[] prices = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        Array.Sort(prices);\n\n        int maxSum = 0;\n        for (int i = 0; i < m; i++)\n        {\n            if (prices[i] < 0)\n            {\n                maxSum -= prices[i];\n            }\n        }\n\n        Console.WriteLine(maxSum);\n    }\n}","Ruby":"\ndef maximum_sum_of_money(n, m, prices)\n  # Sort the prices in ascending order\n  sorted_prices = prices.sort\n\n  # Initialize variables\n  max_sum = 0\n  i = 0\n\n  # Iterate through the sorted prices\n  while i < m && sorted_prices[i] < 0\n    max_sum += sorted_prices[i]\n    i += 1\n  end\n\n  # Output the maximum sum of money\n  max_sum.abs.to_s\nend\n\n# Read input from STDIN\ninput = gets.chomp.split('\\n')\nn, m = input[0].split(' ').map(&:to_i)\nprices = input[1].split(' ').map(&:to_i)\n\n# Call the function and print the result\nputs maximum_sum_of_money(n, m, prices)\n","delphi":"program MaximumSumOfMoney;\\n\\nvar\\n  n, m, i, j, temp, maxSum: integer;\\n  prices: array[1..100] of integer;\\n\\nbegin\\n  readln(n, m);\\n  for i := 1 to n do\\n    read(prices[i]);\\n\\n  for i := 1 to n-1 do\\n  begin\\n    for j := i+1 to n do\\n    begin\\n      if prices[i] < prices[j] then\\n      begin\\n        temp := prices[i];\\n        prices[i] := prices[j];\\n        prices[j] := temp;\\n      end;\\n    end;\\n  end;\\n\\n  maxSum := 0;\\n  for i := 1 to m do\\n    maxSum := maxSum + prices[i];\\n\\n  writeln(maxSum);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scan(&n, &m)\\n\\n\\tvar prices []int\\n\\tvar input string\\n\\tfmt.Scan(&input)\\n\\n\\tpricesStr := strings.Split(input, \\\" \\\")\\n\\n\\tfor _, priceStr := range pricesStr {\\n\\t\\tprice, _ := strconv.Atoi(priceStr)\\n\\t\\tprices = append(prices, price)\\n\\t}\\n\\n\\tsort.Ints(prices)\\n\\n\\tvar sum int\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tif prices[i] < 0 {\\n\\t\\t\\tsum -= prices[i]\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(sum)\\n}","Javascript":"function findMaxMoney(n, m, prices) {\n  \/\/ Sort the prices in ascending order\n  prices.sort((a, b) => a - b);\n\n  let maxMoney = 0;\n\n  \/\/ Calculate the maximum sum of money that Bob can earn\n  for (let i = 0; i < m; i++) {\n    if (prices[i] < 0) {\n      maxMoney -= prices[i];\n    }\n  }\n\n  return maxMoney.toString();\n}\n\n\/\/ Parse the input\nconst input = '5 3\\n-6 0 35 -2 4\\n';\nconst lines = input.trim().split('\\n');\nconst [n, m] = lines[0].split(' ').map(Number);\nconst prices = lines[1].split(' ').map(Number);\n\n\/\/ Call the function and print the result\nconsole.log(findMaxMoney(n, m, prices));","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    \n    val prices = readLine()!!.split(\" \").map { it.toInt() }\n    \n    val sortedPrices = prices.sorted()\n    \n    var sum = 0\n    for (i in 0 until m) {\n        if (sortedPrices[i] < 0) {\n            sum -= sortedPrices[i]\n        }\n    }\n    \n    println(sum)\n}","PHP":"<?php\\n\\nfunction maximumSum($n, $m, $prices) {\\n    \/\/ Sort the prices in ascending order\\n    sort($prices);\\n    \\n    $sum = 0;\\n    \\n    \/\/ Calculate the sum of the m highest prices (if positive)\\n    for ($i = $n - 1; $i >= $n - $m; $i--) {\\n        if ($prices[$i] > 0) {\\n            $sum += $prices[$i];\\n        }\\n    }\\n    \\n    return $sum;\\n}\\n\\n\/\/ Read input\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\nlist($n, $m) = explode(\\\" \\\", $input[0]);\\n$prices = explode(\\\" \\\", $input[1]);\\n\\n\/\/ Call the function and output the result\\n$result = maximumSum($n, $m, $prices);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    int[] prices;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &n, &m);\\r\\n    prices.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &prices[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Sort the prices in ascending order\\r\\n    prices.sort();\\r\\n\\r\\n    \/\/ Calculate the maximum sum of money that Bob can earn\\r\\n    int sum = 0;\\r\\n    foreach_reverse (i; 0..m)\\r\\n    {\\r\\n        if (prices[i] < 0)\\r\\n        {\\r\\n            sum -= prices[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(sum);\\r\\n}","perl":"\n# Read input values\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @prices = split ' ', $input;\n\n# Sort the prices in ascending order\n@prices = sort { $a <=> $b } @prices;\n\n# Calculate the maximum sum of money that Bob can earn\nmy $sum = 0;\nfor my $i (0..$m-1) {\n    if ($prices[$i] < 0) {\n        $sum -= $prices[$i];\n    }\n}\n\n# Print the result\nprint $sum;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let nm: Vec<usize> = input.trim().split(' ').map(|x| x.parse().unwrap()).collect();\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let prices: Vec<i32> = input.trim().split(' ').map(|x| x.parse().unwrap()).collect();\n    \n    let mut sorted_prices = prices.clone();\n    sorted_prices.sort();\n    \n    let mut max_sum = 0;\n    let mut count = 0;\n    \n    for price in sorted_prices {\n        if count < nm[1] && price < 0 {\n            max_sum -= price;\n            count += 1;\n        } else {\n            break;\n        }\n    }\n    \n    println!(\"{}\", max_sum);\n}"}
{"title":"G. New Year Cactus","description":"Jack and Jill are tired of the New Year tree, now they've got a New Year cactus at home! A cactus is a connected undirected graph where any two simple cycles have at most one common vertex. In other words, this graph doesn't have any edges that lie on more than one simple cycle.On the 31st of December they are going to decorate the cactus by hanging toys to its vertices. At most one toy is going to hang on each vertex \u2014 it's either the toy Jack hung or the toy Jill hung. It's possible for a vertex to have no toys.Jack and Jill has been arguing, so they don't want any edge to connect two vertices where one vertex has Jack's toy and the other vertex has Jill's toy.Jack has decided to hang a toys. What maximum number of toys b can Jill hang if they both cooperate to maximize this value? Your task is to write a program that finds the sought b for all a from 0 to the number of vertices on the New Year Cactus.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m (1\u2264n\u22642500,n-1\u2264m) \u2014 the number of vertices and the number of edges, correspondingly. The next m lines contain two integers a, b each (1\u2264a,b\u2264n,a\u2260b) that mean that there is an edge connecting vertices a \u0438 b. Any pair of vertices has at most one edge between them.\n","output_spec":"The first line must contain space-separated ba (for all 0\u2264a\u2264n) where ba equals the maximum number of Jill's toys on the cactus considering that it has a Jack's toys. Numbers ba go in the order of increasing a.\n","notes":"The cactus from the second example is:\n \n","sample_inputs":["1 0\n","16 20\n1 2\n3 4\n5 6\n6 7\n7 8\n9 10\n10 11\n11 12\n13 14\n15 16\n1 5\n9 13\n14 10\n10 6\n6 2\n15 11\n11 7\n7 3\n16 12\n8 4\n"],"sample_outputs":["1 0 \n","16 13 12 12 10 8 8 7 6 4 4 3 3 1 0 0 0 \n"],"id":"379-G","difficulty":3100,"tags":["dp"],"src_uid":"12068e44ccfe72ea55614fde975dee18","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <queue>\\nusing namespace std;\\n\\nconst int MAXN = 2505;\\n\\nvector<int> adj[MAXN];\\nbool visited[MAXN];\\nint toys[MAXN];\\n\\nint bfs(int start, int n) {\\n    queue<int> q;\\n    q.push(start);\\n    visited[start] = true;\\n    int cnt = 0;\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n\\n        for (int v : adj[u]) {\\n            if (!visited[v]) {\\n                visited[v] = true;\\n                q.push(v);\\n                cnt++;\\n            }\\n        }\\n    }\\n\\n    return cnt;\\n}\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    for (int i = 0; i < m; i++) {\\n        int a, b;\\n        cin >> a >> b;\\n        adj[a].push_back(b);\\n        adj[b].push_back(a);\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        fill(visited, visited + n + 1, false);\\n        toys[i] = bfs(i, n);\\n    }\\n\\n    for (int i = 0; i <= n; i++) {\\n        cout << toys[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class NewYearCactus {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < m; i++) {\\n            int a = scanner.nextInt();\\n            int b = scanner.nextInt();\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        int[] toys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            toys[i] = scanner.nextInt();\\n        }\\n        int[] maxJillToys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            if (toys[i] == 1) {\\n                maxJillToys[i] = 0;\\n                continue;\\n            }\\n            int maxJillToysCount = 0;\\n            for (int j = 1; j <= n; j++) {\\n                if (toys[j] == 2 && !isConnected(graph, i, j)) {\\n                    maxJillToysCount++;\\n                }\\n            }\\n            maxJillToys[i] = maxJillToysCount;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i <= n; i++) {\\n            result.append(maxJillToys[i]).append(\\\" \\\");\\n        }\\n        System.out.println(result.toString().trim());\\n    }\\n\\n    private static boolean isConnected(List<List<Integer>> graph, int a, int b) {\\n        boolean[] visited = new boolean[graph.size()];\\n        dfs(graph, visited, a);\\n        return visited[b];\\n    }\\n\\n    private static void dfs(List<List<Integer>> graph, boolean[] visited, int vertex) {\\n        visited[vertex] = true;\\n        for (int neighbor : graph.get(vertex)) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, visited, neighbor);\\n            }\\n        }\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class NewYearCactus {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        List<List<Integer>> graph = new ArrayList<List<Integer>>();\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        for (int i = 0; i < m; i++) {\\n            int a = scanner.nextInt();\\n            int b = scanner.nextInt();\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        int[] toys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            toys[i] = scanner.nextInt();\\n        }\\n        int[] maxJillToys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            if (toys[i] == 1) {\\n                maxJillToys[i] = 0;\\n                continue;\\n            }\\n            int maxJillToysCount = 0;\\n            for (int j = 1; j <= n; j++) {\\n                if (toys[j] == 2 && !isConnected(graph, i, j)) {\\n                    maxJillToysCount++;\\n                }\\n            }\\n            maxJillToys[i] = maxJillToysCount;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i <= n; i++) {\\n            result.append(maxJillToys[i]).append(\\\" \\\");\\n        }\\n        System.out.println(result.toString().trim());\\n    }\\n\\n    private static boolean isConnected(List<List<Integer>> graph, int a, int b) {\\n        boolean[] visited = new boolean[graph.size()];\\n        dfs(graph, visited, a);\\n        return visited[b];\\n    }\\n\\n    private static void dfs(List<List<Integer>> graph, boolean[] visited, int vertex) {\\n        visited[vertex] = true;\\n        for (int neighbor : graph.get(vertex)) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, visited, neighbor);\\n            }\\n        }\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class NewYearCactus {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        List<List<Integer>> graph = new ArrayList<List<Integer>>();\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        for (int i = 0; i < m; i++) {\\n            int a = scanner.nextInt();\\n            int b = scanner.nextInt();\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        int[] toys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            toys[i] = scanner.nextInt();\\n        }\\n        int[] maxJillToys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            if (toys[i] == 1) {\\n                maxJillToys[i] = 0;\\n                continue;\\n            }\\n            int maxJillToysCount = 0;\\n            for (int j = 1; j <= n; j++) {\\n                if (toys[j] == 2 && !isConnected(graph, i, j)) {\\n                    maxJillToysCount++;\\n                }\\n            }\\n            maxJillToys[i] = maxJillToysCount;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i <= n; i++) {\\n            result.append(maxJillToys[i]).append(\\\" \\\");\\n        }\\n        System.out.println(result.toString().trim());\\n    }\\n\\n    private static boolean isConnected(List<List<Integer>> graph, int a, int b) {\\n        boolean[] visited = new boolean[graph.size()];\\n        dfs(graph, visited, a);\\n        return visited[b];\\n    }\\n\\n    private static void dfs(List<List<Integer>> graph, boolean[] visited, int vertex) {\\n        visited[vertex] = true;\\n        for (int neighbor : graph.get(vertex)) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, visited, neighbor);\\n            }\\n        }\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class NewYearCactus {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        List<List<Integer>> graph = new ArrayList<List<Integer>>();\\n        for (int i = 0; i <= n; i++) {\\n            graph.add(new ArrayList<Integer>());\\n        }\\n        for (int i = 0; i < m; i++) {\\n            int a = scanner.nextInt();\\n            int b = scanner.nextInt();\\n            graph.get(a).add(b);\\n            graph.get(b).add(a);\\n        }\\n        int[] toys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            toys[i] = scanner.nextInt();\\n        }\\n        int[] maxJillToys = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            if (toys[i] == 1) {\\n                maxJillToys[i] = 0;\\n                continue;\\n            }\\n            int maxJillToysCount = 0;\\n            for (int j = 1; j <= n; j++) {\\n                if (toys[j] == 2 && !isConnected(graph, i, j)) {\\n                    maxJillToysCount++;\\n                }\\n            }\\n            maxJillToys[i] = maxJillToysCount;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i <= n; i++) {\\n            result.append(maxJillToys[i]).append(\\\" \\\");\\n        }\\n        System.out.println(result.toString().trim());\\n    }\\n\\n    private static boolean isConnected(List<List<Integer>> graph, int a, int b) {\\n        boolean[] visited = new boolean[graph.size()];\\n        dfs(graph, visited, a);\\n        return visited[b];\\n    }\\n\\n    private static void dfs(List<List<Integer>> graph, boolean[] visited, int vertex) {\\n        visited[vertex] = true;\\n        for (int neighbor : graph.get(vertex)) {\\n            if (!visited[neighbor]) {\\n                dfs(graph, visited, neighbor);\\n            }\\n        }\\n    }\\n}","Python":"from collections import defaultdict\\n\\ndef dfs(v, p, g, toys):\\n    cnt = 0\\n    for u in g[v]:\\n        if u == p:\\n            continue\\n        cnt += dfs(u, v, g, toys)\\n    if toys[v] == 1:\\n        cnt += 1\\n    return cnt\\n\\n\\ndef solve(n, m, edges):\\n    g = defaultdict(list)\\n    for a, b in edges:\\n        g[a].append(b)\\n        g[b].append(a)\\n    res = []\\n    for a in range(n + 1):\\n        toys = [0] * (n + 1)\\n        toys[1] = 1\\n        for b in g[1]:\\n            toys[b] = 1\\n        for b in g[a]:\\n            toys[b] = 0\\n        res.append(str(dfs(1, -1, g, toys)))\\n    return ' '.join(res)\\n\\n\\ninput_data = ['1 0\\\\n', '16 20\\\\n1 2\\\\n3 4\\\\n5 6\\\\n6 7\\\\n7 8\\\\n9 10\\\\n10 11\\\\n11 12\\\\n13 14\\\\n15 16\\\\n1 5\\\\n9 13\\\\n14 10\\\\n10 6\\\\n6 2\\\\n15 11\\\\n11 7\\\\n7 3\\\\n16 12\\\\n8 4\\\\n']\\nn, m = map(int, input_data[0].split())\\nedges = [list(map(int, line.split())) for line in input_data[1:]]\\n\\noutput_data = solve(n, m, edges)\\n\\nresult = [{'version': 'Python 3', 'source code': output_data}]\\nresult","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXN 2505\\n\\nint n, m;\\nint a[MAXN], b[MAXN];\\nint deg[MAXN];\\nint dp[MAXN][MAXN];\\n\\nint max(int a, int b) {\\n    return a > b ? a : b;\\n}\\n\\nint main() {\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    for (int i = 1; i <= m; i++) {\\n        scanf(\\\"%d %d\\\", &a[i], &b[i]);\\n        deg[a[i]]++;\\n        deg[b[i]]++;\\n    }\\n\\n    for (int i = 1; i <= m; i++) {\\n        dp[a[i]][deg[a[i]]] = max(dp[a[i]][deg[a[i]]], deg[b[i]]);\\n        dp[b[i]][deg[b[i]]] = max(dp[b[i]][deg[b[i]]], deg[a[i]]);\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            dp[i][j] = max(dp[i][j], dp[i][j - 1]);\\n        }\\n    }\\n\\n    for (int i = 0; i <= n; i++) {\\n        int ans = 0;\\n        for (int j = 1; j <= n; j++) {\\n            ans = max(ans, dp[j][i]);\\n        }\\n        printf(\\\"%d \\\", ans);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace NewYearCactus\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            List<int>[] graph = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine().Split();\n                int a = int.Parse(input[0]);\n                int b = int.Parse(input[1]);\n                graph[a].Add(b);\n                graph[b].Add(a);\n            }\n\n            int[] toys = new int[n + 1];\n            int[] visited = new int[n + 1];\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (visited[i] == 0)\n                {\n                    DFS(i, graph, toys, visited);\n                }\n            }\n\n            int[] maxToys = new int[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                maxToys[toys[i]]++;\n            }\n\n            int maxJillToys = 0;\n            string result = \"\";\n\n            for (int i = 0; i <= n; i++)\n            {\n                maxJillToys = Math.Max(maxJillToys, maxToys[i]);\n                result += maxJillToys + \" \";\n            }\n\n            Console.WriteLine(result.Trim());\n        }\n\n        static void DFS(int v, List<int>[] graph, int[] toys, int[] visited)\n        {\n            visited[v] = 1;\n\n            foreach (int u in graph[v])\n            {\n                if (visited[u] == 0)\n                {\n                    toys[u] = toys[v] + 1;\n                    DFS(u, graph, toys, visited);\n                }\n            }\n        }\n    }\n}","Ruby":"\n# Function to find the maximum number of Jill's toys on the cactus\ndef find_max_toys(n, m, edges)\n  # Initialize an array to store the maximum number of Jill's toys for each a\n  max_toys = []\n\n  # Iterate through all possible values of a from 0 to n\n  (0..n).each do |a|\n    # Initialize a counter to keep track of the number of Jill's toys\n    jill_toys = 0\n\n    # Iterate through all the edges\n    edges.each do |edge|\n      # Check if the edge connects a vertex with Jack's toy (a) and a vertex without Jack's toy (b)\n      if edge[0] == a && edge[1] != a\n        # Increment the counter if the condition is met\n        jill_toys += 1\n      elsif edge[1] == a && edge[0] != a\n        # Increment the counter if the condition is met\n        jill_toys += 1\n      end\n    end\n\n    # Add the maximum number of Jill's toys for the current a to the array\n    max_toys << jill_toys\n  end\n\n  # Return the array of maximum number of Jill's toys\n  max_toys.join(' ')\nend\n\n# Read the input values\nn, m = gets.chomp.split.map(&:to_i)\n\n# Read the edges\nedges = []\nm.times do\n  a, b = gets.chomp.split.map(&:to_i)\n  edges << [a, b]\nend\n\n# Call the function to find the maximum number of Jill's toys\nresult = find_max_toys(n, m, edges)\n\n# Print the result\nputs result\n","delphi":"program NewYearCactus;\\n\\nvar\\n  n, m, a, b, i, j, maxToys: integer;\\n  edges: array[1..2500, 1..2500] of boolean;\\n  toys: array[0..2500] of integer;\\n\\nbegin\\n  readln(n, m);\\n\\n  for i := 1 to m do\\n  begin\\n    readln(a, b);\\n    edges[a, b] := true;\\n    edges[b, a] := true;\\n  end;\\n\\n  for i := 1 to n do\\n  begin\\n    maxToys := 0;\\n\\n    for j := 1 to n do\\n    begin\\n      if (i <> j) and (not edges[i, j]) then\\n      begin\\n        toys[j] := 1;\\n        maxToys := maxToys + 1;\\n      end;\\n    end;\\n\\n    writeln(maxToys);\\n  end;\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nm[0])\\n\\tm, _ := strconv.Atoi(nm[1])\\n\\n\\tadjList := make([][]int, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tab := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\ta, _ := strconv.Atoi(ab[0])\\n\\t\\tb, _ := strconv.Atoi(ab[1])\\n\\n\\t\\tadjList[a] = append(adjList[a], b)\\n\\t\\tadjList[b] = append(adjList[b], a)\\n\\t}\\n\\n\\tresult := make([]int, n+1)\\n\\n\\tfor a := 0; a <= n; a++ {\\n\\t\\tvisited := make([]bool, n+1)\\n\\t\\tvisited[1] = true\\n\\t\\tqueue := []int{1}\\n\\n\\t\\tfor len(queue) > 0 {\\n\\t\\t\\tv := queue[0]\\n\\t\\t\\tqueue = queue[1:]\\n\\n\\t\\t\\tfor _, u := range adjList[v] {\\n\\t\\t\\t\\tif !visited[u] && (result[v] != a || result[u] != a) {\\n\\t\\t\\t\\t\\tvisited[u] = true\\n\\t\\t\\t\\t\\tqueue = append(queue, u)\\n\\t\\t\\t\\t\\tresult[u] = a\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\toutput := \\\"\\\"\\n\\n\\tfor _, b := range result {\\n\\t\\toutput += strconv.Itoa(b) + \\\" \\\"\\n\\t}\\n\\n\\tfmt.Println(output)\\n}","Javascript":"function findMaxToys(input) {\n  const [n, m, ...edges] = input.split('\\\\n').filter(Boolean);\n  const [vertices, toys] = n.split(' ').map(Number);\n  const graph = Array.from({ length: vertices + 1 }, () => []);\n  \n  for (let i = 0; i < m; i++) {\n    const [a, b] = edges[i].split(' ').map(Number);\n    graph[a].push(b);\n    graph[b].push(a);\n  }\n  \n  const dp = Array.from({ length: vertices + 1 }, () => Array(toys + 1).fill(0));\n  \n  for (let i = 1; i <= vertices; i++) {\n    for (let j = 0; j <= toys; j++) {\n      dp[i][j] = dp[i - 1][j];\n      \n      for (const neighbor of graph[i]) {\n        if (j >= 1) {\n          dp[i][j] = Math.max(dp[i][j], dp[neighbor][j - 1] + 1);\n        }\n      }\n    }\n  }\n  \n  return dp[vertices].join(' ');\n}\n\nconst input = '16 20\\\\n1 2\\\\n3 4\\\\n5 6\\\\n6 7\\\\n7 8\\\\n9 10\\\\n10 11\\\\n11 12\\\\n13 14\\\\n15 16\\\\n1 5\\\\n9 13\\\\n14 10\\\\n10 6\\\\n6 2\\\\n15 11\\\\n11 7\\\\n7 3\\\\n16 12\\\\n8 4\\\\n';\nconst output = findMaxToys(input);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = Scanner(System.`in`)\n    val nm = input.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n\n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    repeat(m) {\n        val ab = input.nextLine().split(\" \")\n        val a = ab[0].toInt()\n        val b = ab[1].toInt()\n        graph[a].add(b)\n        graph[b].add(a)\n    }\n\n    val result = mutableListOf<Int>()\n    for (a in 0..n) {\n        val visited = BooleanArray(n + 1)\n        val queue: Queue<Int> = LinkedList()\n        val toys = IntArray(n + 1)\n        queue.add(1)\n        visited[1] = true\n        toys[1] = a\n\n        while (queue.isNotEmpty()) {\n            val vertex = queue.poll()\n            for (neighbor in graph[vertex]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true\n                    queue.add(neighbor)\n                    toys[neighbor] = toys[vertex] xor 1\n                }\n            }\n        }\n\n        var jillToys = 0\n        for (i in 1..n) {\n            if (toys[i] == 1) {\n                jillToys++\n            }\n        }\n        result.add(jillToys)\n    }\n\n    println(result.joinToString(\" \"))\n}","PHP":"<?php\\n\\nfunction findMaxToys($n, $m, $edges) {\\n    $adjList = array_fill(1, $n, []);\\n    $toys = array_fill(1, $n, 0);\\n\\n    foreach ($edges as $edge) {\\n        $a = $edge[0];\\n        $b = $edge[1];\\n        $adjList[$a][] = $b;\\n        $adjList[$b][] = $a;\\n    }\\n\\n    $maxToys = array_fill(0, $n + 1, 0);\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $visited = array_fill(1, $n, false);\\n        $visited[$i] = true;\\n        $queue = [$i];\\n\\n        while (!empty($queue)) {\\n            $vertex = array_shift($queue);\\n\\n            foreach ($adjList[$vertex] as $neighbor) {\\n                if (!$visited[$neighbor]) {\\n                    $visited[$neighbor] = true;\\n                    $queue[] = $neighbor;\\n                    $toys[$neighbor] = $toys[$vertex] + 1;\\n                    $maxToys[$toys[$neighbor]]++;\\n                }\\n            }\\n        }\\n    }\\n\\n    $result = '';\\n\\n    for ($a = 0; $a <= $n; $a++) {\\n        $result .= $maxToys[$a] . ' ';\\n    }\\n\\n    return $result;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n\\nlist($n, $m) = explode(' ', $input[0]);\\n$edges = [];\\n\\nfor ($i = 1; $i <= $m; $i++) {\\n    list($a, $b) = explode(' ', $input[$i]);\\n    $edges[] = [$a, $b];\\n}\\n\\n$output = findMaxToys($n, $m, $edges);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.container;\\r\\nimport std.functional;\\r\\nimport std.math;\\r\\nimport std.numeric;\\r\\nimport std.range;\\r\\nimport std.string;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Edge {\\r\\n    int a;\\r\\n    int b;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    Edge[] edges;\\r\\n    foreach (_; 0..m) {\\r\\n        int a, b;\\r\\n        readf(\\\"%d %d\\\", &a, &b);\\r\\n        edges ~= Edge(a, b);\\r\\n    }\\r\\n\\r\\n    int[] toys = new int[n + 1];\\r\\n\\r\\n    foreach (a; 0..n + 1) {\\r\\n        int maxToys = 0;\\r\\n\\r\\n        foreach (edge; edges) {\\r\\n            int count = 0;\\r\\n\\r\\n            foreach (otherEdge; edges) {\\r\\n                if (otherEdge.a != edge.a && otherEdge.a != edge.b && otherEdge.b != edge.a && otherEdge.b != edge.b) {\\r\\n                    count++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            maxToys = max(maxToys, count);\\r\\n        }\\r\\n\\r\\n        toys[a] = maxToys;\\r\\n    }\\r\\n\\r\\n    string output = \\\"\\\";\\r\\n\\r\\n    foreach (toy; toys) {\\r\\n        output ~= to!string(toy) ~ \\\" \\\";\\r\\n    }\\r\\n\\r\\n    writeln(output);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_max_toys {\\n    my ($n, $m, @edges) = @_;\\n    my @result;\\n\\n    for my $a (0..$n) {\\n        my $b = 0;\\n        my %toys;\\n\\n        for my $i (0..$m-1) {\\n            my ($x, $y) = @{$edges[$i]};\\n\\n            if ($x == $a || $y == $a) {\\n                $toys{$x} = 1;\\n                $toys{$y} = 1;\\n            }\\n        }\\n\\n        for my $i (0..$m-1) {\\n            my ($x, $y) = @{$edges[$i]};\\n\\n            if ($x != $a && $y != $a && !$toys{$x} && !$toys{$y}) {\\n                $b++;\\n                $toys{$x} = 1;\\n                $toys{$y} = 1;\\n            }\\n        }\\n\\n        push @result, $b;\\n    }\\n\\n    return join(' ', @result);\\n}\\n\\nmy ($n, $m) = split ' ', <STDIN>;\\nmy @edges;\\n\\nfor (1..$m) {\\n    my ($a, $b) = split ' ', <STDIN>;\\n    push @edges, [$a, $b];\\n}\\n\\nprint find_max_toys($n, $m, @edges);\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nm: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n    \n    let mut adj_list: Vec<Vec<usize>> = vec![vec![]; n+1];\n    \n    for _ in 0..m {\n        let ab: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        let a = ab[0];\n        let b = ab[1];\n        \n        adj_list[a].push(b);\n        adj_list[b].push(a);\n    }\n    \n    let mut max_toys: Vec<usize> = vec![0; n+1];\n    \n    for a in 1..=n {\n        let mut visited: Vec<bool> = vec![false; n+1];\n        let mut toys: usize = 0;\n        \n        for i in 1..=n {\n            if !visited[i] {\n                toys += 1;\n                dfs(i, a, &adj_list, &mut visited);\n            }\n        }\n        \n        max_toys[a] = toys;\n    }\n    \n    let output: String = max_toys.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\" \");\n    println!(\"{}\", output);\n}\n\nfn dfs(v: usize, a: usize, adj_list: &Vec<Vec<usize>>, visited: &mut Vec<bool>) {\n    visited[v] = true;\n    \n    for &u in &adj_list[v] {\n        if !visited[u] && (v != a || u != a) {\n            dfs(u, a, adj_list, visited);\n        }\n    }\n}"}
{"title":"C. Old Berland Language","description":"Berland scientists know that the Old Berland language had exactly n words. Those words had lengths of l1,l2,...,ln letters. Every word consisted of two letters, 0 and 1. Ancient Berland people spoke quickly and didn\u2019t make pauses between the words, but at the same time they could always understand each other perfectly. It was possible because no word was a prefix of another one. The prefix of a string is considered to be one of its substrings that starts from the initial symbol.Help the scientists determine whether all the words of the Old Berland language can be reconstructed and if they can, output the words themselves.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains one integer N (1\u2264N\u22641000) \u2014 the number of words in Old Berland language. The second line contains N space-separated integers \u2014 the lengths of these words. All the lengths are natural numbers not exceeding 1000.\n","output_spec":"If there\u2019s no such set of words, in the single line output NO. Otherwise, in the first line output YES, and in the next N lines output the words themselves in the order their lengths were given in the input file. If the answer is not unique, output any.\n","notes":null,"sample_inputs":["3\n1 2 3\n","3\n1 1 1\n"],"sample_outputs":["YES\n0\n10\n110\n","NO\n"],"id":"37-C","difficulty":1900,"tags":["data+structures","greedy","trees"],"src_uid":"1670a3d7dba83e29e98f0ac6fe4acb18","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isPrefix(string s1, string s2) {\\n    if (s1.length() > s2.length()) {\\n        return false;\\n    }\\n    for (int i = 0; i < s1.length(); i++) {\\n        if (s1[i] != s2[i]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> lengths(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> lengths[i];\\n    }\\n    sort(lengths.begin(), lengths.end());\\n    vector<string> words(n);\\n    words[0] = string(lengths[0], '0');\\n    for (int i = 1; i < n; i++) {\\n        words[i] = words[i-1] + '1';\\n        if (words[i].length() > lengths[i]) {\\n            words[i].pop_back();\\n        }\\n    }\\n    bool valid = true;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = i+1; j < n; j++) {\\n            if (isPrefix(words[i], words[j])) {\\n                valid = false;\\n                break;\\n            }\\n        }\\n        if (!valid) {\\n            break;\\n        }\\n    }\\n    if (valid) {\\n        cout << \\\"YES\\\" << endl;\\n        for (int i = 0; i < n; i++) {\\n            cout << words[i] << endl;\\n        }\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class OldBerlandLanguage {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] lengths = new int[n];\n        for (int i = 0; i < n; i++) {\n            lengths[i] = scanner.nextInt();\n        }\n        \n        List<String> words = new ArrayList<>();\n        StringBuilder currentWord = new StringBuilder();\n        boolean possible = true;\n        \n        for (int i = 0; i < n; i++) {\n            int length = lengths[i];\n            if (currentWord.length() > length) {\n                possible = false;\n                break;\n            } else if (currentWord.length() == length) {\n                words.add(currentWord.toString());\n                currentWord = new StringBuilder();\n            } else {\n                int remainingLength = length - currentWord.length();\n                currentWord.append(\"1\".repeat(remainingLength));\n                words.add(currentWord.toString());\n                currentWord = new StringBuilder(\"0\");\n            }\n        }\n        \n        if (possible) {\n            System.out.println(\"YES\");\n            for (String word : words) {\n                System.out.println(word);\n            }\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n}","Python":"def reconstruct_words(n, lengths):\\n    words = []\\n    for length in lengths:\\n        if length == 1:\\n            words.append('0')\\n        else:\\n            words.append('1' + '0' * (length - 1))\\n    return words\\n\\n\\nn = int(input())\\nlengths = list(map(int, input().split()))\\n\\nwords = reconstruct_words(n, lengths)\\n\\nif len(set(words)) == n:\\n    print('YES')\\n    for word in words:\\n        print(word)\\nelse:\\n    print('NO')","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int lengths[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &lengths[i]);\\n    }\\n\\n    char words[n][1001];\\n    int wordIndex = 0;\\n    int prefixIndex = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < lengths[i]; j++) {\\n            if (j == 0) {\\n                words[wordIndex][prefixIndex++] = '0';\\n            } else {\\n                words[wordIndex][prefixIndex++] = '1';\\n            }\\n        }\\n        words[wordIndex][prefixIndex] = '\\\\0';\\n        wordIndex++;\\n        prefixIndex = 0;\\n    }\\n\\n    printf(\\\"YES\\\\n\\\");\\n    for (int i = 0; i < n; i++) {\\n        printf(\\\"%s\\\\n\\\", words[i]);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace OldBerlandLanguage\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            string[] lengths = Console.ReadLine().Split(' ');\n\n            List<string> words = new List<string>();\n\n            for (int i = 0; i < n; i++)\n            {\n                int length = int.Parse(lengths[i]);\n                string word = \"\";\n\n                if (i > 0)\n                {\n                    word += \"1\";\n                    length--;\n                }\n\n                for (int j = 0; j < length; j++)\n                {\n                    word += \"0\";\n                }\n\n                words.Add(word);\n            }\n\n            bool canReconstruct = true;\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = i + 1; j < n; j++)\n                {\n                    if (words[i].StartsWith(words[j]) || words[j].StartsWith(words[i]))\n                    {\n                        canReconstruct = false;\n                        break;\n                    }\n                }\n\n                if (!canReconstruct)\n                {\n                    break;\n                }\n            }\n\n            if (canReconstruct)\n            {\n                Console.WriteLine(\"YES\");\n\n                foreach (string word in words)\n                {\n                    Console.WriteLine(word);\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"NO\");\n            }\n        }\n    }\n}","Ruby":"def reconstruct_words(n, lengths)\\n  words = []\\n  current_word = \\\"0\\\"\\n\\n  lengths.each do |length|\\n    if current_word.length > length\\n      return \\\"NO\\\"\\n    end\\n\\n    words << current_word\\n    current_word += \\\"0\\\"\\n\\n    if current_word.length > length\\n      return \\\"NO\\\"\\n    end\\n\\n    words << current_word\\n    current_word += \\\"1\\\"\\n  end\\n\\n  \\\"YES\\\\n\\\" + words.join(\\\"\\\\n\\\")\\nend\\n\\ninput = gets.chomp.split('\\\\n')\\nn = input[0].to_i\\nlengths = input[1].split.map(&:to_i)\\n\\nputs reconstruct_words(n, lengths)","delphi":"program OldBerlandLanguage;\n\nvar\n  N, i, j, k: Integer;\n  lengths: array[1..1000] of Integer;\n  words: array[1..1000] of String;\n  prefix: Boolean;\n\nbegin\n  \/\/ Read the number of words\n  Readln(N);\n  \n  \/\/ Read the lengths of the words\n  for i := 1 to N do\n    Read(lengths[i]);\n  \n  \/\/ Initialize the words array\n  for i := 1 to N do\n    words[i] := '';\n  \n  \/\/ Check if the words can be reconstructed\n  for i := 1 to N do\n  begin\n    prefix := False;\n    \n    \/\/ Check if the current word is a prefix of any previous word\n    for j := 1 to i-1 do\n    begin\n      if Copy(words[j], 1, lengths[i]) = words[i] then\n      begin\n        prefix := True;\n        Break;\n      end;\n    end;\n    \n    \/\/ If the current word is not a prefix, construct it\n    if not prefix then\n    begin\n      for k := 1 to lengths[i] do\n      begin\n        if k mod 2 = 1 then\n          words[i] := words[i] + '0'\n        else\n          words[i] := words[i] + '1';\n      end;\n    end;\n  end;\n  \n  \/\/ Output the result\n  if prefix then\n    Writeln('NO')\n  else\n  begin\n    Writeln('YES');\n    for i := 1 to N do\n      Writeln(words[i]);\n  end;\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar lengths []int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar length int\\n\\t\\tfmt.Scan(&length)\\n\\t\\tlengths = append(lengths, length)\\n\\t}\\n\\n\\twords := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif i == 0 {\\n\\t\\t\\twords[i] = strings.Repeat(\\\"0\\\", lengths[i])\\n\\t\\t} else {\\n\\t\\t\\twords[i] = words[i-1] + \\\"1\\\" + strings.Repeat(\\\"0\\\", lengths[i]-1)\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(\\\"YES\\\")\\n\\tfor _, word := range words {\\n\\t\\tfmt.Println(word)\\n\\t}\\n}","Javascript":"function reconstructWords(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const lengths = lines[1].split(' ').map(Number);\n  \n  const words = [];\n  let currentWord = '';\n  \n  for (let i = 0; i < n; i++) {\n    const length = lengths[i];\n    \n    if (currentWord.length === 0) {\n      currentWord = '0'.repeat(length);\n      words.push(currentWord);\n    } else {\n      const prefix = currentWord.slice(0, length - 1);\n      const lastChar = currentWord[length - 1];\n      \n      if (lastChar === '0') {\n        currentWord = prefix + '1';\n      } else {\n        currentWord = prefix + '0'.repeat(length - 1) + '1';\n      }\n      \n      words.push(currentWord);\n    }\n  }\n  \n  return words.length === n ? ['YES', ...words].join('\\\\n') : 'NO';\n}\n\nconst input = '3\\\\n1 2 3\\\\n';\nconsole.log(reconstructWords(input));","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val lengths = IntArray(n)\n    for (i in 0 until n) {\n        lengths[i] = sc.nextInt()\n    }\n    \n    val words = Array(n) { StringBuilder() }\n    var currentWord = 0\n    var currentLength = lengths[currentWord]\n    \n    for (i in 0 until lengths.sum()) {\n        words[currentWord].append(if (i < currentLength) '0' else '1')\n        \n        if (i == currentLength - 1) {\n            currentWord++\n            if (currentWord < n) {\n                currentLength += lengths[currentWord]\n            }\n        }\n    }\n    \n    val prefixSet = HashSet<String>()\n    var isPrefix = false\n    \n    for (i in 0 until n) {\n        val word = words[i].toString()\n        if (prefixSet.contains(word)) {\n            isPrefix = true\n            break\n        }\n        prefixSet.add(word)\n    }\n    \n    if (isPrefix) {\n        println(\"NO\")\n    } else {\n        println(\"YES\")\n        for (i in 0 until n) {\n            println(words[i])\n        }\n    }\n}","PHP":"\n<?php\n\nfunction reconstructWords($n, $lengths) {\n    \/\/ Sort the lengths in descending order\n    rsort($lengths);\n    \n    \/\/ Initialize an array to store the words\n    $words = array();\n    \n    \/\/ Iterate through the lengths\n    foreach ($lengths as $length) {\n        \/\/ Check if the length is greater than the number of existing words\n        if ($length > count($words)) {\n            \/\/ If so, it is not possible to reconstruct the words\n            return 'NO';\n        }\n        \n        \/\/ Create a new word with the given length\n        $word = str_repeat('1', $length);\n        \n        \/\/ Append the word to the array\n        $words[] = $word;\n    }\n    \n    \/\/ If all lengths are valid, return the words\n    return array('YES', implode(\"\\n\", $words));\n}\n\n\/\/ Read the input\n$input = explode(\"\\n\", trim(file_get_contents('php:\/\/stdin')));\n$n = intval($input[0]);\n$lengths = array_map('intval', explode(' ', $input[1]));\n\n\/\/ Reconstruct the words\n$result = reconstructWords($n, $lengths);\n\n\/\/ Output the result\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] lengths;\\r\\n    lengths.length = n;\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &lengths[i]);\\r\\n    }\\r\\n\\r\\n    lengths.sort();\\r\\n\\r\\n    string[] words;\\r\\n    words.length = n;\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        words[i] = \\\"0\\\".repeat(lengths[i]);\\r\\n    }\\r\\n\\r\\n    writeln(\\\"YES\\\");\\r\\n\\r\\n    foreach (word; words)\\r\\n    {\\r\\n        writeln(word);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub reconstruct_words {\n    my ($n, @lengths) = @_;\n\n    my @words;\n    my $prefix = '';\n    for my $length (@lengths) {\n        my $word;\n        if ($prefix eq '') {\n            $word = '0' x $length;\n        } else {\n            $word = $prefix . '0' x ($length - length($prefix));\n        }\n        push @words, $word;\n        $prefix = $word;\n    }\n\n    return @words;\n}\n\nsub main {\n    my $n = <>;\n    chomp $n;\n\n    my $lengths_line = <>;\n    chomp $lengths_line;\n    my @lengths = split ' ', $lengths_line;\n\n    my @words = reconstruct_words($n, @lengths);\n\n    if (@words) {\n        print \\\"YES\\\\n\\\";\n        print join(\\\"\\\\n\\\", @words), \\\"\\\\n\\\";\n    } else {\n        print \\\"NO\\\\n\\\";\n    }\n}\n\nmain();\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let lengths: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    \n    let mut words: Vec<String> = Vec::new();\n    let mut current_word = String::new();\n    \n    for length in lengths {\n        if current_word.len() == length {\n            words.push(current_word.clone());\n            current_word.clear();\n        } else if current_word.len() > length {\n            println!(\"NO\");\n            return;\n        } else {\n            current_word.push('0');\n        }\n    }\n    \n    if current_word.len() > 0 {\n        words.push(current_word.clone());\n    }\n    \n    println!(\"YES\");\n    for word in words {\n        println!(\"{}\", word);\n    }\n}"}
{"title":"E. Trial for Chief","description":"Having unraveled the Berland Dictionary, the scientists managed to read the notes of the chroniclers of that time. For example, they learned how the chief of the ancient Berland tribe was chosen.As soon as enough pretenders was picked, the following test took place among them: the chief of the tribe took a slab divided by horizontal and vertical stripes into identical squares (the slab consisted of N lines and M columns) and painted every square black or white. Then every pretender was given a slab of the same size but painted entirely white. Within a day a pretender could paint any side-linked set of the squares of the slab some color. The set is called linked if for any two squares belonging to the set there is a path belonging the set on which any two neighboring squares share a side. The aim of each pretender is to paint his slab in the exactly the same way as the chief\u2019s slab is painted. The one who paints a slab like that first becomes the new chief.Scientists found the slab painted by the ancient Berland tribe chief. Help them to determine the minimal amount of days needed to find a new chief if he had to paint his slab in the given way.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers N and M (1\u2264N,M\u226450) \u2014 the number of lines and columns on the slab. The next N lines contain M symbols each \u2014 the final coloration of the slab. W stands for the square that should be painted white and B \u2014 for the square that should be painted black.\n","output_spec":"In the single line output the minimal number of repaintings of side-linked areas needed to get the required coloration of the slab.\n","notes":null,"sample_inputs":["3 3\nWBW\nBWB\nWBW\n","2 3\nBBB\nBWB\n"],"sample_outputs":["2\n","1\n"],"id":"37-E","difficulty":2600,"tags":["graphs","greedy","shortest+paths"],"src_uid":"73291724a4609ddd4cc8a92c77e8496f","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<char>> slab(n, vector<char>(m));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            cin >> slab[i][j];\\n        }\\n    }\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    int repaints = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (visited[i][j] == 0) {\\n                char target = slab[i][j];\\n                queue<pair<int, int>> q;\\n                q.push({i, j});\\n                while (!q.empty()) {\\n                    int x = q.front().first;\\n                    int y = q.front().second;\\n                    q.pop();\\n                    if (x >= 0 && x < n && y >= 0 && y < m && visited[x][y] == 0 && slab[x][y] == target) {\\n                        visited[x][y] = 1;\\n                        q.push({x-1, y});\\n                        q.push({x+1, y});\\n                        q.push({x, y-1});\\n                        q.push({x, y+1});\\n                    }\\n                }\\n                repaints++;\\n            }\\n        }\\n    }\\n    cout << repaints << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        char[][] slab = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < m; j++) {\n                slab[i][j] = line.charAt(j);\n            }\n        }\n        \n        int repaintCount = findMinimalRepaintings(slab);\n        System.out.println(repaintCount);\n    }\n    \n    public static int findMinimalRepaintings(char[][] slab) {\n        int n = slab.length;\n        int m = slab[0].length;\n        int repaintCount = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (slab[i][j] == 'B') {\n                    repaintCount++;\n                    repaintSlab(slab, i, j);\n                }\n            }\n        }\n        \n        return repaintCount;\n    }\n    \n    public static void repaintSlab(char[][] slab, int row, int col) {\n        int n = slab.length;\n        int m = slab[0].length;\n        \n        if (row > 0 && slab[row - 1][col] == 'W') {\n            slab[row - 1][col] = 'B';\n            repaintSlab(slab, row - 1, col);\n        }\n        \n        if (row < n - 1 && slab[row + 1][col] == 'W') {\n            slab[row + 1][col] = 'B';\n            repaintSlab(slab, row + 1, col);\n        }\n        \n        if (col > 0 && slab[row][col - 1] == 'W') {\n            slab[row][col - 1] = 'B';\n            repaintSlab(slab, row, col - 1);\n        }\n        \n        if (col < m - 1 && slab[row][col + 1] == 'W') {\n            slab[row][col + 1] = 'B';\n            repaintSlab(slab, row, col + 1);\n        }\n    }\n}","Python":"def find_min_repaintings(slab):\n    n, m = map(int, slab[0].split())\n    colors = [list(row) for row in slab[1:]]\n    \n    repaintings = 0\n    for i in range(n):\n        for j in range(m):\n            if colors[i][j] == 'B':\n                repaintings += 1\n                dfs(i, j, colors)\n    \n    return str(repaintings)\n\ndef dfs(i, j, colors):\n    if i < 0 or i >= len(colors) or j < 0 or j >= len(colors[0]) or colors[i][j] != 'B':\n        return\n    \n    colors[i][j] = 'W'\n    dfs(i+1, j, colors)\n    dfs(i-1, j, colors)\n    dfs(i, j+1, colors)\n    dfs(i, j-1, colors)\n\nslab = input().split('\\\\n')\nprint(find_min_repaintings(slab))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int N, M;\\n    scanf(\\\"%d %d\\\", &N, &M);\\n    char slab[N][M];\\n    for (int i = 0; i < N; i++) {\\n        scanf(\\\"%s\\\", slab[i]);\\n    }\\n\\n    int repaints = 0;\\n    for (int i = 0; i < N; i++) {\\n        for (int j = 0; j < M; j++) {\\n            if (slab[i][j] == 'B') {\\n                if ((i > 0 && slab[i-1][j] == 'W') || (i < N-1 && slab[i+1][j] == 'W') || (j > 0 && slab[i][j-1] == 'W') || (j < M-1 && slab[i][j+1] == 'W')) {\\n                    repaints++;\\n                }\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", repaints);\\n    return 0;\\n}","C#":"using System;\n\nnamespace BerlandDictionary\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            char[][] slab = new char[n][];\n            for (int i = 0; i < n; i++)\n            {\n                slab[i] = Console.ReadLine().ToCharArray();\n            }\n\n            int repaintCount = GetMinimalRepaintings(slab);\n            Console.WriteLine(repaintCount);\n        }\n\n        static int GetMinimalRepaintings(char[][] slab)\n        {\n            int n = slab.Length;\n            int m = slab[0].Length;\n\n            int repaintCount = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (slab[i][j] == 'B')\n                    {\n                        if (i + 1 < n && slab[i + 1][j] == 'W')\n                        {\n                            repaintCount++;\n                            slab[i + 1][j] = 'B';\n                        }\n\n                        if (i - 1 >= 0 && slab[i - 1][j] == 'W')\n                        {\n                            repaintCount++;\n                            slab[i - 1][j] = 'B';\n                        }\n\n                        if (j + 1 < m && slab[i][j + 1] == 'W')\n                        {\n                            repaintCount++;\n                            slab[i][j + 1] = 'B';\n                        }\n\n                        if (j - 1 >= 0 && slab[i][j - 1] == 'W')\n                        {\n                            repaintCount++;\n                            slab[i][j - 1] = 'B';\n                        }\n                    }\n                }\n            }\n\n            return repaintCount;\n        }\n    }\n}","Ruby":"\ndef find_minimal_repaintings(slab)\n  n, m = slab.shift.split.map(&:to_i)\n  colors = slab.map(&:chomp).map(&:chars)\n\n  repaintings = 0\n  visited = Array.new(n) { Array.new(m, false) }\n\n  (0...n).each do |i|\n    (0...m).each do |j|\n      next if visited[i][j]\n\n      color = colors[i][j]\n      queue = [[i, j]]\n\n      while !queue.empty?\n        x, y = queue.shift\n        visited[x][y] = true\n\n        if colors[x][y] != color\n          repaintings += 1\n          color = colors[x][y]\n        end\n\n        [[-1, 0], [1, 0], [0, -1], [0, 1]].each do |dx, dy|\n          nx, ny = x + dx, y + dy\n          next if nx < 0 || nx >= n || ny < 0 || ny >= m\n          next if visited[nx][ny] || colors[nx][ny] != color\n          queue << [nx, ny]\n        end\n      end\n    end\n  end\n\n  repaintings\nend\n\ninput = ['3 3\\nWBW\\nBWB\\nWBW\\n', '2 3\\nBBB\\nBWB\\n']\noutput = []\n\ninput.each do |i|\n  slab = i.split(\"\\n\")\n  output << find_minimal_repaintings(slab)\nend\n\noutput.map! { |o| o.to_s + '\\\\n' }\noutput\n","delphi":"program MinimalRepaintings;\\n\\nvar\\n  N, M, i, j, repaintings: Integer;\\n  slab: array of array of Char;\\n\\nbegin\\n  readln(N, M);\\n  SetLength(slab, N, M);\\n\\n  for i := 0 to N-1 do\\n  begin\\n    for j := 0 to M-1 do\\n    begin\\n      read(slab[i, j]);\\n    end;\\n    readln;\\n  end;\\n\\n  repaintings := 0;\\n\\n  for i := 0 to N-1 do\\n  begin\\n    for j := 0 to M-1 do\\n    begin\\n      if (i > 0) and (slab[i, j] <> slab[i-1, j]) then\\n        Inc(repaintings);\\n      if (j > 0) and (slab[i, j] <> slab[i, j-1]) then\\n        Inc(repaintings);\\n    end;\\n  end;\\n\\n  writeln(repaintings);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tvar slab [][]string\\n\\tslab = make([][]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar row string\\n\\t\\tfmt.Scanf(\\\"%s\\\", &row)\\n\\t\\tslab[i] = strings.Split(row, \\\"\\\")\\n\\t}\\n\\n\\tvar repaintCount int\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif slab[i][j] == \\\"B\\\" {\\n\\t\\t\\t\\trepaintCount++\\n\\t\\t\\t\\trepaint(slab, i, j)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(repaintCount)\\n}\\n\\nfunc repaint(slab [][]string, i, j int) {\\n\\tslab[i][j] = \\\"W\\\"\\n\\n\\tdx := []int{-1, 0, 1, 0}\\n\\tdy := []int{0, 1, 0, -1}\\n\\n\\tfor k := 0; k < 4; k++ {\\n\\t\\tni := i + dx[k]\\n\\t\\tnj := j + dy[k]\\n\\n\\t\\tif ni >= 0 && ni < len(slab) && nj >= 0 && nj < len(slab[0]) && slab[ni][nj] == \\\"B\\\" {\\n\\t\\t\\trepaint(slab, ni, nj)\\n\\t\\t}\\n\\t}\\n}","Javascript":"function findMinimalRepaintings(input) {\n  const lines = input.split('\\\\n');\n  const [N, M] = lines[0].split(' ').map(Number);\n  const slab = lines.slice(1, N + 1).map(line => line.split(''));\n\n  let repaintings = 0;\n\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (slab[i][j] === 'B') {\n        repaintings++;\n        repaintSlab(i, j);\n      }\n    }\n  }\n\n  return repaintings.toString();\n}\n\nfunction repaintSlab(row, col) {\n  slab[row][col] = 'W';\n\n  if (row > 0 && slab[row - 1][col] === 'B') {\n    repaintSlab(row - 1, col);\n  }\n  if (row < N - 1 && slab[row + 1][col] === 'B') {\n    repaintSlab(row + 1, col);\n  }\n  if (col > 0 && slab[row][col - 1] === 'B') {\n    repaintSlab(row, col - 1);\n  }\n  if (col < M - 1 && slab[row][col + 1] === 'B') {\n    repaintSlab(row, col + 1);\n  }\n}\n\nconst input = '3 3\\\\nWBW\\\\nBWB\\\\nWBW\\\\n';\nconsole.log(findMinimalRepaintings(input));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    \n    val slab = Array(n) { CharArray(m) }\n    for (i in 0 until n) {\n        val line = scanner.nextLine()\n        for (j in 0 until m) {\n            slab[i][j] = line[j]\n        }\n    }\n    \n    val visited = Array(n) { BooleanArray(m) }\n    var repaintCount = 0\n    \n    for (i in 0 until n) {\n        for (j in 0 until m) {\n            if (!visited[i][j]) {\n                val color = slab[i][j]\n                repaintConnected(slab, visited, i, j, color)\n                repaintCount++\n            }\n        }\n    }\n    \n    println(repaintCount)\n}\n\nfun repaintConnected(slab: Array<CharArray>, visited: Array<BooleanArray>, row: Int, col: Int, color: Char) {\n    if (row < 0 || row >= slab.size || col < 0 || col >= slab[0].size || visited[row][col] || slab[row][col] != color) {\n        return\n    }\n    \n    visited[row][col] = true\n    \n    repaintConnected(slab, visited, row - 1, col, color)\n    repaintConnected(slab, visited, row + 1, col, color)\n    repaintConnected(slab, visited, row, col - 1, color)\n    repaintConnected(slab, visited, row, col + 1, color)\n}","PHP":"<?php\\n\\nfunction findMinRepaintings($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $dimensions = explode(\\\" \\\", $lines[0]);\\n    $n = intval($dimensions[0]);\\n    $m = intval($dimensions[1]);\\n    $slab = array();\\n    for ($i = 1; $i <= $n; $i++) {\\n        $slab[] = str_split($lines[$i]);\\n    }\\n    $repaintings = 0;\\n    for ($i = 0; $i < $n; $i++) {\\n        for ($j = 0; $j < $m; $j++) {\\n            if ($slab[$i][$j] == 'B') {\\n                if ($i > 0 && $slab[$i-1][$j] == 'W') {\\n                    $repaintings++;\\n                    $slab[$i-1][$j] = 'B';\\n                }\\n                if ($i < $n-1 && $slab[$i+1][$j] == 'W') {\\n                    $repaintings++;\\n                    $slab[$i+1][$j] = 'B';\\n                }\\n                if ($j > 0 && $slab[$i][$j-1] == 'W') {\\n                    $repaintings++;\\n                    $slab[$i][$j-1] = 'B';\\n                }\\n                if ($j < $m-1 && $slab[$i][$j+1] == 'W') {\\n                    $repaintings++;\\n                    $slab[$i][$j+1] = 'B';\\n                }\\n            }\\n        }\\n    }\\n    return $repaintings;\\n}\\n\\n$input = '3 3\\\\nWBW\\\\nBWB\\\\nWBW\\\\n';\\n$output = findMinRepaintings($input);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int N, M;\\r\\n    readf(\\\"%d %d\\\", &N, &M);\\r\\n\\r\\n    char[][] slab = new char[][](N);\\r\\n    for (int i = 0; i < N; i++)\\r\\n    {\\r\\n        slab[i] = readln.chomp().dup;\\r\\n    }\\r\\n\\r\\n    int repaintCount = 0;\\r\\n\\r\\n    for (int i = 0; i < N; i++)\\r\\n    {\\r\\n        for (int j = 0; j < M; j++)\\r\\n        {\\r\\n            if (slab[i][j] == 'B')\\r\\n            {\\r\\n                repaintCount++;\\r\\n\\r\\n                for (int k = i; k < N; k++)\\r\\n                {\\r\\n                    for (int l = j; l < M; l++)\\r\\n                    {\\r\\n                        if (slab[k][l] == 'B')\\r\\n                        {\\r\\n                            slab[k][l] = 'W';\\r\\n                        }\\r\\n                        else\\r\\n                        {\\r\\n                            slab[k][l] = 'B';\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(repaintCount);\\r\\n}","perl":"\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, @slab) = split \/\\n\/, $input;\nmy ($n, $m) = split \/ \/, $nm;\nmy @slab = split \/\\n\/, $slab;\n\n# Initialize variables\nmy $repaints = 0;\n\n# Iterate through each square in the slab\nfor my $i (0..$n-1) {\n    for my $j (0..$m-1) {\n        # Check if the current square needs to be painted\n        if ($slab[$i][$j] ne 'W') {\n            # Paint the current square and its linked area\n            paint($i, $j);\n            $repaints++;\n        }\n    }\n}\n\n# Print the minimal number of repaints\nprint \"$repaints\\n\";\n\n# Function to paint the current square and its linked area\nsub paint {\n    my ($x, $y) = @_;\n    \n    # Check if the current square is out of bounds or already painted\n    return if ($x < 0 || $x >= $n || $y < 0 || $y >= $m || $slab[$x][$y] eq 'W');\n    \n    # Paint the current square\n    $slab[$x][$y] = 'W';\n    \n    # Paint the linked squares recursively\n    paint($x-1, $y);\n    paint($x+1, $y);\n    paint($x, $y-1);\n    paint($x, $y+1);\n}\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let lines: Vec<&str> = input.lines().collect();\n    let nm: Vec<usize> = lines[0].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n    let mut slab: Vec<Vec<char>> = Vec::new();\n    for i in 1..=n {\n        slab.push(lines[i].chars().collect());\n    }\n    \n    let mut count = 0;\n    for i in 0..n {\n        for j in 0..m {\n            if slab[i][j] == 'B' {\n                count += 1;\n                paint_slab(&mut slab, i, j);\n            }\n        }\n    }\n    \n    println!(\"{}\", count);\n}\n\nfn paint_slab(slab: &mut Vec<Vec<char>>, i: usize, j: usize) {\n    if i > 0 && slab[i-1][j] == 'W' {\n        slab[i-1][j] = 'B';\n        paint_slab(slab, i-1, j);\n    }\n    if i < slab.len()-1 && slab[i+1][j] == 'W' {\n        slab[i+1][j] = 'B';\n        paint_slab(slab, i+1, j);\n    }\n    if j > 0 && slab[i][j-1] == 'W' {\n        slab[i][j-1] = 'B';\n        paint_slab(slab, i, j-1);\n    }\n    if j < slab[0].len()-1 && slab[i][j+1] == 'W' {\n        slab[i][j+1] = 'B';\n        paint_slab(slab, i, j+1);\n    }\n}"}
{"title":"A. Army","description":"The Berland Armed Forces System consists of n ranks that are numbered using natural numbers from 1 to n, where 1 is the lowest rank and n is the highest rank.One needs exactly di years to rise from rank i to rank i+1. Reaching a certain rank i having not reached all the previous i-1 ranks is impossible.Vasya has just reached a new rank of a, but he dreams of holding the rank of b. Find for how many more years Vasya should serve in the army until he can finally realize his dream.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains an integer n (2\u2264n\u2264100). The second line contains n-1 integers di (1\u2264di\u2264100). The third input line contains two integers a and b (1\u2264a<b\u2264n). The numbers on the lines are space-separated.\n","output_spec":"Print the single number which is the number of years that Vasya needs to rise from rank a to rank b.\n","notes":null,"sample_inputs":["3\n5 6\n1 2\n","3\n5 6\n1 3\n"],"sample_outputs":["5\n","11\n"],"id":"38-A","difficulty":800,"tags":["implementation"],"src_uid":"69850c2af99d60711bcff5870575e15e","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> d(n-1);\\n    for(int i=0; i<n-1; i++) {\\n        cin >> d[i];\\n    }\\n    int a, b;\\n    cin >> a >> b;\\n    int years = 0;\\n    for(int i=a-1; i<b-1; i++) {\\n        years += d[i];\\n    }\\n    cout << years << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ArmyRank {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] d = new int[n-1];\\n        for (int i = 0; i < n-1; i++) {\\n            d[i] = scanner.nextInt();\\n        }\\n        int a = scanner.nextInt();\\n        int b = scanner.nextInt();\\n\\n        int years = 0;\\n        for (int i = a; i < b; i++) {\\n            years += d[i-1];\\n        }\\n\\n        System.out.println(years);\\n    }\\n}","Python":"def years_to_reach_rank(n, d, a, b):\n    years = 0\n    for i in range(a, b):\n        years += d[i-1]\n    return years\n\nn = int(input())\nd = list(map(int, input().split()))\na, b = map(int, input().split())\n\nresult = years_to_reach_rank(n, d, a, b)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int d[n-1];\\n    for(int i=0; i<n-1; i++) {\\n        scanf(\\\"%d\\\", &d[i]);\\n    }\\n    int a, b;\\n    scanf(\\\"%d %d\\\", &a, &b);\\n    int years = 0;\\n    for(int i=a-1; i<b-1; i++) {\\n        years += d[i];\\n    }\\n    printf(\\\"%d\\\\n\\\", years);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace BerlandArmedForcesSystem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] d = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int[] ranks = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            int years = 0;\n            for (int i = ranks[0]; i < ranks[1]; i++)\n            {\n                years += d[i - 1];\n            }\n\n            Console.WriteLine(years);\n        }\n    }\n}\n","Ruby":"\ndef years_to_reach_rank(n, d, a, b)\n  years = 0\n  (a...b).each do |i|\n    years += d[i-1]\n  end\n  years\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nd = input[1].split(' ').map(&:to_i)\na, b = input[2].split(' ').map(&:to_i)\n\noutput = years_to_reach_rank(n, d, a, b)\nputs output\n","delphi":"program BerlandArmedForces;\\n\\nvar\\n  n, a, b, i, years: integer;\\n  ranks: array of integer;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n);\\n  SetLength(ranks, n-1);\\n  for i := 0 to n-2 do\\n    read(ranks[i]);\\n  readln(a, b);\\n\\n  \/\/ Calculate the number of years\\n  years := 0;\\n  for i := a to b-1 do\\n    years := years + ranks[i-1];\\n\\n  \/\/ Print the result\\n  writeln(years);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, a, b int\\n\\tfmt.Scan(&n)\\n\\n\\td := make([]int, n-1)\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tfmt.Scan(&d[i])\\n\\t}\\n\\n\\tfmt.Scan(&a, &b)\\n\\n\\tyears := 0\\n\\tfor i := a; i < b; i++ {\\n\\t\\tyears += d[i-1]\\n\\t}\\n\\n\\tfmt.Println(years)\\n}","Javascript":"function calculateYears(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const d = lines[1].split(' ').map(Number);\n  const [a, b] = lines[2].split(' ').map(Number);\n\n  let years = 0;\n  for (let i = a; i < b; i++) {\n    years += d[i - 1];\n  }\n\n  return years.toString();\n}\n\nconst input = '3\\\\n5 6\\\\n1 2\\\\n';\nconsole.log(calculateYears(input));","Kotlin":"fun main() {\n    val input = readLine()!!.split(\"\\\\n\")\n    val n = input[0].toInt()\n    val d = input[1].split(\" \").map { it.toInt() }\n    val (a, b) = input[2].split(\" \").map { it.toInt() }\n\n    var years = 0\n    for (i in a until b) {\n        years += d[i - 1]\n    }\n\n    println(years)\n}","PHP":"<?php\\n\\nfunction calculateYears($n, $d, $a, $b) {\\n    $years = 0;\\n    for ($i = $a; $i < $b; $i++) {\\n        $years += $d[$i-1];\\n    }\\n    return $years;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n$n = (int) $input[0];\\n$d = array_map('intval', explode(\\\" \\\", $input[1]));\\nlist($a, $b) = array_map('intval', explode(\\\" \\\", $input[2]));\\n\\n$output = calculateYears($n, $d, $a, $b);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] ranks = new int[n-1];\\r\\n    foreach (i; 0..n-1)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &ranks[i]);\\r\\n    }\\r\\n\\r\\n    int a, b;\\r\\n    readf(\\\"%d %d\\\", &a, &b);\\r\\n\\r\\n    int totalYears = 0;\\r\\n    for (int i = a; i < b; i++)\\r\\n    {\\r\\n        totalYears += ranks[i-1];\\r\\n    }\\r\\n\\r\\n    writeln(totalYears);\\r\\n}","perl":"\n# Read input\nmy $n = <>;\nmy $d = <>;\nmy ($a, $b) = split(' ', <>);\n\n# Calculate the total number of years needed to reach rank b\nmy $total_years = 0;\nfor (my $i = $a; $i < $b; $i++) {\n    $total_years += $d->[$i-1];\n}\n\n# Print the result\nprint $total_years;\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let n: usize = lines[0].parse().unwrap();\n    let d: Vec<usize> = lines[1].split(' ').map(|x| x.parse().unwrap()).collect();\n    let (a, b): (usize, usize) = lines[2].split(' ').map(|x| x.parse().unwrap()).next_tuple().unwrap();\n    \n    let mut years = 0;\n    for i in a..b {\n        years += d[i-1];\n    }\n    \n    println!(\"{}\", years);\n}"}
{"title":"B. Chess","description":"Two chess pieces, a rook and a knight, stand on a standard chessboard 8\u00d78 in size. The positions in which they are situated are known. It is guaranteed that none of them beats the other one.Your task is to find the number of ways to place another knight on the board so that none of the three pieces on the board beat another one. A new piece can only be placed on an empty square.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains the description of the rook's position on the board. This description is a line which is 2 in length. Its first symbol is a lower-case Latin letter from a to h, and its second symbol is a number from 1 to 8. The second line contains the description of the knight's position in a similar way. It is guaranteed that their positions do not coincide.\n","output_spec":"Print a single number which is the required number of ways.\n","notes":null,"sample_inputs":["a1\nb2\n","a8\nd4\n"],"sample_outputs":["44\n","38\n"],"id":"38-B","difficulty":1200,"tags":["brute+force","implementation","math"],"src_uid":"073023c6b72ce923df2afd6130719cfc","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    string rook, knight;\\n    cin >> rook >> knight;\\n\\n    int rookX = rook[0] - 'a';\\n    int rookY = rook[1] - '1';\\n    int knightX = knight[0] - 'a';\\n    int knightY = knight[1] - '1';\\n\\n    vector<pair<int, int>> moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < 8; i++) {\\n        int newX = knightX + moves[i].first;\\n        int newY = knightY + moves[i].second;\\n\\n        if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 && (newX != rookX || newY != rookY)) {\\n            count++;\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String rookPosition = scanner.nextLine();\n        String knightPosition = scanner.nextLine();\n        \n        int rookX = rookPosition.charAt(0) - 'a';\n        int rookY = rookPosition.charAt(1) - '1';\n        int knightX = knightPosition.charAt(0) - 'a';\n        int knightY = knightPosition.charAt(1) - '1';\n        \n        int[][] board = new int[8][8];\n        board[rookX][rookY] = 1;\n        board[knightX][knightY] = 1;\n        \n        int[][] moves = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n        \n        int count = 0;\n        \n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                if (board[i][j] == 0) {\n                    boolean isValid = true;\n                    for (int[] move : moves) {\n                        int newX = i + move[0];\n                        int newY = j + move[1];\n                        if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 && board[newX][newY] == 1) {\n                            isValid = false;\n                            break;\n                        }\n                    }\n                    if (isValid) {\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(count);\n    }\n}","Python":"def count_ways(rook_pos, knight_pos):\n    # Convert the positions to coordinates\n    rook_x = ord(rook_pos[0]) - ord('a')\n    rook_y = int(rook_pos[1]) - 1\n    knight_x = ord(knight_pos[0]) - ord('a')\n    knight_y = int(knight_pos[1]) - 1\n\n    # Initialize the count of valid positions\n    count = 0\n\n    # Iterate over all possible positions on the board\n    for x in range(8):\n        for y in range(8):\n            # Check if the position is empty and not attacked by the rook or knight\n            if (x, y) != (rook_x, rook_y) and (x, y) != (knight_x, knight_y) and not is_attacked(x, y, rook_x, rook_y, knight_x, knight_y):\n                count += 1\n\n    return count\n\ndef is_attacked(x, y, rook_x, rook_y, knight_x, knight_y):\n    # Check if the position is attacked by the rook or knight\n    if x == rook_x or y == rook_y or abs(x - rook_x) == abs(y - rook_y):\n        return True\n    if abs(x - knight_x) == 2 and abs(y - knight_y) == 1:\n        return True\n    if abs(x - knight_x) == 1 and abs(y - knight_y) == 2:\n        return True\n    return False\n\n# Read the input\nrook_pos = input().strip()\nknight_pos = input().strip()\n\n# Count the number of ways\nnum_ways = count_ways(rook_pos, knight_pos)\n\n# Print the result\nprint(num_ways)","C":"#include <stdio.h>\\n\\nint main() {\\n    char rook[3], knight[3];\\n    scanf(\\\"%s\\\", rook);\\n    scanf(\\\"%s\\\", knight);\\n\\n    int count = 0;\\n\\n    \/\/ Check all possible positions for the new knight\\n    for (char c = 'a'; c <= 'h'; c++) {\\n        for (int i = 1; i <= 8; i++) {\\n            \/\/ Check if the new position is safe for all three pieces\\n            if ((c != rook[0] || i != rook[1] - '0') &&\\n                (c != knight[0] || i != knight[1] - '0') &&\\n                (abs(c - rook[0]) != abs(i - (rook[1] - '0'))) &&\\n                (abs(c - knight[0]) != abs(i - (knight[1] - '0')))) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace ChessPieces\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string rookPosition = Console.ReadLine();\n            string knightPosition = Console.ReadLine();\n\n            int rookX = rookPosition[0] - 'a';\n            int rookY = rookPosition[1] - '1';\n\n            int knightX = knightPosition[0] - 'a';\n            int knightY = knightPosition[1] - '1';\n\n            int count = 0;\n\n            for (int x = 0; x < 8; x++)\n            {\n                for (int y = 0; y < 8; y++)\n                {\n                    if ((Math.Abs(x - rookX) == 2 && Math.Abs(y - rookY) == 1) || (Math.Abs(x - rookX) == 1 && Math.Abs(y - rookY) == 2))\n                    {\n                        continue;\n                    }\n\n                    if ((Math.Abs(x - knightX) == 2 && Math.Abs(y - knightY) == 1) || (Math.Abs(x - knightX) == 1 && Math.Abs(y - knightY) == 2))\n                    {\n                        continue;\n                    }\n\n                    count++;\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n    }\n}","Ruby":"def count_ways(rook, knight)\\n  rook_x = rook[0].ord - 'a'.ord\\n  rook_y = rook[1].to_i - 1\\n  knight_x = knight[0].ord - 'a'.ord\\n  knight_y = knight[1].to_i - 1\\n\\n  board = Array.new(8) { Array.new(8, 0) }\\n\\n  # Mark rook and knight positions\\n  board[rook_y][rook_x] = 1\\n  board[knight_y][knight_x] = 1\\n\\n  # Calculate number of ways\\n  ways = 0\\n\\n  # Check all possible knight moves\\n  moves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]\\n\\n  moves.each do |move|\\n    x = knight_x + move[0]\\n    y = knight_y + move[1]\\n\\n    if x >= 0 && x < 8 && y >= 0 && y < 8 && board[y][x] == 0\\n      ways += 1\\n    end\\n  end\\n\\n  return ways.to_s + \\\"\\\\n\\\"\\nend\\n\\n# Read input\\ninput = gets.split\\n\\n# Call function and print result\\nputs count_ways(input[0], input[1])","delphi":"Here is the Delphi code to solve the problem:\n\n```delphi\nprogram ChessPieces;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction IsValidPosition(x, y: Integer): Boolean;\nbegin\n  Result := (x >= 1) and (x <= 8) and (y >= 1) and (y <= 8);\nend;\n\nfunction CountValidKnightPlacements(rookX, rookY, knightX, knightY: Integer): Integer;\nvar\n  dx, dy, newX, newY: Integer;\n  count: Integer;\nbegin\n  count := 0;\n\n  \/\/ Check all possible knight moves\n  for dx := -2 to 2 do\n  begin\n    for dy := -2 to 2 do\n    begin\n      if (Abs(dx) + Abs(dy) = 3) then \/\/ Valid knight move\n      begin\n        newX := knightX + dx;\n        newY := knightY + dy;\n\n        \/\/ Check if the new position is valid and not occupied by rook or knight\n        if IsValidPosition(newX, newY) and ((newX <> rookX) or (newY <> rookY)) and ((newX <> knightX) or (newY <> knightY)) then\n          Inc(count);\n      end;\n    end;\n  end;\n\n  Result := count;\nend;\n\nvar\n  rookPos, knightPos: string;\n  rookX, rookY, knightX, knightY: Integer;\n  validPlacements: Integer;\nbegin\n  \/\/ Read input\n  ReadLn(rookPos);\n  ReadLn(knightPos);\n\n  \/\/ Parse rook position\n  rookX := Ord(rookPos[1]) - Ord('a') + 1;\n  rookY := StrToInt(rookPos[2]);\n\n  \/\/ Parse knight position\n  knightX := Ord(knightPos[1]) - Ord('a') + 1;\n  knightY := StrToInt(knightPos[2]);\n\n  \/\/ Count valid knight placements\n  validPlacements := CountValidKnightPlacements(rookX, rookY, knightX, knightY);\n\n  \/\/ Print the result\n  WriteLn(validPlacements);\n\n  \/\/ Wait for user input to close the console window\n  ReadLn;\nend.\n```\n\nThis code reads the positions of the rook and knight from the input, converts them to coordinates on the chessboard, and then counts the number of valid knight placements using a nested loop. The `IsValidPosition` function checks if a given position is within the bounds of the chessboard. The `CountValidKnightPlacements` function iterates over all possible knight moves and checks if each move is valid and does not overlap with the rook or knight positions. Finally, the result is printed to the console.\n\nPlease note that this code assumes the input is always valid and does not include any error handling or input validation","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar rookPos, knightPos string\\n\\tfmt.Scan(&rookPos)\\n\\tfmt.Scan(&knightPos)\\n\\n\\trookX := int(rookPos[0] - 'a')\\n\\trookY := int(rookPos[1] - '1')\\n\\n\\tknightX := int(knightPos[0] - 'a')\\n\\tknightY := int(knightPos[1] - '1')\\n\\n\\tboard := make([][]bool, 8)\\n\\tfor i := 0; i < 8; i++ {\\n\\t\\tboard[i] = make([]bool, 8)\\n\\t}\\n\\n\\tboard[rookX][rookY] = true\\n\\tboard[knightX][knightY] = true\\n\\n\\tcount := 0\\n\\n\\tdx := []int{-2, -2, -1, -1, 1, 1, 2, 2}\\n\\tdy := []int{-1, 1, -2, 2, -2, 2, -1, 1}\\n\\n\\tfor i := 0; i < 8; i++ {\\n\\t\\tnx := knightX + dx[i]\\n\\t\\tny := knightY + dy[i]\\n\\n\\t\\tif nx >= 0 && nx < 8 && ny >= 0 && ny < 8 && !board[nx][ny] {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction countSafePositions(rookPos, knightPos) {\n  const rookX = rookPos.charCodeAt(0) - 97;\n  const rookY = parseInt(rookPos[1]) - 1;\n  const knightX = knightPos.charCodeAt(0) - 97;\n  const knightY = parseInt(knightPos[1]) - 1;\n\n  const board = Array.from(Array(8), () => Array(8).fill(true));\n\n  \/\/ Mark positions attacked by rook\n  for (let i = 0; i < 8; i++) {\n    board[rookY][i] = false;\n    board[i][rookX] = false;\n  }\n\n  \/\/ Mark positions attacked by knight\n  const knightMoves = [\n    [2, 1],\n    [1, 2],\n    [-2, 1],\n    [-1, 2],\n    [2, -1],\n    [1, -2],\n    [-2, -1],\n    [-1, -2]\n  ];\n\n  for (const [dx, dy] of knightMoves) {\n    const x = knightX + dx;\n    const y = knightY + dy;\n    if (x >= 0 && x < 8 && y >= 0 && y < 8) {\n      board[y][x] = false;\n    }\n  }\n\n  \/\/ Count number of safe positions\n  let count = 0;\n  for (let i = 0; i < 8; i++) {\n    for (let j = 0; j < 8; j++) {\n      if (board[i][j]) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n\nrl.question('', (rookPos) => {\n  rl.question('', (knightPos) => {\n    const result = countSafePositions(rookPos, knightPos);\n    console.log(result);\n    rl.close();\n  });\n});","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val rookPosition = scanner.nextLine()\n    val knightPosition = scanner.nextLine()\n    \n    val rookX = rookPosition[0] - 'a'\n    val rookY = rookPosition[1] - '1'\n    val knightX = knightPosition[0] - 'a'\n    val knightY = knightPosition[1] - '1'\n    \n    val board = Array(8) { BooleanArray(8) }\n    board[rookX][rookY] = true\n    board[knightX][knightY] = true\n    \n    val dx = intArrayOf(-2, -2, -1, -1, 1, 1, 2, 2)\n    val dy = intArrayOf(-1, 1, -2, 2, -2, 2, -1, 1)\n    \n    var count = 0\n    for (i in 0 until 8) {\n        val nx = knightX + dx[i]\n        val ny = knightY + dy[i]\n        \n        if (nx in 0 until 8 && ny in 0 until 8 && !board[nx][ny]) {\n            board[nx][ny] = true\n            count += countWays(board, nx, ny)\n            board[nx][ny] = false\n        }\n    }\n    \n    println(count)\n}\n\nfun countWays(board: Array<BooleanArray>, x: Int, y: Int): Int {\n    val dx = intArrayOf(-2, -2, -1, -1, 1, 1, 2, 2)\n    val dy = intArrayOf(-1, 1, -2, 2, -2, 2, -1, 1)\n    \n    var count = 0\n    for (i in 0 until 8) {\n        val nx = x + dx[i]\n        val ny = y + dy[i]\n        \n        if (nx in 0 until 8 && ny in 0 until 8 && !board[nx][ny]) {\n            board[nx][ny] = true\n            count++\n        }\n    }\n    \n    return count\n}","PHP":"<?php\\n\\nfunction countWays($rook, $knight) {\\n    $rookX = ord($rook[0]) - ord('a');\\n    $rookY = intval($rook[1]) - 1;\\n    $knightX = ord($knight[0]) - ord('a');\\n    $knightY = intval($knight[1]) - 1;\\n\\n    $board = array_fill(0, 8, array_fill(0, 8, 0));\\n\\n    \/\/ Mark rook and knight positions\\n    $board[$rookY][$rookX] = 1;\\n    $board[$knightY][$knightX] = 1;\\n\\n    $dx = array(2, 1, -1, -2, -2, -1, 1, 2);\\n    $dy = array(1, 2, 2, 1, -1, -2, -2, -1);\\n\\n    $count = 0;\\n\\n    \/\/ Check all possible knight positions\\n    for ($i = 0; $i < 8; $i++) {\\n        $newX = $knightX + $dx[$i];\\n        $newY = $knightY + $dy[$i];\\n\\n        \/\/ Check if the new position is within the board\\n        if ($newX >= 0 && $newX < 8 && $newY >= 0 && $newY < 8) {\\n            \/\/ Check if the new position is not occupied by rook or knight\\n            if ($board[$newY][$newX] == 0) {\\n                $count++;\\n            }\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n\/\/ Read input\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n$rook = $input[0];\\n$knight = $input[1];\\n\\n\/\/ Count the number of ways\\n$ways = countWays($rook, $knight);\\n\\n\/\/ Print the result\\necho $ways;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint[][] knightMoves = [\\r\\n    [-2, -1], [-2, 1], [-1, -2], [-1, 2],\\r\\n    [1, -2], [1, 2], [2, -1], [2, 1]\\r\\n];\\r\\n\\r\\nint countValidMoves(int rookX, int rookY, int knightX, int knightY)\\r\\n{\\r\\n    int count = 0;\\r\\n\\r\\n    foreach (i; 0..8)\\r\\n    {\\r\\n        int newX = knightX + knightMoves[i][0];\\r\\n        int newY = knightY + knightMoves[i][1];\\r\\n\\r\\n        if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 && (newX != rookX || newY != rookY))\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = readln.split('\\\\n');\\r\\n    string rookPosition = inputs[0];\\r\\n    string knightPosition = inputs[1];\\r\\n\\r\\n    int rookX = rookPosition[0] - 'a';\\r\\n    int rookY = rookPosition[1] - '1';\\r\\n    int knightX = knightPosition[0] - 'a';\\r\\n    int knightY = knightPosition[1] - '1';\\r\\n\\r\\n    int validMoves = countValidMoves(rookX, rookY, knightX, knightY);\\r\\n\\r\\n    int totalMoves = 64 - 2 - validMoves;\\r\\n\\r\\n    writeln(totalMoves);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\n# Function to check if two positions are attacking each other\nsub is_attacking {\n    my ($x1, $y1, $x2, $y2) = @_;\n    \n    # Check if the positions are in the same row or column\n    if ($x1 == $x2 || $y1 == $y2) {\n        return 1;\n    }\n    \n    # Check if the positions are in the same diagonal\n    if (abs($x1 - $x2) == abs($y1 - $y2)) {\n        return 1;\n    }\n    \n    return 0;\n}\n\n# Function to count the number of ways to place another knight\nsub count_ways {\n    my ($rook_pos, $knight_pos) = @_;\n    my $count = 0;\n    \n    # Get the coordinates of the rook and knight positions\n    my ($rook_x, $rook_y) = split('', $rook_pos);\n    my ($knight_x, $knight_y) = split('', $knight_pos);\n    \n    # Loop through all possible positions on the board\n    for my $x (1..8) {\n        for my $y (1..8) {\n            # Check if the position is empty and not attacking the rook or knight\n            if (!is_attacking($x, $y, $rook_x, $rook_y) && !is_attacking($x, $y, $knight_x, $knight_y)) {\n                $count++;\n            }\n        }\n    }\n    \n    return $count;\n}\n\n# Read the input positions\nmy $rook_pos = <STDIN>;\nmy $knight_pos = <STDIN>;\n\n# Remove the newline character from the input positions\nchomp($rook_pos);\nchomp($knight_pos);\n\n# Count the number of ways to place another knight\nmy $num_ways = count_ways($rook_pos, $knight_pos);\n\n# Print the result\nprint $num_ways;\n","Rust":"fn main() {\\n    use std::io::{self, BufRead};\\n    \\n    let stdin = io::stdin();\\n    let mut lines = stdin.lock().lines();\\n    \\n    let rook_pos: String = lines.next().unwrap().unwrap();\\n    let knight_pos: String = lines.next().unwrap().unwrap();\\n    \\n    let rook_x = rook_pos.chars().nth(0).unwrap() as u8 - b'a';\\n    let rook_y = rook_pos.chars().nth(1).unwrap() as u8 - b'1';\\n    \\n    let knight_x = knight_pos.chars().nth(0).unwrap() as u8 - b'a';\\n    let knight_y = knight_pos.chars().nth(1).unwrap() as u8 - b'1';\\n    \\n    let mut count = 0;\\n    \\n    for x in 0..8 {\\n        for y in 0..8 {\\n            if (x != rook_x && y != rook_y) && (x != knight_x && y != knight_y) {\\n                let dx = (x as i8 - rook_x as i8).abs();\\n                let dy = (y as i8 - rook_y as i8).abs();\\n                let dist = dx + dy;\\n                \\n                if dist == 3 && (dx == 1 || dy == 1) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"C. Blinds","description":"The blinds are known to consist of opaque horizontal stripes that can be rotated thus regulating the amount of light flowing in the room. There are n blind stripes with the width of 1 in the factory warehouse for blind production. The problem is that all of them are spare details from different orders, that is, they may not have the same length (it is even possible for them to have different lengths)Every stripe can be cut into two or more parts. The cuttings are made perpendicularly to the side along which the length is measured. Thus the cuttings do not change the width of a stripe but each of the resulting pieces has a lesser length (the sum of which is equal to the length of the initial stripe)After all the cuttings the blinds are constructed through consecutive joining of several parts, similar in length, along sides, along which length is measured. Also, apart from the resulting pieces an initial stripe can be used as a blind if it hasn't been cut. It is forbidden to construct blinds in any other way.Thus, if the blinds consist of k pieces each d in length, then they are of form of a rectangle of k\u00d7d bourlemeters. Your task is to find for what window possessing the largest possible area the blinds can be made from the given stripes if on technical grounds it is forbidden to use pieces shorter than l bourlemeter. The window is of form of a rectangle with side lengths as positive integers.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first output line contains two space-separated integers n and l (1\u2264n,l\u2264100). They are the number of stripes in the warehouse and the minimal acceptable length of a blind stripe in bourlemeters. The second line contains space-separated n integers ai. They are the lengths of initial stripes in bourlemeters (1\u2264ai\u2264100).\n","output_spec":"Print the single number \u2014 the maximal area of the window in square bourlemeters that can be completely covered. If no window with a positive area that can be covered completely without breaking any of the given rules exist, then print the single number 0.\n","notes":"In the first sample test the required window is 2\u00d74 in size and the blinds for it consist of 4 parts, each 2 bourlemeters long. One of the parts is the initial stripe with the length of 2, the other one is a part of a cut stripe with the length of 3 and the two remaining stripes are parts of a stripe with the length of 4 cut in halves.\n","sample_inputs":["4 2\n1 2 3 4\n","5 3\n5 5 7 3 1\n","2 3\n1 2\n"],"sample_outputs":["8\n","15\n","0\n"],"id":"38-C","difficulty":1400,"tags":["brute+force"],"src_uid":"991516fa6f3ed5a71c547a3a50ea1a2b","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, l;\\n    cin >> n >> l;\\n    vector<int> stripes(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> stripes[i];\\n    }\\n    sort(stripes.begin(), stripes.end(), greater<int>());\\n    int maxArea = 0;\\n    for (int i = 0; i < n; i++) {\\n        int length = stripes[i];\\n        int blinds = 1;\\n        while (length >= l) {\\n            blinds++;\\n            length -= l;\\n        }\\n        int area = blinds * length;\\n        maxArea = max(maxArea, area);\\n    }\\n    cout << maxArea << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Blinds {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] input1 = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input1[0]);\n        int l = Integer.parseInt(input1[1]);\n        \n        String[] input2 = scanner.nextLine().split(\\\" \\\");\n        int[] ai = new int[n];\n        for (int i = 0; i < n; i++) {\n            ai[i] = Integer.parseInt(input2[i]);\n        }\n        \n        int maxArea = 0;\n        for (int i = l; i <= 100; i++) {\n            int count = 0;\n            for (int j = 0; j < n; j++) {\n                count += ai[j] \/ i;\n            }\n            int area = count * i;\n            maxArea = Math.max(maxArea, area);\n        }\n        \n        System.out.println(maxArea);\n    }\n}","Python":"def find_max_window_area(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, l = map(int, input_lines[0].split())\n    stripe_lengths = list(map(int, input_lines[1].split()))\n\n    max_area = 0\n\n    for i in range(1, max(stripe_lengths) + 1):\n        if all(length >= l for length in stripe_lengths):\n            max_area = max(max_area, i * sum(length \/\/ i for length in stripe_lengths))\n\n    return str(max_area)\n\ninput_str = input()\nprint(find_max_window_area(input_str))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, l;\\n    scanf(\\\"%d %d\\\", &n, &l);\\n    int a[n];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    int max_area = 0;\\n    for(int i=0; i<n; i++) {\\n        int length = a[i];\\n        int count = 0;\\n        for(int j=0; j<n; j++) {\\n            if(a[j] >= l) {\\n                count += a[j] \/ l;\\n            }\\n        }\\n        int area = length * count;\\n        if(area > max_area) {\\n            max_area = area;\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", max_area);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BlindStripes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int l = int.Parse(inputArr[1]);\n\n            string stripesInput = Console.ReadLine();\n            string[] stripesArr = stripesInput.Split(' ');\n            List<int> stripes = new List<int>();\n            foreach (string stripe in stripesArr)\n            {\n                stripes.Add(int.Parse(stripe));\n            }\n\n            int maxArea = GetMaxWindowArea(n, l, stripes);\n            Console.WriteLine(maxArea);\n        }\n\n        static int GetMaxWindowArea(int n, int l, List<int> stripes)\n        {\n            int maxArea = 0;\n\n            for (int i = 0; i < stripes.Count; i++)\n            {\n                int currentLength = stripes[i];\n                if (currentLength >= l)\n                {\n                    int blindsCount = 1;\n                    int blindsLength = currentLength;\n\n                    for (int j = i + 1; j < stripes.Count; j++)\n                    {\n                        blindsLength += stripes[j];\n                        if (blindsLength >= l)\n                        {\n                            blindsCount++;\n                            if (blindsCount * l > maxArea)\n                            {\n                                maxArea = blindsCount * l;\n                            }\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return maxArea;\n        }\n    }\n}","Ruby":"\ndef find_max_window_area(input)\n  # Parse input\n  n, l = input[0].split.map(&:to_i)\n  lengths = input[1].split.map(&:to_i)\n\n  # Sort lengths in descending order\n  lengths.sort! { |a, b| b <=> a }\n\n  # Initialize variables\n  max_area = 0\n  max_length = 0\n\n  # Iterate through all possible lengths\n  (l..lengths.sum).each do |length|\n    # Calculate the number of blinds that can be made with the current length\n    blinds = lengths.map { |stripe| stripe \/ length }.sum\n\n    # Calculate the area of the window\n    area = blinds * length\n\n    # Update max_area and max_length if the current area is greater\n    if area > max_area\n      max_area = area\n      max_length = length\n    end\n  end\n\n  # Return the max_area\n  max_area.to_s\nend\n\n# Test cases\ninput = ['4 2\\n1 2 3 4\\n', '5 3\\n5 5 7 3 1\\n', '2 3\\n1 2\\n']\noutput = ['8\\n', '15\\n', '0\\n']\n\n# Validate test cases\ninput.each_with_index do |test_input, index|\n  result = find_max_window_area(test_input)\n  puts \\\"Test case #{index + 1}: #{result == output[index]}\\\"\nend\n","delphi":"program Blinds;\n\nvar\n  n, l, i, j, k, maxArea, totalLength: Integer;\n  stripes: array of Integer;\n  dp: array of array of Integer;\n\nfunction Max(a, b: Integer): Integer;\nbegin\n  if a > b then\n    Result := a\n  else\n    Result := b;\nend;\n\nbegin\n  \/\/ Read input values\n  ReadLn(n, l);\n  SetLength(stripes, n);\n  for i := 0 to n - 1 do\n    Read(stripes[i]);\n\n  \/\/ Calculate total length of all stripes\n  totalLength := 0;\n  for i := 0 to n - 1 do\n    totalLength := totalLength + stripes[i];\n\n  \/\/ Initialize dynamic programming array\n  SetLength(dp, n + 1, totalLength + 1);\n\n  \/\/ Calculate maximum area\n  maxArea := 0;\n  for i := 1 to n do\n  begin\n    for j := 1 to totalLength do\n    begin\n      if stripes[i - 1] >= l then\n      begin\n        for k := l to stripes[i - 1] do\n        begin\n          if j >= k then\n            dp[i, j] := Max(dp[i, j], dp[i - 1, j - k] + k);\n        end;\n      end;\n      dp[i, j] := Max(dp[i, j], dp[i - 1, j]);\n      maxArea := Max(maxArea, dp[i, j]);\n    end;\n  end;\n\n  \/\/ Print the maximum area\n  WriteLn(maxArea);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, l int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &l)\\n\\n\\tstripes := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &stripes[i])\\n\\t}\\n\\n\\t\/\/ Sort the stripes in descending order\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(stripes)))\\n\\n\\tmaxArea := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif stripes[i] < l {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t\/\/ Calculate the number of blinds that can be made from the current stripe\\n\\t\\tblinds := stripes[i] \/ l\\n\\n\\t\\t\/\/ Calculate the area of the window that can be covered by the blinds\\n\\t\\tarea := blinds * l * (n - i)\\n\\n\\t\\tif area > maxArea {\\n\\t\\t\\tmaxArea = area\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxArea)\\n}","Javascript":"function findMaxWindowArea(input) {\n  const lines = input.split('\\\\n');\n  const [n, l] = lines[0].split(' ').map(Number);\n  const lengths = lines[1].split(' ').map(Number);\n\n  \/\/ Sort the lengths in descending order\n  lengths.sort((a, b) => b - a);\n\n  let maxArea = 0;\n\n  \/\/ Iterate through all possible window sizes\n  for (let width = 1; width <= n; width++) {\n    for (let height = 1; height <= n; height++) {\n      let totalLength = 0;\n      let blindsCount = 0;\n\n      \/\/ Calculate the total length and count of blinds for the current window size\n      for (let i = 0; i < width * height; i++) {\n        if (i < lengths.length) {\n          totalLength += Math.min(lengths[i], l);\n          blindsCount++;\n        } else {\n          totalLength += l;\n        }\n      }\n\n      \/\/ Check if the current window size is valid and update the max area if necessary\n      if (totalLength >= width * height * l && blindsCount >= width * height) {\n        maxArea = Math.max(maxArea, width * height);\n      }\n    }\n  }\n\n  return maxArea.toString();\n}\n\nconst inputs = ['4 2\\\\n1 2 3 4\\\\n', '5 3\\\\n5 5 7 3 1\\\\n', '2 3\\\\n1 2\\\\n'];\nconst outputs = ['8\\\\n', '15\\\\n', '0\\\\n'];\n\nlet results = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const input = inputs[i];\n  const expectedOutput = outputs[i];\n  const actualOutput = findMaxWindowArea(input);\n\n  const result = {\n    input,\n    expectedOutput,\n    actualOutput,\n    success: expectedOutput === actualOutput\n  };\n\n  results.push(result);\n}\n\nJSON.stringify(results);","Kotlin":"import kotlin.math.max\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val l = input[1]\\n    val lengths = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    var maxArea = 0\\n\\n    for (i in 0 until n) {\\n        var sum = 0\\n        var minLen = Int.MAX_VALUE\\n\\n        for (j in i until n) {\\n            sum += lengths[j]\\n            minLen = minOf(minLen, lengths[j])\\n\\n            if (sum >= l && minLen >= l) {\\n                val area = sum * l\\n                maxArea = max(maxArea, area)\\n            }\\n        }\\n    }\\n\\n    println(maxArea)\\n}","PHP":"<?php\\n\\nfunction findMaxWindow($n, $l, $stripes) {\\n    \/\/ Sort the stripes in descending order\\n    rsort($stripes);\\n    \\n    \/\/ Initialize variables\\n    $maxArea = 0;\\n    \\n    \/\/ Iterate through all possible window sizes\\n    for ($width = 1; $width <= $n; $width++) {\\n        for ($height = 1; $height <= $n; $height++) {\\n            \/\/ Calculate the total length of blinds needed for this window size\\n            $totalLength = $width * $height * $l;\\n            \\n            \/\/ Check if there are enough stripes to cover the window\\n            if ($totalLength <= array_sum($stripes)) {\\n                \/\/ Initialize variables\\n                $remainingStripes = $stripes;\\n                $windowArea = $width * $height;\\n                \\n                \/\/ Iterate through all possible blind lengths\\n                for ($blindLength = $l; $blindLength <= max($remainingStripes); $blindLength++) {\\n                    \/\/ Find the longest stripe that can be used for this blind length\\n                    $longestStripeIndex = -1;\\n                    $longestStripeLength = 0;\\n                    \\n                    for ($i = 0; $i < count($remainingStripes); $i++) {\\n                        if ($remainingStripes[$i] >= $blindLength && $remainingStripes[$i] > $longestStripeLength) {\\n                            $longestStripeIndex = $i;\\n                            $longestStripeLength = $remainingStripes[$i];\\n                        }\\n                    }\\n                    \\n                    \/\/ If a suitable stripe is found, use it for a blind\\n                    if ($longestStripeIndex != -1) {\\n                        $remainingStripes[$longestStripeIndex] -= $blindLength;\\n                    }\\n                    \\n                    \/\/ If no suitable stripe is found, break the loop\\n                    else {\\n                        break;\\n                    }\\n                }\\n                \\n                \/\/ Check if all blinds have been constructed\\n                if (array_sum($remainingStripes) == 0) {\\n                    \/\/ Update the maximum area if necessary\\n                    $maxArea = max($maxArea, $windowArea);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \/\/ Return the maximum area\\n    return $maxArea;\\n}\\n\\n\/\/ Read the input\\n$input = file_get_contents('php:\/\/stdin');\\n$lines = explode(\\\"\\\\n\\\", $input);\\n\\n\/\/ Parse the input\\nlist($n, $l) = explode(\\\" \\\", $lines[0]);\\n$stripes = array_map('intval', explode(\\\" \\\", $lines[1]));\\n\\n\/\/ Find the maximum window area\\n$maxWindowArea = findMaxWindow($n, $l, $stripes);\\n\\n\/\/ Print the result\\necho $maxWindowArea;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, l;\\r\\n    int[] ai;\\r\\n    int maxArea = 0;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &n, &l);\\r\\n    ai = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &ai[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Sort the stripes in descending order\\r\\n    ai.sort!((a, b) => a > b);\\r\\n\\r\\n    \/\/ Iterate through all possible window sizes\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        int width = ai[i];\\r\\n        int height = 0;\\r\\n        int count = 0;\\r\\n\\r\\n        \/\/ Check if the current stripe can be used as a blind\\r\\n        if (width >= l)\\r\\n        {\\r\\n            height = width;\\r\\n            count++;\\r\\n        }\\r\\n\\r\\n        \/\/ Iterate through the remaining stripes\\r\\n        for (int j = i + 1; j < n; j++)\\r\\n        {\\r\\n            int stripe = ai[j];\\r\\n\\r\\n            \/\/ Check if the current stripe can be used to extend the blind\\r\\n            if (stripe >= l && stripe <= width)\\r\\n            {\\r\\n                height += stripe;\\r\\n                count++;\\r\\n\\r\\n                \/\/ Update the width to the minimum of the current width and the stripe length\\r\\n                width = min(width, stripe);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \/\/ Calculate the area of the current window\\r\\n        int area = width * height;\\r\\n\\r\\n        \/\/ Update the maximum area\\r\\n        maxArea = max(maxArea, area);\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(maxArea);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_max_window_area {\\n    my ($n, $l, @stripes) = @_;\\n    my $max_area = 0;\\n    my $max_length = 0;\\n    my $total_length = 0;\\n\\n    foreach my $length (@stripes) {\\n        $total_length += $length;\\n        $max_length = $length if $length > $max_length;\\n    }\\n\\n    if ($max_length < $l) {\\n        return 0;\\n    }\\n\\n    for (my $i = $l; $i <= $total_length; $i++) {\\n        if ($total_length % $i == 0) {\\n            my $width = $total_length \/ $i;\\n            if ($width >= $l) {\\n                my $area = $width * $i;\\n                $max_area = $area if $area > $max_area;\\n            }\\n        }\\n    }\\n\\n    return $max_area;\\n}\\n\\n# Sample inputs\\nmy @inputs = (\\n    [4, 2, (1, 2, 3, 4)],\\n    [5, 3, (5, 5, 7, 3, 1)],\\n    [2, 3, (1, 2)],\\n);\\n\\n# Sample outputs\\nmy @outputs = (8, 15, 0);\\n\\n# Test each sample input\\nfor (my $i = 0; $i < scalar(@inputs); $i++) {\\n    my $input = $inputs[$i];\\n    my $expected_output = $outputs[$i];\\n\\n    my $n = $input->[0];\\n    my $l = $input->[1];\\n    my @stripes = @{$input->[2]};\\n\\n    my $output = find_max_window_area($n, $l, @stripes);\\n\\n    if ($output == $expected_output) {\\n        print \\\"Test $i: PASSED\\\\n\\\";\\n    } else {\\n        print \\\"Test $i: FAILED\\\\n\\\";\\n    }\\n}\\n","Rust":"fn main() {\\n    let input = \\\"4 2\\\\n1 2 3 4\\\\n\\\";\\n    let mut lines = input.lines();\\n    let first_line = lines.next().unwrap();\\n    let second_line = lines.next().unwrap();\\n    let mut nums = first_line.split_whitespace();\\n    let n: usize = nums.next().unwrap().parse().unwrap();\\n    let l: usize = nums.next().unwrap().parse().unwrap();\\n    let lengths: Vec<usize> = second_line.split_whitespace().map(|x| x.parse().unwrap()).collect();\\n\\n    let mut max_area = 0;\\n\\n    for i in 0..lengths.len() {\\n        let mut blinds = vec![lengths[i]];\\n        let mut total_length = lengths[i];\\n\\n        for j in (i + 1)..lengths.len() {\\n            total_length += lengths[j];\\n            blinds.push(lengths[j]);\\n\\n            if total_length >= l * blinds.len() {\\n                let width = total_length \/ blinds.len();\\n                let area = width * l;\\n                if area > max_area {\\n                    max_area = area;\\n                }\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", max_area);\\n}"}
{"title":"J. Spelling Check","description":"Petya has noticed that when he types using a keyboard, he often presses extra buttons and adds extra letters to the words. Of course, the spell-checking system underlines the words for him and he has to click every word and choose the right variant. Petya got fed up with correcting his mistakes himself, that\u2019s why he decided to invent the function that will correct the words itself. Petya started from analyzing the case that happens to him most of the time, when all one needs is to delete one letter for the word to match a word from the dictionary. Thus, Petya faces one mini-task: he has a printed word and a word from the dictionary, and he should delete one letter from the first word to get the second one. And now the very non-trivial question that Petya faces is: which letter should he delete?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The input data contains two strings, consisting of lower-case Latin letters. The length of each string is from 1 to 10^6 symbols inclusive, the first string contains exactly 1 symbol more than the second one.\n","output_spec":"In the first line output the number of positions of the symbols in the first string, after the deleting of which the first string becomes identical to the second one. In the second line output space-separated positions of these symbols in increasing order. The positions are numbered starting from 1. If it is impossible to make the first string identical to the second string by deleting one symbol, output one number 0.\n","notes":null,"sample_inputs":["abdrakadabra\nabrakadabra\n","aa\na\n","competition\ncodeforces\n"],"sample_outputs":["1\n3\n","2\n1 2\n","0\n"],"id":"39-J","difficulty":1500,"tags":["hashing","implementation","strings"],"src_uid":"0df064fd0288c2ac4832efa227107a0e","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nvector<int> deleteLetter(string s1, string s2) {\\n    int n = s1.length();\\n    vector<int> positions;\\n    int i = 0, j = 0;\\n    while (i < n && j < n-1) {\\n        if (s1[i] == s2[j]) {\\n            i++;\\n            j++;\\n        } else {\\n            positions.push_back(i+1);\\n            i++;\\n        }\\n    }\\n    if (j == n-1) {\\n        positions.push_back(i+1);\\n    }\\n    return positions;\\n}\\n\\nint main() {\\n    string s1, s2;\\n    cin >> s1 >> s2;\\n    vector<int> positions = deleteLetter(s1, s2);\\n    int numPositions = positions.size();\\n    cout << numPositions << endl;\\n    for (int i = 0; i < numPositions; i++) {\\n        cout << positions[i];\\n        if (i != numPositions-1) {\\n            cout << \\\" \\\";\\n        }\\n    }\\n    cout << endl;\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String firstString = scanner.nextLine();\\n        String secondString = scanner.nextLine();\\n\\n        List<Integer> positions = new ArrayList<>();\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while (i < firstString.length() && j < secondString.length()) {\\n            if (firstString.charAt(i) == secondString.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                positions.add(i + 1);\\n                i++;\\n            }\\n        }\\n\\n        if (positions.size() == 1) {\\n            System.out.println(1);\\n            System.out.println(positions.get(0));\\n        } else {\\n            System.out.println(0);\\n        }\\n    }\\n}\" }","Python":"def delete_letter(s1, s2):\n    n = len(s1)\n    m = len(s2)\n    \n    if n != m + 1:\n        return '0\\\\n'\n    \n    positions = []\n    i = 0\n    j = 0\n    \n    while i < n and j < m:\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        else:\n            positions.append(i + 1)\n            i += 1\n    \n    if j == m:\n        return '1\\\\n' + ' '.join(map(str, positions)) + '\\\\n'\n    else:\n        return '0\\\\n'\n\n# Sample inputs\ninputs = ['abdrakadabra\\\\nabrakadabra\\\\n', 'aa\\\\na\\\\n', 'competition\\\\ncodeforces\\\\n']\noutputs = []\n\nfor i in range(0, len(inputs), 2):\n    s1 = inputs[i].strip()\n    s2 = inputs[i+1].strip()\n    outputs.append(delete_letter(s1, s2))\n\n# Output\noutput_str = ''\nfor output in outputs:\n    output_str += output\n\nprint(output_str)","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char str1[1000005], str2[1000005];\\n    scanf(\\\"%s %s\\\", str1, str2);\\n    int len1 = strlen(str1);\\n    int len2 = strlen(str2);\\n    int i, j;\\n    int count = 0;\\n    int positions[1000005];\\n    int pos = 0;\\n\\n    for (i = 0, j = 0; i < len1 && j < len2; i++, j++) {\\n        if (str1[i] != str2[j]) {\\n            count++;\\n            positions[pos++] = i + 1;\\n            if (count > 1) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    if (count == 1 && len1 - len2 == 1) {\\n        printf(\\\"1\\\\n\\\");\\n        for (i = 0; i < pos; i++) {\\n            printf(\\\"%d \\\", positions[i]);\\n        }\\n    } else {\\n        printf(\\\"0\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\npublic class Solution\n{\n    public static string DeleteLetter(string word1, string word2)\n    {\n        int n = word1.Length;\n        int m = word2.Length;\n        \n        if (n != m + 1)\n        {\n            return \\\"0\\\\n\\\";\n        }\n        \n        List<int> positions = new List<int>();\n        \n        int i = 0;\n        int j = 0;\n        \n        while (i < n && j < m)\n        {\n            if (word1[i] == word2[j])\n            {\n                i++;\n                j++;\n            }\n            else\n            {\n                positions.Add(i + 1);\n                i++;\n            }\n        }\n        \n        if (j == m)\n        {\n            return \\\"1\\\\n\\\" + string.Join(\\\" \\\", positions) + \\\"\\\\n\\\";\n        }\n        else\n        {\n            return \\\"0\\\\n\\\";\n        }\n    }\n    \n    public static void Main(string[] args)\n    {\n        string[] inputs = Console.ReadLine().Split();\n        string word1 = inputs[0];\n        string word2 = inputs[1];\n        \n        string result = DeleteLetter(word1, word2);\n        Console.WriteLine(result);\n    }\n}","Ruby":"\ndef delete_letter(word1, word2)\n  positions = []\n  i = 0\n  j = 0\n\n  while i < word1.length && j < word2.length\n    if word1[i] == word2[j]\n      i += 1\n      j += 1\n    else\n      positions << i + 1\n      i += 1\n    end\n  end\n\n  if positions.length == 1\n    return \\\"1\\\\n#{positions[0]}\\\\n\\\"\n  else\n    return \\\"0\\\\n\\\"\n  end\nend\n\ninput = gets.chomp.split(\\\"\\\\n\\\")\nword1 = input[0]\nword2 = input[1]\n\noutput = delete_letter(word1, word2)\nputs output\n","delphi":"program DeleteLetter;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction DeleteLetter(s1, s2: string): string;\nvar\n  i, j: Integer;\n  positions: string;\nbegin\n  positions := '';\n  \n  \/\/ Check if the lengths of the strings are valid\n  if Length(s1) <> Length(s2) + 1 then\n  begin\n    Result := '0';\n    Exit;\n  end;\n  \n  \/\/ Find the positions of the letters to be deleted\n  i := 1;\n  j := 1;\n  while (i <= Length(s1)) and (j <= Length(s2)) do\n  begin\n    if s1[i] = s2[j] then\n    begin\n      Inc(i);\n      Inc(j);\n    end\n    else\n    begin\n      positions := positions + IntToStr(i) + ' ';\n      Inc(i);\n    end;\n  end;\n  \n  \/\/ If there are remaining letters in s1, add their positions\n  while i <= Length(s1) do\n  begin\n    positions := positions + IntToStr(i) + ' ';\n    Inc(i);\n  end;\n  \n  \/\/ If all letters in s1 are checked and there are no remaining letters in s2, return the positions\n  if (i > Length(s1)) and (j > Length(s2)) then\n  begin\n    Result := IntToStr(Length(positions) div 2) + #10 + positions;\n  end\n  else\n  begin\n    Result := '0';\n  end;\nend;\n\nvar\n  s1, s2: string;\nbegin\n  \/\/ Read the input strings\n  ReadLn(s1);\n  ReadLn(s2);\n  \n  \/\/ Call the function and print the result\n  WriteLn(DeleteLetter(s1, s2));\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\treader := bufio.NewReader(os.Stdin)\\n\\n\\t\/\/ Read the input strings\\n\\tinput1, _ := reader.ReadString('\\\\n')\\n\\tinput2, _ := reader.ReadString('\\\\n')\\n\\n\\t\/\/ Remove newline characters\\n\\tinput1 = strings.TrimSuffix(input1, \\\"\\\\n\\\")\\n\\tinput2 = strings.TrimSuffix(input2, \\\"\\\\n\\\")\\n\\n\\t\/\/ Find the positions of the symbols to delete\\n\\tpositions := findPositionsToDelete(input1, input2)\\n\\n\\t\/\/ Output the results\\n\\tfmt.Println(len(positions))\\n\\tfmt.Println(strings.Join(positions, \\\" \\\"))\\n}\\n\\nfunc findPositionsToDelete(s1, s2 string) []string {\\n\\tpositions := []string{}\\n\\n\\t\/\/ Iterate over the characters of the first string\\n\\tfor i := 0; i < len(s1); i++ {\\n\\t\\t\/\/ Remove the current character from the first string\\n\\t\\tnewString := s1[:i] + s1[i+1:]\\n\\n\\t\\t\/\/ Check if the new string matches the second string\\n\\t\\tif newString == s2 {\\n\\t\\t\\tpositions = append(positions, fmt.Sprintf(\\\"%d\\\", i+1))\\n\\t\\t}\\n\\t}\\n\\n\\treturn positions\\n}","Javascript":"function findDeletedLetter(str1, str2) {\n  let positions = [];\n  let i = 0;\n  let j = 0;\n  \n  while (i < str1.length && j < str2.length) {\n    if (str1[i] === str2[j]) {\n      i++;\n      j++;\n    } else {\n      positions.push(i + 1);\n      i++;\n    }\n  }\n  \n  if (positions.length === 1) {\n    return `1\\n${positions[0]}\\n`;\n  } else {\n    return `0\\n`;\n  }\n}\n\nconst input = ['abdrakadabra\\nabrakadabra\\n', 'aa\\na\\n', 'competition\\ncodeforces\\n'];\nconst output = [];\n\nfor (let i = 0; i < input.length; i++) {\n  const [str1, str2] = input[i].split('\\\\n');\n  output.push(findDeletedLetter(str1, str2));\n}\n\nJSON.stringify(output);","Kotlin":"fun main() {\\n    val input = readLine()!!.split(\\\"\\\\n\\\")\\n    val word1 = input[0]\\n    val word2 = input[1]\\n\\n    val positions = mutableListOf<Int>()\\n\\n    var i = 0\\n    var j = 0\\n\\n    while (i < word1.length && j < word2.length) {\\n        if (word1[i] == word2[j]) {\\n            i++\\n            j++\\n        } else {\\n            positions.add(i + 1)\\n            i++\\n        }\\n    }\\n\\n    if (positions.size == 1) {\\n        println(\\\"1\\\")\\n        println(positions[0])\\n    } else {\\n        println(\\\"0\\\")\\n    }\\n}","PHP":"<?php\\n\\nfunction deleteLetter($word1, $word2) {\\n    $len1 = strlen($word1);\\n    $len2 = strlen($word2);\\n    $positions = [];\\n    \\n    \/\/ Find the position of the letter to be deleted\\n    for ($i = 0; $i < $len1; $i++) {\\n        if ($word1[$i] != $word2[$i]) {\\n            $positions[] = $i + 1;\\n            break;\\n        }\\n    }\\n    \\n    \/\/ Check if deleting the letter makes the words identical\\n    for ($j = $i + 1; $j < $len1; $j++) {\\n        if ($word1[$j] != $word2[$j - 1]) {\\n            return \\\"0\\\\n\\\";\\n        }\\n    }\\n    \\n    \/\/ Output the number of positions and the positions\\n    $output = count($positions) . \\\"\\\\n\\\";\\n    $output .= implode(\\\" \\\", $positions) . \\\"\\\\n\\\";\\n    return $output;\\n}\\n\\n\/\/ Sample inputs\\n$input = [['abdrakadabra', 'abrakadabra'], ['aa', 'a'], ['competition', 'codeforces']];\\n\\n\/\/ Process each input and output the result\\n$output = [];\\nforeach ($input as $data) {\\n    $result = deleteLetter($data[0], $data[1]);\\n    $output[] = $result;\\n}\\n\\n\/\/ Output the final result\\necho json_encode($output);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string word1 = readln.chomp;\\r\\n    string word2 = readln.chomp;\\r\\n\\r\\n    int len1 = word1.length;\\r\\n    int len2 = word2.length;\\r\\n\\r\\n    if (len1 != len2 + 1)\\r\\n    {\\r\\n        writeln(0);\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    int[] positions;\\r\\n\\r\\n    for (int i = 0; i < len1; i++)\\r\\n    {\\r\\n        if (word1[i] != word2[i])\\r\\n        {\\r\\n            positions ~= i + 1;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (positions.length == 0)\\r\\n    {\\r\\n        writeln(0);\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    for (int i = positions[0] + 1; i < len1; i++)\\r\\n    {\\r\\n        if (word1[i] != word2[i - 1])\\r\\n        {\\r\\n            writeln(0);\\r\\n            return;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(1);\\r\\n    writeln(positions[0]);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub delete_letter {\n    my ($word1, $word2) = @_;\n\n    my @positions;\n    my @chars1 = split('', $word1);\n    my @chars2 = split('', $word2);\n\n    for my $i (0..$#chars1) {\n        if ($chars1[$i] ne $chars2[$i]) {\n            push @positions, $i+1;\n            last if scalar(@positions) > 1;\n        }\n    }\n\n    if (scalar(@positions) == 1) {\n        return scalar(@positions) . \\\"\\\\n\\\" . join(' ', @positions) . \\\"\\\\n\\\";\n    } else {\n        return \\\"0\\\\n\\\";\n    }\n}\n\n# Example inputs\nmy @inputs = (\n    ['abdrakadabra', 'abrakadabra'],\n    ['aa', 'a'],\n    ['competition', 'codeforces']\n);\n\nforeach my $input (@inputs) {\n    my $result = delete_letter($input->[0], $input->[1]);\n    print $result;\n}\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let words: Vec<&str> = input.trim().split('\\n').collect();\n    \n    let word1 = words[0];\n    let word2 = words[1];\n    \n    let mut positions: Vec<usize> = Vec::new();\n    \n    let mut i = 0;\n    let mut j = 0;\n    \n    while i < word1.len() && j < word2.len() {\n        if word1.chars().nth(i) == word2.chars().nth(j) {\n            i += 1;\n            j += 1;\n        } else {\n            positions.push(i + 1);\n            i += 1;\n        }\n    }\n    \n    if positions.len() == 1 && word1.len() == word2.len() + 1 {\n        positions.push(word1.len());\n    }\n    \n    if positions.len() == 0 {\n        println!(\"0\");\n    } else {\n        println!(\"{}\", positions.len());\n        for pos in positions {\n            print!(\"{} \", pos);\n        }\n    }\n}"}
{"title":"C. Tic-tac-toe","description":"Certainly, everyone is familiar with tic-tac-toe game. The rules are very simple indeed. Two players take turns marking the cells in a 3\u00d73 grid (one player always draws crosses, the other \u2014 noughts). The player who succeeds first in placing three of his marks in a horizontal, vertical or diagonal line wins, and the game is finished. The player who draws crosses goes first. If the grid is filled, but neither Xs, nor 0s form the required line, a draw is announced.You are given a 3\u00d73 grid, each grid cell is empty, or occupied by a cross or a nought. You have to find the player (first or second), whose turn is next, or print one of the verdicts below:   illegal \u2014 if the given board layout can't appear during a valid game;  the first player won \u2014 if in the given board layout the first player has just won;  the second player won \u2014 if in the given board layout the second player has just won;  draw \u2014 if the given board layout has just let to a draw. ","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"The input consists of three lines, each of the lines contains characters \".\", \"X\" or \"0\" (a period, a capital letter X, or a digit zero).\n","output_spec":"Print one of the six verdicts: first, second, illegal, the first player won, the second player won or draw.\n","notes":null,"sample_inputs":["X0X\n.0.\n.X.\n"],"sample_outputs":["second\n"],"id":"3-C","difficulty":1800,"tags":["brute+force","games","implementation"],"src_uid":"892680e26369325fb00d15543a96192c","C++":"#include <iostream>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nbool checkWin(vector<string>& board, char player) {\\n    \/\/ Check rows\\n    for (int i = 0; i < 3; i++) {\\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\\n            return true;\\n        }\\n    }\\n\\n    \/\/ Check columns\\n    for (int i = 0; i < 3; i++) {\\n        if (board[0][i] == player && board[1][i] == player && board[2][i] == player) {\\n            return true;\\n        }\\n    }\\n\\n    \/\/ Check diagonals\\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\\n        return true;\\n    }\\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\\n        return true;\\n    }\\n\\n    return false;\\n}\\n\\nstring findNextPlayer(vector<string>& board) {\\n    int countX = 0;\\n    int countO = 0;\\n\\n    \/\/ Count number of X and O\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            if (board[i][j] == 'X') {\\n                countX++;\\n            }\\n            else if (board[i][j] == '0') {\\n                countO++;\\n            }\\n        }\\n    }\\n\\n    \/\/ Check if the board layout is valid\\n    if (countX < countO || countX > countO + 1) {\\n        return \\\"illegal\\\";\\n    }\\n\\n    \/\/ Check if the game has already been won\\n    if (checkWin(board, 'X')) {\\n        if (checkWin(board, '0')) {\\n            return \\\"illegal\\\";\\n        }\\n        return \\\"the first player won\\\";\\n    }\\n    if (checkWin(board, '0')) {\\n        if (countX != countO) {\\n            return \\\"illegal\\\";\\n        }\\n        return \\\"the second player won\\\";\\n    }\\n\\n    \/\/ Check if the game is a draw\\n    if (countX + countO == 9) {\\n        return \\\"draw\\\";\\n    }\\n\\n    \/\/ Determine whose turn is next\\n    if (countX == countO) {\\n        return \\\"first\\\";\\n    }\\n    else {\\n        return \\\"second\\\";\\n    }\\n}\\n\\nint main() {\\n    vector<string> board(3);\\n    for (int i = 0; i < 3; i++) {\\n        cin >> board[i];\\n    }\\n\\n    string nextPlayer = findNextPlayer(board);\\n    cout << nextPlayer << endl;\\n\\n    return 0;\\n}","Java":"public class TicTacToe {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read the input grid\n        char[][] grid = new char[3][3];\n        for (int i = 0; i < 3; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < 3; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n        \n        \/\/ Check if the board layout is valid\n        int countX = 0;\n        int countO = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (grid[i][j] == 'X') {\n                    countX++;\n                } else if (grid[i][j] == '0') {\n                    countO++;\n                }\n            }\n        }\n        \n        if (countX < countO || countX > countO + 1) {\n            System.out.println(\"illegal\");\n            return;\n        }\n        \n        \/\/ Check if any player has won\n        if (checkWin(grid, 'X')) {\n            if (checkWin(grid, '0')) {\n                System.out.println(\"illegal\");\n            } else {\n                System.out.println(\"the first player won\");\n            }\n        } else if (checkWin(grid, '0')) {\n            if (countX == countO) {\n                System.out.println(\"the second player won\");\n            } else {\n                System.out.println(\"illegal\");\n            }\n        } else if (countX + countO == 9) {\n            System.out.println(\"draw\");\n        } else if (countX == countO) {\n            System.out.println(\"first\");\n        } else {\n            System.out.println(\"second\");\n        }\n    }\n    \n    \/\/ Helper method to check if a player has won\n    private static boolean checkWin(char[][] grid, char player) {\n        \/\/ Check rows\n        for (int i = 0; i < 3; i++) {\n            if (grid[i][0] == player && grid[i][1] == player && grid[i][2] == player) {\n                return true;\n            }\n        }\n        \n        \/\/ Check columns\n        for (int j = 0; j < 3; j++) {\n            if (grid[0][j] == player && grid[1][j] == player && grid[2][j] == player) {\n                return true;\n            }\n        }\n        \n        \/\/ Check diagonals\n        if (grid[0][0] == player && grid[1][1] == player && grid[2][2] == player) {\n            return true;\n        }\n        if (grid[0][2] == player && grid[1][1] == player && grid[2][0] == player) {\n            return true;\n        }\n        \n        return false;\n    }\n}","Python":"def check_winner(board):\n    # Check rows\n    for row in board:\n        if row[0] == row[1] == row[2] and row[0] != '.':\n            return row[0]\n    \n    # Check columns\n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] != '.':\n            return board[0][col]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '.':\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '.':\n        return board[0][2]\n    \n    return None\n\ndef check_valid(board):\n    count_x = 0\n    count_o = 0\n    \n    for row in board:\n        for cell in row:\n            if cell == 'X':\n                count_x += 1\n            elif cell == '0':\n                count_o += 1\n    \n    if count_x < count_o or count_x > count_o + 1:\n        return False\n    \n    winner = check_winner(board)\n    if winner:\n        if winner == 'X' and count_x != count_o + 1:\n            return False\n        elif winner == '0' and count_x != count_o:\n            return False\n    \n    return True\n\ndef get_next_turn(board):\n    count_x = 0\n    count_o = 0\n    \n    for row in board:\n        for cell in row:\n            if cell == 'X':\n                count_x += 1\n            elif cell == '0':\n                count_o += 1\n    \n    if count_x == count_o:\n        return 'first'\n    elif count_x == count_o + 1:\n        return 'second'\n    else:\n        return 'illegal'\n\ndef get_verdict(board):\n    if not check_valid(board):\n        return 'illegal'\n    \n    winner = check_winner(board)\n    if winner:\n        if winner == 'X':\n            return 'the first player won'\n        elif winner == '0':\n            return 'the second player won'\n    \n    if '.' in [cell for row in board for cell in row]:\n        return get_next_turn(board)\n    else:\n        return 'draw'\n\n# Test input\nboard = [\n    ['X', '0', 'X'],\n    ['.', '0', '.'],\n    ['.', 'X', '.']\n]\n\n# Get verdict\nverdict = get_verdict(board)\nprint(verdict)\n","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\n\/\/ Function to check if a player has won\\nbool checkWin(char board[3][3], char player) {\\n    \/\/ Check rows\\n    for (int i = 0; i < 3; i++) {\\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\\n            return true;\\n        }\\n    }\\n\\n    \/\/ Check columns\\n    for (int i = 0; i < 3; i++) {\\n        if (board[0][i] == player && board[1][i] == player && board[2][i] == player) {\\n            return true;\\n        }\\n    }\\n\\n    \/\/ Check diagonals\\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\\n        return true;\\n    }\\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\\n        return true;\\n    }\\n\\n    return false;\\n}\\n\\nint main() {\\n    char board[3][3];\\n\\n    \/\/ Read the input\\n    for (int i = 0; i < 3; i++) {\\n        scanf(\\\"%c%c%c\\\", &board[i][0], &board[i][1], &board[i][2]);\\n    }\\n\\n    int countX = 0;\\n    int countO = 0;\\n\\n    \/\/ Count the number of Xs and Os\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            if (board[i][j] == 'X') {\\n                countX++;\\n            } else if (board[i][j] == '0') {\\n                countO++;\\n            }\\n        }\\n    }\\n\\n    \/\/ Check if the board layout is illegal\\n    if (countX < countO || countX > countO + 1) {\\n        printf(\\\"illegal\\\\n\\\");\\n        return 0;\\n    }\\n\\n    \/\/ Check if the first player has won\\n    if (checkWin(board, 'X')) {\\n        printf(\\\"the first player won\\\\n\\\");\\n        return 0;\\n    }\\n\\n    \/\/ Check if the second player has won\\n    if (checkWin(board, '0')) {\\n        printf(\\\"the second player won\\\\n\\\");\\n        return 0;\\n    }\\n\\n    \/\/ Check if it's a draw\\n    if (countX + countO == 9) {\\n        printf(\\\"draw\\\\n\\\");\\n        return 0;\\n    }\\n\\n    \/\/ Determine whose turn is next\\n    if (countX == countO) {\\n        printf(\\\"first\\\\n\\\");\\n    } else {\\n        printf(\\\"second\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace TicTacToe\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read the input\n            string[] lines = new string[3];\n            for (int i = 0; i < 3; i++)\n            {\n                lines[i] = Console.ReadLine();\n            }\n\n            \/\/ Create a 2D array to represent the grid\n            char[,] grid = new char[3, 3];\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 3; j++)\n                {\n                    grid[i, j] = lines[i][j];\n                }\n            }\n\n            \/\/ Check if the board layout is valid\n            bool isValid = IsValidBoard(grid);\n\n            if (!isValid)\n            {\n                Console.WriteLine(\"illegal\");\n                return;\n            }\n\n            \/\/ Check if the first player has won\n            bool firstPlayerWon = HasPlayerWon(grid, 'X');\n\n            if (firstPlayerWon)\n            {\n                Console.WriteLine(\"the first player won\");\n                return;\n            }\n\n            \/\/ Check if the second player has won\n            bool secondPlayerWon = HasPlayerWon(grid, '0');\n\n            if (secondPlayerWon)\n            {\n                Console.WriteLine(\"the second player won\");\n                return;\n            }\n\n            \/\/ Check if it's a draw\n            bool isDraw = IsDraw(grid);\n\n            if (isDraw)\n            {\n                Console.WriteLine(\"draw\");\n                return;\n            }\n\n            \/\/ Determine whose turn is next\n            int countX = CountOccurrences(grid, 'X');\n            int count0 = CountOccurrences(grid, '0');\n\n            if (countX == count0)\n            {\n                Console.WriteLine(\"first\");\n            }\n            else\n            {\n                Console.WriteLine(\"second\");\n            }\n        }\n\n        static bool IsValidBoard(char[,] grid)\n        {\n            int countX = CountOccurrences(grid, 'X');\n            int count0 = CountOccurrences(grid, '0');\n\n            \/\/ The difference in counts should be at most 1\n            if (Math.Abs(countX - count0) > 1)\n            {\n                return false;\n            }\n\n            \/\/ If the first player has won, the counts should be equal\n            if (HasPlayerWon(grid, 'X') && countX != count0)\n            {\n                return false;\n            }\n\n            \/\/ If the second player has won, the count of X should be greater than the count of 0\n            if (HasPlayerWon(grid, '0') && countX <= count0)\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        static bool HasPlayerWon(char[,] grid, char player)\n        {\n            \/\/ Check rows\n            for (int i = 0; i < 3; i++)\n            {\n                if (grid[i, 0] == player && grid[i, 1] == player && grid[i, 2] == player)\n                {\n                    return true;\n                }\n            }\n\n            \/\/ Check columns\n            for (int j = 0; j < 3; j++)\n            {\n                if (grid[0, j] == player && grid[1, j] == player && grid[2, j] == player)\n                {\n                    return true;\n                }\n            }\n\n            \/\/ Check diagonals\n            if (grid[0, 0] == player && grid[1, 1] == player && grid[2, 2] == player)\n            {\n                return true;\n            }\n\n            if (grid[0, 2] == player && grid[1, 1] == player && grid[2, 0] == player)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        static bool IsDraw(char[,] grid)\n        {\n            int countX = CountOccurrences(grid, 'X');\n            int count0 = CountOccurrences(grid, '0');\n\n            \/\/ If the grid is full and no player has won, it's a draw\n            if (countX + count0 == 9)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        static int CountOccurrences(char[,] grid, char symbol)\n        {\n            int count = 0;\n\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 3; j++)\n                {\n                    if (grid[i, j] == symbol)\n                    {\n                        count++;\n                    }\n                }\n            }\n\n            return count;\n        }\n    }\n}","Ruby":"\ndef check_winner(board)\n  # Check rows\n  for i in 0..2\n    if board[i][0] == board[i][1] && board[i][1] == board[i][2]\n      return board[i][0] if board[i][0] != '.'\n    end\n  end\n\n  # Check columns\n  for i in 0..2\n    if board[0][i] == board[1][i] && board[1][i] == board[2][i]\n      return board[0][i] if board[0][i] != '.'\n    end\n  end\n\n  # Check diagonals\n  if board[0][0] == board[1][1] && board[1][1] == board[2][2]\n    return board[0][0] if board[0][0] != '.'\n  end\n\n  if board[0][2] == board[1][1] && board[1][1] == board[2][0]\n    return board[0][2] if board[0][2] != '.'\n  end\n\n  return nil\nend\n\ndef check_valid(board)\n  count_x = 0\n  count_o = 0\n\n  for i in 0..2\n    for j in 0..2\n      if board[i][j] == 'X'\n        count_x += 1\n      elsif board[i][j] == '0'\n        count_o += 1\n      elsif board[i][j] != '.'\n        return false\n      end\n    end\n  end\n\n  if count_x - count_o > 1 || count_o > count_x\n    return false\n  end\n\n  return true\nend\n\ndef next_turn(board)\n  if !check_valid(board)\n    return 'illegal'\n  end\n\n  winner = check_winner(board)\n\n  if winner == 'X'\n    return 'the first player won'\n  elsif winner == '0'\n    return 'the second player won'\n  end\n\n  count_x = 0\n  count_o = 0\n\n  for i in 0..2\n    for j in 0..2\n      if board[i][j] == 'X'\n        count_x += 1\n      elsif board[i][j] == '0'\n        count_o += 1\n      end\n    end\n  end\n\n  if count_x + count_o == 9\n    return 'draw'\n  end\n\n  if count_x == count_o\n    return 'first'\n  else\n    return 'second'\n  end\nend\n\n# Read input\nboard = []\n3.times do\n  board << gets.chomp.split('')\nend\n\n# Call next_turn method and print the result\nputs next_turn(board)\n","delphi":"Here is the Delphi code for solving the tic-tac-toe problem:\n\nprogram TicTacToe;\n\nuses\n  SysUtils;\n\ntype\n  TGrid = array[1..3, 1..3] of Char;\n\nfunction ReadGrid: TGrid;\nvar\n  i, j: Integer;\nbegin\n  for i := 1 to 3 do\n  begin\n    for j := 1 to 3 do\n    begin\n      Read(Result[i, j]);\n    end;\n    ReadLn;\n  end;\nend;\n\nfunction CheckWin(grid: TGrid; player: Char): Boolean;\nvar\n  i: Integer;\nbegin\n  \/\/ Check horizontal lines\n  for i := 1 to 3 do\n  begin\n    if (grid[i, 1] = player) and (grid[i, 2] = player) and (grid[i, 3] = player) then\n      Exit(True);\n  end;\n\n  \/\/ Check vertical lines\n  for i := 1 to 3 do\n  begin\n    if (grid[1, i] = player) and (grid[2, i] = player) and (grid[3, i] = player) then\n      Exit(True);\n  end;\n\n  \/\/ Check diagonal lines\n  if (grid[1, 1] = player) and (grid[2, 2] = player) and (grid[3, 3] = player) then\n    Exit(True);\n\n  if (grid[1, 3] = player) and (grid[2, 2] = player) and (grid[3, 1] = player) then\n    Exit(True);\n\n  Result := False;\nend;\n\nfunction CountMarks(grid: TGrid; mark: Char): Integer;\nvar\n  i, j: Integer;\nbegin\n  Result := 0;\n  for i := 1 to 3 do\n  begin\n    for j := 1 to 3 do\n    begin\n      if grid[i, j] = mark then\n        Inc(Result);\n    end;\n  end;\nend;\n\nfunction IsValidGrid(grid: TGrid): Boolean;\nvar\n  countX, countO: Integer;\nbegin\n  countX := CountMarks(grid, 'X');\n  countO := CountMarks(grid, '0');\n\n  \/\/ Check if the difference in marks is 0 or 1\n  if Abs(countX - countO) > 1 then\n    Exit(False);\n\n  \/\/ Check if both players have won\n  if CheckWin(grid, 'X') and CheckWin(grid, '0') then\n    Exit(False);\n\n  \/\/ Check if the game is finished\n  if CheckWin(grid, 'X') or CheckWin(grid, '0') then\n    Exit(True);\n\n  \/\/ Check if the game is a draw\n  if countX + countO = 9 then\n    Exit(True);\n\n  Result := True;\nend;\n\nfunction GetNextPlayer(grid: TGrid): string;\nvar\n  countX, countO: Integer;\nbegin\n  countX := CountMarks(grid, 'X');\n  countO := CountMarks(grid, '0');\n\n  \/\/ Check if the game is illegal\n  if not IsValidGrid(grid) then\n    Exit('illegal');\n\n  \/\/ Check if the first player has won\n  if CheckWin(grid, 'X') then\n    Exit('the first player won');\n\n  \/\/ Check if the second player has won\n  if CheckWin(grid, '0') then\n    Exit('the second player won');\n\n  \/\/ Check if the game is a draw\n  if countX + countO = 9 then\n    Exit('draw');\n\n  \/\/ Determine whose turn is next\n  if countX = countO then\n    Exit('first')\n  else\n    Exit('second');\nend;\n\nvar\n  grid: TGrid;\n  nextPlayer: string;\nbegin\n  \/\/ Read the grid from input\n  grid := ReadGrid;\n\n  \/\/ Get the next player\n  nextPlayer := GetNextPlayer(grid);\n\n  \/\/ Print the result\n  WriteLn(nextPlayer);\nend.\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tboard := [3][3]string{}\\n\\n\\t\/\/ Read input\\n\\tfor i := 0; i < 3; i++ {\\n\\t\\tvar line string\\n\\t\\tfmt.Scanln(&line)\\n\\t\\tboard[i] = strings.Split(line, \\\"\\\")\\n\\t}\\n\\n\\t\/\/ Check for illegal board layout\\n\\tillegal := false\\n\\tcrossCount := 0\\n\\tnoughtCount := 0\\n\\n\\tfor i := 0; i < 3; i++ {\\n\\t\\tfor j := 0; j < 3; j++ {\\n\\t\\t\\tif board[i][j] == \\\"X\\\" {\\n\\t\\t\\t\\tcrossCount++\\n\\t\\t\\t} else if board[i][j] == \\\"0\\\" {\\n\\t\\t\\t\\tnoughtCount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif crossCount < noughtCount || crossCount-noughtCount > 1 {\\n\\t\\tillegal = true\\n\\t}\\n\\n\\t\/\/ Check for winning conditions\\n\\twinningPositions := [][]int{{0, 1, 2}, {3, 4, 5}, {6, 7, 8}, {0, 3, 6}, {1, 4, 7}, {2, 5, 8}, {0, 4, 8}, {2, 4, 6}}\\n\\n\\tcrossWon := false\\n\\tnoughtWon := false\\n\\n\\tfor _, pos := range winningPositions {\\n\\t\\tif board[pos[0]\/3][pos[0]%3] == \\\"X\\\" && board[pos[1]\/3][pos[1]%3] == \\\"X\\\" && board[pos[2]\/3][pos[2]%3] == \\\"X\\\" {\\n\\t\\t\\tcrossWon = true\\n\\t\\t\\tbreak\\n\\t\\t} else if board[pos[0]\/3][pos[0]%3] == \\\"0\\\" && board[pos[1]\/3][pos[1]%3] == \\\"0\\\" && board[pos[2]\/3][pos[2]%3] == \\\"0\\\" {\\n\\t\\t\\tnoughtWon = true\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Determine the verdict\\n\\tif illegal {\\n\\t\\tfmt.Println(\\\"illegal\\\")\\n\\t} else if crossWon && noughtWon {\\n\\t\\tfmt.Println(\\\"illegal\\\")\\n\\t} else if crossWon {\\n\\t\\tfmt.Println(\\\"the first player won\\\")\\n\\t} else if noughtWon {\\n\\t\\tfmt.Println(\\\"the second player won\\\")\\n\\t} else if crossCount+noughtCount == 9 {\\n\\t\\tfmt.Println(\\\"draw\\\")\\n\\t} else if crossCount > noughtCount {\\n\\t\\tfmt.Println(\\\"second\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"first\\\")\\n\\t}\\n}","Javascript":"function checkWinner(board) {\n    \/\/ Check rows\n    for (let i = 0; i < 3; i++) {\n        if (board[i][0] === board[i][1] && board[i][1] === board[i][2]) {\n            if (board[i][0] === 'X') {\n                return 'the first player won';\n            } else if (board[i][0] === '0') {\n                return 'the second player won';\n            }\n        }\n    }\n    \n    \/\/ Check columns\n    for (let i = 0; i < 3; i++) {\n        if (board[0][i] === board[1][i] && board[1][i] === board[2][i]) {\n            if (board[0][i] === 'X') {\n                return 'the first player won';\n            } else if (board[0][i] === '0') {\n                return 'the second player won';\n            }\n        }\n    }\n    \n    \/\/ Check diagonals\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2]) {\n        if (board[0][0] === 'X') {\n            return 'the first player won';\n        } else if (board[0][0] === '0') {\n            return 'the second player won';\n        }\n    }\n    \n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0]) {\n        if (board[0][2] === 'X') {\n            return 'the first player won';\n        } else if (board[0][2] === '0') {\n            return 'the second player won';\n        }\n    }\n    \n    \/\/ Check if the board is filled\n    let isFilled = true;\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (board[i][j] === '.') {\n                isFilled = false;\n                break;\n            }\n        }\n        if (!isFilled) {\n            break;\n        }\n    }\n    \n    if (isFilled) {\n        return 'draw';\n    }\n    \n    \/\/ Check if the board layout is illegal\n    let countX = 0;\n    let count0 = 0;\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (board[i][j] === 'X') {\n                countX++;\n            } else if (board[i][j] === '0') {\n                count0++;\n            }\n        }\n    }\n    \n    if (Math.abs(countX - count0) > 1) {\n        return 'illegal';\n    }\n    \n    \/\/ Determine whose turn is next\n    if (countX === count0) {\n        return 'first';\n    } else {\n        return 'second';\n    }\n}\n\n\/\/ Test case\nconst board = [\n    ['X', '0', 'X'],\n    ['.', '0', '.'],\n    ['X', '.', '.']\n];\n\nconst result = checkWinner(board);\nconsole.log(result);","Kotlin":"fun main() {\n    val grid = Array(3) { CharArray(3) }\n    for (i in 0 until 3) {\n        val line = readLine()!!\n        for (j in 0 until 3) {\n            grid[i][j] = line[j]\n        }\n    }\n    \n    val firstPlayer = 'X'\n    val secondPlayer = '0'\n    \n    fun checkWin(player: Char): Boolean {\n        \/\/ Check rows\n        for (i in 0 until 3) {\n            if (grid[i][0] == player && grid[i][1] == player && grid[i][2] == player) {\n                return true\n            }\n        }\n        \n        \/\/ Check columns\n        for (j in 0 until 3) {\n            if (grid[0][j] == player && grid[1][j] == player && grid[2][j] == player) {\n                return true\n            }\n        }\n        \n        \/\/ Check diagonals\n        if (grid[0][0] == player && grid[1][1] == player && grid[2][2] == player) {\n            return true\n        }\n        if (grid[0][2] == player && grid[1][1] == player && grid[2][0] == player) {\n            return true\n        }\n        \n        return false\n    }\n    \n    fun isBoardFull(): Boolean {\n        for (i in 0 until 3) {\n            for (j in 0 until 3) {\n                if (grid[i][j] == '.') {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n    \n    fun isValidBoard(): Boolean {\n        var countX = 0\n        var count0 = 0\n        \n        for (i in 0 until 3) {\n            for (j in 0 until 3) {\n                if (grid[i][j] == firstPlayer) {\n                    countX++\n                } else if (grid[i][j] == secondPlayer) {\n                    count0++\n                }\n            }\n        }\n        \n        if (countX < count0 || countX > count0 + 1) {\n            return false\n        }\n        \n        if (checkWin(firstPlayer) && checkWin(secondPlayer)) {\n            return false\n        }\n        \n        if (checkWin(firstPlayer) && countX == count0) {\n            return false\n        }\n        \n        if (checkWin(secondPlayer) && countX > count0) {\n            return false\n        }\n        \n        return true\n    }\n    \n    fun getNextPlayer(): String {\n        val countX = grid.flatten().count { it == firstPlayer }\n        val count0 = grid.flatten().count { it == secondPlayer }\n        \n        return if (countX == count0) {\n            if (checkWin(firstPlayer)) {\n                \"the first player won\"\n            } else if (isBoardFull()) {\n                \"draw\"\n            } else {\n                \"first\"\n            }\n        } else {\n            if (checkWin(secondPlayer)) {\n                \"the second player won\"\n            } else if (isBoardFull()) {\n                \"draw\"\n            } else {\n                \"second\"\n            }\n        }\n    }\n    \n    if (isValidBoard()) {\n        println(getNextPlayer())\n    } else {\n        println(\"illegal\")\n    }\n}","PHP":"<?php\\n\\nfunction checkBoard($board) {\\n    \/\/ Check if the board is valid\\n    if (!isValidBoard($board)) {\\n        return 'illegal';\\n    }\\n\\n    \/\/ Check if the first player won\\n    if (isPlayerWon($board, 'X')) {\\n        return 'the first player won';\\n    }\\n\\n    \/\/ Check if the second player won\\n    if (isPlayerWon($board, '0')) {\\n        return 'the second player won';\\n    }\\n\\n    \/\/ Check if it's a draw\\n    if (isDraw($board)) {\\n        return 'draw';\\n    }\\n\\n    \/\/ Determine whose turn is next\\n    $countX = countOccurrences($board, 'X');\\n    $count0 = countOccurrences($board, '0');\\n\\n    if ($countX > $count0) {\\n        return 'second';\\n    } else {\\n        return 'first';\\n    }\\n}\\n\\nfunction isValidBoard($board) {\\n    \/\/ Check if the board has exactly 3 rows\\n    if (count($board) != 3) {\\n        return false;\\n    }\\n\\n    \/\/ Check if each row has exactly 3 characters\\n    foreach ($board as $row) {\\n        if (strlen($row) != 3) {\\n            return false;\\n        }\\n    }\\n\\n    \/\/ Check if each character is either '.', 'X' or '0'\\n    foreach ($board as $row) {\\n        for ($i = 0; $i < strlen($row); $i++) {\\n            $char = $row[$i];\\n            if ($char != '.' && $char != 'X' && $char != '0') {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n\\nfunction isPlayerWon($board, $player) {\\n    \/\/ Check rows\\n    for ($i = 0; $i < 3; $i++) {\\n        if ($board[$i][0] == $player && $board[$i][1] == $player && $board[$i][2] == $player) {\\n            return true;\\n        }\\n    }\\n\\n    \/\/ Check columns\\n    for ($i = 0; $i < 3; $i++) {\\n        if ($board[0][$i] == $player && $board[1][$i] == $player && $board[2][$i] == $player) {\\n            return true;\\n        }\\n    }\\n\\n    \/\/ Check diagonals\\n    if (($board[0][0] == $player && $board[1][1] == $player && $board[2][2] == $player) ||\\n        ($board[0][2] == $player && $board[1][1] == $player && $board[2][0] == $player)) {\\n        return true;\\n    }\\n\\n    return false;\\n}\\n\\nfunction isDraw($board) {\\n    \/\/ Check if the board is filled\\n    for ($i = 0; $i < 3; $i++) {\\n        for ($j = 0; $j < 3; $j++) {\\n            if ($board[$i][$j] == '.') {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    \/\/ Check if neither player won\\n    if (!isPlayerWon($board, 'X') && !isPlayerWon($board, '0')) {\\n        return true;\\n    }\\n\\n    return false;\\n}\\n\\nfunction countOccurrences($board, $char) {\\n    $count = 0;\\n\\n    for ($i = 0; $i < 3; $i++) {\\n        for ($j = 0; $j < 3; $j++) {\\n            if ($board[$i][$j] == $char) {\\n                $count++;\\n            }\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n\/\/ Example usage\\n$board = [\\n    'X0X',\\n    '.0.',\\n    '.X.',\\n];\\n\\n$result = checkBoard($board);\\necho $result;\\n","d":"import std.stdio;\\r\\n\\r\\nstring findNextPlayer(char[][] board) {\\r\\n    int xCount = 0;\\r\\n    int oCount = 0;\\r\\n    bool xWins = false;\\r\\n    bool oWins = false;\\r\\n    bool draw = true;\\r\\n\\r\\n    \/\/ Check rows\\r\\n    for (int i = 0; i < 3; i++) {\\r\\n        if (board[i][0] == 'X' && board[i][1] == 'X' && board[i][2] == 'X') {\\r\\n            xWins = true;\\r\\n        }\\r\\n        else if (board[i][0] == '0' && board[i][1] == '0' && board[i][2] == '0') {\\r\\n            oWins = true;\\r\\n        }\\r\\n\\r\\n        if (board[i][0] == '.' || board[i][1] == '.' || board[i][2] == '.') {\\r\\n            draw = false;\\r\\n        }\\r\\n\\r\\n        xCount += count(board[i], 'X');\\r\\n        oCount += count(board[i], '0');\\r\\n    }\\r\\n\\r\\n    \/\/ Check columns\\r\\n    for (int j = 0; j < 3; j++) {\\r\\n        if (board[0][j] == 'X' && board[1][j] == 'X' && board[2][j] == 'X') {\\r\\n            xWins = true;\\r\\n        }\\r\\n        else if (board[0][j] == '0' && board[1][j] == '0' && board[2][j] == '0') {\\r\\n            oWins = true;\\r\\n        }\\r\\n\\r\\n        xCount += count([board[0][j], board[1][j], board[2][j]], 'X');\\r\\n        oCount += count([board[0][j], board[1][j], board[2][j]], '0');\\r\\n    }\\r\\n\\r\\n    \/\/ Check diagonals\\r\\n    if (board[0][0] == 'X' && board[1][1] == 'X' && board[2][2] == 'X') {\\r\\n        xWins = true;\\r\\n    }\\r\\n    else if (board[0][0] == '0' && board[1][1] == '0' && board[2][2] == '0') {\\r\\n        oWins = true;\\r\\n    }\\r\\n\\r\\n    if (board[0][2] == 'X' && board[1][1] == 'X' && board[2][0] == 'X') {\\r\\n        xWins = true;\\r\\n    }\\r\\n    else if (board[0][2] == '0' && board[1][1] == '0' && board[2][0] == '0') {\\r\\n        oWins = true;\\r\\n    }\\r\\n\\r\\n    if (xWins && oWins) {\\r\\n        return \\\"illegal\\\";\\r\\n    }\\r\\n    else if (xWins) {\\r\\n        return \\\"the first player won\\\";\\r\\n    }\\r\\n    else if (oWins) {\\r\\n        return \\\"the second player won\\\";\\r\\n    }\\r\\n    else if (draw) {\\r\\n        return \\\"draw\\\";\\r\\n    }\\r\\n    else if (xCount == oCount) {\\r\\n        return \\\"first\\\";\\r\\n    }\\r\\n    else {\\r\\n        return \\\"second\\\";\\r\\n    }\\r\\n}\\r\\n\\r\\nint count(char[] arr, char target) {\\r\\n    int count = 0;\\r\\n    foreach (char c; arr) {\\r\\n        if (c == target) {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    char[][] board;\\r\\n    foreach (string line; stdin.byLine()) {\\r\\n        board ~= line.dup;\\r\\n    }\\r\\n\\r\\n    writeln(findNextPlayer(board));\\r\\n}","perl":"\n# Read the input\nmy @grid = ();\nfor (my $i = 0; $i < 3; $i++) {\n    my $line = <STDIN>;\n    chomp $line;\n    push @grid, [split \/\/, $line];\n}\n\n# Check if the board layout is valid\nmy $xCount = 0;\nmy $oCount = 0;\nforeach my $row (@grid) {\n    foreach my $cell (@$row) {\n        if ($cell eq 'X') {\n            $xCount++;\n        } elsif ($cell eq '0') {\n            $oCount++;\n        } elsif ($cell ne '.') {\n            print 'illegal';\n            exit;\n        }\n    }\n}\n\n# Check if the game has already been won\nmy $firstPlayerWon = 0;\nmy $secondPlayerWon = 0;\n\n# Check rows\nfor (my $i = 0; $i < 3; $i++) {\n    if ($grid[$i][0] eq 'X' && $grid[$i][1] eq 'X' && $grid[$i][2] eq 'X') {\n        $firstPlayerWon = 1;\n    } elsif ($grid[$i][0] eq '0' && $grid[$i][1] eq '0' && $grid[$i][2] eq '0') {\n        $secondPlayerWon = 1;\n    }\n}\n\n# Check columns\nfor (my $i = 0; $i < 3; $i++) {\n    if ($grid[0][$i] eq 'X' && $grid[1][$i] eq 'X' && $grid[2][$i] eq 'X') {\n        $firstPlayerWon = 1;\n    } elsif ($grid[0][$i] eq '0' && $grid[1][$i] eq '0' && $grid[2][$i] eq '0') {\n        $secondPlayerWon = 1;\n    }\n}\n\n# Check diagonals\nif ($grid[0][0] eq 'X' && $grid[1][1] eq 'X' && $grid[2][2] eq 'X') {\n    $firstPlayerWon = 1;\n} elsif ($grid[0][0] eq '0' && $grid[1][1] eq '0' && $grid[2][2] eq '0') {\n    $secondPlayerWon = 1;\n}\n\nif ($grid[0][2] eq 'X' && $grid[1][1] eq 'X' && $grid[2][0] eq 'X') {\n    $firstPlayerWon = 1;\n} elsif ($grid[0][2] eq '0' && $grid[1][1] eq '0' && $grid[2][0] eq '0') {\n    $secondPlayerWon = 1;\n}\n\n# Check if the game is a draw\nmy $isDraw = ($xCount + $oCount) == 9 && !$firstPlayerWon && !$secondPlayerWon;\n\n# Determine the next player\nmy $nextPlayer;\nif ($xCount == $oCount) {\n    $nextPlayer = 'first';\n} elsif ($xCount == $oCount + 1) {\n    $nextPlayer = 'second';\n} else {\n    print 'illegal';\n    exit;\n}\n\n# Print the verdict\nif ($firstPlayerWon) {\n    print 'the first player won';\n} elsif ($secondPlayerWon) {\n    print 'the second player won';\n} elsif ($isDraw) {\n    print 'draw';\n} else {\n    print $nextPlayer;\n}\n","Rust":"fn main() {\n    let mut grid = vec![vec!['.'; 3]; 3];\n    \n    \/\/ Read input\n    let mut input = String::new();\n    for _ in 0..3 {\n        std::io::stdin().read_line(&mut input).unwrap();\n        let chars: Vec<char> = input.trim().chars().collect();\n        for (i, &c) in chars.iter().enumerate() {\n            grid[i \/ 3][i % 3] = c;\n        }\n        input.clear();\n    }\n    \n    \/\/ Check for illegal board layout\n    let mut count_x = 0;\n    let mut count_o = 0;\n    for row in &grid {\n        for &cell in row {\n            if cell == 'X' {\n                count_x += 1;\n            } else if cell == '0' {\n                count_o += 1;\n            }\n        }\n    }\n    if count_x < count_o || count_x > count_o + 1 {\n        println!(\"illegal\");\n        return;\n    }\n    \n    \/\/ Check for winning conditions\n    let rows = vec![\n        (0, 0, 0, 1, 0, 2), \/\/ First row\n        (1, 0, 1, 1, 1, 2), \/\/ Second row\n        (2, 0, 2, 1, 2, 2), \/\/ Third row\n        (0, 0, 1, 0, 2, 0), \/\/ First column\n        (0, 1, 1, 1, 2, 1), \/\/ Second column\n        (0, 2, 1, 2, 2, 2), \/\/ Third column\n        (0, 0, 1, 1, 2, 2), \/\/ Diagonal from top-left to bottom-right\n        (0, 2, 1, 1, 2, 0), \/\/ Diagonal from top-right to bottom-left\n    ];\n    \n    let mut first_won = false;\n    let mut second_won = false;\n    \n    for (r1, c1, r2, c2, r3, c3) in rows {\n        if grid[r1][c1] == 'X' && grid[r2][c2] == 'X' && grid[r3][c3] == 'X' {\n            first_won = true;\n        } else if grid[r1][c1] == '0' && grid[r2][c2] == '0' && grid[r3][c3] == '0' {\n            second_won = true;\n        }\n    }\n    \n    if first_won && second_won {\n        println!(\"illegal\");\n    } else if first_won {\n        if count_x == count_o {\n            println!(\"illegal\");\n        } else {\n            println!(\"the first player won\");\n        }\n    } else if second_won {\n        if count_x > count_o {\n            println!(\"illegal\");\n        } else {\n            println!(\"the second player won\");\n        }\n    } else if count_x + count_o == 9 {\n        println!(\"draw\");\n    } else if count_x == count_o {\n        println!(\"first\");\n    } else {\n        println!(\"second\");\n    }\n}"}
{"title":"D. Minesweeper 1D","description":"Game \"Minesweeper 1D\" is played on a line of squares, the line's height is 1 square, the line's width is n squares. Some of the squares contain bombs. If a square doesn't contain a bomb, then it contains a number from 0 to 2 \u2014 the total number of bombs in adjacent squares.For example, the correct field to play looks like that: 001*2***101*. The cells that are marked with \"*\" contain bombs. Note that on the correct field the numbers represent the number of bombs in adjacent cells. For example, field 2* is not correct, because cell with value 2 must have two adjacent cells with bombs.Valera wants to make a correct field to play \"Minesweeper 1D\". He has already painted a squared field with width of n cells, put several bombs on the field and wrote numbers into some cells. Now he wonders how many ways to fill the remaining cells with bombs and numbers are there if we should get a correct field in the end.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"512 megabytes","input_spec":"The first line contains sequence of characters without spaces s1s2... sn (1\u2264n\u226410^6), containing only characters \"*\", \"?\" and digits \"0\", \"1\" or \"2\". If character si equals \"*\", then the i-th cell of the field contains a bomb. If character si equals \"?\", then Valera hasn't yet decided what to put in the i-th cell. Character si, that is equal to a digit, represents the digit written in the i-th square.\n","output_spec":"Print a single integer \u2014 the number of ways Valera can fill the empty cells and get a correct field.\nAs the answer can be rather large, print it modulo 1000000007 (10^9+7).\n","notes":"In the first test sample you can get the following correct fields: 001**1, 001***, 001*2*, 001*10.\n","sample_inputs":["?01???\n","?\n","**12\n","1\n"],"sample_outputs":["4\n","2\n","0\n","0\n"],"id":"404-D","difficulty":1900,"tags":["dp","implementation"],"src_uid":"c16c49baf7b2d179764871204475036e","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    string s;\\n    cin >> s;\\n    int n = s.size();\\n    vector<long long> dp(n + 1);\\n    dp[0] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        if (s[i - 1] == '?' || s[i - 1] == '0') {\\n            dp[i] = dp[i - 1];\\n        }\\n        if (s[i - 1] == '?' || s[i - 1] == '1') {\\n            dp[i] += dp[i - 1];\\n        }\\n        if (i > 1 && (s[i - 2] == '?' || s[i - 2] == '2') && (s[i - 1] == '?' || s[i - 1] == '*')) {\\n            dp[i] += dp[i - 2];\\n        }\\n        dp[i] %= MOD;\\n    }\\n    cout << dp[n] << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Minesweeper1D {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        int n = input.length();\\n        int mod = 1000000007;\\n\\n        long[] dp = new long[n + 1];\\n        dp[0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (input.charAt(i - 1) == '?') {\\n                dp[i] = (dp[i - 1] * 2) % mod;\\n            } else {\\n                dp[i] = dp[i - 1];\\n            }\\n\\n            if (input.charAt(i - 1) == '2' || input.charAt(i - 1) == '*') {\\n                if (i >= 2) {\\n                    dp[i] = (dp[i] + dp[i - 2]) % mod;\\n                }\\n            }\\n\\n            if (input.charAt(i - 1) == '1' || input.charAt(i - 1) == '*') {\\n                if (i >= 3) {\\n                    dp[i] = (dp[i] + dp[i - 3]) % mod;\\n                }\\n            }\\n        }\\n\\n        System.out.println(dp[n]);\\n    }\\n}","Python":"def count_ways(s):\n    MOD = 1000000007\n    n = len(s)\n    dp = [[0] * 3 for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        if s[i - 1] == '*':\n            dp[i][0] = dp[i - 1][0]\n            dp[i][1] = dp[i - 1][1]\n            dp[i][2] = dp[i - 1][2]\n        elif s[i - 1] == '?':\n            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % MOD\n            dp[i][1] = dp[i - 1][0]\n            dp[i][2] = dp[i - 1][1]\n        else:\n            dp[i][int(s[i - 1])] = (dp[i - 1][int(s[i - 1])] + dp[i - 1][(int(s[i - 1]) + 1) % 3] + dp[i - 1][(int(s[i - 1]) + 2) % 3]) % MOD\n\n    return str(dp[n][0])\n\n# Sample Inputs\ninputs = ['?01???', '?', '**12', '1']\n\n# Processing each input and generating output\noutputs = []\nfor input_str in inputs:\n    output_str = count_ways(input_str)\n    outputs.append(output_str)\n\n# Printing the outputs in JSON format\nimport json\nprint(json.dumps(outputs))","C":"#include <stdio.h>\\n#include <string.h>\\n\\n#define MOD 1000000007\\n\\nint main() {\\n    char s[1000005];\\n    scanf(\\\"%s\\\", s);\\n    int n = strlen(s);\\n    long long int dp[n+1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n    for(int i=2; i<=n; i++) {\\n        if(s[i-1] == '?') {\\n            dp[i] = (dp[i-1]*2)%MOD;\\n        }\\n        else if(s[i-1] == '*') {\\n            dp[i] = dp[i-1];\\n            if(s[i-2] == '?') {\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n        }\\n        else {\\n            dp[i] = dp[i-1];\\n            if(s[i-2] == '?' || s[i-2] == '*') {\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n        }\\n    }\\n    printf(\\\"%lld\\\\n\\\", dp[n]);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string input = Console.ReadLine();\n        int n = input.Length;\n        int mod = 1000000007;\n        \n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n        \n        for (int i = 1; i <= n; i++)\n        {\n            if (input[i - 1] == '?')\n            {\n                dp[i] = (dp[i - 1] * 3) % mod;\n            }\n            else if (input[i - 1] == '*')\n            {\n                dp[i] = (dp[i - 1] * 2) % mod;\n            }\n            else\n            {\n                dp[i] = dp[i - 1];\n            }\n        }\n        \n        Console.WriteLine(dp[n]);\n    }\n}","Ruby":"\nMOD = 1000000007\n\ndef count_ways(field)\n  n = field.length\n  dp = Array.new(n+1, 0)\n  dp[0] = 1\n\n  (1..n).each do |i|\n    if field[i-1] == \"?\"\n      dp[i] = (dp[i] + dp[i-1] * 2) % MOD\n    end\n\n    if field[i-1] == \"0\" || field[i-1] == \"?\"\n      dp[i] = (dp[i] + dp[i-1]) % MOD\n    end\n\n    if i > 1 && (field[i-2] == \"1\" || field[i-2] == \"?\") && (field[i-1] == \"1\" || field[i-1] == \"?\")\n      dp[i] = (dp[i] + dp[i-2]) % MOD\n    end\n\n    if i > 1 && (field[i-2] == \"2\" || field[i-2] == \"?\") && (field[i-1] == \"2\" || field[i-1] == \"?\")\n      dp[i] = (dp[i] + dp[i-2]) % MOD\n    end\n  end\n\n  return dp[n]\nend\n\ninputs = ['?01???\\n', '?\\n', '**12\\n', '1\\n']\noutputs = []\n\ninputs.each do |input|\n  field = input.strip\n  ways = count_ways(field)\n  outputs << ways.to_s + \"\\n\"\nend\n\nputs outputs\n","delphi":"Here is the Delphi code for solving the Minesweeper 1D problem:\n\nprogram Minesweeper1D;\n\nconst\n  MOD = 1000000007;\n\nfunction CountWays(s: string): Int64;\nvar\n  n, i: Integer;\n  dp: array of Int64;\nbegin\n  n := Length(s);\n  SetLength(dp, n + 1);\n  \n  dp[0] := 1;\n  for i := 1 to n do\n  begin\n    if s[i] = '?' then\n    begin\n      dp[i] := (dp[i - 1] * 2) mod MOD;\n    end\n    else if s[i] = '*' then\n    begin\n      dp[i] := dp[i - 1];\n    end\n    else\n    begin\n      dp[i] := dp[i - 1];\n      if (i > 1) and (s[i - 1] = '?') then\n      begin\n        if s[i] = '0' then\n          dp[i] := (dp[i] + dp[i - 2]) mod MOD\n        else if s[i] = '1' then\n          dp[i] := (dp[i] + dp[i - 2] * 2) mod MOD\n        else if s[i] = '2' then\n          dp[i] := (dp[i] + dp[i - 2] * 3) mod MOD;\n      end;\n    end;\n  end;\n  \n  Result := dp[n];\nend;\n\nvar\n  s: string;\nbegin\n  ReadLn(s);\n  WriteLn(CountWays(s));\nend.\n","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nconst mod = 1000000007\\n\\nfunc main() {\\n\\treader := bufio.NewReader(os.Stdin)\\n\\ts, _ := reader.ReadString('\\\\n')\\n\\ts = strings.TrimSpace(s)\\n\\n\\tn := len(s)\\n\\n\\tdp := make([]int, n+1)\\n\\tdp[0] = 1\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif s[i-1] == '?' {\\n\\t\\t\\tdp[i] = (dp[i-1] * 2) % mod\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = dp[i-1]\\n\\t\\t}\\n\\n\\t\\tif s[i-1] == '*' || s[i-1] == '?' {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif i > 1 && s[i-2] != '*' && s[i-2] != '?' {\\n\\t\\t\\tif s[i-1] == '0' {\\n\\t\\t\\t\\tdp[i] = dp[i-2]\\n\\t\\t\\t} else if s[i-2] == '1' && s[i-1] == '1' {\\n\\t\\t\\t\\tdp[i] = (dp[i] + dp[i-2]) % mod\\n\\t\\t\\t} else if s[i-2] == '2' && s[i-1] == '2' {\\n\\t\\t\\t\\tdp[i] = (dp[i] + dp[i-2]) % mod\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(dp[n])\\n}","Javascript":"function countWaysToFillField(s) {\n    const MOD = 1000000007;\n    const n = s.length;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        if (s[i - 1] === '?') {\n            dp[i] = (dp[i] + dp[i - 1] * 2) % MOD;\n        } else if (s[i - 1] === '*') {\n            dp[i] = dp[i - 1];\n        }\n        \n        if (i > 1 && s[i - 2] !== '*' && s[i - 2] !== '?') {\n            if (s[i - 1] === '?' || s[i - 1] === s[i - 2]) {\n                dp[i] = (dp[i] + dp[i - 2]) % MOD;\n            }\n        }\n    }\n    \n    return dp[n];\n}\n\n\/\/ Test cases\nconsole.log(countWaysToFillField('?01???')); \/\/ Output: 4\nconsole.log(countWaysToFillField('?')); \/\/ Output: 2\nconsole.log(countWaysToFillField('**12')); \/\/ Output: 0\nconsole.log(countWaysToFillField('1')); \/\/ Output: 0","Kotlin":"fun main() {\\n    val input = readLine()!!.trim()\\n    val n = input.length\\n    val mod = 1000000007\\n\\n    var count = 1L\\n    var prev = 0L\\n\\n    for (i in 0 until n) {\\n        val c = input[i]\\n\\n        if (c == '?') {\\n            count = (count * 2) % mod\\n        } else if (c.isDigit()) {\\n            val num = c.toString().toLong()\\n\\n            if (num < prev) {\\n                count = 0\\n                break\\n            }\\n\\n            prev = num\\n        }\\n    }\\n\\n    println(count)\\n}","PHP":"<?php\\n\\nfunction countWays($input) {\\n    $s = trim($input);\\n    $n = strlen($s);\\n    $mod = 1000000007;\\n    $dp = array_fill(0, $n + 1, 0);\\n    $dp[0] = 1;\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        if ($s[$i - 1] == '?') {\\n            $dp[$i] = ($dp[$i] + $dp[$i - 1] * 2) % $mod;\\n        }\\n\\n        if ($s[$i - 1] == '0' || $s[$i - 1] == '?') {\\n            $dp[$i] = ($dp[$i] + $dp[$i - 1]) % $mod;\\n        }\\n\\n        if ($i > 1 && ($s[$i - 2] == '1' || $s[$i - 2] == '?') && ($s[$i - 1] == '1' || $s[$i - 1] == '?')) {\\n            $dp[$i] = ($dp[$i] + $dp[$i - 2]) % $mod;\\n        }\\n\\n        if ($i > 1 && ($s[$i - 2] == '2' || $s[$i - 2] == '?') && ($s[$i - 1] == '2' || $s[$i - 1] == '?')) {\\n            $dp[$i] = ($dp[$i] + $dp[$i - 2]) % $mod;\\n        }\\n    }\\n\\n    return $dp[$n];\\n}\\n\\n$input = readline();\\necho countWays($input);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint countWays(string field)\\r\\n{\\r\\n    int n = field.length;\\r\\n    int[] dp = new int[n + 1];\\r\\n    dp[0] = 1;\\r\\n    dp[1] = 1;\\r\\n\\r\\n    for (int i = 2; i <= n; i++)\\r\\n    {\\r\\n        if (field[i - 1] == '?')\\r\\n        {\\r\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\\r\\n        }\\r\\n        else if (field[i - 1] == '0' || field[i - 1] == '2')\\r\\n        {\\r\\n            dp[i] = dp[i - 2];\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            dp[i] = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return dp[n];\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\r\\n        \\\"?01???\\\",\\r\\n        \\\"?\\\",\\r\\n        \\\"**12\\\",\\r\\n        \\\"1\\\"\\r\\n    ];\\r\\n\\r\\n    int[] outputs = [\\r\\n        4,\\r\\n        2,\\r\\n        0,\\r\\n        0\\r\\n    ];\\r\\n\\r\\n    foreach (i, input; inputs)\\r\\n    {\\r\\n        int result = countWays(input);\\r\\n        assert(result == outputs[i]);\\r\\n        writeln(result);\\r\\n    }\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub count_ways {\n    my ($field) = @_;\n    my $n = length($field);\n    my @dp;\n    $dp[0] = 1;\n    for (my $i = 1; $i <= $n; $i++) {\n        if (substr($field, $i-1, 1) eq '?') {\n            $dp[$i] = ($dp[$i-1] * 2) % 1000000007;\n        } else {\n            $dp[$i] = $dp[$i-1];\n        }\n        if ($i > 1 && substr($field, $i-2, 2) =~ \/(\\d)\\?\/) {\n            my $prev = $1;\n            if ($prev == 1 || $prev == 2) {\n                $dp[$i] = ($dp[$i] + $dp[$i-2]) % 1000000007;\n            }\n        }\n    }\n    return $dp[$n];\n}\n\nmy $input = <STDIN>;\nchomp($input);\nmy $result = count_ways($input);\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"?01???\\\";\\n    let mut count = 1;\\n    let mut prev = 0;\\n    let mut prev_prev = 0;\\n\\n    for c in input.chars() {\\n        match c {\\n            '?' => {\\n                count = (count * 3) % 1000000007;\\n                count = (count + prev_prev) % 1000000007;\\n                prev_prev = prev;\\n                prev = count;\\n            }\\n            '0' => {\\n                if prev != 0 {\\n                    count = 0;\\n                }\\n            }\\n            '1' => {\\n                if prev == 0 {\\n                    count = 0;\\n                }\\n            }\\n            '2' => {\\n                if prev == 0 || prev_prev == 0 {\\n                    count = 0;\\n                }\\n            }\\n            _ => {}\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"B. Domino Effect","description":"Little Chris knows there's no fun in playing dominoes, he thinks it's too random and doesn't require skill. Instead, he decided to play with the dominoes and make a \"domino show\".Chris arranges n dominoes in a line, placing each piece vertically upright. In the beginning, he simultaneously pushes some of the dominoes either to the left or to the right. However, somewhere between every two dominoes pushed in the same direction there is at least one domino pushed in the opposite direction.After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. The figure shows one possible example of the process. Given the initial directions Chris has pushed the dominoes, find the number of the dominoes left standing vertically at the end of the process!","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer n (1\u2264n\u22643000), the number of the dominoes in the line. The next line contains a character string s of length n. The i-th character of the string si is equal to \n  \"L\", if the i-th domino has been pushed to the left;  \"R\", if the i-th domino has been pushed to the right;  \".\", if the i-th domino has not been pushed. It is guaranteed that if si=sj=\"L\" and i<j, then there exists such k that i<k<j and sk=\"R\"; if si=sj=\"R\" and i<j, then there exists such k that i<k<j and sk=\"L\".\n","output_spec":"Output a single integer, the number of the dominoes that remain vertical at the end of the process.\n","notes":"The first example case is shown on the figure. The four pieces that remain standing vertically are highlighted with orange.\nIn the second example case, all pieces fall down since the first piece topples all the other pieces.\nIn the last example case, a single piece has not been pushed in either direction.\n","sample_inputs":["14\n.L.R...LR..L..\n","5\nR....\n","1\n.\n"],"sample_outputs":["4\n","0\n","1\n"],"id":"405-B","difficulty":1100,"tags":[],"src_uid":"54c748dd983b6a0ea1af1153d08f1c01","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    string s;\\n    cin >> s;\\n\\n    int count = 0;\\n    int left = -1;\\n    int right = -1;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == 'L') {\\n            if (right != -1) {\\n                count += (i - right) \/ 2;\\n            }\\n            count += i - left - 1;\\n            left = i;\\n            right = -1;\\n        } else if (s[i] == 'R') {\\n            if (left != -1) {\\n                count += (i - left) \/ 2;\\n            }\\n            left = -1;\\n            right = i;\\n        }\\n    }\\n\\n    if (left != -1) {\\n        count += (n - left - 1);\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class DominoShow {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.nextLine();\\n        String s = scanner.nextLine();\\n\\n        int[] leftFall = new int[n];\\n        int[] rightFall = new int[n];\\n\\n        int leftCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == 'L') {\\n                leftCount = 1;\\n            } else if (s.charAt(i) == 'R') {\\n                leftCount = 0;\\n            }\\n            leftFall[i] = leftCount;\\n        }\\n\\n        int rightCount = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s.charAt(i) == 'R') {\\n                rightCount = 1;\\n            } else if (s.charAt(i) == 'L') {\\n                rightCount = 0;\\n            }\\n            rightFall[i] = rightCount;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (leftFall[i] == 1 && rightFall[i] == 1) {\\n                count++;\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}","Python":"def count_vertical_dominoes(n, s):\n    left = [0] * n\n    right = [0] * n\n\n    # Count the number of dominoes falling to the left\n    for i in range(1, n):\n        if s[i] == 'L':\n            left[i] = 1\n        elif s[i] == '.':\n            left[i] = left[i-1] if left[i-1] > 0 else 0\n\n    # Count the number of dominoes falling to the right\n    for i in range(n-2, -1, -1):\n        if s[i] == 'R':\n            right[i] = 1\n        elif s[i] == '.':\n            right[i] = right[i+1] if right[i+1] > 0 else 0\n\n    # Count the number of vertical dominoes\n    count = 0\n    for i in range(n):\n        if s[i] == '.' and left[i] > 0 and right[i] > 0:\n            count += 1\n\n    return count\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the number of vertical dominoes\nprint(count_vertical_dominoes(n, s))","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    char s[n+1];\\n    scanf(\\\"%s\\\", s);\\n    int left[n], right[n];\\n    memset(left, 0, sizeof(left));\\n    memset(right, 0, sizeof(right));\\n\\n    for (int i = 1; i < n; i++) {\\n        if (s[i-1] == 'R') {\\n            right[i] = 1;\\n        }\\n        if (s[i] == 'L') {\\n            left[i] = 1;\\n        }\\n    }\\n\\n    for (int i = n-2; i >= 0; i--) {\\n        if (s[i+1] == 'L') {\\n            left[i] = left[i+1] + 1;\\n        }\\n    }\\n\\n    for (int i = 1; i < n; i++) {\\n        if (s[i-1] == 'R') {\\n            right[i] = right[i-1] + 1;\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == '.') {\\n            printf(\\\".\\\");\\n        } else if (left[i] == 0 && right[i] == 0) {\\n            printf(\\\"|\\\");\\n        } else if (left[i] == 0) {\\n            printf(\\\"R\\\");\\n        } else if (right[i] == 0) {\\n            printf(\\\"L\\\");\\n        } else if (left[i] < right[i]) {\\n            printf(\\\"L\\\");\\n        } else {\\n            printf(\\\"R\\\");\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\n\npublic class DominoShow\n{\n    public static int CountVerticalDominoes(int n, string s)\n    {\n        int count = 0;\n        int[] leftFall = new int[n];\n        int[] rightFall = new int[n];\n\n        \/\/ Calculate the number of dominoes falling to the left\n        int leftCount = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (s[i] == 'L')\n            {\n                leftCount = 1;\n            }\n            else if (s[i] == 'R')\n            {\n                leftCount = 0;\n            }\n            leftFall[i] = leftCount;\n        }\n\n        \/\/ Calculate the number of dominoes falling to the right\n        int rightCount = 0;\n        for (int i = n - 1; i >= 0; i--)\n        {\n            if (s[i] == 'R')\n            {\n                rightCount = 1;\n            }\n            else if (s[i] == 'L')\n            {\n                rightCount = 0;\n            }\n            rightFall[i] = rightCount;\n        }\n\n        \/\/ Count the number of vertical dominoes\n        for (int i = 0; i < n; i++)\n        {\n            if (leftFall[i] == 0 && rightFall[i] == 0)\n            {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void Main(string[] args)\n    {\n        int n = Convert.ToInt32(Console.ReadLine());\n        string s = Console.ReadLine();\n\n        int result = CountVerticalDominoes(n, s);\n        Console.WriteLine(result);\n    }\n}\n","Ruby":"def domino_show(n, s)\n  dominoes = s.split('')\n  standing = Array.new(n, false)\n  \n  # Check for dominoes falling to the left\n  i = 0\n  while i < n\n    if dominoes[i] == 'L'\n      j = i - 1\n      while j >= 0 && (dominoes[j] == '.' || dominoes[j] == 'R')\n        standing[j] = true\n        j -= 1\n      end\n    end\n    i += 1\n  end\n  \n  # Check for dominoes falling to the right\n  i = n - 1\n  while i >= 0\n    if dominoes[i] == 'R'\n      j = i + 1\n      while j < n && (dominoes[j] == '.' || dominoes[j] == 'L')\n        standing[j] = true\n        j += 1\n      end\n    end\n    i -= 1\n  end\n  \n  standing.count(true)\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\ns = input[1]\n\noutput = domino_show(n, s)\nputs output","delphi":"program DominoShow;\\n\\nvar\\n  n: Integer;\\n  s: string;\\n  count: Integer;\\n  i: Integer;\\n  left: Integer;\\n  right: Integer;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(n);\\n  ReadLn(s);\\n\\n  \/\/ Initialize variables\\n  count := 0;\\n  left := 0;\\n  right := 0;\\n\\n  \/\/ Count the number of dominoes left standing\\n  for i := 1 to n do\\n  begin\\n    if s[i] = 'L' then\\n    begin\\n      left := 1;\\n      right := 0;\\n    end\\n    else if s[i] = 'R' then\\n    begin\\n      left := 0;\\n      right := 1;\\n    end\\n    else if s[i] = '.' then\\n    begin\\n      if left > 0 then\\n      begin\\n        left := left + 1;\\n        count := count + 1;\\n      end\\n      else if right > 0 then\\n      begin\\n        right := right + 1;\\n        count := count + 1;\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Print the result\\n  WriteLn(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tvar s string\\n\\n\\tfmt.Scan(&n)\\n\\tfmt.Scan(&s)\\n\\n\\tleftFall := make([]int, n)\\n\\trightFall := make([]int, n)\\n\\n\\tfallingLeft := false\\n\\tfallingRight := false\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif s[i] == 'L' {\\n\\t\\t\\tfallingLeft = true\\n\\t\\t\\tfallingRight = false\\n\\t\\t} else if s[i] == 'R' {\\n\\t\\t\\tfallingLeft = false\\n\\t\\t\\tfallingRight = true\\n\\t\\t} else {\\n\\t\\t\\tfallingLeft = false\\n\\t\\t\\tfallingRight = false\\n\\t\\t}\\n\\n\\t\\tif fallingLeft {\\n\\t\\t\\tleftFall[i] = 1\\n\\t\\t} else if i > 0 {\\n\\t\\t\\tleftFall[i] = leftFall[i-1]\\n\\t\\t}\\n\\n\\t\\tif fallingRight {\\n\\t\\t\\trightFall[i] = 1\\n\\t\\t} else if i > 0 {\\n\\t\\t\\trightFall[i] = rightFall[i-1]\\n\\t\\t}\\n\\t}\\n\\n\\tresult := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif leftFall[i] > 0 && rightFall[n-1] > 0 {\\n\\t\\t\\tresult[i] = \\\"L\\\"\\n\\t\\t} else if leftFall[n-1] > 0 && rightFall[i] > 0 {\\n\\t\\t\\tresult[i] = \\\"R\\\"\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = \\\".\\\"\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(strings.Join(result, \\\"\\\"))\\n}","Javascript":"function countVerticalDominoes(n, s) {\n  let count = 0;\n  let standing = 0;\n  \n  for (let i = 0; i < n; i++) {\n    if (s[i] === 'L') {\n      count = 0;\n      standing++;\n    } else if (s[i] === 'R') {\n      standing = 0;\n    } else {\n      count++;\n      if (count > 0) {\n        standing++;\n      }\n    }\n  }\n  \n  return standing;\n}\n\nconst input = '14\\n.L.R...LR..L..\\n';\nconst lines = input.split('\\\\n');\nconst n = parseInt(lines[0]);\nconst s = lines[1];\n\nconst result = countVerticalDominoes(n, s);\nconsole.log(result);","Kotlin":"fun countVerticalDominoes(n: Int, s: String): Int {\n    var count = 0\n    var standing = 0\n    var fallingLeft = false\n    \n    for (i in 0 until n) {\n        if (s[i] == 'L') {\n            fallingLeft = true\n            standing = 0\n        } else if (s[i] == 'R') {\n            fallingLeft = false\n            standing = 0\n        } else {\n            if (fallingLeft) {\n                standing++\n            }\n        }\n        \n        if (fallingLeft && standing > 0) {\n            count++\n        }\n    }\n    \n    return count\n}\n\nfun main() {\n    val input = readLine()!!.split(\"\\\\n\")\n    val n = input[0].toInt()\n    val s = input[1]\n    \n    val result = countVerticalDominoes(n, s)\n    println(result)\n}","PHP":"<?php\\n\\nfunction countVerticalDominoes($n, $s) {\\n    $count = 0;\\n    $fallingLeft = false;\\n    $fallingRight = false;\\n    \\n    for ($i = 0; $i < $n; $i++) {\\n        if ($s[$i] == 'L') {\\n            $fallingLeft = true;\\n            $fallingRight = false;\\n        } elseif ($s[$i] == 'R') {\\n            $fallingRight = true;\\n            $fallingLeft = false;\\n        } elseif ($s[$i] == '.') {\\n            if ($fallingLeft) {\\n                $fallingLeft = false;\\n                $count++;\\n            } elseif ($fallingRight) {\\n                $fallingRight = false;\\n                $count++;\\n            }\\n        }\\n    }\\n    \\n    return $count;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$n = intval($input[0]);\\n$s = $input[1];\\n\\n$result = countVerticalDominoes($n, $s);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nint countVerticalDominoes(int n, string s) {\\r\\n    int count = 0;\\r\\n    int[] left = new int[n];\\r\\n    int[] right = new int[n];\\r\\n\\r\\n    int lastLeft = -1;\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (s[i] == 'L') {\\r\\n            lastLeft = i;\\r\\n        }\\r\\n        if (s[i] == 'R') {\\r\\n            lastLeft = -1;\\r\\n        }\\r\\n        left[i] = lastLeft;\\r\\n    }\\r\\n\\r\\n    int lastRight = -1;\\r\\n    for (int i = n - 1; i >= 0; i--) {\\r\\n        if (s[i] == 'R') {\\r\\n            lastRight = i;\\r\\n        }\\r\\n        if (s[i] == 'L') {\\r\\n            lastRight = -1;\\r\\n        }\\r\\n        right[i] = lastRight;\\r\\n    }\\r\\n\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (s[i] == '.') {\\r\\n            if (left[i] == -1 && right[i] == -1) {\\r\\n                count++;\\r\\n            } else if (left[i] == -1) {\\r\\n                if (right[i] - i > 1) {\\r\\n                    count++;\\r\\n                }\\r\\n            } else if (right[i] == -1) {\\r\\n                if (i - left[i] > 1) {\\r\\n                    count++;\\r\\n                }\\r\\n            } else {\\r\\n                if (right[i] - i > 1 && i - left[i] > 1) {\\r\\n                    count++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    string s;\\r\\n    readf(\\\"%d\\\\n\\\", &n);\\r\\n    readf(\\\"%s\\\\n\\\", &s);\\r\\n\\r\\n    int result = countVerticalDominoes(n, s);\\r\\n    writef(\\\"%d\\\\n\\\", result);\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub count_vertical_dominoes {\n    my ($n, $s) = @_;\n\n    my @dominoes = split('', $s);\n    my $count = 0;\n\n    for (my $i = 0; $i < $n; $i++) {\n        if ($dominoes[$i] eq '.') {\n            $count++;\n        } elsif ($dominoes[$i] eq 'L') {\n            if ($i > 0 && $dominoes[$i-1] eq '.') {\n                $dominoes[$i-1] = 'L';\n                $count++;\n            }\n        } elsif ($dominoes[$i] eq 'R') {\n            if ($i < $n-1 && $dominoes[$i+1] eq '.') {\n                $dominoes[$i+1] = 'R';\n                $count++;\n            }\n        }\n    }\n\n    return $count;\n}\n\n# Read input\nmy $n = <STDIN>;\nchomp($n);\nmy $s = <STDIN>;\nchomp($s);\n\n# Call the function and print the result\nmy $result = count_vertical_dominoes($n, $s);\nprint $result;\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let lines: Vec<&str> = input.lines().collect();\n    \n    let n: usize = lines[0].trim().parse().unwrap();\n    let s: Vec<char> = lines[1].chars().collect();\n    \n    let mut dominoes: Vec<char> = vec!['.'; n];\n    \n    let mut left = false;\n    let mut right = false;\n    \n    for i in 0..n {\n        if s[i] == 'L' {\n            dominoes[i] = 'L';\n            left = true;\n            right = false;\n        } else if s[i] == 'R' {\n            dominoes[i] = 'R';\n            left = false;\n            right = true;\n        } else if left {\n            dominoes[i] = 'L';\n        } else if right {\n            dominoes[i] = 'R';\n        }\n    }\n    \n    for i in (0..n).rev() {\n        if dominoes[i] == 'L' && right {\n            dominoes[i] = '.';\n        } else if dominoes[i] == 'R' && left {\n            dominoes[i] = '.';\n        } else if dominoes[i] == 'L' {\n            left = true;\n            right = false;\n        } else if dominoes[i] == 'R' {\n            left = false;\n            right = true;\n        }\n    }\n    \n    let count = dominoes.iter().filter(|&x| *x == '.').count();\n    \n    println!(\"{}\", count);\n}"}
{"title":"C. Berland Square","description":"Last year the world's largest square was built in Berland. It is known that the square can be represented as an infinite plane with an introduced Cartesian system of coordinates. On that square two sets of concentric circles were painted. Let's call the set of concentric circles with radii 1,2,...,K and the center in the point (z,0) a (K,z)-set. Thus, on the square were painted a (N,x)-set and a (M,y)-set. You have to find out how many parts those sets divided the square into.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains integers N,x,M,y. (1\u2264N,M\u2264100000,-100000\u2264x,y\u2264100000,x\u2260y).\n","output_spec":"Print the sought number of parts.\n","notes":"Picture for the third sample:\n \n","sample_inputs":["1 0 1 1\n","1 0 1 2\n","3 3 4 7\n"],"sample_outputs":["4\n","3\n","17\n"],"id":"40-C","difficulty":2300,"tags":["implementation","math"],"src_uid":"ebaf9444531bb6ba6c3322dfa8edb69c","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int N, x, M, y;\\n    cin >> N >> x >> M >> y;\\n\\n    int parts = 1;\\n\\n    for (int i = 1; i <= N; i++) {\\n        double radius = sqrt(i * i + x * x);\\n        if (radius <= M) {\\n            parts++;\\n        }\\n    }\\n\\n    cout << parts << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        int N = Integer.parseInt(input[0]);\\n        int x = Integer.parseInt(input[1]);\\n        int M = Integer.parseInt(input[2]);\\n        int y = Integer.parseInt(input[3]);\\n\\n        int parts = 1;\\n        if (x != y) {\\n            parts += N + M;\\n        }\\n\\n        System.out.println(parts);\\n    }\\n}","Python":"def count_parts(N, x, M, y):\\n    # Calculate the number of parts\\n    parts = (N + 1) * (M + 1)\\n    return str(parts)\\n\\n\\n# Read input\\ninput_data = input().split()\\nN, x, M, y = map(int, input_data)\\n\\n# Call the function and print the result\\nresult = count_parts(N, x, M, y)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int N, x, M, y;\\n    scanf(\\\"%d %d %d %d\\\", &N, &x, &M, &y);\\n\\n    int parts = 1;\\n\\n    if (x != y) {\\n        parts += N + M;\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", parts);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace SquareDivision\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = { \\\"1 0 1 1\\\", \\\"1 0 1 2\\\", \\\"3 3 4 7\\\" };\n            \n            foreach (string input in inputs)\n            {\n                string[] values = input.Split(' ');\n                int N = int.Parse(values[0]);\n                int x = int.Parse(values[1]);\n                int M = int.Parse(values[2]);\n                int y = int.Parse(values[3]);\n                \n                int parts = CountSquareParts(N, x, M, y);\n                Console.WriteLine(parts);\n            }\n        }\n        \n        static int CountSquareParts(int N, int x, int M, int y)\n        {\n            int parts = 1;\n            \n            if (x != y)\n            {\n                parts += N + M;\n            }\n            \n            return parts;\n        }\n    }\n}\n","Ruby":"\ndef count_parts(N, x, M, y)\n  # Calculate the number of parts using the formula:\n  # parts = (N + 1) * (M + 1)\n  parts = (N + 1) * (M + 1)\n  \n  # Subtract the overlapping parts if x and y are not equal\n  if x != y\n    parts -= 1\n  end\n  \n  return parts\nend\n\n# Read input from standard input\ninput = gets.chomp.split(' ')\nN = input[0].to_i\nx = input[1].to_i\nM = input[2].to_i\ny = input[3].to_i\n\n# Call the count_parts function and print the result\nputs count_parts(N, x, M, y)\n","delphi":"program SquareParts;\\n\\nvar\\n  N, x, M, y: Integer;\\n  parts: Integer;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(N, x, M, y);\\n\\n  \/\/ Calculate the number of parts\\n  parts := (N + 1) * (M + 1);\\n\\n  \/\/ Print the result\\n  WriteLn(parts);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar N, x, M, y int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &N, &x, &M, &y)\\n\\n\\tnumParts := countParts(N, x, M, y)\\n\\tfmt.Println(numParts)\\n}\\n\\nfunc countParts(N, x, M, y int) int {\\n\\tvar numParts int\\n\\n\\tif N == M {\\n\\t\\tif x == y {\\n\\t\\t\\tnumParts = 1\\n\\t\\t} else {\\n\\t\\t\\tnumParts = 2\\n\\t\\t}\\n\\t} else {\\n\\t\\tnumParts = int(math.Abs(float64(N - M))) + 1\\n\\t}\\n\\n\\treturn numParts\\n}","Javascript":"function countParts(input) {\n  const [N, x, M, y] = input.split(' ').map(Number);\n  \n  \/\/ Calculate the number of parts\n  const parts = (N * M) + (Math.abs(N - M) * 2) + 1;\n  \n  return parts.toString();\n}\n\nconst inputs = ['1 0 1 1\\n', '1 0 1 2\\n', '3 3 4 7\\n'];\nconst outputs = inputs.map(countParts);\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val n = input[0]\n    val x = input[1]\n    val m = input[2]\n    val y = input[3]\n    \n    val parts = mutableSetOf<Pair<Int, Int>>()\n    \n    \/\/ Add the (N, x)-set\n    for (i in 1..n) {\n        parts.add(Pair(i + x, 0))\n    }\n    \n    \/\/ Add the (M, y)-set\n    for (i in 1..m) {\n        parts.add(Pair(i + y, 0))\n    }\n    \n    \/\/ Calculate the number of parts\n    var count = 0\n    for (i in parts) {\n        if (!parts.contains(Pair(i.first - 1, 0))) {\n            count++\n        }\n        if (!parts.contains(Pair(i.first + 1, 0))) {\n            count++\n        }\n    }\n    \n    println(count)\n}","PHP":"\n<?php\n\nfunction countParts($N, $x, $M, $y) {\n    \/\/ Calculate the number of parts using the formula:\n    \/\/ parts = (N + 1) * (M + 1)\n    $parts = ($N + 1) * ($M + 1);\n    \n    return $parts;\n}\n\n\/\/ Read input from stdin\n$input = trim(fgets(STDIN));\n\n\/\/ Parse input\nlist($N, $x, $M, $y) = explode(' ', $input);\n\n\/\/ Call the countParts function\n$result = countParts($N, $x, $M, $y);\n\n\/\/ Print the result\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int N, x, M, y;\\r\\n    readf(\\\"%d %d %d %d\\\", &N, &x, &M, &y);\\r\\n\\r\\n    int minX = min(x, y);\\r\\n    int maxX = max(x, y);\\r\\n\\r\\n    int parts = 1;\\r\\n\\r\\n    for (int i = 1; i <= N; i++)\\r\\n    {\\r\\n        int circleX = i;\\r\\n\\r\\n        if (circleX >= minX && circleX <= maxX)\\r\\n            parts++;\\r\\n    }\\r\\n\\r\\n    for (int i = 1; i <= M; i++)\\r\\n    {\\r\\n        int circleY = i;\\r\\n\\r\\n        if (circleY >= minX && circleY <= maxX)\\r\\n            parts++;\\r\\n    }\\r\\n\\r\\n    writeln(parts);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_parts {\n    my ($N, $x, $M, $y) = @_;\n\n    my $parts = 1;\n\n    # Calculate the number of parts in the (N, x)-set\n    $parts += $N;\n\n    # Calculate the number of parts in the (M, y)-set\n    $parts += $M;\n\n    # Calculate the number of overlapping parts\n    my $overlap = abs($x - $y) - 1;\n    $parts -= $overlap;\n\n    return $parts;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\nmy ($N, $x, $M, $y) = split ' ', $input;\n\n# Calculate the number of parts\nmy $result = count_parts($N, $x, $M, $y);\n\n# Print the result\nprint $result;\n","Rust":"\n\nfn main() {\n    let input = vec![\n        (1, 0, 1, 1),\n        (1, 0, 1, 2),\n        (3, 3, 4, 7),\n    ];\n\n    for (n, x, m, y) in input {\n        let parts = find_parts(n, x, m, y);\n        println!(\"{}\", parts);\n    }\n}\n\nfn find_parts(n: i32, x: i32, m: i32, y: i32) -> i32 {\n    let mut parts = 1;\n\n    if x != y {\n        parts += 1;\n    }\n\n    parts += n + m;\n\n    return parts;\n}\n\n"}
{"title":"D. Interesting Sequence","description":"Berland scientists noticed long ago that the world around them depends on Berland population. Due to persistent research in this area the scientists managed to find out that the Berland chronology starts from the moment when the first two people came to that land (it is considered to have happened in the first year). After one Berland year after the start of the chronology the population had already equaled 13 people (the second year). However, tracing the population number during the following years was an ultimately difficult task, still it was found out that if di \u2014 the number of people in Berland in the year of i, then either di=12di-2, or di=13di-1-12di-2. Of course no one knows how many people are living in Berland at the moment, but now we can tell if there could possibly be a year in which the country population equaled A. That's what we ask you to determine. Also, if possible, you have to find out in which years it could be (from the beginning of Berland chronology). Let's suppose that it could be in the years of a1,a2,...,ak. Then you have to define how many residents could be in the country during those years apart from the A variant. Look at the examples for further explanation.","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains integer A (1\u2264A<10^300). It is guaranteed that the number doesn't contain leading zeros.\n","output_spec":"On the first output line print YES, if there could be a year in which the total population of the country equaled A, otherwise print NO. \nIf the answer is YES, then you also have to print number k \u2014 the number of years in which the population could equal A. On the next line you have to output precisely k space-separated numbers \u2014 a1,a2,...,ak. Those numbers have to be output in the increasing order.\nOn the next line you should output number p \u2014 how many variants of the number of people could be in the years of a1,a2,...,ak, apart from the A variant. On each of the next p lines you have to print one number \u2014 the sought number of residents. Those number also have to go in the increasing order. \nIf any number (or both of them) k or p exceeds 1000, then you have to print 1000 instead of it and only the first 1000 possible answers in the increasing order.\nThe numbers should have no leading zeros.\n","notes":null,"sample_inputs":["2\n","3\n","13\n","1729\n"],"sample_outputs":["YES\n1\n1\n0\n","NO\n","YES\n1\n2\n0\n","YES\n1\n4\n1\n156\n"],"id":"40-D","difficulty":2600,"tags":["math"],"src_uid":"0ef5e0621f13107d0c8786766ae2ac56","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <string>\\n#include <unordered_set>\\nusing namespace std;\\n\\nstring add(string a, string b) {\\n    string res;\\n    int carry = 0;\\n    int i = a.size() - 1;\\n    int j = b.size() - 1;\\n    while (i >= 0 || j >= 0 || carry) {\\n        int sum = carry;\\n        if (i >= 0) {\\n            sum += a[i] - '0';\\n            i--;\\n        }\\n        if (j >= 0) {\\n            sum += b[j] - '0';\\n            j--;\\n        }\\n        carry = sum \/ 10;\\n        sum %= 10;\\n        res += to_string(sum);\\n    }\\n    reverse(res.begin(), res.end());\\n    return res;\\n}\\n\\nint main() {\\n    string A;\\n    cin >> A;\\n    unordered_set<string> population;\\n    population.insert(\\\"1\\\");\\n    population.insert(\\\"13\\\");\\n    string prev = \\\"1\\\";\\n    string curr = \\\"13\\\";\\n    while (population.size() <= 1000) {\\n        string next = add(curr, add(curr, prev));\\n        population.insert(next);\\n        prev = curr;\\n        curr = next;\\n    }\\n    if (population.count(A) > 0) {\\n        cout << \\\"YES\\\" << endl;\\n        cout << \\\"1\\\" << endl;\\n        cout << A << endl;\\n        cout << \\\"0\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class BerlandPopulation {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        BigInteger A = scanner.nextBigInteger();\\n        scanner.close();\\n\\n        List<BigInteger> years = new ArrayList<>();\\n        List<BigInteger> residents = new ArrayList<>();\\n\\n        BigInteger d1 = BigInteger.valueOf(2);\\n        BigInteger d2 = BigInteger.valueOf(13);\\n\\n        if (A.equals(d1) || A.equals(d2)) {\\n            System.out.println(\\\"YES\\\");\\n            System.out.println(\\\"1\\\");\\n            System.out.println(A);\\n            System.out.println(\\\"0\\\");\\n            return;\\n        }\\n\\n        years.add(d1);\\n        years.add(d2);\\n\\n        BigInteger maxIterations = BigInteger.valueOf(1000);\\n        BigInteger iterations = BigInteger.ZERO;\\n\\n        while (iterations.compareTo(maxIterations) < 0) {\\n            BigInteger d = d2.multiply(BigInteger.valueOf(13)).subtract(d1.multiply(BigInteger.valueOf(12)));\\n            years.add(d);\\n            d1 = d2;\\n            d2 = d;\\n            iterations = iterations.add(BigInteger.ONE);\\n\\n            if (d.equals(A)) {\\n                System.out.println(\\\"YES\\\");\\n                System.out.println(\\\"1\\\");\\n                System.out.println(A);\\n                System.out.println(\\\"0\\\");\\n                return;\\n            }\\n\\n            if (d.compareTo(A) > 0) {\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < years.size(); i++) {\\n            BigInteger year = years.get(i);\\n            if (year.equals(A)) {\\n                System.out.println(\\\"YES\\\");\\n                System.out.println(\\\"1\\\");\\n                System.out.println(A);\\n                System.out.println(\\\"0\\\");\\n                return;\\n            }\\n\\n            if (year.compareTo(A) > 0) {\\n                break;\\n            }\\n\\n            for (int j = i + 1; j < years.size(); j++) {\\n                BigInteger nextYear = years.get(j);\\n                BigInteger diff = nextYear.subtract(year);\\n                if (diff.equals(A)) {\\n                    System.out.println(\\\"YES\\\");\\n                    System.out.println(\\\"2\\\");\\n                    System.out.println(year + \\\" \\\" + nextYear);\\n                    System.out.println(\\\"0\\\");\\n                    return;\\n                }\\n\\n                if (diff.compareTo(A) > 0) {\\n                    break;\\n                }\\n\\n                if (!residents.contains(diff)) {\\n                    residents.add(diff);\\n                }\\n            }\\n        }\\n\\n        System.out.println(\\\"NO\\\");\\n    }\\n}","Python":"def find_population(A):\n    def find_years(A):\n        years = []\n        d = [2, 3]\n        while True:\n            d.append(12 * d[-2])\n            if d[-1] == A:\n                years.append(len(d) - 1)\n                break\n            d.append(13 * d[-1] - 12 * d[-2])\n            if d[-1] == A:\n                years.append(len(d) - 1)\n                break\n            if len(d) > 1000:\n                break\n        return years\n\n    def find_variants(years):\n        variants = []\n        for year in years:\n            d = [2, 3]\n            for i in range(2, year + 1):\n                d.append(12 * d[-2])\n                if len(d) > 1000:\n                    break\n                d.append(13 * d[-1] - 12 * d[-2])\n                if len(d) > 1000:\n                    break\n            variants.extend(d[:-1])\n        return sorted(set(variants))\n\n    years = find_years(A)\n    if years:\n        variants = find_variants(years)\n        return 'YES\\\\n{}\\\\n{}\\\\n{}'.format(len(years), ' '.join(map(str, years)), len(variants)) + '\\\\n' + '\\\\n'.join(map(str, variants[:1000]))\n    else:\n        return 'NO'\n\nA = int(input())\nprint(find_population(A))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MAX_LEN 1000\\n\\nchar* add(char* a, char* b) {\\n    int len_a = strlen(a);\\n    int len_b = strlen(b);\\n    int len_res = len_a > len_b ? len_a + 1 : len_b + 1;\\n    char* res = (char*)malloc(len_res * sizeof(char));\\n    int carry = 0;\\n    int i, j, k;\\n    for (i = len_a - 1, j = len_b - 1, k = len_res - 1; i >= 0 || j >= 0; i--, j--, k--) {\\n        int digit_a = i >= 0 ? a[i] - '0' : 0;\\n        int digit_b = j >= 0 ? b[j] - '0' : 0;\\n        int sum = digit_a + digit_b + carry;\\n        res[k] = sum % 10 + '0';\\n        carry = sum \/ 10;\\n    }\\n    if (carry > 0) {\\n        res[k] = carry + '0';\\n        k--;\\n    }\\n    res[len_res - 1] = '\\\\0';\\n    return res + k + 1;\\n}\\n\\nint main() {\\n    char A[MAX_LEN];\\n    scanf(\\\"%s\\\", A);\\n    int len_A = strlen(A);\\n    char* dp[MAX_LEN];\\n    dp[0] = (char*)malloc(2 * sizeof(char));\\n    dp[0][0] = '1';\\n    dp[0][1] = '\\\\0';\\n    dp[1] = (char*)malloc(3 * sizeof(char));\\n    dp[1][0] = '1';\\n    dp[1][1] = '3';\\n    dp[1][2] = '\\\\0';\\n    int i;\\n    for (i = 2; i < len_A; i++) {\\n        dp[i] = add(dp[i - 1], dp[i - 2]);\\n    }\\n    int found = 0;\\n    int k = 0;\\n    int p = 0;\\n    char* years[1000];\\n    char* residents[1000];\\n    for (i = 0; i < len_A; i++) {\\n        if (strcmp(A, dp[i]) == 0) {\\n            found = 1;\\n            k = 1;\\n            years[0] = (char*)malloc((i + 1) * sizeof(char));\\n            strncpy(years[0], A, i);\\n            years[0][i] = '\\\\0';\\n            break;\\n        }\\n        if (strcmp(A, dp[i]) < 0) {\\n            k = 1;\\n            years[0] = (char*)malloc((i + 1) * sizeof(char));\\n            strncpy(years[0], dp[i - 1], i);\\n            years[0][i] = '\\\\0';\\n            break;\\n        }\\n    }\\n    if (found) {\\n        printf(\\\"YES\\\\n\\\");\\n        printf(\\\"%d\\\\n\\\", k);\\n        for (i = 0; i < k; i++) {\\n            printf(\\\"%s \\\", years[i]);\\n            free(years[i]);\\n        }\\n        printf(\\\"\\\\n\\\");\\n        printf(\\\"%d\\\\n\\\", p);\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n    for (i = 0; i < len_A; i++) {\\n        free(dp[i]);\\n    }\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\npublic class Program\n{\n    public static void Main()\n    {\n        BigInteger A = BigInteger.Parse(Console.ReadLine());\n        \n        List<BigInteger> years = new List<BigInteger>();\n        List<BigInteger> residents = new List<BigInteger>();\n        \n        BigInteger d1 = 2;\n        BigInteger d2 = 13;\n        \n        if (A == d1 || A == d2)\n        {\n            Console.WriteLine(\\\"YES\\\");\n            Console.WriteLine(\\\"1\\\");\n            Console.WriteLine(A);\n            Console.WriteLine(\\\"0\\\");\n            return;\n        }\n        \n        years.Add(1);\n        residents.Add(d1);\n        years.Add(2);\n        residents.Add(d2);\n        \n        BigInteger k = 2;\n        BigInteger p = 0;\n        \n        while (true)\n        {\n            BigInteger d = 12 * d1;\n            if (d == A)\n            {\n                Console.WriteLine(\\\"YES\\\");\n                Console.WriteLine(k);\n                for (int i = 0; i < k; i++)\n                {\n                    Console.Write(years[i] + \\\" \\\");\n                }\n                Console.WriteLine();\n                Console.WriteLine(p);\n                for (int i = 0; i < p; i++)\n                {\n                    Console.WriteLine(residents[i]);\n                }\n                return;\n            }\n            else if (d > A)\n            {\n                break;\n            }\n            \n            years.Add(k + 1);\n            residents.Add(d);\n            \n            k++;\n            \n            d1 = d2;\n            d2 = d;\n        }\n        \n        d1 = 2;\n        d2 = 13;\n        \n        while (true)\n        {\n            BigInteger d = 13 * d2 - 12 * d1;\n            if (d == A)\n            {\n                Console.WriteLine(\\\"YES\\\");\n                Console.WriteLine(k);\n                for (int i = 0; i < k; i++)\n                {\n                    Console.Write(years[i] + \\\" \\\");\n                }\n                Console.WriteLine();\n                Console.WriteLine(p);\n                for (int i = 0; i < p; i++)\n                {\n                    Console.WriteLine(residents[i]);\n                }\n                return;\n            }\n            else if (d > A)\n            {\n                break;\n            }\n            \n            years.Add(k + 1);\n            residents.Add(d);\n            \n            k++;\n            \n            d1 = d2;\n            d2 = d;\n        }\n        \n        Console.WriteLine(\\\"NO\\\");\n    }\n}\n","Ruby":"\ndef find_population(a)\n  # Initialize an array to store the possible years\n  years = []\n\n  # Check if A is a power of 12\n  if Math.log(a, 12) % 1 == 0\n    years << Math.log(a, 12).to_i\n  end\n\n  # Check if A is a power of 13\n  if Math.log(a, 13) % 1 == 0\n    years << Math.log(a, 13).to_i\n  end\n\n  # Check if A can be obtained by the given formula\n  d = [2, 13]\n  while d[-1] < a\n    d << 12 * d[-2] + d[-1]\n  end\n\n  if d.include?(a)\n    years << d.index(a)\n  end\n\n  # Sort the years in increasing order\n  years.sort!\n\n  # Calculate the number of residents for each year\n  residents = []\n  years.each do |year|\n    residents << 12 * d[year-2] + d[year-1]\n  end\n\n  # Check if the number of years or residents exceeds 1000\n  if years.length > 1000\n    years = years[0..999]\n  end\n\n  if residents.length > 1000\n    residents = residents[0..999]\n  end\n\n  # Prepare the output string\n  output = \"\"\n  if years.empty?\n    output += \"NO\\n\"\n  else\n    output += \"YES\\n\"\n    output += \"#{years.length}\\n\"\n    output += years.join(\" \") + \"\\n\"\n    output += \"#{residents.length}\\n\"\n    output += residents.join(\"\\n\") + \"\\n\"\n  end\n\n  return output\nend\n\n# Read the input\na = gets.chomp.to_i\n\n# Call the function and print the output\nputs find_population(a)\n","delphi":"program BerlandPopulation;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction BerlandPopulation(A: string): string;\\nvar\\n  i, j, k, p: Integer;\\n  years: array[1..1000] of Integer;\\n  residents: array[1..1000] of Integer;\\n  count: Integer;\\nbegin\\n  Result := '';\\n  k := 0;\\n  p := 0;\\n  years[1] := 1;\\n  years[2] := 2;\\n  residents[1] := 1;\\n  residents[2] := 2;\\n  count := 2;\\n\\n  for i := 3 to 1000 do\\n  begin\\n    years[i] := 12 * years[i-2];\\n    if years[i] > 1000 then\\n      years[i] := 1000;\\n    residents[i] := years[i] - years[i-1];\\n    if residents[i] > 1000 then\\n      residents[i] := 1000;\\n    count := count + residents[i];\\n    if count > 1000 then\\n    begin\\n      count := 1000;\\n      Break;\\n    end;\\n  end;\\n\\n  if A = '1' then\\n  begin\\n    Result := 'YES\\\\n1\\\\n1\\\\n0\\\\n';\\n    Exit;\\n  end;\\n\\n  for i := 1 to count do\\n  begin\\n    if years[i] = StrToInt(A) then\\n    begin\\n      Result := 'YES\\\\n1\\\\n' + IntToStr(years[i]) + '\\\\n0\\\\n';\\n      Exit;\\n    end;\\n  end;\\n\\n  for i := 1 to count do\\n  begin\\n    for j := 1 to count do\\n\\n    begin\\n      if years[i] + years[j] = StrToInt(A) then\\n      begin\\n        Result := 'YES\\\\n2\\\\n' + IntToStr(years[i]) + ' ' + IntToStr(years[j]) + '\\\\n0\\\\n';\\n        Exit;\\n      end;\\n\\n      for k := 1 to count do\\n      begin\\n        if years[i] + years[j] + years[k] = StrToInt(A) then\\n        begin\\n          Result := 'YES\\\\n3\\\\n' + IntToStr(years[i]) + ' ' + IntToStr(years[j]) + ' ' + IntToStr(years[k]) + '\\\\n0\\\\n';\\n          Exit;\\n        end;\\n\\n        for p := 1 to count do\\n        begin\\n          if years[i] + years[j] + years[k] + residents[p] = StrToInt(A) then\\n          begin\\n            Result := 'YES\\\\n3\\\\n' + IntToStr(years[i]) + ' ' + IntToStr(years[j]) + ' ' + IntToStr(years[k]) + '\\\\n1\\\\n' + IntToStr(residents[p]) + '\\\\n';\\n            Exit;\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  Result := 'NO\\\\n';\\nend;\\n\\nvar\\n  A: string;\\nbegin\\n  ReadLn(A);\\n  WriteLn(BerlandPopulation(A));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\/big\\\"\\n)\\n\\nfunc main() {\\n\\tvar A big.Int\\n\\tfmt.Scan(&A)\\n\\n\\tvar ans []string\\n\\n\\t\/\/ Check if A is a power of 12\\n\\tif A.BitLen() > 0 && A.BitLen()%2 == 0 {\\n\\t\\ttmp := new(big.Int).Set(&A)\\n\\t\\tfor tmp.BitLen() > 0 {\\n\\t\\t\\tif tmp.Mod(tmp, big.NewInt(12)).Cmp(big.NewInt(0)) != 0 {\\n\\t\\t\\t\\tans = append(ans, \\\"NO\\\")\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\ttmp.Div(tmp, big.NewInt(12))\\n\\t\\t}\\n\\t\\tif len(ans) == 0 {\\n\\t\\t\\tans = append(ans, \\\"YES\\\")\\n\\t\\t\\tans = append(ans, \\\"1\\\")\\n\\t\\t\\tans = append(ans, A.String())\\n\\t\\t\\tans = append(ans, \\\"0\\\")\\n\\t\\t}\\n\\t} else {\\n\\t\\tans = append(ans, \\\"NO\\\")\\n\\t}\\n\\n\\t\/\/ Print the result\\n\\tfor _, s := range ans {\\n\\t\\tfmt.Println(s)\\n\\t}\\n}","Javascript":"\nfunction findPopulation(A) {\n  let years = [];\n  let residents = [];\n  \n  \/\/ Check if A is a power of 12\n  let power = Math.log(A) \/ Math.log(12);\n  if (power === Math.floor(power)) {\n    years.push(power);\n    residents.push(A);\n    return { result: 'YES', years: years, residents: residents };\n  }\n  \n  \/\/ Check if A is a power of 13\n  power = Math.log(A + 12) \/ Math.log(13);\n  if (power === Math.floor(power)) {\n    years.push(power);\n    residents.push(A);\n    return { result: 'YES', years: years, residents: residents };\n  }\n  \n  \/\/ Check if A can be reached from previous years\n  let prevYear = 1;\n  let currYear = 2;\n  let nextYear = 3;\n  \n  while (nextYear <= A) {\n    if (nextYear === A) {\n      years.push(currYear);\n      residents.push(nextYear);\n      return { result: 'YES', years: years, residents: residents };\n    }\n    \n    let temp = nextYear;\n    nextYear = 13 * currYear - 12 * prevYear;\n    prevYear = currYear;\n    currYear = temp;\n  }\n  \n  return { result: 'NO' };\n}\n\nfunction solve(input) {\n  let A = BigInt(input.trim());\n  let result = findPopulation(A);\n  \n  let output = result.result + '\\\\n';\n  \n  if (result.result === 'YES') {\n    output += result.years.length + '\\\\n';\n    output += result.years.join(' ') + '\\\\n';\n    output += result.residents.length + '\\\\n';\n    output += result.residents.join('\\\\n');\n  }\n  \n  return output;\n}\n\nconsole.log(solve('2'));\nconsole.log(solve('3'));\nconsole.log(solve('13'));\nconsole.log(solve('1729'));\n","Kotlin":"import java.math.BigInteger\\n\\nfun main() {\\n    val A = readLine()!!.toBigInteger()\\n    val years = mutableListOf<BigInteger>()\\n    val residents = mutableSetOf<BigInteger>()\\n\\n    fun findYears(n: BigInteger) {\\n        if (n == A) return\\n        if (n > A) return\\n\\n        years.add(n)\\n\\n        findYears(n * BigInteger.valueOf(12))\\n        findYears(n * BigInteger.valueOf(13) - n * BigInteger.valueOf(12))\\n    }\\n\\n    findYears(BigInteger.valueOf(13))\\n\\n    if (years.contains(A)) {\\n        println(\\\"YES\\\")\\n        println(\\\"1\\\")\\n        println(A)\\n        println(\\\"0\\\")\\n    } else {\\n        println(\\\"NO\\\")\\n    }\\n}","PHP":"\n<?php\n\nfunction findPopulation($A) {\n    $years = [];\n    $variants = [];\n    \n    \/\/ Check if A is a power of 12\n    if (($A & ($A - 1)) == 0) {\n        $years[] = 1;\n        $variants[] = 1;\n        return ['YES', $years, $variants];\n    }\n    \n    \/\/ Calculate the maximum possible year\n    $maxYear = 1000;\n    \n    \/\/ Initialize population variables\n    $prevPrevYear = 1;\n    $prevYear = 13;\n    $currentYear = 0;\n    \n    \/\/ Iterate through the years\n    for ($i = 2; $i <= $maxYear; $i++) {\n        $currentYear = 12 * $prevPrevYear;\n        if ($currentYear == $A) {\n            $years[] = $i;\n            $variants[] = $prevYear;\n        }\n        \n        $currentYear = 13 * $prevYear - 12 * $prevPrevYear;\n        if ($currentYear == $A) {\n            $years[] = $i;\n            $variants[] = $prevYear;\n        }\n        \n        $prevPrevYear = $prevYear;\n        $prevYear = $currentYear;\n    }\n    \n    \/\/ Check if there are any valid years\n    if (count($years) > 0) {\n        return ['YES', $years, $variants];\n    } else {\n        return ['NO'];\n    }\n}\n\n\/\/ Read input from stdin\n$A = intval(trim(fgets(STDIN)));\n\n\/\/ Find the population\n$result = findPopulation($A);\n\n\/\/ Print the result\necho $result[0] . PHP_EOL;\nif ($result[0] == 'YES') {\n    $years = $result[1];\n    $variants = $result[2];\n    \n    $k = min(count($years), 1000);\n    echo $k . PHP_EOL;\n    for ($i = 0; $i < $k; $i++) {\n        echo $years[$i] . ' ';\n    }\n    echo PHP_EOL;\n    \n    $p = min(count($variants), 1000);\n    echo $p . PHP_EOL;\n    for ($i = 0; $i < $p; $i++) {\n        echo $variants[$i] . PHP_EOL;\n    }\n}\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string input = readln();\\r\\n    BigInt A = to!BigInt(input);\\r\\n\\r\\n    BigInt[] population;\\r\\n    population ~= 2;\\r\\n    population ~= 13;\\r\\n\\r\\n    while (population[$-1] < A)\\r\\n    {\\r\\n        BigInt d = 12 * population[$-2];\\r\\n        population ~= d;\\r\\n\\r\\n        if (population[$-1] == A)\\r\\n        {\\r\\n            writeln(\\\"YES\\\");\\r\\n            writeln(1);\\r\\n            writeln(population[$-1]);\\r\\n            writeln(0);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        d = 13 * population[$-1] - 12 * population[$-2];\\r\\n        population ~= d;\\r\\n\\r\\n        if (population[$-1] == A)\\r\\n        {\\r\\n            writeln(\\\"YES\\\");\\r\\n            writeln(1);\\r\\n            writeln(population[$-1]);\\r\\n            writeln(0);\\r\\n            return;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(\\\"NO\\\");\\r\\n}\\r\\n","perl":"use strict;\\nuse warnings;\\n\\nsub find_population {\\n    my ($A) = @_;\\n    my @years;\\n    my @residents;\\n    my $count_years = 0;\\n    my $count_residents = 0;\\n    my %seen;\\n\\n    if ($A == 1) {\\n        return \\\"YES\\\\n1\\\\n1\\\\n0\\\\n\\\";\\n    }\\n\\n    my @dp = (1, 13);\\n\\n    for (my $i = 2; $i <= 1000; $i++) {\\n        my $d = 13 * $dp[$i-1] - 12 * $dp[$i-2];\\n        push @dp, $d;\\n\\n        if ($d == $A) {\\n            push @years, $i;\\n            $count_years++;\\n        }\\n\\n        if (!$seen{$d} && $d != $A) {\\n            push @residents, $d;\\n            $count_residents++;\\n            $seen{$d} = 1;\\n        }\\n    }\\n\\n    my $output = \\\"\\\";\\n\\n    if ($count_years > 0) {\\n        $output .= \\\"YES\\\\n$count_years\\\\n\\\";\\n        $output .= join(\\\" \\\", @years[0..999]) . \\\"\\\\n\\\";\\n    } else {\\n        $output .= \\\"NO\\\\n\\\";\\n    }\\n\\n    if ($count_residents > 0) {\\n        $output .= \\\"$count_residents\\\\n\\\";\\n        $output .= join(\\\"\\\\n\\\", @residents[0..999]) . \\\"\\\\n\\\";\\n    }\\n\\n    return $output;\\n}\\n\\nmy $A = <STDIN>;\\nchomp $A;\\n\\nmy $result = find_population($A);\\nprint $result;\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let a: u128 = lines.next().unwrap().parse().unwrap();\n    \n    let mut possible_years = Vec::new();\n    let mut possible_residents = Vec::new();\n    \n    let mut d1: u128 = 2;\n    let mut d2: u128 = 13;\n    \n    if a == d1 || a == d2 {\n        possible_years.push(1);\n        possible_residents.push(0);\n    }\n    \n    let mut year = 2;\n    \n    while year <= 1000 {\n        let d = 12 * d1;\n        d2 = 13 * d2 - 12 * d1;\n        d1 = d;\n        \n        if a == d {\n            possible_years.push(year);\n            possible_residents.push(0);\n        } else if a == d2 {\n            possible_years.push(year);\n            possible_residents.push(d1);\n        }\n        \n        year += 1;\n    }\n    \n    let num_years = possible_years.len().min(1000);\n    let num_residents = possible_residents.len().min(1000);\n    \n    if num_years > 0 {\n        println!(\"YES\");\n        println!(\"{}\", num_years);\n        for i in 0..num_years {\n            print!(\"{} \", possible_years[i]);\n        }\n        println!();\n        println!(\"{}\", num_residents);\n        for i in 0..num_residents {\n            println!(\"{}\", possible_residents[i]);\n        }\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"A. Translation","description":"The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the \u00abtranslation\u00bb. Vasya translated word s from Berlandish into Birlandish as t. Help him: find out if he translated the word correctly.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.\n","output_spec":"If the word t is a word s, written reversely, print YES, otherwise print NO.\n","notes":null,"sample_inputs":["code\nedoc\n","abb\naba\n","code\ncode\n"],"sample_outputs":["YES\n","NO\n","NO\n"],"id":"41-A","difficulty":800,"tags":["implementation","strings"],"src_uid":"35a4be326690b58bf9add547fb63a5a5","C++":"#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    string s, t;\\n    cin >> s >> t;\\n    reverse(t.begin(), t.end());\\n    if (s == t) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Translation {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String s = scanner.nextLine();\\n        String t = scanner.nextLine();\\n        String reversedS = new StringBuilder(s).reverse().toString();\\n        if (reversedS.equals(t)) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n}","Python":"def check_translation(s, t):\n    if s == t[::-1]:\n        return 'YES'\n    else:\n        return 'NO'\n\ns = input().strip()\nt = input().strip()\nresult = check_translation(s, t)\nprint(result)\n","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char s[101];\\n    char t[101];\\n    scanf(\\\"%s\\\", s);\\n    scanf(\\\"%s\\\", t);\\n    int len = strlen(s);\\n    int i;\\n    for(i=0; i<len; i++) {\\n        if(s[i] != t[len-i-1]) {\\n            printf(\\\"NO\\\\n\\\");\\n            return 0;\\n        }\\n    }\\n    printf(\\\"YES\\\\n\\\");\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string s = Console.ReadLine();\n        string t = Console.ReadLine();\n        \n        string reversedS = ReverseString(s);\n        \n        if(reversedS == t)\n        {\n            Console.WriteLine(\\\"YES\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"NO\\\");\n        }\n    }\n    \n    public static string ReverseString(string s)\n    {\n        char[] charArray = s.ToCharArray();\n        Array.Reverse(charArray);\n        return new string(charArray);\n    }\n}","Ruby":"def translated_correctly(s, t)\\n  if s.reverse == t\\n    return 'YES'\\n  else\\n    return 'NO'\\n  end\\nend\\n\\ninput = gets.chomp\\ns = input\\ninput = gets.chomp\\nt = input\\n\\nputs translated_correctly(s, t)\\n","delphi":"program Translation;\n\nvar\n  s, t: string;\n\nbegin\n  \/\/ Read the input words\n  readln(s);\n  readln(t);\n  \n  \/\/ Reverse the word s\n  for var i := Length(s) downto 1 do\n    s := s + s[i];\n  Delete(s, 1, Length(s) div 2);\n  \n  \/\/ Check if t is equal to the reversed s\n  if t = s then\n    writeln('YES')\n  else\n    writeln('NO');\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar s, t string\\n\\tfmt.Scan(&s)\\n\\tfmt.Scan(&t)\\n\\n\\tif strings.EqualFold(s, reverse(t)) {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}\\n\\nfunc reverse(s string) string {\\n\\tr := []rune(s)\\n\\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tr[i], r[j] = r[j], r[i]\\n\\t}\\n\\treturn string(r)\\n}","Javascript":"function isTranslationCorrect(s, t) {\n  \/\/ Reverse the string s\n  let reversedS = s.split('').reverse().join('');\n\n  \/\/ Check if the reversed string s is equal to t\n  if (reversedS === t) {\n    return 'YES';\n  } else {\n    return 'NO';\n  }\n}\n\n\/\/ Test cases\nconsole.log(isTranslationCorrect('code', 'edoc')); \/\/ Output: YES\nconsole.log(isTranslationCorrect('abb', 'aba')); \/\/ Output: NO\nconsole.log(isTranslationCorrect('code', 'code')); \/\/ Output: NO","Kotlin":"fun main() {\n    val s = readLine()!!\n    val t = readLine()!!\n\n    if (s.reversed() == t) {\n        println(\\\"YES\\\")\n    } else {\n        println(\\\"NO\\\")\n    }\n}","PHP":"<?php\\n\\nfunction isTranslationCorrect($s, $t) {\\n    $reversedS = strrev($s);\\n    if ($reversedS == $t) {\\n        return 'YES';\\n    } else {\\n        return 'NO';\\n    }\\n}\\n\\n$input = file_get_contents('php:\/\/input');\\n$data = json_decode($input, true);\\n$s = $data['s'];\\n$t = $data['t'];\\n\\n$result = isTranslationCorrect($s, $t);\\necho json_encode($result);\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string s, t;\\r\\n    readln(s);\\r\\n    readln(t);\\r\\n\\r\\n    string reversedS = s.reverse;\\r\\n\\r\\n    if (reversedS == t)\\r\\n    {\\r\\n        writeln(\\\"YES\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub is_translation_correct {\n    my ($s, $t) = @_;\n    \n    # Reverse the string s\n    my $reversed_s = reverse $s;\n    \n    # Check if the reversed string s is equal to t\n    if ($reversed_s eq $t) {\n        return 'YES';\n    } else {\n        return 'NO';\n    }\n}\n\n# Read input from STDIN\nmy $s = <STDIN>;\nmy $t = <STDIN>;\n\n# Remove newline characters from input\nchomp($s);\nchomp($t);\n\n# Check if the translation is correct\nmy $result = is_translation_correct($s, $t);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\n    let mut s = String::new();\n    let mut t = String::new();\n\n    std::io::stdin().read_line(&mut s).unwrap();\n    std::io::stdin().read_line(&mut t).unwrap();\n\n    let s = s.trim();\n    let t = t.trim();\n\n    let reversed_s: String = s.chars().rev().collect();\n\n    if reversed_s == t {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"A. Pasha and Hamsters","description":"Pasha has two hamsters: Arthur and Alexander. Pasha put n apples in front of them. Pasha knows which apples Arthur likes. Similarly, Pasha knows which apples Alexander likes. Pasha doesn't want any conflict between the hamsters (as they may like the same apple), so he decided to distribute the apples between the hamsters on his own. He is going to give some apples to Arthur and some apples to Alexander. It doesn't matter how many apples each hamster gets but it is important that each hamster gets only the apples he likes. It is possible that somebody doesn't get any apples.Help Pasha distribute all the apples between the hamsters. Note that Pasha wants to distribute all the apples, not just some of them.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains integers n, a, b (1\u2264n\u2264100;\u00a01\u2264a,b\u2264n) \u2014 the number of apples Pasha has, the number of apples Arthur likes and the number of apples Alexander likes, correspondingly.\nThe next line contains a distinct integers \u2014 the numbers of the apples Arthur likes. The next line contains b distinct integers \u2014 the numbers of the apples Alexander likes.\nAssume that the apples are numbered from 1 to n. The input is such that the answer exists.\n","output_spec":"Print n characters, each of them equals either 1 or 2. If the i-h character equals 1, then the i-th apple should be given to Arthur, otherwise it should be given to Alexander. If there are multiple correct answers, you are allowed to print any of them.\n","notes":null,"sample_inputs":["4 2 3\n1 2\n2 3 4\n","5 5 2\n3 4 1 2 5\n2 3\n"],"sample_outputs":["1 1 2 2\n","1 1 1 1 1\n"],"id":"421-A","difficulty":800,"tags":["constructive+algorithms","implementation"],"src_uid":"a35a27754c9c095c6f1b2d4adccbfe93","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, a, b;\\n    cin >> n >> a >> b;\\n    vector<int> arthur(a);\\n    vector<int> alexander(b);\\n    for (int i = 0; i < a; i++) {\\n        cin >> arthur[i];\\n    }\\n    for (int i = 0; i < b; i++) {\\n        cin >> alexander[i];\\n    }\\n    vector<int> distribution(n, 0);\\n    for (int i = 0; i < a; i++) {\\n        distribution[arthur[i] - 1] = 1;\\n    }\\n    for (int i = 0; i < b; i++) {\\n        distribution[alexander[i] - 1] = 2;\\n    }\\n    for (int i = 0; i < n; i++) {\\n        cout << distribution[i] << \\\" \\\";\\n    }\\n    cout << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class HamsterApples {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input\n        String[] input = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input[0]);\n        int a = Integer.parseInt(input[1]);\n        int b = Integer.parseInt(input[2]);\n        \n        \/\/ Read Arthur's preferences\n        Set<Integer> arthurPreferences = new HashSet<>();\n        input = scanner.nextLine().split(\\\" \\\");\n        for (int i = 0; i < a; i++) {\n            arthurPreferences.add(Integer.parseInt(input[i]));\n        }\n        \n        \/\/ Read Alexander's preferences\n        Set<Integer> alexanderPreferences = new HashSet<>();\n        input = scanner.nextLine().split(\\\" \\\");\n        for (int i = 0; i < b; i++) {\n            alexanderPreferences.add(Integer.parseInt(input[i]));\n        }\n        \n        \/\/ Distribute the apples\n        StringBuilder result = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            if (arthurPreferences.contains(i)) {\n                result.append(\\\"1 \\\");\n            } else if (alexanderPreferences.contains(i)) {\n                result.append(\\\"2 \\\");\n            }\n        }\n        \n        \/\/ Print the result\n        System.out.println(result.toString().trim());\n    }\n}","Python":"def distribute_apples(n, a, b, arthur_likes, alexander_likes):\n    result = ['1' if i in arthur_likes else '2' for i in range(1, n+1)]\n    return ' '.join(result)\n\ninput_data = input().split('\\\\n')\nn, a, b = map(int, input_data[0].split())\narthur_likes = set(map(int, input_data[1].split()))\nalexander_likes = set(map(int, input_data[2].split()))\n\noutput = distribute_apples(n, a, b, arthur_likes, alexander_likes)\nprint(output)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, a, b;\\n    scanf(\\\"%d %d %d\\\", &n, &a, &b);\\n    int arthur[a], alexander[b];\\n    for (int i = 0; i < a; i++) {\\n        scanf(\\\"%d\\\", &arthur[i]);\\n    }\\n    for (int i = 0; i < b; i++) {\\n        scanf(\\\"%d\\\", &alexander[i]);\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        if (i == arthur[0]) {\\n            printf(\\\"1 \\\");\\n            for (int j = 0; j < a - 1; j++) {\\n                arthur[j] = arthur[j + 1];\\n            }\\n            a--;\\n        } else if (i == alexander[0]) {\\n            printf(\\\"2 \\\");\\n            for (int j = 0; j < b - 1; j++) {\\n                alexander[j] = alexander[j + 1];\\n            }\\n            b--;\\n        }\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace HamsterApples\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int a = int.Parse(inputArr[1]);\n            int b = int.Parse(inputArr[2]);\n\n            input = Console.ReadLine();\n            string[] arthurLikesArr = input.Split(' ');\n            List<int> arthurLikes = new List<int>();\n            for (int i = 0; i < a; i++)\n            {\n                arthurLikes.Add(int.Parse(arthurLikesArr[i]));\n            }\n\n            input = Console.ReadLine();\n            string[] alexanderLikesArr = input.Split(' ');\n            List<int> alexanderLikes = new List<int>();\n            for (int i = 0; i < b; i++)\n            {\n                alexanderLikes.Add(int.Parse(alexanderLikesArr[i]));\n            }\n\n            int[] distribution = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                if (arthurLikes.Contains(i + 1))\n                {\n                    distribution[i] = 1;\n                }\n                else\n                {\n                    distribution[i] = 2;\n                }\n            }\n\n            for (int i = 0; i < n; i++)\n            {\n                Console.Write(distribution[i] + \" \");\n            }\n        }\n    }\n}","Ruby":"\ndef distribute_apples(n, a, b, arthur_likes, alexander_likes)\n  result = []\n  arthur_likes.each do |apple|\n    result[apple-1] = 1\n  end\n  alexander_likes.each do |apple|\n    result[apple-1] = 2\n  end\n  result.map { |x| x.nil? ? 1 : x }.join(' ')\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\na = input[1].to_i\nb = input[2].to_i\n\narthur_likes = gets.chomp.split(' ').map(&:to_i)\nalexander_likes = gets.chomp.split(' ').map(&:to_i)\n\nputs distribute_apples(n, a, b, arthur_likes, alexander_likes)\n","delphi":"program HamsterApples;\\n\\nvar\\n  n, a, b, i, apple: integer;\\n  arthurLikes, alexanderLikes: array of integer;\\n  distribution: array of integer;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n, a, b);\\n  SetLength(arthurLikes, a);\\n  SetLength(alexanderLikes, b);\\n  SetLength(distribution, n);\\n\\n  \/\/ Read Arthur's favorite apples\\n  for i := 0 to a-1 do\\n  begin\\n    read(apple);\\n    arthurLikes[i] := apple;\\n  end;\\n\\n  \/\/ Read Alexander's favorite apples\\n  for i := 0 to b-1 do\\n  begin\\n    read(apple);\\n    alexanderLikes[i] := apple;\\n  end;\\n\\n  \/\/ Distribute the apples\\n  for i := 1 to n do\\n  begin\\n    if (i in arthurLikes) then\\n      distribution[i-1] := 1\\n    else if (i in alexanderLikes) then\\n      distribution[i-1] := 2\\n    else\\n      distribution[i-1] := 1; \/\/ Give the apple to Arthur by default\\n  end;\\n\\n  \/\/ Print the distribution\\n  for i := 0 to n-1 do\\n    write(distribution[i], ' ');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnab := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nab[0])\\n\\ta, _ := strconv.Atoi(nab[1])\\n\\tb, _ := strconv.Atoi(nab[2])\\n\\n\\tscanner.Scan()\\n\\tarthurLikes := make(map[int]bool)\\n\\tarthurApples := strings.Split(scanner.Text(), \\\" \\\")\\n\\tfor _, apple := range arthurApples {\\n\\t\\tappleNum, _ := strconv.Atoi(apple)\\n\\t\\tarthurLikes[appleNum] = true\\n\\t}\\n\\n\\tscanner.Scan()\\n\\talexanderLikes := make(map[int]bool)\\n\\talexanderApples := strings.Split(scanner.Text(), \\\" \\\")\\n\\tfor _, apple := range alexanderApples {\\n\\t\\tappleNum, _ := strconv.Atoi(apple)\\n\\t\\talexanderLikes[appleNum] = true\\n\\t}\\n\\n\\tresult := make([]string, n)\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif arthurLikes[i] {\\n\\t\\t\\tresult[i-1] = \\\"1\\\"\\n\\t\\t} else if alexanderLikes[i] {\\n\\t\\t\\tresult[i-1] = \\\"2\\\"\\n\\t\\t} else {\\n\\t\\t\\tresult[i-1] = \\\"1\\\"\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(strings.Join(result, \\\" \\\"))\\n}","Javascript":"function distributeApples(input) {\n  const lines = input.split('\\\\n');\n  const [n, a, b] = lines[0].split(' ').map(Number);\n  const arthurLikes = lines[1].split(' ').map(Number);\n  const alexanderLikes = lines[2].split(' ').map(Number);\n\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (arthurLikes.includes(i)) {\n      result.push(1);\n    } else {\n      result.push(2);\n    }\n  }\n\n  return result.join(' ');\n}\n\nconsole.log(distributeApples('4 2 3\\\\n1 2\\\\n2 3 4\\\\n'));\nconsole.log(distributeApples('5 5 2\\\\n3 4 1 2 5\\\\n2 3\\\\n'));","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val a = input[1].toInt()\n    val b = input[2].toInt()\n\n    val arthurLikes = scanner.nextLine().split(\" \").map { it.toInt() }.toSet()\n    val alexanderLikes = scanner.nextLine().split(\" \").map { it.toInt() }.toSet()\n\n    val result = StringBuilder()\n    for (i in 1..n) {\n        if (i in arthurLikes) {\n            result.append(\"1 \")\n        } else if (i in alexanderLikes) {\n            result.append(\"2 \")\n        }\n    }\n\n    println(result.toString().trim())\n}","PHP":"<?php\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n\\nlist($n, $a, $b) = explode(\\\" \\\", $input[0]);\\n$arthur_likes = explode(\\\" \\\", $input[1]);\\n$alexander_likes = explode(\\\" \\\", $input[2]);\\n\\n$output = '';\\n\\nfor ($i = 1; $i <= $n; $i++) {\\n    if (in_array($i, $arthur_likes)) {\\n        $output .= '1 ';\\n    } else {\\n        $output .= '2 ';\\n    }\\n}\\n\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, a, b;\\r\\n    readf(\\\"%d %d %d\\\", &n, &a, &b);\\r\\n\\r\\n    int[] arthurLikes = new int[a];\\r\\n    int[] alexanderLikes = new int[b];\\r\\n\\r\\n    readf(\\\"%s\\\", &arthurLikes);\\r\\n    readf(\\\"%s\\\", &alexanderLikes);\\r\\n\\r\\n    int[] distribution = new int[n];\\r\\n\\r\\n    foreach (i, apple; arthurLikes)\\r\\n    {\\r\\n        distribution[apple - 1] = 1;\\r\\n    }\\r\\n\\r\\n    foreach (i, apple; alexanderLikes)\\r\\n    {\\r\\n        distribution[apple - 1] = 2;\\r\\n    }\\r\\n\\r\\n    writeln(distribution);\\r\\n}","perl":"\n# Read input values\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $a, $b) = split(' ', $input);\n\n$input = <STDIN>;\nchomp $input;\nmy @arthur_likes = split(' ', $input);\n\n$input = <STDIN>;\nchomp $input;\nmy @alexander_likes = split(' ', $input);\n\n# Initialize an array to store the distribution of apples\nmy @distribution;\n\n# Assign apples to Arthur\nforeach my $apple (@arthur_likes) {\n    $distribution[$apple-1] = 1;\n}\n\n# Assign apples to Alexander\nforeach my $apple (@alexander_likes) {\n    $distribution[$apple-1] = 2;\n}\n\n# Print the distribution\nprint join(' ', @distribution), \"\\n\";\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n\n    let first_line: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = first_line[0];\n    let a = first_line[1];\n    let b = first_line[2];\n\n    let arthur_likes: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let alexander_likes: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut distribution = vec![0; n];\n\n    for apple in arthur_likes {\n        distribution[apple - 1] = 1;\n    }\n\n    for apple in alexander_likes {\n        if distribution[apple - 1] == 0 {\n            distribution[apple - 1] = 2;\n        }\n    }\n\n    let output: String = distribution\n        .iter()\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n        .join(\" \");\n\n    println!(\"{}\", output);\n}"}
{"title":"A. Devu, the Singer and Churu, the Joker","description":"Devu is a renowned classical singer. He is invited to many big functions\/festivals. Recently he was invited to \"All World Classical Singing Festival\". Other than Devu, comedian Churu was also invited.Devu has provided organizers a list of the songs and required time for singing them. He will sing n songs, i^th song will take ti minutes exactly. The Comedian, Churu will crack jokes. All his jokes are of 5 minutes exactly.People have mainly come to listen Devu. But you know that he needs rest of 10 minutes after each song. On the other hand, Churu being a very active person, doesn't need any rest.You as one of the organizers should make an optimal s\u0441hedule for the event. For some reasons you must follow the conditions:  The duration of the event must be no more than d minutes;  Devu must complete all his songs;  With satisfying the two previous conditions the number of jokes cracked by Churu should be as many as possible. If it is not possible to find a way to conduct all the songs of the Devu, output -1. Otherwise find out maximum number of jokes that Churu can crack in the grand event.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains two space separated integers n, d (1\u2264n\u2264100;\u00a01\u2264d\u226410000). The second line contains n space-separated integers: t1,t2,...,tn (1\u2264ti\u2264100).\n","output_spec":"If there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.\n","notes":"Consider the first example. The duration of the event is 30 minutes. There could be maximum 5 jokes in the following way:\n  First Churu cracks a joke in 5 minutes.  Then Devu performs the first song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now Devu performs second song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now finally Devu will perform his last song in 1 minutes.  Total time spent is 5+2+10+2+10+1=30 minutes.\nConsider the second example. There is no way of organizing Devu's all songs. Hence the answer is -1. \n","sample_inputs":["3 30\n2 2 1\n","3 20\n2 1 1\n"],"sample_outputs":["5\n","-1\n"],"id":"439-A","difficulty":900,"tags":["greedy","implementation"],"src_uid":"b16f5f5c4eeed2a3700506003e8ea8ea","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, d;\\n    cin >> n >> d;\\n    vector<int> songs(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> songs[i];\\n    }\\n    int totalDuration = accumulate(songs.begin(), songs.end(), 0) + (n - 1) * 10;\\n    if (totalDuration > d) {\\n        cout << -1 << endl;\\n    } else {\\n        int jokes = (n - 1) * 2;\\n        jokes += (d - totalDuration) \/ 5;\\n        cout << jokes << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ClassicalSingingFestival {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int d = scanner.nextInt();\\n        int[] songs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            songs[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        int totalDuration = 0;\\n        int totalJokes = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            totalDuration += songs[i];\\n            totalJokes += 2;\\n\\n            if (totalDuration + 10 > d) {\\n                System.out.println(-1);\\n                return;\\n            }\\n\\n            if (i != n - 1) {\\n                totalDuration += 10;\\n            }\\n        }\\n\\n        int remainingTime = d - totalDuration;\\n        int jokesPossible = remainingTime \/ 5;\\n        totalJokes += jokesPossible;\\n\\n        System.out.println(totalJokes);\\n    }\\n}","Python":"def optimal_schedule(n, d, songs):\\n    total_time = sum(songs) + (n-1)*10\\n    if total_time > d:\\n        return '-1'\\n    else:\\n        jokes = (n-1)*2\\n        return str(jokes + (d - total_time)\/\/5)\\n\\n\\ninput_data = input().split('\\\\n')\\nn, d = map(int, input_data[0].split())\\nsongs = list(map(int, input_data[1].split()))\\n\\noutput = optimal_schedule(n, d, songs)\\nprint(output)","C":"#include <stdio.h>\n\nint main() {\n    int n, d;\n    scanf(\\\"%d %d\\\", &n, &d);\n    \n    int songs[n];\n    for(int i=0; i<n; i++) {\n        scanf(\\\"%d\\\", &songs[i]);\n    }\n    \n    int total_time = 0;\n    int jokes = 0;\n    \n    for(int i=0; i<n; i++) {\n        total_time += songs[i];\n        jokes += (songs[i] \/ 5);\n        \n        if(i != n-1) {\n            total_time += 10;\n        }\n    }\n    \n    if(total_time > d) {\n        printf(\\\"-1\\\\n\\\");\n    } else {\n        int remaining_time = d - total_time;\n        jokes += (remaining_time \/ 5);\n        printf(\\\"%d\\\\n\\\", jokes);\n    }\n    \n    return 0;\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        int n = int.Parse(input[0]);\n        int d = int.Parse(input[1]);\n\n        int[] songs = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n        int totalSongsTime = 0;\n        int totalJokes = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            totalSongsTime += songs[i];\n            totalJokes += 2; \/\/ Churu cracks 2 jokes after each song\n\n            if (totalSongsTime + (10 * (i + 1)) > d)\n            {\n                Console.WriteLine(-1);\n                return;\n            }\n        }\n\n        int remainingTime = d - totalSongsTime - (10 * n);\n        totalJokes += remainingTime \/ 5; \/\/ Churu cracks jokes with remaining time\n\n        Console.WriteLine(totalJokes);\n    }\n}","Ruby":"\ndef optimal_schedule(n, d, songs)\n  total_time = songs.sum + (n-1)*10\n  if total_time > d\n    return -1\n  else\n    jokes = (n-1)*2 + (d - total_time)\/5\n    return jokes\n  end\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nd = input[1].to_i\n\nsongs = gets.chomp.split(' ').map(&:to_i)\n\noutput = optimal_schedule(n, d, songs)\nputs output\n","delphi":"program ClassicalSingingFestival;\\n\\nvar\\n  n, d, i, totalTime, totalJokes: Integer;\\n  songs: array of Integer;\\n\\nbegin\\n  ReadLn(n, d);\\n  SetLength(songs, n);\\n  for i := 0 to n-1 do\\n    Read(songs[i]);\\n  totalTime := 0;\\n  totalJokes := 0;\\n  for i := 0 to n-1 do\\n  begin\\n    totalTime := totalTime + songs[i];\\n    if i < n-1 then\\n      totalTime := totalTime + 10;\\n    if totalTime > d then\\n    begin\\n      WriteLn(-1);\\n      Exit;\\n    end;\\n    totalJokes := totalJokes + 2;\\n  end;\\n  totalTime := totalTime + 5;\\n  if totalTime > d then\\n    WriteLn(-1)\\n  else\\n    WriteLn(totalJokes);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, d int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &d)\\n\\n\\tvar songs []int\\n\\tvar input string\\n\\tfmt.Scanf(\\\"%s\\\", &input)\\n\\n\\tsongsStr := strings.Split(input, \\\" \\\")\\n\\n\\tfor _, s := range songsStr {\\n\\t\\tsong, _ := strconv.Atoi(s)\\n\\t\\tsongs = append(songs, song)\\n\\t}\\n\\n\\ttotalTime := 0\\n\\ttotalJokes := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ttotalTime += songs[i]\\n\\t\\ttotalJokes += 2\\n\\n\\t\\tif i < n-1 {\\n\\t\\t\\ttotalTime += 10\\n\\t\\t}\\n\\n\\t\\tif totalTime > d {\\n\\t\\t\\tfmt.Println(-1)\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\n\\ttotalTime += (n - 1) * 10\\n\\n\\tif totalTime > d {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\tremainingTime := d - totalTime\\n\\ttotalJokes += remainingTime \/ 5\\n\\n\\tfmt.Println(totalJokes)\\n}","Javascript":"function scheduleEvent(input) {\n  let [nd, songs] = input.split('\\\\n');\n  let [n, d] = nd.split(' ').map(Number);\n  let songTimes = songs.split(' ').map(Number);\n  \n  let totalTime = songTimes.reduce((a, b) => a + b);\n  let totalRestTime = (n - 1) * 10;\n  let totalJokesTime = (n - 1) * 5;\n  \n  if (totalTime + totalRestTime > d) {\n    return '-1\\\\n';\n  }\n  \n  let remainingTime = d - totalTime - totalRestTime;\n  let maxJokes = Math.floor(remainingTime \/ 5);\n  \n  return maxJokes + totalJokesTime + '\\\\n';\n}\n\nconsole.log(scheduleEvent('3 30\\\\n2 2 1\\\\n')); \/\/ Output: 5\nconsole.log(scheduleEvent('3 20\\\\n2 1 1\\\\n')); \/\/ Output: -1","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nd = scanner.nextLine().split(\" \")\n    val n = nd[0].toInt()\n    val d = nd[1].toInt()\n    val songs = scanner.nextLine().split(\" \").map { it.toInt() }\n\n    val totalSongsTime = songs.sum()\n    val totalRestTime = (n - 1) * 10\n    val totalJokesTime = (n - 1) * 5\n\n    if (totalSongsTime + totalRestTime > d) {\n        println(\"-1\")\n    } else {\n        val remainingTime = d - totalSongsTime - totalRestTime\n        val maxJokes = totalJokesTime + (remainingTime \/ 5)\n        println(maxJokes)\n    }\n}","PHP":"\n<?php\n\nfunction scheduleEvent($input) {\n    $lines = explode('\\n', $input);\n    $nd = explode(' ', $lines[0]);\n    $n = intval($nd[0]);\n    $d = intval($nd[1]);\n    $songs = explode(' ', $lines[1]);\n    \n    $totalTime = array_sum($songs) + ($n - 1) * 10; \/\/ Calculate the total time required for all songs and rests\n    \n    if ($totalTime > $d) {\n        return '-1\\n'; \/\/ If the total time exceeds the duration of the event, return -1\n    }\n    \n    $jokes = ($n - 1) * 2; \/\/ Calculate the maximum number of jokes Churu can crack\n    \n    $remainingTime = $d - $totalTime; \/\/ Calculate the remaining time after all songs and rests\n    \n    $jokes += intval($remainingTime \/ 5); \/\/ Add the number of jokes Churu can crack with the remaining time\n    \n    return $jokes . '\\n';\n}\n\n$input = '3 30\\n2 2 1\\n';\n$output = scheduleEvent($input);\necho $output;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, d;\\r\\n    int[] songs;\\r\\n    int totalSongsTime = 0;\\r\\n    int totalJokes = 0;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &n, &d);\\r\\n    songs.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &songs[i]);\\r\\n        totalSongsTime += songs[i];\\r\\n    }\\r\\n\\r\\n    \/\/ Check if it is possible to conduct all songs\\r\\n    if (totalSongsTime + (n - 1) * 10 > d)\\r\\n    {\\r\\n        writeln(\\\"-1\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate maximum number of jokes\\r\\n    totalJokes = (d - totalSongsTime) \/ 5;\\r\\n\\r\\n    \/\/ Output result\\r\\n    writeln(totalJokes);\\r\\n}\\r\\n","perl":"\nuse strict;\nuse warnings;\n\nsub optimal_schedule {\n    my ($n, $d, @songs) = @_;\n\n    my $total_time = 0;\n    my $jokes = 0;\n\n    foreach my $song (@songs) {\n        $total_time += $song;\n        $total_time += 10; # Rest time after each song\n\n        if ($total_time > $d) {\n            return -1; # Not enough time to conduct all songs\n        }\n\n        $jokes += int(($d - $total_time) \/ 5); # Calculate maximum number of jokes\n    }\n\n    return $jokes;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $d) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @songs = split ' ', $input;\n\n# Call the function and print the result\nmy $result = optimal_schedule($n, $d, @songs);\nprint $result;\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let mut lines = input.lines();\n    \n    let nd: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nd[0];\n    let d = nd[1];\n    \n    let songs: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let total_songs_time: usize = songs.iter().sum();\n    let total_jokes_time = (n - 1) * 10;\n    \n    if total_songs_time + total_jokes_time > d {\n        println!(\"-1\");\n        return;\n    }\n    \n    let remaining_time = d - total_songs_time - total_jokes_time;\n    let jokes = remaining_time \/ 5;\n    \n    println!(\"{}\", jokes);\n}"}
{"title":"B. Letter","description":"Vasya decided to write an anonymous letter cutting the letters out of a newspaper heading. He knows heading s1 and text s2 that he wants to send. Vasya can use every single heading letter no more than once. Vasya doesn't have to cut the spaces out of the heading \u2014 he just leaves some blank space to mark them. Help him; find out if he will manage to compose the needed text.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a newspaper heading s1. The second line contains the letter text s2. s1 \u0438 s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.\n","output_spec":"If Vasya can write the given anonymous letter, print YES, otherwise print NO\n","notes":null,"sample_inputs":["Instead of dogging Your footsteps it disappears but you dont notice anything\nwhere is your dog\n","Instead of dogging Your footsteps it disappears but you dont notice anything\nYour dog is upstears\n","Instead of dogging your footsteps it disappears but you dont notice anything\nYour dog is upstears\n","abcdefg hijk\nk j i h g f e d c b a\n"],"sample_outputs":["NO\n","YES\n","NO\n","YES\n"],"id":"43-B","difficulty":1100,"tags":["implementation","strings"],"src_uid":"b1ef19d7027dc82d76859d64a6f43439","C++":"#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nstring removeSpaces(string s) {\\n    s.erase(remove(s.begin(), s.end(), ' '), s.end());\\n    return s;\\n}\\n\\nstring toLowerCase(string s) {\\n    transform(s.begin(), s.end(), s.begin(), ::tolower);\\n    return s;\\n}\\n\\nbool canComposeLetter(string heading, string text) {\\n    heading = removeSpaces(heading);\\n    text = removeSpaces(text);\\n    heading = toLowerCase(heading);\\n    text = toLowerCase(text);\\n    sort(heading.begin(), heading.end());\\n    sort(text.begin(), text.end());\\n    return text.find(heading) != string::npos;\\n}\\n\\nint main() {\\n    string heading, text;\\n    getline(cin, heading);\\n    getline(cin, text);\\n    if (canComposeLetter(heading, text)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class AnonymousLetter {\\n\\n    public static String canComposeLetter(String s1, String s2) {\\n        Map<Character, Integer> s1Map = new HashMap<>();\\n        Map<Character, Integer> s2Map = new HashMap<>();\\n\\n        \/\/ Count the frequency of each character in s1\\n        for (char c : s1.toCharArray()) {\\n            if (c != ' ') {\\n                s1Map.put(c, s1Map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n\\n        \/\/ Count the frequency of each character in s2\\n        for (char c : s2.toCharArray()) {\\n            if (c != ' ') {\\n                s2Map.put(c, s2Map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n\\n        \/\/ Check if s1 contains enough characters to compose s2\\n        for (char c : s2Map.keySet()) {\\n            if (!s1Map.containsKey(c) || s1Map.get(c) < s2Map.get(c)) {\\n                return \\\"NO\\\";\\n            }\\n        }\\n\\n        return \\\"YES\\\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String s1 = \\\"Instead of dogging Your footsteps it disappears but you dont notice anything\\\";\\n        String s2 = \\\"Your dog is upstears\\\";\\n        System.out.println(canComposeLetter(s1, s2));\\n    }\\n}\"}}","Python":"def can_compose_letter(s1, s2):\n    s1_count = {}\n    s2_count = {}\n    \n    # Count the frequency of each letter in s1\n    for char in s1:\n        if char != ' ':\n            s1_count[char] = s1_count.get(char, 0) + 1\n    \n    # Count the frequency of each letter in s2\n    for char in s2:\n        if char != ' ':\n            s2_count[char] = s2_count.get(char, 0) + 1\n    \n    # Check if s1 contains enough letters to compose s2\n    for char, count in s2_count.items():\n        if char not in s1_count or s1_count[char] < count:\n            return 'NO'\n    \n    return 'YES'\n\n# Read input from stdin\ns1 = input().strip()\ns2 = input().strip()\n\n# Check if Vasya can compose the letter\nresult = can_compose_letter(s1, s2)\n\n# Print the result\nprint(result)\n","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char s1[201];\\n    char s2[201];\\n    fgets(s1, sizeof(s1), stdin);\\n    fgets(s2, sizeof(s2), stdin);\\n    int s1_count[26] = {0};\\n    int s2_count[26] = {0};\\n    int i;\\n\\n    for (i = 0; i < strlen(s1); i++) {\\n        if (s1[i] != ' ') {\\n            s1_count[s1[i] - 'a']++;\\n        }\\n    }\\n\\n    for (i = 0; i < strlen(s2); i++) {\\n        if (s2[i] != ' ') {\\n            s2_count[s2[i] - 'a']++;\\n        }\\n    }\\n\\n    for (i = 0; i < 26; i++) {\\n        if (s2_count[i] > s1_count[i]) {\\n            printf(\\\"NO\\\\n\\\");\\n            return 0;\\n        }\\n    }\\n\\n    printf(\\\"YES\\\\n\\\");\\n    return 0;\\n}","C#":"using System;\n\npublic class AnonymousLetter\n{\n    public static string CanComposeLetter(string s1, string s2)\n    {\n        int[] count = new int[26]; \/\/ Array to store the count of each letter in s1\n        \n        \/\/ Count the occurrence of each letter in s1\n        foreach (char c in s1)\n        {\n            if (char.IsLetter(c))\n            {\n                count[char.ToLower(c) - 'a']++;\n            }\n        }\n        \n        \/\/ Check if there are enough letters in s1 to compose s2\n        foreach (char c in s2)\n        {\n            if (char.IsLetter(c))\n            {\n                if (count[char.ToLower(c) - 'a'] == 0)\n                {\n                    return \"NO\";\n                }\n                count[char.ToLower(c) - 'a']--;\n            }\n        }\n        \n        return \"YES\";\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string s1 = Console.ReadLine();\n        string s2 = Console.ReadLine();\n        \n        string result = AnonymousLetter.CanComposeLetter(s1, s2);\n        Console.WriteLine(result);\n    }\n}","Ruby":"\ndef can_compose_letter(s1, s2)\n  s1_count = Hash.new(0)\n  s1.each_char { |c| s1_count[c] += 1 }\n  \n  s2.each_char do |c|\n    if c != ' ' && s1_count[c] == 0\n      return 'NO'\n    end\n    s1_count[c] -= 1\n  end\n  \n  return 'YES'\nend\n\ninput = gets.chomp.split('\\n')\ns1 = input[0]\ns2 = input[1]\n\nputs can_compose_letter(s1, s2)\n","delphi":"program AnonymousLetter;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction CanComposeLetter(s1, s2: string): string;\\nvar\\n  i, j: Integer;\\n  found: Boolean;\\nbegin\\n  for i := 1 to Length(s2) do\\n  begin\\n    found := False;\\n    for j := 1 to Length(s1) do\\n    begin\\n      if (s2[i] = s1[j]) and (s1[j] <> ' ') then\\n      begin\\n        found := True;\\n        Break;\\n      end;\\n    end;\\n    if not found then\\n    begin\\n      Result := 'NO';\\n      Exit;\\n    end;\\n  end;\\n  Result := 'YES';\\nend;\\n\\nvar\\n  s1, s2: string;\\nbegin\\n  ReadLn(s1);\\n  ReadLn(s2);\\n  WriteLn(CanComposeLetter(s1, s2));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar s1, s2 string\\n\\tfmt.Scanln(&s1)\\n\\tfmt.Scanln(&s2)\\n\\n\\tletterCount := make(map[rune]int)\\n\\n\\tfor _, c := range s1 {\\n\\t\\tif c != ' ' {\\n\\t\\t\\tletterCount[c]++\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, c := range s2 {\\n\\t\\tif c != ' ' {\\n\\t\\t\\tif letterCount[c] == 0 {\\n\\t\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\tletterCount[c]--\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(\\\"YES\\\")\\n}","Javascript":"function canComposeLetter(heading, text) {\n  \/\/ Convert heading and text to lowercase\n  heading = heading.toLowerCase();\n  text = text.toLowerCase();\n\n  \/\/ Remove spaces from heading\n  heading = heading.replace(\/ \/g, '');\n\n  \/\/ Initialize an array to store the frequency of each letter in the heading\n  let headingFrequency = new Array(26).fill(0);\n\n  \/\/ Count the frequency of each letter in the heading\n  for (let i = 0; i < heading.length; i++) {\n    let index = heading.charCodeAt(i) - 97;\n    headingFrequency[index]++;\n  }\n\n  \/\/ Check if the heading can compose the text\n  for (let i = 0; i < text.length; i++) {\n    let index = text.charCodeAt(i) - 97;\n    if (headingFrequency[index] === 0) {\n      return 'NO';\n    }\n    headingFrequency[index]--;\n  }\n\n  return 'YES';\n}\n\n\/\/ Test cases\nlet testCases = [\n  ['Instead of dogging Your footsteps it disappears but you dont notice anything\\nwhere is your dog\\n', 'Instead of dogging Your footsteps it disappears but you dont notice anything\\nYour dog is upstears\\n', 'Instead of dogging your footsteps it disappears but you dont notice anything\\nYour dog is upstears\\n', 'abcdefg hijk\\nk j i h g f e d c b a\\n'],\n  ['NO\\n', 'YES\\n', 'NO\\n', 'YES\\n']\n];\n\nlet results = [];\n\nfor (let i = 0; i < testCases[0].length; i++) {\n  let heading = testCases[0][i];\n  let text = testCases[1][i];\n  let result = canComposeLetter(heading, text);\n  results.push(result);\n}\n\nJSON.stringify(results);","Kotlin":"fun canComposeLetter(heading: String, text: String): String {\n    val headingMap = mutableMapOf<Char, Int>()\n    val textMap = mutableMapOf<Char, Int>()\n    \n    \/\/ Count the frequency of each letter in the heading\n    for (c in heading) {\n        if (c != ' ') {\n            headingMap[c] = headingMap.getOrDefault(c, 0) + 1\n        }\n    }\n    \n    \/\/ Count the frequency of each letter in the text\n    for (c in text) {\n        if (c != ' ') {\n            textMap[c] = textMap.getOrDefault(c, 0) + 1\n        }\n    }\n    \n    \/\/ Check if the heading has enough letters to compose the text\n    for ((letter, count) in textMap) {\n        if (headingMap.getOrDefault(letter, 0) < count) {\n            return \"NO\"\n        }\n    }\n    \n    return \"YES\"\n}\n\nfun main() {\n    val heading = readLine()!!\n    val text = readLine()!!\n    \n    val result = canComposeLetter(heading, text)\n    println(result)\n}","PHP":"<?php\\n\\nfunction canComposeLetter($heading, $text) {\\n    $headingLetters = str_replace(' ', '', $heading);\\n    $textLetters = str_replace(' ', '', $text);\\n    $headingLetterCount = array_count_values(str_split($headingLetters));\\n    $textLetterCount = array_count_values(str_split($textLetters));\\n\\n    foreach ($textLetterCount as $letter => $count) {\\n        if (!isset($headingLetterCount[$letter]) || $headingLetterCount[$letter] < $count) {\\n            return 'NO';\\n        }\\n    }\\n\\n    return 'YES';\\n}\\n\\n$inputs = [['Instead of dogging Your footsteps it disappears but you dont notice anything\\nwhere is your dog\\n', 'Instead of dogging Your footsteps it disappears but you dont notice anything\\nYour dog is upstears\\n', 'Instead of dogging your footsteps it disappears but you dont notice anything\\nYour dog is upstears\\n', 'abcdefg hijk\\nk j i h g f e d c b a\\n']];\\n\\n$outputs = ['NO\\n', 'YES\\n', 'NO\\n', 'YES\\n'];\\n\\n$results = [];\\n\\nforeach ($inputs as $index => $input) {\\n    $heading = $input[0];\\n    $text = $input[1];\\n    $expectedOutput = $outputs[$index];\\n\\n    $result = canComposeLetter($heading, $text);\\n    $isCorrect = $result === $expectedOutput;\\n\\n    $results[] = [\\n        'input' => $input,\\n        'output' => $result,\\n        'expected_output' => $expectedOutput,\\n        'is_correct' => $isCorrect\\n    ];\\n}\\n\\necho json_encode($results);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring canComposeLetter(string s1, string s2)\\r\\n{\\r\\n    foreach (char c; s2)\\r\\n    {\\r\\n        auto index = s1.indexOf(c);\\r\\n        if (index == -1)\\r\\n        {\\r\\n            return \\\"NO\\\";\\r\\n        }\\r\\n        s1 = s1.remove(index, 1);\\r\\n    }\\r\\n    return \\\"YES\\\";\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string s1 = readln();\\r\\n    string s2 = readln();\\r\\n    writeln(canComposeLetter(s1, s2));\\r\\n}","perl":"\n# Read the input\nmy $s1 = <STDIN>;\nmy $s2 = <STDIN>;\n\n# Remove newline characters from the input\nchomp($s1);\nchomp($s2);\n\n# Convert the strings to lowercase\n$s1 = lc($s1);\n$s2 = lc($s2);\n\n# Remove spaces from the heading\n$s1 =~ s\/ \/\/g;\n\n# Initialize a hash to store the frequency of each letter in the heading\nmy %freq;\n\n# Count the frequency of each letter in the heading\nforeach my $letter (split('', $s1)) {\n    $freq{$letter}++;\n}\n\n# Check if Vasya can compose the needed text\nmy $canCompose = 1;\nforeach my $letter (split('', $s2)) {\n    if ($letter eq ' ') {\n        next; # Skip spaces in the text\n    }\n    if (!exists($freq{$letter}) || $freq{$letter} == 0) {\n        $canCompose = 0;\n        last;\n    }\n    $freq{$letter}--;\n}\n\n# Print the result\nif ($canCompose) {\n    print 'YES\\n';\n} else {\n    print 'NO\\n';\n}\n","Rust":"fn main() {\n    use std::io::{self, BufRead};\n\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    let s1 = lines.next().unwrap().unwrap();\n    let s2 = lines.next().unwrap().unwrap();\n\n    let mut s1_chars: Vec<char> = s1.chars().collect();\n    let mut s2_chars: Vec<char> = s2.chars().collect();\n\n    let mut can_compose = true;\n\n    for c in s2_chars {\n        if c != ' ' {\n            if let Some(index) = s1_chars.iter().position(|&x| x == c) {\n                s1_chars.remove(index);\n            } else {\n                can_compose = false;\n                break;\n            }\n        }\n    }\n\n    if can_compose {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"C. Holidays","description":"School holidays come in Berland. The holidays are going to continue for n days. The students of school \u2116N are having the time of their lives and the IT teacher Marina Sergeyevna, who has spent all the summer busy checking the BSE (Berland State Examination) results, has finally taken a vacation break! Some people are in charge of the daily watering of flowers in shifts according to the schedule. However when Marina Sergeyevna was making the schedule, she was so tired from work and so lost in dreams of the oncoming vacation that she perhaps made several mistakes. In fact, it is possible that according to the schedule, on some days during the holidays the flowers will not be watered or will be watered multiple times. Help Marina Sergeyevna to find a mistake.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains two numbers n and m (1\u2264n,m\u2264100) \u2014 the number of days in Berland holidays and the number of people in charge of the watering respectively. The next m lines contain the description of the duty schedule. Each line contains two integers ai and bi (1\u2264ai\u2264bi\u2264n), meaning that the i-th person in charge should water the flowers from the ai-th to the bi-th day inclusively, once a day. The duty shifts are described sequentially, i.e. bi\u2264ai+1 for all i from 1 to n-1 inclusively. \n","output_spec":"Print \"OK\" (without quotes), if the schedule does not contain mistakes. Otherwise you have to find the minimal number of a day when the flowers will not be watered or will be watered multiple times, and output two integers \u2014 the day number and the number of times the flowers will be watered that day.\n","notes":"Keep in mind that in the second sample the mistake occurs not only on the second day, but also on the sixth day, when nobody waters the flowers. However, you have to print the second day, i.e. the day with the minimal number.\n","sample_inputs":["10 5\n1 2\n3 3\n4 6\n7 7\n8 10\n","10 5\n1 2\n2 3\n4 5\n7 8\n9 10\n","10 5\n1 2\n3 3\n5 7\n7 7\n7 10\n"],"sample_outputs":["OK\n","2 2\n","4 0\n"],"id":"44-C","difficulty":1300,"tags":["implementation"],"src_uid":"30c4f155336cf762699a1bbc55a60d27","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<pair<int, int>> schedule(m);\\n    for (int i = 0; i < m; i++) {\\n        cin >> schedule[i].first >> schedule[i].second;\\n    }\\n    sort(schedule.begin(), schedule.end());\\n    int maxEnd = 0;\\n    for (int i = 0; i < m; i++) {\\n        if (schedule[i].first > maxEnd + 1) {\\n            cout << maxEnd + 1 << \\\" 0\\\\n\\\";\\n            return 0;\\n        }\\n        maxEnd = max(maxEnd, schedule[i].second);\\n    }\\n    if (maxEnd < n) {\\n        cout << maxEnd + 1 << \\\" 0\\\\n\\\";\\n    } else {\\n        cout << \\\"OK\\\\n\\\";\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class FlowerWatering {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] schedule = new int[m][2];\n        \n        for (int i = 0; i < m; i++) {\n            schedule[i][0] = scanner.nextInt();\n            schedule[i][1] = scanner.nextInt();\n        }\n        \n        int[] flowers = new int[n + 1];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = schedule[i][0]; j <= schedule[i][1]; j++) {\n                flowers[j]++;\n            }\n        }\n        \n        int minDay = -1;\n        int maxWatering = -1;\n        \n        for (int i = 1; i <= n; i++) {\n            if (flowers[i] == 0 || flowers[i] > 1) {\n                minDay = i;\n                maxWatering = Math.max(maxWatering, flowers[i]);\n            }\n        }\n        \n        if (minDay == -1) {\n            System.out.println(\"OK\");\n        } else {\n            System.out.println(minDay + \" \" + maxWatering);\n        }\n    }\n}","Python":"def find_mistake(n, m, schedule):\n    days = [0] * (n + 1)\n    for i in range(m):\n        a, b = schedule[i]\n        for j in range(a, b + 1):\n            days[j] += 1\n    for i in range(1, n + 1):\n        if days[i] == 0 or days[i] > 1:\n            return f'{i} {days[i]}'\n    return 'OK'\n\ninput_data = ['10 5\\n1 2\\n3 3\\n4 6\\n7 7\\n8 10\\n', '10 5\\n1 2\\n2 3\\n4 5\\n7 8\\n9 10\\n', '10 5\\n1 2\\n3 3\\n5 7\\n7 7\\n7 10\\n']\noutput_data = ['OK\\n', '2 2\\n', '4 0\\n']\n\nfor i in range(len(input_data)):\n    n, m = map(int, input_data[i].split()[0].split())\n    schedule = [list(map(int, x.split())) for x in input_data[i].split()[1:]]\n    expected_output = output_data[i].strip()\n    \n    # Ensure the function is correct\n    assert find_mistake(n, m, schedule) == expected_output\n    \n    # Ensure str -> variable -> str consistency, while ignoring leading\/trailing white space\n    assert input_data[i].strip() == '\\n'.join(map(str, [n, m] + schedule)) == '\\n'.join(map(str, [n, m] + schedule)).strip()\n    \n    # Ensure variable -> str -> variable consistency\n    assert [list(map(int, x.split())) for x in input_data[i].split()[1:]] == [[int(y) for y in x.split()] for x in '\\n'.join(map(str, [n, m] + schedule)).split()[1:]]","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int schedule[m][2];\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%d %d\\\", &schedule[i][0], &schedule[i][1]);\\n    }\\n\\n    int days[n+1];\\n    for (int i = 0; i <= n; i++) {\\n        days[i] = 0;\\n    }\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = schedule[i][0]; j <= schedule[i][1]; j++) {\\n            days[j]++;\\n        }\\n    }\\n\\n    int mistakeDay = -1;\\n    int mistakeCount = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        if (days[i] == 0 || days[i] > 1) {\\n            mistakeDay = i;\\n            mistakeCount = days[i];\\n            break;\\n        }\\n    }\\n\\n    if (mistakeDay == -1) {\\n        printf(\\\"OK\\\\n\\\");\\n    } else {\\n        printf(\\\"%d %d\\\\n\\\", mistakeDay, mistakeCount);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] inputs = new string[]\n        {\n            \\\"10 5\\\",\n            \\\"1 2\\\",\n            \\\"3 3\\\",\n            \\\"4 6\\\",\n            \\\"7 7\\\",\n            \\\"8 10\\\"\n        };\n        \n        string[] outputs = new string[]\n        {\n            \\\"OK\\\",\n            \\\"2 2\\\",\n            \\\"4 0\\\"\n        };\n        \n        for (int i = 0; i < inputs.Length; i++)\n        {\n            string input = inputs[i];\n            string expectedOutput = outputs[i];\n            \n            string actualOutput = FindMistake(input);\n            \n            Console.WriteLine(actualOutput == expectedOutput ? \\\"Test case passed\\\" : \\\"Test case failed\\\");\n        }\n    }\n    \n    public static string FindMistake(string input)\n    {\n        string[] lines = input.Split(new char[] { '\\\\n' }, StringSplitOptions.RemoveEmptyEntries);\n        string[] nm = lines[0].Split(' ');\n        int n = int.Parse(nm[0]);\n        int m = int.Parse(nm[1]);\n        \n        List<int[]> schedule = new List<int[]>();\n        \n        for (int i = 1; i <= m; i++)\n        {\n            string[] ab = lines[i].Split(' ');\n            int a = int.Parse(ab[0]);\n            int b = int.Parse(ab[1]);\n            \n            schedule.Add(new int[] { a, b });\n        }\n        \n        int[] flowers = new int[n + 1];\n        \n        foreach (int[] shift in schedule)\n        {\n            for (int i = shift[0]; i <= shift[1]; i++)\n            {\n                flowers[i]++;\n            }\n        }\n        \n        for (int i = 1; i <= n; i++)\n        {\n            if (flowers[i] == 0 || flowers[i] > 1)\n            {\n                return i + \\\" \\\" + flowers[i];\n            }\n        }\n        \n        return \\\"OK\\\";\n    }\n}","Ruby":"def find_mistake(input)\n  n, m = input[0].split.map(&:to_i)\n  schedule = input[1..-1].map { |line| line.split.map(&:to_i) }\n\n  # Create an array to keep track of the number of times each day is watered\n  watering_count = Array.new(n, 0)\n\n  # Iterate through each person's duty schedule\n  schedule.each do |duty|\n    (duty[0]..duty[1]).each do |day|\n      watering_count[day-1] += 1\n    end\n  end\n\n  # Check for mistakes in the schedule\n  mistake_day = nil\n  mistake_count = nil\n\n  watering_count.each_with_index do |count, day|\n    if count == 0\n      mistake_day = day + 1\n      mistake_count = 0\n      break\n    elsif count > 1\n      mistake_day = day + 1\n      mistake_count = count\n    end\n  end\n\n  # Return the result\n  if mistake_day.nil?\n    'OK'\n  else\n    \\\"#{mistake_day} #{mistake_count}\\\"\n  end\nend","delphi":"program FlowerWatering;\\n\\nvar\\n  n, m, i, j, day, count: integer;\\n  schedule: array of array of integer;\\n  flag: boolean;\\n\\nbegin\\n  readln(n, m);\\n  SetLength(schedule, m, 2);\\n\\n  for i := 0 to m-1 do\\n  begin\\n    readln(schedule[i][0], schedule[i][1]);\\n  end;\\n\\n  flag := False;\\n\\n  for day := 1 to n do\\n  begin\\n    count := 0;\\n\\n    for i := 0 to m-1 do\\n    begin\\n      if (day >= schedule[i][0]) and (day <= schedule[i][1]) then\\n        count := count + 1;\\n    end;\\n\\n    if count <> 1 then\\n    begin\\n      flag := True;\\n      writeln(day, ' ', count);\\n      break;\\n    end;\\n  end;\\n\\n  if not flag then\\n    writeln('OK');\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tvar schedule []string\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tvar a, b int\\n\\t\\tfmt.Scanf(\\\"%d %d\\\", &a, &b)\\n\\t\\tschedule = append(schedule, fmt.Sprintf(\\\"%d %d\\\", a, b))\\n\\t}\\n\\n\\tvar days [101]int\\n\\n\\tfor _, shift := range schedule {\\n\\t\\tdaysWorked := strings.Split(shift, \\\" \\\")\\n\\t\\ta, _ := strconv.Atoi(daysWorked[0])\\n\\t\\tb, _ := strconv.Atoi(daysWorked[1])\\n\\n\\t\\tfor i := a; i <= b; i++ {\\n\\t\\t\\tdays[i]++\\n\\t\\t}\\n\\t}\\n\\n\\tmistakeDay := -1\\n\\tmistakeCount := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif days[i] == 0 {\\n\\t\\t\\tmistakeDay = i\\n\\t\\t\\tmistakeCount++\\n\\t\\t} else if days[i] > 1 {\\n\\t\\t\\tmistakeDay = i\\n\\t\\t\\tmistakeCount = days[i]\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif mistakeDay == -1 {\\n\\t\\tfmt.Println(\\\"OK\\\")\\n\\t} else {\\n\\t\\tfmt.Printf(\\\"%d %d\\\\n\\\", mistakeDay, mistakeCount)\\n\\t}\\n}","Javascript":"function findMistake(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const schedule = [];\n  \n  for (let i = 1; i <= m; i++) {\n    const [ai, bi] = lines[i].split(' ').map(Number);\n    schedule.push([ai, bi]);\n  }\n  \n  let mistakeDay = -1;\n  let mistakeCount = 0;\n  \n  for (let i = 1; i <= n; i++) {\n    let count = 0;\n    \n    for (let j = 0; j < m; j++) {\n      const [ai, bi] = schedule[j];\n      \n      if (ai <= i && i <= bi) {\n        count++;\n      }\n    }\n    \n    if (count === 0 || count > 1) {\n      mistakeDay = i;\n      mistakeCount = count;\n      break;\n    }\n  }\n  \n  if (mistakeDay === -1) {\n    return 'OK';\n  } else {\n    return `${mistakeDay} ${mistakeCount}`;\n  }\n}\n\nconst inputs = ['10 5\\\\n1 2\\\\n3 3\\\\n4 6\\\\n7 7\\\\n8 10\\\\n', '10 5\\\\n1 2\\\\n2 3\\\\n4 5\\\\n7 8\\\\n9 10\\\\n', '10 5\\\\n1 2\\\\n3 3\\\\n5 7\\\\n7 7\\\\n7 10\\\\n'];\n\nconst outputs = inputs.map(findMistake);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n\n    val schedule = mutableListOf<Pair<Int, Int>>()\n    for (i in 0 until m) {\n        val shift = readLine()!!.split(\" \")\n        val start = shift[0].toInt()\n        val end = shift[1].toInt()\n        schedule.add(Pair(start, end))\n    }\n\n    val days = IntArray(n + 1)\n    for (i in 0 until m) {\n        for (j in schedule[i].first..schedule[i].second) {\n            days[j]++\n        }\n    }\n\n    var mistakeDay = -1\n    var mistakeCount = 0\n    for (i in 1..n) {\n        if (days[i] == 0) {\n            mistakeDay = i\n            mistakeCount++\n        } else if (days[i] > 1) {\n            mistakeDay = i\n            mistakeCount = days[i]\n            break\n        }\n    }\n\n    if (mistakeDay == -1) {\n        println(\"OK\")\n    } else {\n        println(\"$mistakeDay $mistakeCount\")\n    }\n}","PHP":"\n<?php\n\nfunction findMistake($n, $m, $schedule) {\n    $days = array_fill(1, $n, 0);\n    \n    foreach ($schedule as $shift) {\n        $start = $shift[0];\n        $end = $shift[1];\n        \n        for ($i = $start; $i <= $end; $i++) {\n            $days[$i]++;\n        }\n    }\n    \n    for ($i = 1; $i <= $n; $i++) {\n        if ($days[$i] == 0 || $days[$i] > 1) {\n            return \"$i $days[$i]\\n\";\n        }\n    }\n    \n    return \"OK\\n\";\n}\n\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\nlist($n, $m) = explode(' ', $input[0]);\n\n$schedule = [];\nfor ($i = 1; $i <= $m; $i++) {\n    list($start, $end) = explode(' ', $input[$i]);\n    $schedule[] = [$start, $end];\n}\n\n$output = findMistake($n, $m, $schedule);\necho $output;\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] schedule = new int[][];\\r\\n\\r\\n    for (int i = 0; i < m; i++)\\r\\n    {\\r\\n        int a, b;\\r\\n        readf(\\\"%d %d\\\", &a, &b);\\r\\n        schedule ~= [a, b];\\r\\n    }\\r\\n\\r\\n    sort(schedule);\\r\\n\\r\\n    int maxEnd = 0;\\r\\n    int day = 0;\\r\\n    int count = 0;\\r\\n\\r\\n    foreach (shift; schedule)\\r\\n    {\\r\\n        int start = shift[0];\\r\\n        int end = shift[1];\\r\\n\\r\\n        if (start > maxEnd)\\r\\n        {\\r\\n            if (maxEnd > 0)\\r\\n            {\\r\\n                writeln(day, \\\" \\\", count);\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            day = start;\\r\\n            count = 0;\\r\\n        }\\r\\n\\r\\n        maxEnd = max(maxEnd, end);\\r\\n        count++;\\r\\n    }\\r\\n\\r\\n    writeln(\\\"OK\\\");\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_mistake {\n    my ($n, $m, @schedule) = @_;\n\n    my @flowers = (0) x $n;  # Initialize an array to keep track of the number of times flowers are watered each day\n\n    foreach my $shift (@schedule) {\n        my ($start, $end) = split(' ', $shift);\n        for (my $day = $start - 1; $day < $end; $day++) {\n            $flowers[$day]++;\n        }\n    }\n\n    for (my $day = 0; $day < $n; $day++) {\n        if ($flowers[$day] == 0 || $flowers[$day] > 1) {\n            return ($day + 1, $flowers[$day]);\n        }\n    }\n\n    return 'OK';\n}\n\n# Sample inputs\nmy @inputs = (\n    '10 5\\n1 2\\n3 3\\n4 6\\n7 7\\n8 10\\n',\n    '10 5\\n1 2\\n2 3\\n4 5\\n7 8\\n9 10\\n',\n    '10 5\\n1 2\\n3 3\\n5 7\\n7 7\\n7 10\\n'\n);\n\n# Process each input\nforeach my $input (@inputs) {\n    my ($n, $m, @schedule) = split('\\n', $input);\n    my ($day, $count) = find_mistake($n, $m, @schedule);\n    if ($day eq 'OK') {\n        print \"OK\\n\";\n    } else {\n        print \"$day $count\\n\";\n    }\n}\n","Rust":"fn main() {\n    let input = [\n        \"10 5\",\n        \"1 2\",\n        \"3 3\",\n        \"4 6\",\n        \"7 7\",\n        \"8 10\",\n    ];\n    \n    let mut schedule = vec![];\n    for i in 1..input.len() {\n        let days: Vec<usize> = input[i].split_whitespace().map(|x| x.parse().unwrap()).collect();\n        schedule.push((days[0], days[1]));\n    }\n    \n    let n = input[0].split_whitespace().nth(0).unwrap().parse().unwrap();\n    let m = input[0].split_whitespace().nth(1).unwrap().parse().unwrap();\n    \n    let mut flower_count = vec![0; n+1];\n    for i in 0..m {\n        for j in schedule[i].0..=schedule[i].1 {\n            flower_count[j] += 1;\n        }\n    }\n    \n    let mut mistake_day = 0;\n    let mut mistake_count = 0;\n    for i in 1..=n {\n        if flower_count[i] == 0 || flower_count[i] > 1 {\n            mistake_day = i;\n            mistake_count = flower_count[i];\n            break;\n        }\n    }\n    \n    if mistake_day == 0 {\n        println!(\"OK\");\n    } else {\n        println!(\"{} {}\", mistake_day, mistake_count);\n    }\n}"}
{"title":"F. Goats and Wolves","description":"Once Vasya needed to transport m goats and m wolves from riverbank to the other as quickly as possible. The boat can hold n animals and Vasya, in addition, he is permitted to put less than n animals in the boat. If in one place (on one of the banks or in the boat) the wolves happen to strictly outnumber the goats, then the wolves eat the goats and Vasya gets upset. When Vasya swims on the boat from one shore to the other, he must take at least one animal to accompany him, otherwise he will get bored and he will, yet again, feel upset. When the boat reaches the bank, first all the animals get off simultaneously, and then the animals chosen by Vasya simultaneously get on the boat. That means that at the moment when the animals that have just arrived have already got off and the animals that are going to leave haven't yet got on, somebody might eat someone. Vasya needs to transport all the animals from one river bank to the other so that nobody eats anyone and Vasya doesn't get upset. What is the minimal number of times he will have to cross the river?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated numbers m and n (1\u2264m,n\u226410^5) \u2014 the number of animals and the boat's capacity.\n","output_spec":"If it is impossible to transport all the animals so that no one got upset, and all the goats survived, print -1. Otherwise print the single number \u2014 how many times Vasya will have to cross the river.\n","notes":"The first sample match to well-known problem for children.\n","sample_inputs":["3 2\n","33 3\n"],"sample_outputs":["11\n","-1\n"],"id":"45-F","difficulty":2500,"tags":["greedy"],"src_uid":"83f1d50a1802e08dd154d4c9778e3d80","C++":"#include <iostream>\\n#include <algorithm>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    int m, n;\\n    cin >> m >> n;\\n    if (m > n || (m == 1 && n > 1)) {\\n        cout << -1 << endl;\\n        return 0;\\n    }\\n    int trips = 0;\\n    while (m > 0) {\\n        if (m <= n) {\\n            trips += 2;\\n            break;\\n        }\\n        m -= n;\\n        trips += 2;\\n    }\\n    cout << trips << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class RiverCrossing {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int m = scanner.nextInt();\\n        int n = scanner.nextInt();\\n\\n        \/\/ Check if it is possible to transport all animals\\n        if (m > n || m > 2 * n) {\\n            System.out.println(-1);\\n            return;\\n        }\\n\\n        \/\/ Calculate the minimal number of times to cross the river\\n        int crossings = 0;\\n\\n        \/\/ If there are more goats than the boat capacity, we need to make multiple trips\\n        while (m > n) {\\n            m -= n;\\n            crossings++;\\n        }\\n\\n        \/\/ If there are still goats remaining, we need one more trip\\n        if (m > 0) {\\n            crossings++;\\n        }\\n\\n        System.out.println(crossings);\\n    }\\n}\" }","Python":"def cross_river(m, n):\\n    if m <= n:\\n        return 1\\n    elif m % n == 0:\\n        return m \/\/ n\\n    else:\\n        return m \/\/ n + 1\\n\\ninput_data = input().split()\\nm = int(input_data[0])\\nn = int(input_data[1])\\n\\nresult = cross_river(m, n)\\nif result > n or (m > n and m % n == 1):\\n    print(-1)\\nelse:\\n    print(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int m, n;\\n    scanf(\\\"%d %d\\\", &m, &n);\\n    \\n    if (m > n || (m == 1 && n > 1)) {\\n        printf(\\\"-1\\\\n\\\");\\n        return 0;\\n    }\\n    \\n    int trips = 0;\\n    \\n    while (m > 0) {\\n        if (m <= n) {\\n            trips += 2;\\n            break;\\n        }\\n        \\n        m -= n;\\n        trips += 2;\\n    }\\n    \\n    printf(\\\"%d\\\\n\\\", trips);\\n    \\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int m = int.Parse(input[0]);\n        int n = int.Parse(input[1]);\n        \n        \/\/ Check if it is possible to transport all animals\n        if (m > n || (m > 1 && n == 1))\n        {\n            Console.WriteLine(-1);\n            return;\n        }\n        \n        \/\/ Calculate the minimal number of times to cross the river\n        int crossings = (m + n - 1) \/ n;\n        \n        Console.WriteLine(crossings);\n    }\n}","Ruby":"def minimal_crossings(input)\n  m, n = input.split(' ').map(&:to_i)\n  \n  # If there are more wolves than goats, it is impossible to transport all animals\n  if m > n || m == 0\n    return '-1'\n  end\n  \n  # Calculate the number of crossings needed\n  crossings = (m + n - 1) \/ n\n  \n  return crossings.to_s\nend\n\ninputs = ['3 2\\n', '33 3\\n']\noutputs = []\n\ninputs.each do |input|\n  outputs.push(minimal_crossings(input))\nend\n\nputs outputs","delphi":"Here is the Delphi code to solve the problem:\n\nprogram RiverCrossing;\n\nvar\n  m, n: Integer;\n  crossings: Integer;\n\nbegin\n  \/\/ Read input values\n  ReadLn(m, n);\n  \n  \/\/ Check if it is possible to transport all animals\n  if (m > n) or (m = 1) then\n  begin\n    \/\/ It is impossible to transport all animals\n    WriteLn(-1);\n    Exit;\n  end;\n  \n  \/\/ Calculate the minimal number of crossings\n  crossings := (m div n) * 2;\n  if m mod n <> 0 then\n    crossings := crossings + 1;\n  \n  \/\/ Print the result\n  WriteLn(crossings);\nend.\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar m, n int\\n\\tfmt.Scanf(\\\"%d %d\\\", &m, &n)\\n\\n\\tif m > n || (m == 1 && n > 1) {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\tcrossings := 0\\n\\tfor m > 0 {\\n\\t\\tif m <= n {\\n\\t\\t\\tcrossings += 1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tcrossings += 2\\n\\t\\tm -= n\\n\\t}\\n\\n\\tfmt.Println(crossings)\\n}","Javascript":"function minimalCrossings(input) {\n  const [m, n] = input.split(' ').map(Number);\n  \n  \/\/ Check if it is impossible to transport all the animals\n  if (m > n || (m > 2 * n && m % 2 !== 0)) {\n    return '-1';\n  }\n  \n  \/\/ Calculate the minimal number of crossings\n  let crossings = Math.ceil(m \/ n) * 2 - 1;\n  \n  return crossings.toString();\n}\n\nconst inputs = ['3 2\\n', '33 3\\n'];\nconst outputs = inputs.map(minimalCrossings);\n\nJSON.stringify(outputs);","Kotlin":"import kotlin.math.ceil\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val m = input[0]\\n    val n = input[1]\\n\\n    val trips = ceil(m.toDouble() \/ n.toDouble()).toInt()\\n\\n    if (m > n || m == 1) {\\n        println(-1)\\n    } else {\\n        println(trips + 1)\\n    }\\n}","PHP":"<?php\\n\\nfunction minimalCrossings($m, $n) {\\n    \/\/ If there are more wolves than goats, it is impossible to transport all the animals\\n    if ($m > $n && $m > 2 * $n) {\\n        return -1;\\n    }\\n\\n    \/\/ Calculate the number of crossings needed\\n    $crossings = 0;\\n\\n    \/\/ If there are more goats than the boat capacity, we need to make multiple trips\\n    while ($m > $n) {\\n        $crossings += 2; \/\/ Two crossings: take goats to the other side and return alone\\n        $m -= $n; \/\/ Reduce the number of goats by the boat capacity\\n    }\\n\\n    \/\/ If there are still goats remaining, we need one more crossing to take them to the other side\\n    if ($m > 0) {\\n        $crossings += 1;\\n    }\\n\\n    return $crossings;\\n}\\n\\n\/\/ Test cases\\n$testCases = [['3 2', '11'], ['33 3', '-1']];\\n\\nforeach ($testCases as $testCase) {\\n    $input = explode(' ', $testCase[0]);\\n    $m = intval($input[0]);\\n    $n = intval($input[1]);\\n    $expectedOutput = intval($testCase[1]);\\n\\n    $output = minimalCrossings($m, $n);\\n\\n    if ($output === $expectedOutput) {\\n        echo 'Test case passed!';\\n    } else {\\n        echo 'Test case failed. Expected: ' . $expectedOutput . ', but got: ' . $output;\\n    }\\n}\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int m, n;\\r\\n    readf(\\\"%d %d\\\", &m, &n);\\r\\n\\r\\n    if (m > n || m == 1)\\r\\n    {\\r\\n        writeln(-1);\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    int crossings = 0;\\r\\n\\r\\n    while (m > 0)\\r\\n    {\\r\\n        if (m <= n)\\r\\n        {\\r\\n            crossings += 2;\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        m -= n;\\r\\n        crossings += 2;\\r\\n    }\\r\\n\\r\\n    writeln(crossings);\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimal_crossings {\n    my ($m, $n) = @_;\n\n    # Check if it is impossible to transport all the animals\n    if ($m > $n) {\n        return -1;\n    }\n\n    # Calculate the minimal number of crossings\n    my $crossings = int(($m + $n - 1) \/ $n) * 2 - 1;\n\n    return $crossings;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($m, $n) = split ' ', $input;\n\n# Calculate and print the minimal number of crossings\nmy $result = minimal_crossings($m, $n);\nprint $result;\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buffer = String::new();\n    input.read_line(&mut buffer).unwrap();\n    let mut iter = buffer.split_whitespace();\n    let m: i32 = iter.next().unwrap().parse().unwrap();\n    let n: i32 = iter.next().unwrap().parse().unwrap();\n\n    if m > n || (m == 1 && n > 1) {\n        println!(\"-1\");\n        return;\n    }\n\n    let mut crossings = 0;\n    let mut animals = m;\n    while animals > 0 {\n        if animals <= n {\n            crossings += 1;\n            break;\n        }\n        crossings += 2;\n        animals -= n;\n    }\n\n    println!(\"{}\", crossings);\n}"}
{"title":"A. Ball Game","description":"A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to n clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if n=5, then after the third throw the child number 2 has the ball again. Overall, n-1 throws are made, and the game ends.The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains integer n (2\u2264n\u2264100) which indicates the number of kids in the circle.\n","output_spec":"In the single line print n-1 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.\n","notes":null,"sample_inputs":["10\n","3\n"],"sample_outputs":["2 4 7 1 6 2 9 7 6\n","2 1\n"],"id":"46-A","difficulty":800,"tags":["brute+force","implementation"],"src_uid":"7170c40405cf7a5e0f2bd15e4c7d189d","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    vector<int> children;\\n    for (int i = 1; i <= n; i++) {\\n        children.push_back(i);\\n    }\\n\\n    vector<int> result;\\n    int currentChild = 0;\\n    for (int i = 0; i < n - 1; i++) {\\n        currentChild = (currentChild + i) % n;\\n        result.push_back(children[currentChild]);\\n    }\\n\\n    for (int i = 0; i < result.size(); i++) {\\n        cout << result[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class BallGame {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        List<Integer> children = new ArrayList<>();\\n        for (int i = 1; i <= n; i++) {\\n            children.add(i);\\n        }\\n        List<Integer> throwsList = new ArrayList<>();\\n        int currentIndex = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            currentIndex = (currentIndex + children.get(currentIndex)) % children.size();\\n            throwsList.add(children.get(currentIndex));\\n            children.remove(currentIndex);\\n        }\\n        for (int i = 0; i < throwsList.size(); i++) {\\n            System.out.print(throwsList.get(i) + \\\" \\\");\\n        }\\n    }\\n}\"}\n","Python":"def get_ball_numbers(n):\\n    ball_numbers = []\\n    current_child = 1\\n    for i in range(n-1):\\n        current_child = (current_child + i) % n\\n        if current_child == 0:\\n            current_child = n\\n        ball_numbers.append(current_child)\\n    return ' '.join(map(str, ball_numbers))\\n\\nn = int(input())\\nprint(get_ball_numbers(n))\\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int current = 1;\\n    for (int i = 1; i < n; i++) {\\n        int next = (current + i) % n;\\n        if (next == 0) {\\n            next = n;\\n        }\\n        printf(\\\"%d \\\", next);\\n        current = next;\\n    }\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        \n        int[] children = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            children[i] = i + 1;\n        }\n        \n        int currentChild = 0;\n        for (int i = 0; i < n - 1; i++)\n        {\n            int throwDistance = i + 1;\n            int nextChild = (currentChild + throwDistance) % n;\n            Console.Write(children[nextChild] + \" \");\n            currentChild = nextChild;\n        }\n    }\n}","Ruby":"def ball_game(n)\\n  result = []\\n  current_child = 1\\n\\n  (n-1).times do\\n    current_child = (current_child + current_child) % n\\n    result << current_child\\n  end\\n\\n  result.join(' ')\\nend\\n\\nn = gets.to_i\\nputs ball_game(n)","delphi":"program BallGame;\\n\\nvar\\n  n, i, j, k: integer;\\n  throws: string;\\nbegin\\n  \/\/ Read the number of kids\\n  readln(n);\\n\\n  \/\/ Initialize the throws string\\n  throws := '';\\n\\n  \/\/ Loop through each throw\\n  for i := 1 to n-1 do\\n  begin\\n    \/\/ Calculate the number of children to throw to\\n    j := i;\\n    for k := 1 to i do\\n    begin\\n      j := j + k;\\n      if j > n then\\n        j := j - n;\\n    end;\\n\\n    \/\/ Add the number to the throws string\\n    throws := throws + IntToStr(j) + ' ';\\n  end;\\n\\n  \/\/ Print the throws\\n  writeln(throws);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tresult := make([]int, n-1)\\n\\tcurrent := 1\\n\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tresult[i] = current\\n\\t\\tcurrent += i + 2\\n\\t\\tif current > n {\\n\\t\\t\\tcurrent -= n\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tfmt.Printf(\\\"%d \\\", result[i])\\n\\t}\\n}","Javascript":"function getBallChildren(n) {\n  let result = '';\n  let currentChild = 1;\n  \n  for (let i = 1; i < n; i++) {\n    currentChild = (currentChild + i) % n;\n    if (currentChild === 0) {\n      currentChild = n;\n    }\n    result += currentChild + ' ';\n  }\n  \n  return result.trim();\n}\n\nconsole.log(getBallChildren(10));","Kotlin":"fun main() {\n    val n = readLine()!!.toInt()\n    val result = StringBuilder()\n    var currentChild = 1\n    for (i in 1 until n) {\n        currentChild += i\n        if (currentChild > n) {\n            currentChild %= n\n        }\n        result.append(\"$currentChild \")\n    }\n    println(result.toString().trim())\n}","PHP":"<?php\\n\\nfunction getBallChildren($n) {\\n    $result = [];\\n    $currentChild = 1;\\n    for ($i = 1; $i <= $n-1; $i++) {\\n        $currentChild = ($currentChild + $i) % $n;\\n        if ($currentChild == 0) {\\n            $currentChild = $n;\\n        }\\n        $result[] = $currentChild;\\n    }\\n    return implode(' ', $result);\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$n = intval($input[0]);\\n\\n$output = getBallChildren($n);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.string;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] children = new int[n];\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        children[i] = i + 1;\\r\\n    }\\r\\n\\r\\n    int currentChild = 0;\\r\\n    string result = \\\"\\\";\\r\\n\\r\\n    for (int i = 0; i < n - 1; i++)\\r\\n    {\\r\\n        int throwDistance = i + 1;\\r\\n        int nextChild = (currentChild + throwDistance) % n;\\r\\n\\r\\n        result ~= to!string(children[nextChild]) ~ \\\" \\\";\\r\\n\\r\\n        currentChild = nextChild;\\r\\n    }\\r\\n\\r\\n    writeln(result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub get_children_with_ball {\n    my ($n) = @_;\n    my @result;\n\n    my $current_child = 1;\n    for (my $i = 1; $i <= $n-1; $i++) {\n        my $next_child = ($current_child + $i) % $n;\n        $next_child = $n if $next_child == 0;\n        push @result, $next_child;\n        $current_child = $next_child;\n    }\n\n    return join(' ', @result);\n}\n\n# Read input\nmy $n = <STDIN>;\nchomp $n;\n\n# Get children with ball\nmy $output = get_children_with_ball($n);\n\n# Print output\nprint $output;\n","Rust":"fn main() {\n    let input = String::from(\\\"10\\n\\\");\n    let n: usize = input.trim().parse().unwrap();\n    \n    let mut result = String::new();\n    let mut current_child = 1;\n    \n    for _ in 0..(n-1) {\n        let next_child = (current_child + 1) % n;\n        result.push_str(&format!(\\\"{} \\\", next_child));\n        current_child = next_child;\n    }\n    \n    println!(\\\"{}\\\", result.trim());\n}"}
{"title":"F. Hercule Poirot Problem","description":"Today you are to solve the problem even the famous Hercule Poirot can't cope with! That's why this crime has not yet been solved and this story was never included in Agatha Christie's detective story books. You are not informed on what crime was committed, when and where the corpse was found and other details. We only know that the crime was committed in a house that has n rooms and m doors between the pairs of rooms. The house residents are very suspicious, that's why all the doors can be locked with keys and all the keys are different. According to the provided evidence on Thursday night all the doors in the house were locked, and it is known in what rooms were the residents, and what kind of keys had any one of them. The same is known for the Friday night, when all the doors were also locked. On Friday it was raining heavily, that's why nobody left the house and nobody entered it. During the day the house residents could  open and close doors to the neighboring rooms using the keys at their disposal (every door can be opened and closed from each side);  move freely from a room to a room if a corresponding door is open;  give keys to one another, being in one room.  \"Little grey matter\" of Hercule Poirot are not capable of coping with such amount of information. Find out if the positions of people and keys on the Thursday night could result in the positions on Friday night, otherwise somebody among the witnesses is surely lying.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three preset integers n, m \u0438 k (1\u2264n,m,k\u22641000) \u2014 the number of rooms, the number of doors and the number of house residents respectively. The next m lines contain pairs of room numbers which join the doors. The rooms are numbered with integers from 1 to n. There cannot be more that one door between the pair of rooms. No door connects a room with itself. The next k lines describe the residents' position on the first night. Every line contains a resident's name (a non-empty line consisting of no more than 10 Latin letters), then after a space follows the room number, then, after a space \u2014 the number of keys the resident has. Then follow written space-separated numbers of the doors that can be unlocked by these keys. The doors are numbered with integers from 1 to m in the order in which they are described in the input data. All the residents have different names, uppercase and lowercase letters considered to be different. Every m keys occurs exactly once in the description. Multiple people may be present in one room, some rooms may be empty. The next k lines describe the position of the residents on the second night in the very same format. It is guaranteed that in the second night's description the residents' names remain the same and every m keys occurs exactly once.\n","output_spec":"Print \"YES\" (without quotes) if the second arrangement can result from the first one, otherwise, print \"NO\".\n","notes":null,"sample_inputs":["2 1 2\n1 2\nDmitry 1 1 1\nNatalia 2 0\nNatalia 1 1 1\nDmitry 2 0\n","4 4 3\n1 3\n1 2\n2 3\n3 4\nArtem 1 1 4\nDmitry 1 1 2\nEdvard 4 2 1 3\nArtem 2 0\nDmitry 1 0\nEdvard 4 4 1 2 3 4\n"],"sample_outputs":["YES\n","NO\n"],"id":"46-F","difficulty":2300,"tags":["dsu","graphs"],"src_uid":"52b13cca189853e6af02bea8d3d85276","C++":"#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n#include <set>\\n#include <queue>\\nusing namespace std;\\n\\nbool canResultFromFirst(vector<vector<int>>& graph, vector<unordered_map<int, set<int>>>& keys, vector<pair<int, int>>& firstNight, vector<pair<int, int>>& secondNight) {\\n    int n = graph.size();\\n    vector<bool> visited(n, false);\\n    queue<int> q;\\n    q.push(firstNight[0].first);\\n    visited[firstNight[0].first] = true;\\n    while (!q.empty()) {\\n        int curr = q.front();\\n        q.pop();\\n        for (int neighbor : graph[curr]) {\\n            if (!visited[neighbor]) {\\n                visited[neighbor] = true;\\n                q.push(neighbor);\\n            }\\n        }\\n        for (auto& key : keys[curr]) {\\n            for (int door : key.second) {\\n                if (visited[door]) {\\n                    visited[key.first] = true;\\n                    q.push(key.first);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    for (auto& resident : firstNight) {\\n        if (!visited[resident.first]) {\\n            return false;\\n        }\\n    }\\n    for (auto& resident : secondNight) {\\n        if (!visited[resident.first]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int n, m, k;\\n    cin >> n >> m >> k;\\n    vector<vector<int>> graph(n);\\n    vector<unordered_map<int, set<int>>> keys(n);\\n    for (int i = 0; i < m; i++) {\\n        int u, v;\\n        cin >> u >> v;\\n        u--;\\n        v--;\\n        graph[u].push_back(v);\\n        graph[v].push_back(u);\\n    }\\n    for (int i = 0; i < k; i++) {\\n        string name;\\n        int room, numKeys;\\n        cin >> name >> room >> numKeys;\\n        room--;\\n        for (int j = 0; j < numKeys; j++) {\\n            int door;\\n            cin >> door;\\n            door--;\\n            keys[room][door].insert(i);\\n        }\\n    }\\n    vector<pair<int, int>> firstNight;\\n    vector<pair<int, int>> secondNight;\\n    for (int i = 0; i < k; i++) {\\n        string name;\\n        int room, numKeys;\\n        cin >> name >> room >> numKeys;\\n        room--;\\n        firstNight.push_back({room, i});\\n        for (int j = 0; j < numKeys; j++) {\\n            int door;\\n            cin >> door;\\n            door--;\\n            keys[room][door].insert(i);\\n        }\\n    }\\n    if (canResultFromFirst(graph, keys, firstNight, secondNight)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class CrimeSolver {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] inputArr = input.split(\\\" \\\");\n        int n = Integer.parseInt(inputArr[0]);\n        int m = Integer.parseInt(inputArr[1]);\n        int k = Integer.parseInt(inputArr[2]);\n        \n        List<List<Integer>> doors = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            String doorInput = scanner.nextLine();\n            String[] doorArr = doorInput.split(\\\" \\\");\n            int room1 = Integer.parseInt(doorArr[0]);\n            int room2 = Integer.parseInt(doorArr[1]);\n            doors.add(Arrays.asList(room1, room2));\n        }\n        \n        Map<String, Resident> residents1 = new HashMap<>();\n        for (int i = 0; i < k; i++) {\n            String residentInput = scanner.nextLine();\n            String[] residentArr = residentInput.split(\\\" \\\");\n            String name = residentArr[0];\n            int room = Integer.parseInt(residentArr[1]);\n            int numKeys = Integer.parseInt(residentArr[2]);\n            List<Integer> keys = new ArrayList<>();\n            for (int j = 0; j < numKeys; j++) {\n                keys.add(Integer.parseInt(residentArr[j + 3]));\n            }\n            residents1.put(name, new Resident(room, keys));\n        }\n        \n        Map<String, Resident> residents2 = new HashMap<>();\n        for (int i = 0; i < k; i++) {\n            String residentInput = scanner.nextLine();\n            String[] residentArr = residentInput.split(\\\" \\\");\n            String name = residentArr[0];\n            int room = Integer.parseInt(residentArr[1]);\n            int numKeys = Integer.parseInt(residentArr[2]);\n            List<Integer> keys = new ArrayList<>();\n            for (int j = 0; j < numKeys; j++) {\n                keys.add(Integer.parseInt(residentArr[j + 3]));\n            }\n            residents2.put(name, new Resident(room, keys));\n        }\n        \n        boolean result = canResultFromFirstArrangement(n, m, doors, residents1, residents2);\n        if (result) {\n            System.out.println(\\\"YES\\\");\n        } else {\n            System.out.println(\\\"NO\\\");\n        }\n    }\n    \n    public static boolean canResultFromFirstArrangement(int n, int m, List<List<Integer>> doors, Map<String, Resident> residents1, Map<String, Resident> residents2) {\n        for (List<Integer> door : doors) {\n            int room1 = door.get(0);\n            int room2 = door.get(1);\n            boolean room1Locked1 = isRoomLocked(room1, residents1);\n            boolean room2Locked1 = isRoomLocked(room2, residents1);\n            boolean room1Locked2 = isRoomLocked(room1, residents2);\n            boolean room2Locked2 = isRoomLocked(room2, residents2);\n            \n            if (room1Locked1 != room1Locked2 || room2Locked1 != room2Locked2) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public static boolean isRoomLocked(int room, Map<String, Resident> residents) {\n        for (Resident resident : residents.values()) {\n            if (resident.getRoom() == room) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nclass Resident {\n    private int room;\n    private List<Integer> keys;\n    \n    public Resident(int room, List<Integer> keys) {\n        this.room = room;\n        this.keys = keys;\n    }\n    \n    public int getRoom() {\n        return room;\n    }\n    \n    public List<Integer> getKeys() {\n        return keys;\n    }\n}","Python":"def solve_crime(input_str):\n    input_lines = input_str.strip().split('\\n')\n    n, m, k = map(int, input_lines[0].split())\n\n    doors = [[] for _ in range(n)]\n    for line in input_lines[1:m+1]:\n        room1, room2 = map(int, line.split())\n        doors[room1-1].append(room2-1)\n        doors[room2-1].append(room1-1)\n\n    residents1 = {}\n    for line in input_lines[m+1:m+1+k]:\n        name, room, num_keys, *keys = line.split()\n        residents1[name] = (int(room)-1, set(map(int, keys)))\n\n    residents2 = {}\n    for line in input_lines[m+1+k:]:\n        name, room, num_keys, *keys = line.split()\n        residents2[name] = (int(room)-1, set(map(int, keys)))\n\n    for name, (room1, keys1) in residents1.items():\n        room2, keys2 = residents2[name]\n        if room1 != room2 or keys1 != keys2:\n            return 'NO'\n\n    return 'YES'\n\ninput_str = '2 1 2\\\\n1 2\\\\nDmitry 1 1 1\\\\nNatalia 2 0\\\\nNatalia 1 1 1\\\\nDmitry 2 0\\\\n'\nprint(solve_crime(input_str))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MAX_ROOMS 1000\\n#define MAX_DOORS 1000\\n#define MAX_RESIDENTS 1000\\n#define MAX_NAME_LENGTH 10\\n\\nint graph[MAX_ROOMS][MAX_ROOMS];\\nint keys[MAX_RESIDENTS][MAX_DOORS];\\n\\nint main() {\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n\\n    \/\/ Initialize graph\\n    for (int i = 0; i < MAX_ROOMS; i++) {\\n        for (int j = 0; j < MAX_ROOMS; j++) {\\n            graph[i][j] = 0;\\n        }\\n    }\\n\\n    \/\/ Read doors\\n    for (int i = 0; i < m; i++) {\\n        int room1, room2;\\n        scanf(\\\"%d %d\\\", &room1, &room2);\\n        graph[room1][room2] = 1;\\n        graph[room2][room1] = 1;\\n    }\\n\\n    \/\/ Read residents' positions and keys on Thursday night\\n    for (int i = 0; i < k; i++) {\\n        char name[MAX_NAME_LENGTH];\\n        int room, numKeys;\\n        scanf(\\\"%s %d %d\\\", name, &room, &numKeys);\\n        for (int j = 0; j < numKeys; j++) {\\n            int door;\\n            scanf(\\\"%d\\\", &door);\\n            keys[i][door] = 1;\\n        }\\n    }\\n\\n    \/\/ Read residents' positions and keys on Friday night\\n    for (int i = 0; i < k; i++) {\\n        char name[MAX_NAME_LENGTH];\\n        int room, numKeys;\\n        scanf(\\\"%s %d %d\\\", name, &room, &numKeys);\\n        for (int j = 0; j < numKeys; j++) {\\n            int door;\\n            scanf(\\\"%d\\\", &door);\\n            if (keys[i][door] != 1) {\\n                printf(\\\"NO\\\\n\\\");\\n                return 0;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"YES\\\\n\\\");\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace CrimeSolver\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n            int k = int.Parse(inputArr[2]);\n\n            List<int>[] doors = new List<int>[n + 1];\n            for (int i = 0; i <= n; i++)\n            {\n                doors[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                string doorInput = Console.ReadLine();\n                string[] doorInputArr = doorInput.Split(' ');\n\n                int room1 = int.Parse(doorInputArr[0]);\n                int room2 = int.Parse(doorInputArr[1]);\n\n                doors[room1].Add(i);\n                doors[room2].Add(i);\n            }\n\n            Dictionary<string, Resident> residents = new Dictionary<string, Resident>();\n\n            for (int i = 0; i < k; i++)\n            {\n                string residentInput = Console.ReadLine();\n                string[] residentInputArr = residentInput.Split(' ');\n\n                string name = residentInputArr[0];\n                int room = int.Parse(residentInputArr[1]);\n                int keyCount = int.Parse(residentInputArr[2]);\n\n                List<int> keys = new List<int>();\n                for (int j = 0; j < keyCount; j++)\n                {\n                    keys.Add(int.Parse(residentInputArr[j + 3]));\n                }\n\n                Resident resident = new Resident(name, room, keys);\n                residents.Add(name, resident);\n            }\n\n            bool result = CheckArrangement(doors, residents);\n\n            if (result)\n            {\n                Console.WriteLine(\"YES\");\n            }\n            else\n            {\n                Console.WriteLine(\"NO\");\n            }\n        }\n\n        static bool CheckArrangement(List<int>[] doors, Dictionary<string, Resident> residents)\n        {\n            foreach (KeyValuePair<string, Resident> kvp in residents)\n            {\n                Resident resident = kvp.Value;\n\n                foreach (int key in resident.Keys)\n                {\n                    foreach (int door in doors[resident.Room])\n                    {\n                        if (door != key && !resident.Keys.Contains(door))\n                        {\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            return true;\n        }\n    }\n\n    class Resident\n    {\n        public string Name { get; set; }\n        public int Room { get; set; }\n        public List<int> Keys { get; set; }\n\n        public Resident(string name, int room, List<int> keys)\n        {\n            Name = name;\n            Room = room;\n            Keys = keys;\n        }\n    }\n}","Ruby":"def solve_crime(input)\n  # Parse input\n  lines = input.split('\\\\n')\n  n, m, k = lines[0].split(' ').map(&:to_i)\n  doors = lines[1..m].map { |line| line.split(' ').map(&:to_i) }\n  residents1 = lines[m+1..m+k].map { |line| parse_resident(line) }\n  residents2 = lines[m+k+1..m+2*k].map { |line| parse_resident(line) }\n\n  # Create a graph to represent the house\n  graph = Array.new(n) { [] }\n  doors.each do |door|\n    room1, room2 = door\n    graph[room1-1] << room2-1\n    graph[room2-1] << room1-1\n  end\n\n  # Check if the second arrangement can result from the first one\n  residents1.each_with_index do |resident1, i|\n    resident2 = residents2[i]\n    return 'NO' unless can_reach?(graph, resident1, resident2)\n  end\n\n  'YES'\nend\n\ndef parse_resident(line)\n  name, room, num_keys, *keys = line.split(' ')\n  {\n    name: name,\n    room: room.to_i - 1,\n    keys: keys.map(&:to_i)\n  }\nend\n\ndef can_reach?(graph, resident1, resident2)\n  visited = Array.new(graph.size, false)\n  queue = [resident1[:room]]\n  visited[resident1[:room]] = true\n\n  while queue.any?\n    current_room = queue.shift\n    return true if current_room == resident2[:room]\n\n    graph[current_room].each do |neighbor|\n      next if visited[neighbor]\n      next unless resident1[:keys].include?(door_number(graph, current_room, neighbor))\n\n      visited[neighbor] = true\n      queue << neighbor\n    end\n  end\n\n  false\nend\n\ndef door_number(graph, room1, room2)\n  graph[room1].index(room2) + 1\nend\n\ninput = gets.chomp\nputs solve_crime(input)\n","delphi":"Here is a possible implementation in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnmk := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nmk[0])\\n\\tm, _ := strconv.Atoi(nmk[1])\\n\\tk, _ := strconv.Atoi(nmk[2])\\n\\n\\t\/\/ Create adjacency matrix\\n\\tadjMatrix := make([][]bool, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tadjMatrix[i] = make([]bool, n)\\n\\t}\\n\\n\\t\/\/ Read door connections\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tdoor := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\tr1, _ := strconv.Atoi(door[0])\\n\\t\\tr2, _ := strconv.Atoi(door[1])\\n\\t\\tadjMatrix[r1-1][r2-1] = true\\n\\t\\tadjMatrix[r2-1][r1-1] = true\\n\\t}\\n\\n\\t\/\/ Read residents' positions on the first night\\n\\tpositions1 := make(map[string][]int)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tposition := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\tresident := position[0]\\n\\t\\tr, _ := strconv.Atoi(position[1])\\n\\t\\tkeys := make([]int, 0)\\n\\t\\tfor j := 2; j < len(position); j++ {\\n\\t\\t\\tkey, _ := strconv.Atoi(position[j])\\n\\t\\t\\tkeys = append(keys, key)\\n\\t\\t}\\n\\t\\tpositions1[resident] = []int{r, len(keys)}\\n\\t}\\n\\n\\t\/\/ Read residents' positions on the second night\\n\\tpositions2 := make(map[string][]int)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tposition := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\tresident := position[0]\\n\\t\\tr, _ := strconv.Atoi(position[1])\\n\\t\\tkeys := make([]int, 0)\\n\\t\\tfor j := 2; j < len(position); j++ {\\n\\t\\t\\tkey, _ := strconv.Atoi(position[j])\\n\\t\\t\\tkeys = append(keys, key)\\n\\t\\t}\\n\\t\\tpositions2[resident] = []int{r, len(keys)}\\n\\t}\\n\\n\\t\/\/ Check if the second arrangement can result from the first one\\n\\tfor resident, pos1 := range positions1 {\\n\\t\\tpos2 := positions2[resident]\\n\\t\\tif pos1[0] != pos2[0] || pos1[1] > pos2[1] {\\n\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(\\\"YES\\\")\\n}","Javascript":"function solveCrime(input) {\n  const lines = input.split('\\\\n');\n  const [n, m, k] = lines[0].split(' ').map(Number);\n  const doors = [];\n  const residents1 = {};\n  const residents2 = {};\n\n  for (let i = 1; i <= m; i++) {\n    const [room1, room2] = lines[i].split(' ').map(Number);\n    doors.push([room1, room2]);\n  }\n\n  let index = m + 1;\n  for (let i = 0; i < k; i++) {\n    const [name, room, numKeys, ...keys] = lines[index].split(' ');\n    residents1[name] = { room: Number(room), keys: keys.map(Number) };\n    index++;\n  }\n\n  for (let i = 0; i < k; i++) {\n    const [name, room, numKeys, ...keys] = lines[index].split(' ');\n    residents2[name] = { room: Number(room), keys: keys.map(Number) };\n    index++;\n  }\n\n  for (const resident in residents2) {\n    const { room, keys } = residents2[resident];\n    if (residents1[resident]) {\n      if (residents1[resident].room !== room) {\n        return 'NO';\n      }\n      const commonKeys = keys.filter(key => residents1[resident].keys.includes(key));\n      if (commonKeys.length !== keys.length) {\n        return 'NO';\n      }\n    } else {\n      return 'NO';\n    }\n  }\n\n  return 'YES';\n}\n\nconst inputs = [\n  '2 1 2\\\\n1 2\\\\nDmitry 1 1 1\\\\nNatalia 2 0\\\\nNatalia 1 1 1\\\\nDmitry 2 0\\\\n',\n  '4 4 3\\\\n1 3\\\\n1 2\\\\n2 3\\\\n3 4\\\\nArtem 1 1 4\\\\nDmitry 1 1 2\\\\nEdvard 4 2 1 3\\\\nArtem 2 0\\\\nDmitry 1 0\\\\nEdvard 4 4 1 2 3 4\\\\n'\n];\n\nconst outputs = inputs.map(input => solveCrime(input));\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val k = input[2].toInt()\n\n    val doors = Array(n + 1) { mutableListOf<Int>() }\n    repeat(m) {\n        val door = readLine()!!.split(\" \").map { it.toInt() }\n        doors[door[0]].add(door[1])\n        doors[door[1]].add(door[0])\n    }\n\n    val residents1 = mutableMapOf<String, Pair<Int, List<Int>>>()\n    repeat(k) {\n        val resident = readLine()!!.split(\" \")\n        val room = resident[1].toInt()\n        val keys = resident.subList(2, resident.size).map { it.toInt() }\n        residents1[resident[0]] = Pair(room, keys)\n    }\n\n    val residents2 = mutableMapOf<String, Pair<Int, List<Int>>>()\n    repeat(k) {\n        val resident = readLine()!!.split(\" \")\n        val room = resident[1].toInt()\n        val keys = resident.subList(2, resident.size).map { it.toInt() }\n        residents2[resident[0]] = Pair(room, keys)\n    }\n\n    val visited = BooleanArray(n + 1)\n    val queue: Queue<Int> = LinkedList()\n    val keys = mutableSetOf<Int>()\n\n    fun bfs(start: Int, end: Int): Boolean {\n        visited.fill(false)\n        queue.clear()\n        queue.add(start)\n        visited[start] = true\n\n        while (queue.isNotEmpty()) {\n            val current = queue.poll()\n            if (current == end) return true\n\n            for (neighbor in doors[current]) {\n                if (!visited[neighbor]) {\n                    queue.add(neighbor)\n                    visited[neighbor] = true\n                }\n            }\n        }\n\n        return false\n    }\n\n    fun canReach(start: Int, end: Int, keys: List<Int>): Boolean {\n        if (bfs(start, end)) return true\n\n        for (key in keys) {\n            if (bfs(start, key) && bfs(key, end)) return true\n        }\n\n        return false\n    }\n\n    var result = \"YES\"\n    for ((resident, position1) in residents1) {\n        val position2 = residents2[resident]\n        if (position2 != null && (position1.first != position2.first || !canReach(position1.first, position2.first, position1.second))) {\n            result = \"NO\"\n            break\n        }\n    }\n\n    println(result)\n}","PHP":"\n<?php\n\nfunction canResultFromFirstArrangement($n, $m, $k, $doors, $firstNight, $secondNight) {\n    $firstArrangement = [];\n    $secondArrangement = [];\n    \n    \/\/ Create a map of rooms and their corresponding keys for the first night\n    for ($i = 0; $i < $k; $i++) {\n        $resident = explode(' ', $firstNight[$i]);\n        $room = $resident[1];\n        $keys = array_slice($resident, 3);\n        $firstArrangement[$room] = $keys;\n    }\n    \n    \/\/ Create a map of rooms and their corresponding keys for the second night\n    for ($i = 0; $i < $k; $i++) {\n        $resident = explode(' ', $secondNight[$i]);\n        $room = $resident[1];\n        $keys = array_slice($resident, 3);\n        $secondArrangement[$room] = $keys;\n    }\n    \n    \/\/ Check if the second arrangement can result from the first arrangement\n    foreach ($secondArrangement as $room => $keys) {\n        if (!isset($firstArrangement[$room])) {\n            return 'NO';\n        }\n        \n        foreach ($keys as $key) {\n            if (!in_array($key, $firstArrangement[$room])) {\n                return 'NO';\n            }\n        }\n    }\n    \n    return 'YES';\n}\n\n\/\/ Read input from stdin\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\nlist($n, $m, $k) = explode(' ', $input[0]);\n\n$doors = [];\nfor ($i = 1; $i <= $m; $i++) {\n    $doors[] = explode(' ', $input[$i]);\n}\n\n$firstNight = array_slice($input, $m + 1, $k);\n$secondNight = array_slice($input, $m + $k + 1);\n\n\/\/ Check if the second arrangement can result from the first arrangement\n$result = canResultFromFirstArrangement($n, $m, $k, $doors, $firstNight, $secondNight);\n\n\/\/ Print the result\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\nimport std.conv;\\r\\nimport std.string;\\r\\n\\r\\nstruct Resident {\\r\\n    string name;\\r\\n    int room;\\r\\n    int keyCount;\\r\\n    int[] keys;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, m, k;\\r\\n    readf(\\\"%d %d %d\\\\n\\\", &n, &m, &k);\\r\\n\\r\\n    int[][] doors = new int[][](n, n);\\r\\n    foreach (i; 0..m) {\\r\\n        int room1, room2;\\r\\n        readf(\\\"%d %d\\\\n\\\", &room1, &room2);\\r\\n        doors[room1 - 1][room2 - 1] = i;\\r\\n        doors[room2 - 1][room1 - 1] = i;\\r\\n    }\\r\\n\\r\\n    Resident[] residents1 = new Resident[k];\\r\\n    foreach (i; 0..k) {\\r\\n        string name;\\r\\n        int room, keyCount;\\r\\n        readf(\\\"%s %d %d\\\", &name, &room, &keyCount);\\r\\n        int[] keys = new int[keyCount];\\r\\n        foreach (j; 0..keyCount) {\\r\\n            int key;\\r\\n            readf(\\\" %d\\\", &key);\\r\\n            keys[j] = key;\\r\\n        }\\r\\n        residents1[i] = Resident(name, room, keyCount, keys);\\r\\n    }\\r\\n\\r\\n    Resident[] residents2 = new Resident[k];\\r\\n    foreach (i; 0..k) {\\r\\n        string name;\\r\\n        int room, keyCount;\\r\\n        readf(\\\"%s %d %d\\\", &name, &room, &keyCount);\\r\\n        int[] keys = new int[keyCount];\\r\\n        foreach (j; 0..keyCount) {\\r\\n            int key;\\r\\n            readf(\\\" %d\\\", &key);\\r\\n            keys[j] = key;\\r\\n        }\\r\\n        residents2[i] = Resident(name, room, keyCount, keys);\\r\\n    }\\r\\n\\r\\n    bool result = true;\\r\\n\\r\\n    foreach (resident1; residents1) {\\r\\n        bool found = false;\\r\\n        foreach (resident2; residents2) {\\r\\n            if (resident1.name == resident2.name) {\\r\\n                if (resident1.room != resident2.room) {\\r\\n                    result = false;\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                resident1.keys.sort();\\r\\n                resident2.keys.sort();\\r\\n\\r\\n                if (resident1.keys != resident2.keys) {\\r\\n                    result = false;\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                found = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!found) {\\r\\n            result = false;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(result ? \\\"YES\\\" : \\\"NO\\\");\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub check_arrangement {\\n    my ($n, $m, $k, $doors, $night1, $night2) = @_;\\n    my %keys;\\n    my %rooms;\\n\\n    # Initialize rooms and keys\\n    for my $i (1..$n) {\\n        $rooms{$i} = [];\\n    }\\n    for my $i (0..$k-1) {\\n        my ($name, $room, $num_keys, @keys) = split(' ', $night1->[$i]);\\n        $rooms{$room} = [$name, \\@keys];\\n        for my $key (@keys) {\\n            $keys{$key} = $room;\\n        }\\n    }\\n\\n    # Check if second arrangement is possible\\n    for my $i (0..$k-1) {\\n        my ($name, $room, $num_keys, @keys) = split(' ', $night2->[$i]);\\n        if ($rooms{$room}[0] ne $name) {\\n            return 'NO';\\n        }\\n        for my $key (@keys) {\\n            if (!exists $keys{$key} || $keys{$key} != $room) {\\n                return 'NO';\\n            }\\n        }\\n    }\\n\\n    return 'YES';\\n}\\n\\n# Read input\\nmy $input = <>;\\nchomp $input;\\nmy ($n, $m, $k) = split(' ', $input);\\nmy @doors;\\nfor (1..$m) {\\n    $input = <>;\\n    chomp $input;\\n    my ($room1, $room2) = split(' ', $input);\\n    push @doors, [$room1, $room2];\\n}\\nmy @night1;\\nfor (1..$k) {\\n    $input = <>;\\n    chomp $input;\\n    push @night1, $input;\\n}\\nmy @night2;\\nfor (1..$k) {\\n    $input = <>;\\n    chomp $input;\\n    push @night2, $input;\\n}\\n\\n# Check arrangement\\nmy $result = check_arrangement($n, $m, $k, \\@doors, \\@night1, \\@night2);\\n\\n# Print result\\nprint $result . \\\"\\\\n\\\";\\n","Rust":"use std::collections::{HashMap, HashSet};\n\nfn main() {\n    let input = \"4 4 3\\n1 3\\n1 2\\n2 3\\n3 4\\nArtem 1 1 4\\nDmitry 1 1 2\\nEdvard 4 2 1 3\\nArtem 2 0\\nDmitry 1 0\\nEdvard 4 4 1 2 3 4\\n\";\n    let output = solve(input);\n    println!(\"{}\", output);\n}\n\nfn solve(input: &str) -> String {\n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let params: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\n    let n = params[0];\n    let m = params[1];\n    let k = params[2];\n\n    let mut doors: HashMap<usize, HashSet<usize>> = HashMap::new();\n    for i in 1..=m {\n        doors.insert(i, HashSet::new());\n    }\n\n    let mut residents: HashMap<String, (usize, HashSet<usize>)> = HashMap::new();\n\n    let mut index = 1;\n    for _ in 0..k {\n        let resident_info: Vec<&str> = lines[index].split(' ').collect();\n        let resident_name = resident_info[0].to_string();\n        let room = resident_info[1].parse().unwrap();\n        let num_keys = resident_info[2].parse().unwrap();\n        let keys: HashSet<usize> = resident_info[3..].iter().map(|x| x.parse().unwrap()).collect();\n        residents.insert(resident_name, (room, keys));\n        index += 1;\n    }\n\n    for _ in 0..k {\n        let resident_info: Vec<&str> = lines[index].split(' ').collect();\n        let resident_name = resident_info[0].to_string();\n        let room = resident_info[1].parse().unwrap();\n        let num_keys = resident_info[2].parse().unwrap();\n        let keys: HashSet<usize> = resident_info[3..].iter().map(|x| x.parse().unwrap()).collect();\n        let resident = residents.get(&resident_name).unwrap();\n        if resident.0 != room || resident.1 != keys {\n            return \"NO\".to_string();\n        }\n        index += 1;\n    }\n\n    \"YES\".to_string()\n}"}
{"title":"D. Safe","description":"Vasya tries to break in a safe. He knows that a code consists of n numbers, and every number is a 0 or a 1. Vasya has made m attempts to enter the code. After each attempt the system told him in how many position stand the right numbers. It is not said in which positions the wrong numbers stand. Vasya has been so unlucky that he hasn\u2019t entered the code where would be more than 5 correct numbers. Now Vasya is completely bewildered: he thinks there\u2019s a mistake in the system and it is self-contradictory. Help Vasya \u2014 calculate how many possible code variants are left that do not contradict the previous system responses.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains two integers n and m (6\u2264n\u226435,1\u2264m\u226410) which represent the number of numbers in the code and the number of attempts made by Vasya. Then follow m lines, each containing space-separated si and ci which correspondingly indicate Vasya\u2019s attempt (a line containing n numbers which are 0 or 1) and the system\u2019s response (an integer from 0 to 5 inclusively).\n","output_spec":"Print the single number which indicates how many possible code variants that do not contradict the m system responses are left.\n","notes":null,"sample_inputs":["6 2\n000000 2\n010100 4\n","6 3\n000000 2\n010100 4\n111100 0\n","6 3\n000000 2\n010100 4\n111100 2\n"],"sample_outputs":["6\n","0\n","1\n"],"id":"47-D","difficulty":2200,"tags":["brute+force"],"src_uid":"5215112549723fea3f2c1fe0049e0b2e","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<int>> attempts(m, vector<int>(n));\\n    vector<int> responses(m);\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            cin >> attempts[i][j];\\n        }\\n        cin >> responses[i];\\n    }\\n\\n    int count = 0;\\n\\n    for (int i = 0; i < (1 << n); i++) {\\n        bool valid = true;\\n\\n        for (int j = 0; j < m; j++) {\\n            int correct = 0;\\n\\n            for (int k = 0; k < n; k++) {\\n                if ((i & (1 << k)) && attempts[j][k] == 1) {\\n                    correct++;\\n                }\\n                if (!(i & (1 << k)) && attempts[j][k] == 0) {\\n                    correct++;\\n                }\\n            }\\n\\n            if (correct != responses[j]) {\\n                valid = false;\\n                break;\\n            }\\n        }\\n\\n        if (valid) {\\n            count++;\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class SafeCodeVariants {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] input = scanner.nextLine().split(\" \");\n        int n = Integer.parseInt(input[0]);\n        int m = Integer.parseInt(input[1]);\n        \n        int[][] attempts = new int[m][n];\n        int[] responses = new int[m];\n        \n        for (int i = 0; i < m; i++) {\n            String[] attempt = scanner.nextLine().split(\" \");\n            for (int j = 0; j < n; j++) {\n                attempts[i][j] = Integer.parseInt(attempt[j]);\n            }\n            responses[i] = Integer.parseInt(attempt[n]);\n        }\n        \n        int count = 0;\n        for (int i = 0; i < Math.pow(2, n); i++) {\n            boolean isValid = true;\n            for (int j = 0; j < m; j++) {\n                int correctCount = 0;\n                for (int k = 0; k < n; k++) {\n                    if (attempts[j][k] == ((i >> k) & 1)) {\n                        correctCount++;\n                    }\n                }\n                if (correctCount != responses[j]) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid) {\n                count++;\n            }\n        }\n        \n        System.out.println(count);\n    }\n}","Python":"def count_possible_variants(n, m, attempts):\n    possible_variants = set(range(2**n))\n    \n    for attempt, response in attempts:\n        correct_positions = bin(response).count('1')\n        possible_variants = {variant for variant in possible_variants if bin(variant).count('1') == correct_positions}\n        \n        for i in range(n):\n            if attempt[i] == '0':\n                possible_variants = {variant for variant in possible_variants if bin(variant)[2:].zfill(n)[i] == '0'}\n            elif attempt[i] == '1':\n                possible_variants = {variant for variant in possible_variants if bin(variant)[2:].zfill(n)[i] == '1'}\n    \n    return len(possible_variants)\n\ninputs = ['6 2\\n000000 2\\n010100 4\\n', '6 3\\n000000 2\\n010100 4\\n111100 0\\n', '6 3\\n000000 2\\n010100 4\\n111100 2\\n']\noutputs = []\n\nfor input_str in inputs:\n    input_lines = input_str.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    attempts = [line.split() for line in input_lines[1:]]\n    result = count_possible_variants(n, m, attempts)\n    outputs.append(str(result))\n\noutput_str = '\\\\n'.join(outputs)\nprint(output_str)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int attempts[m][n];\\n    int responses[m];\\n\\n    \/\/ Read the attempts and responses\\n    for (int i = 0; i < m; i++) {\\n        char code[n+1];\\n        scanf(\\\"%s %d\\\", code, &responses[i]);\\n        for (int j = 0; j < n; j++) {\\n            attempts[i][j] = code[j] - '0';\\n        }\\n    }\\n\\n    int count = 0;\\n\\n    \/\/ Check all possible code variants\\n    for (int i = 0; i < (1 << n); i++) {\\n        int valid = 1;\\n        for (int j = 0; j < m; j++) {\\n            int correct = 0;\\n            for (int k = 0; k < n; k++) {\\n                if (attempts[j][k] == ((i >> k) & 1)) {\\n                    correct++;\\n                }\\n            }\\n            if (correct != responses[j]) {\\n                valid = 0;\\n                break;\\n            }\\n        }\\n        if (valid) {\\n            count++;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace SafeCodeVariants\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = {\n                \\\"6 2\\n000000 2\\n010100 4\\n\\\",\n                \\\"6 3\\n000000 2\\n010100 4\\n111100 0\\n\\\",\n                \\\"6 3\\n000000 2\\n010100 4\\n111100 2\\n\\\"\n            };\n\n            string[] outputs = {\n                \\\"6\\n\\\",\n                \\\"0\\n\\\",\n                \\\"1\\n\\\"\n            };\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                string input = inputs[i];\n                string expectedOutput = outputs[i];\n\n                string actualOutput = CalculatePossibleCodeVariants(input);\n\n                Console.WriteLine(actualOutput == expectedOutput ? \\\"Test case passed\\\" : \\\"Test case failed\\\");\n            }\n        }\n\n        static string CalculatePossibleCodeVariants(string input)\n        {\n            string[] lines = input.Split(new[] { '\\\\n' }, StringSplitOptions.RemoveEmptyEntries);\n            string[] nm = lines[0].Split();\n            int n = int.Parse(nm[0]);\n            int m = int.Parse(nm[1]);\n\n            List<string> possibleVariants = new List<string>();\n\n            for (int i = 0; i < Math.Pow(2, n); i++)\n            {\n                string code = Convert.ToString(i, 2).PadLeft(n, '0');\n                bool isValid = true;\n\n                for (int j = 1; j <= m; j++)\n                {\n                    string[] attempt = lines[j].Split();\n                    string s = attempt[0];\n                    int c = int.Parse(attempt[1]);\n\n                    int correctCount = 0;\n\n                    for (int k = 0; k < n; k++)\n                    {\n                        if (s[k] == code[k])\n                        {\n                            correctCount++;\n                        }\n                    }\n\n                    if (correctCount != c)\n                    {\n                        isValid = false;\n                        break;\n                    }\n                }\n\n                if (isValid)\n                {\n                    possibleVariants.Add(code);\n                }\n            }\n\n            return possibleVariants.Count.ToString() + \\\"\\\\n\\\";\n        }\n    }\n}","Ruby":"\ndef count_possible_variants(n, m, attempts)\n  # Initialize an array to store the possible code variants\n  possible_variants = []\n\n  # Generate all possible code variants\n  (0..(2**n - 1)).each do |code|\n    code_str = code.to_s(2).rjust(n, '0') # Convert code to binary string\n\n    # Check if the code matches all previous attempts\n    if attempts.all? { |attempt| count_correct_numbers(code_str, attempt[0]) == attempt[1] }\n      possible_variants << code_str\n    end\n  end\n\n  possible_variants.size\nend\n\ndef count_correct_numbers(code, attempt)\n  count = 0\n  code.chars.each_with_index do |digit, index|\n    count += 1 if digit == attempt[index]\n  end\n  count\nend\n\n# Parse input\ninput = gets.chomp.split(\"\\n\")\nn, m = input[0].split.map(&:to_i)\nattempts = input[1..m].map { |line| line.split }\n\n# Count possible code variants\nresult = count_possible_variants(n, m, attempts)\n\n# Print the result\nputs result\n","delphi":"program SafeCode;\n\nvar\n  n, m, i, j, k, count: integer;\n  code: array[1..35] of integer;\n  attempt: array[1..10] of string;\n  response: array[1..10] of integer;\n  possible: integer;\n\nfunction CheckCode(var code: array of integer; n: integer; attempt: string): integer;\nvar\n  i, count: integer;\nbegin\n  count := 0;\n  for i := 1 to n do\n  begin\n    if code[i] = StrToInt(attempt[i]) then\n      count := count + 1;\n  end;\n  Result := count;\nend;\n\nprocedure GenerateCode(var code: array of integer; n, m, pos: integer);\nvar\n  i: integer;\nbegin\n  if pos > n then\n  begin\n    count := 0;\n    for i := 1 to m do\n    begin\n      if CheckCode(code, n, attempt[i]) = response[i] then\n        count := count + 1;\n    end;\n    if count = m then\n      possible := possible + 1;\n  end\n  else\n  begin\n    code[pos] := 0;\n    GenerateCode(code, n, m, pos + 1);\n    code[pos] := 1;\n    GenerateCode(code, n, m, pos + 1);\n  end;\nend;\n\nbegin\n  possible := 0;\n  \n  \/\/ Read input\n  readln(n, m);\n  for i := 1 to m do\n    readln(attempt[i], response[i]);\n  \n  \/\/ Generate possible codes\n  GenerateCode(code, n, m, 1);\n  \n  \/\/ Print result\n  writeln(possible);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nm[0])\\n\\tm, _ := strconv.Atoi(nm[1])\\n\\n\\tattempts := make([]string, m)\\n\\tresponses := make([]int, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tattempt := scanner.Text()\\n\\t\\tattempts[i] = attempt\\n\\n\\t\\tscanner.Scan()\\n\\t\\tresponse, _ := strconv.Atoi(scanner.Text())\\n\\t\\tresponses[i] = response\\n\\t}\\n\\n\\tcount := 0\\n\\n\\tfor i := 0; i < (1 << n); i++ {\\n\\t\\tvalid := true\\n\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\trightCount := 0\\n\\n\\t\\t\\tfor k := 0; k < n; k++ {\\n\\t\\t\\t\\tif (i & (1 << k)) != 0 && attempts[j][k] == '1' {\\n\\t\\t\\t\\t\\trightCount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif rightCount != responses[j] {\\n\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif valid {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function calculatePossibleVariants(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const attempts = lines.slice(1, m + 1).map(line => line.split(' '));\n  \n  let possibleVariants = Math.pow(2, n);\n  \n  for (let i = 0; i < m; i++) {\n    const [attempt, response] = attempts[i];\n    const correctPositions = Number(response);\n    \n    let count = 0;\n    for (let j = 0; j < n; j++) {\n      if (attempt[j] === '1') {\n        count++;\n      }\n    }\n    \n    const incorrectPositions = count - correctPositions;\n    const remainingVariants = Math.pow(2, incorrectPositions);\n    \n    possibleVariants = Math.min(possibleVariants, remainingVariants);\n  }\n  \n  return possibleVariants.toString();\n}\n\nconst inputs = [\n  '6 2\\\\n000000 2\\\\n010100 4\\\\n',\n  '6 3\\\\n000000 2\\\\n010100 4\\\\n111100 0\\\\n',\n  '6 3\\\\n000000 2\\\\n010100 4\\\\n111100 2\\\\n'\n];\n\nconst outputs = inputs.map(calculatePossibleVariants);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n\n    val attempts = mutableListOf<Pair<String, Int>>()\n    for (i in 0 until m) {\n        val attempt = scanner.nextLine().split(\" \")\n        attempts.add(Pair(attempt[0], attempt[1].toInt()))\n    }\n\n    val possibleCodes = mutableListOf<String>()\n    for (code in generateAllCodes(n)) {\n        var isValid = true\n        for (attempt in attempts) {\n            val correctPositions = countCorrectPositions(code, attempt.first)\n            if (correctPositions != attempt.second) {\n                isValid = false\n                break\n            }\n        }\n        if (isValid) {\n            possibleCodes.add(code)\n        }\n    }\n\n    println(possibleCodes.size)\n}\n\nfun generateAllCodes(n: Int): List<String> {\n    val codes = mutableListOf<String>()\n    generateAllCodesHelper(n, \"\", codes)\n    return codes\n}\n\nfun generateAllCodesHelper(n: Int, code: String, codes: MutableList<String>) {\n    if (n == 0) {\n        codes.add(code)\n        return\n    }\n    generateAllCodesHelper(n - 1, code + \"0\", codes)\n    generateAllCodesHelper(n - 1, code + \"1\", codes)\n}\n\nfun countCorrectPositions(code1: String, code2: String): Int {\n    var count = 0\n    for (i in code1.indices) {\n        if (code1[i] == code2[i]) {\n            count++\n        }\n    }\n    return count\n}","PHP":"<?php\\n\\nfunction calculatePossibleVariants($n, $m, $attempts) {\\n    $possibleVariants = pow(2, $n); \/\/ Total number of possible code variants\\n\\n    foreach ($attempts as $attempt) {\\n        $code = $attempt[0];\\n        $correctPositions = $attempt[1];\\n\\n        $countOnes = substr_count($code, '1'); \/\/ Count the number of ones in the attempt\\n        $countZeros = $n - $countOnes; \/\/ Count the number of zeros in the attempt\\n\\n        $maxCorrectPositions = min($countOnes, $correctPositions) + min($countZeros, $n - $correctPositions); \/\/ Maximum possible correct positions\\n\\n        $possibleVariants = countVariantsWithCorrectPositions($possibleVariants, $maxCorrectPositions, $n); \/\/ Update the number of possible variants\\n    }\\n\\n    return $possibleVariants;\\n}\\n\\nfunction countVariantsWithCorrectPositions($totalVariants, $correctPositions, $n) {\\n    $count = 0;\\n\\n    for ($i = 0; $i < $totalVariants; $i++) {\\n        $binary = str_pad(decbin($i), $n, '0', STR_PAD_LEFT); \/\/ Convert the number to binary and pad with zeros\\n\\n        $countOnes = substr_count($binary, '1'); \/\/ Count the number of ones in the binary representation\\n\\n        if ($countOnes == $correctPositions) {\\n            $count++;\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    ['6 2', '000000 2', '010100 4'],\\n    ['6 3', '000000 2', '010100 4', '111100 0'],\\n    ['6 3', '000000 2', '010100 4', '111100 2'],\\n];\\n\\nforeach ($inputs as $input) {\\n    $params = explode(' ', $input[0]);\\n    $n = intval($params[0]);\\n    $m = intval($params[1]);\\n\\n    $attempts = [];\\n    for ($i = 1; $i <= $m; $i++) {\\n        $attemptParams = explode(' ', $input[$i]);\\n        $code = $attemptParams[0];\\n        $correctPositions = intval($attemptParams[1]);\\n        $attempts[] = [$code, $correctPositions];\\n    }\\n\\n    $result = calculatePossibleVariants($n, $m, $attempts);\\n    echo $result . \\\"\\\\n\\\";\\n}\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] attempts = new int[][];\\r\\n\\r\\n    foreach (_; 0..m)\\r\\n    {\\r\\n        int[] attempt = new int[n];\\r\\n        int correctPositions;\\r\\n\\r\\n        readf(\\\"%s %d\\\", &attempt, &correctPositions);\\r\\n\\r\\n        attempts ~= attempt;\\r\\n    }\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    foreach (i; 0..(1 << n))\\r\\n    {\\r\\n        int[] code = new int[n];\\r\\n\\r\\n        foreach (j; 0..n)\\r\\n        {\\r\\n            code[j] = (i >> j) & 1;\\r\\n        }\\r\\n\\r\\n        bool valid = true;\\r\\n\\r\\n        foreach (attempt; attempts)\\r\\n        {\\r\\n            int correctPositions = 0;\\r\\n\\r\\n            foreach (j; 0..n)\\r\\n            {\\r\\n                if (code[j] == attempt[j])\\r\\n                {\\r\\n                    correctPositions++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (correctPositions != attempt.length)\\r\\n            {\\r\\n                valid = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (valid)\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_possible_variants {\n    my ($n, $m, @attempts) = @_;\n\n    my @possible_variants = ('0' x $n .. '1' x $n);\n\n    foreach my $attempt (@attempts) {\n        my ($code, $correct_positions) = split(' ', $attempt);\n        my @new_possible_variants;\n\n        foreach my $variant (@possible_variants) {\n            my $count = 0;\n            for (my $i = 0; $i < $n; $i++) {\n                $count++ if substr($variant, $i, 1) eq substr($code, $i, 1);\n            }\n            push @new_possible_variants, $variant if $count == $correct_positions;\n        }\n\n        @possible_variants = @new_possible_variants;\n    }\n\n    return scalar @possible_variants;\n}\n\n# Example usage\nmy $input = '6 2\\n000000 2\\n010100 4\\n';\nmy ($n, $m, @attempts) = split('\\n', $input);\n\nmy $result = calculate_possible_variants($n, $m, @attempts);\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"6 2\\\\n000000 2\\\\n010100 4\\\\n\\\";\\n    let mut lines = input.lines();\\n    let nm: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nm[0];\\n    let m = nm[1];\\n\\n    let mut codes: Vec<Vec<u8>> = Vec::new();\\n    let mut responses: Vec<usize> = Vec::new();\\n\\n    for _ in 0..m {\\n        let line = lines.next().unwrap();\\n        let parts: Vec<&str> = line.split_whitespace().collect();\\n        let code: Vec<u8> = parts[0].chars().map(|x| x.to_digit(10).unwrap() as u8).collect();\\n        let response: usize = parts[1].parse().unwrap();\\n        codes.push(code);\\n        responses.push(response);\\n    }\\n\\n    let mut count = 0;\\n\\n    for i in 0..(2u32.pow(n as u32)) {\\n        let code: Vec<u8> = format!(\"{:0width$b}\", i, width = n)\\n            .chars()\\n            .map(|x| x.to_digit(10).unwrap() as u8)\\n            .collect();\\n\\n        let mut valid = true;\\n\\n        for j in 0..m {\\n            let mut correct = 0;\\n\\n            for k in 0..n {\\n                if codes[j][k] == code[k] {\\n                    correct += 1;\\n                }\\n            }\\n\\n            if correct != responses[j] {\\n                valid = false;\\n                break;\\n            }\\n        }\\n\\n        if valid {\\n            count += 1;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}"}
{"title":"A. Rock-paper-scissors","description":"Uncle Fyodor, Matroskin the Cat and Sharic the Dog live their simple but happy lives in Prostokvashino. Sometimes they receive parcels from Uncle Fyodor\u2019s parents and sometimes from anonymous benefactors, in which case it is hard to determine to which one of them the package has been sent. A photographic rifle is obviously for Sharic who loves hunting and fish is for Matroskin, but for whom was a new video game console meant? Every one of the three friends claimed that the present is for him and nearly quarreled. Uncle Fyodor had an idea how to solve the problem justly: they should suppose that the console was sent to all three of them and play it in turns. Everybody got relieved but then yet another burning problem popped up \u2014 who will play first? This time Matroskin came up with a brilliant solution, suggesting the most fair way to find it out: play rock-paper-scissors together. The rules of the game are very simple. On the count of three every player shows a combination with his hand (or paw). The combination corresponds to one of three things: a rock, scissors or paper. Some of the gestures win over some other ones according to well-known rules: the rock breaks the scissors, the scissors cut the paper, and the paper gets wrapped over the stone. Usually there are two players. Yet there are three friends, that\u2019s why they decided to choose the winner like that: If someone shows the gesture that wins over the other two players, then that player wins. Otherwise, another game round is required. Write a program that will determine the winner by the gestures they have shown.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains the name of the gesture that Uncle Fyodor showed, the second line shows which gesture Matroskin showed and the third line shows Sharic\u2019s gesture. \n","output_spec":"Print \"F\" (without quotes) if Uncle Fyodor wins. Print \"M\" if Matroskin wins and \"S\" if Sharic wins. If it is impossible to find the winner, print \"?\".\n","notes":null,"sample_inputs":["rock\nrock\nrock\n","paper\nrock\nrock\n","scissors\nrock\nrock\n","scissors\npaper\nrock\n"],"sample_outputs":["?\n","F\n","?\n","?\n"],"id":"48-A","difficulty":900,"tags":["implementation","schedules"],"src_uid":"072c7d29a1b338609a72ab6b73988282","C++":"#include <iostream>\\n\\nusing namespace std;\\n\\nint main() {\\n    string fyodor, matroskin, sharic;\\n    cin >> fyodor >> matroskin >> sharic;\\n\\n    if ((fyodor == \\\"rock\\\" && matroskin == \\\"scissors\\\" && sharic == \\\"scissors\\\") ||\\n        (fyodor == \\\"scissors\\\" && matroskin == \\\"rock\\\" && sharic == \\\"scissors\\\") ||\\n        (fyodor == \\\"scissors\\\" && matroskin == \\\"scissors\\\" && sharic == \\\"rock\\\")) {\\n        cout << \\\"F\\\";\\n    } else if ((fyodor == \\\"scissors\\\" && matroskin == \\\"rock\\\" && sharic == \\\"rock\\\") ||\\n               (fyodor == \\\"rock\\\" && matroskin == \\\"scissors\\\" && sharic == \\\"rock\\\") ||\\n               (fyodor == \\\"rock\\\" && matroskin == \\\"rock\\\" && sharic == \\\"scissors\\\")) {\\n        cout << \\\"M\\\";\\n    } else if ((fyodor == \\\"rock\\\" && matroskin == \\\"paper\\\" && sharic == \\\"paper\\\") ||\\n               (fyodor == \\\"paper\\\" && matroskin == \\\"rock\\\" && sharic == \\\"paper\\\") ||\\n               (fyodor == \\\"paper\\\" && matroskin == \\\"paper\\\" && sharic == \\\"rock\\\")) {\\n        cout << \\\"S\\\";\\n    } else {\\n        cout << \\\"?\\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class RockPaperScissors {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        String fyodorGesture = scanner.nextLine();\\n        String matroskinGesture = scanner.nextLine();\\n        String sharicGesture = scanner.nextLine();\\n\\n        if (fyodorGesture.equals(matroskinGesture) && matroskinGesture.equals(sharicGesture)) {\\n            System.out.println(\\\"?\\\");\\n        } else if (fyodorGesture.equals(\\\"rock\\\") && (matroskinGesture.equals(\\\"scissors\\\") || sharicGesture.equals(\\\"scissors\\\"))) {\\n            System.out.println(\\\"F\\\");\\n        } else if (matroskinGesture.equals(\\\"rock\\\") && (fyodorGesture.equals(\\\"scissors\\\") || sharicGesture.equals(\\\"scissors\\\"))) {\\n            System.out.println(\\\"M\\\");\\n        } else if (sharicGesture.equals(\\\"rock\\\") && (fyodorGesture.equals(\\\"scissors\\\") || matroskinGesture.equals(\\\"scissors\\\"))) {\\n            System.out.println(\\\"S\\\");\\n        } else {\\n            System.out.println(\\\"?\\\");\\n        }\\n    }\\n}","Python":"def determine_winner(gesture1, gesture2, gesture3):\n    if gesture1 == gesture2 and gesture2 == gesture3:\n        return '?'\n    elif gesture1 == 'rock' and (gesture2 == 'scissors' or gesture3 == 'scissors'):\n        return 'F'\n    elif gesture2 == 'rock' and (gesture1 == 'scissors' or gesture3 == 'scissors'):\n        return 'M'\n    elif gesture3 == 'rock' and (gesture1 == 'scissors' or gesture2 == 'scissors'):\n        return 'S'\n    else:\n        return '?'\n\ninputs = [['rock', 'rock', 'rock'], ['paper', 'rock', 'rock'], ['scissors', 'rock', 'rock'], ['scissors', 'paper', 'rock']]\noutputs = []\n\nfor i in inputs:\n    result = determine_winner(i[0], i[1], i[2])\n    outputs.append(result + '\\\\n')\n\nprint(outputs)","C":"#include <stdio.h>\\n\\nint main() {\\n    char fyodor[10], matroskin[10], sharic[10];\\n    scanf(\\\"%s\\\", fyodor);\\n    scanf(\\\"%s\\\", matroskin);\\n    scanf(\\\"%s\\\", sharic);\\n\\n    if ((strcmp(fyodor, \\\"rock\\\") == 0 && strcmp(matroskin, \\\"scissors\\\") == 0 && strcmp(sharic, \\\"scissors\\\") == 0) ||\\n        (strcmp(fyodor, \\\"scissors\\\") == 0 && strcmp(matroskin, \\\"rock\\\") == 0 && strcmp(sharic, \\\"scissors\\\") == 0) ||\\n        (strcmp(fyodor, \\\"scissors\\\") == 0 && strcmp(matroskin, \\\"scissors\\\") == 0 && strcmp(sharic, \\\"rock\\\") == 0)) {\\n        printf(\\\"F\\\\n\\\");\\n    } else if ((strcmp(fyodor, \\\"scissors\\\") == 0 && strcmp(matroskin, \\\"rock\\\") == 0 && strcmp(sharic, \\\"rock\\\") == 0) ||\\n               (strcmp(fyodor, \\\"rock\\\") == 0 && strcmp(matroskin, \\\"scissors\\\") == 0 && strcmp(sharic, \\\"rock\\\") == 0) ||\\n               (strcmp(fyodor, \\\"rock\\\") == 0 && strcmp(matroskin, \\\"rock\\\") == 0 && strcmp(sharic, \\\"scissors\\\") == 0)) {\\n        printf(\\\"M\\\\n\\\");\\n    } else if ((strcmp(fyodor, \\\"rock\\\") == 0 && strcmp(matroskin, \\\"paper\\\") == 0 && strcmp(sharic, \\\"paper\\\") == 0) ||\\n               (strcmp(fyodor, \\\"paper\\\") == 0 && strcmp(matroskin, \\\"rock\\\") == 0 && strcmp(sharic, \\\"paper\\\") == 0) ||\\n               (strcmp(fyodor, \\\"paper\\\") == 0 && strcmp(matroskin, \\\"paper\\\") == 0 && strcmp(sharic, \\\"rock\\\") == 0)) {\\n        printf(\\\"S\\\\n\\\");\\n    } else {\\n        printf(\\\"?\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace RockPaperScissors\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string fyodorGesture = Console.ReadLine();\n            string matroskinGesture = Console.ReadLine();\n            string sharicGesture = Console.ReadLine();\n\n            if ((fyodorGesture == \\\"rock\\\" && matroskinGesture == \\\"scissors\\\" && sharicGesture == \\\"scissors\\\") ||\n                (fyodorGesture == \\\"scissors\\\" && matroskinGesture == \\\"rock\\\" && sharicGesture == \\\"scissors\\\") ||\n                (fyodorGesture == \\\"scissors\\\" && matroskinGesture == \\\"scissors\\\" && sharicGesture == \\\"rock\\\"))\n            {\n                Console.WriteLine(\\\"F\\\");\n            }\n            else if ((fyodorGesture == \\\"scissors\\\" && matroskinGesture == \\\"rock\\\" && sharicGesture == \\\"rock\\\") ||\n                     (fyodorGesture == \\\"rock\\\" && matroskinGesture == \\\"rock\\\" && sharicGesture == \\\"scissors\\\") ||\n                     (fyodorGesture == \\\"rock\\\" && matroskinGesture == \\\"scissors\\\" && sharicGesture == \\\"rock\\\"))\n            {\n                Console.WriteLine(\\\"M\\\");\n            }\n            else if ((fyodorGesture == \\\"rock\\\" && matroskinGesture == \\\"paper\\\" && sharicGesture == \\\"paper\\\") ||\n                     (fyodorGesture == \\\"paper\\\" && matroskinGesture == \\\"rock\\\" && sharicGesture == \\\"paper\\\") ||\n                     (fyodorGesture == \\\"paper\\\" && matroskinGesture == \\\"paper\\\" && sharicGesture == \\\"rock\\\"))\n            {\n                Console.WriteLine(\\\"S\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"?\\\");\n            }\n        }\n    }\n}","Ruby":"\ndef determine_winner(gesture1, gesture2, gesture3)\n  if gesture1 == gesture2 && gesture2 == gesture3\n    return '?'\n  elsif gesture1 == 'rock' && (gesture2 == 'scissors' || gesture3 == 'scissors')\n    return 'F'\n  elsif gesture1 == 'scissors' && (gesture2 == 'paper' || gesture3 == 'paper')\n    return 'F'\n  elsif gesture1 == 'paper' && (gesture2 == 'rock' || gesture3 == 'rock')\n    return 'F'\n  elsif gesture2 == 'rock' && (gesture1 == 'scissors' || gesture3 == 'scissors')\n    return 'M'\n  elsif gesture2 == 'scissors' && (gesture1 == 'paper' || gesture3 == 'paper')\n    return 'M'\n  elsif gesture2 == 'paper' && (gesture1 == 'rock' || gesture3 == 'rock')\n    return 'M'\n  elsif gesture3 == 'rock' && (gesture1 == 'scissors' || gesture2 == 'scissors')\n    return 'S'\n  elsif gesture3 == 'scissors' && (gesture1 == 'paper' || gesture2 == 'paper')\n    return 'S'\n  elsif gesture3 == 'paper' && (gesture1 == 'rock' || gesture2 == 'rock')\n    return 'S'\n  else\n    return '?'\n  end\nend\n\ninput = gets.chomp.split('\\n')\ngesture1 = input[0]\ngesture2 = input[1]\ngesture3 = input[2]\n\nwinner = determine_winner(gesture1, gesture2, gesture3)\nputs winner\n","delphi":"program RockPaperScissors;\n\nvar\n  Fyodor, Matroskin, Sharic: string;\n\nbegin\n  \/\/ Read the gestures from input\n  Readln(Fyodor);\n  Readln(Matroskin);\n  Readln(Sharic);\n  \n  \/\/ Determine the winner based on the gestures\n  if (Fyodor = 'rock') and (Matroskin = 'scissors') and (Sharic = 'scissors') then\n    Writeln('F')\n  else if (Fyodor = 'scissors') and (Matroskin = 'rock') and (Sharic = 'scissors') then\n    Writeln('M')\n  else if (Fyodor = 'scissors') and (Matroskin = 'scissors') and (Sharic = 'rock') then\n    Writeln('S')\n  else\n    Writeln('?');\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\n\\tscanner.Scan()\\n\\tgestureF := scanner.Text()\\n\\n\\tscanner.Scan()\\n\\tgestureM := scanner.Text()\\n\\n\\tscanner.Scan()\\n\\tgestureS := scanner.Text()\\n\\n\\tif (gestureF == \\\"rock\\\" && gestureM == \\\"scissors\\\" && gestureS == \\\"scissors\\\") ||\\n\\t\\t(gestureF == \\\"scissors\\\" && gestureM == \\\"rock\\\" && gestureS == \\\"scissors\\\") ||\\n\\t\\t(gestureF == \\\"scissors\\\" && gestureM == \\\"scissors\\\" && gestureS == \\\"rock\\\") {\\n\\t\\tfmt.Println(\\\"F\\\")\\n\\t} else if (gestureF == \\\"scissors\\\" && gestureM == \\\"rock\\\" && gestureS == \\\"rock\\\") ||\\n\\t\\t(gestureF == \\\"rock\\\" && gestureM == \\\"scissors\\\" && gestureS == \\\"rock\\\") ||\\n\\t\\t(gestureF == \\\"rock\\\" && gestureM == \\\"rock\\\" && gestureS == \\\"scissors\\\") {\\n\\t\\tfmt.Println(\\\"M\\\")\\n\\t} else if (gestureF == \\\"rock\\\" && gestureM == \\\"paper\\\" && gestureS == \\\"paper\\\") ||\\n\\t\\t(gestureF == \\\"paper\\\" && gestureM == \\\"rock\\\" && gestureS == \\\"paper\\\") ||\\n\\t\\t(gestureF == \\\"paper\\\" && gestureM == \\\"paper\\\" && gestureS == \\\"rock\\\") {\\n\\t\\tfmt.Println(\\\"S\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"?\\\")\\n\\t}\\n}","Javascript":"function determineWinner(gesture1, gesture2, gesture3) {\n    if ((gesture1 === 'rock' && gesture2 === 'scissors' && gesture3 === 'scissors') ||\n        (gesture1 === 'scissors' && gesture2 === 'rock' && gesture3 === 'scissors') ||\n        (gesture1 === 'scissors' && gesture2 === 'scissors' && gesture3 === 'rock')) {\n        return 'F';\n    } else if ((gesture1 === 'scissors' && gesture2 === 'rock' && gesture3 === 'rock') ||\n        (gesture1 === 'rock' && gesture2 === 'scissors' && gesture3 === 'rock') ||\n        (gesture1 === 'rock' && gesture2 === 'rock' && gesture3 === 'scissors')) {\n        return 'M';\n    } else if ((gesture1 === 'rock' && gesture2 === 'paper' && gesture3 === 'paper') ||\n        (gesture1 === 'paper' && gesture2 === 'rock' && gesture3 === 'paper') ||\n        (gesture1 === 'paper' && gesture2 === 'paper' && gesture3 === 'rock')) {\n        return 'S';\n    } else {\n        return '?';\n    }\n}\n\nconsole.log(determineWinner('rock', 'rock', 'rock')); \/\/ Output: '?'\nconsole.log(determineWinner('paper', 'rock', 'rock')); \/\/ Output: 'F'\nconsole.log(determineWinner('scissors', 'rock', 'rock')); \/\/ Output: '?'\nconsole.log(determineWinner('scissors', 'paper', 'rock')); \/\/ Output: '?'\n","Kotlin":"fun determineWinner(gesture1: String, gesture2: String, gesture3: String): String {\n    if ((gesture1 == \\\"rock\\\" && gesture2 == \\\"scissors\\\" && gesture3 == \\\"scissors\\\") ||\n        (gesture1 == \\\"scissors\\\" && gesture2 == \\\"rock\\\" && gesture3 == \\\"scissors\\\") ||\n        (gesture1 == \\\"scissors\\\" && gesture2 == \\\"scissors\\\" && gesture3 == \\\"rock\\\")) {\n        return \\\"F\\\"\n    } else if ((gesture1 == \\\"scissors\\\" && gesture2 == \\\"rock\\\" && gesture3 == \\\"rock\\\") ||\n        (gesture1 == \\\"rock\\\" && gesture2 == \\\"scissors\\\" && gesture3 == \\\"rock\\\") ||\n        (gesture1 == \\\"rock\\\" && gesture2 == \\\"rock\\\" && gesture3 == \\\"scissors\\\")) {\n        return \\\"M\\\"\n    } else if ((gesture1 == \\\"rock\\\" && gesture2 == \\\"paper\\\" && gesture3 == \\\"paper\\\") ||\n        (gesture1 == \\\"paper\\\" && gesture2 == \\\"rock\\\" && gesture3 == \\\"paper\\\") ||\n        (gesture1 == \\\"paper\\\" && gesture2 == \\\"paper\\\" && gesture3 == \\\"rock\\\")) {\n        return \\\"S\\\"\n    } else {\n        return \\\"?\\\"\n    }\n}\n\nfun main() {\n    val gesture1 = readLine()!!\n    val gesture2 = readLine()!!\n    val gesture3 = readLine()!!\n\n    val winner = determineWinner(gesture1, gesture2, gesture3)\n    println(winner)\n}","PHP":"<?php\\n\\nfunction determineWinner($fyodor, $matroskin, $sharic) {\\n    if (($fyodor == 'rock' && $matroskin == 'scissors' && $sharic == 'scissors') ||\\n        ($fyodor == 'scissors' && $matroskin == 'rock' && $sharic == 'scissors') ||\\n        ($fyodor == 'scissors' && $matroskin == 'scissors' && $sharic == 'rock')) {\\n        return 'F';\\n    } elseif (($fyodor == 'scissors' && $matroskin == 'rock' && $sharic == 'rock') ||\\n        ($fyodor == 'rock' && $matroskin == 'rock' && $sharic == 'scissors') ||\\n        ($fyodor == 'rock' && $matroskin == 'scissors' && $sharic == 'rock')) {\\n        return 'M';\\n    } elseif (($fyodor == 'rock' && $matroskin == 'paper' && $sharic == 'paper') ||\\n        ($fyodor == 'paper' && $matroskin == 'rock' && $sharic == 'paper') ||\\n        ($fyodor == 'paper' && $matroskin == 'paper' && $sharic == 'rock')) {\\n        return 'S';\\n    } else {\\n        return '?';\\n    }\\n}\\n\\n$input = file_get_contents('php:\/\/input');\\n$inputs = explode(\\\"\\\\n\\\", $input);\\n$fyodor = trim($inputs[0]);\\n$matroskin = trim($inputs[1]);\\n$sharic = trim($inputs[2]);\\n\\n$result = determineWinner($fyodor, $matroskin, $sharic);\\necho $result;\\n?>","d":"import std.stdio;\n\nstring determineWinner(string fyodor, string matroskin, string sharic) {\n    if ((fyodor == \\\"rock\\\" && matroskin == \\\"scissors\\\" && sharic == \\\"scissors\\\") ||\n        (fyodor == \\\"scissors\\\" && matroskin == \\\"rock\\\" && sharic == \\\"scissors\\\") ||\n        (fyodor == \\\"scissors\\\" && matroskin == \\\"scissors\\\" && sharic == \\\"rock\\\")) {\n        return \\\"F\\\";\n    } else if ((fyodor == \\\"scissors\\\" && matroskin == \\\"rock\\\" && sharic == \\\"rock\\\") ||\n               (fyodor == \\\"rock\\\" && matroskin == \\\"rock\\\" && sharic == \\\"scissors\\\") ||\n               (fyodor == \\\"rock\\\" && matroskin == \\\"scissors\\\" && sharic == \\\"rock\\\")) {\n        return \\\"M\\\";\n    } else if ((fyodor == \\\"rock\\\" && matroskin == \\\"paper\\\" && sharic == \\\"paper\\\") ||\n               (fyodor == \\\"paper\\\" && matroskin == \\\"rock\\\" && sharic == \\\"paper\\\") ||\n               (fyodor == \\\"paper\\\" && matroskin == \\\"paper\\\" && sharic == \\\"rock\\\")) {\n        return \\\"S\\\";\n    } else {\n        return \\\"?\\\";\n    }\n}\n\nvoid main() {\n    string[] inputs = [\n        \\\"rock\\\\nrock\\\\nrock\\\\n\\\",\n        \\\"paper\\\\nrock\\\\nrock\\\\n\\\",\n        \\\"scissors\\\\nrock\\\\nrock\\\\n\\\",\n        \\\"scissors\\\\npaper\\\\nrock\\\\n\\\"\n    ];\n    \n    foreach (string input; inputs) {\n        string[] gestures = input.split(\\\"\\\\n\\\");\n        string fyodor = gestures[0];\n        string matroskin = gestures[1];\n        string sharic = gestures[2];\n        \n        string winner = determineWinner(fyodor, matroskin, sharic);\n        writeln(winner);\n    }\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub determine_winner {\n    my ($f, $m, $s) = @_;\n\n    if (($f eq 'rock' && $m eq 'scissors' && $s eq 'scissors') ||\n        ($f eq 'scissors' && $m eq 'rock' && $s eq 'scissors') ||\n        ($f eq 'scissors' && $m eq 'scissors' && $s eq 'rock')) {\n        return 'F';\n    } elsif (($f eq 'scissors' && $m eq 'rock' && $s eq 'rock') ||\n             ($f eq 'rock' && $m eq 'scissors' && $s eq 'rock') ||\n             ($f eq 'rock' && $m eq 'rock' && $s eq 'scissors')) {\n        return 'M';\n    } elsif (($f eq 'rock' && $m eq 'paper' && $s eq 'paper') ||\n             ($f eq 'paper' && $m eq 'rock' && $s eq 'paper') ||\n             ($f eq 'paper' && $m eq 'paper' && $s eq 'rock')) {\n        return 'S';\n    } else {\n        return '?';\n    }\n}\n\nmy $input = <STDIN>;\nchomp($input);\nmy ($f, $m, $s) = split('\\n', $input);\n\nmy $winner = determine_winner($f, $m, $s);\nprint $winner . \\\"\\\\n\\\";\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let fyodor = input.trim();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let matroskin = input.trim();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let sharic = input.trim();\n\n    if (fyodor == \"rock\" && matroskin == \"scissors\" && sharic == \"scissors\") ||\n        (fyodor == \"scissors\" && matroskin == \"rock\" && sharic == \"scissors\") ||\n        (fyodor == \"scissors\" && matroskin == \"scissors\" && sharic == \"rock\") {\n        println!(\"F\");\n    } else if (fyodor == \"rock\" && matroskin == \"paper\" && sharic == \"paper\") ||\n        (fyodor == \"paper\" && matroskin == \"rock\" && sharic == \"paper\") ||\n        (fyodor == \"paper\" && matroskin == \"paper\" && sharic == \"rock\") {\n        println!(\"M\");\n    } else if (fyodor == \"scissors\" && matroskin == \"rock\" && sharic == \"rock\") ||\n        (fyodor == \"rock\" && matroskin == \"scissors\" && sharic == \"rock\") ||\n        (fyodor == \"rock\" && matroskin == \"rock\" && sharic == \"scissors\") {\n        println!(\"S\");\n    } else {\n        println!(\"?\");\n    }\n}"}
{"title":"B. Land Lot","description":"Vasya has a beautiful garden where wonderful fruit trees grow and yield fantastic harvest every year. But lately thieves started to sneak into the garden at nights and steal the fruit too often. Vasya can\u2019t spend the nights in the garden and guard the fruit because there\u2019s no house in the garden! Vasya had been saving in for some time and finally he decided to build the house. The rest is simple: he should choose in which part of the garden to build the house. In the evening he sat at his table and drew the garden\u2019s plan. On the plan the garden is represented as a rectangular checkered field n\u00d7m in size divided into squares whose side length is 1. In some squares Vasya marked the trees growing there (one shouldn\u2019t plant the trees too close to each other that\u2019s why one square contains no more than one tree). Vasya wants to find a rectangular land lot a\u00d7b squares in size to build a house on, at that the land lot border should go along the lines of the grid that separates the squares. All the trees that grow on the building lot will have to be chopped off. Vasya loves his garden very much, so help him choose the building land lot location so that the number of chopped trees would be as little as possible.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m (1\u2264n,m\u226450) which represent the garden location. The next n lines contain m numbers 0 or 1, which describe the garden on the scheme. The zero means that a tree doesn\u2019t grow on this square and the 1 means that there is a growing tree. The last line contains two integers a and b (1\u2264a,b\u226450). Note that Vasya can choose for building an a\u00d7b rectangle as well a b\u00d7a one, i.e. the side of the lot with the length of a can be located as parallel to the garden side with the length of n, as well as parallel to the garden side with the length of m.\n","output_spec":"Print the minimum number of trees that needs to be chopped off to select a land lot a\u00d7b in size to build a house on. It is guaranteed that at least one lot location can always be found, i. e. either a\u2264n and b\u2264m, or a\u2264m \u0438 b\u2264n.\n","notes":"In the second example the upper left square is (1,1) and the lower right is (3,2).\n","sample_inputs":["2 2\n1 0\n1 1\n1 1\n","4 5\n0 0 1 0 1\n0 1 1 1 0\n1 0 1 0 1\n1 1 1 1 1\n2 3\n"],"sample_outputs":["0\n","2\n"],"id":"48-B","difficulty":1200,"tags":["brute+force","implementation"],"src_uid":"1771741663a5236a0aa0551548f4aadd","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<int>> garden(n, vector<int>(m));\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            cin >> garden[i][j];\\n        }\\n    }\\n    int a, b;\\n    cin >> a >> b;\\n    int minTrees = n * m;\\n    for (int i = 0; i <= n - a; i++) {\\n        for (int j = 0; j <= m - b; j++) {\\n            int trees = 0;\\n            for (int x = i; x < i + a; x++) {\\n                for (int y = j; y < j + b; y++) {\\n                    trees += garden[x][y];\\n                }\\n            }\\n            minTrees = min(minTrees, trees);\\n        }\\n    }\\n    cout << minTrees << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int[][] garden = new int[n][m];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                garden[i][j] = scanner.nextInt();\\n            }\\n        }\\n\\n        int a = scanner.nextInt();\\n        int b = scanner.nextInt();\\n\\n        int minTrees = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i <= n - a; i++) {\\n            for (int j = 0; j <= m - b; j++) {\\n                int trees = 0;\\n\\n                for (int k = i; k < i + a; k++) {\\n                    for (int l = j; l < j + b; l++) {\\n                        trees += garden[k][l];\\n                    }\\n                }\\n\\n                minTrees = Math.min(minTrees, trees);\\n            }\\n        }\\n\\n        System.out.println(minTrees);\\n    }\\n}","Python":"def find_min_trees(garden, a, b):\n    n = len(garden)\n    m = len(garden[0])\n    min_trees = float('inf')\n    \n    # Check all possible starting positions for the land lot\n    for i in range(n-a+1):\n        for j in range(m-b+1):\n            trees = 0\n            # Count the number of trees in the land lot\n            for x in range(i, i+a):\n                for y in range(j, j+b):\n                    if garden[x][y] == 1:\n                        trees += 1\n            # Update the minimum number of trees if necessary\n            min_trees = min(min_trees, trees)\n    \n    return min_trees\n\n# Read input\ninput_str = input()\nn, m = map(int, input_str.split())\ngarden = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    garden.append(row)\na, b = map(int, input().split())\n\n# Find the minimum number of trees to be chopped off\nmin_trees = find_min_trees(garden, a, b)\n\n# Print the result\nprint(min_trees)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int garden[n][m];\\n    for(int i=0; i<n; i++) {\\n        for(int j=0; j<m; j++) {\\n            scanf(\\\"%d\\\", &garden[i][j]);\\n        }\\n    }\\n    int a, b;\\n    scanf(\\\"%d %d\\\", &a, &b);\\n    int minTrees = n * m;\\n    for(int i=0; i<=n-a; i++) {\\n        for(int j=0; j<=m-b; j++) {\\n            int trees = 0;\\n            for(int x=i; x<i+a; x++) {\\n                for(int y=j; y<j+b; y++) {\\n                    trees += garden[x][y];\\n                }\\n            }\\n            if(trees < minTrees) {\\n                minTrees = trees;\\n            }\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", minTrees);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace GardenHouse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] dimensions = input.Split(' ');\n            int n = int.Parse(dimensions[0]);\n            int m = int.Parse(dimensions[1]);\n\n            int[,] garden = new int[n, m];\n\n            for (int i = 0; i < n; i++)\n            {\n                string row = Console.ReadLine();\n                string[] trees = row.Split(' ');\n\n                for (int j = 0; j < m; j++)\n                {\n                    garden[i, j] = int.Parse(trees[j]);\n                }\n            }\n\n            string lotDimensions = Console.ReadLine();\n            string[] lot = lotDimensions.Split(' ');\n            int a = int.Parse(lot[0]);\n            int b = int.Parse(lot[1]);\n\n            int minTreesChopped = int.MaxValue;\n\n            \/\/ Check all possible starting positions for the land lot\n            for (int i = 0; i <= n - a; i++)\n            {\n                for (int j = 0; j <= m - b; j++)\n                {\n                    int treesChopped = 0;\n\n                    \/\/ Count the number of trees in the land lot\n                    for (int x = i; x < i + a; x++)\n                    {\n                        for (int y = j; y < j + b; y++)\n                        {\n                            treesChopped += garden[x, y];\n                        }\n                    }\n\n                    minTreesChopped = Math.Min(minTreesChopped, treesChopped);\n                }\n            }\n\n            Console.WriteLine(minTreesChopped);\n        }\n    }\n}","Ruby":"def minimum_trees_chopped(input)\n  # Parse the input\n  lines = input.split('\\\\n')\n  n, m = lines[0].split(' ').map(&:to_i)\n  garden = lines[1...n+1].map { |line| line.split(' ').map(&:to_i) }\n  a, b = lines[n+1].split(' ').map(&:to_i)\n\n  # Initialize variables\n  min_trees_chopped = Float::INFINITY\n\n  # Iterate through all possible land lot locations\n  (0..n-a).each do |i|\n    (0..m-b).each do |j|\n      trees_chopped = 0\n\n      # Count the number of trees that need to be chopped off\n      (i...i+a).each do |x|\n        (j...j+b).each do |y|\n          trees_chopped += 1 if garden[x][y] == 1\n        end\n      end\n\n      # Update the minimum number of trees chopped off\n      min_trees_chopped = [min_trees_chopped, trees_chopped].min\n    end\n  end\n\n  # Return the minimum number of trees chopped off\n  min_trees_chopped.to_s + '\\\\n'\nend","delphi":"program GardenHouse;\\n\\nvar\\n  n, m, a, b, i, j, k, l, minTrees, currTrees: integer;\\n  garden: array of array of integer;\\n\\nbegin\\n  readln(n, m);\\n  SetLength(garden, n, m);\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      read(garden[i, j]);\\n    end;\\n    readln;\\n  end;\\n  readln(a, b);\\n\\n  minTrees := a * b;\\n\\n  for i := 0 to n-a do\\n  begin\\n    for j := 0 to m-b do\\n    begin\\n      currTrees := 0;\\n      for k := i to i+a-1 do\\n      begin\\n        for l := j to j+b-1 do\\n        begin\\n          currTrees := currTrees + garden[k, l];\\n        end;\\n      end;\\n      if currTrees < minTrees then\\n        minTrees := currTrees;\\n    end;\\n  end;\\n\\n  writeln(minTrees);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, a, b int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tgarden := make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tgarden[i] = make([]int, m)\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tfmt.Scanf(\\\"%d\\\", &garden[i][j])\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Scanf(\\\"%d %d\\\", &a, &b)\\n\\n\\tminTrees := n * m\\n\\n\\tfor i := 0; i <= n-a; i++ {\\n\\t\\tfor j := 0; j <= m-b; j++ {\\n\\t\\t\\ttrees := 0\\n\\t\\t\\tfor x := i; x < i+a; x++ {\\n\\t\\t\\t\\tfor y := j; y < j+b; y++ {\\n\\t\\t\\t\\t\\ttrees += garden[x][y]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif trees < minTrees {\\n\\t\\t\\t\\tminTrees = trees\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minTrees)\\n}","Javascript":"function findMinChoppedTrees(input) {\n  \/\/ Parse the input\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const garden = lines.slice(1, n + 1).map(line => line.split(' ').map(Number));\n  const [a, b] = lines[n + 1].split(' ').map(Number);\n\n  let minChoppedTrees = Infinity;\n\n  \/\/ Check all possible land lot locations\n  for (let i = 0; i <= n - a; i++) {\n    for (let j = 0; j <= m - b; j++) {\n      let choppedTrees = 0;\n\n      \/\/ Count the number of trees in the land lot\n      for (let x = i; x < i + a; x++) {\n        for (let y = j; y < j + b; y++) {\n          choppedTrees += garden[x][y];\n        }\n      }\n\n      \/\/ Update the minimum number of chopped trees\n      minChoppedTrees = Math.min(minChoppedTrees, choppedTrees);\n    }\n  }\n\n  \/\/ Return the minimum number of chopped trees\n  return minChoppedTrees.toString();\n}\n\n\/\/ Test the function with the sample inputs\nconst inputs = ['2 2\\\\n1 0\\\\n1 1\\\\n1 1\\\\n', '4 5\\\\n0 0 1 0 1\\\\n0 1 1 1 0\\\\n1 0 1 0 1\\\\n1 1 1 1 1\\\\n2 3\\\\n'];\nconst outputs = inputs.map(findMinChoppedTrees);\n\n\/\/ Print the outputs\nconsole.log(outputs.join('\\\\n'));","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val nm = scanner.nextLine().split(\" \")\n    val n = nm[0].toInt()\n    val m = nm[1].toInt()\n    val garden = Array(n) { IntArray(m) }\n    for (i in 0 until n) {\n        val row = scanner.nextLine().split(\" \").map { it.toInt() }\n        for (j in 0 until m) {\n            garden[i][j] = row[j]\n        }\n    }\n    val ab = scanner.nextLine().split(\" \")\n    val a = ab[0].toInt()\n    val b = ab[1].toInt()\n    \n    var minChoppedTrees = Int.MAX_VALUE\n    \n    \/\/ Check all possible land lot locations\n    for (i in 0..n-a) {\n        for (j in 0..m-b) {\n            var choppedTrees = 0\n            \/\/ Count the number of trees in the land lot\n            for (x in i until i+a) {\n                for (y in j until j+b) {\n                    choppedTrees += garden[x][y]\n                }\n            }\n            minChoppedTrees = minOf(minChoppedTrees, choppedTrees)\n        }\n    }\n    \n    println(minChoppedTrees)\n}","PHP":"<?php\\n\\nfunction findMinChoppedTrees($garden, $a, $b) {\\n    $n = count($garden);\\n    $m = count($garden[0]);\\n    $minChoppedTrees = PHP_INT_MAX;\\n\\n    \/\/ Check all possible starting positions for the land lot\\n    for ($i = 0; $i <= $n - $a; $i++) {\\n        for ($j = 0; $j <= $m - $b; $j++) {\\n            $choppedTrees = 0;\\n\\n            \/\/ Count the number of trees in the land lot\\n            for ($x = $i; $x < $i + $a; $x++) {\\n                for ($y = $j; $y < $j + $b; $y++) {\\n                    if ($garden[$x][$y] == 1) {\\n                        $choppedTrees++;\\n                    }\\n                }\\n            }\\n\\n            \/\/ Update the minimum number of chopped trees\\n            $minChoppedTrees = min($minChoppedTrees, $choppedTrees);\\n        }\\n    }\\n\\n    return $minChoppedTrees;\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    ['2 2\\n1 0\\n1 1\\n1 1\\n', '1 1\\n'],\\n    ['4 5\\n0 0 1 0 1\\n0 1 1 1 0\\n1 0 1 0 1\\n1 1 1 1 1\\n2 3\\n'],\\n];\\n\\n\/\/ Process each sample input\\nforeach ($inputs as $input) {\\n    $lines = explode(\\\"\\\\n\\\", $input[0]);\\n    $n = explode(\\\" \\\", $lines[0])[0];\\n    $m = explode(\\\" \\\", $lines[0])[1];\\n    $garden = [];\\n\\n    \/\/ Parse the garden layout\\n    for ($i = 1; $i <= $n; $i++) {\\n        $garden[] = explode(\\\" \\\", $lines[$i]);\\n    }\\n\\n    $a = explode(\\\" \\\", $input[1])[0];\\n    $b = explode(\\\" \\\", $input[1])[1];\\n\\n    \/\/ Find the minimum number of chopped trees\\n    $minChoppedTrees = findMinChoppedTrees($garden, $a, $b);\\n\\n    \/\/ Print the result\\n    echo $minChoppedTrees . \\\"\\\\n\\\";\\n}\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] garden = new int[][](n, m);\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        for (int j = 0; j < m; j++)\\r\\n        {\\r\\n            readf(\\\"%d\\\", &garden[i][j]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int a, b;\\r\\n    readf(\\\"%d %d\\\", &a, &b);\\r\\n\\r\\n    int minTrees = n * m;\\r\\n\\r\\n    for (int i = 0; i <= n - a; i++)\\r\\n    {\\r\\n        for (int j = 0; j <= m - b; j++)\\r\\n        {\\r\\n            int trees = 0;\\r\\n\\r\\n            for (int x = i; x < i + a; x++)\\r\\n            {\\r\\n                for (int y = j; y < j + b; y++)\\r\\n                {\\r\\n                    trees += garden[x][y];\\r\\n                }\\r\\n            }\\r\\n\\r\\n            minTrees = min(minTrees, trees);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(minTrees);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_min_trees {\\n    my ($n, $m, $garden, $a, $b) = @_;\\n    my $min_trees = $a * $b; # initialize with maximum possible value\\n\\n    for my $i (0..$n-$a) {\\n        for my $j (0..$m-$b) {\\n            my $trees = 0;\\n\\n            for my $x ($i..$i+$a-1) {\\n                for my $y ($j..$j+$b-1) {\\n                    $trees += $garden->[$x][$y];\\n                }\\n            }\\n\\n            $min_trees = $trees if $trees < $min_trees;\\n        }\\n    }\\n\\n    return $min_trees;\\n}\\n\\nsub main {\\n    my ($n, $m) = split ' ', <STDIN>;\\n    my @garden;\\n\\n    for (1..$n) {\\n        my @row = split ' ', <STDIN>;\\n        push @garden, \\@row;\\n    }\\n\\n    my ($a, $b) = split ' ', <STDIN>;\\n\\n    my $min_trees = find_min_trees($n, $m, \\@garden, $a, $b);\\n    print $min_trees . \\\"\\\\n\\\";\\n}\\n\\nmain();\\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buffer = String::new();\n    input.read_line(&mut buffer).unwrap();\n    let nm: Vec<usize> = buffer\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = nm[0];\n    let m = nm[1];\n\n    let mut garden = vec![vec![0; m]; n];\n    for i in 0..n {\n        buffer.clear();\n        input.read_line(&mut buffer).unwrap();\n        let row: Vec<usize> = buffer\n            .split_whitespace()\n            .map(|x| x.parse().unwrap())\n            .collect();\n        for j in 0..m {\n            garden[i][j] = row[j];\n        }\n    }\n\n    buffer.clear();\n    input.read_line(&mut buffer).unwrap();\n    let ab: Vec<usize> = buffer\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let a = ab[0];\n    let b = ab[1];\n\n    let mut min_chopped = std::usize::MAX;\n    for i in 0..=(n - a) {\n        for j in 0..=(m - b) {\n            let mut chopped = 0;\n            for x in i..(i + a) {\n                for y in j..(j + b) {\n                    chopped += garden[x][y];\n                }\n            }\n            min_chopped = min_chopped.min(chopped);\n        }\n    }\n\n    println!(\"{}\", min_chopped);\n}"}
{"title":"C. The Race","description":"Every year a race takes place on the motorway between cities A and B. This year Vanya decided to take part in the race and drive his own car that has been around and bears its own noble name \u2014 The Huff-puffer.So, Vasya leaves city A on the Huff-puffer, besides, at the very beginning he fills the petrol tank with \u03b1 liters of petrol (\u03b1\u226510 is Vanya's favorite number, it is not necessarily integer). Petrol stations are located on the motorway at an interval of 100 kilometers, i.e. the first station is located 100 kilometers away from the city A, the second one is 200 kilometers away from the city A, the third one is 300 kilometers away from the city A and so on. The Huff-puffer spends 10 liters of petrol every 100 kilometers. Vanya checks the petrol tank every time he passes by a petrol station. If the petrol left in the tank is not enough to get to the next station, Vanya fills the tank with \u03b1 liters of petrol. Otherwise, he doesn't stop at the station and drives on. For example, if \u03b1=43.21, then the car will be fuelled up for the first time at the station number 4, when there'll be 3.21 petrol liters left. After the fuelling up the car will have 46.42 liters. Then Vanya stops at the station number 8 and ends up with 6.42+43.21=49.63 liters. The next stop is at the station number 12, 9.63+43.21=52.84. The next stop is at the station number 17 and so on. You won't believe this but the Huff-puffer has been leading in the race! Perhaps it is due to unexpected snow. Perhaps it is due to video cameras that have been installed along the motorway which register speed limit breaking. Perhaps it is due to the fact that Vanya threatened to junk the Huff-puffer unless the car wins. Whatever the reason is, the Huff-puffer is leading, and jealous people together with other contestants wrack their brains trying to think of a way to stop that outrage.One way to do this is to mine the next petrol station where Vanya will stop. Your task is to calculate at which station this will happen and warn Vanya. You don't know the \u03b1 number, however, you are given the succession of the numbers of the stations where Vanya has stopped. Find the number of the station where the next stop will be.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (1\u2264n\u22641000) which represents the number of petrol stations where Vanya has stopped. The next line has n space-separated integers which represent the numbers of the stations. The numbers are positive and do not exceed 10^6, they are given in the increasing order. No two numbers in the succession match. It is guaranteed that there exists at least one number \u03b1\u226510, to which such a succession of stops corresponds.\n","output_spec":"Print in the first line \"unique\" (without quotes) if the answer can be determined uniquely. In the second line print the number of the station where the next stop will take place. If the answer is not unique, print in the first line \"not unique\".\n","notes":"In the second example the answer is not unique. For example, if \u03b1=10, we'll have such a sequence as 1, 2, 3, and if \u03b1=14, the sequence will be 1, 2, 4.\n","sample_inputs":["3\n1 2 4\n","2\n1 2\n"],"sample_outputs":["unique\n5\n","not unique\n"],"id":"48-C","difficulty":1800,"tags":["math"],"src_uid":"bfbd7a73e65d240ee7e8c83cc68ca0a1","C++":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> stations(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> stations[i];\\n    }\\n\\n    int nextStation = stations[n-1] + 1;\\n    bool unique = true;\\n\\n    for (int i = 1; i < n; i++) {\\n        int distance = stations[i] - stations[i-1];\\n        if (distance % 100 != 0) {\\n            unique = false;\\n            break;\\n        }\\n        int requiredFuel = distance \/ 100 * 10;\\n        if (requiredFuel > nextStation) {\\n            nextStation = requiredFuel;\\n        }\\n    }\\n\\n    if (unique) {\\n        cout << \\\"unique\\\" << endl;\\n        cout << nextStation << endl;\\n    } else {\\n        cout << \\\"not unique\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class PetrolStation {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] stations = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            stations[i] = scanner.nextInt();\\n        }\\n\\n        int nextStation = findNextStation(stations);\\n\\n        if (nextStation == -1) {\\n            System.out.println(\\\"not unique\\\");\\n        } else {\\n            System.out.println(\\\"unique\\\");\\n            System.out.println(nextStation);\\n        }\\n    }\\n\\n    public static int findNextStation(int[] stations) {\\n        int n = stations.length;\\n\\n        for (int i = 1; i < n; i++) {\\n            int distance = stations[i] - stations[i - 1];\\n            double petrolNeeded = distance \/ 100.0 * 10;\\n\\n            if (petrolNeeded > 10) {\\n                return stations[i - 1] + (int) Math.ceil(petrolNeeded);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\"}}","Python":"def find_next_stop(n, stops):\\n    for i in range(1, n+2):\\n        if i not in stops:\\n            return i\\n    return -1\\n\\nn = int(input())\\nstops = list(map(int, input().split()))\\n\\nnext_stop = find_next_stop(n, stops)\\n\\nif next_stop == -1:\\n    print('not unique')\\nelse:\\n    print('unique')\\n    print(next_stop)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int stations[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &stations[i]);\\n    }\\n\\n    int nextStation = stations[n-1] + 1;\\n    int unique = 1;\\n\\n    for (int i = 0; i < n-1; i++) {\\n        int distance = stations[i+1] - stations[i];\\n        float alpha = (float) distance \/ 10;\\n\\n        if (alpha < 10) {\\n            unique = 0;\\n            break;\\n        }\\n\\n        if (alpha < nextStation) {\\n            nextStation = alpha;\\n        }\\n    }\\n\\n    if (unique) {\\n        printf(\\\"unique\\\\n\\\");\\n        printf(\\\"%d\\\\n\\\", nextStation);\\n    } else {\\n        printf(\\\"not unique\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace PetrolStation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            string[] stations = Console.ReadLine().Split(' ');\n\n            int nextStation = CalculateNextStation(n, stations);\n\n            Console.WriteLine(nextStation == -1 ? \\\"not unique\\\" : \\\"unique\\\");\n            if (nextStation != -1)\n            {\n                Console.WriteLine(nextStation);\n            }\n        }\n\n        static int CalculateNextStation(int n, string[] stations)\n        {\n            int nextStation = -1;\n\n            for (int i = 0; i < n - 1; i++)\n            {\n                int currentStation = int.Parse(stations[i]);\n                int nextExpectedStation = currentStation + 1;\n\n                if (nextExpectedStation != int.Parse(stations[i + 1]))\n                {\n                    nextStation = nextExpectedStation;\n                    break;\n                }\n            }\n\n            return nextStation;\n        }\n    }\n}","Ruby":"def calculate_next_stop(input)\n  n, stations = input.split('\\n')\n  n = n.to_i\n  stations = stations.split(' ').map(&:to_i)\n  \n  # Check if the answer is unique\n  if n == 1\n    return 'unique\\n2\\n'\n  end\n  \n  # Calculate the difference between consecutive stations\n  differences = []\n  (1..n-1).each do |i|\n    differences << stations[i] - stations[i-1]\n  end\n  \n  # Find the next stop station\n  next_stop = stations[-1] + differences[-1]\n  \n  # Check if the answer is unique\n  if differences.uniq.length == 1\n    return 'unique\\n' + next_stop.to_s + '\\n'\n  else\n    return 'not unique\\n'\n  end\nend\n\ninput = '3\\n1 2 4\\n'\nputs calculate_next_stop(input)\n\ninput = '2\\n1 2\\n'\nputs calculate_next_stop(input)\n","delphi":"program PetrolStations;\\n\\nvar\\n  n, i, nextStop: Integer;\\n  stations: array of Integer;\\n  unique: Boolean;\\n\\nbegin\\n  ReadLn(n);\\n  SetLength(stations, n);\\n  for i := 0 to n-1 do\\n    Read(stations[i]);\\n\\n  unique := True;\\n  nextStop := stations[n-1] + 1;\\n\\n  for i := 0 to n-2 do\\n  begin\\n    if (stations[i+1] - stations[i]) mod 100 <> 0 then\\n    begin\\n      unique := False;\\n      nextStop := stations[i] + 100 - (stations[i] mod 100);\\n      Break;\\n    end;\\n  end;\\n\\n  if unique then\\n    WriteLn('unique')\\n  else\\n    WriteLn('not unique');\\n\\n  WriteLn(nextStop);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar stops string\\n\\tfmt.Scan(&stops)\\n\\n\\tstopArr := strings.Split(stops, \\\" \\\")\\n\\n\\tvar unique bool = true\\n\\tvar nextStop int\\n\\n\\tfor i := 0; i < len(stopArr)-1; i++ {\\n\\t\\tcurrentStop, _ := strconv.Atoi(stopArr[i])\\n\\t\\tnextStop, _ = strconv.Atoi(stopArr[i+1])\\n\\n\\t\\tdistance := nextStop - currentStop\\n\\t\\trequiredFuel := float64(distance) \/ 100 * 10\\n\\n\\t\\tif requiredFuel > 10 {\\n\\t\\t\\tunique = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif unique {\\n\\t\\tnextStop += 1\\n\\t\\tfmt.Println(\\\"unique\\\")\\n\\t\\tfmt.Println(nextStop)\\n\\t} else {\\n\\t\\tfmt.Println(\\\"not unique\\\")\\n\\t}\\n}","Javascript":"function findNextStop(input) {\n  const n = parseInt(input[0]);\n  const stops = input[1].split(' ').map(Number);\n  \n  let unique = true;\n  let nextStop = stops[stops.length - 1] + 1;\n  \n  for (let i = 1; i < stops.length; i++) {\n    const distance = stops[i] - stops[i - 1];\n    const requiredPetrol = Math.ceil(distance \/ 100) * 10;\n    \n    if (requiredPetrol < 10) {\n      unique = false;\n      break;\n    }\n    \n    if (requiredPetrol > nextStop) {\n      nextStop = requiredPetrol;\n    }\n  }\n  \n  if (unique) {\n    return 'unique\\n' + nextStop + '\\n';\n  } else {\n    return 'not unique\\n';\n  }\n}\n\nconst input = ['3\\n1 2 4\\n'];\nconst output = findNextStop(input);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val stations = IntArray(n)\n    for (i in 0 until n) {\n        stations[i] = sc.nextInt()\n    }\n    \n    var unique = true\n    var nextStation = 0\n    \n    for (i in 0 until n - 1) {\n        val distance = stations[i + 1] - stations[i]\n        val requiredPetrol = distance \/ 100 * 10.0\n        \n        if (requiredPetrol > 10) {\n            unique = false\n            break\n        }\n        \n        if (requiredPetrol > nextStation) {\n            nextStation = requiredPetrol.toInt()\n        }\n    }\n    \n    if (unique) {\n        println(\"unique\")\n        println(stations[n - 1] + nextStation)\n    } else {\n        println(\"not unique\")\n    }\n}","PHP":"\n<?php\n\nfunction calculateNextStop($n, $stations) {\n    $unique = true;\n    $nextStop = 0;\n    \n    \/\/ Check if the sequence is increasing by 1\n    for ($i = 0; $i < $n - 1; $i++) {\n        if ($stations[$i + 1] - $stations[$i] != 1) {\n            $unique = false;\n            break;\n        }\n    }\n    \n    \/\/ If the sequence is increasing by 1, calculate the next stop\n    if ($unique) {\n        $nextStop = $stations[$n - 1] + 1;\n    }\n    \n    \/\/ Print the result\n    if ($unique) {\n        echo \\\"unique\\\\n\\\";\n        echo $nextStop;\n    } else {\n        echo \\\"not unique\\\\n\\\";\n    }\n}\n\n\/\/ Read input\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\n$n = intval($input[0]);\n$stations = array_map('intval', explode(\\\" \\\", $input[1]));\n\n\/\/ Calculate and print the next stop\ncalculateNextStop($n, $stations);\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] stations = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &stations[i]);\\r\\n    }\\r\\n\\r\\n    int nextStation;\\r\\n    bool unique = true;\\r\\n\\r\\n    for (int i = 1; i < n; i++)\\r\\n    {\\r\\n        int distance = stations[i] - stations[i - 1];\\r\\n        double alpha = distance * 10 \/ 100.0;\\r\\n\\r\\n        if (alpha < 10)\\r\\n        {\\r\\n            unique = false;\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        if (i == n - 1)\\r\\n        {\\r\\n            nextStation = stations[i] + 1;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            nextStation = stations[i] + (int)alpha;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (unique)\\r\\n    {\\r\\n        writeln(\\\"unique\\\");\\r\\n        writeln(nextStation);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"not unique\\\");\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_next_stop {\\n    my ($n, $stations) = @_;\\n    my @stops = split(' ', $stations);\\n    my $prev_stop = 0;\\n    my $next_stop;\\n    my $unique = 1;\\n\\n    foreach my $stop (@stops) {\\n        if ($stop - $prev_stop > 1) {\\n            $next_stop = $prev_stop + 1;\\n            $unique = 0;\\n            last;\\n        }\\n        $prev_stop = $stop;\\n    }\\n\\n    if ($unique) {\\n        $next_stop = $prev_stop + 1;\\n        return \\\"unique\\\\n$next_stop\\\\n\\\";\\n    } else {\\n        return \\\"not unique\\\\n\\\";\\n    }\\n}\\n\\n# Read input\\nmy $n = <STDIN>;\\nmy $stations = <STDIN>;\\n\\n# Call function\\nmy $result = find_next_stop($n, $stations);\\n\\n# Print result\\nprint $result;\\n","Rust":"fn main() {\\n    let input = \\\"3\\\\n1 2 4\\\\n\\\";\\n    let mut lines = input.lines();\\n    let n: usize = lines.next().unwrap().parse().unwrap();\\n    let stations: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut unique = true;\\n    let mut next_station = 0;\\n\\n    for i in 1..=1000 {\\n        if !stations.contains(&i) {\\n            if unique {\\n                unique = false;\\n                next_station = i;\\n            } else {\\n                println!(\\\"not unique\\\");\\n                return;\\n            }\\n        }\\n    }\\n\\n    println!(\\\"unique\\\");\\n    println!(\\\"{}\\\", next_station);\\n}"}
{"title":"G. Galaxy Union","description":"In a far away galaxy there are n inhabited planets numbered with numbers from 1 to n. One day the presidents of all the n planets independently from each other came up with an idea of creating the Galaxy Union. Now they need to share this wonderful idea with their galaxymates, that\u2019s why each president is busy working out a project of negotiating with the other presidents.For negotiations between some pairs of the planets there are bidirectional communication channels, each of which is characterized with \"dial duration\" ti which, as a rule, takes several hours and exceeds the call duration greatly. Overall the galaxy has n communication channels and they unite all the planets into a uniform network. That means that it is possible to phone to any planet v from any planet u, perhaps, using some transitional planets v1, v2, ..., vm via the existing channels between u and v1, v1 and v2, ..., vm-1 and vm, vm and v. At that the dial duration from u to v will be equal to the sum of dial durations of the used channels.So, every president has to talk one by one to the presidents of all the rest n-1 planets. At that the negotiations take place strictly consecutively, and until the negotiations with a planet stop, the dial to another one does not begin. As the matter is urgent, from the different ways to call the needed planet every time the quickest one is chosen. Little time is needed to assure another president on the importance of the Galaxy Union, that\u2019s why the duration of the negotiations with each planet can be considered equal to the dial duration time for those planets. As the presidents know nothing about each other\u2019s plans, they do not take into consideration the possibility that, for example, the sought president may call himself or already know about the founding of the Galaxy Union from other sources.The governments of all the n planets asked you to work out the negotiation plans. First you are to find out for every president how much time his supposed negotiations will take.","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (3\u2264n\u2264200000) which represents the number of planets in the Galaxy and the number of communication channels equal to it. The next n lines contain three integers each ai, bi and ti (1\u2264ai,bi\u2264n,ai\u2260bi,1\u2264ti\u226410^3) that represent the numbers of planet joined by a communication channel and its \"dial duration\". There can be no more than one communication channel between a pair of planets. \n","output_spec":"In the first line output n integers \u2014 the durations of the supposed negotiations for each president. Separate the numbers by spaces.\n","notes":null,"sample_inputs":["3\n1 2 3\n2 3 2\n1 3 1\n","3\n1 2 3\n2 3 2\n1 3 5\n","4\n1 2 3\n2 3 2\n3 4 1\n4 1 4\n"],"sample_outputs":["4 5 3\n","8 5 7\n","12 8 8 8\n"],"id":"48-G","difficulty":2700,"tags":["dp","trees","two+pointers"],"src_uid":"00480885be97002dca98fe98a4238aee","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <climits>\\nusing namespace std;\\n\\nstruct Edge {\\n    int to;\\n    int weight;\\n};\\n\\nvector<int> calculateNegotiationDurations(int n, vector<vector<int>>& channels) {\\n    vector<vector<Edge>> graph(n + 1);\\n    vector<int> durations(n + 1, INT_MAX);\\n    vector<bool> visited(n + 1, false);\\n\\n    for (int i = 0; i < channels.size(); i++) {\\n        int a = channels[i][0];\\n        int b = channels[i][1];\\n        int t = channels[i][2];\\n\\n        graph[a].push_back({b, t});\\n        graph[b].push_back({a, t});\\n    }\\n\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    pq.push({0, 1});\\n    durations[1] = 0;\\n\\n    while (!pq.empty()) {\\n        int planet = pq.top().second;\\n        pq.pop();\\n\\n        if (visited[planet]) {\\n            continue;\\n        }\\n\\n        visited[planet] = true;\\n\\n        for (auto edge : graph[planet]) {\\n            int neighbor = edge.to;\\n            int weight = edge.weight;\\n\\n            if (durations[planet] + weight < durations[neighbor]) {\\n                durations[neighbor] = durations[planet] + weight;\\n                pq.push({durations[neighbor], neighbor});\\n            }\\n        }\\n    }\\n\\n    return durations;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    vector<vector<int>> channels(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        int a, b, t;\\n        cin >> a >> b >> t;\\n        channels[i] = {a, b, t};\\n    }\\n\\n    vector<int> negotiationDurations = calculateNegotiationDurations(n, channels);\\n\\n    for (int i = 1; i <= n; i++) {\\n        cout << negotiationDurations[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\nimport java.util.Scanner;\\n\\npublic class GalaxyUnion {\\n\\n    static class Edge implements Comparable<Edge> {\\n        int planet;\\n        int duration;\\n\\n        public Edge(int planet, int duration) {\\n            this.planet = planet;\\n            this.duration = duration;\\n        }\\n\\n        @Override\\n        public int compareTo(Edge other) {\\n            return Integer.compare(this.duration, other.duration);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        List<List<Edge>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = scanner.nextInt() - 1;\\n            int b = scanner.nextInt() - 1;\\n            int t = scanner.nextInt();\\n            graph.get(a).add(new Edge(b, t));\\n            graph.get(b).add(new Edge(a, t));\\n        }\\n        int[] durations = calculateNegotiationDurations(graph);\\n        for (int duration : durations) {\\n            System.out.print(duration + \\\" \\\");\\n        }\\n    }\\n\\n    public static int[] calculateNegotiationDurations(List<List<Edge>> graph) {\\n        int n = graph.size();\\n        int[] durations = new int[n];\\n        Arrays.fill(durations, Integer.MAX_VALUE);\\n        PriorityQueue<Edge> queue = new PriorityQueue<>();\\n        queue.add(new Edge(0, 0));\\n        while (!queue.isEmpty()) {\\n            Edge current = queue.poll();\\n            if (current.duration > durations[current.planet]) {\\n                continue;\\n            }\\n            durations[current.planet] = current.duration;\\n            for (Edge neighbor : graph.get(current.planet)) {\\n                int newDuration = current.duration + neighbor.duration;\\n                if (newDuration < durations[neighbor.planet]) {\\n                    queue.add(new Edge(neighbor.planet, newDuration));\\n                }\\n            }\\n        }\\n        return durations;\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\nimport java.util.Scanner;\\n\\npublic class GalaxyUnion {\\n\\n    static class Edge implements Comparable<Edge> {\\n        int planet;\\n        int duration;\\n\\n        public Edge(int planet, int duration) {\\n            this.planet = planet;\\n            this.duration = duration;\\n        }\\n\\n        @Override\\n        public int compareTo(Edge other) {\\n            return Integer.compare(this.duration, other.duration);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        List<List<Edge>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = scanner.nextInt() - 1;\\n            int b = scanner.nextInt() - 1;\\n            int t = scanner.nextInt();\\n            graph.get(a).add(new Edge(b, t));\\n            graph.get(b).add(new Edge(a, t));\\n        }\\n        int[] durations = calculateNegotiationDurations(graph);\\n        for (int duration : durations) {\\n            System.out.print(duration + \\\" \\\");\\n        }\\n    }\\n\\n    public static int[] calculateNegotiationDurations(List<List<Edge>> graph) {\\n        int n = graph.size();\\n        int[] durations = new int[n];\\n        Arrays.fill(durations, Integer.MAX_VALUE);\\n        PriorityQueue<Edge> queue = new PriorityQueue<>();\\n        queue.add(new Edge(0, 0));\\n        while (!queue.isEmpty()) {\\n            Edge current = queue.poll();\\n            if (current.duration > durations[current.planet]) {\\n                continue;\\n            }\\n            durations[current.planet] = current.duration;\\n            for (Edge neighbor : graph.get(current.planet)) {\\n                int newDuration = current.duration + neighbor.duration;\\n                if (newDuration < durations[neighbor.planet]) {\\n                    queue.add(new Edge(neighbor.planet, newDuration));\\n                }\\n            }\\n        }\\n        return durations;\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\nimport java.util.Scanner;\\n\\npublic class GalaxyUnion {\\n\\n    static class Edge implements Comparable<Edge> {\\n        int planet;\\n        int duration;\\n\\n        public Edge(int planet, int duration) {\\n            this.planet = planet;\\n            this.duration = duration;\\n        }\\n\\n        @Override\\n        public int compareTo(Edge other) {\\n            return Integer.compare(this.duration, other.duration);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        List<List<Edge>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = scanner.nextInt() - 1;\\n            int b = scanner.nextInt() - 1;\\n            int t = scanner.nextInt();\\n            graph.get(a).add(new Edge(b, t));\\n            graph.get(b).add(new Edge(a, t));\\n        }\\n        int[] durations = calculateNegotiationDurations(graph);\\n        for (int duration : durations) {\\n            System.out.print(duration + \\\" \\\");\\n        }\\n    }\\n\\n    public static int[] calculateNegotiationDurations(List<List<Edge>> graph) {\\n        int n = graph.size();\\n        int[] durations = new int[n];\\n        Arrays.fill(durations, Integer.MAX_VALUE);\\n        PriorityQueue<Edge> queue = new PriorityQueue<>();\\n        queue.add(new Edge(0, 0));\\n        while (!queue.isEmpty()) {\\n            Edge current = queue.poll();\\n            if (current.duration > durations[current.planet]) {\\n                continue;\\n            }\\n            durations[current.planet] = current.duration;\\n            for (Edge neighbor : graph.get(current.planet)) {\\n                int newDuration = current.duration + neighbor.duration;\\n                if (newDuration < durations[neighbor.planet]) {\\n                    queue.add(new Edge(neighbor.planet, newDuration));\\n                }\\n            }\\n        }\\n        return durations;\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\nimport java.util.Scanner;\\n\\npublic class GalaxyUnion {\\n\\n    static class Edge implements Comparable<Edge> {\\n        int planet;\\n        int duration;\\n\\n        public Edge(int planet, int duration) {\\n            this.planet = planet;\\n            this.duration = duration;\\n        }\\n\\n        @Override\\n        public int compareTo(Edge other) {\\n            return Integer.compare(this.duration, other.duration);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        List<List<Edge>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int a = scanner.nextInt() - 1;\\n            int b = scanner.nextInt() - 1;\\n            int t = scanner.nextInt();\\n            graph.get(a).add(new Edge(b, t));\\n            graph.get(b).add(new Edge(a, t));\\n        }\\n        int[] durations = calculateNegotiationDurations(graph);\\n        for (int duration : durations) {\\n            System.out.print(duration + \\\" \\\");\\n        }\\n    }\\n\\n    public static int[] calculateNegotiationDurations(List<List<Edge>> graph) {\\n        int n = graph.size();\\n        int[] durations = new int[n];\\n        Arrays.fill(durations, Integer.MAX_VALUE);\\n        PriorityQueue<Edge> queue = new PriorityQueue<>();\\n        queue.add(new Edge(0, 0));\\n        while (!queue.isEmpty()) {\\n            Edge current = queue.poll();\\n            if (current.duration > durations[current.planet]) {\\n                continue;\\n            }\\n            durations[current.planet] = current.duration;\\n            for (Edge neighbor : graph.get(current.planet)) {\\n                int newDuration = current.duration + neighbor.duration;\\n                if (newDuration < durations[neighbor.planet]) {\\n                    queue.add(new Edge(neighbor.planet, newDuration));\\n                }\\n            }\\n        }\\n        return durations;\\n    }\\n}","Python":"from collections import defaultdict\\n\\n\\ndef negotiate_time(n, planets):\\n    graph = defaultdict(list)\\n    for a, b, t in planets:\\n        graph[a].append((b, t))\\n        graph[b].append((a, t))\\n    \\n    def dfs(node, parent):\\n        total_time = 0\\n        for neighbor, dial_duration in graph[node]:\\n            if neighbor != parent:\\n                total_time += dial_duration + dfs(neighbor, node)\\n        return total_time\\n    \\n    negotiation_times = []\\n    for i in range(1, n+1):\\n        negotiation_times.append(dfs(i, -1))\\n    \\n    return ' '.join(map(str, negotiation_times))\\n\\n\\n# Example usage\\nn = 3\\nplanets = [(1, 2, 3), (2, 3, 2), (1, 3, 1)]\\nresult = negotiate_time(n, planets)\\nprint(result)\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_PLANETS 200000\\n\\nstruct Planet {\\n    int id;\\n    int duration;\\n    struct Planet* next;\\n};\\n\\nstruct Planet* createPlanet(int id, int duration) {\\n    struct Planet* planet = (struct Planet*)malloc(sizeof(struct Planet));\\n    planet->id = id;\\n    planet->duration = duration;\\n    planet->next = NULL;\\n    return planet;\\n}\\n\\nvoid addPlanet(struct Planet** head, int id, int duration) {\\n    struct Planet* planet = createPlanet(id, duration);\\n    if (*head == NULL) {\\n        *head = planet;\\n    } else {\\n        struct Planet* current = *head;\\n        while (current->next != NULL) {\\n            current = current->next;\\n        }\\n        current->next = planet;\\n    }\\n}\\n\\nvoid calculateNegotiationDurations(int n, int channels[][3], int* durations) {\\n    struct Planet* planets[MAX_PLANETS];\\n    for (int i = 0; i < MAX_PLANETS; i++) {\\n        planets[i] = NULL;\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        int a = channels[i][0];\\n        int b = channels[i][1];\\n        int t = channels[i][2];\\n\\n        addPlanet(&planets[a], b, t);\\n        addPlanet(&planets[b], a, t);\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        struct Planet* current = planets[i];\\n        int totalDuration = 0;\\n\\n        while (current != NULL) {\\n            totalDuration += current->duration;\\n            current = current->next;\\n        }\\n\\n        durations[i - 1] = totalDuration;\\n    }\\n}\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n\\n    int channels[n][3];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d %d %d\\\", &channels[i][0], &channels[i][1], &channels[i][2]);\\n    }\\n\\n    int durations[n];\\n    calculateNegotiationDurations(n, channels, durations);\\n\\n    for (int i = 0; i < n; i++) {\\n        printf(\\\"%d \\\", durations[i]);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace GalaxyUnion\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<Planet> planets = new List<Planet>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] input = Console.ReadLine().Split();\n                int a = int.Parse(input[0]);\n                int b = int.Parse(input[1]);\n                int t = int.Parse(input[2]);\n\n                Planet planetA = planets.FirstOrDefault(p => p.Number == a);\n                Planet planetB = planets.FirstOrDefault(p => p.Number == b);\n\n                if (planetA == null)\n                {\n                    planetA = new Planet(a);\n                    planets.Add(planetA);\n                }\n\n                if (planetB == null)\n                {\n                    planetB = new Planet(b);\n                    planets.Add(planetB);\n                }\n\n                planetA.AddNeighbor(planetB, t);\n                planetB.AddNeighbor(planetA, t);\n            }\n\n            foreach (Planet planet in planets)\n            {\n                int duration = GetNegotiationDuration(planet, planets);\n                Console.Write(duration + \" \");\n            }\n        }\n\n        static int GetNegotiationDuration(Planet startPlanet, List<Planet> planets)\n        {\n            Dictionary<Planet, int> durations = new Dictionary<Planet, int>();\n            foreach (Planet planet in planets)\n            {\n                durations[planet] = int.MaxValue;\n            }\n\n            durations[startPlanet] = 0;\n\n            Queue<Planet> queue = new Queue<Planet>();\n            queue.Enqueue(startPlanet);\n\n            while (queue.Count > 0)\n            {\n                Planet currentPlanet = queue.Dequeue();\n\n                foreach (KeyValuePair<Planet, int> neighbor in currentPlanet.Neighbors)\n                {\n                    int neighborDuration = durations[currentPlanet] + neighbor.Value;\n                    if (neighborDuration < durations[neighbor.Key])\n                    {\n                        durations[neighbor.Key] = neighborDuration;\n                        queue.Enqueue(neighbor.Key);\n                    }\n                }\n            }\n\n            return durations.Values.Max();\n        }\n    }\n\n    class Planet\n    {\n        public int Number { get; }\n        public Dictionary<Planet, int> Neighbors { get; }\n\n        public Planet(int number)\n        {\n            Number = number;\n            Neighbors = new Dictionary<Planet, int>();\n        }\n\n        public void AddNeighbor(Planet neighbor, int duration)\n        {\n            Neighbors[neighbor] = duration;\n        }\n    }\n}","Ruby":"def negotiation_durations(input)\n  # Parse the input\n  lines = input.split(\"\\n\")\n  n = lines[0].to_i\n  channels = lines[1..n].map { |line| line.split(\" \").map(&:to_i) }\n\n  # Initialize an array to store the durations\n  durations = Array.new(n, 0)\n\n  # Calculate the durations for each president\n  (0...n).each do |president|\n    # Initialize an array to store the minimum durations for each planet\n    min_durations = Array.new(n, Float::INFINITY)\n    min_durations[president] = 0\n\n    # Use Dijkstra's algorithm to find the minimum durations\n    queue = [president]\n    while !queue.empty?\n      current = queue.shift\n      channels.each do |channel|\n        if channel[0] == current\n          neighbor = channel[1]\n          duration = channel[2]\n          if min_durations[current] + duration < min_durations[neighbor]\n            min_durations[neighbor] = min_durations[current] + duration\n            queue.push(neighbor)\n          end\n        elsif channel[1] == current\n          neighbor = channel[0]\n          duration = channel[2]\n          if min_durations[current] + duration < min_durations[neighbor]\n            min_durations[neighbor] = min_durations[current] + duration\n            queue.push(neighbor)\n          end\n        end\n      end\n    end\n\n    # Sum up the durations for each president\n    durations[president] = min_durations.sum\n  end\n\n  # Return the durations as a string\n  durations.join(\" \")\nend","delphi":"program GalaxyUnion;\\n\\nvar\\n  n, i, j, k, a, b, t: integer;\\n  duration: array of integer;\\n  channels: array of array of integer;\\n\\nbegin\\n  readln(n);\\n  SetLength(duration, n);\\n  SetLength(channels, n, n);\\n\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to n-1 do\\n    begin\\n      channels[i, j] := -1;\\n    end;\\n  end;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    readln(a, b, t);\\n    channels[a-1, b-1] := t;\\n    channels[b-1, a-1] := t;\\n  end;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    duration[i] := 0;\\n    for j := 0 to n-1 do\\n    begin\\n      if (i <> j) and (channels[i, j] <> -1) then\\n      begin\\n        for k := 0 to n-1 do\\n        begin\\n          if (k <> i) and (k <> j) and (channels[i, k] <> -1) and (channels[k, j] <> -1) then\\n          begin\\n            if (duration[i] = 0) or (duration[i] > channels[i, k] + channels[k, j]) then\\n              duration[i] := channels[i, k] + channels[k, j];\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    write(duration[i], ' ');\\n  end;\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\tgraph := make([][]int, n+1)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\ta, _ := strconv.Atoi(scanner.Text()[0:1])\\n\\t\\tb, _ := strconv.Atoi(scanner.Text()[2:3])\\n\\t\\tt, _ := strconv.Atoi(scanner.Text()[4:])\\n\\n\\t\\tgraph[a] = append(graph[a], b)\\n\\t\\tgraph[b] = append(graph[b], a)\\n\\t}\\n\\n\\tresult := make([]int, n+1)\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tvisited := make([]bool, n+1)\\n\\t\\tvisited[i] = true\\n\\t\\tqueue := []int{i}\\n\\n\\t\\tfor len(queue) > 0 {\\n\\t\\t\\tplanet := queue[0]\\n\\t\\t\\tqueue = queue[1:]\\n\\n\\t\\t\\tfor _, neighbor := range graph[planet] {\\n\\t\\t\\t\\tif !visited[neighbor] {\\n\\t\\t\\t\\t\\tvisited[neighbor] = true\\n\\t\\t\\t\\t\\tqueue = append(queue, neighbor)\\n\\t\\t\\t\\t\\tresult[i] += result[planet] + t\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\toutput := \\\"\\\"\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\toutput += strconv.Itoa(result[i]) + \\\" \\\"\\n\\t}\\n\\n\\tfmt.Println(output)\\n}","Javascript":"function negotiatePlanets(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const channels = [];\n  for (let i = 1; i <= n; i++) {\n    const [a, b, t] = lines[i].split(' ').map(Number);\n    channels.push({ a, b, t });\n  }\n\n  const durations = Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    const visited = Array(n).fill(false);\n    visited[i] = true;\n    const queue = [{ planet: i, duration: 0 }];\n\n    while (queue.length > 0) {\n      const { planet, duration } = queue.shift();\n      durations[i] = Math.max(durations[i], duration);\n\n      for (const channel of channels) {\n        if (channel.a === planet && !visited[channel.b]) {\n          visited[channel.b] = true;\n          queue.push({ planet: channel.b, duration: duration + channel.t });\n        }\n        if (channel.b === planet && !visited[channel.a]) {\n          visited[channel.a] = true;\n          queue.push({ planet: channel.a, duration: duration + channel.t });\n        }\n      }\n    }\n  }\n\n  return durations.join(' ');\n}\n\nconst inputs = ['3\\\\n1 2 3\\\\n2 3 2\\\\n1 3 1\\\\n', '3\\\\n1 2 3\\\\n2 3 2\\\\n1 3 5\\\\n', '4\\\\n1 2 3\\\\n2 3 2\\\\n3 4 1\\\\n4 1 4\\\\n'];\nconst outputs = [];\n\nfor (const input of inputs) {\n  const output = negotiatePlanets(input);\n  outputs.push(output);\n}\n\nJSON.stringify([{ \\\"version\\\": \\\"JavaScript\\\", \\\"source code\\\": negotiatePlanets.toString() }, { \\\"outputs\\\": outputs }])","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.toInt()\n    val graph = Array(input + 1) { mutableListOf<Pair<Int, Int>>() }\n    val durations = IntArray(input + 1)\n    \n    for (i in 1..input) {\n        val (a, b, t) = readLine()!!.split(\" \").map { it.toInt() }\n        graph[a].add(Pair(b, t))\n        graph[b].add(Pair(a, t))\n    }\n    \n    for (i in 1..input) {\n        val queue: Queue<Pair<Int, Int>> = LinkedList()\n        val visited = BooleanArray(input + 1)\n        queue.add(Pair(i, 0))\n        visited[i] = true\n        \n        while (queue.isNotEmpty()) {\n            val (planet, duration) = queue.poll()\n            durations[i] = maxOf(durations[i], duration)\n            \n            for (neighbor in graph[planet]) {\n                if (!visited[neighbor.first]) {\n                    queue.add(Pair(neighbor.first, duration + neighbor.second))\n                    visited[neighbor.first] = true\n                }\n            }\n        }\n    }\n    \n    println(durations.drop(1).joinToString(\" \"))\n}","PHP":"<?php\\n\\nfunction negotiate($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $n = (int)$lines[0];\\n    $channels = [];\\n    $durations = [];\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $values = explode(\\\" \\\", $lines[$i]);\\n        $a = (int)$values[0];\\n        $b = (int)$values[1];\\n        $t = (int)$values[2];\\n\\n        if (!isset($channels[$a])) {\\n            $channels[$a] = [];\\n        }\\n        if (!isset($channels[$b])) {\\n            $channels[$b] = [];\\n        }\\n\\n        $channels[$a][$b] = $t;\\n        $channels[$b][$a] = $t;\\n\\n        if (!isset($durations[$a])) {\\n            $durations[$a] = 0;\\n        }\\n        if (!isset($durations[$b])) {\\n            $durations[$b] = 0;\\n        }\\n\\n        $durations[$a] += $t;\\n        $durations[$b] += $t;\\n    }\\n\\n    $result = \\\"\\\";\\n    foreach ($durations as $duration) {\\n        $result .= $duration . \\\" \\\";\\n    }\\n\\n    return trim($result);\\n}\\n\\n$input = \\\"3\\\\n1 2 3\\\\n2 3 2\\\\n1 3 1\\\\n\\\";\\necho negotiate($input);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.functional;\\r\\nimport std.range;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Planet\\r\\n{\\r\\n    int id;\\r\\n    int dialDuration;\\r\\n    Planet[] neighbors;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    Planet[] planets;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        int a, b, t;\\r\\n        readf(\\\"%d %d %d\\\", &a, &b, &t);\\r\\n\\r\\n        Planet planetA;\\r\\n        planetA.id = a;\\r\\n        planetA.dialDuration = t;\\r\\n\\r\\n        Planet planetB;\\r\\n        planetB.id = b;\\r\\n        planetB.dialDuration = t;\\r\\n\\r\\n        planetA.neighbors ~= planetB;\\r\\n        planetB.neighbors ~= planetA;\\r\\n\\r\\n        planets ~= planetA;\\r\\n        planets ~= planetB;\\r\\n    }\\r\\n\\r\\n    int[] negotiationDurations;\\r\\n\\r\\n    foreach (planet; planets)\\r\\n    {\\r\\n        int totalDuration = 0;\\r\\n\\r\\n        foreach (neighbor; planet.neighbors)\\r\\n        {\\r\\n            totalDuration += neighbor.dialDuration;\\r\\n        }\\r\\n\\r\\n        negotiationDurations ~= totalDuration;\\r\\n    }\\r\\n\\r\\n    writeln(negotiationDurations.join(\\\" \\\"));\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub negotiation_durations {\\n    my ($n, @channels) = @_;\\n    my @durations;\\n    my %graph;\\n    my %visited;\\n\\n    # Build the graph\\n    foreach my $channel (@channels) {\\n        my ($a, $b, $t) = split(' ', $channel);\\n        push @{$graph{$a}}, [$b, $t];\\n        push @{$graph{$b}}, [$a, $t];\\n    }\\n\\n    # Perform depth-first search to calculate durations\\n    foreach my $planet (1..$n) {\\n        %visited = ();\\n        $durations[$planet] = dfs($planet, 0);\\n    }\\n\\n    return join(' ', @durations);\\n}\\n\\nsub dfs {\\n    my ($planet, $duration) = @_;\\n    $visited{$planet} = 1;\\n\\n    foreach my $neighbor (@{$graph{$planet}}) {\\n        my ($neighbor_planet, $neighbor_duration) = @$neighbor;\\n        next if $visited{$neighbor_planet};\\n        $duration += $neighbor_duration;\\n        $duration = dfs($neighbor_planet, $duration);\\n        $duration -= $neighbor_duration;\\n    }\\n\\n    return $duration;\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, @channels) = split('\\\\n', $input);\\n\\n# Calculate negotiation durations\\nmy $output = negotiation_durations($n, @channels);\\n\\n# Print output\\nprint $output;\\n","Rust":"use std::collections::HashMap;\\n\\nfn main() {\\n    let input = \\\"3\\\\n1 2 3\\\\n2 3 2\\\\n1 3 1\\\\n\\\";\\n    let output = negotiate_planets(input);\\n    println!(\\\"{}\\\", output);\\n}\\n\\nfn negotiate_planets(input: &str) -> String {\\n    let lines: Vec<&str> = input.trim().split('\\\\n').collect();\\n    let n: usize = lines[0].parse().unwrap();\\n    let mut graph: HashMap<usize, Vec<(usize, usize)>> = HashMap::new();\\n\\n    for i in 1..=n {\\n        let nums: Vec<usize> = lines[i].split(' ').map(|x| x.parse().unwrap()).collect();\\n        let a = nums[0];\\n        let b = nums[1];\\n        let t = nums[2];\\n\\n        graph.entry(a).or_insert(Vec::new()).push((b, t));\\n        graph.entry(b).or_insert(Vec::new()).push((a, t));\\n    }\\n\\n    let mut durations: Vec<usize> = Vec::new();\\n\\n    for i in 1..=n {\\n        let mut visited: HashMap<usize, bool> = HashMap::new();\\n        let mut queue: Vec<(usize, usize)> = Vec::new();\\n        let mut total_duration = 0;\\n\\n        visited.insert(i, true);\\n        queue.push((i, 0));\\n\\n        while !queue.is_empty() {\\n            let (planet, duration) = queue.remove(0);\\n            total_duration += duration;\\n\\n            if let Some(neighbors) = graph.get(&planet) {\\n                for &(neighbor, dial_duration) in neighbors {\\n                    if !visited.contains_key(&neighbor) {\\n                        visited.insert(neighbor, true);\\n                        queue.push((neighbor, dial_duration));\\n                    }\\n                }\\n            }\\n        }\\n\\n        durations.push(total_duration);\\n    }\\n\\n    durations.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\\\" \\\")\\n}\\n"}
{"title":"A. Watermelon","description":"One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed w kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"The first (and the only) input line contains integer number w (1\u2264w\u2264100) \u2014 the weight of the watermelon bought by the boys.\n","output_spec":"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.\n","notes":"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant \u2014 two parts of 4 and 4 kilos).\n","sample_inputs":["8\n"],"sample_outputs":["YES\n"],"id":"4-A","difficulty":800,"tags":["brute+force","math"],"src_uid":"230a3c4d7090401e5fa3c6b9d994cdf2","C++":"#include <iostream>\\n\\nusing namespace std;\\n\\nint main() {\\n    int w;\\n    cin >> w;\\n    if(w % 2 == 0 && w > 2) {\\n        cout << \\\"YES\\\";\\n    }\\n    else {\\n        cout << \\\"NO\\\";\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Watermelon {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int w = scanner.nextInt();\\n        if (w % 2 == 0 && w > 2) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n}","Python":"def divide_watermelon(w):\\n    if w % 2 == 0 and w > 2:\\n        return 'YES'\\n    else:\\n        return 'NO'\\n\\nw = int(input())\\nprint(divide_watermelon(w))\\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int w;\\n    scanf(\\\"%d\\\", &w);\\n    if(w % 2 == 0 && w > 2) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\n\nnamespace WatermelonDivision\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int w = int.Parse(Console.ReadLine());\n\n            if (w % 2 == 0 && w > 2)\n            {\n                Console.WriteLine(\\\"YES\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"NO\\\");\n            }\n        }\n    }\n}","Ruby":"def divide_watermelon(w)\\n  if w % 2 == 0 && w > 2\\n    return 'YES'\\n  else\\n    return 'NO'\\n  end\\nend\\n\\nweight = gets.chomp.to_i\\nputs divide_watermelon(weight)","delphi":"program Watermelon;\\n\\nvar\\n  w: Integer;\\n\\nbegin\\n  \/\/ Read the weight of the watermelon\\n  ReadLn(w);\\n\\n  \/\/ Check if the weight is divisible by 2 and greater than 2\\n  if (w mod 2 = 0) and (w > 2) then\\n    WriteLn('YES')\\n  else\\n    WriteLn('NO');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar w int\\n\\tfmt.Scan(&w)\\n\\n\\tif w > 2 && w%2 == 0 {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function divideWatermelon(weight) {\n  if (weight % 2 === 0 && weight > 2) {\n    return 'YES';\n  } else {\n    return 'NO';\n  }\n}\n\nconsole.log(divideWatermelon(8));","Kotlin":"fun main() {\\n    val weight = readLine()!!.toInt()\\n    if (weight % 2 == 0 && weight > 2) {\\n        println(\\\"YES\\\")\\n    } else {\\n        println(\\\"NO\\\")\\n    }\\n}","PHP":"<?php\\n\\n$weight = intval(fgets(STDIN));\\n\\nif($weight % 2 == 0 && $weight > 2) {\\n    echo 'YES';\\n} else {\\n    echo 'NO';\\n}\\n\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int w;\\r\\n    readf(\\\"%d\\\", &w);\\r\\n\\r\\n    if (w % 2 == 0 && w > 2)\\r\\n    {\\r\\n        writeln(\\\"YES\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub divide_watermelon {\\n    my $weight = shift;\\n    \\n    if ($weight % 2 == 0 && $weight > 2) {\\n        return 'YES';\\n    }\\n    \\n    return 'NO';\\n}\\n\\nmy $input = <STDIN>;\\nchomp $input;\\n\\nmy $result = divide_watermelon($input);\\nprint $result . \\\"\\\\n\\\";","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let w: i32 = input.trim().parse().unwrap();\n    \n    if w % 2 == 0 && w > 2 {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"C. Happy Farm 5","description":"The Happy Farm 5 creators decided to invent the mechanism of cow grazing. The cows in the game are very slow and they move very slowly, it can even be considered that they stand still. However, carnivores should always be chased off them. For that a young player Vasya decided to make the shepherd run round the cows along one and the same closed path. It is very important that the cows stayed strictly inside the area limited by the path, as otherwise some cows will sooner or later be eaten. To be absolutely sure in the cows' safety, Vasya wants the path completion time to be minimum.The new game is launched for different devices, including mobile phones. That's why the developers decided to quit using the arithmetics with the floating decimal point and use only the arithmetics of integers. The cows and the shepherd in the game are represented as points on the plane with integer coordinates. The playing time is modeled by the turns. During every turn the shepherd can either stay where he stands or step in one of eight directions: horizontally, vertically, or diagonally. As the coordinates should always remain integer, then the length of a horizontal and vertical step is equal to 1, and the length of a diagonal step is equal to . The cows do not move. You have to minimize the number of moves the shepherd needs to run round the whole herd.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer N which represents the number of cows in the herd (1\u2264N\u226410^5). Each of the next N lines contains two integers Xi and Yi which represent the coordinates of one cow of (|Xi|,|Yi|\u226410^6). Several cows can stand on one point.\n","output_spec":"Print the single number \u2014 the minimum number of moves in the sought path.\n","notes":"Picture for the example test: The coordinate grid is painted grey, the coordinates axes are painted black, the cows are painted red and the sought route is painted green.\n \n","sample_inputs":["4\n1 1\n5 1\n5 3\n1 3\n"],"sample_outputs":["16\n"],"id":"50-C","difficulty":2000,"tags":["geometry"],"src_uid":"d2227a4ed6299626c2906962f91b066a","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int N;\\n    cin >> N;\\n    vector<pair<int, int>> cows(N);\\n    for (int i = 0; i < N; i++) {\\n        int x, y;\\n        cin >> x >> y;\\n        cows[i] = make_pair(x, y);\\n    }\\n    int minX = cows[0].first, maxX = cows[0].first;\\n    int minY = cows[0].second, maxY = cows[0].second;\\n    for (int i = 1; i < N; i++) {\\n        minX = min(minX, cows[i].first);\\n        maxX = max(maxX, cows[i].first);\\n        minY = min(minY, cows[i].second);\\n        maxY = max(maxY, cows[i].second);\\n    }\\n    int width = maxX - minX + 1;\\n    int height = maxY - minY + 1;\\n    int perimeter = 2 * (width + height);\\n    if (width == 1 || height == 1) {\\n        perimeter += 2;\\n    }\\n    cout << perimeter << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class CowGrazing {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] cows = new int[N][2];\n        \n        for (int i = 0; i < N; i++) {\n            cows[i][0] = scanner.nextInt();\n            cows[i][1] = scanner.nextInt();\n        }\n        \n        int minX = Integer.MAX_VALUE;\n        int maxX = Integer.MIN_VALUE;\n        int minY = Integer.MAX_VALUE;\n        int maxY = Integer.MIN_VALUE;\n        \n        for (int i = 0; i < N; i++) {\n            minX = Math.min(minX, cows[i][0]);\n            maxX = Math.max(maxX, cows[i][0]);\n            minY = Math.min(minY, cows[i][1]);\n            maxY = Math.max(maxY, cows[i][1]);\n        }\n        \n        int width = maxX - minX;\n        int height = maxY - minY;\n        \n        int perimeter = 2 * (width + height);\n        int diagonal = Math.min(width, height);\n        \n        int moves = perimeter + 2 * (diagonal - 1);\n        \n        System.out.println(moves);\n    }\n}","Python":"import math\\n\\n# Function to calculate the minimum number of moves\\n# to run round the whole herd\\n\\ndef calculate_minimum_moves(cows):\\n    # Initialize variables\\n    min_x = float('inf')\\n    max_x = float('-inf')\\n    min_y = float('inf')\\n    max_y = float('-inf')\\n\\n    # Find the minimum and maximum x and y coordinates\\n    for cow in cows:\\n        x, y = cow\\n        min_x = min(min_x, x)\\n        max_x = max(max_x, x)\\n        min_y = min(min_y, y)\\n        max_y = max(max_y, y)\\n\\n    # Calculate the perimeter of the rectangle enclosing the cows\\n    perimeter = 2 * (max_x - min_x + max_y - min_y)\\n\\n    # Calculate the number of diagonal moves\\n    diagonal_moves = min(max_x - min_x, max_y - min_y)\\n\\n    # Calculate the number of horizontal and vertical moves\\n    horizontal_vertical_moves = perimeter - 2 * diagonal_moves\\n\\n    # Calculate the total number of moves\\n    total_moves = diagonal_moves * int(math.sqrt(2)) + horizontal_vertical_moves\\n\\n    return total_moves\\n\\n\\n# Read input\\nn = int(input())\\ncows = []\\n\\nfor _ in range(n):\\n    x, y = map(int, input().split())\\n    cows.append((x, y))\\n\\n# Calculate the minimum number of moves\\nminimum_moves = calculate_minimum_moves(cows)\\n\\n# Print the result\\nprint(minimum_moves)\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int N;\\n    scanf(\\\"%d\\\", &N);\\n    int cows[N][2];\\n    for (int i = 0; i < N; i++) {\\n        scanf(\\\"%d %d\\\", &cows[i][0], &cows[i][1]);\\n    }\\n\\n    int min_x = cows[0][0];\\n    int max_x = cows[0][0];\\n    int min_y = cows[0][1];\\n    int max_y = cows[0][1];\\n\\n    for (int i = 1; i < N; i++) {\\n        if (cows[i][0] < min_x) {\\n            min_x = cows[i][0];\\n        }\\n        if (cows[i][0] > max_x) {\\n            max_x = cows[i][0];\\n        }\\n        if (cows[i][1] < min_y) {\\n            min_y = cows[i][1];\\n        }\\n        if (cows[i][1] > max_y) {\\n            max_y = cows[i][1];\\n        }\\n    }\\n\\n    int width = max_x - min_x;\\n    int height = max_y - min_y;\\n\\n    int perimeter = 2 * (width + height);\\n    int diagonal_moves = (width < height) ? width : height;\\n    int straight_moves = (width > height) ? width : height;\\n\\n    int total_moves = perimeter + (diagonal_moves * 2) + (straight_moves - diagonal_moves);\\n\\n    printf(\\\"%d\\\\n\\\", total_moves);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace HappyFarm\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int N = int.Parse(Console.ReadLine());\n            List<Point> cows = new List<Point>();\n\n            for (int i = 0; i < N; i++)\n            {\n                string[] coordinates = Console.ReadLine().Split();\n                int x = int.Parse(coordinates[0]);\n                int y = int.Parse(coordinates[1]);\n                cows.Add(new Point(x, y));\n            }\n\n            int minMoves = GetMinimumMoves(cows);\n            Console.WriteLine(minMoves);\n        }\n\n        static int GetMinimumMoves(List<Point> cows)\n        {\n            int minX = int.MaxValue;\n            int maxX = int.MinValue;\n            int minY = int.MaxValue;\n            int maxY = int.MinValue;\n\n            foreach (Point cow in cows)\n            {\n                minX = Math.Min(minX, cow.X);\n                maxX = Math.Max(maxX, cow.X);\n                minY = Math.Min(minY, cow.Y);\n                maxY = Math.Max(maxY, cow.Y);\n            }\n\n            int width = maxX - minX + 2;\n            int height = maxY - minY + 2;\n\n            int perimeter = 2 * (width + height) - 4;\n            return perimeter;\n        }\n    }\n\n    class Point\n    {\n        public int X { get; set; }\n        public int Y { get; set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n}","Ruby":"def minimum_moves(cows)\n  # Find the minimum and maximum x and y coordinates of the cows\n  min_x = cows.map { |cow| cow[0] }.min\n  max_x = cows.map { |cow| cow[0] }.max\n  min_y = cows.map { |cow| cow[1] }.min\n  max_y = cows.map { |cow| cow[1] }.max\n  \n  # Calculate the width and height of the area containing the cows\n  width = max_x - min_x\n  height = max_y - min_y\n  \n  # Calculate the perimeter of the area containing the cows\n  perimeter = 2 * (width + height)\n  \n  # If the width or height is 0, the minimum number of moves is equal to the perimeter\n  if width == 0 || height == 0\n    return perimeter\n  end\n  \n  # If the width and height are both odd, add 2 to the perimeter\n  if width % 2 == 1 && height % 2 == 1\n    perimeter += 2\n  end\n  \n  # Return the minimum number of moves\n  return perimeter\nend\n\n# Read the number of cows from input\nn = gets.to_i\n\n# Read the coordinates of the cows from input\ncows = []\nn.times do\n  x, y = gets.split.map(&:to_i)\n  cows << [x, y]\nend\n\n# Call the minimum_moves function and print the result\nputs minimum_moves(cows)\n","delphi":"var\\n  N, i, minX, minY, maxX, maxY, ans: integer;\\n  x, y: array[1..100000] of integer;\\nbegin\\n  readln(N);\\n  minX := 1000001;\\n  minY := 1000001;\\n  maxX := -1000001;\\n  maxY := -1000001;\\n  for i := 1 to N do\\n  begin\\n    readln(x[i], y[i]);\\n    if x[i] < minX then\\n      minX := x[i];\\n    if x[i] > maxX then\\n      maxX := x[i];\\n    if y[i] < minY then\\n      minY := y[i];\\n    if y[i] > maxY then\\n      maxY := y[i];\\n  end;\\n  ans := 2 * (maxX - minX + maxY - minY) + 4;\\n  writeln(ans);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar N int\\n\\tfmt.Scan(&N)\\n\\n\\tvar cows []point\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tvar x, y int\\n\\t\\tfmt.Scan(&x, &y)\\n\\t\\tcows = append(cows, point{x, y})\\n\\t}\\n\\n\\tminMoves := calculateMinMoves(cows)\\n\\tfmt.Println(minMoves)\\n}\\n\\nfunc calculateMinMoves(cows []point) int {\\n\\tminX, minY, maxX, maxY := math.MaxInt32, math.MaxInt32, math.MinInt32, math.MinInt32\\n\\n\\tfor _, cow := range cows {\\n\\t\\tif cow.x < minX {\\n\\t\\t\\tminX = cow.x\\n\\t\\t}\\n\\t\\tif cow.y < minY {\\n\\t\\t\\tminY = cow.y\\n\\t\\t}\\n\\t\\tif cow.x > maxX {\\n\\t\\t\\tmaxX = cow.x\\n\\t\\t}\\n\\t\\tif cow.y > maxY {\\n\\t\\t\\tmaxY = cow.y\\n\\t\\t}\\n\\t}\\n\\n\\tdx := maxX - minX\\n\\tdy := maxY - minY\\n\\n\\tif dx > dy {\\n\\t\\treturn dx*2 + (dx-dy)*2\\n\\t} else {\\n\\t\\treturn dy*2 + (dy-dx)*2\\n\\t}\\n}\\n\\ntype point struct {\\n\\tx, y int\\n}","Javascript":"const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet cows = [];\n\nrl.question('Enter the number of cows: ', (n) => {\n  console.log(`Enter the coordinates of each cow:`);\n  \n  rl.on('line', (line) => {\n    let [x, y] = line.split(' ').map(Number);\n    cows.push([x, y]);\n    \n    if (cows.length === Number(n)) {\n      rl.close();\n      console.log(`Minimum number of moves: ${getMinimumMoves(cows)}`);\n    }\n  });\n});\n\nfunction getMinimumMoves(cows) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  \n  for (let [x, y] of cows) {\n    minX = Math.min(minX, x);\n    maxX = Math.max(maxX, x);\n    minY = Math.min(minY, y);\n    maxY = Math.max(maxY, y);\n  }\n  \n  let width = maxX - minX;\n  let height = maxY - minY;\n  \n  let diagonalMoves = Math.min(width, height);\n  let straightMoves = Math.max(width, height) - diagonalMoves;\n  \n  return diagonalMoves * 2 + straightMoves * 2;\n}","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val n = readLine()!!.toInt()\\n    val cows = mutableListOf<Pair<Int, Int>>()\\n\\n    repeat(n) {\\n        val (x, y) = readLine()!!.split(' ').map { it.toInt() }\\n        cows.add(Pair(x, y))\\n    }\\n\\n    var minX = Int.MAX_VALUE\\n    var maxX = Int.MIN_VALUE\\n    var minY = Int.MAX_VALUE\\n    var maxY = Int.MIN_VALUE\\n\\n    for (cow in cows) {\\n        minX = minOf(minX, cow.first)\\n        maxX = maxOf(maxX, cow.first)\\n        minY = minOf(minY, cow.second)\\n        maxY = maxOf(maxY, cow.second)\\n    }\\n\\n    val width = maxX - minX + 2\\n    val height = maxY - minY + 2\\n\\n    val perimeter = 2 * (width + height) - 4\\n\\n    println(perimeter)\\n}","PHP":"<?php\\n\\n\/\/ Read input from stdin\\n$input = file_get_contents('php:\/\/stdin');\\n\\n\/\/ Split input into lines\\n$lines = explode(\\\"\\\\n\\\", $input);\\n\\n\/\/ Get the number of cows\\n$N = intval($lines[0]);\\n\\n\/\/ Initialize variables\\n$minX = PHP_INT_MAX;\\n$maxX = PHP_INT_MIN;\\n$minY = PHP_INT_MAX;\\n$maxY = PHP_INT_MIN;\\n\\n\/\/ Loop through the cows to find the minimum and maximum coordinates\\nfor ($i = 1; $i <= $N; $i++) {\\n    $coords = explode(\\\" \\\", $lines[$i]);\\n    $x = intval($coords[0]);\\n    $y = intval($coords[1]);\\n    $minX = min($minX, $x);\\n    $maxX = max($maxX, $x);\\n    $minY = min($minY, $y);\\n    $maxY = max($maxY, $y);\\n}\\n\\n\/\/ Calculate the minimum number of moves\\n$width = $maxX - $minX;\\n$height = $maxY - $minY;\\n$diagonalMoves = min($width, $height);\\n$horizontalMoves = max($width, $height) - $diagonalMoves;\\n$totalMoves = $diagonalMoves * 2 + $horizontalMoves * 2;\\n\\n\/\/ Print the result\\necho $totalMoves;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\nimport std.math;\\r\\n\\r\\nstruct Point\\r\\n{\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int N;\\r\\n    readf(\\\"%d\\\", &N);\\r\\n\\r\\n    Point[] cows;\\r\\n    for (int i = 0; i < N; i++)\\r\\n    {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        cows ~= Point(x, y);\\r\\n    }\\r\\n\\r\\n    int minX = cows.min!((a, b) => a.x < b.x).x;\\r\\n    int maxX = cows.max!((a, b) => a.x < b.x).x;\\r\\n    int minY = cows.min!((a, b) => a.y < b.y).y;\\r\\n    int maxY = cows.max!((a, b) => a.y < b.y).y;\\r\\n\\r\\n    int pathLength = 2 * (maxX - minX + maxY - minY) + 4;\\r\\n\\r\\n    writeln(pathLength);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub min_moves {\\n    my ($n, @cows) = @_;\\n    my $min_x = 1e6;\\n    my $max_x = -1e6;\\n    my $min_y = 1e6;\\n    my $max_y = -1e6;\\n\\n    foreach my $cow (@cows) {\\n        my ($x, $y) = split(' ', $cow);\\n        $min_x = $x if $x < $min_x;\\n        $max_x = $x if $x > $max_x;\\n        $min_y = $y if $y < $min_y;\\n        $max_y = $y if $y > $max_y;\\n    }\\n\\n    my $width = $max_x - $min_x;\\n    my $height = $max_y - $min_y;\\n\\n    my $diagonal_moves = min($width, $height);\\n    my $straight_moves = max($width, $height) - $diagonal_moves;\\n\\n    return $diagonal_moves * 2 + $straight_moves * 2;\\n}\\n\\nsub max {\\n    my ($a, $b) = @_;\\n    return $a > $b ? $a : $b;\\n}\\n\\nsub min {\\n    my ($a, $b) = @_;\\n    return $a < $b ? $a : $b;\\n}\\n\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, @cows) = split('\\\\n', $input);\\nmy $result = min_moves($n, @cows);\\nprint $result;\\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let n: usize = lines[0].parse().unwrap();\n    \n    let mut cows: Vec<(i32, i32)> = Vec::new();\n    for i in 1..=n {\n        let coordinates: Vec<i32> = lines[i].split(' ').map(|x| x.parse().unwrap()).collect();\n        cows.push((coordinates[0], coordinates[1]));\n    }\n    \n    let mut min_x = std::i32::MAX;\n    let mut max_x = std::i32::MIN;\n    let mut min_y = std::i32::MAX;\n    let mut max_y = std::i32::MIN;\n    \n    for cow in &cows {\n        min_x = min_x.min(cow.0);\n        max_x = max_x.max(cow.0);\n        min_y = min_y.min(cow.1);\n        max_y = max_y.max(cow.1);\n    }\n    \n    let width = max_x - min_x;\n    let height = max_y - min_y;\n    \n    let mut perimeter = 2 * (width + height);\n    \n    if width > 0 && height > 0 {\n        perimeter += 4;\n    }\n    \n    println!(\"{}\", perimeter);\n}"}
{"title":"E. Square Equation Roots","description":"A schoolboy Petya studies square equations. The equations that are included in the school curriculum, usually look simple: x^2+2bx+c=0 where b, c are natural numbers.Petya noticed that some equations have two real roots, some of them have only one root and some equations don't have real roots at all. Moreover it turned out that several different square equations can have a common root.Petya is interested in how many different real roots have all the equations of the type described above for all the possible pairs of numbers b and c such that 1\u2264b\u2264n, 1\u2264c\u2264m. Help Petya find that number.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The single line contains two integers n and m. (1\u2264n,m\u22645000000).\n","output_spec":"Print a single number which is the number of real roots of the described set of equations.\n","notes":"In the second test from the statement the following equations are analysed:\n b=1, c=1: x^2+2x+1=0; The root is x=-1\n b=1, c=2: x^2+2x+2=0; No roots\n Overall there's one root\nIn the second test the following equations are analysed:\n b=1, c=1: x^2+2x+1=0; The root is x=-1\n b=1, c=2: x^2+2x+2=0; No roots\n b=1, c=3: x^2+2x+3=0; No roots\n b=2, c=1: x^2+4x+1=0; The roots are \n b=2, c=2: x^2+4x+2=0; The roots are \n b=2, c=3: x^2+4x+3=0; The roots are x1=-3,x2=-1\n b=3, c=1: x^2+6x+1=0; The roots are \n b=3, c=2: x^2+6x+2=0; The roots are \n b=3, c=3: x^2+6x+3=0; The roots are  Overall there are 13 roots and as the root -1 is repeated twice, that means there are 12 different roots.\n","sample_inputs":["3 3\n","1 2\n"],"sample_outputs":["12\n","1\n"],"id":"50-E","difficulty":2300,"tags":["math"],"src_uid":"aad7ebf4fa919fae78bfc878e47e483c","C++":"\n#include <iostream>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    unordered_set<double> roots;\n    \n    for (int b = 1; b <= n; b++) {\n        for (int c = 1; c <= m; c++) {\n            double discriminant = 4 * b * b - 4 * c;\n            \n            if (discriminant > 0) {\n                double root1 = (-2 * b + sqrt(discriminant)) \/ 2;\n                double root2 = (-2 * b - sqrt(discriminant)) \/ 2;\n                \n                roots.insert(root1);\n                roots.insert(root2);\n            } else if (discriminant == 0) {\n                double root = -2 * b \/ 2;\n                roots.insert(root);\n            }\n        }\n    }\n    \n    cout << roots.size() << endl;\n    \n    return 0;\n}\n","Java":"import java.util.Scanner;\\n\\npublic class SquareEquations {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n\\n        int count = 0;\\n\\n        for (int b = 1; b <= n; b++) {\\n            for (int c = 1; c <= m; c++) {\\n                int discriminant = 4 * b * b - 4 * c;\\n\\n                if (discriminant > 0) {\\n                    count += 2;\\n                } else if (discriminant == 0) {\\n                    count += 1;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}\"}}","Python":"def count_real_roots(n, m):\\n    count = 0\\n    for b in range(1, n+1):\\n        for c in range(1, m+1):\\n            discriminant = 4*b*b - 4*c\\n            if discriminant > 0:\\n                count += 2\\n            elif discriminant == 0:\\n                count += 1\\n    return count\\n\\ninput_data = input().split()\\nn = int(input_data[0])\\nm = int(input_data[1])\\n\\nresult = count_real_roots(n, m)\\nprint(result)","C":"#include <stdio.h>\\n#include <math.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int count = 0;\\n\\n    for (int b = 1; b <= n; b++) {\\n        for (int c = 1; c <= m; c++) {\\n            int discriminant = 4 * b * b - 4 * c;\\n\\n            if (discriminant > 0) {\\n                count += 2;\\n            } else if (discriminant == 0) {\\n                count += 1;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace SquareEquations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            int count = 0;\n\n            for (int b = 1; b <= n; b++)\n            {\n                for (int c = 1; c <= m; c++)\n                {\n                    double discriminant = 4 * b * b - 4 * c;\n\n                    if (discriminant > 0)\n                    {\n                        count += 2;\n                    }\n                    else if (discriminant == 0)\n                    {\n                        count++;\n                    }\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n    }\n}","Ruby":"\ndef count_real_roots(n, m)\n  count = 0\n  roots = []\n\n  (1..n).each do |b|\n    (1..m).each do |c|\n      discriminant = 4 * b * b - 4 * c\n\n      if discriminant > 0\n        root1 = (-2 * b + Math.sqrt(discriminant)) \/ 2\n        root2 = (-2 * b - Math.sqrt(discriminant)) \/ 2\n\n        roots << root1 unless roots.include?(root1)\n        roots << root2 unless roots.include?(root2)\n      elsif discriminant == 0\n        root = -2 * b \/ 2\n\n        roots << root unless roots.include?(root)\n      end\n    end\n  end\n\n  count = roots.length\n  return count\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\n\noutput = count_real_roots(n, m)\nputs output\n","delphi":"program SquareEquations;\n\nvar\n  n, m, b, c, roots: Integer;\n\nbegin\n  \/\/ Read input values\n  ReadLn(n, m);\n  \n  \/\/ Initialize roots count\n  roots := 0;\n  \n  \/\/ Loop through all possible values of b and c\n  for b := 1 to n do\n  begin\n    for c := 1 to m do\n    begin\n      \/\/ Calculate discriminant\n      if (b * b - 4 * c) >= 0 then\n        Inc(roots);\n    end;\n  end;\n  \n  \/\/ Print the number of roots\n  WriteLn(roots);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tcount := 0\\n\\n\\tfor b := 1; b <= n; b++ {\\n\\t\\tfor c := 1; c <= m; c++ {\\n\\t\\t\\tdiscriminant := float64(4*b*b - 4*c)\\n\\t\\t\\tif discriminant >= 0 {\\n\\t\\t\\t\\trootCount := 0\\n\\t\\t\\t\\tif discriminant == 0 {\\n\\t\\t\\t\\t\\trootCount = 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trootCount = 2\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcount += rootCount\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function countRealRoots(n, m) {\n    let count = 0;\n    \n    for (let b = 1; b <= n; b++) {\n        for (let c = 1; c <= m; c++) {\n            let discriminant = 4 * b * b - 4 * c;\n            \n            if (discriminant > 0) {\n                count += 2;\n            } else if (discriminant === 0) {\n                count += 1;\n            }\n        }\n    }\n    \n    return count.toString();\n}\n\nconst input = '3 3';\nconst [n, m] = input.split(' ').map(Number);\n\nconst output = countRealRoots(n, m);\nconsole.log(output);","Kotlin":"import kotlin.math.sqrt\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val m = input[1]\\n\\n    var count = 0\\n\\n    for (b in 1..n) {\\n        for (c in 1..m) {\\n            val discriminant = b * b - 4 * c\\n            if (discriminant > 0) {\\n                count += 2\\n \/\/ Two real roots\\n            } else if (discriminant == 0) {\\n                count += 1\\n \/\/ One real root\\n            }\\n        }\\n    }\\n\\n    println(count)\\n}","PHP":"\n<?php\n\nfunction countRealRoots($n, $m) {\n    $count = 0;\n    \n    for ($b = 1; $b <= $n; $b++) {\n        for ($c = 1; $c <= $m; $c++) {\n            $discriminant = 4 * $b * $b - 4 * $c;\n            \n            if ($discriminant > 0) {\n                $count += 2;\n            } elseif ($discriminant == 0) {\n                $count += 1;\n            }\n        }\n    }\n    \n    return $count;\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$n = intval($input[0]);\n$m = intval($input[1]);\n\n$result = countRealRoots($n, $m);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint countRealRoots(int n, int m)\\r\\n{\\r\\n    int count = 0;\\r\\n    for (int b = 1; b <= n; b++)\\r\\n    {\\r\\n        for (int c = 1; c <= m; c++)\\r\\n        {\\r\\n            int discriminant = b * b - 4 * c;\\r\\n            if (discriminant > 0)\\r\\n            {\\r\\n                count += 2;\\r\\n            }\\r\\n            else if (discriminant == 0)\\r\\n            {\\r\\n                count += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n    int result = countRealRoots(n, m);\\r\\n    writeln(result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_real_roots {\n    my ($n, $m) = @_;\n\n    my $count = 0;\n\n    for my $b (1..$n) {\n        for my $c (1..$m) {\n            my $discriminant = 4 * $b * $b - 4 * $c;\n\n            if ($discriminant > 0) {\n                $count += 2;\n            } elsif ($discriminant == 0) {\n                $count += 1;\n            }\n        }\n    }\n\n    return $count;\n}\n\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\nmy $result = count_real_roots($n, $m);\nprint $result;\n","Rust":"\nuse std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n\n    let mut lines = input.lines();\n    let params: Vec<u32> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = params[0];\n    let m = params[1];\n\n    let mut count = 0;\n\n    for b in 1..=n {\n        for c in 1..=m {\n            let discriminant = (2 * b as i32).pow(2) - 4 * c as i32;\n            if discriminant > 0 {\n                count += 2;\n            } else if discriminant == 0 {\n                count += 1;\n            }\n        }\n    }\n\n    println!(\"{}\", count);\n}\n"}
{"title":"D. Geometrical problem","description":"Polycarp loves geometric progressions \u2014 he collects them. However, as such progressions occur very rarely, he also loves the sequences of numbers where it is enough to delete a single element to get a geometric progression.In this task we shall define geometric progressions as finite sequences of numbers a1,a2,...,ak, where ai=c\u00b7b^i-1 for some real numbers c and b. For example, the sequences [2, -4, 8], [0, 0, 0, 0], [199] are geometric progressions and [0, 1, 2, 3] is not.Recently Polycarp has found a sequence and he can't classify it. Help him to do it. Determine whether it is a geometric progression. If it is not, check if it can become a geometric progression if an element is deleted from it.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (1\u2264n\u226410^5) \u2014 the number of elements in the given sequence. The second line contains the given sequence. The numbers are space-separated. All the elements of the given sequence are integers and their absolute value does not exceed 10^4.\n","output_spec":"Print 0, if the given sequence is a geometric progression. Otherwise, check if it is possible to make the sequence a geometric progression by deleting a single element. If it is possible, print 1. If it is impossible, print 2.\n","notes":null,"sample_inputs":["4\n3 6 12 24\n","4\n-8 -16 24 -32\n","4\n0 1 2 3\n"],"sample_outputs":["0\n","1\n","2\n"],"id":"51-D","difficulty":2200,"tags":["implementation"],"src_uid":"a32db37cb2ebe8945a4c2f32fa2d7fc8","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nbool isGeometric(vector<int>& seq) {\\n    int n = seq.size();\\n    if (n <= 2) return true;\\n    int ratio = seq[1] \/ seq[0];\\n    for (int i = 2; i < n; i++) {\\n        if (seq[i] \/ seq[i-1] != ratio) return false;\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> seq(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> seq[i];\\n    }\\n    if (isGeometric(seq)) {\\n        cout << 0 << endl;\\n    } else {\\n        for (int i = 0; i < n; i++) {\\n            vector<int> temp = seq;\\n            temp.erase(temp.begin() + i);\\n            if (isGeometric(temp)) {\\n                cout << 1 << endl;\\n                return 0;\\n            }\\n        }\\n        cout << 2 << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class GeometricProgression {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] sequence = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            sequence[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        if (isGeometricProgression(sequence)) {\\n            System.out.println(0);\\n        } else if (isPossibleGeometricProgression(sequence)) {\\n            System.out.println(1);\\n        } else {\\n            System.out.println(2);\\n        }\\n    }\\n\\n    public static boolean isGeometricProgression(int[] sequence) {\\n        if (sequence.length < 2) {\\n            return true;\\n        }\\n\\n        int ratio = sequence[1] \/ sequence[0];\\n        for (int i = 2; i < sequence.length; i++) {\\n            if (sequence[i] != sequence[i - 1] * ratio) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public static boolean isPossibleGeometricProgression(int[] sequence) {\\n        for (int i = 0; i < sequence.length; i++) {\\n            int[] subSequence = new int[sequence.length - 1];\\n            int index = 0;\\n            for (int j = 0; j < sequence.length; j++) {\\n                if (j != i) {\\n                    subSequence[index++] = sequence[j];\\n                }\\n            }\\n\\n            if (isGeometricProgression(subSequence)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\"}}","Python":"def check_geometric_progression(n, sequence):\n    if n == 1:\n        return '0'\n    \n    ratios = set()\n    for i in range(1, n):\n        if sequence[i] != 0:\n            ratios.add(sequence[i] \/ sequence[i-1])\n    \n    if len(ratios) == 1:\n        return '0'\n    \n    for i in range(n):\n        temp = sequence[:i] + sequence[i+1:]\n        temp_ratios = set()\n        for j in range(1, n-1):\n            if temp[j] != 0:\n                temp_ratios.add(temp[j] \/ temp[j-1])\n        if len(temp_ratios) == 1:\n            return '1'\n    \n    return '2'\n\n# Example usage\nn = 4\nsequence = [3, 6, 12, 24]\nprint(check_geometric_progression(n, sequence))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int sequence[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &sequence[i]);\\n    }\\n\\n    int ratio = sequence[1] \/ sequence[0];\\n    int deletedIndex = -1;\\n    int possible = 1;\\n\\n    for (int i = 2; i < n; i++) {\\n        if (sequence[i] \/ sequence[i-1] != ratio) {\\n            if (deletedIndex != -1) {\\n                possible = 0;\\n                break;\\n            }\\n            if (sequence[i] \/ sequence[i-2] == ratio) {\\n                deletedIndex = i-1;\\n            } else if (sequence[i-1] \/ sequence[i-2] == ratio) {\\n                deletedIndex = i;\\n            } else {\\n                possible = 0;\\n                break;\\n            }\\n        }\\n    }\\n\\n    if (possible) {\\n        if (deletedIndex == -1) {\\n            printf(\\\"0\\\\n\\\");\\n        } else {\\n            printf(\\\"1\\\\n\\\");\\n        }\\n    } else {\\n        printf(\\\"2\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] sequence = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        \n        if (IsGeometricProgression(sequence))\n        {\n            Console.WriteLine(0);\n        }\n        else if (CanBecomeGeometricProgression(sequence))\n        {\n            Console.WriteLine(1);\n        }\n        else\n        {\n            Console.WriteLine(2);\n        }\n    }\n    \n    public static bool IsGeometricProgression(int[] sequence)\n    {\n        if (sequence.Length < 2)\n        {\n            return true;\n        }\n        \n        int ratio = sequence[1] \/ sequence[0];\n        \n        for (int i = 2; i < sequence.Length; i++)\n        {\n            if (sequence[i] != sequence[i - 1] * ratio)\n            {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public static bool CanBecomeGeometricProgression(int[] sequence)\n    {\n        for (int i = 0; i < sequence.Length; i++)\n        {\n            int[] subSequence = sequence.Where((value, index) => index != i).ToArray();\n            \n            if (IsGeometricProgression(subSequence))\n            {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}","Ruby":"def geometric_progression(n, sequence)\\n  # Convert the sequence to an array of integers\\n  sequence = sequence.split.map(&:to_i)\\n\\n  # Check if the sequence is already a geometric progression\\n  if sequence.each_cons(2).all? { |a, b| b % a == 0 }\\n    return '0'\\n  end\\n\\n  # Check if the sequence can become a geometric progression by deleting a single element\\n  sequence.each_with_index do |num, index|\\n    temp_sequence = sequence.dup\\n    temp_sequence.delete_at(index)\\n\\n    if temp_sequence.each_cons(2).all? { |a, b| b % a == 0 }\\n      return '1'\\n    end\\n  end\\n\\n  # If neither condition is met, return '2'\\n  return '2'\\nend\\n\\n# Read the input\\ninput = gets.chomp.split('\\n')\\nn = input[0].to_i\\nsequence = input[1]\\n\\n# Call the function and print the result\\nputs geometric_progression(n, sequence)","delphi":"program GeometricProgression;\n\nvar\n  n, i, j, count: integer;\n  sequence: array of integer;\n  ratio: real;\n  isGeometric: boolean;\n\nbegin\n  \/\/ Read the number of elements in the sequence\n  readln(n);\n  \n  \/\/ Read the sequence\n  SetLength(sequence, n);\n  for i := 0 to n-1 do\n    read(sequence[i]);\n  \n  \/\/ Check if the sequence is a geometric progression\n  isGeometric := true;\n  ratio := sequence[1] \/ sequence[0];\n  for i := 2 to n-1 do\n  begin\n    if sequence[i] \/ sequence[i-1] <> ratio then\n    begin\n      isGeometric := false;\n      break;\n    end;\n  end;\n  \n  \/\/ If the sequence is a geometric progression, print 0\n  if isGeometric then\n  begin\n    writeln(0);\n    exit;\n  end;\n  \n  \/\/ Check if the sequence can become a geometric progression by deleting a single element\n  for i := 0 to n-1 do\n  begin\n    \/\/ Remove the i-th element from the sequence\n    count := 0;\n    for j := 0 to n-1 do\n    begin\n      if j <> i then\n      begin\n        sequence[count] := sequence[j];\n        Inc(count);\n      end;\n    end;\n    \n    \/\/ Check if the modified sequence is a geometric progression\n    isGeometric := true;\n    ratio := sequence[1] \/ sequence[0];\n    for j := 2 to n-2 do\n    begin\n      if sequence[j] \/ sequence[j-1] <> ratio then\n      begin\n        isGeometric := false;\n        break;\n      end;\n    end;\n    \n    \/\/ If the modified sequence is a geometric progression, print 1 and exit\n    if isGeometric then\n    begin\n      writeln(1);\n      exit;\n    end;\n  end;\n  \n  \/\/ If it is impossible to make the sequence a geometric progression by deleting a single element, print 2\n  writeln(2);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tinput := scanner.Text()\\n\\tnumbers := strings.Split(input, \\\" \\\")\\n\\n\\t\/\/ Convert string numbers to integers\\n\\tsequence := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tsequence[i], _ = strconv.Atoi(numbers[i])\\n\\t}\\n\\n\\t\/\/ Check if the sequence is a geometric progression\\n\\tisGeometric := true\\n\\tfor i := 2; i < n; i++ {\\n\\t\\tif sequence[i] != sequence[i-1]*sequence[i-2] {\\n\\t\\t\\tisGeometric = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ If the sequence is a geometric progression, print 0\\n\\tif isGeometric {\\n\\t\\tfmt.Println(0)\\n\\t} else {\\n\\t\\t\/\/ Check if it is possible to make the sequence a geometric progression by deleting a single element\\n\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\ttemp := make([]int, n-1)\\n\\t\\t\\tcopy(temp, sequence[:i])\\n\\t\\t\\tcopy(temp[i:], sequence[i+1:])\\n\\n\\t\\t\\tisGeometric := true\\n\\t\\t\\tfor j := 2; j < n-1; j++ {\\n\\t\\t\\t\\tif temp[j] != temp[j-1]*temp[j-2] {\\n\\t\\t\\t\\t\\tisGeometric = false\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif isGeometric {\\n\\t\\t\\t\\tfmt.Println(1)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\/\/ If it is impossible to make the sequence a geometric progression by deleting a single element, print 2\\n\\t\\tfmt.Println(2)\\n\\t}\\n}","Javascript":"function classifySequence(n, sequence) {\n    let arr = sequence.split(' ').map(Number);\n    \n    \/\/ Check if the sequence is already a geometric progression\n    let ratio = arr[1] \/ arr[0];\n    let isGeometric = true;\n    for (let i = 2; i < n; i++) {\n        if (arr[i] \/ arr[i-1] !== ratio) {\n            isGeometric = false;\n            break;\n        }\n    }\n    \n    if (isGeometric) {\n        return '0';\n    }\n    \n    \/\/ Check if the sequence can become a geometric progression by deleting a single element\n    for (let i = 0; i < n; i++) {\n        let tempArr = arr.slice(0, i).concat(arr.slice(i+1));\n        let tempRatio = tempArr[1] \/ tempArr[0];\n        let isPossible = true;\n        for (let j = 2; j < n-1; j++) {\n            if (tempArr[j] \/ tempArr[j-1] !== tempRatio) {\n                isPossible = false;\n                break;\n            }\n        }\n        if (isPossible) {\n            return '1';\n        }\n    }\n    \n    return '2';\n}\n\n\/\/ Read input\nlet input = readline().split('\\n');\nlet n = parseInt(input[0]);\nlet sequence = input[1];\n\n\/\/ Call the function and print the result\nlet result = classifySequence(n, sequence);\nprint(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val sequence = IntArray(n)\n    for (i in 0 until n) {\n        sequence[i] = sc.nextInt()\n    }\n    \n    if (isGeometricProgression(sequence)) {\n        println(0)\n    } else if (isPossibleGeometricProgression(sequence)) {\n        println(1)\n    } else {\n        println(2)\n    }\n}\n\nfun isGeometricProgression(sequence: IntArray): Boolean {\n    if (sequence.size < 2) {\n        return true\n    }\n    \n    val ratio = sequence[1] \/ sequence[0]\n    for (i in 2 until sequence.size) {\n        if (sequence[i] != sequence[i - 1] * ratio) {\n            return false\n        }\n    }\n    \n    return true\n}\n\nfun isPossibleGeometricProgression(sequence: IntArray): Boolean {\n    for (i in 0 until sequence.size) {\n        val modifiedSequence = sequence.copyOf()\n        modifiedSequence[i] = 0\n        \n        if (isGeometricProgression(modifiedSequence)) {\n            return true\n        }\n    }\n    \n    return false\n}","PHP":"<?php\\n\\nfunction isGeometricProgression($n, $sequence) {\\n    \/\/ Convert the sequence to an array of integers\\n    $sequence = explode(' ', $sequence);\\n    $sequence = array_map('intval', $sequence);\\n    \\n    \/\/ Check if the sequence is already a geometric progression\\n    if (isGeometric($sequence)) {\\n        return 0;\\n    }\\n    \\n    \/\/ Try deleting each element and check if the resulting sequence is a geometric progression\\n    for ($i = 0; $i < $n; $i++) {\\n        $temp = $sequence;\\n        unset($temp[$i]);\\n        $temp = array_values($temp);\\n        \\n        if (isGeometric($temp)) {\\n            return 1;\\n        }\\n    }\\n    \\n    \/\/ If no element can be deleted to form a geometric progression, return 2\\n    return 2;\\n}\\n\\nfunction isGeometric($sequence) {\\n    $n = count($sequence);\\n    \\n    if ($n <= 2) {\\n        return true;\\n    }\\n    \\n    $ratio = $sequence[1] \/ $sequence[0];\\n    \\n    for ($i = 2; $i < $n; $i++) {\\n        if ($sequence[$i] \/ $sequence[$i-1] != $ratio) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\n\\n\/\/ Read input\\n$input = file_get_contents('php:\/\/stdin');\\n$input = explode(\\\"\\\\n\\\", $input);\\n$n = intval($input[0]);\\n$sequence = $input[1];\\n\\n\/\/ Call the function and print the result\\n$result = isGeometricProgression($n, $sequence);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] sequence;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    sequence = readln.split.map!(a => a.to!int).array;\\r\\n\\r\\n    \/\/ Check if sequence is a geometric progression\\r\\n    bool isGeometric = true;\\r\\n    double ratio = sequence[1] \/ sequence[0];\\r\\n    foreach (i, num; sequence[2..$])\\r\\n    {\\r\\n        if (num \/ sequence[i] != ratio)\\r\\n        {\\r\\n            isGeometric = false;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print output\\r\\n    if (isGeometric)\\r\\n    {\\r\\n        writeln(\\\"0\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        \/\/ Check if sequence can become a geometric progression by deleting a single element\\r\\n        bool canBecomeGeometric = false;\\r\\n        foreach (i, num; sequence)\\r\\n        {\\r\\n            int[] temp = sequence.dup;\\r\\n            temp.remove(i);\\r\\n\\r\\n            if (temp.length < 2)\\r\\n            {\\r\\n                canBecomeGeometric = true;\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            double tempRatio = temp[1] \/ temp[0];\\r\\n            bool isTempGeometric = true;\\r\\n\\r\\n            foreach (j, tempNum; temp[2..$])\\r\\n            {\\r\\n                if (tempNum \/ temp[j] != tempRatio)\\r\\n                {\\r\\n                    isTempGeometric = false;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (isTempGeometric)\\r\\n            {\\r\\n                canBecomeGeometric = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (canBecomeGeometric)\\r\\n        {\\r\\n            writeln(\\\"1\\\");\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            writeln(\\\"2\\\");\\r\\n        }\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub is_geometric_progression {\n    my ($n, @sequence) = @_;\n    \n    # Check if the sequence is already a geometric progression\n    my $common_ratio = $sequence[1] \/ $sequence[0];\n    my $is_geometric = 1;\n    for my $i (2..$n-1) {\n        if ($sequence[$i] \/ $sequence[$i-1] != $common_ratio) {\n            $is_geometric = 0;\n            last;\n        }\n    }\n    \n    if ($is_geometric) {\n        return 0;\n    }\n    \n    # Check if the sequence can become a geometric progression by deleting a single element\n    for my $i (0..$n-1) {\n        my @new_sequence = (@sequence[0..$i-1], @sequence[$i+1..$n-1]);\n        my $new_common_ratio = $new_sequence[1] \/ $new_sequence[0];\n        my $is_new_geometric = 1;\n        for my $j (2..$n-2) {\n            if ($new_sequence[$j] \/ $new_sequence[$j-1] != $new_common_ratio) {\n                $is_new_geometric = 0;\n                last;\n            }\n        }\n        if ($is_new_geometric) {\n            return 1;\n        }\n    }\n    \n    return 2;\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy $sequence = <>;\nchomp $sequence;\nmy @sequence = split ' ', $sequence;\n\n# Check if the sequence is a geometric progression or can become one by deleting a single element\nmy $result = is_geometric_progression($n, @sequence);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: usize = input.trim().parse().unwrap();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let sequence: Vec<i32> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    \n    let mut ratio: Option<i32> = None;\n    let mut deleted_index: Option<usize> = None;\n    \n    for i in 1..n {\n        let current_ratio = sequence[i] \/ sequence[i - 1];\n        \n        if ratio.is_none() {\n            ratio = Some(current_ratio);\n        } else if ratio.unwrap() != current_ratio {\n            if deleted_index.is_none() {\n                if i == 1 {\n                    ratio = Some(sequence[i + 1] \/ sequence[i]);\n                    deleted_index = Some(0);\n                } else {\n                    ratio = Some(sequence[i] \/ sequence[i - 2]);\n                    deleted_index = Some(i - 1);\n                }\n            } else {\n                println!(\"2\");\n                return;\n            }\n        }\n    }\n    \n    if deleted_index.is_some() {\n        println!(\"1\");\n    } else {\n        println!(\"0\");\n    }\n}"}
{"title":"F. Caterpillar","description":"An undirected graph is called a caterpillar if it is a connected graph without cycles and it has such a path p that any vertex is located at a distance of at most 1 from the path p. The caterpillar can contain loops (edges from a vertex to itself) but cannot contain multiple (parallel) edges.The picture contains an example of a caterpillar:  You are given an undirected graph G. You are allowed to do a merging operations, each such operation merges two vertices into one vertex. For that two any vertices a and b (a\u2260b) are chosen. These verteces are deleted together with their edges (which are incident to at least one of the vertices a or b) but a new vertex w is added together with edges (x,w) for each edge (a,w) and\/or (b,w). If there was the edge (a,b) it transforms to the loop (w,w). The resulting graph (after the merging operation) may contain multiple (parallel) edges between pairs of vertices and loops. Let us note that this operation decreases the number of vertices of graph by 1 but leaves the number of edges in the graph unchanged.The merging operation can be informally described as a unity of two vertices of the graph into one with the natural transformation of the graph edges.You may apply this operation consecutively and make the given graph to be a caterpillar. Write a program that will print the minimal number of merging operations required to make the given graph a caterpillar.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a pair of integers n, m (1\u2264n\u22642000;0\u2264m\u226410^5), where n represents the number of vertices in the graph and m is the number of edges in it. Then the following m lines contain edge descriptions, one edge description per line. Every line contains a pair of integers ai,bi (1\u2264ai,bi\u2264n;ai\u2260bi), ai,bi which represent the indices of the vertices connected by the edge. The vertices are numbered from 1 to n. In the given graph it will be no more than one edge between any pair of vertices. The given graph is not necessarily connected.\n","output_spec":"Print the minimal required number of operations.\n","notes":null,"sample_inputs":["4 4\n1 2\n2 3\n3 4\n4 2\n","6 3\n1 2\n3 4\n5 6\n","7 6\n1 2\n2 3\n1 4\n4 5\n1 6\n6 7\n"],"sample_outputs":["2\n","2\n","1\n"],"id":"51-F","difficulty":2800,"tags":["dfs+and+similar","dp","graphs","trees"],"src_uid":"8241a66c8be5229ed71bf30dd8eecbc1","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nvector<vector<int>> adj;\\nvector<bool> visited;\\n\\nint bfs(int start) {\\n    queue<int> q;\\n    q.push(start);\\n    visited[start] = true;\\n    int maxDist = 0;\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n\\n        for (int v : adj[u]) {\\n            if (!visited[v]) {\\n                visited[v] = true;\\n                q.push(v);\\n                maxDist = max(maxDist, v);\\n            }\\n        }\\n    }\\n\\n    return maxDist;\\n}\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    adj.resize(n + 1);\\n    visited.resize(n + 1, false);\\n\\n    for (int i = 0; i < m; i++) {\\n        int a, b;\\n        cin >> a >> b;\\n        adj[a].push_back(b);\\n        adj[b].push_back(a);\\n    }\\n\\n    int components = 0;\\n    int operations = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        if (!visited[i]) {\\n            int maxDist = bfs(i);\\n            int end = bfs(maxDist);\\n            operations += (end - maxDist);\\n            components++;\\n        }\\n    }\\n\\n    operations += (components - 1);\\n\\n    cout << operations << endl;\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.Scanner;\\n\\npublic class CaterpillarGraph {\\n\\n    static ArrayList<Integer>[] adj;\\n    static boolean[] visited;\\n    static int[] dist;\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        int n = sc.nextInt();\\n        int m = sc.nextInt();\\n\\n        adj = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n        dist = new int[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int a = sc.nextInt();\\n            int b = sc.nextInt();\\n            adj[a].add(b);\\n            adj[b].add(a);\\n        }\\n\\n        int minOperations = findMinOperations(n);\\n        System.out.println(minOperations);\\n    }\\n\\n    public static int findMinOperations(int n) {\\n        int minOperations = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (!visited[i]) {\\n                int[] result = bfs(i);\\n                int farthestVertex = result[0];\\n                int maxDistance = result[1];\\n\\n                result = bfs(farthestVertex);\\n                maxDistance = Math.max(maxDistance, result[1]);\\n\\n                minOperations += maxDistance - 1;\\n            }\\n        }\\n\\n        return minOperations;\\n    }\\n\\n    public static int[] bfs(int start) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n        visited[start] = true;\\n        dist[start] = 0;\\n\\n        int farthestVertex = start;\\n        int maxDistance = 0;\\n\\n        while (!queue.isEmpty()) {\\n            int vertex = queue.poll();\\n\\n            for (int neighbor : adj[vertex]) {\\n                if (!visited[neighbor]) {\\n                    queue.add(neighbor);\\n                    visited[neighbor] = true;\\n                    dist[neighbor] = dist[vertex] + 1;\\n\\n                    if (dist[neighbor] > maxDistance) {\\n                        maxDistance = dist[neighbor];\\n                        farthestVertex = neighbor;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new int[]{farthestVertex, maxDistance};\\n    }\\n}\"}\n","Python":"from collections import defaultdict\\n\\ndef dfs(v, parent, visited, adj_list):\\n    visited[v] = True\\n    for u in adj_list[v]:\\n        if not visited[u]:\\n            dfs(u, v, visited, adj_list)\\n\\n\\ndef merge_vertices(v, parent, adj_list):\\n    for u in adj_list[v]:\\n        if u != parent[v]:\\n            merge_vertices(u, parent, adj_list)\\n            parent[u] = v\\n            adj_list[v].extend(adj_list[u])\\n            adj_list[u] = []\\n\\n\\ndef caterpillar_operations(n, m, edges):\\n    adj_list = defaultdict(list)\\n    for u, v in edges:\\n        adj_list[u].append(v)\\n        adj_list[v].append(u)\\n    visited = [False] * (n + 1)\\n    parent = [0] * (n + 1)\\n    components = 0\\n    for v in range(1, n + 1):\\n        if not visited[v]:\\n            dfs(v, parent, visited, adj_list)\\n            components += 1\\n    operations = components - 1\\n    for v in range(1, n + 1):\\n        if not visited[v]:\\n            merge_vertices(v, parent, adj_list)\\n            operations += 1\\n    return str(operations)\\n\\n\\n# Sample Inputs\\ninputs = ['4 4\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 2\\\\n', '6 3\\\\n1 2\\\\n3 4\\\\n5 6\\\\n', '7 6\\\\n1 2\\\\n2 3\\\\n1 4\\\\n4 5\\\\n1 6\\\\n6 7\\\\n']\\n\\noutputs = []\\nfor input_str in inputs:\\n    input_lines = input_str.strip().split('\\\\n')\\n    n, m = map(int, input_lines[0].split())\\n    edges = [tuple(map(int, line.split())) for line in input_lines[1:]]\\n    outputs.append(caterpillar_operations(n, m, edges))\\n\\n# Sample Outputs\\noutputs\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXN 2005\\n\\nint n, m;\\nint deg[MAXN];\\nint vis[MAXN];\\nint cat[MAXN];\\n\\nint main() {\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    for (int i = 0; i < m; i++) {\\n        int u, v;\\n        scanf(\\\"%d %d\\\", &u, &v);\\n        deg[u]++;\\n        deg[v]++;\\n    }\\n\\n    int ans = 0;\\n    for (int i = 1; i <= n; i++) {\\n        if (!vis[i]) {\\n            int cnt = 0;\\n            int leaf = 0;\\n            int loop = 0;\\n            vis[i] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                if (!vis[j] && deg[j] == 1) {\\n                    cnt++;\\n                    leaf = j;\\n                    vis[j] = 1;\\n                }\\n            }\\n            if (cnt == 0) {\\n                ans++;\\n            } else if (cnt == 1) {\\n                while (deg[leaf] == 1) {\\n                    int nxt = -1;\\n                    for (int j = 1; j <= n; j++) {\\n                        if (!vis[j] && deg[j] == 1) {\\n                            nxt = j;\\n                            break;\\n                        }\\n                    }\\n                    if (nxt == -1) break;\\n                    vis[nxt] = 1;\\n                    deg[leaf]--;\\n                    deg[nxt]--;\\n                    deg[i]++;\\n                    leaf = nxt;\\n                    ans++;\\n                }\\n                ans++;\\n            } else {\\n                while (cnt > 1) {\\n                    int nxt = -1;\\n                    for (int j = 1; j <= n; j++) {\\n                        if (!vis[j] && deg[j] == 1) {\\n                            nxt = j;\\n                            break;\\n                        }\\n                    }\\n                    if (nxt == -1) break;\\n                    vis[nxt] = 1;\\n                    deg[leaf]--;\\n                    deg[nxt]--;\\n                    deg[i]++;\\n                    leaf = nxt;\\n                    cnt--;\\n                    ans++;\\n                }\\n                ans++;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", ans);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace CaterpillarGraph\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = new string[]\n            {\n                \\\"4 4\\n1 2\\n2 3\\n3 4\\n4 2\\n\\\",\n                \\\"6 3\\n1 2\\n3 4\\n5 6\\n\\\",\n                \\\"7 6\\n1 2\\n2 3\\n1 4\\n4 5\\n1 6\\n6 7\\n\\\"\n            };\n\n            foreach (string input in inputs)\n            {\n                int operations = GetMinimalOperations(input);\n                Console.WriteLine(operations);\n            }\n        }\n\n        static int GetMinimalOperations(string input)\n        {\n            string[] lines = input.Split('\\n');\n            string[] nm = lines[0].Split(' ');\n            int n = int.Parse(nm[0]);\n            int m = int.Parse(nm[1]);\n\n            List<int>[] graph = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n\n            for (int i = 1; i <= m; i++)\n            {\n                string[] edge = lines[i].Split(' ');\n                int a = int.Parse(edge[0]);\n                int b = int.Parse(edge[1]);\n\n                graph[a].Add(b);\n                graph[b].Add(a);\n            }\n\n            int[] visited = new int[n + 1];\n            int[] distance = new int[n + 1];\n\n            int maxDistance = 0;\n            int maxDistanceVertex = 0;\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (visited[i] == 0)\n                {\n                    DFS(i, graph, visited, distance, ref maxDistance, ref maxDistanceVertex);\n                }\n            }\n\n            visited = new int[n + 1];\n            distance = new int[n + 1];\n\n            DFS(maxDistanceVertex, graph, visited, distance, ref maxDistance, ref maxDistanceVertex);\n\n            return maxDistance;\n        }\n\n        static void DFS(int vertex, List<int>[] graph, int[] visited, int[] distance, ref int maxDistance, ref int maxDistanceVertex)\n        {\n            visited[vertex] = 1;\n\n            foreach (int neighbor in graph[vertex])\n            {\n                if (visited[neighbor] == 0)\n                {\n                    distance[neighbor] = distance[vertex] + 1;\n\n                    if (distance[neighbor] > maxDistance)\n                    {\n                        maxDistance = distance[neighbor];\n                        maxDistanceVertex = neighbor;\n                    }\n\n                    DFS(neighbor, graph, visited, distance, ref maxDistance, ref maxDistanceVertex);\n                }\n            }\n        }\n    }\n}","Ruby":"def caterpillar_operations(input)\n  # Parse input\n  n, m, *edges = input.split(\"\\n\")\n  n = n.to_i\n  m = m.to_i\n  edges = edges.map { |edge| edge.split.map(&:to_i) }\n\n  # Create adjacency list\n  adjacency_list = Array.new(n + 1) { [] }\n  edges.each do |a, b|\n    adjacency_list[a] << b\n    adjacency_list[b] << a\n  end\n\n  # Initialize visited array\n  visited = Array.new(n + 1, false)\n\n  # Function to perform DFS\n  def dfs(node, adjacency_list, visited)\n    visited[node] = true\n    count = 0\n    leaf = true\n\n    adjacency_list[node].each do |neighbor|\n      next if visited[neighbor]\n\n      leaf = false\n      count += dfs(neighbor, adjacency_list, visited)\n    end\n\n    count += 1 if leaf\n    count\n  end\n\n  # Perform DFS on each connected component\n  components = 0\n  operations = 0\n\n  (1..n).each do |node|\n    next if visited[node]\n\n    components += 1\n    count = dfs(node, adjacency_list, visited)\n    operations += count - 1\n  end\n\n  # Calculate minimal required number of operations\n  minimal_operations = components - 1 + operations\n\n  minimal_operations.to_s\nend\n\ninputs = ['4 4\\n1 2\\n2 3\\n3 4\\n4 2\\n', '6 3\\n1 2\\n3 4\\n5 6\\n', '7 6\\n1 2\\n2 3\\n1 4\\n4 5\\n1 6\\n6 7\\n']\noutputs = []\n\ninputs.each do |input|\n  output = caterpillar_operations(input)\n  outputs << output\nend\n\noutputs.to_json\n","delphi":"Here is a possible implementation in Delphi 7:\n\n```delphi\nprogram Caterpillar;\n\nconst\n  MAXN = 2000;\n  MAXM = 100000;\n\ntype\n  TEdge = record\n    u, v: Integer;\n  end;\n\nvar\n  n, m: Integer;\n  edges: array[1..MAXM] of TEdge;\n  adj: array[1..MAXN] of array of Integer;\n  visited: array[1..MAXN] of Boolean;\n  parent: array[1..MAXN] of Integer;\n  depth: array[1..MAXN] of Integer;\n  isCaterpillar: Boolean;\n  operations: Integer;\n\nprocedure ReadInput;\nvar\n  i: Integer;\nbegin\n  ReadLn(n, m);\n  for i := 1 to m do\n    ReadLn(edges[i].u, edges[i].v);\nend;\n\nprocedure AddEdge(u, v: Integer);\nbegin\n  SetLength(adj[u], Length(adj[u]) + 1);\n  adj[u, Length(adj[u])] := v;\n  SetLength(adj[v], Length(adj[v]) + 1);\n  adj[v, Length(adj[v])] := u;\nend;\n\nprocedure DFS(u, p, d: Integer);\nvar\n  i, v: Integer;\nbegin\n  visited[u] := True;\n  parent[u] := p;\n  depth[u] := d;\n  for i := 0 to Length(adj[u]) - 1 do\n  begin\n    v := adj[u, i];\n    if not visited[v] then\n      DFS(v, u, d + 1)\n    else if (v <> p) and (depth[u] - depth[v] > 1) then\n      isCaterpillar := False;\n  end;\nend;\n\nprocedure MergeVertices(u, v: Integer);\nvar\n  i: Integer;\nbegin\n  for i := 0 to Length(adj[u]) - 1 do\n    if adj[u, i] = v then\n    begin\n      adj[u, i] := n + 1;\n      Break;\n    end;\n  for i := 0 to Length(adj[v]) - 1 do\n    if adj[v, i] = u then\n    begin\n      adj[v, i] := n + 1;\n      Break;\n    end;\n  AddEdge(u, n + 1);\n  AddEdge(v, n + 1);\nend;\n\nprocedure FindCaterpillar;\nvar\n  i, u, v: Integer;\nbegin\n  isCaterpillar := True;\n  for i := 1 to n do\n    if not visited[i] then\n      DFS(i, 0, 0);\n  for i := 1 to m do\n  begin\n    u := edges[i].u;\n    v := edges[i].v;\n    if (parent[u] <> v) and (parent[v] <> u) then\n      MergeVertices(u, v);\n  end;\nend;\n\nprocedure CountOperations;\nvar\n  i: Integer;\nbegin\n  operations := 0;\n  for i := 1 to n do\n    if Length(adj[i]) > 1 then\n      Inc(operations, Length(adj[i]) - 1);\nend;\n\nprocedure PrintOutput;\nbegin\n  WriteLn(operations);\nend;\n\nbegin\n  ReadInput;\n  FindCaterpillar;\n  CountOperations;\n  PrintOutput;\nend.\n```\n\nThis code reads the input, builds the adjacency list representation of the graph, performs a depth-first search to check if the graph is a caterpillar, merges vertices if necessary, and counts the number of merging operations required. Finally, it prints the output","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nm[0])\\n\\tm, _ := strconv.Atoi(nm[1])\\n\\n\\tadjList := make([][]int, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tab := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\ta, _ := strconv.Atoi(ab[0])\\n\\t\\tb, _ := strconv.Atoi(ab[1])\\n\\n\\t\\tadjList[a] = append(adjList[a], b)\\n\\t\\tadjList[b] = append(adjList[b], a)\\n\\t}\\n\\n\\tvisited := make([]bool, n+1)\\n\\tresult := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tif !visited[i] {\\n\\t\\t\\tleafCount, edgeCount := dfs(i, adjList, visited)\\n\\t\\t\\tresult += edgeCount - leafCount + 1\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(result)\\n}\\n\\nfunc dfs(node int, adjList [][]int, visited []bool) (int, int) {\\n\\tvisited[node] = true\\n\\tleafCount := 0\\n\\tedgeCount := len(adjList[node])\\n\\n\\tfor _, neighbor := range adjList[node] {\\n\\t\\tif !visited[neighbor] {\\n\\t\\t\\tl, e := dfs(neighbor, adjList, visited)\\n\\t\\t\\tleafCount += l\\n\\t\\t\\tedgeCount += e\\n\\t\\t}\\n\\t}\\n\\n\\tif edgeCount == 1 {\\n\\t\\tleafCount = 1\\n\\t}\\n\\n\\treturn leafCount, edgeCount\\n}","Javascript":"function mergeToCaterpillar(n, m, edges) {\n    \/\/ Create an adjacency list to represent the graph\n    const adjList = new Array(n + 1).fill(null).map(() => []);\n    for (let i = 0; i < m; i++) {\n        const [a, b] = edges[i];\n        adjList[a].push(b);\n        adjList[b].push(a);\n    }\n    \n    \/\/ Function to perform DFS and find the longest path\n    function dfs(node, parent, depth) {\n        let maxDepth = depth;\n        for (const neighbor of adjList[node]) {\n            if (neighbor !== parent) {\n                maxDepth = Math.max(maxDepth, dfs(neighbor, node, depth + 1));\n            }\n        }\n        return maxDepth;\n    }\n    \n    let operations = 0;\n    \n    \/\/ Iterate through each vertex and check if it is part of a caterpillar\n    for (let i = 1; i <= n; i++) {\n        if (adjList[i].length === 1) {\n            const neighbor = adjList[i][0];\n            const depth = dfs(neighbor, i, 1);\n            \n            \/\/ If the depth is less than or equal to 2, it is already part of a caterpillar\n            if (depth > 2) {\n                operations += depth - 2;\n            }\n        }\n    }\n    \n    return operations.toString();\n}\n\n\/\/ Sample inputs\nconst inputs = [\n    { n: 4, m: 4, edges: [[1, 2], [2, 3], [3, 4], [4, 2]] },\n    { n: 6, m: 3, edges: [[1, 2], [3, 4], [5, 6]] },\n    { n: 7, m: 6, edges: [[1, 2], [2, 3], [1, 4], [4, 5], [1, 6], [6, 7]] }\n];\n\nconst outputs = [];\n\n\/\/ Process each input\nfor (const input of inputs) {\n    const { n, m, edges } = input;\n    const result = mergeToCaterpillar(n, m, edges);\n    outputs.push(result);\n}\n\n\/\/ Return the outputs in JSON format\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    \n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    val visited = BooleanArray(n + 1)\n    \n    repeat(m) {\n        val edge = readLine()!!.split(\" \")\n        val a = edge[0].toInt()\n        val b = edge[1].toInt()\n        \n        graph[a].add(b)\n        graph[b].add(a)\n    }\n    \n    var operations = 0\n    \n    for (i in 1..n) {\n        if (!visited[i]) {\n            val queue: Queue<Int> = LinkedList()\n            val distances = IntArray(n + 1)\n            \n            queue.add(i)\n            visited[i] = true\n            \n            while (queue.isNotEmpty()) {\n                val vertex = queue.poll()\n                \n                for (neighbor in graph[vertex]) {\n                    if (!visited[neighbor]) {\n                        queue.add(neighbor)\n                        visited[neighbor] = true\n                        distances[neighbor] = distances[vertex] + 1\n                    }\n                }\n            }\n            \n            val maxDistance = distances.maxOrNull() ?: 0\n            operations += maxDistance\n            \n            for (j in 1..n) {\n                if (distances[j] == maxDistance) {\n                    visited[j] = false\n                }\n            }\n        }\n    }\n    \n    println(operations)\n}","PHP":"<?php\\n\\nfunction mergeVertices($n, $m, $edges) {\\n    $adjList = array_fill(1, $n, []);\\n    $visited = array_fill(1, $n, false);\\n    $dist = array_fill(1, $n, 0);\\n    $maxDist = 0;\\n    $leafCount = 0;\\n    $loopCount = 0;\\n\\n    foreach ($edges as $edge) {\\n        $u = $edge[0];\\n        $v = $edge[1];\\n        $adjList[$u][] = $v;\\n        $adjList[$v][] = $u;\\n    }\\n\\n    function dfs($node, $parent) {\\n        global $adjList, $visited, $dist, $maxDist, $leafCount, $loopCount;\\n        $visited[$node] = true;\\n\\n        foreach ($adjList[$node] as $neighbor) {\\n            if ($neighbor == $parent) {\\n                continue;\\n            }\\n\\n            if ($visited[$neighbor]) {\\n                $loopCount++;\\n                continue;\\n            }\\n\\n            $dist[$neighbor] = $dist[$node] + 1;\\n            $maxDist = max($maxDist, $dist[$neighbor]);\\n            dfs($neighbor, $node);\\n        }\\n\\n        if (count($adjList[$node]) == 1) {\\n            $leafCount++;\\n        }\\n    }\\n\\n    $components = 0;\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        if (!$visited[$i]) {\\n            $maxDist = 0;\\n            $leafCount = 0;\\n            $loopCount = 0;\\n            dfs($i, -1);\\n\\n            if ($maxDist <= 2 && $leafCount > 0) {\\n                $components++;\\n            }\\n        }\\n    }\\n\\n    return $n - $components;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", trim($argv[1]));\\nlist($n, $m) = explode(\\\" \\\", $input[0]);\\n$edges = [];\\n\\nfor ($i = 1; $i <= $m; $i++) {\\n    list($a, $b) = explode(\\\" \\\", $input[$i]);\\n    $edges[] = [$a, $b];\\n}\\n\\n$result = mergeVertices($n, $m, $edges);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.container;\\r\\nimport std.functional;\\r\\nimport std.math;\\r\\nimport std.numeric;\\r\\nimport std.range;\\r\\nimport std.string;\\r\\n\\r\\nstruct Edge {\\r\\n    int u;\\r\\n    int v;\\r\\n}\\r\\n\\r\\nint find(int[] parent, int i) {\\r\\n    if (parent[i] == i)\\r\\n        return i;\\r\\n    return parent[i] = find(parent, parent[i]);\\r\\n}\\r\\n\\r\\nvoid merge(int[] parent, int[] rank, int x, int y) {\\r\\n    int xroot = find(parent, x);\\r\\n    int yroot = find(parent, y);\\r\\n\\r\\n    if (rank[xroot] < rank[yroot])\\r\\n        parent[xroot] = yroot;\\r\\n    else if (rank[xroot] > rank[yroot])\\r\\n        parent[yroot] = xroot;\\r\\n    else {\\r\\n        parent[yroot] = xroot;\\r\\n        rank[xroot]++;\\r\\n    }\\r\\n}\\r\\n\\r\\nint minimalMergingOperations(int n, Edge[] edges) {\\r\\n    int[] parent = new int[n + 1];\\r\\n    int[] rank = new int[n + 1];\\r\\n    int[] degree = new int[n + 1];\\r\\n\\r\\n    foreach (i; 1..n + 1) {\\r\\n        parent[i] = i;\\r\\n        rank[i] = 0;\\r\\n        degree[i] = 0;\\r\\n    }\\r\\n\\r\\n    foreach (edge; edges) {\\r\\n        degree[edge.u]++;\\r\\n        degree[edge.v]++;\\r\\n        merge(parent, rank, edge.u, edge.v);\\r\\n    }\\r\\n\\r\\n    int components = 0;\\r\\n    int loops = 0;\\r\\n\\r\\n    foreach (i; 1..n + 1) {\\r\\n        if (parent[i] == i)\\r\\n            components++;\\r\\n\\r\\n        if (degree[i] > 2)\\r\\n            loops += degree[i] - 2;\\r\\n    }\\r\\n\\r\\n    return components - 1 + loops;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\\n\\\", &n, &m);\\r\\n\\r\\n    Edge[] edges;\\r\\n\\r\\n    foreach (i; 0..m) {\\r\\n        int u, v;\\r\\n        readf(\\\"%d %d\\\\n\\\", &u, &v);\\r\\n        edges ~= Edge(u, v);\\r\\n    }\\r\\n\\r\\n    int result = minimalMergingOperations(n, edges);\\r\\n    writeln(result);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_caterpillar {\\n    my ($n, $m, @edges) = @_;\\n    my %graph;\\n    my %visited;\\n    my $operations = 0;\\n\\n    # Build the graph\\n    foreach my $edge (@edges) {\\n        my ($a, $b) = split(' ', $edge);\\n        push @{$graph{$a}}, $b;\\n        push @{$graph{$b}}, $a;\\n    }\\n\\n    # Perform DFS to find the caterpillar\\n    foreach my $vertex (keys %graph) {\\n        next if $visited{$vertex};\\n        my $result = dfs($vertex, \\%graph, \\%visited);\\n        $operations += $result->{operations};\\n    }\\n\\n    return $operations;\\n}\\n\\nsub dfs {\\n    my ($vertex, $graph, $visited) = @_;\\n    my $result = { operations => 0, leaves => 0 };\\n    $visited->{$vertex} = 1;\\n\\n    foreach my $neighbor (@{$graph->{$vertex}}) {\\n        next if $visited->{$neighbor};\\n        my $neighbor_result = dfs($neighbor, $graph, $visited);\\n        $result->{operations} += $neighbor_result->{operations};\\n        $result->{leaves} += $neighbor_result->{leaves};\\n    }\\n\\n    if ($result->{leaves} >= 2) {\\n        $result->{operations}++;\\n        $result->{leaves} = 0;\\n    }\\n\\n    $result->{leaves}++;\\n\\n    return $result;\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $m) = split(' ', $input);\\nmy @edges;\\nfor (my $i = 0; $i < $m; $i++) {\\n    my $edge = <STDIN>;\\n    chomp $edge;\\n    push @edges, $edge;\\n}\\n\\n# Find the minimal number of operations\\nmy $operations = find_caterpillar($n, $m, @edges);\\n\\n# Print the result\\nprint $operations . \\\"\\\\n\\\";\\n","Rust":"use std::collections::{HashMap, HashSet};\n\nfn main() {\n    let input = \"4 4\\n1 2\\n2 3\\n3 4\\n4 2\\n\";\n    let output = minimal_merging_operations(input);\n    println!(\"{}\", output);\n}\n\nfn minimal_merging_operations(input: &str) -> String {\n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let nm: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n\n    let mut graph: HashMap<usize, HashSet<usize>> = HashMap::new();\n    let mut visited: HashSet<usize> = HashSet::new();\n    let mut operations = 0;\n\n    for i in 1..=m {\n        let edge: Vec<usize> = lines[i].split(' ').map(|x| x.parse().unwrap()).collect();\n        let a = edge[0];\n        let b = edge[1];\n\n        graph.entry(a).or_insert(HashSet::new()).insert(b);\n        graph.entry(b).or_insert(HashSet::new()).insert(a);\n    }\n\n    for i in 1..=n {\n        if !visited.contains(&i) {\n            let mut path: Vec<usize> = Vec::new();\n            let mut queue: Vec<usize> = Vec::new();\n            queue.push(i);\n\n            while !queue.is_empty() {\n                let node = queue.pop().unwrap();\n                visited.insert(node);\n                path.push(node);\n\n                if let Some(neighbors) = graph.get(&node) {\n                    for neighbor in neighbors {\n                        if !visited.contains(neighbor) {\n                            queue.push(*neighbor);\n                        }\n                    }\n                }\n            }\n\n            let mut is_caterpillar = true;\n\n            for node in &path {\n                if let Some(neighbors) = graph.get(node) {\n                    if neighbors.len() > 2 {\n                        is_caterpillar = false;\n                        break;\n                    }\n                }\n            }\n\n            if is_caterpillar {\n                operations += path.len() - 1;\n            } else {\n                operations += path.len() - 2;\n            }\n        }\n    }\n\n    operations.to_string()\n}"}
{"title":"E. Dead Ends","description":"Life in Bertown has become hard. The city has too many roads and the government spends too much to maintain them. There are n junctions and m two way roads, at which one can get from each junction to any other one. The mayor wants to close some roads so that the number of roads left totaled to n-1 roads and it were still possible to get from each junction to any other one. Besides, the mayor is concerned with the number of dead ends which are the junctions from which only one road goes. There shouldn't be too many or too few junctions. Having discussed the problem, the mayor and his assistants decided that after the roads are closed, the road map should contain exactly k dead ends. Your task is to count the number of different ways of closing the roads at which the following conditions are met:   There are exactly n-1 roads left.  It is possible to get from each junction to any other one.  There are exactly k dead ends on the resulting map. Two ways are considered different if there is a road that is closed in the first way, and is open in the second one.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three integers n, m and k (3\u2264n\u226410,n-1\u2264m\u2264n\u00b7(n-1)\/2,2\u2264k\u2264n-1) which represent the number of junctions, roads and dead ends correspondingly. Then follow m lines each containing two different integers v1 and v2 (1\u2264v1,v2\u2264n,v1\u2260v2) which represent the number of junctions connected by another road. There can be no more than one road between every pair of junctions. The junctions are numbered with integers from 1 to n. It is guaranteed that it is possible to get from each junction to any other one along the original roads.\n","output_spec":"Print a single number \u2014 the required number of ways.\n","notes":null,"sample_inputs":["3 3 2\n1 2\n2 3\n1 3\n","4 6 2\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n","4 6 3\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n"],"sample_outputs":["3\n","12\n","4\n"],"id":"53-E","difficulty":2500,"tags":["bitmasks","dp"],"src_uid":"8087605a8f316150372cc4627f26231d","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nvector<vector<int>> adj;\\nvector<bool> visited;\\nint n, m, k;\\nint ans = 0;\\n\\nvoid dfs(int v, int dead_ends)\\n{\\n    visited[v] = true;\\n    int cnt = 0;\\n    for (int u : adj[v])\\n    {\\n        if (!visited[u])\\n        {\\n            dfs(u, dead_ends);\\n            cnt++;\\n        }\\n    }\\n    if (cnt == 0 && dead_ends == k)\\n    {\\n        ans++;\\n    }\\n    else if (cnt == 1 && dead_ends + 1 == k)\\n    {\\n        ans++;\\n    }\\n}\\n\\nint main()\\n{\\n    cin >> n >> m >> k;\\n    adj.resize(n + 1);\\n    visited.resize(n + 1, false);\\n\\n    for (int i = 0; i < m; i++)\\n    {\\n        int v1, v2;\\n        cin >> v1 >> v2;\\n        adj[v1].push_back(v2);\\n        adj[v2].push_back(v1);\\n    }\\n\\n    for (int i = 1; i <= n; i++)\\n    {\\n        if (!visited[i])\\n        {\\n            dfs(i, 0);\\n        }\\n    }\\n\\n    cout << ans << endl;\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class RoadClosure {\\n\\n    static int n, m, k;\\n    static List<Integer>[] adj;\\n    static boolean[] visited;\\n    static int deadEnds;\\n    static int ways;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        k = scanner.nextInt();\\n\\n        adj = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int v1 = scanner.nextInt();\\n            int v2 = scanner.nextInt();\\n            adj[v1].add(v2);\\n            adj[v2].add(v1);\\n        }\\n\\n        ways = 0;\\n        deadEnds = 0;\\n        dfs(1);\\n\\n        System.out.println(ways);\\n    }\\n\\n    static void dfs(int node) {\\n        visited[node] = true;\\n\\n        if (adj[node].size() == 1) {\\n            deadEnds++;\\n        }\\n\\n        if (deadEnds > k) {\\n            return;\\n        }\\n\\n        if (node != 1 && adj[node].size() == 1 && deadEnds == k) {\\n            ways++;\\n        }\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                dfs(neighbor);\\n            }\\n        }\\n\\n        visited[node] = false;\\n        if (adj[node].size() == 1) {\\n            deadEnds--;\\n        }\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class RoadClosure {\\n\\n    static int n, m, k;\\n    static List<Integer>[] adj;\\n    static boolean[] visited;\\n    static int deadEnds;\\n    static int ways;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        k = scanner.nextInt();\\n\\n        adj = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            adj[i] = new ArrayList<Integer>();\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int v1 = scanner.nextInt();\\n            int v2 = scanner.nextInt();\\n            adj[v1].add(v2);\\n            adj[v2].add(v1);\\n        }\\n\\n        ways = 0;\\n        deadEnds = 0;\\n        dfs(1);\\n\\n        System.out.println(ways);\\n    }\\n\\n    static void dfs(int node) {\\n        visited[node] = true;\\n\\n        if (adj[node].size() == 1) {\\n            deadEnds++;\\n        }\\n\\n        if (deadEnds > k) {\\n            return;\\n        }\\n\\n        if (node != 1 && adj[node].size() == 1 && deadEnds == k) {\\n            ways++;\\n        }\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                dfs(neighbor);\\n            }\\n        }\\n\\n        visited[node] = false;\\n        if (adj[node].size() == 1) {\\n            deadEnds--;\\n        }\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class RoadClosure {\\n\\n    static int n, m, k;\\n    static List<Integer>[] adj;\\n    static boolean[] visited;\\n    static int deadEnds;\\n    static int ways;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        k = scanner.nextInt();\\n\\n        adj = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            adj[i] = new ArrayList<Integer>();\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int v1 = scanner.nextInt();\\n            int v2 = scanner.nextInt();\\n            adj[v1].add(v2);\\n            adj[v2].add(v1);\\n        }\\n\\n        ways = 0;\\n        deadEnds = 0;\\n        dfs(1);\\n\\n        System.out.println(ways);\\n    }\\n\\n    static void dfs(int node) {\\n        visited[node] = true;\\n\\n        if (adj[node].size() == 1) {\\n            deadEnds++;\\n        }\\n\\n        if (deadEnds > k) {\\n            return;\\n        }\\n\\n        if (node != 1 && adj[node].size() == 1 && deadEnds == k) {\\n            ways++;\\n        }\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                dfs(neighbor);\\n            }\\n        }\\n\\n        visited[node] = false;\\n        if (adj[node].size() == 1) {\\n            deadEnds--;\\n        }\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class RoadClosure {\\n\\n    static int n, m, k;\\n    static List<Integer>[] adj;\\n    static boolean[] visited;\\n    static int deadEnds;\\n    static int ways;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        n = scanner.nextInt();\\n        m = scanner.nextInt();\\n        k = scanner.nextInt();\\n\\n        adj = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n\\n        for (int i = 1; i <= n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            int v1 = scanner.nextInt();\\n            int v2 = scanner.nextInt();\\n            adj[v1].add(v2);\\n            adj[v2].add(v1);\\n        }\\n\\n        ways = 0;\\n        deadEnds = 0;\\n        dfs(1);\\n\\n        System.out.println(ways);\\n    }\\n\\n    static void dfs(int node) {\\n        visited[node] = true;\\n\\n        if (adj[node].size() == 1) {\\n            deadEnds++;\\n        }\\n\\n        if (deadEnds > k) {\\n            return;\\n        }\\n\\n        if (node != 1 && adj[node].size() == 1 && deadEnds == k) {\\n            ways++;\\n        }\\n\\n        for (int neighbor : adj[node]) {\\n            if (!visited[neighbor]) {\\n                dfs(neighbor);\\n            }\\n        }\\n\\n        visited[node] = false;\\n        if (adj[node].size() == 1) {\\n            deadEnds--;\\n        }\\n    }\\n}","Python":"from itertools import combinations\\n\\n# Function to check if the resulting map is valid\\n# Returns True if valid, False otherwise\\n\\ndef is_valid_map(adj_list, dead_ends):\\n    visited = [False] * len(adj_list)\\n    stack = []\\n    stack.append(0)\\n    visited[0] = True\\n    while stack:\\n        node = stack.pop()\\n        for neighbor in adj_list[node]:\\n            if not visited[neighbor]:\\n                stack.append(neighbor)\\n                visited[neighbor] = True\\n    for i in range(len(visited)):\\n        if not visited[i]:\\n            return False\\n    if len(dead_ends) != sum([1 for i in range(len(adj_list)) if len(adj_list[i]) == 1]):\\n        return False\\n    return True\\n\\n\\n# Function to count the number of ways to close roads\\n\\ndef count_ways(n, m, k, roads):\\n    adj_list = [[] for _ in range(n)]\\n    for road in roads:\\n        v1, v2 = road\\n        adj_list[v1-1].append(v2-1)\\n        adj_list[v2-1].append(v1-1)\\n    possible_ways = 0\\n    for comb in combinations(range(m), n-1):\\n        new_adj_list = [[] for _ in range(n)]\\n        dead_ends = []\\n        for i in range(m):\\n            if i in comb:\\n                v1, v2 = roads[i]\\n                new_adj_list[v1-1].append(v2-1)\\n                new_adj_list[v2-1].append(v1-1)\\n            else:\\n                v1, v2 = roads[i]\\n                dead_ends.append(v1-1)\\n                dead_ends.append(v2-1)\\n        if is_valid_map(new_adj_list, dead_ends) and len(dead_ends) == k:\\n            possible_ways += 1\\n    return possible_ways\\n\\n\\n# Main code\\n\\ninputs = ['3 3 2\\\\n1 2\\\\n2 3\\\\n1 3\\\\n', '4 6 2\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 1\\\\n1 3\\\\n2 4\\\\n', '4 6 3\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 1\\\\n1 3\\\\n2 4\\\\n']\\noutputs = ['3\\\\n', '12\\\\n', '4\\\\n']\\n\\nresults = []\\n\\nfor i in range(len(inputs)):\\n    n, m, k = map(int, inputs[i].split()[0:3])\\n    roads = [list(map(int, x.split())) for x in inputs[i].split()[3:]]\\n    ways = count_ways(n, m, k, roads)\\n    results.append(str(ways) + '\\\\n')\\n\\nprint(results)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXN 10\\n\\nint n, m, k;\\nint graph[MAXN][MAXN];\\nint visited[MAXN];\\nint deadEnds[MAXN];\\nint result = 0;\\n\\nvoid dfs(int node, int edgesLeft, int deadEndsLeft) {\\n    visited[node] = 1;\\n    if (edgesLeft == 0 && deadEndsLeft == 0) {\\n        result++;\\n        return;\\n    }\\n    if (edgesLeft == 0 || deadEndsLeft == 0) {\\n        return;\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        if (graph[node][i] && !visited[i]) {\\n            visited[i] = 1;\\n            if (deadEnds[i]) {\\n                dfs(i, edgesLeft - 1, deadEndsLeft - 1);\\n            } else {\\n                dfs(i, edgesLeft - 1, deadEndsLeft);\\n            }\\n            visited[i] = 0;\\n        }\\n    }\\n}\\n\\nint main() {\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n    for (int i = 0; i < m; i++) {\\n        int v1, v2;\\n        scanf(\\\"%d %d\\\", &v1, &v2);\\n        graph[v1][v2] = 1;\\n        graph[v2][v1] = 1;\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            if (graph[i][j]) {\\n                deadEnds[i]++;\\n            }\\n        }\\n    }\\n    for (int i = 1; i <= n; i++) {\\n        visited[i] = 1;\\n        if (deadEnds[i]) {\\n            dfs(i, n - 2, k - 1);\\n        } else {\\n            dfs(i, n - 2, k);\\n        }\\n        visited[i] = 0;\\n    }\\n    printf(\\\"%d\\\\n\\\", result);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RoadClosure\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n            int k = int.Parse(inputArr[2]);\n\n            List<int>[] graph = new List<int>[n + 1];\n            for (int i = 0; i <= n; i++)\n            {\n                graph[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                string road = Console.ReadLine();\n                string[] roadArr = road.Split(' ');\n                int v1 = int.Parse(roadArr[0]);\n                int v2 = int.Parse(roadArr[1]);\n\n                graph[v1].Add(v2);\n                graph[v2].Add(v1);\n            }\n\n            int[] deadEnds = new int[n + 1];\n            int[] visited = new int[n + 1];\n            int[] parent = new int[n + 1];\n\n            int result = CountWays(graph, deadEnds, visited, parent, k, 1);\n\n            Console.WriteLine(result);\n        }\n\n        static int CountWays(List<int>[] graph, int[] deadEnds, int[] visited, int[] parent, int k, int node)\n        {\n            visited[node] = 1;\n\n            if (graph[node].Count == 1)\n            {\n                deadEnds[node] = 1;\n            }\n\n            int ways = 0;\n\n            foreach (int neighbor in graph[node])\n            {\n                if (visited[neighbor] == 0)\n                {\n                    parent[neighbor] = node;\n                    ways += CountWays(graph, deadEnds, visited, parent, k, neighbor);\n                }\n            }\n\n            if (deadEnds[node] == 1 && k > 0)\n            {\n                deadEnds[node] = 0;\n                k--;\n                ways++;\n            }\n\n            return ways;\n        }\n    }\n}","Ruby":"\n# Function to count the number of ways to close roads\ndef count_ways(n, m, k, roads)\n  # Initialize variables\n  count = 0\n  visited = Array.new(n, false)\n  dead_ends = Array.new(n, false)\n  \n  # Helper function to perform DFS\n  def dfs(node, visited, dead_ends, roads)\n    visited[node] = true\n    \n    # Check if current node is a dead end\n    if roads[node].length == 1\n      dead_ends[node] = true\n    end\n    \n    # Perform DFS on adjacent nodes\n    roads[node].each do |adj_node|\n      if !visited[adj_node]\n        dfs(adj_node, visited, dead_ends, roads)\n      end\n    end\n  end\n  \n  # Create adjacency list representation of roads\n  roads_list = Array.new(n) { [] }\n  roads.each do |road|\n    v1, v2 = road\n    roads_list[v1-1] << v2-1\n    roads_list[v2-1] << v1-1\n  end\n  \n  # Perform DFS on each junction\n  (0...n).each do |node|\n    if !visited[node]\n      dfs(node, visited, dead_ends, roads_list)\n    end\n  end\n  \n  # Count the number of ways to close roads\n  (0...n).each do |node|\n    if dead_ends[node]\n      count += 1\n    end\n  end\n  \n  return count\nend\n\n# Parse input\ninput = '3 3 2\\n1 2\\n2 3\\n1 3\\n'\nn, m, k = input.split(\"\\n\")[0].split.map(&:to_i)\nroads = input.split(\"\\n\")[1..-1].map { |line| line.split.map(&:to_i) }\n\n# Count the number of ways to close roads\nways = count_ways(n, m, k, roads)\n\n# Print the result\nputs ways\n","delphi":"program Main;\\n\\nvar\\n  n, m, k, i, j, ans: integer;\\n  g: array[1..10, 1..10] of boolean;\\n  deg: array[1..10] of integer;\\n\\nprocedure dfs(v, cnt: integer);\\nvar\\n  i: integer;\\nbegin\\n  if cnt > k then\\n    exit;\\n  if v = n then\\n  begin\\n    if cnt = k then\\n      ans := ans + 1;\\n    exit;\\n  end;\\n  for i := 1 to n do\\n  begin\\n    if g[v, i] then\\n    begin\\n      g[v, i] := false;\\n      g[i, v] := false;\\n      deg[v] := deg[v] - 1;\\n      deg[i] := deg[i] - 1;\\n      dfs(i, cnt + 1);\\n      g[v, i] := true;\\n      g[i, v] := true;\\n      deg[v] := deg[v] + 1;\\n      deg[i] := deg[i] + 1;\\n    end;\\n  end;\\nend;\\n\\nbegin\\n  readln(n, m, k);\\n  for i := 1 to m do\\n  begin\\n    readln(j, k);\\n    g[j, k] := true;\\n    g[k, j] := true;\\n    deg[j] := deg[j] + 1;\\n    deg[k] := deg[k] + 1;\\n  end;\\n  ans := 0;\\n  dfs(1, 0);\\n  writeln(ans);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnmk := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nmk[0])\\n\\tm, _ := strconv.Atoi(nmk[1])\\n\\tk, _ := strconv.Atoi(nmk[2])\\n\\n\\tadjList := make([][]int, n+1)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tuv := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\tu, _ := strconv.Atoi(uv[0])\\n\\t\\tv, _ := strconv.Atoi(uv[1])\\n\\n\\t\\tadjList[u] = append(adjList[u], v)\\n\\t\\tadjList[v] = append(adjList[v], u)\\n\\t}\\n\\n\\tvisited := make([]bool, n+1)\\n\\tdeadEnds := 0\\n\\n\\tvar dfs func(int)\\n\\tdfs = func(node int) {\\n\\t\\tvisited[node] = true\\n\\n\\t\\tif len(adjList[node]) == 1 {\\n\\t\\t\\tdeadEnds++\\n\\t\\t}\\n\\n\\t\\tfor _, neighbor := range adjList[node] {\\n\\t\\t\\tif !visited[neighbor] {\\n\\t\\t\\t\\tdfs(neighbor)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tdfs(1)\\n\\n\\tif deadEnds < k {\\n\\t\\tfmt.Println(0)\\n\\t\\treturn\\n\\t}\\n\\n\\tif deadEnds == k {\\n\\t\\tfmt.Println(1)\\n\\t\\treturn\\n\\t}\\n\\n\\tresult := 0\\n\\n\\tvar countWays func(int, int)\\n\\tcountWays = func(node int, count int) {\\n\\t\\tvisited[node] = true\\n\\n\\t\\tif count == k {\\n\\t\\t\\tresult++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor _, neighbor := range adjList[node] {\\n\\t\\t\\tif !visited[neighbor] {\\n\\t\\t\\t\\tcountWays(neighbor, count+1)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvisited[node] = false\\n\\t}\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tvisited[i] = false\\n\\t}\\n\\n\\tcountWays(1, 0)\\n\\n\\tfmt.Println(result)\\n}","Javascript":"function countWays(n, m, k, roads) {\n    let graph = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    let deadEnds = new Array(n + 1).fill(0);\n    \n    for (let i = 0; i < m; i++) {\n        let [v1, v2] = roads[i];\n        graph[v1][v2] = 1;\n        graph[v2][v1] = 1;\n        deadEnds[v1]++;\n        deadEnds[v2]++;\n    }\n    \n    let dp = new Array(n + 1).fill(0).map(() => new Array(k + 1).fill(0));\n    \n    for (let i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= k; j++) {\n            dp[i][j] = dp[i - 1][j];\n            \n            for (let p = 1; p < i; p++) {\n                if (graph[i][p] === 1) {\n                    dp[i][j] += dp[p][j - 1];\n                }\n            }\n        }\n    }\n    \n    return dp[n][k];\n}\n\nlet inputs = ['3 3 2\\\\n1 2\\\\n2 3\\\\n1 3\\\\n', '4 6 2\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 1\\\\n1 3\\\\n2 4\\\\n', '4 6 3\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 1\\\\n1 3\\\\n2 4\\\\n'];\nlet outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    let lines = inputs[i].split('\\\\n');\n    let [n, m, k] = lines[0].split(' ').map(Number);\n    let roads = [];\n    \n    for (let j = 1; j <= m; j++) {\n        let [v1, v2] = lines[j].split(' ').map(Number);\n        roads.push([v1, v2]);\n    }\n    \n    let result = countWays(n, m, k, roads);\n    outputs.push(result + '\\\\n');\n}\n\nJSON.stringify([{\"version\": \"JavaScript\", \"source code\": countWays.toString()}])","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val k = input[2].toInt()\n\n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    repeat(m) {\n        val road = scanner.nextLine().split(\" \")\n        val v1 = road[0].toInt()\n        val v2 = road[1].toInt()\n        graph[v1].add(v2)\n        graph[v2].add(v1)\n    }\n\n    val visited = BooleanArray(n + 1)\n    val deadEnds = IntArray(n + 1)\n    var result = 0\n\n    fun dfs(node: Int, parent: Int): Int {\n        visited[node] = true\n        var count = 0\n        for (neighbor in graph[node]) {\n            if (neighbor != parent) {\n                if (!visited[neighbor]) {\n                    count += dfs(neighbor, node)\n                } else if (neighbor != parent && deadEnds[neighbor] == 0) {\n                    count++\n                }\n            }\n        }\n        deadEnds[node] = count\n        return count\n    }\n\n    for (i in 1..n) {\n        if (!visited[i]) {\n            val count = dfs(i, -1)\n            if (count == k) {\n                result++\n            }\n        }\n    }\n\n    println(result)\n}","PHP":"\n<?php\n\n\/\/ Function to calculate the number of ways to close roads\nfunction calculateWays($n, $m, $k, $roads) {\n    \/\/ Create an adjacency matrix to represent the road connections\n    $adjMatrix = array_fill(0, $n, array_fill(0, $n, 0));\n    foreach ($roads as $road) {\n        $v1 = $road[0] - 1;\n        $v2 = $road[1] - 1;\n        $adjMatrix[$v1][$v2] = 1;\n        $adjMatrix[$v2][$v1] = 1;\n    }\n    \n    \/\/ Initialize variables\n    $ways = 0;\n    $visited = array_fill(0, $n, false);\n    \n    \/\/ Recursive function to find all possible ways to close roads\n    function findWays($adjMatrix, $visited, $current, $n, $m, $k, &$ways) {\n        \/\/ Base case: if all roads are closed and k dead ends are reached\n        if ($m == $n - 1 && $k == 0) {\n            $ways++;\n            return;\n        }\n        \n        \/\/ Mark current junction as visited\n        $visited[$current] = true;\n        \n        \/\/ Count the number of dead ends\n        $deadEnds = 0;\n        for ($i = 0; $i < $n; $i++) {\n            if ($adjMatrix[$current][$i] == 1 && !$visited[$i]) {\n                $visited[$i] = true;\n                $deadEnds++;\n            }\n        }\n        \n        \/\/ Recursive call for each unvisited junction\n        for ($i = 0; $i < $n; $i++) {\n            if (!$visited[$i]) {\n                $visited[$i] = true;\n                findWays($adjMatrix, $visited, $i, $n, $m + 1, $k - $deadEnds, $ways);\n                $visited[$i] = false;\n            }\n        }\n        \n        \/\/ Mark current junction as unvisited\n        $visited[$current] = false;\n    }\n    \n    \/\/ Call the recursive function for each junction\n    for ($i = 0; $i < $n; $i++) {\n        findWays($adjMatrix, $visited, $i, $n, 0, $k, $ways);\n    }\n    \n    return $ways;\n}\n\n\/\/ Read input from stdin\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\nlist($n, $m, $k) = explode(' ', $input[0]);\n$roads = array();\nfor ($i = 1; $i <= $m; $i++) {\n    list($v1, $v2) = explode(' ', $input[$i]);\n    $roads[] = array($v1, $v2);\n}\n\n\/\/ Calculate the number of ways to close roads\n$ways = calculateWays($n, $m, $k, $roads);\n\n\/\/ Print the result\necho $ways;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, k;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &k);\\r\\n\\r\\n    int[][] graph = new int[][](n, n);\\r\\n    foreach (i; 0..m)\\r\\n    {\\r\\n        int v1, v2;\\r\\n        readf(\\\"%d %d\\\", &v1, &v2);\\r\\n        graph[v1 - 1][v2 - 1] = 1;\\r\\n        graph[v2 - 1][v1 - 1] = 1;\\r\\n    }\\r\\n\\r\\n    int[][] dp = new int[][](n, n);\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        dp[i][i] = 1;\\r\\n        foreach (j; 0..i)\\r\\n        {\\r\\n            dp[i][j] = dp[j][i] = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[] deadEnds = new int[](n);\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        deadEnds[i] = graph[i].count(1) == 1 ? 1 : 0;\\r\\n    }\\r\\n\\r\\n    int count = 0;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        foreach (j; i + 1..n)\\r\\n        {\\r\\n            if (graph[i][j] == 1)\\r\\n            {\\r\\n                graph[i][j] = graph[j][i] = 0;\\r\\n\\r\\n                int[] visited = new int[](n);\\r\\n                int[] stack = new int[](n);\\r\\n                int top = 0;\\r\\n\\r\\n                stack[top++] = i;\\r\\n                visited[i] = 1;\\r\\n\\r\\n                while (top > 0)\\r\\n                {\\r\\n                    int v = stack[--top];\\r\\n\\r\\n                    foreach (u; 0..n)\\r\\n                    {\\r\\n                        if (graph[v][u] == 1 && visited[u] == 0)\\r\\n                        {\\r\\n                            stack[top++] = u;\\r\\n                            visited[u] = 1;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                bool isConnected = true;\\r\\n                foreach (v; 0..n)\\r\\n                {\\r\\n                    if (visited[v] == 0)\\r\\n                    {\\r\\n                        isConnected = false;\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (isConnected)\\r\\n                {\\r\\n                    int[] newDeadEnds = new int[](n);\\r\\n                    foreach (v; 0..n)\\r\\n                    {\\r\\n                        newDeadEnds[v] = deadEnds[v];\\r\\n                    }\\r\\n\\r\\n                    newDeadEnds[i] = newDeadEnds[j] = 1;\\r\\n\\r\\n                    int newK = newDeadEnds.count(1);\\r\\n\\r\\n                    if (newK == k)\\r\\n                    {\\r\\n                        count++;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                graph[i][j] = graph[j][i] = 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_ways {\n    my ($n, $m, $k, @roads) = @_;\n\n    my @adj_list;\n    for (my $i = 0; $i < $n; $i++) {\n        push @{$adj_list[$i]}, ();\n    }\n\n    foreach my $road (@roads) {\n        my ($v1, $v2) = split ' ', $road;\n        push @{$adj_list[$v1-1]}, $v2-1;\n        push @{$adj_list[$v2-1]}, $v1-1;\n    }\n\n    my $count = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        my $degree = scalar @{$adj_list[$i]};\n        if ($degree == 1) {\n            $count++;\n        }\n    }\n\n    my $result = 0;\n    if ($count == $k) {\n        $result = 1;\n    }\n\n    return $result;\n}\n\nsub generate_combinations {\n    my ($n, $m, $k) = @_;\n\n    my @roads;\n    for (my $i = 1; $i <= $n; $i++) {\n        for (my $j = $i+1; $j <= $n; $j++) {\n            push @roads, \"$i $j\";\n        }\n    }\n\n    my $total_ways = 0;\n    my $total_combinations = 2**$m;\n    for (my $i = 0; $i < $total_combinations; $i++) {\n        my $binary = sprintf(\"%0${m}b\", $i);\n        my @selected_roads;\n        for (my $j = 0; $j < $m; $j++) {\n            if (substr($binary, $j, 1) eq '1') {\n                push @selected_roads, $roads[$j];\n            }\n        }\n        if (scalar @selected_roads == $n-1) {\n            my $ways = count_ways($n, $m, $k, @selected_roads);\n            $total_ways += $ways;\n        }\n    }\n\n    return $total_ways;\n}\n\nmy @inputs = (\n    ['3 3 2\\n1 2\\n2 3\\n1 3\\n'],\n    ['4 6 2\\n1 2\\n2 3\\n3 4\\n4 1\\n1 3\\n2 4\\n'],\n    ['4 6 3\\n1 2\\n2 3\\n3 4\\n4 1\\n1 3\\n2 4\\n']\n);\n\nmy @outputs = (\n    '3\\n',\n    '12\\n',\n    '4\\n'\n);\n\nfor (my $i = 0; $i < scalar @inputs; $i++) {\n    my ($n, $m, $k) = split ' ', $inputs[$i][0];\n    my @roads = split '\\n', $inputs[$i][0];\n    shift @roads;\n    my $result = generate_combinations($n, $m, $k);\n    if ($result == $outputs[$i]) {\n        print 'Test case ', $i+1, ' passed.\\n';\n    } else {\n        print 'Test case ', $i+1, ' failed.\\n';\n    }\n}\n","Rust":"use std::collections::HashSet;\\n\\nfn main() {\\n    let input = \\\"4 6 2\\\\n1 2\\\\n2 3\\\\n3 4\\\\n4 1\\\\n1 3\\\\n2 4\\\\n\\\";\\n    let lines: Vec<&str> = input.trim().split('\\\\n').collect();\\n    let params: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\\n    let n = params[0];\\n    let m = params[1];\\n    let k = params[2];\\n\\n    let mut graph: Vec<HashSet<usize>> = vec![HashSet::new(); n + 1];\\n\\n    for i in 1..=m {\\n        let vertices: Vec<usize> = lines[i].split(' ').map(|x| x.parse().unwrap()).collect();\\n        let u = vertices[0];\\n        let v = vertices[1];\\n        graph[u].insert(v);\\n        graph[v].insert(u);\\n    }\\n\\n    let mut count = 0;\\n\\n    for i in 1..=n {\\n        let mut visited: HashSet<usize> = HashSet::new();\\n        visited.insert(i);\\n        dfs(i, &graph, &mut visited, k, &mut count);\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}\\n\\nfn dfs(node: usize, graph: &Vec<HashSet<usize>>, visited: &mut HashSet<usize>, k: usize, count: &mut usize) {\\n    if visited.len() == k + 1 {\\n        *count += 1;\\n        return;\\n    }\\n\\n    for &neighbor in &graph[node] {\\n        if !visited.contains(&neighbor) {\\n            visited.insert(neighbor);\\n            dfs(neighbor, graph, visited, k, count);\\n            visited.remove(&neighbor);\\n        }\\n    }\\n}"}
{"title":"A. Presents","description":"The Hedgehog likes to give presents to his friend, but no less he likes to receive them.Having received another present today, the Hedgehog suddenly understood that he has no place to put it as there was no room left on the special shelf in the cupboard. He will have to choose another shelf, but which one should he choose, how large should it be?In order to get to know this, the Hedgehog asks you to write him a program that will count the estimated number of presents that he will receive during the following N days. Besides, he is guided by the principle:   on each holiday day the Hedgehog will necessarily receive a present,  he receives presents at least every K days (i.e., if he received a present on the i-th day, he will receive the next present no later than on the i+K-th day).  For the given N and K, as well as the list of holidays among the following N days count the minimal number of presents that could be given to the Hedgehog. The number of today's day is zero, and you should regard today's present as already given (i.e., you shouldn't count it in the answer).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains integers N and K (1\u2264N\u2264365, 1\u2264K\u2264N).\nThe second line contains a number C which represents the number of holidays (0\u2264C\u2264N). Then in the same line follow C numbers ranging from 1 to N which are the numbers of holiday days. The numbers are given in the increasing order, without repeating numbers among them.\n","output_spec":"Print a single number \u2014 the minimal number of presents the Hedgehog will receive over the following N days.\n","notes":null,"sample_inputs":["5 2\n1 3\n","10 1\n3 6 7 8\n"],"sample_outputs":["3","10"],"id":"54-A","difficulty":1300,"tags":["implementation"],"src_uid":"07b750dbf7f942eab80d4260103c7472","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int N, K, C;\\n    cin >> N >> K >> C;\\n    vector<int> holidays(C);\\n    for (int i = 0; i < C; i++) {\\n        cin >> holidays[i];\\n    }\\n\\n    int presents = 0;\\n    int day = 0;\\n    int nextHoliday = 0;\\n\\n    while (day < N) {\\n        if (nextHoliday < C && day == holidays[nextHoliday]) {\\n            presents++;\\n            nextHoliday++;\\n        } else if ((day + 1) % K == 0) {\\n            presents++;\\n        }\\n        day++;\\n    }\\n\\n    cout << presents << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class HedgehogPresents {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String[] input = scanner.nextLine().split(\\\" \\\");\\n        int N = Integer.parseInt(input[0]);\\n        int K = Integer.parseInt(input[1]);\\n\\n        input = scanner.nextLine().split(\\\" \\\");\\n        int C = Integer.parseInt(input[0]);\\n        int[] holidays = new int[C];\\n        for (int i = 0; i < C; i++) {\\n            holidays[i] = Integer.parseInt(input[i + 1]);\\n        }\\n\\n        int presents = 0;\\n        int lastPresentDay = -1;\\n\\n        for (int i = 1; i <= N; i++) {\\n            if (isHoliday(i, holidays)) {\\n                presents++;\\n                lastPresentDay = i;\\n            } else if (i - lastPresentDay >= K) {\\n                presents++;\\n                lastPresentDay = i;\\n            }\\n        }\\n\\n        System.out.println(presents);\\n    }\\n\\n    private static boolean isHoliday(int day, int[] holidays) {\\n        for (int holiday : holidays) {\\n            if (holiday == day) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\"}\n","Python":"def count_presents(N, K, holidays):\n    presents = 0\n    last_present_day = -K\n    for day in range(1, N+1):\n        if day in holidays:\n            presents += 1\n            last_present_day = day\n        elif day - last_present_day >= K:\n            presents += 1\n            last_present_day = day\n    return presents\n\ninput_data = input().split('\\\\n')\nN, K = map(int, input_data[0].split())\nholidays = list(map(int, input_data[1].split()[1:]))\nresult = count_presents(N, K, holidays)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int N, K, C;\\n    scanf(\\\"%d %d\\\", &N, &K);\\n    scanf(\\\"%d\\\", &C);\\n    int holidays[C];\\n    for (int i = 0; i < C; i++) {\\n        scanf(\\\"%d\\\", &holidays[i]);\\n    }\\n\\n    int presents = 0;\\n    int day = 0;\\n    int holidayIndex = 0;\\n\\n    while (day < N) {\\n        day++;\\n        presents++;\\n\\n        if (holidayIndex < C && day == holidays[holidayIndex]) {\\n            holidayIndex++;\\n            continue;\\n        }\\n\\n        if (day % K == 0) {\\n            presents++;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\", presents);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string input = Console.ReadLine();\n        string[] inputArr = input.Split(' ');\n        int N = int.Parse(inputArr[0]);\n        int K = int.Parse(inputArr[1]);\n\n        input = Console.ReadLine();\n        inputArr = input.Split(' ');\n        int C = int.Parse(inputArr[0]);\n\n        List<int> holidays = new List<int>();\n        for (int i = 1; i <= C; i++)\n        {\n            holidays.Add(int.Parse(inputArr[i]));\n        }\n\n        int presents = 0;\n        int lastPresentDay = 0;\n\n        foreach (int holiday in holidays)\n        {\n            int daysSinceLastPresent = holiday - lastPresentDay - 1;\n            presents += (daysSinceLastPresent \/ K);\n            lastPresentDay = holiday;\n        }\n\n        int remainingDays = N - lastPresentDay;\n        presents += (remainingDays \/ K);\n\n        Console.WriteLine(presents);\n    }\n}","Ruby":"def minimal_presents(input)\n  n, k = input[0].split.map(&:to_i)\n  holidays = input[1].split.map(&:to_i)\n  \n  presents = 0\n  current_day = 0\n  \n  (1..n).each do |day|\n    if holidays.include?(day)\n      presents += 1\n      current_day = day\n    elsif day - current_day >= k\n      presents += 1\n      current_day = day\n    end\n  end\n  \n  presents.to_s\nend\n\ninput = gets.chomp.split('\\n')\nputs minimal_presents(input)","delphi":"program HedgehogPresents;\\n\\nvar\\n  N, K, C, i, j, presentCount: integer;\\n  holidays: array of integer;\\n\\nbegin\\n  readln(N, K);\\n  readln(C);\\n  SetLength(holidays, C);\\n  for i := 0 to C-1 do\\n    read(holidays[i]);\\n\\n  presentCount := 0;\\n  j := 0;\\n\\n  for i := 1 to N do\\n  begin\\n    if (i = holidays[j]) then\\n    begin\\n      presentCount := presentCount + 1;\\n      j := j + 1;\\n    end\\n    else if ((i - holidays[j-1]) mod K = 0) then\\n      presentCount := presentCount + 1;\\n  end;\\n\\n  writeln(presentCount);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar N, K, C int\\n\\tfmt.Scanf(\\\"%d %d\\\", &N, &K)\\n\\tfmt.Scanf(\\\"%d\\\", &C)\\n\\n\\tholidays := make(map[int]bool)\\n\\n\\tfor i := 0; i < C; i++ {\\n\\t\\tvar holiday int\\n\\t\\tfmt.Scanf(\\\"%d\\\", &holiday)\\n\\t\\tholidays[holiday] = true\\n\\t}\\n\\n\\tpresents := 0\\n\\tcurrentDay := 0\\n\\n\\tfor i := 1; i <= N; i++ {\\n\\t\\tif holidays[i] {\\n\\t\\t\\tpresents++\\n\\t\\t\\tcurrentDay = 0\\n\\t\\t} else {\\n\\t\\t\\tcurrentDay++\\n\\t\\t\\tif currentDay == K {\\n\\t\\t\\t\\tpresents++\\n\\t\\t\\t\\tcurrentDay = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(presents)\\n}","Javascript":"function countPresents(input) {\n  const [NK, holidays] = input.split('\\\\n');\n  const [N, K] = NK.split(' ').map(Number);\n  const holidayDays = holidays.split(' ').map(Number);\n\n  let presents = 0;\n  let lastPresentDay = 0;\n\n  for (let i = 1; i <= N; i++) {\n    if (holidayDays.includes(i)) {\n      presents++;\n      lastPresentDay = i;\n    } else if (i - lastPresentDay >= K) {\n      presents++;\n      lastPresentDay = i;\n    }\n  }\n\n  return presents.toString();\n}\n\nconsole.log(countPresents('5 2\\\\n1 3\\\\n'));","Kotlin":"fun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val k = input[1]\\n\\n    val holidays = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    var presents = 0\\n    var lastPresentDay = -k\\n\\n    for (i in 1..n) {\\n        if (i in holidays) {\\n            presents++\\n            lastPresentDay = i\\n        } else if (i - lastPresentDay >= k) {\\n            presents++\\n            lastPresentDay = i\\n        }\\n    }\\n\\n    println(presents)\\n}","PHP":"<?php\\n\\nfunction countPresents($input) {\\n    \/\/ Parse input\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    list($n, $k) = explode(\\\" \\\", $lines[0]);\\n    $holidays = explode(\\\" \\\", $lines[1]);\\n    $c = count($holidays);\\n    \\n    \/\/ Calculate the minimal number of presents\\n    $presents = 0;\\n    $lastPresentDay = 0;\\n    for ($i = 0; $i < $n; $i++) {\\n        if ($i == $lastPresentDay + $k || in_array($i, $holidays)) {\\n            $presents++;\\n            $lastPresentDay = $i;\\n        }\\n    }\\n    \\n    \/\/ Return the result\\n    return $presents;\\n}\\n\\n\/\/ Test the function\\n$input1 = \\\"5 2\\\\n1 3\\\\n\\\";\\n$output1 = countPresents($input1);\\necho $output1; \/\/ Output: 3\\n\\n$input2 = \\\"10 1\\\\n3 6 7 8\\\\n\\\";\\n$output2 = countPresents($input2);\\necho $output2; \/\/ Output: 10\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int N, K, C;\\r\\n    int[] holidays;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &N, &K);\\r\\n    scanf(\\\"%d\\\", &C);\\r\\n    holidays = new int[C];\\r\\n    foreach (i; 0..C)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &holidays[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate the minimal number of presents\\r\\n    int presents = 0;\\r\\n    int lastHoliday = 0;\\r\\n    foreach (day; 1..N+1)\\r\\n    {\\r\\n        if (day % K == 0)\\r\\n        {\\r\\n            presents++;\\r\\n            lastHoliday = day;\\r\\n        }\\r\\n        else if (holidays.canFind(day))\\r\\n        {\\r\\n            presents++;\\r\\n            lastHoliday = day;\\r\\n        }\\r\\n        else if (day - lastHoliday >= K)\\r\\n        {\\r\\n            presents++;\\r\\n            lastHoliday = day;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(presents);\\r\\n}","perl":"\n# Read input values\nmy $input = <STDIN>;\nchomp $input;\nmy ($N, $K) = split ' ', $input;\n\nmy $holidays = <STDIN>;\nchomp $holidays;\nmy @holidays = split ' ', $holidays;\n\n# Initialize variables\nmy $presents = 0;\nmy $last_present_day = 0;\n\n# Iterate over the N days\nfor my $day (1..$N) {\n    # Check if it's a holiday\n    if (grep { $_ == $day } @holidays) {\n        $presents++;\n        $last_present_day = $day;\n    }\n    # Check if it's time for the next present\n    elsif ($day - $last_present_day >= $K) {\n        $presents++;\n        $last_present_day = $day;\n    }\n}\n\n# Print the minimal number of presents\nprint $presents;\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let mut lines = input.lines();\n    \n    let nk: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nk[0];\n    let k = nk[1];\n    \n    let holidays: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut presents = 0;\n    let mut day = 0;\n    \n    for i in 1..=n {\n        if !holidays.contains(&i) && (i - day) % k == 0 {\n            presents += 1;\n            day = i;\n        }\n    }\n    \n    println!(\"{}\", presents);\n}"}
{"title":"B. Cutting Jigsaw Puzzle","description":"The Hedgehog recently remembered one of his favorite childhood activities, \u2014 solving puzzles, and got into it with new vigor. He would sit day in, day out with his friend buried into thousands of tiny pieces of the picture, looking for the required items one by one.Soon the Hedgehog came up with a brilliant idea: instead of buying ready-made puzzles, one can take his own large piece of paper with some picture and cut it into many small rectangular pieces, then mix them and solve the resulting puzzle, trying to piece together the picture. The resulting task is even more challenging than the classic puzzle: now all the fragments have the same rectangular shape, and one can assemble the puzzle only relying on the picture drawn on the pieces.All puzzle pieces turn out to be of the same size X\u00d7Y, because the picture is cut first by horizontal cuts with the pitch of X, then with vertical cuts with the pitch of Y. If we denote the initial size of the picture as A\u00d7B, then A must be divisible by X and B must be divisible by Y (X and Y are integer numbers). However, not every such cutting of the picture will result in a good puzzle. The Hedgehog finds a puzzle good if no two pieces in it are the same (It is allowed to rotate the pieces when comparing them, but it is forbidden to turn them over). Your task is to count for a given picture the number of good puzzles that you can make from it, and also to find the puzzle with the minimal piece size.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two numbers A and B which are the sizes of the picture. They are positive integers not exceeding 20.\nThen follow A lines containing B symbols each, describing the actual picture. The lines only contain uppercase English letters.\n","output_spec":"In the first line print the number of possible good puzzles (in other words, the number of pairs (X,Y) such that the puzzle with the corresponding element sizes will be good). This number should always be positive, because the whole picture is a good puzzle itself. \nIn the second line print two numbers \u2014 the sizes X and Y of the smallest possible element among all good puzzles. The comparison is made firstly by the area XY of one element and secondly \u2014 by the length X.\n","notes":"The picture in the first sample test has the following good puzzles: (2,1), (2,2), (2,4).\n","sample_inputs":["2 4\nABDC\nABDC\n","2 6\nABCCBA\nABCCBA\n"],"sample_outputs":["3\n2 1\n","1\n2 6\n"],"id":"54-B","difficulty":1800,"tags":["hashing","implementation"],"src_uid":"4de8b72f9ce12554cae8b6a83b3f023e","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <set>\\nusing namespace std;\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint main() {\\n    int A, B;\\n    cin >> A >> B;\\n    vector<string> picture(A);\\n    for (int i = 0; i < A; i++) {\\n        cin >> picture[i];\\n    }\\n\\n    set<pair<int, int>> puzzles;\\n\\n    for (int i = 1; i <= A; i++) {\\n        if (A % i == 0) {\\n            for (int j = 1; j <= B; j++) {\\n                if (B % j == 0) {\\n                    bool valid = true;\\n                    for (int x = 0; x < A; x += i) {\\n                        for (int y = 0; y < B; y += j) {\\n                            string piece = \\\"\\\";\\n                            for (int p = x; p < x + i; p++) {\\n                                for (int q = y; q < y + j; q++) {\\n                                    piece += picture[p][q];\\n                                }\\n                            }\\n                            if (count(picture.begin(), picture.end(), piece) > 1) {\\n                                valid = false;\\n                                break;\\n                            }\\n                        }\\n                        if (!valid) {\\n                            break;\\n                        }\\n                    }\\n                    if (valid) {\\n                        puzzles.insert(make_pair(i, j));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    cout << puzzles.size() << endl;\\n    int minArea = A * B;\\n    int minX = A;\\n    for (auto puzzle : puzzles) {\\n        int area = puzzle.first * puzzle.second;\\n        if (area < minArea) {\\n            minArea = area;\\n            minX = puzzle.first;\\n        }\\n        else if (area == minArea && puzzle.first < minX) {\\n            minX = puzzle.first;\\n        }\\n    }\\n    cout << minX << \\\" \\\" << minArea \/ minX << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class PuzzleSolver {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read the sizes of the picture\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        \n        \/\/ Read the picture\n        char[][] picture = new char[A][B];\n        for (int i = 0; i < A; i++) {\n            String line = scanner.next();\n            for (int j = 0; j < B; j++) {\n                picture[i][j] = line.charAt(j);\n            }\n        }\n        \n        \/\/ Find all possible puzzle sizes\n        Set<Pair<Integer, Integer>> puzzleSizes = new HashSet<>();\n        for (int X = 1; X <= A; X++) {\n            if (A % X == 0) {\n                for (int Y = 1; Y <= B; Y++) {\n                    if (B % Y == 0) {\n                        boolean isGoodPuzzle = true;\n                        for (int i = 0; i < A && isGoodPuzzle; i += X) {\n                            for (int j = 0; j < B && isGoodPuzzle; j += Y) {\n                                Set<Character> piece = new HashSet<>();\n                                for (int k = i; k < i + X; k++) {\n                                    for (int l = j; l < j + Y; l++) {\n                                        piece.add(picture[k][l]);\n                                    }\n                                }\n                                if (piece.size() != X * Y) {\n                                    isGoodPuzzle = false;\n                                }\n                            }\n                        }\n                        if (isGoodPuzzle) {\n                            puzzleSizes.add(new Pair<>(X, Y));\n                        }\n                    }\n                }\n            }\n        }\n        \n        \/\/ Count the number of possible good puzzles\n        int numGoodPuzzles = puzzleSizes.size();\n        \n        \/\/ Find the smallest puzzle size\n        Pair<Integer, Integer> smallestPuzzleSize = Collections.min(puzzleSizes, new Comparator<Pair<Integer, Integer>>() {\n            @Override\n            public int compare(Pair<Integer, Integer> p1, Pair<Integer, Integer> p2) {\n                int area1 = p1.getKey() * p1.getValue();\n                int area2 = p2.getKey() * p2.getValue();\n                if (area1 != area2) {\n                    return Integer.compare(area1, area2);\n                } else {\n                    return Integer.compare(p1.getKey(), p2.getKey());\n                }\n            }\n        });\n        \n        \/\/ Print the output\n        System.out.println(numGoodPuzzles);\n        System.out.println(smallestPuzzleSize.getKey() + \" \" + smallestPuzzleSize.getValue());\n    }\n}","Python":"def count_good_puzzles(picture):\n    A, B = map(int, picture[0].split())\n    puzzle = [list(row) for row in picture[1:]]\n    \n    good_puzzles = set()\n    min_area = float('inf')\n    min_length = float('inf')\n    \n    for x in range(1, A+1):\n        if A % x == 0:\n            for y in range(1, B+1):\n                if B % y == 0:\n                    valid_puzzle = True\n                    for i in range(0, A, x):\n                        for j in range(0, B, y):\n                            piece = [row[j:j+y] for row in puzzle[i:i+x]]\n                            if piece in good_puzzles:\n                                valid_puzzle = False\n                                break\n                            good_puzzles.add(piece)\n                        if not valid_puzzle:\n                            break\n                    if valid_puzzle:\n                        area = x * y\n                        if area < min_area:\n                            min_area = area\n                            min_length = x\n                        elif area == min_area and x < min_length:\n                            min_length = x\n    \n    return '{}\\\\n{} {}'.format(len(good_puzzles), min_length, min_area)\n\n# Sample inputs\ninputs = ['2 4\\\\nABDC\\\\nABDC\\\\n', '2 6\\\\nABCCBA\\\\nABCCBA\\\\n']\n\n# Process inputs and print outputs\nfor input_str in inputs:\n    input_lines = input_str.strip().split('\\\\n')\n    output_str = count_good_puzzles(input_lines)\n    print(output_str)\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint main() {\\n    int A, B;\\n    scanf(\\\"%d %d\\\", &A, &B);\\n    char picture[A][B];\\n    for (int i = 0; i < A; i++) {\\n        scanf(\\\"%s\\\", picture[i]);\\n    }\\n\\n    int count = 0;\\n    int minArea = A * B;\\n    int minX = A;\\n\\n    for (int x = 1; x <= A; x++) {\\n        if (A % x == 0) {\\n            for (int y = 1; y <= B; y++) {\\n                if (B % y == 0) {\\n                    int valid = 1;\\n                    for (int i = 0; i < A; i += x) {\\n                        for (int j = 0; j < B; j += y) {\\n                            for (int k = i; k < i + x; k++) {\\n                                for (int l = j; l < j + y; l++) {\\n                                    if (picture[k][l] != picture[i][j]) {\\n                                        valid = 0;\\n                                        break;\\n                                    }\\n                                }\\n                                if (!valid) {\\n                                    break;\\n                                }\\n                            }\\n                            if (!valid) {\\n                                break;\\n                            }\\n                        }\\n                        if (!valid) {\\n                            break;\\n                        }\\n                    }\\n                    if (valid) {\\n                        count++;\\n                        int area = x * y;\\n                        if (area < minArea || (area == minArea && x < minX)) {\\n                            minArea = area;\\n                            minX = x;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n%d %d\\\\n\\\", count, minX, minArea \/ minX);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace PuzzleSolver\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] dimensions = input.Split(' ');\n            int A = int.Parse(dimensions[0]);\n            int B = int.Parse(dimensions[1]);\n\n            char[,] picture = new char[A, B];\n\n            for (int i = 0; i < A; i++)\n            {\n                string line = Console.ReadLine();\n                for (int j = 0; j < B; j++)\n                {\n                    picture[i, j] = line[j];\n                }\n            }\n\n            int count = CountGoodPuzzles(picture, A, B);\n            Tuple<int, int> smallestElementSize = FindSmallestElementSize(picture, A, B);\n\n            Console.WriteLine(count);\n            Console.WriteLine(smallestElementSize.Item1 + \" \" + smallestElementSize.Item2);\n        }\n\n        static int CountGoodPuzzles(char[,] picture, int A, int B)\n        {\n            HashSet<string> puzzles = new HashSet<string>();\n\n            for (int x = 1; x <= A; x++)\n            {\n                for (int y = 1; y <= B; y++)\n                {\n                    if (A % x == 0 && B % y == 0)\n                    {\n                        bool isGoodPuzzle = true;\n\n                        for (int i = 0; i < A; i += x)\n                        {\n                            for (int j = 0; j < B; j += y)\n                            {\n                                string puzzle = GetPuzzle(picture, i, j, x, y);\n\n                                if (puzzles.Contains(puzzle))\n                                {\n                                    isGoodPuzzle = false;\n                                    break;\n                                }\n\n                                puzzles.Add(puzzle);\n                            }\n\n                            if (!isGoodPuzzle)\n                            {\n                                break;\n                            }\n                        }\n\n                        if (!isGoodPuzzle)\n                        {\n                            puzzles.Clear();\n                        }\n                    }\n                }\n            }\n\n            return puzzles.Count;\n        }\n\n        static string GetPuzzle(char[,] picture, int startX, int startY, int x, int y)\n        {\n            string puzzle = \"\";\n\n            for (int i = startX; i < startX + x; i++)\n            {\n                for (int j = startY; j < startY + y; j++)\n                {\n                    puzzle += picture[i, j];\n                }\n            }\n\n            return puzzle;\n        }\n\n        static Tuple<int, int> FindSmallestElementSize(char[,] picture, int A, int B)\n        {\n            int smallestArea = A * B;\n            int smallestX = A;\n            int smallestY = B;\n\n            for (int x = 1; x <= A; x++)\n            {\n                for (int y = 1; y <= B; y++)\n                {\n                    if (A % x == 0 && B % y == 0)\n                    {\n                        bool isGoodPuzzle = true;\n\n                        for (int i = 0; i < A; i += x)\n                        {\n                            for (int j = 0; j < B; j += y)\n                            {\n                                string puzzle = GetPuzzle(picture, i, j, x, y);\n\n                                if (puzzle.Length != x * y)\n                                {\n                                    isGoodPuzzle = false;\n                                    break;\n                                }\n                            }\n\n                            if (!isGoodPuzzle)\n                            {\n                                break;\n                            }\n                        }\n\n                        if (isGoodPuzzle && x * y < smallestArea)\n                        {\n                            smallestArea = x * y;\n                            smallestX = x;\n                            smallestY = y;\n                        }\n                    }\n                }\n            }\n\n            return new Tuple<int, int>(smallestX, smallestY);\n        }\n    }\n}","Ruby":"\ndef gcd(a, b)\n  if b == 0\n    return a\n  else\n    return gcd(b, a % b)\n  end\nend\n\ndef count_good_puzzles(a, b, picture)\n  count = 0\n  min_area = a * b\n  min_x = a\n  min_y = b\n\n  for x in 1..a\n    for y in 1..b\n      if a % x == 0 && b % y == 0\n        valid = true\n        for i in 0..(a \/ x) - 1\n          for j in 0..(b \/ y) - 1\n            piece = picture[i * x, x].map { |row| row[j * y, y] }\n            if picture.include?(piece) || picture.include?(piece.transpose)\n              valid = false\n              break\n            end\n          end\n          break if !valid\n        end\n\n        if valid\n          count += 1\n          area = x * y\n          if area < min_area || (area == min_area && x < min_x)\n            min_area = area\n            min_x = x\n            min_y = y\n          end\n        end\n      end\n    end\n  end\n\n  return count, min_x, min_y\nend\n\ninput = gets.chomp.split('\\\\n')\na, b = input[0].split.map(&:to_i)\npicture = input[1..-1]\n\ncount, min_x, min_y = count_good_puzzles(a, b, picture)\n\nputs count\nputs \\\\\"\\#{min_x} \\#{min_y}\\\\\"","delphi":"program PuzzleSolver;\\n\\nvar\\n  A, B, X, Y, i, j, k, l, m, n, count: integer;\\n  picture: array[1..20, 1..20] of char;\\n  goodPuzzles: integer;\\n  minArea, minX: integer;\\n\\nbegin\\n  readln(A, B);\\n\\n  for i := 1 to A do\\n  begin\\n    for j := 1 to B do\\n    begin\\n      read(picture[i, j]);\\n    end;\\n    readln;\\n  end;\\n\\n  goodPuzzles := 1;\\n  minArea := A * B;\\n  minX := B;\\n\\n  for X := 1 to A do\\n  begin\\n    if A mod X = 0 then\\n    begin\\n      for Y := 1 to B do\\n      begin\\n        if B mod Y = 0 then\\n        begin\\n          count := 0;\\n\\n          for i := 1 to A div X do\\n          begin\\n            for j := 1 to B div Y do\\n            begin\\n              for k := 1 to X do\\n              begin\\n                for l := 1 to Y do\\n                begin\\n                  m := (i - 1) * X + k;\\n                  n := (j - 1) * Y + l;\\n\\n                  if (m <= A) and (n <= B) then\\n                  begin\\n                    if picture[m, n] = picture[k, l] then\\n                    begin\\n                      count := count + 1;\\n                      break;\\n                    end;\\n                  end;\\n                end;\\n\\n                if count > 0 then\\n                  break;\\n              end;\\n\\n              if count > 0 then\\n                break;\\n            end;\\n\\n            if count > 0 then\\n              break;\\n          end;\\n\\n          if count = 0 then\\n          begin\\n            goodPuzzles := goodPuzzles + 1;\\n\\n            if X * Y < minArea then\\n            begin\\n              minArea := X * Y;\\n              minX := X;\\n            end;\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  writeln(goodPuzzles);\\n  writeln(minX, ' ', B div minX);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar A, B int\\n\\tfmt.Scanf(\\\"%d %d\\\", &A, &B)\\n\\n\\tpicture := make([]string, A)\\n\\tfor i := 0; i < A; i++ {\\n\\t\\tfmt.Scanf(\\\"%s\\\", &picture[i])\\n\\t}\\n\\n\\tvar count int\\n\\tvar minX, minY int\\n\\tminArea := A * B\\n\\n\\tfor X := 1; X <= A; X++ {\\n\\t\\tif A%X != 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor Y := 1; Y <= B; Y++ {\\n\\t\\t\\tif B%Y != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tvalid := true\\n\\t\\t\\tvisited := make(map[string]bool)\\n\\n\\t\\t\\tfor i := 0; i < A; i += X {\\n\\t\\t\\t\\tfor j := 0; j < B; j += Y {\\n\\t\\t\\t\\t\\tpiece := strings.Join(picture[i:i+X], \\\"\\\")\\n\\t\\t\\t\\t\\tif visited[piece] {\\n\\t\\t\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvisited[piece] = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif !valid {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif valid {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t\\tarea := X * Y\\n\\t\\t\\t\\tif area < minArea {\\n\\t\\t\\t\\t\\tminArea = area\\n\\t\\t\\t\\t\\tminX = X\\n\\t\\t\\t\\t\\tminY = Y\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Printf(\\\"%d\\\\n%d %d\\\\n\\\", count, minX, minY)\\n}","Javascript":"function countGoodPuzzles(input) {\n  const lines = input.split('\\\\n');\n  const [A, B] = lines[0].split(' ').map(Number);\n  const picture = lines.slice(1, A + 1).map(line => line.split(''));\n\n  const gcd = (a, b) => {\n    if (b === 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  };\n\n  let count = 0;\n  let minArea = Infinity;\n  let minX = Infinity;\n  let minY = Infinity;\n\n  for (let x = 1; x <= A; x++) {\n    if (A % x === 0) {\n      for (let y = 1; y <= B; y++) {\n        if (B % y === 0) {\n          let valid = true;\n          for (let i = 0; i < A; i += x) {\n            for (let j = 0; j < B; j += y) {\n              const piece = [];\n              for (let k = i; k < i + x; k++) {\n                piece.push(picture[k].slice(j, j + y).join(''));\n              }\n              const rotatedPiece = piece.map(row => row.split('').reverse().join(''));\n              if (piece.join('') === rotatedPiece.join('')) {\n                valid = false;\n                break;\n              }\n            }\n            if (!valid) {\n              break;\n            }\n          }\n          if (valid) {\n            count++;\n            const area = x * y;\n            if (area < minArea || (area === minArea && x < minX)) {\n              minArea = area;\n              minX = x;\n              minY = y;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return `${count}\\\\n${minX} ${minY}`;\n}\n\nconst inputs = ['2 4\\\\nABDC\\\\nABDC\\\\n', '2 6\\\\nABCCBA\\\\nABCCBA\\\\n'];\nconst outputs = inputs.map(countGoodPuzzles);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val A = input[0].toInt()\n    val B = input[1].toInt()\n    \n    val puzzle = Array(A) { CharArray(B) }\n    for (i in 0 until A) {\n        val line = scanner.nextLine()\n        for (j in 0 until B) {\n            puzzle[i][j] = line[j]\n        }\n    }\n    \n    val goodPuzzles = findGoodPuzzles(puzzle)\n    val smallestPuzzle = findSmallestPuzzle(goodPuzzles)\n    \n    println(goodPuzzles.size)\n    println(\"${smallestPuzzle.first} ${smallestPuzzle.second}\")\n}\n\nfun findGoodPuzzles(puzzle: Array<CharArray>): List<Pair<Int, Int>> {\n    val goodPuzzles = mutableListOf<Pair<Int, Int>>()\n    val A = puzzle.size\n    val B = puzzle[0].size\n    \n    for (x in 1..A) {\n        if (A % x == 0) {\n            for (y in 1..B) {\n                if (B % y == 0) {\n                    val pieces = mutableSetOf<String>()\n                    var isValid = true\n                    \n                    for (i in 0 until A step x) {\n                        for (j in 0 until B step y) {\n                            val piece = puzzle.slice(i until i + x).map { it.slice(j until j + y).joinToString(\"\") }.joinToString(\"\\n\")\n                            if (pieces.contains(piece)) {\n                                isValid = false\n                                break\n                            }\n                            pieces.add(piece)\n                        }\n                        if (!isValid) {\n                            break\n                        }\n                    }\n                    \n                    if (isValid) {\n                        goodPuzzles.add(Pair(x, y))\n                    }\n                }\n            }\n        }\n    }\n    \n    return goodPuzzles\n}\n\nfun findSmallestPuzzle(goodPuzzles: List<Pair<Int, Int>>): Pair<Int, Int> {\n    val smallestPuzzle = goodPuzzles.minByOrNull { it.first * it.second }\n    return smallestPuzzle ?: Pair(0, 0)\n}","PHP":"<?php\\n\\n\/\/ Read input from stdin\\n$input = explode(\\\"\\\\n\\\", trim(fgets(STDIN)));\\n\\n\/\/ Extract A and B from the first line\\nlist($A, $B) = explode(\\\" \\\", $input[0]);\\n\\n\/\/ Initialize an empty array to store the puzzle pieces\\n$puzzlePieces = array();\\n\\n\/\/ Loop through the remaining lines to extract the puzzle pieces\\nfor ($i = 1; $i <= $A; $i++) {\\n    $puzzlePieces[] = str_split($input[$i]);\\n}\\n\\n\/\/ Initialize variables to store the number of good puzzles and the smallest possible element size\\n$goodPuzzles = 0;\\n$minSize = PHP_INT_MAX;\\n\\n\/\/ Loop through all possible values of X and Y\\nfor ($X = 1; $X <= $A; $X++) {\\n    for ($Y = 1; $Y <= $B; $Y++) {\\n        \/\/ Check if X and Y are divisors of A and B respectively\\n        if ($A % $X == 0 && $B % $Y == 0) {\\n            \/\/ Initialize an empty array to store the unique puzzle pieces\\n            $uniquePieces = array();\\n            $isValid = true;\\n\\n            \/\/ Loop through all puzzle pieces\\n            for ($i = 0; $i < $A; $i += $X) {\\n                for ($j = 0; $j < $B; $j += $Y) {\\n                    \/\/ Extract the current puzzle piece\\n                    $piece = array();\\n                    for ($k = $i; $k < $i + $X; $k++) {\\n                        $piece[] = array_slice($puzzlePieces[$k], $j, $Y);\\n                    }\\n\\n                    \/\/ Check if the current puzzle piece is already in the unique pieces array\\n                    if (in_array($piece, $uniquePieces)) {\\n                        $isValid = false;\\n                        break;\\n                    }\\n\\n                    \/\/ Add the current puzzle piece to the unique pieces array\\n                    $uniquePieces[] = $piece;\\n                }\\n\\n                if (!$isValid) {\\n                    break;\\n                }\\n            }\\n\\n            \/\/ If the puzzle is valid, increment the number of good puzzles and update the smallest possible element size\\n            if ($isValid) {\\n                $goodPuzzles++;\\n                $minSize = min($minSize, $X * $Y);\\n            }\\n        }\\n    }\\n}\\n\\n\/\/ Print the number of good puzzles and the smallest possible element size\\necho $goodPuzzles . \\\"\\\\n\\\";\\necho $minSize . \\\"\\\\n\\\";\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int A, B;\\r\\n    readf(\\\"%d %d\\\", &A, &B);\\r\\n\\r\\n    char[][] picture = new char[][](A);\\r\\n    foreach (ref line; picture)\\r\\n    {\\r\\n        line = readln.chomp().dup;\\r\\n    }\\r\\n\\r\\n    int count = 0;\\r\\n    int minX = A;\\r\\n    int minY = B;\\r\\n\\r\\n    for (int X = 1; X <= A; X++)\\r\\n    {\\r\\n        if (A % X != 0)\\r\\n            continue;\\r\\n\\r\\n        for (int Y = 1; Y <= B; Y++)\\r\\n        {\\r\\n            if (B % Y != 0)\\r\\n                continue;\\r\\n\\r\\n            bool[][] visited = new bool[][](A \/ X, B \/ Y);\\r\\n\\r\\n            bool valid = true;\\r\\n\\r\\n            for (int i = 0; i < A; i += X)\\r\\n            {\\r\\n                for (int j = 0; j < B; j += Y)\\r\\n                {\\r\\n                    if (visited[i \/ X][j \/ Y])\\r\\n                    {\\r\\n                        valid = false;\\r\\n                        break;\\r\\n                    }\\r\\n\\r\\n                    char[] piece = picture[i][j..j + Y];\\r\\n\\r\\n                    for (int k = i + 1; k < i + X; k++)\\r\\n                    {\\r\\n                        if (piece != picture[k][j..j + Y])\\r\\n                        {\\r\\n                            valid = false;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    if (!valid)\\r\\n                        break;\\r\\n\\r\\n                    visited[i \/ X][j \/ Y] = true;\\r\\n                }\\r\\n\\r\\n                if (!valid)\\r\\n                    break;\\r\\n            }\\r\\n\\r\\n            if (valid)\\r\\n            {\\r\\n                count++;\\r\\n                minX = min(minX, X);\\r\\n                minY = min(minY, Y);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n    writeln(minX, \\\" \\\", minY);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub count_good_puzzles {\\n    my ($A, $B, @picture) = @_;\\n    my %puzzles;\\n    my $min_area = $A * $B;\\n    my $min_length = $A;\\n\\n    for my $x (1..$A) {\\n        next if $A % $x != 0;\\n        for my $y (1..$B) {\\n            next if $B % $y != 0;\\n\\n            my %pieces;\\n            my $valid = 1;\\n\\n            for my $i (0..$A\/$x-1) {\\n                for my $j (0..$B\/$y-1) {\\n                    my $piece = '';\\n\\n                    for my $k (0..$x-1) {\\n                        for my $l (0..$y-1) {\\n                            $piece .= $picture[$i*$x+$k][$j*$y+$l];\\n                        }\\n                    }\\n\\n                    if (exists $pieces{$piece}) {\\n                        $valid = 0;\\n                        last;\\n                    }\\n\\n                    $pieces{$piece} = 1;\\n                }\\n\\n                last if !$valid;\\n            }\\n\\n            if ($valid) {\\n                my $area = $x * $y;\\n\\n                if ($area < $min_area || ($area == $min_area && $x < $min_length)) {\\n                    $min_area = $area;\\n                    $min_length = $x;\\n                }\\n\\n                $puzzles{$x}{$y} = 1;\\n            }\\n        }\\n    }\\n\\n    my $count = scalar keys %puzzles;\\n    my $output = \\\"$count\\\\n$min_length $min_area\\\\n\\\";\\n\\n    return $output;\\n}\\n\\n# Sample inputs\\nmy @inputs = (\\n    [2, 4, ['A', 'B', 'D', 'C'], ['A', 'B', 'D', 'C']],\\n    [2, 6, ['A', 'B', 'C', 'C', 'B', 'A'], ['A', 'B', 'C', 'C', 'B', 'A']],\\n);\\n\\n# Process inputs\\nmy @outputs;\\n\\nfor my $input (@inputs) {\\n    my ($A, $B, @picture) = @$input;\\n    my $output = count_good_puzzles($A, $B, @picture);\\n    push @outputs, $output;\\n}\\n\\n# Print outputs\\nfor my $output (@outputs) {\\n    print \\\"$output\\\\n\\\";\\n}\\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let dimensions: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\n    let a = dimensions[0];\n    let b = dimensions[1];\n    \n    let picture: Vec<Vec<char>> = lines[1..].iter().map(|x| x.chars().collect()).collect();\n    \n    let mut puzzles: Vec<(usize, usize)> = Vec::new();\n    \n    for x in 1..=a {\n        if a % x == 0 {\n            for y in 1..=b {\n                if b % y == 0 {\n                    let mut valid = true;\n                    for i in 0..a\/x {\n                        for j in 0..b\/y {\n                            let mut piece = Vec::new();\n                            for k in 0..x {\n                                piece.push(picture[i*x+k][j*y..(j+1)*y].to_vec());\n                            }\n                            if puzzles.contains(&(x, y)) {\n                                continue;\n                            }\n                            if puzzles.contains(&(y, x)) {\n                                continue;\n                            }\n                            if puzzles.iter().any(|p| is_same_piece(&piece, p)) {\n                                valid = false;\n                                break;\n                            }\n                        }\n                        if !valid {\n                            break;\n                        }\n                    }\n                    if valid {\n                        puzzles.push((x, y));\n                    }\n                }\n            }\n        }\n    }\n    \n    let num_puzzles = puzzles.len();\n    let smallest_puzzle = puzzles.iter().min_by_key(|&(x, y)| (x * y, x)).unwrap();\n    \n    println!(\"{}\\n{} {}\", num_puzzles, smallest_puzzle.0, smallest_puzzle.1);\n}\n\nfn is_same_piece(piece: &Vec<Vec<char>>, puzzle: &(usize, usize)) -> bool {\n    let x = puzzle.0;\n    let y = puzzle.1;\n    \n    if piece.len() != x || piece[0].len() != y {\n        return false;\n    }\n    \n    let mut rotated_piece = vec![vec!['.'; y]; x];\n    \n    for i in 0..x {\n        for j in 0..y {\n            rotated_piece[i][j] = piece[j][i];\n        }\n    }\n    \n    piece == &rotated_piece\n}"}
{"title":"C. Pie or die","description":"Volodya and Vlad play the following game. There are k pies at the cells of n\u00d7m board. Each turn Volodya moves one pie to the neighbouring (by side) cell. If the pie lies at the border of the board then Volodya can move it outside the board, get the pie and win. After Volodya's move, Vlad bans some edge at the border of the board of length 1 (between two knots of the board) so that Volodya is not able to move the pie outside the board through this edge anymore. The question is: will Volodya win this game? We suppose both players follow the optimal strategy.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"First line contains 3 integers, separated by space: 1\u2264n,m\u2264100 \u2014 dimensions of the board and 0\u2264k\u2264100 \u2014 the number of pies. Each of the next k lines contains 2 integers, separated by space: 1\u2264x\u2264n, 1\u2264y\u2264m \u2014 coordinates of the corresponding pie. There could be more than one pie at a cell. \n","output_spec":"Output only one word: \"YES\" \u2014 if Volodya wins, \"NO\" \u2014 otherwise.\n","notes":null,"sample_inputs":["2 2 1\n1 2\n","3 4 0\n","100 50 2\n50 25\n50 25\n"],"sample_outputs":["YES","NO","NO"],"id":"55-C","difficulty":1900,"tags":["games"],"src_uid":"6214a85d2be0a908dcbfe089327cf51a","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m, k;\\n    cin >> n >> m >> k;\\n    vector<vector<int>> board(n, vector<int>(m, 0));\\n    for (int i = 0; i < k; i++) {\\n        int x, y;\\n        cin >> x >> y;\\n        board[x-1][y-1]++;\\n    }\\n    bool win = false;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (board[i][j] > 0) {\\n                if (i == 0 || i == n-1 || j == 0 || j == m-1) {\\n                    win = true;\\n                    break;\\n                }\\n            }\\n        }\\n        if (win) {\\n            break;\\n        }\\n    }\\n    if (win) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] dimensions = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(dimensions[0]);\n        int m = Integer.parseInt(dimensions[1]);\n        int k = Integer.parseInt(dimensions[2]);\n        \n        int[][] board = new int[n][m];\n        \n        for (int i = 0; i < k; i++) {\n            String[] coordinates = scanner.nextLine().split(\\\" \\\");\n            int x = Integer.parseInt(coordinates[0]) - 1;\n            int y = Integer.parseInt(coordinates[1]) - 1;\n            board[x][y]++;\n        }\n        \n        boolean[][] visited = new boolean[n][m];\n        boolean win = false;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j]) {\n                    if (dfs(board, visited, i, j, n, m)) {\n                        win = true;\n                        break;\n                    }\n                }\n            }\n            if (win) {\n                break;\n            }\n        }\n        \n        if (win) {\n            System.out.println(\\\"YES\\\");\n        } else {\n            System.out.println(\\\"NO\\\");\n        }\n    }\n    \n    public static boolean dfs(int[][] board, boolean[][] visited, int x, int y, int n, int m) {\n        visited[x][y] = true;\n        \n        if (x == 0 || x == n - 1 || y == 0 || y == m - 1) {\n            return true;\n        }\n        \n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny] && board[nx][ny] > 0) {\n                if (dfs(board, visited, nx, ny, n, m)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n}","Python":"def volodya_wins(board, pies):\n    n, m = board\n    for pie in pies:\n        x, y = pie\n        if x == 1 or x == n or y == 1 or y == m:\n            return 'YES'\n    return 'NO'\n\ninputs = [['2 2 1', '1 2'], ['3 4 0'], ['100 50 2', '50 25', '50 25']]\noutputs = ['YES', 'NO', 'NO']\n\nresults = []\nfor i in range(len(inputs)):\n    input_lines = inputs[i]\n    n, m, k = map(int, input_lines[0].split())\n    board = (n, m)\n    pies = []\n    for j in range(k):\n        x, y = map(int, input_lines[j+1].split())\n        pies.append((x, y))\n    output = volodya_wins(board, pies)\n    results.append(output == outputs[i])\n\noutput = [{\"version\": \"Python 3\", \"source code\": volodya_wins.__code__.co_code.hex()}]\noutput.append({\"version\": \"Python 3\", \"source code\": results.__code__.co_code.hex()})\noutput","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\nint main() {\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n    int board[n][m];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            board[i][j] = 0;\\n        }\\n    }\\n    for (int i = 0; i < k; i++) {\\n        int x, y;\\n        scanf(\\\"%d %d\\\", &x, &y);\\n        board[x-1][y-1]++;\\n    }\\n    bool win = false;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (board[i][j] > 0) {\\n                if (i == 0 || i == n-1 || j == 0 || j == m-1) {\\n                    win = true;\\n                    break;\\n                }\\n            }\\n        }\\n        if (win) {\\n            break;\\n        }\\n    }\\n    if (win) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace VolodyaAndVladGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = { \\\"2 2 1\\n1 2\\n\\\", \\\"3 4 0\\n\\\", \\\"100 50 2\\n50 25\\n50 25\\n\\\" };\n            \n            foreach (string input in inputs)\n            {\n                string[] lines = input.Split('\\\\n');\n                string[] dimensions = lines[0].Split(' ');\n                int n = int.Parse(dimensions[0]);\n                int m = int.Parse(dimensions[1]);\n                int k = int.Parse(dimensions[2]);\n                \n                List<Tuple<int, int>> pies = new List<Tuple<int, int>>();\n                for (int i = 1; i <= k; i++)\n                {\n                    string[] coordinates = lines[i].Split(' ');\n                    int x = int.Parse(coordinates[0]);\n                    int y = int.Parse(coordinates[1]);\n                    pies.Add(new Tuple<int, int>(x, y));\n                }\n                \n                string result = VolodyaWins(n, m, pies) ? \\\"YES\\\" : \\\"NO\\\";\n                Console.WriteLine(result);\n            }\n        }\n        \n        static bool VolodyaWins(int n, int m, List<Tuple<int, int>> pies)\n        {\n            foreach (Tuple<int, int> pie in pies)\n            {\n                int x = pie.Item1;\n                int y = pie.Item2;\n                \n                if (x == 1 || x == n || y == 1 || y == m)\n                {\n                    return true;\n                }\n            }\n            \n            return false;\n        }\n    }\n}","Ruby":"\ndef volodya_wins(board, pies)\n  n, m = board[0], board[1]\n  k = board[2]\n  \n  # Create a 2D array to represent the board\n  game_board = Array.new(n) { Array.new(m, 0) }\n  \n  # Place the pies on the board\n  pies.each do |pie|\n    x, y = pie[0], pie[1]\n    game_board[x-1][y-1] += 1\n  end\n  \n  # Check if Volodya can win\n  game_board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if cell > 0\n        # Check if the pie is at the border\n        if i == 0 || i == n-1 || j == 0 || j == m-1\n          return 'YES'\n        end\n      end\n    end\n  end\n  \n  'NO'\nend\n\n# Parse the input\ninputs = ['2 2 1\\n1 2\\n', '3 4 0\\n', '100 50 2\\n50 25\\n50 25\\n']\noutputs = []\n\ninputs.each do |input|\n  lines = input.split(\"\\n\")\n  board = lines[0].split(' ').map(&:to_i)\n  pies = lines[1..-1].map { |line| line.split(' ').map(&:to_i) }\n  \n  outputs << volodya_wins(board, pies)\nend\n\noutputs\n","delphi":"Here is a possible implementation in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, k int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &k)\\n\\n\\tboard := make([][]int, n+2)\\n\\tfor i := 0; i < n+2; i++ {\\n\\t\\tboard[i] = make([]int, m+2)\\n\\t}\\n\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tvar x, y int\\n\\t\\tfmt.Scanf(\\\"%d %d\\\", &x, &y)\\n\\t\\tboard[x][y]++\\n\\t}\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tfor j := 1; j <= m; j++ {\\n\\t\\t\\tif board[i][j] > 0 {\\n\\t\\t\\t\\tif board[i-1][j] == 0 && board[i+1][j] == 0 && board[i][j-1] == 0 && board[i][j+1] == 0 {\\n\\t\\t\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(\\\"YES\\\")\\n}","Javascript":"function volodyaWins(board, pies) {\n  const [n, m] = board;\n  const visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n  \n  function dfs(x, y) {\n    if (x < 0 || x >= n || y < 0 || y >= m) {\n      return true;\n    }\n    \n    if (visited[x][y]) {\n      return false;\n    }\n    \n    visited[x][y] = true;\n    \n    const dx = [-1, 0, 1, 0];\n    const dy = [0, 1, 0, -1];\n    \n    for (let i = 0; i < 4; i++) {\n      const nx = x + dx[i];\n      const ny = y + dy[i];\n      \n      if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {\n        if (dfs(nx, ny)) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n  \n  for (const [x, y] of pies) {\n    if (dfs(x - 1, y - 1)) {\n      return 'YES';\n    }\n  }\n  \n  return 'NO';\n}\n\nconst inputs = ['2 2 1\\n1 2\\n', '3 4 0\\n', '100 50 2\\n50 25\\n50 25\\n'];\nconst outputs = [];\n\nfor (const input of inputs) {\n  const lines = input.trim().split('\\n');\n  const [n, m, k] = lines[0].split(' ').map(Number);\n  const board = [n, m];\n  const pies = [];\n\n  for (let i = 1; i <= k; i++) {\n    const [x, y] = lines[i].split(' ').map(Number);\n    pies.push([x, y]);\n  }\n\n  const result = volodyaWins(board, pies);\n  outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val dimensions = scanner.nextLine().split(\" \").map { it.toInt() }\n    val n = dimensions[0]\n    val m = dimensions[1]\n    val k = dimensions[2]\n    \n    val pies = mutableSetOf<Pair<Int, Int>>()\n    for (i in 0 until k) {\n        val coordinates = scanner.nextLine().split(\" \").map { it.toInt() }\n        val x = coordinates[0]\n        val y = coordinates[1]\n        pies.add(Pair(x, y))\n    }\n    \n    val bannedEdges = mutableSetOf<Pair<Pair<Int, Int>, Pair<Int, Int>>>()\n    for (i in 1..n) {\n        bannedEdges.add(Pair(Pair(i, 1), Pair(i, 0)))\n        bannedEdges.add(Pair(Pair(i, m), Pair(i, m + 1)))\n    }\n    for (j in 1..m) {\n        bannedEdges.add(Pair(Pair(1, j), Pair(0, j)))\n        bannedEdges.add(Pair(Pair(n, j), Pair(n + 1, j)))\n    }\n    \n    var volodyaWins = false\n    for (pie in pies) {\n        val x = pie.first\n        val y = pie.second\n        if (!bannedEdges.contains(Pair(Pair(x, y), Pair(x, y + 1))) &&\n            !bannedEdges.contains(Pair(Pair(x, y), Pair(x, y - 1))) &&\n            !bannedEdges.contains(Pair(Pair(x, y), Pair(x + 1, y))) &&\n            !bannedEdges.contains(Pair(Pair(x, y), Pair(x - 1, y)))) {\n            volodyaWins = true\n            break\n        }\n    }\n    \n    if (volodyaWins) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"<?php\\n\\nfunction volodyaWins($n, $m, $k, $pies) {\\n    \/\/ Create a 2D array to represent the board\\n    $board = array_fill(0, $n, array_fill(0, $m, 0));\\n\\n    \/\/ Place the pies on the board\\n    foreach ($pies as $pie) {\\n        $x = $pie[0] - 1;\\n        $y = $pie[1] - 1;\\n        $board[$x][$y]++;\\n    }\\n\\n    \/\/ Check if Volodya can win\\n    foreach ($pies as $pie) {\\n        $x = $pie[0] - 1;\\n        $y = $pie[1] - 1;\\n\\n        \/\/ Check if the pie is at the border\\n        if ($x == 0 || $x == $n - 1 || $y == 0 || $y == $m - 1) {\\n            return 'YES';\\n        }\\n\\n        \/\/ Check if there is a neighbouring pie at the border\\n        if ($board[$x - 1][$y] > 0 || $board[$x + 1][$y] > 0 || $board[$x][$y - 1] > 0 || $board[$x][$y + 1] > 0) {\\n            return 'YES';\\n        }\\n    }\\n\\n    return 'NO';\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    [2, 2, 1, [[1, 2]]],\\n    [3, 4, 0, []],\\n    [100, 50, 2, [[50, 25], [50, 25]]]\\n];\\n\\n\/\/ Process each input\\n$outputs = [];\\nforeach ($inputs as $input) {\\n    $n = $input[0];\\n    $m = $input[1];\\n    $k = $input[2];\\n    $pies = $input[3];\\n\\n    $result = volodyaWins($n, $m, $k, $pies);\\n    $outputs[] = $result;\\n}\\n\\n\/\/ Output the results\\nforeach ($outputs as $output) {\\n    echo $output . \\\"\\\\n\\\";\\n}\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nstruct Point {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isWinning(int n, int m, int k, Point[] pies) {\\r\\n    int[][] board = new int[][](n, m);\\r\\n    foreach (Point pie; pies) {\\r\\n        board[pie.x - 1][pie.y - 1]++;\\r\\n    }\\r\\n\\r\\n    int[][] dp = new int[][](n, m);\\r\\n    foreach (Point pie; pies) {\\r\\n        dp[pie.x - 1][pie.y - 1] = 1;\\r\\n    }\\r\\n\\r\\n    foreach (int i; 0 .. n) {\\r\\n        foreach (int j; 0 .. m) {\\r\\n            if (i > 0) {\\r\\n                dp[i][j] = max(dp[i][j], dp[i - 1][j]);\\r\\n            }\\r\\n            if (j > 0) {\\r\\n                dp[i][j] = max(dp[i][j], dp[i][j - 1]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    foreach (Point pie; pies) {\\r\\n        if (dp[pie.x - 1][pie.y - 1] == 1) {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    string[] inputs = [\\r\\n        \\\"2 2 1\\\\n1 2\\\\n\\\",\\r\\n        \\\"3 4 0\\\\n\\\",\\r\\n        \\\"100 50 2\\\\n50 25\\\\n50 25\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    string[] outputs = [\\r\\n        \\\"YES\\\",\\r\\n        \\\"NO\\\",\\r\\n        \\\"NO\\\"\\r\\n    ];\\r\\n\\r\\n    foreach (int i; 0 .. inputs.length) {\\r\\n        string[] lines = inputs[i].splitLines();\\r\\n        int[] dimensions = lines[0].split.map!(a => a.to!int).array;\\r\\n        int n = dimensions[0];\\r\\n        int m = dimensions[1];\\r\\n        int k = dimensions[2];\\r\\n\\r\\n        Point[] pies;\\r\\n        foreach (int j; 1 .. k + 1) {\\r\\n            int[] coordinates = lines[j].split.map!(a => a.to!int).array;\\r\\n            pies ~= Point(coordinates[0], coordinates[1]);\\r\\n        }\\r\\n\\r\\n        bool result = isWinning(n, m, k, pies);\\r\\n        string output = result ? \\\"YES\\\" : \\\"NO\\\";\\r\\n\\r\\n        assert(output == outputs[i]);\\r\\n    }\\r\\n\\r\\n    writeln(\\\"All test cases passed!\\\");\\r\\n}","perl":"\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $k) = split ' ', $input;\n\n# Initialize the board\nmy @board;\nfor (my $i = 0; $i < $n; $i++) {\n    for (my $j = 0; $j < $m; $j++) {\n        $board[$i][$j] = 0;\n    }\n}\n\n# Place the pies on the board\nfor (my $i = 0; $i < $k; $i++) {\n    my $pie = <STDIN>;\n    chomp $pie;\n    my ($x, $y) = split ' ', $pie;\n    $board[$x-1][$y-1]++;\n}\n\n# Check if Volodya can win\nmy $canWin = 0;\nfor (my $i = 0; $i < $n; $i++) {\n    for (my $j = 0; $j < $m; $j++) {\n        if ($board[$i][$j] > 0) {\n            if ($i == 0 || $i == $n-1 || $j == 0 || $j == $m-1) {\n                $canWin = 1;\n                last;\n            }\n        }\n    }\n    last if $canWin;\n}\n\n# Output the result\nif ($canWin) {\n    print 'YES';\n} else {\n    print 'NO';\n}\n","Rust":"fn main() {\\n    let input = \\\"2 2 1\\\\n1 2\\\\n\\\";\\n    let mut lines = input.lines();\\n    let dimensions: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = dimensions[0];\\n    let m = dimensions[1];\\n    let k = dimensions[2];\\n    let mut pies: Vec<(usize, usize)> = Vec::new();\\n\\n    for _ in 0..k {\\n        let pie: Vec<usize> = lines\\n            .next()\\n            .unwrap()\\n            .split_whitespace()\\n            .map(|x| x.parse().unwrap())\\n            .collect();\\n        pies.push((pie[0], pie[1]));\\n    }\\n\\n    let mut win = false;\\n\\n    for pie in pies {\\n        let (x, y) = pie;\\n        if x == 1 || x == n || y == 1 || y == m {\\n            win = true;\\n            break;\\n        }\\n    }\\n\\n    if win {\\n        println!(\\\"YES\\\");\\n    } else {\\n        println!(\\\"NO\\\");\\n    }\\n}"}
{"title":"D. Beautiful numbers","description":"Volodya is an odd boy and his taste is strange as well. It seems to him that a positive integer number is beautiful if and only if it is divisible by each of its nonzero digits. We will not argue with this and just count the quantity of beautiful numbers in given ranges.","input_from":"standard input","output_to":"standard output","time_limit":"4 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input contains the number of cases t (1\u2264t\u226410). Each of the next t lines contains two natural numbers li and ri (1\u2264li\u2264ri\u22649\u00b710^18).\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).\n","output_spec":"Output should contain t numbers \u2014 answers to the queries, one number per line \u2014 quantities of beautiful numbers in given intervals (from li to ri, inclusively).\n","notes":null,"sample_inputs":["1\n1 9\n","1\n12 15\n"],"sample_outputs":["9\n","2\n"],"id":"55-D","difficulty":2500,"tags":["dp","number+theory"],"src_uid":"37feadce373f728ba2a560b198ca4bc9","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\nusing namespace std;\\n\\nbool isBeautiful(long long int num) {\\n    string s = to_string(num);\\n    for (char c : s) {\\n        int digit = c - '0';\\n        if (digit == 0 || num % digit != 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint countBeautifulNumbers(long long int l, long long int r) {\\n    int count = 0;\\n    for (long long int i = l; i <= r; i++) {\\n        if (isBeautiful(i)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    int t;\\n    cin >> t;\\n    vector<pair<long long int, long long int>> queries(t);\\n    for (int i = 0; i < t; i++) {\\n        cin >> queries[i].first >> queries[i].second;\\n    }\\n    for (int i = 0; i < t; i++) {\\n        cout << countBeautifulNumbers(queries[i].first, queries[i].second) << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class BeautifulNumbers {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int t = scanner.nextInt();\\n        scanner.nextLine();\\n        for (int i = 0; i < t; i++) {\\n            long li = scanner.nextLong();\\n            long ri = scanner.nextLong();\\n            scanner.nextLine();\\n            int count = 0;\\n            for (long num = li; num <= ri; num++) {\\n                if (isBeautiful(num)) {\\n                    count++;\\n                }\\n            }\\n            System.out.println(count);\\n        }\\n    }\\n\\n    public static boolean isBeautiful(long num) {\\n        String numString = String.valueOf(num);\\n        for (int i = 0; i < numString.length(); i++) {\\n            int digit = Character.getNumericValue(numString.charAt(i));\\n            if (digit != 0 && num % digit != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}","Python":"def is_beautiful(num):\n    for digit in str(num):\n        if digit == '0' or num % int(digit) != 0:\n            return False\n    return True\n\ndef count_beautiful_numbers(l, r):\n    count = 0\n    for num in range(l, r+1):\n        if is_beautiful(num):\n            count += 1\n    return count\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    l, r = map(int, input().split())\n    results.append(count_beautiful_numbers(l, r))\n\noutput = '\\\\n'.join(map(str, results))\nprint(output)","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isBeautiful(long long int num) {\\n    long long int temp = num;\\n    while (temp > 0) {\\n        int digit = temp % 10;\\n        if (digit == 0 || num % digit != 0) {\\n            return false;\\n        }\\n        temp \/= 10;\\n    }\\n    return true;\\n}\\n\\nint countBeautifulNumbers(long long int li, long long int ri) {\\n    int count = 0;\\n    for (long long int i = li; i <= ri; i++) {\\n        if (isBeautiful(i)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    int t;\\n    scanf(\\\"%d\\\", &t);\\n    while (t--) {\\n        long long int li, ri;\\n        scanf(\\\"%lld %lld\\\", &li, &ri);\\n        int beautifulCount = countBeautifulNumbers(li, ri);\\n        printf(\\\"%d\\\\n\\\", beautifulCount);\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace BeautifulNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int t = int.Parse(Console.ReadLine());\n            List<long[]> queries = new List<long[]>();\n\n            for (int i = 0; i < t; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                long li = long.Parse(input[0]);\n                long ri = long.Parse(input[1]);\n                queries.Add(new long[] { li, ri });\n            }\n\n            foreach (var query in queries)\n            {\n                long beautifulCount = CountBeautifulNumbers(query[0], query[1]);\n                Console.WriteLine(beautifulCount);\n            }\n        }\n\n        static long CountBeautifulNumbers(long li, long ri)\n        {\n            long beautifulCount = 0;\n\n            for (long i = li; i <= ri; i++)\n            {\n                if (IsBeautiful(i))\n                {\n                    beautifulCount++;\n                }\n            }\n\n            return beautifulCount;\n        }\n\n        static bool IsBeautiful(long num)\n        {\n            string numString = num.ToString();\n\n            foreach (char digit in numString)\n            {\n                int digitValue = int.Parse(digit.ToString());\n\n                if (digitValue == 0 || num % digitValue != 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}","Ruby":"\ndef beautiful_numbers(t, ranges)\n  results = []\n  \n  ranges.each do |range|\n    count = 0\n    (range[0]..range[1]).each do |num|\n      digits = num.to_s.chars.map(&:to_i)\n      next if digits.include?(0)\n      \n      divisible = true\n      digits.each do |digit|\n        divisible = false if num % digit != 0\n      end\n      \n      count += 1 if divisible\n    end\n    \n    results << count\n  end\n  \n  results\nend\n\nt = gets.to_i\nranges = []\n\nt.times do\n  ranges << gets.split.map(&:to_i)\nend\n\noutput = beautiful_numbers(t, ranges)\noutput.each { |count| puts count }\n","delphi":"program BeautifulNumbers;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction IsBeautifulNumber(num: Int64): Boolean;\\nvar\\n  digit: Integer;\\nbegin\\n  while num > 0 do\\n  begin\\n    digit := num mod 10;\\n    if (digit = 0) or (num mod digit <> 0) then\\n    begin\\n      Result := False;\\n      Exit;\\n    end;\\n    num := num div 10;\\n  end;\\n  Result := True;\\nend;\\n\\nfunction CountBeautifulNumbersInRange(l, r: Int64): Int64;\\nvar\\n  i: Int64;\\nbegin\\n  Result := 0;\\n  for i := l to r do\\n  begin\\n    if IsBeautifulNumber(i) then\\n      Inc(Result);\\n  end;\\nend;\\n\\nvar\\n  t, i: Integer;\\n  l, r: Int64;\\nbegin\\n  ReadLn(t);\\n  for i := 1 to t do\\n  begin\\n    ReadLn(l, r);\\n    Writeln(CountBeautifulNumbersInRange(l, r));\\n  end;\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc isBeautiful(num int64) bool {\\n\\tdigits := strconv.FormatInt(num, 10)\\n\\n\\tfor _, digit := range digits {\\n\\t\\td, _ := strconv.Atoi(string(digit))\\n\\t\\tif d == 0 || num%d != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc countBeautifulNumbers(l, r int64) int {\\n\\tcount := 0\\n\\n\\tfor i := l; i <= r; i++ {\\n\\t\\tif isBeautiful(i) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n\\nfunc main() {\\n\\tvar t int\\n\\tfmt.Scan(&t)\\n\\n\\tfor i := 0; i < t; i++ {\\n\\t\\tvar l, r int64\\n\\t\\tfmt.Scan(&l, &r)\\n\\n\\t\\tcount := countBeautifulNumbers(l, r)\\n\\t\\tfmt.Println(count)\\n\\t}\\n}","Javascript":"function countBeautifulNumbers(t, cases) {\n  let results = [];\n  \n  for (let i = 0; i < t; i++) {\n    let [li, ri] = cases[i];\n    let count = 0;\n    \n    for (let num = li; num <= ri; num++) {\n      let digits = String(num).split('').map(Number);\n      let divisible = true;\n      \n      for (let digit of digits) {\n        if (digit === 0 || num % digit !== 0) {\n          divisible = false;\n          break;\n        }\n      }\n      \n      if (divisible) {\n        count++;\n      }\n    }\n    \n    results.push(count);\n  }\n  \n  return results;\n}\n\n\/\/ Example usage\nlet t = 2;\nlet cases = [[1, 9], [12, 15]];\nlet results = countBeautifulNumbers(t, cases);\nconsole.log(results);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val t = scanner.nextInt()\n    val queries = mutableListOf<Pair<Long, Long>>()\n    \n    for (i in 0 until t) {\n        val li = scanner.nextLong()\n        val ri = scanner.nextLong()\n        queries.add(Pair(li, ri))\n    }\n    \n    for (query in queries) {\n        val beautifulCount = countBeautifulNumbers(query.first, query.second)\n        println(beautifulCount)\n    }\n}\n\nfun countBeautifulNumbers(li: Long, ri: Long): Long {\n    var beautifulCount = 0L\n    \n    for (num in li..ri) {\n        if (isBeautiful(num)) {\n            beautifulCount++\n        }\n    }\n    \n    return beautifulCount\n}\n\nfun isBeautiful(num: Long): Boolean {\n    var temp = num\n    \n    while (temp > 0) {\n        val digit = temp % 10\n        \n        if (digit == 0L || num % digit != 0L) {\n            return false\n        }\n        \n        temp \/= 10\n    }\n    \n    return true\n}","PHP":"<?php\\n\\nfunction countBeautifulNumbers($t, $cases) {\\n    $results = [];\\n    for ($i = 0; $i < $t; $i++) {\\n        $range = explode(' ', $cases[$i]);\\n        $count = 0;\\n        for ($num = $range[0]; $num <= $range[1]; $num++) {\\n            $digits = str_split($num);\\n            $isBeautiful = true;\\n            foreach ($digits as $digit) {\\n                if ($digit == 0 || $num % $digit != 0) {\\n                    $isBeautiful = false;\\n                    break;\\n                }\\n            }\\n            if ($isBeautiful) {\\n                $count++;\\n            }\\n        }\\n        $results[] = $count;\\n    }\\n    return $results;\\n}\\n\\n$t = 2;\\n$cases = ['1 9', '12 15'];\\n\\n$results = countBeautifulNumbers($t, $cases);\\n\\nforeach ($results as $result) {\\n    echo $result . \\\"\\\\n\\\";\\n}\\n\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint countBeautifulNumbers(uint li, uint ri)\\r\\n{\\r\\n    int count = 0;\\r\\n    for (uint i = li; i <= ri; i++)\\r\\n    {\\r\\n        bool isBeautiful = true;\\r\\n        foreach (char digit; to!string(i))\\r\\n        {\\r\\n            if (digit == '0' || i % to!uint(digit) != 0)\\r\\n            {\\r\\n                isBeautiful = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (isBeautiful)\\r\\n            count++;\\r\\n    }\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int t;\\r\\n    readf(\\\"%d\\\", &t);\\r\\n\\r\\n    for (int i = 0; i < t; i++)\\r\\n    {\\r\\n        uint li, ri;\\r\\n        readf(\\\"%d %d\\\", &li, &ri);\\r\\n\\r\\n        int beautifulCount = countBeautifulNumbers(li, ri);\\r\\n        writeln(beautifulCount);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_beautiful_numbers {\n    my ($li, $ri) = @_;\n\n    my $count = 0;\n    for my $num ($li..$ri) {\n        my @digits = split('', $num);\n        my $divisible = 1;\n        foreach my $digit (@digits) {\n            if ($digit == 0 || $num % $digit != 0) {\n                $divisible = 0;\n                last;\n            }\n        }\n        $count++ if $divisible;\n    }\n\n    return $count;\n}\n\nmy $t = <>;\nchomp($t);\n\nmy @results;\nfor (1..$t) {\n    my ($li, $ri) = split(' ', <>);\n    chomp($ri);\n    push @results, count_beautiful_numbers($li, $ri);\n}\n\nforeach my $result (@results) {\n    print \"$result\\n\";\n}\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let t: usize = lines.next().unwrap().parse().unwrap();\n    \n    for _ in 0..t {\n        let line = lines.next().unwrap();\n        let mut nums = line.split_whitespace().map(|x| x.parse().unwrap());\n        let li = nums.next().unwrap();\n        let ri = nums.next().unwrap();\n        \n        let beautiful_count = count_beautiful_numbers(li, ri);\n        println!(\"{}\", beautiful_count);\n    }\n}\n\nfn count_beautiful_numbers(li: u64, ri: u64) -> u64 {\n    let mut count = 0;\n    \n    for num in li..=ri {\n        if is_beautiful(num) {\n            count += 1;\n        }\n    }\n    \n    count\n}\n\nfn is_beautiful(num: u64) -> bool {\n    let digits: Vec<u64> = num.to_string().chars().map(|c| c.to_digit(10).unwrap() as u64).collect();\n    \n    for digit in digits {\n        if digit == 0 {\n            continue;\n        }\n        \n        if num % digit != 0 {\n            return false;\n        }\n    }\n    \n    true\n}"}
{"title":"B. Berland National Library","description":"Berland National Library has recently been built in the capital of Berland. In addition, in the library you can take any of the collected works of Berland leaders, the library has a reading room.Today was the pilot launch of an automated reading room visitors' accounting system! The scanner of the system is installed at the entrance to the reading room. It records the events of the form \"reader entered room\", \"reader left room\". Every reader is assigned a registration number during the registration procedure at the library \u2014 it's a unique integer from 1 to 10^6. Thus, the system logs events of two forms:  \"+ ri\" \u2014 the reader with registration number ri entered the room;  \"- ri\" \u2014 the reader with registration number ri left the room. The first launch of the system was a success, it functioned for some period of time, and, at the time of its launch and at the time of its shutdown, the reading room may already have visitors.Significant funds of the budget of Berland have been spent on the design and installation of the system. Therefore, some of the citizens of the capital now demand to explain the need for this system and the benefits that its implementation will bring. Now, the developers of the system need to urgently come up with reasons for its existence.Help the system developers to find the minimum possible capacity of the reading room (in visitors) using the log of the system available to you.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains a positive integer n (1\u2264n\u2264100) \u2014 the number of records in the system log. Next follow n events from the system journal in the order in which the were made. Each event was written on a single line and looks as \"+ ri\" or \"- ri\", where ri is an integer from 1 to 10^6, the registration number of the visitor (that is, distinct visitors always have distinct registration numbers).\nIt is guaranteed that the log is not contradictory, that is, for every visitor the types of any of his two consecutive events are distinct. Before starting the system, and after stopping the room may possibly contain visitors.\n","output_spec":"Print a single integer \u2014 the minimum possible capacity of the reading room.\n","notes":"In the first sample test, the system log will ensure that at some point in the reading room were visitors with registration numbers 1, 1200 and 12001. More people were not in the room at the same time based on the log. Therefore, the answer to the test is 3.\n","sample_inputs":["6\n+ 12001\n- 12001\n- 1\n- 1200\n+ 1\n+ 7\n","2\n- 1\n- 2\n","2\n+ 1\n- 1\n"],"sample_outputs":["3","2","1"],"id":"567-B","difficulty":1300,"tags":["implementation"],"src_uid":"6cfd3b0a403212ec68bac1667bce9ef1","C++":"#include <iostream>\\n#include <unordered_set>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    unordered_set<int> visitors;\\n    vector<int> events;\\n\\n    for (int i = 0; i < n; i++) {\\n        char sign;\\n        int ri;\\n        cin >> sign >> ri;\\n\\n        if (sign == '+') {\\n            visitors.insert(ri);\\n            events.push_back(1);\\n        } else {\\n            visitors.erase(ri);\\n            events.push_back(-1);\\n        }\\n    }\\n\\n    int capacity = 0;\\n    int current = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        current += events[i];\\n        capacity = max(capacity, current);\\n    }\\n\\n    cout << capacity << endl;\\n\\n    return 0;\\n}","Java":"import java.util.HashSet;\\nimport java.util.Scanner;\\n\\npublic class ReadingRoomCapacity {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.nextLine();\\n\\n        HashSet<Integer> visitors = new HashSet<>();\\n        int maxCapacity = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            String event = scanner.nextLine();\\n            int visitorId = Integer.parseInt(event.split(\\\" \\\")[1]);\\n\\n            if (event.charAt(0) == '+') {\\n                visitors.add(visitorId);\\n                maxCapacity = Math.max(maxCapacity, visitors.size());\\n            } else {\\n                visitors.remove(visitorId);\\n            }\\n        }\\n\\n        System.out.println(maxCapacity);\\n    }\\n}","Python":"def minimum_capacity(log):\n    visitors = set()\n    max_capacity = 0\n    current_capacity = 0\n    \n    for event in log:\n        if event[0] == '+':\n            visitor = int(event[2:])\n            visitors.add(visitor)\n            current_capacity += 1\n            max_capacity = max(max_capacity, current_capacity)\n        else:\n            visitor = int(event[2:])\n            visitors.remove(visitor)\n            current_capacity -= 1\n    \n    return str(max_capacity)\n\nlog = input().split('\\\\n')\nprint(minimum_capacity(log))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int capacity = 0;\\n    int max_capacity = 0;\\n    int i;\\n    char event[3];\\n    int visitor;\\n    for (i = 0; i < n; i++) {\\n        scanf(\\\"%s %d\\\", event, &visitor);\\n        if (event[0] == '+') {\\n            capacity++;\\n            if (capacity > max_capacity) {\\n                max_capacity = capacity;\\n            }\\n        } else {\\n            capacity--;\\n        }\\n    }\\n    printf(\\\"%d\\\", max_capacity);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace ReadingRoomCapacity\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            HashSet<int> visitors = new HashSet<int>();\n            int maxCapacity = 0;\n            int currentCapacity = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] eventInfo = Console.ReadLine().Split();\n                char eventType = eventInfo[0][0];\n                int visitorId = int.Parse(eventInfo[1]);\n\n                if (eventType == '+')\n                {\n                    visitors.Add(visitorId);\n                    currentCapacity++;\n                    maxCapacity = Math.Max(maxCapacity, currentCapacity);\n                }\n                else if (eventType == '-')\n                {\n                    visitors.Remove(visitorId);\n                    currentCapacity--;\n                }\n            }\n\n            Console.WriteLine(maxCapacity);\n        }\n    }\n}","Ruby":"\ndef minimum_capacity(log)\n  # Initialize an empty set to keep track of visitors in the room\n  visitors = Set.new\n\n  # Iterate through each event in the log\n  log.each do |event|\n    # Split the event into the type (+ or -) and the registration number\n    type, registration_number = event.split(' ')\n\n    # If the event is a visitor entering the room, add them to the set\n    if type == '+'\n      visitors.add(registration_number.to_i)\n    # If the event is a visitor leaving the room, remove them from the set\n    elsif type == '-'\n      visitors.delete(registration_number.to_i)\n    end\n  end\n\n  # Return the size of the set, which represents the minimum possible capacity of the reading room\n  visitors.size\nend\n\n# Read the input from standard input\ninput = gets.chomp\n\n# Split the input into lines and remove any leading\/trailing whitespace\nlines = input.split('\\n').map(&:strip)\n\n# Call the minimum_capacity method with the log and print the result\nputs minimum_capacity(lines)\n","delphi":"program ReadingRoomCapacity;\\n\\nvar\\n  n, i, capacity, count: integer;\\n  event: string;\\n  visitors: array[1..1000000] of boolean;\\n\\nbegin\\n  readln(n);\\n  capacity := 0;\\n  count := 0;\\n\\n  for i := 1 to n do\\n  begin\\n    readln(event);\\n\\n    if event[1] = '+' then\\n    begin\\n      delete(event, 1, 2);\\n      if not visitors[StrToInt(event)] then\\n      begin\\n        visitors[StrToInt(event)] := true;\\n        count := count + 1;\\n        if count > capacity then\\n          capacity := count;\\n      end;\\n    end\\n    else\\n    begin\\n      delete(event, 1, 2);\\n      if visitors[StrToInt(event)] then\\n      begin\\n        visitors[StrToInt(event)] := false;\\n        count := count - 1;\\n      end;\\n    end;\\n  end;\\n\\n  writeln(capacity);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\tvisitors := make(map[int]bool)\\n\\tcount := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tevent := scanner.Text()\\n\\t\\tif event[0] == '+' {\\n\\t\\t\\tnum, _ := strconv.Atoi(event[2:])\\n\\t\\t\\tvisitors[num] = true\\n\\t\\t\\tcount++\\n\\t\\t} else {\\n\\t\\t\\tnum, _ := strconv.Atoi(event[2:])\\n\\t\\t\\tif visitors[num] {\\n\\t\\t\\t\\tdelete(visitors, num)\\n\\t\\t\\t\\tcount--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function minimumCapacity(log) {\n  let visitors = new Set();\n  let maxCapacity = 0;\n  \n  for (let i = 0; i < log.length; i++) {\n    let event = log[i].split(' ');\n    let action = event[0];\n    let visitor = parseInt(event[1]);\n    \n    if (action === '+') {\n      visitors.add(visitor);\n      maxCapacity = Math.max(maxCapacity, visitors.size);\n    } else {\n      visitors.delete(visitor);\n    }\n  }\n  \n  return maxCapacity;\n}\n\nlet log = ['+ 12001', '- 12001', '- 1', '- 1200', '+ 1', '+ 7'];\nlet capacity = minimumCapacity(log);\nconsole.log(capacity);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val log = mutableListOf<String>()\n    for (i in 0 until n) {\n        log.add(scanner.next())\n    }\n    \n    val visitors = mutableSetOf<Int>()\n    var maxCapacity = 0\n    var currentCapacity = 0\n    \n    for (event in log) {\n        val eventType = event[0]\n        val visitorId = event.substring(2).toInt()\n        \n        if (eventType == '+') {\n            visitors.add(visitorId)\n            currentCapacity++\n            maxCapacity = maxOf(maxCapacity, currentCapacity)\n        } else {\n            visitors.remove(visitorId)\n            currentCapacity--\n        }\n    }\n    \n    println(maxCapacity)\n}","PHP":"<?php\\n\\nfunction minimumCapacity($log) {\\n    $events = explode(\\\"\\\\n\\\", $log);\\n    $visitors = [];\\n    $capacity = 0;\\n\\n    foreach ($events as $event) {\\n        if (strpos($event, '+') !== false) {\\n            $visitor = intval(substr($event, 2));\\n            $visitors[$visitor] = true;\\n            $capacity = max($capacity, count($visitors));\\n        } else {\\n            $visitor = intval(substr($event, 2));\\n            unset($visitors[$visitor]);\\n        }\\n    }\\n\\n    return $capacity;\\n}\\n\\n$log = \\\"6\\\\n+ 12001\\\\n- 12001\\\\n- 1\\\\n- 1200\\\\n+ 1\\\\n+ 7\\\\n\\\";\\necho minimumCapacity($log);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    HashSet!int visitors;\\r\\n    int maxCapacity = 0;\\r\\n\\r\\n    foreach (_; 0 .. n)\\r\\n    {\\r\\n        char op;\\r\\n        int ri;\\r\\n        readf(\\\" %c %d\\\", &op, &ri);\\r\\n\\r\\n        if (op == '+')\\r\\n        {\\r\\n            visitors.insert(ri);\\r\\n            maxCapacity = max(maxCapacity, visitors.length);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            visitors.remove(ri);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxCapacity);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimum_capacity {\n    my ($log) = @_;\n    \n    my %visitors;\n    my $capacity = 0;\n    \n    foreach my $event (@$log) {\n        my ($type, $visitor) = split(' ', $event);\n        \n        if ($type eq '+') {\n            $visitors{$visitor} = 1;\n            $capacity = scalar(keys %visitors) if scalar(keys %visitors) > $capacity;\n        } elsif ($type eq '-') {\n            delete $visitors{$visitor};\n        }\n    }\n    \n    return $capacity;\n}\n\n# Sample inputs\nmy @inputs = (\n    ['6\\n+ 12001\\n- 12001\\n- 1\\n- 1200\\n+ 1\\n+ 7\\n'],\n    ['2\\n- 1\\n- 2\\n'],\n    ['2\\n+ 1\\n- 1\\n']\n);\n\n# Process sample inputs\nforeach my $input (@inputs) {\n    my ($log) = @$input;\n    my @events = split('\\n', $log);\n    shift @events; # Remove the first line (number of records)\n    \n    my $result = minimum_capacity(\\@events);\n    print $result.\"\\n\";\n}\n","Rust":"use std::collections::HashSet;\\n\\nfn main() {\\n    let input = \\\"6\\\\n+ 12001\\\\n- 12001\\\\n- 1\\\\n- 1200\\\\n+ 1\\\\n+ 7\\\\n\\\";\\n    let log = input.trim().split('\\\\n').collect::<Vec<_>>();\\n    let mut visitors = HashSet::new();\\n    let mut max_capacity = 0;\\n\\n    for event in log {\\n        let parts: Vec<_> = event.split(' ').collect();\\n        let action = parts[0];\\n        let visitor = parts[1].parse::<u32>().unwrap();\\n\\n        if action == \\\"+\\\" {\\n            visitors.insert(visitor);\\n            let current_capacity = visitors.len();\\n            if current_capacity > max_capacity {\\n                max_capacity = current_capacity;\\n            }\\n        } else {\\n            visitors.remove(&visitor);\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", max_capacity);\\n}"}
{"title":"A. Arrays","description":"You are given two arrays A and B consisting of integers, sorted in non-decreasing order. Check whether it is possible to choose k numbers in array A and choose m numbers in array B so that any number chosen in the first array is strictly less than any number chosen in the second array.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers nA,nB (1\u2264nA,nB\u226410^5), separated by a space \u2014 the sizes of arrays A and B, correspondingly.\nThe second line contains two integers k and m (1\u2264k\u2264nA,1\u2264m\u2264nB), separated by a space.\nThe third line contains nA numbers a1,a2,... anA (-10^9\u2264a1\u2264a2\u2264...\u2264anA\u226410^9), separated by spaces \u2014 elements of array A.\nThe fourth line contains nB integers b1,b2,... bnB (-10^9\u2264b1\u2264b2\u2264...\u2264bnB\u226410^9), separated by spaces \u2014 elements of array B.\n","output_spec":"Print \"YES\" (without the quotes), if you can choose k numbers in array A and m numbers in array B so that any number chosen in array A was strictly less than any number chosen in array B. Otherwise, print \"NO\" (without the quotes).\n","notes":"In the first sample test you can, for example, choose numbers 1 and 2 from array A and number 3 from array B (1 < 3 and 2 < 3).\nIn the second sample test the only way to choose k elements in the first array and m elements in the second one is to choose all numbers in both arrays, but then not all the numbers chosen in A will be less than all the numbers chosen in B: .\n","sample_inputs":["3 3\n2 1\n1 2 3\n3 4 5\n","3 3\n3 3\n1 2 3\n3 4 5\n","5 2\n3 1\n1 1 1 1 1\n2 2\n"],"sample_outputs":["YES\n","NO\n","YES\n"],"id":"572-A","difficulty":900,"tags":["sortings"],"src_uid":"8e0581cce19d6bf5eba30a0aebee9a08","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstring checkArrays(int nA, int nB, int k, int m, vector<int>& A, vector<int>& B) {\\n    if (A[k-1] < B[nB-m]) {\\n        return \\\"YES\\\";\\n    }\\n    return \\\"NO\\\";\\n}\\n\\nint main() {\\n    int nA, nB, k, m;\\n    cin >> nA >> nB;\\n    cin >> k >> m;\\n    vector<int> A(nA);\\n    vector<int> B(nB);\\n    for (int i = 0; i < nA; i++) {\\n        cin >> A[i];\\n    }\\n    for (int i = 0; i < nB; i++) {\\n        cin >> B[i];\\n    }\\n    string result = checkArrays(nA, nB, k, m, A, B);\\n    cout << result << endl;\\n    return 0;\\n}","Java":"import java.util.Arrays;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int nA = scanner.nextInt();\\n        int nB = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        int[] A = new int[nA];\\n        int[] B = new int[nB];\\n\\n        for (int i = 0; i < nA; i++) {\\n            A[i] = scanner.nextInt();\\n        }\\n\\n        for (int i = 0; i < nB; i++) {\\n            B[i] = scanner.nextInt();\\n        }\\n\\n        if (A[k - 1] < B[nB - m]) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n}","Python":"def check_arrays(nA, nB, k, m, A, B):\\n    if A[k-1] < B[-m]:\\n        return 'YES'\\n    else:\\n        return 'NO'\\n\\n# Sample Inputs\\ninputs = ['3 3\\\\n2 1\\\\n1 2 3\\\\n3 4 5\\\\n', '3 3\\\\n3 3\\\\n1 2 3\\\\n3 4 5\\\\n', '5 2\\\\n3 1\\\\n1 1 1 1 1\\\\n2 2\\\\n']\\n\\n# Parsing Inputs\\nnA, nB = map(int, inputs[0].split())\\nk, m = map(int, inputs[1].split())\\nA = list(map(int, inputs[2].split()))\\nB = list(map(int, inputs[3].split()))\\n\\n# Calling Function\\noutput = check_arrays(nA, nB, k, m, A, B)\\n\\n# Printing Output\\nprint(output)","C":"#include <stdio.h>\\n\\nint main() {\\n    int nA, nB, k, m;\\n    scanf(\\\"%d %d\\\", &nA, &nB);\\n    scanf(\\\"%d %d\\\", &k, &m);\\n    int A[nA], B[nB];\\n    for (int i = 0; i < nA; i++) {\\n        scanf(\\\"%d\\\", &A[i]);\\n    }\\n    for (int i = 0; i < nB; i++) {\\n        scanf(\\\"%d\\\", &B[i]);\\n    }\\n\\n    if (A[k-1] < B[nB-m]) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int nA = int.Parse(input[0]);\n        int nB = int.Parse(input[1]);\n\n        input = Console.ReadLine().Split();\n        int k = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n\n        int[] A = new int[nA];\n        int[] B = new int[nB];\n\n        input = Console.ReadLine().Split();\n        for (int i = 0; i < nA; i++)\n        {\n            A[i] = int.Parse(input[i]);\n        }\n\n        input = Console.ReadLine().Split();\n        for (int i = 0; i < nB; i++)\n        {\n            B[i] = int.Parse(input[i]);\n        }\n\n        if (A[k - 1] < B[nB - m])\n        {\n            Console.WriteLine(\"YES\");\n        }\n        else\n        {\n            Console.WriteLine(\"NO\");\n        }\n    }\n}","Ruby":"\ndef choose_numbers(nA, nB, k, m, A, B)\n  # Check if the last number in A is less than the first number in B\n  if A[-1] < B[0]\n    # Check if there are enough numbers in A and B to choose k and m numbers respectively\n    if nA >= k && nB >= m\n      return 'YES'\n    end\n  end\n  \n  return 'NO'\nend\n\n# Read input\ninput = gets.chomp.split('\\n')\nnA, nB = input[0].split(' ').map(&:to_i)\nk, m = input[1].split(' ').map(&:to_i)\nA = input[2].split(' ').map(&:to_i)\nB = input[3].split(' ').map(&:to_i)\n\n# Call the function and print the result\nputs choose_numbers(nA, nB, k, m, A, B)\n","delphi":"program ChooseNumbers;\n\nvar\n  nA, nB, k, m, i: Integer;\n  A, B: array of Integer;\n  possible: Boolean;\n\nbegin\n  \/\/ Read input\n  ReadLn(nA, nB);\n  ReadLn(k, m);\n  \n  \/\/ Initialize arrays\n  SetLength(A, nA);\n  SetLength(B, nB);\n  \n  \/\/ Read elements of array A\n  for i := 0 to nA-1 do\n    Read(A[i]);\n  \n  \/\/ Read elements of array B\n  for i := 0 to nB-1 do\n    Read(B[i]);\n  \n  \/\/ Check if it is possible to choose numbers\n  possible := (A[k-1] < B[nB-m]);\n  \n  \/\/ Print result\n  if possible then\n    WriteLn('YES')\n  else\n    WriteLn('NO');\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\n\\t\/\/ Read the input\\n\\tscanner.Scan()\\n\\tnAB := strings.Split(scanner.Text(), \\\" \\\")\\n\\tnA, _ := strconv.Atoi(nAB[0])\\n\\tnB, _ := strconv.Atoi(nAB[1])\\n\\n\\tscanner.Scan()\\n\\tkm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tk, _ := strconv.Atoi(km[0])\\n\\tm, _ := strconv.Atoi(km[1])\\n\\n\\tscanner.Scan()\\n\\tarrayA := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\tscanner.Scan()\\n\\tarrayB := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\t\/\/ Check if it is possible to choose k numbers in array A and m numbers in array B\\n\\tif arrayA[k-1] < arrayB[nB-m] {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function checkArrays(nA, nB, k, m, arrayA, arrayB) {\n    \/\/ Check if the last element of array A is less than the first element of array B\n    if (arrayA[nA - 1] < arrayB[0]) {\n        \/\/ Check if there are enough elements in array A and B to choose k and m numbers respectively\n        if (nA >= k && nB >= m) {\n            return 'YES';\n        }\n    }\n    return 'NO';\n}\n\n\/\/ Sample inputs\nconst inputs = [\n    '3 3\\n2 1\\n1 2 3\\n3 4 5\\n',\n    '3 3\\n3 3\\n1 2 3\\n3 4 5\\n',\n    '5 2\\n3 1\\n1 1 1 1 1\\n2 2\\n'\n];\n\n\/\/ Process each sample input\nconst outputs = inputs.map(input => {\n    const lines = input.trim().split('\\n');\n    const [nA, nB] = lines[0].split(' ').map(Number);\n    const [k, m] = lines[1].split(' ').map(Number);\n    const arrayA = lines[2].split(' ').map(Number);\n    const arrayB = lines[3].split(' ').map(Number);\n    \n    return checkArrays(nA, nB, k, m, arrayA, arrayB);\n});\n\n\/\/ Output the results\nconsole.log(outputs.join('\\\\n'));","Kotlin":"fun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val nA = input[0]\\n    val nB = input[1]\\n\\n    val kAndM = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val k = kAndM[0]\\n    val m = kAndM[1]\\n\\n    val arrayA = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val arrayB = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    val maxA = arrayA[k - 1]\\n    val minB = arrayB[nB - m]\\n\\n    if (maxA < minB) {\\n        println(\\\"YES\\\")\\n    } else {\\n        println(\\\"NO\\\")\\n    }\\n}","PHP":"\n<?php\n\nfunction checkArrays($nA, $nB, $k, $m, $arrayA, $arrayB) {\n    \/\/ Check if the last element of array A is less than the first element of array B\n    if ($arrayA[$nA - 1] < $arrayB[0]) {\n        \/\/ Check if there are enough elements in array A and B to choose k and m numbers respectively\n        if ($nA >= $k && $nB >= $m) {\n            return 'YES';\n        }\n    }\n    \n    return 'NO';\n}\n\n\/\/ Read input from stdin\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\n\n\/\/ Parse input\nlist($nA, $nB) = explode(' ', $input[0]);\nlist($k, $m) = explode(' ', $input[1]);\n$arrayA = array_map('intval', explode(' ', $input[2]));\n$arrayB = array_map('intval', explode(' ', $input[3]));\n\n\/\/ Call the function and print the result\n$result = checkArrays($nA, $nB, $k, $m, $arrayA, $arrayB);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nbool checkArrays(int[] A, int[] B, int k, int m)\\r\\n{\\r\\n    if (A.length < k || B.length < m)\\r\\n        return false;\\r\\n\\r\\n    int maxA = A[A.length - k];\\r\\n    int minB = B[m - 1];\\r\\n\\r\\n    return maxA < minB;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int nA, nB;\\r\\n    int k, m;\\r\\n    int[] A;\\r\\n    int[] B;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d %d\\\", &nA, &nB);\\r\\n    readf(\\\"%d %d\\\", &k, &m);\\r\\n\\r\\n    A = new int[nA];\\r\\n    B = new int[nB];\\r\\n\\r\\n    foreach (i; 0..nA)\\r\\n        readf(\\\"%d\\\", &A[i]);\\r\\n\\r\\n    foreach (i; 0..nB)\\r\\n        readf(\\\"%d\\\", &B[i]);\\r\\n\\r\\n    \/\/ Check arrays\\r\\n    bool result = checkArrays(A, B, k, m);\\r\\n\\r\\n    \/\/ Print output\\r\\n    if (result)\\r\\n        writeln(\\\"YES\\\");\\r\\n    else\\r\\n        writeln(\\\"NO\\\");\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub check_arrays {\n    my ($nA, $nB, $k, $m, @A, @B) = @_;\n\n    # Check if the number of elements in A and B is sufficient\n    if ($nA < $k || $nB < $m) {\n        return 'NO';\n    }\n\n    # Check if the largest element in A is less than the smallest element in B\n    if ($A[$k-1] >= $B[$m-1]) {\n        return 'NO';\n    }\n\n    return 'YES';\n}\n\n# Read input\nmy ($nA, $nB) = split ' ', <>;\nmy ($k, $m) = split ' ', <>;\nmy @A = split ' ', <>;\nmy @B = split ' ', <>;\n\n# Call the check_arrays function\nmy $result = check_arrays($nA, $nB, $k, $m, @A, @B);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut input = input.split_whitespace();\n    let n_a: usize = input.next().unwrap().parse().unwrap();\n    let n_b: usize = input.next().unwrap().parse().unwrap();\n\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut input = input.split_whitespace();\n    let k: usize = input.next().unwrap().parse().unwrap();\n    let m: usize = input.next().unwrap().parse().unwrap();\n\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let a: Vec<i64> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let b: Vec<i64> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n\n    if a[k - 1] < b[n_b - m] {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"A. Square Earth?","description":"Meg the Rabbit decided to do something nice, specifically \u2014 to determine the shortest distance between two points on the surface of our planet. But Meg... what can you say, she wants everything simple. So, she already regards our planet as a two-dimensional circle. No, wait, it's even worse \u2014 as a square of side n. Thus, the task has been reduced to finding the shortest path between two dots on a square (the path should go through the square sides). To simplify the task let us consider the vertices of the square to lie at points whose coordinates are: (0,0), (n,0), (0,n) and (n,n).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The single line contains 5 space-separated integers: n,x1,y1,x2,y2 (1\u2264n\u22641000,0\u2264x1,y1,x2,y2\u2264n) which correspondingly represent a side of the square, the coordinates of the first point and the coordinates of the second point. It is guaranteed that the points lie on the sides of the square.\n","output_spec":"You must print on a single line the shortest distance between the points.\n","notes":null,"sample_inputs":["2 0 0 1 0\n","2 0 1 2 1\n","100 0 0 100 100\n"],"sample_outputs":["1\n","4\n","200\n"],"id":"57-A","difficulty":1300,"tags":["dfs+and+similar","greedy","implementation"],"src_uid":"685fe16c217b5b71eafdb4198822250e","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, x1, y1, x2, y2;\\n    cin >> n >> x1 >> y1 >> x2 >> y2;\\n\\n    int dx = abs(x1 - x2);\\n    int dy = abs(y1 - y2);\\n\\n    int minDist = min(dx, dy);\\n    int maxDist = max(dx, dy);\\n\\n    int diagonalDist = minDist * 2 + maxDist;\\n    int straightDist = maxDist - minDist;\\n\\n    int shortestDist = diagonalDist + straightDist;\\n\\n    cout << shortestDist << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ShortestDistance {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] inputs = input.split(\\\" \\\");\\n        int n = Integer.parseInt(inputs[0]);\\n        int x1 = Integer.parseInt(inputs[1]);\\n        int y1 = Integer.parseInt(inputs[2]);\\n        int x2 = Integer.parseInt(inputs[3]);\\n        int y2 = Integer.parseInt(inputs[4]);\\n\\n        int distance = calculateShortestDistance(n, x1, y1, x2, y2);\\n        System.out.println(distance);\\n    }\\n\\n    public static int calculateShortestDistance(int n, int x1, int y1, int x2, int y2) {\\n        int distance = 0;\\n\\n        if (x1 == x2) {\\n            distance = Math.abs(y1 - y2);\\n        } else if (y1 == y2) {\\n            distance = Math.abs(x1 - x2);\\n        } else {\\n            int diagonalDistance = Math.min(Math.abs(x1 - x2), Math.abs(y1 - y2));\\n            int remainingDistance = Math.abs(x1 - x2) + Math.abs(y1 - y2) - 2 * diagonalDistance;\\n            distance = diagonalDistance + remainingDistance;\\n        }\\n\\n        return distance;\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.util.Scanner;\\n\\npublic class ShortestDistance {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] inputs = input.split(\\\" \\\");\\n        int n = Integer.parseInt(inputs[0]);\\n        int x1 = Integer.parseInt(inputs[1]);\\n        int y1 = Integer.parseInt(inputs[2]);\\n        int x2 = Integer.parseInt(inputs[3]);\\n        int y2 = Integer.parseInt(inputs[4]);\\n\\n        int distance = calculateShortestDistance(n, x1, y1, x2, y2);\\n        System.out.println(distance);\\n    }\\n\\n    public static int calculateShortestDistance(int n, int x1, int y1, int x2, int y2) {\\n        int distance = 0;\\n\\n        if (x1 == x2) {\\n            distance = Math.abs(y1 - y2);\\n        } else if (y1 == y2) {\\n            distance = Math.abs(x1 - x2);\\n        } else {\\n            int diagonalDistance = Math.min(Math.abs(x1 - x2), Math.abs(y1 - y2));\\n            int remainingDistance = Math.abs(x1 - x2) + Math.abs(y1 - y2) - 2 * diagonalDistance;\\n            distance = diagonalDistance + remainingDistance;\\n        }\\n\\n        return distance;\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.util.Scanner;\\n\\npublic class ShortestDistance {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] inputs = input.split(\\\" \\\");\\n        int n = Integer.parseInt(inputs[0]);\\n        int x1 = Integer.parseInt(inputs[1]);\\n        int y1 = Integer.parseInt(inputs[2]);\\n        int x2 = Integer.parseInt(inputs[3]);\\n        int y2 = Integer.parseInt(inputs[4]);\\n\\n        int distance = calculateShortestDistance(n, x1, y1, x2, y2);\\n        System.out.println(distance);\\n    }\\n\\n    public static int calculateShortestDistance(int n, int x1, int y1, int x2, int y2) {\\n        int distance = 0;\\n\\n        if (x1 == x2) {\\n            distance = Math.abs(y1 - y2);\\n        } else if (y1 == y2) {\\n            distance = Math.abs(x1 - x2);\\n        } else {\\n            int diagonalDistance = Math.min(Math.abs(x1 - x2), Math.abs(y1 - y2));\\n            int remainingDistance = Math.abs(x1 - x2) + Math.abs(y1 - y2) - 2 * diagonalDistance;\\n            distance = diagonalDistance + remainingDistance;\\n        }\\n\\n        return distance;\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.util.Scanner;\\n\\npublic class ShortestDistance {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] inputs = input.split(\\\" \\\");\\n        int n = Integer.parseInt(inputs[0]);\\n        int x1 = Integer.parseInt(inputs[1]);\\n        int y1 = Integer.parseInt(inputs[2]);\\n        int x2 = Integer.parseInt(inputs[3]);\\n        int y2 = Integer.parseInt(inputs[4]);\\n\\n        int distance = calculateShortestDistance(n, x1, y1, x2, y2);\\n        System.out.println(distance);\\n    }\\n\\n    public static int calculateShortestDistance(int n, int x1, int y1, int x2, int y2) {\\n        int distance = 0;\\n\\n        if (x1 == x2) {\\n            distance = Math.abs(y1 - y2);\\n        } else if (y1 == y2) {\\n            distance = Math.abs(x1 - x2);\\n        } else {\\n            int diagonalDistance = Math.min(Math.abs(x1 - x2), Math.abs(y1 - y2));\\n            int remainingDistance = Math.abs(x1 - x2) + Math.abs(y1 - y2) - 2 * diagonalDistance;\\n            distance = diagonalDistance + remainingDistance;\\n        }\\n\\n        return distance;\\n    }\\n}","Python":"import math\\n\\n# Function to calculate the shortest distance between two points on a square\\n\\ndef shortest_distance(n, x1, y1, x2, y2):\\n    # Calculate the distance between the points on the same side of the square\\n    if x1 == x2 or y1 == y2:\\n        return abs(x1 - x2) + abs(y1 - y2)\\n    \\n    # Calculate the distance between the points on different sides of the square\\n    else:\\n        distance1 = abs(x1 - x2) + abs(y1 - y2)\\n        distance2 = abs(x1 - n) + abs(y1 - n) + abs(x2 - n) + abs(y2 - n)\\n        distance3 = abs(x1 - n) + abs(y1 - n) + abs(x2 - n) + abs(y2)\\n        distance4 = abs(x1 - n) + abs(y1) + abs(x2 - n) + abs(y2 - n)\\n        distance5 = abs(x1) + abs(y1 - n) + abs(x2 - n) + abs(y2 - n)\\n        \\n        return min(distance1, distance2, distance3, distance4, distance5)\\n\\n# Read input\\ninput_data = input().split()\\nn = int(input_data[0])\\nx1 = int(input_data[1])\\ny1 = int(input_data[2])\\nx2 = int(input_data[3])\\ny2 = int(input_data[4])\\n\\n# Calculate and print the shortest distance\\nprint(shortest_distance(n, x1, y1, x2, y2))","C":"#include <stdio.h>\\n#include <math.h>\\n\\nint main() {\\n    int n, x1, y1, x2, y2;\\n    scanf(\\\"%d %d %d %d %d\\\", &n, &x1, &y1, &x2, &y2);\\n    int dx = abs(x1 - x2);\\n    int dy = abs(y1 - y2);\\n    int minDist = fmin(dx, dy);\\n    int maxDist = fmax(dx, dy);\\n    int diagonalDist = maxDist - minDist;\\n    int shortestDist = minDist + diagonalDist;\\n    printf(\\\"%d\\\\n\\\", shortestDist);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] inputs = { \\\"2 0 0 1 0\\\", \\\"2 0 1 2 1\\\", \\\"100 0 0 100 100\\\" };\n        \n        foreach (string input in inputs)\n        {\n            string[] values = input.Split(' ');\n            int n = int.Parse(values[0]);\n            int x1 = int.Parse(values[1]);\n            int y1 = int.Parse(values[2]);\n            int x2 = int.Parse(values[3]);\n            int y2 = int.Parse(values[4]);\n            \n            int distance = CalculateShortestDistance(n, x1, y1, x2, y2);\n            \n            Console.WriteLine(distance);\n        }\n    }\n    \n    public static int CalculateShortestDistance(int n, int x1, int y1, int x2, int y2)\n    {\n        int dx = Math.Abs(x1 - x2);\n        int dy = Math.Abs(y1 - y2);\n        \n        return dx + dy;\n    }\n}","Ruby":"def shortest_distance(input)\n  n, x1, y1, x2, y2 = input.split.map(&:to_i)\n  \n  if x1 == x2 || y1 == y2\n    distance = (x1 - x2).abs + (y1 - y2).abs\n  else\n    distance = (x1 - x2).abs + (y1 - y2).abs + 2\n  end\n  \n  distance.to_s\nend\n\ninputs = ['2 0 0 1 0\\n', '2 0 1 2 1\\n', '100 0 0 100 100\\n']\noutputs = []\n\ninputs.each do |input|\n  outputs << shortest_distance(input)\nend\n\noutputs.to_json","delphi":"program ShortestDistance;\n\nvar\n  n, x1, y1, x2, y2: Integer;\n  distance: Integer;\n\nbegin\n  \/\/ Read input values\n  ReadLn(n, x1, y1, x2, y2);\n  \n  \/\/ Calculate the shortest distance\n  if x1 = x2 then\n    distance := Abs(y1 - y2)\n  else if y1 = y2 then\n    distance := Abs(x1 - x2)\n  else\n    distance := Abs(x1 - x2) + Abs(y1 - y2);\n  \n  \/\/ Print the result\n  WriteLn(distance);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, x1, y1, x2, y2 int\\n\\tfmt.Scanf(\\\"%d %d %d %d %d\\\", &n, &x1, &y1, &x2, &y2)\\n\\n\\tdx := math.Abs(float64(x1 - x2))\\n\\tdy := math.Abs(float64(y1 - y2))\\n\\n\\tif dx > dy {\\n\\t\\tfmt.Println(dx)\\n\\t} else {\\n\\t\\tfmt.Println(dy)\\n\\t}\\n}","Javascript":"function shortestDistance(input) {\n  const [n, x1, y1, x2, y2] = input.split(' ').map(Number);\n  \n  \/\/ Calculate the distance between the points\n  const distance = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n  \n  return distance.toString();\n}\n\nconst inputs = ['2 0 0 1 0\\n', '2 0 1 2 1\\n', '100 0 0 100 100\\n'];\nconst outputs = inputs.map(shortestDistance);\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val n = input[0]\n    val x1 = input[1]\n    val y1 = input[2]\n    val x2 = input[3]\n    val y2 = input[4]\n    \n    val distance = Math.abs(x1 - x2) + Math.abs(y1 - y2)\n    println(distance)\n}","PHP":"<?php\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = $input[0];\\n$x1 = $input[1];\\n$y1 = $input[2];\\n$x2 = $input[3];\\n$y2 = $input[4];\\n\\n$distance = abs($x1 - $x2) + abs($y1 - $y2);\\n\\necho $distance;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\\"2 0 0 1 0\\\", \\\"2 0 1 2 1\\\", \\\"100 0 0 100 100\\\"];\\r\\n    foreach (string input; inputs)\\r\\n    {\\r\\n        int n, x1, y1, x2, y2;\\r\\n        sscanf(input, \\\"%d %d %d %d %d\\\", &n, &x1, &y1, &x2, &y2);\\r\\n\\r\\n        int distance;\\r\\n        if (x1 == x2)\\r\\n        {\\r\\n            distance = abs(y1 - y2);\\r\\n        }\\r\\n        else if (y1 == y2)\\r\\n        {\\r\\n            distance = abs(x1 - x2);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            int diagonalDistance = abs(x1 - x2) + abs(y1 - y2);\\r\\n            int sideDistance = min(x1 + x2, 2 * n - x1 - x2) + min(y1 + y2, 2 * n - y1 - y2);\\r\\n            distance = min(diagonalDistance, sideDistance);\\r\\n        }\\r\\n\\r\\n        writeln(to!string(distance));\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub shortest_distance {\\n    my ($n, $x1, $y1, $x2, $y2) = @_;\\n\\n    my $distance = 0;\\n\\n    # Calculate the shortest distance\\n    if ($x1 == $x2) {\\n        $distance = abs($y2 - $y1);\\n    }\\n    elsif ($y1 == $y2) {\\n        $distance = abs($x2 - $x1);\\n    }\\n    else {\\n        my $dx = abs($x2 - $x1);\\n        my $dy = abs($y2 - $y1);\\n        $distance = $dx + $dy;\\n    }\\n\\n    return $distance;\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\n\\n# Parse input\\nmy ($n, $x1, $y1, $x2, $y2) = split ' ', $input;\\n\\n# Calculate and print the shortest distance\\nmy $result = shortest_distance($n, $x1, $y1, $x2, $y2);\\nprint $result . \\\"\\\\n\\\";\\n","Rust":"fn main() {\n    let input = String::from(\"2 0 0 1 0\\n\");\n    let mut input = input.split_whitespace();\n    let n: i32 = input.next().unwrap().parse().unwrap();\n    let x1: i32 = input.next().unwrap().parse().unwrap();\n    let y1: i32 = input.next().unwrap().parse().unwrap();\n    let x2: i32 = input.next().unwrap().parse().unwrap();\n    let y2: i32 = input.next().unwrap().parse().unwrap();\n\n    let distance = (x1 - x2).abs() + (y1 - y2).abs();\n    println!(\"{}\", distance);\n}"}
{"title":"A. Word","description":"Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP \u2014 with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a word s \u2014 it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.\n","output_spec":"Print the corrected word s. If the given word s has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.\n","notes":null,"sample_inputs":["HoUse\n","ViP\n","maTRIx\n"],"sample_outputs":["house\n","VIP\n","matrix\n"],"id":"59-A","difficulty":800,"tags":["implementation","strings"],"src_uid":"b432dfa66bae2b542342f0b42c0a2598","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nstring correctWord(string word) {\\n    int upperCount = 0;\\n    int lowerCount = 0;\\n\\n    for (char c : word) {\\n        if (isupper(c)) {\\n            upperCount++;\\n        } else {\\n            lowerCount++;\\n        }\\n    }\\n\\n    if (upperCount > lowerCount) {\\n        for (char& c : word) {\\n            c = toupper(c);\\n        }\\n    } else {\\n        for (char& c : word) {\\n            c = tolower(c);\\n        }\\n    }\\n\\n    return word;\\n}\\n\\nint main() {\\n    string word;\\n    cin >> word;\\n\\n    string correctedWord = correctWord(word);\\n    cout << correctedWord << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ChangeWordRegister {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String word = scanner.nextLine();\\n        int uppercaseCount = 0;\\n        int lowercaseCount = 0;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n            if (Character.isUpperCase(word.charAt(i))) {\\n                uppercaseCount++;\\n            } else {\\n                lowercaseCount++;\\n            }\\n        }\\n\\n        if (uppercaseCount > lowercaseCount) {\\n            System.out.println(word.toUpperCase());\\n        } else {\\n            System.out.println(word.toLowerCase());\\n        }\\n    }\\n}","Python":"def change_case(word):\n    uppercase_count = 0\n    lowercase_count = 0\n    \n    for letter in word:\n        if letter.isupper():\n            uppercase_count += 1\n        else:\n            lowercase_count += 1\n    \n    if uppercase_count > lowercase_count:\n        return word.upper()\n    else:\n        return word.lower()\n\nword = input().strip()\nprint(change_case(word))","C":"#include <stdio.h>\\n#include <ctype.h>\\n#include <string.h>\\n\\nvoid changeCase(char* word) {\\n    int uppercaseCount = 0;\\n    int lowercaseCount = 0;\\n    int length = strlen(word);\\n\\n    for (int i = 0; i < length; i++) {\\n        if (isupper(word[i])) {\\n            uppercaseCount++;\\n        } else {\\n            lowercaseCount++;\\n        }\\n    }\\n\\n    if (uppercaseCount > lowercaseCount) {\\n        for (int i = 0; i < length; i++) {\\n            word[i] = toupper(word[i]);\\n        }\\n    } else {\\n        for (int i = 0; i < length; i++) {\\n            word[i] = tolower(word[i]);\\n        }\\n    }\\n}\\n\\nint main() {\\n    char word[101];\\n    fgets(word, sizeof(word), stdin);\\n    changeCase(word);\\n    printf(\\\"%s\\\", word);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string word = Console.ReadLine().Trim();\n        int uppercaseCount = 0;\n        int lowercaseCount = 0;\n        \n        foreach (char c in word)\n        {\n            if (char.IsUpper(c))\n            {\n                uppercaseCount++;\n            }\n            else\n            {\n                lowercaseCount++;\n            }\n        }\n        \n        if (uppercaseCount > lowercaseCount)\n        {\n            Console.WriteLine(word.ToUpper());\n        }\n        else\n        {\n            Console.WriteLine(word.ToLower());\n        }\n    }\n}","Ruby":"def change_case(word)\\n  uppercase_count = word.scan(\/[A-Z]\/).size\\n  lowercase_count = word.scan(\/[a-z]\/).size\\n\\n  if uppercase_count > lowercase_count\\n    word.upcase\\n  else\\n    word.downcase\\n  end\\nend\\n\\nword = gets.chomp\\nputs change_case(word)","delphi":"program ChangeCase;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction CorrectWord(s: string): string;\\nvar\\n  uppercaseCount, lowercaseCount: Integer;\\n  i: Integer;\\nbegin\\n  uppercaseCount := 0;\\n  lowercaseCount := 0;\\n\\n  \/\/ Count the number of uppercase and lowercase letters\\n  for i := 1 to Length(s) do\\n  begin\\n    if s[i] in ['A'..'Z'] then\\n      Inc(uppercaseCount)\\n    else if s[i] in ['a'..'z'] then\\n      Inc(lowercaseCount);\\n  end;\\n\\n  \/\/ Determine the corrected word\\n  if uppercaseCount > lowercaseCount then\\n    Result := UpperCase(s)\\n  else\\n    Result := LowerCase(s);\\nend;\\n\\nvar\\n  word: string;\\nbegin\\n  \/\/ Read the word from input\\n  ReadLn(word);\\n\\n  \/\/ Correct the word and print the result\\n  WriteLn(CorrectWord(word));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar word string\\n\\tfmt.Scan(&word)\\n\\n\\tupperCount := 0\\n\\tlowerCount := 0\\n\\n\\tfor _, char := range word {\\n\\t\\tif strings.ToUpper(string(char)) == string(char) {\\n\\t\\t\\tupperCount++\\n\\t\\t} else {\\n\\t\\t\\tlowerCount++\\n\\t\\t}\\n\\t}\\n\\n\\tif upperCount > lowerCount {\\n\\t\\tfmt.Println(strings.ToUpper(word))\\n\\t} else {\\n\\t\\tfmt.Println(strings.ToLower(word))\\n\\t}\\n}","Javascript":"function changeCase(word) {\n  var uppercaseCount = 0;\n  var lowercaseCount = 0;\n  \n  \/\/ Count the number of uppercase and lowercase letters in the word\n  for (var i = 0; i < word.length; i++) {\n    if (word[i] === word[i].toUpperCase()) {\n      uppercaseCount++;\n    } else {\n      lowercaseCount++;\n    }\n  }\n  \n  \/\/ If there are more uppercase letters, convert the word to uppercase\n  if (uppercaseCount > lowercaseCount) {\n    return word.toUpperCase();\n  } else {\n    return word.toLowerCase();\n  }\n}\n\n\/\/ Test cases\nconsole.log(changeCase('HoUse')); \/\/ Output: house\nconsole.log(changeCase('ViP')); \/\/ Output: VIP\nconsole.log(changeCase('maTRIx')); \/\/ Output: matrix","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val word = scanner.nextLine()\n    val uppercaseCount = word.count { it.isUpperCase() }\n    val lowercaseCount = word.count { it.isLowerCase() }\n    \n    val correctedWord = if (uppercaseCount > lowercaseCount) {\n        word.toUpperCase()\n    } else {\n        word.toLowerCase()\n    }\n    \n    println(correctedWord)\n}","PHP":"<?php\\n\\nfunction changeCase($word) {\\n    $upperCount = 0;\\n    $lowerCount = 0;\\n\\n    \/\/ Count the number of uppercase and lowercase letters\\n    for ($i = 0; $i < strlen($word); $i++) {\\n        if (ctype_upper($word[$i])) {\\n            $upperCount++;\\n        } else {\\n            $lowerCount++;\\n        }\\n    }\\n\\n    \/\/ If there are more uppercase letters, convert the word to uppercase\\n    if ($upperCount > $lowerCount) {\\n        return strtoupper($word);\\n    }\\n\\n    \/\/ If there are more lowercase letters or an equal number of uppercase and lowercase letters, convert the word to lowercase\\n    return strtolower($word);\\n}\\n\\n\/\/ Test cases\\n$words = ['HoUse', 'ViP', 'maTRIx'];\\n\\nforeach ($words as $word) {\\n    echo changeCase($word) . \\\"\\\\n\\\";\\n}\\n","d":"import std.stdio;\\r\\n\\r\\nstring changeWordRegister(string word)\\r\\n{\\r\\n    int uppercaseCount = 0;\\r\\n    int lowercaseCount = 0;\\r\\n\\r\\n    foreach (char c; word)\\r\\n    {\\r\\n        if (c.isUpper)\\r\\n            uppercaseCount++;\\r\\n        else\\r\\n            lowercaseCount++;\\r\\n    }\\r\\n\\r\\n    if (uppercaseCount > lowercaseCount)\\r\\n        return word.toUpper;\\r\\n    else\\r\\n        return word.toLower;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string word = readln.chomp;\\r\\n    string correctedWord = changeWordRegister(word);\\r\\n    writeln(correctedWord);\\r\\n}","perl":"\n# Read the input word\nmy $word = <STDIN>;\nchomp $word;\n\n# Count the number of uppercase and lowercase letters\nmy $uppercase_count = ($word =~ tr\/A-Z\/\/);\nmy $lowercase_count = ($word =~ tr\/a-z\/\/);\n\n# If there are more uppercase letters, convert the word to uppercase\nif ($uppercase_count > $lowercase_count) {\n    $word = uc $word;\n}\n# Otherwise, convert the word to lowercase\nelse {\n    $word = lc $word;\n}\n\n# Print the corrected word\nprint $word;\n","Rust":"fn main() {\n    let mut word = String::new();\n    std::io::stdin().read_line(&mut word).unwrap();\n    word = word.trim().to_string();\n    \n    let mut uppercase_count = 0;\n    let mut lowercase_count = 0;\n    \n    for c in word.chars() {\n        if c.is_ascii_uppercase() {\n            uppercase_count += 1;\n        } else {\n            lowercase_count += 1;\n        }\n    }\n    \n    if uppercase_count > lowercase_count {\n        println!(\"{}\", word.to_ascii_uppercase());\n    } else {\n        println!(\"{}\", word.to_ascii_lowercase());\n    }\n}"}
{"title":"A. The Two Routes","description":"In Absurdistan, there are n towns (numbered 1 through n) and m bidirectional railways. There is also an absurdly simple road network\u00a0\u2014 for each pair of different towns x and y, there is a bidirectional road between towns x and y if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.A train and a bus leave town 1 at the same time. They both have the same destination, town n, and don't make any stops on the way (but they can wait in town n). The train can move only along railways and the bus can move only along roads.You've been asked to plan out routes for the vehicles; each route can use any road\/railway multiple times. One of the most important aspects to consider is safety\u00a0\u2014 in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town n) simultaneously.Under these constraints, what is the minimum number of hours needed for both vehicles to reach town n (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town n at the same moment of time, but are allowed to do so.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input contains two integers n and m (2\u2264n\u2264400, 0\u2264m\u2264n(n-1)\/2)\u00a0\u2014 the number of towns and the number of railways respectively.\nEach of the next m lines contains two integers u and v, denoting a railway between towns u and v (1\u2264u,v\u2264n, u\u2260v).\nYou may assume that there is at most one railway connecting any two towns.\n","output_spec":"Output one integer\u00a0\u2014 the smallest possible time of the later vehicle's arrival in town n. If it's impossible for at least one of the vehicles to reach town n, output -1.\n","notes":"In the first sample, the train can take the route  and the bus can take the route . Note that they can arrive at town 4 at the same time.\nIn the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.\n","sample_inputs":["4 2\n1 3\n3 4\n","4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n","5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n"],"sample_outputs":["2\n","-1\n","3\n"],"id":"601-A","difficulty":1600,"tags":["graphs","shortest+paths"],"src_uid":"fbfc333ad4b0a750f654a00be84aea67","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <climits>\\nusing namespace std;\\n\\nconst int INF = INT_MAX;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<int>> adj(n+1);\\n    vector<bool> visited(n+1, false);\\n    vector<int> dist(n+1, INF);\\n\\n    for (int i = 0; i < m; i++) {\\n        int u, v;\\n        cin >> u >> v;\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n\\n    queue<int> q;\\n    q.push(1);\\n    visited[1] = true;\\n    dist[1] = 0;\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n\\n        for (int v : adj[u]) {\\n            if (!visited[v]) {\\n                visited[v] = true;\\n                dist[v] = dist[u] + 1;\\n                q.push(v);\\n            }\\n        }\\n    }\\n\\n    if (dist[n] == INF) {\\n        cout << -1 << endl;\\n    } else {\\n        cout << dist[n] << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        List<List<Integer>> railways = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            railways.add(Arrays.asList(u, v));\n        }\n        \n        int[] distances = new int[n + 1];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[1] = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            for (List<Integer> railway : railways) {\n                int u = railway.get(0);\n                int v = railway.get(1);\n                if (distances[u] != Integer.MAX_VALUE && distances[u] + 1 < distances[v]) {\n                    distances[v] = distances[u] + 1;\n                }\n                if (distances[v] != Integer.MAX_VALUE && distances[v] + 1 < distances[u]) {\n                    distances[u] = distances[v] + 1;\n                }\n            }\n        }\n        \n        if (distances[n] == Integer.MAX_VALUE) {\n            System.out.println(-1);\n        } else {\n            System.out.println(distances[n]);\n        }\n    }\n}","Python":"from collections import defaultdict\\n\\ndef find_min_arrival_time(n, m, railways):\\n    # Create an adjacency list to represent the railway connections\\n    adj_list = defaultdict(list)\\n    for u, v in railways:\\n        adj_list[u].append(v)\\n        adj_list[v].append(u)\\n    \\n    # Perform a breadth-first search to find the shortest path from town 1 to town n\\n    queue = [(1, 0)]\\n    visited = set()\\n    while queue:\\n        town, time = queue.pop(0)\\n        if town == n:\\n            return time\\n        visited.add(town)\\n        for neighbor in adj_list[town]:\\n            if neighbor not in visited:\\n                queue.append((neighbor, time + 1))\\n    \\n    # If there is no path from town 1 to town n, return -1\\n    return -1\\n\\n\\n# Sample inputs\\ninputs = ['4 2\\\\n1 3\\\\n3 4\\\\n', '4 6\\\\n1 2\\\\n1 3\\\\n1 4\\\\n2 3\\\\n2 4\\\\n3 4\\\\n', '5 5\\\\n4 2\\\\n3 5\\\\n4 5\\\\n5 1\\\\n1 2\\\\n']\\n\\n# Process each input\\noutputs = []\\nfor input_str in inputs:\\n    input_lines = input_str.strip().split('\\\\n')\\n    n, m = map(int, input_lines[0].split())\\n    railways = [tuple(map(int, line.split())) for line in input_lines[1:]]\\n    output = find_min_arrival_time(n, m, railways)\\n    outputs.append(str(output))\\n\\n# Format outputs\\noutput_str = '\\\\n'.join(outputs)\\n\\n# Print the outputs\\nprint(output_str)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdbool.h>\\n\\n#define MAX_TOWNS 400\\n\\nbool graph[MAX_TOWNS][MAX_TOWNS];\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n\\n    \/\/ Initialize graph\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            graph[i][j] = false;\\n        }\\n    }\\n\\n    \/\/ Read railways\\n    for (int i = 0; i < m; i++) {\\n        int u, v;\\n        scanf(\\\"%d %d\\\", &u, &v);\\n        graph[u-1][v-1] = true;\\n        graph[v-1][u-1] = true;\\n    }\\n\\n    \/\/ Check if there is a road between every pair of towns\\n    for (int i = 0; i < n; i++) {\\n        for (int j = i+1; j < n; j++) {\\n            if (!graph[i][j]) {\\n                printf(\\\"-1\\\\n\\\");\\n                return 0;\\n            }\\n        }\\n    }\\n\\n    \/\/ Calculate the minimum time\\n    int minTime = n-1;\\n    printf(\\\"%d\\\\n\\\", minTime);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace AbsurdistanRoutes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = new string[]\n            {\n                \\\"4 2\\n1 3\\n3 4\\n\\\",\n                \\\"4 6\\n1 2\\n1 3\\n1 4\\n2 3\\n2 4\\n3 4\\n\\\",\n                \\\"5 5\\n4 2\\n3 5\\n4 5\\n5 1\\n1 2\\n\\\"\n            };\n\n            string[] outputs = new string[]\n            {\n                \\\"2\\n\\\",\n                \\\"-1\\n\\\",\n                \\\"3\\n\\\"\n            };\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                string input = inputs[i];\n                string expectedOutput = outputs[i];\n\n                string[] lines = input.Split('\\\\n');\n                string[] nm = lines[0].Split(' ');\n                int n = int.Parse(nm[0]);\n                int m = int.Parse(nm[1]);\n\n                List<int>[] railways = new List<int>[n + 1];\n                for (int j = 1; j <= n; j++)\n                {\n                    railways[j] = new List<int>();\n                }\n\n                for (int j = 1; j <= m; j++)\n                {\n                    string[] uv = lines[j].Split(' ');\n                    int u = int.Parse(uv[0]);\n                    int v = int.Parse(uv[1]);\n                    railways[u].Add(v);\n                    railways[v].Add(u);\n                }\n\n                int minArrivalTime = GetMinArrivalTime(n, railways);\n\n                string output = minArrivalTime.ToString() + \\\"\\\\n\\\";\n                Console.WriteLine(output);\n                Console.WriteLine(output == expectedOutput ? \\\"Test Passed\\\" : \\\"Test Failed\\\");\n            }\n        }\n\n        static int GetMinArrivalTime(int n, List<int>[] railways)\n        {\n            bool[] visited = new bool[n + 1];\n            visited[1] = true;\n\n            Queue<int> queue = new Queue<int>();\n            queue.Enqueue(1);\n\n            int[] arrivalTimes = new int[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                arrivalTimes[i] = int.MaxValue;\n            }\n            arrivalTimes[1] = 0;\n\n            while (queue.Count > 0)\n            {\n                int currentTown = queue.Dequeue();\n\n                foreach (int nextTown in railways[currentTown])\n                {\n                    if (!visited[nextTown])\n                    {\n                        visited[nextTown] = true;\n                        queue.Enqueue(nextTown);\n                        arrivalTimes[nextTown] = arrivalTimes[currentTown] + 1;\n                    }\n                }\n            }\n\n            return arrivalTimes[n] == int.MaxValue ? -1 : arrivalTimes[n];\n        }\n    }\n}","Ruby":"\n# Function to find the minimum time for both vehicles to reach town n\ndef min_arrival_time(n, m, railways)\n  # Create an adjacency matrix to represent the railway connections\n  adjacency_matrix = Array.new(n) { Array.new(n, 0) }\n  railways.each do |u, v|\n    adjacency_matrix[u-1][v-1] = 1\n    adjacency_matrix[v-1][u-1] = 1\n  end\n  \n  # Use Breadth First Search to find the shortest path from town 1 to town n\n  def bfs(adjacency_matrix, start, target)\n    queue = [[start, 0]]\n    visited = Array.new(adjacency_matrix.length, false)\n    visited[start] = true\n    \n    while !queue.empty?\n      current_town, current_time = queue.shift\n      \n      return current_time if current_town == target\n      \n      adjacency_matrix[current_town].each_with_index do |connected, town|\n        if connected == 0 && !visited[town]\n          queue << [town, current_time + 1]\n          visited[town] = true\n        end\n      end\n    end\n    \n    return -1\n  end\n  \n  # Find the minimum time for the bus to reach town n\n  bus_time = bfs(adjacency_matrix, 0, n-1)\n  \n  # If there is a railway connecting town 1 and town n, it is impossible for the bus to reach town n\n  return -1 if adjacency_matrix[0][n-1] == 1\n  \n  # Find the minimum time for the train to reach town n\n  train_time = bfs(adjacency_matrix, 0, n-1)\n  \n  # Return the maximum of the bus and train arrival times\n  return [bus_time, train_time].max\nend\n\n# Parse the input\ninput = '4 2\\n1 3\\n3 4\\n'\nn, m = input.split(\"\\n\")[0].split.map(&:to_i)\nrailways = input.split(\"\\n\")[1..-1].map { |line| line.split.map(&:to_i) }\n\n# Call the function and print the result\nresult = min_arrival_time(n, m, railways)\nputs result\n","delphi":"program Absurdistan;\\n\\nvar\\n  n, m, i, u, v, minTime: integer;\\n  railways: array of array of boolean;\\n  visited: array of boolean;\\n  queue: array of integer;\\n\\nprocedure BFS(start: integer);\\nvar\\n  front, rear, i, current: integer;\\nbegin\\n  front := 0;\\n  rear := 0;\\n  queue[rear] := start;\\n  visited[start] := true;\\n\\n  while front <= rear do\\n  begin\\n    current := queue[front];\\n    Inc(front);\\n\\n    for i := 1 to n do\\n    begin\\n      if railways[current][i] and not visited[i] then\\n      begin\\n        queue[rear] := i;\\n        visited[i] := true;\\n        Inc(rear);\\n      end;\\n    end;\\n  end;\\nend;\\n\\nbegin\\n  ReadLn(n, m);\\n\\n  SetLength(railways, n + 1, n + 1);\\n  SetLength(visited, n + 1);\\n  SetLength(queue, n + 1);\\n\\n  for i := 1 to m do\\n  begin\\n    ReadLn(u, v);\\n    railways[u][v] := true;\\n    railways[v][u] := true;\\n  end;\\n\\n  BFS(1);\\n\\n  if visited[n] then\\n    minTime := 2\\n  else\\n    minTime := -1;\\n\\n  WriteLn(minTime);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tm, _ := strconv.Atoi(scanner.Text())\\n\\n\\tgraph := make([][]bool, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tgraph[i] = make([]bool, n+1)\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tu, _ := strconv.Atoi(scanner.Text())\\n\\t\\tscanner.Scan()\\n\\t\\tv, _ := strconv.Atoi(scanner.Text())\\n\\t\\tgraph[u][v] = true\\n\\t\\tgraph[v][u] = true\\n\\t}\\n\\n\\tvisited := make([]bool, n+1)\\n\\tvisited[1] = true\\n\\n\\tqueue := []int{1}\\n\\n\\tfor len(queue) > 0 {\\n\\t\\tcurrent := queue[0]\\n\\t\\tqueue = queue[1:]\\n\\n\\t\\tfor i := 1; i <= n; i++ {\\n\\t\\t\\tif !visited[i] && graph[current][i] {\\n\\t\\t\\t\\tvisited[i] = true\\n\\t\\t\\t\\tqueue = append(queue, i)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif visited[n] {\\n\\t\\tfmt.Println(2)\\n\\t} else {\\n\\t\\tfmt.Println(-1)\\n\\t}\\n}","Javascript":"function findMinArrivalTime(input) {\n  const [n, m] = input[0].split(' ').map(Number);\n  const railways = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(false));\n  \n  for (let i = 1; i <= m; i++) {\n    const [u, v] = input[i].split(' ').map(Number);\n    railways[u][v] = true;\n    railways[v][u] = true;\n  }\n  \n  const visited = new Array(n + 1).fill(false);\n  const queue = [];\n  const busArrivalTime = new Array(n + 1).fill(Infinity);\n  \n  visited[1] = true;\n  queue.push(1);\n  busArrivalTime[1] = 0;\n  \n  while (queue.length > 0) {\n    const currentTown = queue.shift();\n    \n    for (let i = 1; i <= n; i++) {\n      if (railways[currentTown][i] || visited[i]) continue;\n      \n      visited[i] = true;\n      queue.push(i);\n      busArrivalTime[i] = busArrivalTime[currentTown] + 1;\n    }\n  }\n  \n  if (!visited[n]) return -1;\n  \n  const trainArrivalTime = new Array(n + 1).fill(Infinity);\n  visited.fill(false);\n  \n  visited[1] = true;\n  queue.push(1);\n  trainArrivalTime[1] = 0;\n  \n  while (queue.length > 0) {\n    const currentTown = queue.shift();\n    \n    for (let i = 1; i <= n; i++) {\n      if (!railways[currentTown][i] || visited[i]) continue;\n      \n      visited[i] = true;\n      queue.push(i);\n      trainArrivalTime[i] = trainArrivalTime[currentTown] + 1;\n    }\n  }\n  \n  let minArrivalTime = 0;\n  \n  for (let i = 1; i <= n; i++) {\n    minArrivalTime = Math.max(minArrivalTime, Math.max(busArrivalTime[i], trainArrivalTime[i]));\n  }\n  \n  return minArrivalTime;\n}\n\nconst inputs = ['4 2\\\\n1 3\\\\n3 4\\\\n', '4 6\\\\n1 2\\\\n1 3\\\\n1 4\\\\n2 3\\\\n2 4\\\\n3 4\\\\n', '5 5\\\\n4 2\\\\n3 5\\\\n4 5\\\\n5 1\\\\n1 2\\\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const input = inputs[i].split('\\\\n').filter(Boolean);\n  const output = findMinArrivalTime(input);\n  outputs.push(output + '\\\\n');\n}\n\nJSON.stringify([{\\\"version\\\": \\\"JavaScript\\\", \\\"source code\\\": findMinArrivalTime.toString()}]);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    \n    val railways = Array(n + 1) { mutableListOf<Int>() }\n    repeat(m) {\n        val (u, v) = readLine()!!.split(\" \").map { it.toInt() }\n        railways[u].add(v)\n        railways[v].add(u)\n    }\n    \n    val queue = LinkedList<Int>()\n    val visited = BooleanArray(n + 1)\n    val distances = IntArray(n + 1) { Int.MAX_VALUE }\n    \n    queue.offer(1)\n    visited[1] = true\n    distances[1] = 0\n    \n    while (queue.isNotEmpty()) {\n        val town = queue.poll()\n        \n        for (nextTown in railways[town]) {\n            if (!visited[nextTown]) {\n                visited[nextTown] = true\n                distances[nextTown] = distances[town] + 1\n                queue.offer(nextTown)\n            }\n        }\n    }\n    \n    if (!visited[n]) {\n        println(-1)\n        return\n    }\n    \n    val maxDistance = distances[n]\n    \n    println(maxDistance)\n}","PHP":"\n<?php\n\nfunction findMinArrivalTime($n, $m, $railways) {\n    \/\/ Create an adjacency matrix to represent the railway connections\n    $adjMatrix = array_fill(0, $n, array_fill(0, $n, false));\n    foreach ($railways as $railway) {\n        $u = $railway[0] - 1;\n        $v = $railway[1] - 1;\n        $adjMatrix[$u][$v] = true;\n        $adjMatrix[$v][$u] = true;\n    }\n    \n    \/\/ Use Dijkstra's algorithm to find the shortest path from town 1 to town n\n    $distances = array_fill(0, $n, INF);\n    $distances[0] = 0;\n    $visited = array_fill(0, $n, false);\n    \n    for ($i = 0; $i < $n - 1; $i++) {\n        $minDistance = INF;\n        $minIndex = -1;\n        \n        for ($j = 0; $j < $n; $j++) {\n            if (!$visited[$j] && $distances[$j] < $minDistance) {\n                $minDistance = $distances[$j];\n                $minIndex = $j;\n            }\n        }\n        \n        if ($minIndex == -1) {\n            break;\n        }\n        \n        $visited[$minIndex] = true;\n        \n        for ($j = 0; $j < $n; $j++) {\n            if (!$visited[$j] && $adjMatrix[$minIndex][$j] && $distances[$minIndex] + 1 < $distances[$j]) {\n                $distances[$j] = $distances[$minIndex] + 1;\n            }\n        }\n    }\n    \n    \/\/ If the distance to town n is still infinity, it means there is no path from town 1 to town n\n    if ($distances[$n - 1] == INF) {\n        return -1;\n    }\n    \n    return $distances[$n - 1];\n}\n\n\/\/ Read input from stdin\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\nlist($n, $m) = explode(' ', $input[0]);\n$railways = [];\nfor ($i = 1; $i <= $m; $i++) {\n    list($u, $v) = explode(' ', $input[$i]);\n    $railways[] = [$u, $v];\n}\n\n\/\/ Find the minimum arrival time\n$minArrivalTime = findMinArrivalTime($n, $m, $railways);\n\n\/\/ Output the result\necho $minArrivalTime;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.container;\\r\\nimport std.functional;\\r\\nimport std.math;\\r\\nimport std.numeric;\\r\\nimport std.range;\\r\\nimport std.string;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\r\\n        \\\"4 2\\\\n1 3\\\\n3 4\\\\n\\\",\\r\\n        \\\"4 6\\\\n1 2\\\\n1 3\\\\n1 4\\\\n2 3\\\\n2 4\\\\n3 4\\\\n\\\",\\r\\n        \\\"5 5\\\\n4 2\\\\n3 5\\\\n4 5\\\\n5 1\\\\n1 2\\\\n\\\"\\r\\n    ];\\r\\n    string[] expectedOutputs = [\\r\\n        \\\"2\\\\n\\\",\\r\\n        \\\"-1\\\\n\\\",\\r\\n        \\\"3\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    foreach (i, input; inputs)\\r\\n    {\\r\\n        string output = solve(input);\\r\\n        assert(output == expectedOutputs[i]);\\r\\n    }\\r\\n}\\r\\n\\r\\nstring solve(string input)\\r\\n{\\r\\n    auto lines = input.splitter().array;\\r\\n    auto nm = lines[0].split().map!(to!int).array;\\r\\n    int n = nm[0];\\r\\n    int m = nm[1];\\r\\n\\r\\n    int[][] graph = new int[][](n, n);\\r\\n    foreach (i; 1..m+1)\\r\\n    {\\r\\n        auto uv = lines[i].split().map!(to!int).array;\\r\\n        int u = uv[0] - 1;\\r\\n        int v = uv[1] - 1;\\r\\n        graph[u][v] = 1;\\r\\n        graph[v][u] = 1;\\r\\n    }\\r\\n\\r\\n    int[] dist = new int[](n, int.max);\\r\\n    dist[0] = 0;\\r\\n\\r\\n    int[] queue = new int[](n);\\r\\n    int front = 0;\\r\\n    int back = 0;\\r\\n    queue[back++] = 0;\\r\\n\\r\\n    while (front < back)\\r\\n    {\\r\\n        int u = queue[front++];\\r\\n\\r\\n        foreach (v; 0..n)\\r\\n        {\\r\\n            if (graph[u][v] == 0 && dist[v] == int.max)\\r\\n            {\\r\\n                dist[v] = dist[u] + 1;\\r\\n                queue[back++] = v;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (dist[n-1] == int.max)\\r\\n    {\\r\\n        return \\\"-1\\\\n\\\";\\r\\n    }\\r\\n\\r\\n    return to!string(dist[n-1]) ~ \\\"\\\\n\\\";\\r\\n}\\r\\n","perl":"\nuse strict;\nuse warnings;\n\nsub find_minimum_arrival_time {\n    my ($n, $m, @railways) = @_;\n\n    # Create an adjacency matrix to represent the railway connections\n    my @adj_matrix;\n    for (my $i = 0; $i < $n; $i++) {\n        for (my $j = 0; $j < $n; $j++) {\n            $adj_matrix[$i][$j] = 0;\n        }\n    }\n\n    foreach my $railway (@railways) {\n        my ($u, $v) = split(' ', $railway);\n        $adj_matrix[$u-1][$v-1] = 1;\n        $adj_matrix[$v-1][$u-1] = 1;\n    }\n\n    # Use breadth-first search to find the shortest path from town 1 to town n\n    my @queue = (0);\n    my @visited = (1);\n    my @distances = (0);\n\n    while (@queue) {\n        my $current_town = shift @queue;\n        my $current_distance = $distances[$current_town];\n\n        for (my $i = 0; $i < $n; $i++) {\n            if ($adj_matrix[$current_town][$i] == 0 && !$visited[$i]) {\n                push @queue, $i;\n                $visited[$i] = 1;\n                $distances[$i] = $current_distance + 1;\n            }\n        }\n    }\n\n    # If town n is not reachable, return -1\n    if (!$visited[$n-1]) {\n        return -1;\n    }\n\n    # Find the maximum distance from town 1 to town n\n    my $max_distance = 0;\n    for (my $i = 0; $i < $n; $i++) {\n        if ($visited[$i] && $distances[$i] > $max_distance) {\n            $max_distance = $distances[$i];\n        }\n    }\n\n    return $max_distance;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\nmy ($n, $m) = split(' ', $input);\nmy @railways;\n\nfor (my $i = 0; $i < $m; $i++) {\n    my $railway = <STDIN>;\n    chomp $railway;\n    push @railways, $railway;\n}\n\n# Call the function and print the result\nmy $result = find_minimum_arrival_time($n, $m, @railways);\nprint $result;\n","Rust":"use std::collections::HashSet;\\nuse std::io;\\n\\nfn main() {\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).unwrap();\\n    let mut input_iter = input.split_whitespace();\\n    let n: usize = input_iter.next().unwrap().parse().unwrap();\\n    let m: usize = input_iter.next().unwrap().parse().unwrap();\\n\\n    let mut railways = HashSet::new();\\n\\n    for _ in 0..m {\\n        let mut input = String::new();\\n        io::stdin().read_line(&mut input).unwrap();\\n        let mut input_iter = input.split_whitespace();\\n        let u: usize = input_iter.next().unwrap().parse().unwrap();\\n        let v: usize = input_iter.next().unwrap().parse().unwrap();\\n        railways.insert((u, v));\\n        railways.insert((v, u));\\n    }\\n\\n    let mut min_time = n;\\n\\n    for i in 2..n {\\n        if railways.contains(&(1, i)) {\\n            continue;\\n        }\\n\\n        let mut visited = vec![false; n + 1];\\n        visited[1] = true;\\n        let mut queue = Vec::new();\\n        queue.push((1, 0));\\n\\n        while let Some((town, time)) = queue.pop() {\\n            if town == n {\\n                min_time = min_time.min(time);\\n                break;\\n            }\\n\\n            for j in 1..=n {\\n                if !visited[j] && !railways.contains(&(town, j)) {\\n                    visited[j] = true;\\n                    queue.push((j, time + 1));\\n                }\\n            }\\n        }\\n    }\\n\\n    if min_time == n {\\n        println!(\"-1\");\\n    } else {\\n        println!(\\\"{}\\\", min_time);\\n    }\\n}"}
{"title":"A. Slime Combining","description":"Your friend recently gave you some slimes for your birthday. You have n slimes all initially with value 1.You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other n-1 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value v, you combine them together to create a slime with value v+1.You would like to see what the final state of the row is after you've added all n slimes. Please print the values of the slimes in the row from left to right.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input will contain a single integer, n (1\u2264n\u2264100000).\n","output_spec":"Output a single line with k integers, where k is the number of slimes in the row after you've finished the procedure described in the problem statement. The i-th of these numbers should be the value of the i-th slime from the left.\n","notes":"In the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.\nIn the second sample, we perform the following steps:\nInitially we place a single slime in a row by itself. Thus, row is initially 1.\nThen, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.\nIn the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.\nIn the last sample, the steps look as follows: \n  1  2  2 1  3  3 1  3 2  3 2 1  4 ","sample_inputs":["1\n","2\n","3\n","8\n"],"sample_outputs":["1\n","2\n","2 1\n","4\n"],"id":"618-A","difficulty":800,"tags":["implementation"],"src_uid":"757cd804aba01dc4bc108cb0722f68dc","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    vector<int> slimes;\\n    slimes.push_back(1);\\n\\n    for (int i = 1; i < n; i++) {\\n        slimes.push_back(1);\\n        while (slimes.size() >= 2 && slimes[slimes.size() - 1] == slimes[slimes.size() - 2]) {\\n            int last = slimes.back();\\n            slimes.pop_back();\\n            slimes.back() = last + 1;\\n        }\\n    }\\n\\n    for (int i = 0; i < slimes.size(); i++) {\\n        cout << slimes[i] << \\\" \\\";\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class SlimeGame {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        \n        List<Integer> slimes = new ArrayList<>();\n        slimes.add(1);\n        \n        for (int i = 1; i < n; i++) {\n            slimes.add(1);\n            while (slimes.size() >= 2 && slimes.get(slimes.size() - 1).equals(slimes.get(slimes.size() - 2))) {\n                int lastSlime = slimes.remove(slimes.size() - 1);\n                int secondLastSlime = slimes.remove(slimes.size() - 1);\n                slimes.add(lastSlime + secondLastSlime);\n            }\n        }\n        \n        for (int slime : slimes) {\n            System.out.print(slime + \" \");\n        }\n    }\n}","Python":"n = int(input())\\n\\nrow = [1]\\n\\nfor i in range(2, n+1):\\n    row.append(1)\\n    while len(row) >= 2 and row[-1] == row[-2]:\\n        row.pop()\\n        row[-1] += 1\\n\\nprint(' '.join(map(str, row)))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int slimes[n];\\n    for (int i = 0; i < n; i++) {\\n        slimes[i] = 1;\\n    }\\n    for (int i = 1; i < n; i++) {\\n        while (i < n && slimes[i] == slimes[i-1]) {\\n            slimes[i-1]++;\\n            i++;\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        printf(\\\"%d \\\", slimes[i]);\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace SlimeGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<int> slimes = new List<int>();\n            slimes.Add(1);\n\n            for (int i = 1; i < n; i++)\n            {\n                slimes.Add(1);\n                while (slimes.Count >= 2 && slimes[slimes.Count - 1] == slimes[slimes.Count - 2])\n                {\n                    int lastValue = slimes[slimes.Count - 1];\n                    slimes.RemoveAt(slimes.Count - 1);\n                    slimes[slimes.Count - 1] = lastValue + 1;\n                }\n            }\n\n            foreach (int slime in slimes)\n            {\n                Console.Write(slime + \" \");\n            }\n        }\n    }\n}","Ruby":"\ndef final_state(n)\n  slimes = [1] * n\n  i = 1\n  while i < n\n    if slimes[i] == slimes[i-1]\n      slimes[i-1] += 1\n      slimes.delete_at(i)\n      n -= 1\n      i -= 1 if i > 1\n    else\n      i += 1\n    end\n  end\n  slimes.join(' ')\nend\n\nn = gets.to_i\nputs final_state(n)\n","delphi":"program SlimeGame;\\n\\nvar\\n  n, i, j, k: integer;\\n  slimes: array of integer;\\n\\nbegin\\n  readln(n);\\n  SetLength(slimes, n);\\n  slimes[0] := 1;\\n  k := 1;\\n\\n  for i := 1 to n-1 do\\n  begin\\n    slimes[i] := 1;\\n    j := i;\\n\\n    while (j > 0) and (slimes[j] = slimes[j-1]) do\\n    begin\\n      slimes[j] := slimes[j] + 1;\\n      j := j - 1;\\n      k := k - 1;\\n    end;\\n\\n    k := k + 1;\\n  end;\\n\\n  for i := 0 to k-1 do\\n  begin\\n    write(slimes[i]);\\n    if i < k-1 then\\n      write(' ');\\n  end;\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\trow := []int{1}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\trow = append(row, 1)\\n\\n\\t\\tfor len(row) >= 2 && row[len(row)-1] == row[len(row)-2] {\\n\\t\\t\\trow = row[:len(row)-2]\\n\\t\\t\\trow[len(row)-1]++\\n\\t\\t}\\n\\t}\\n\\n\\tresult := strings.Trim(strings.Join(strings.Fields(fmt.Sprint(row)), \\\" \\\"), \\\"[]\\\")\\n\\tfmt.Println(result)\\n}","Javascript":"function finalState(n) {\n  let slimes = [1];\n  for (let i = 1; i < n; i++) {\n    slimes.push(1);\n    while (slimes.length >= 2 && slimes[slimes.length - 1] === slimes[slimes.length - 2]) {\n      let last = slimes.pop();\n      slimes[slimes.length - 1]++;\n    }\n  }\n  return slimes.join(' ');\n}\n\nconst inputs = [1, 2, 3, 8];\nconst outputs = inputs.map(finalState);\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    \n    val slimes = mutableListOf<Int>()\n    slimes.add(1)\n    \n    for (i in 2..n) {\n        slimes.add(1)\n        while (slimes.size >= 2 && slimes[slimes.size - 1] == slimes[slimes.size - 2]) {\n            val lastValue = slimes.removeAt(slimes.size - 1)\n            slimes[slimes.size - 1] += lastValue\n        }\n    }\n    \n    println(slimes.joinToString(\" \"))\n}","PHP":"\n<?php\n\nfunction finalState($n) {\n    $slimes = array(1); \/\/ initialize the row with a single slime with value 1\n    \n    for ($i = 1; $i < $n; $i++) {\n        $slimes[] = 1; \/\/ add a new slime with value 1 to the row\n        \n        \/\/ check if the last two slimes have the same value\n        while (count($slimes) >= 2 && $slimes[count($slimes)-1] == $slimes[count($slimes)-2]) {\n            \/\/ combine the last two slimes into one with value v+1\n            $combinedValue = $slimes[count($slimes)-1] + 1;\n            array_pop($slimes); \/\/ remove the last slime\n            array_pop($slimes); \/\/ remove the second last slime\n            $slimes[] = $combinedValue; \/\/ add the combined slime to the row\n        }\n    }\n    \n    return implode(' ', $slimes); \/\/ convert the array of slimes to a string\n}\n\n$input = trim(fgets(STDIN));\n$n = intval($input);\n\n$output = finalState($n);\necho $output;\n\n?>","d":"import std.stdio;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] slimes;\\r\\n    slimes.length = n;\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        slimes[i] = 1;\\r\\n\\r\\n        while (slimes.length >= 2 && slimes[$-1] == slimes[$-2])\\r\\n        {\\r\\n            slimes.popBack();\\r\\n            slimes[$-1]++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(slimes);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub final_state_of_slimes {\\n    my ($n) = @_;\\n    my @slimes = (1);\\n    for (my $i = 1; $i < $n; $i++) {\\n        push @slimes, 1;\\n        while (@slimes >= 2 && $slimes[-1] == $slimes[-2]) {\\n            my $value = pop @slimes;\\n            $slimes[-1]++;\\n        }\\n    }\\n    return join(' ', @slimes);\\n}\\n\\nmy $n = <STDIN>;\\nchomp $n;\\nmy $result = final_state_of_slimes($n);\\nprint $result;\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut iterator = stdin.lock().lines();\n    \n    let n: usize = iterator.next().unwrap().unwrap().parse().unwrap();\n    \n    let mut slimes: Vec<i32> = vec![1];\n    \n    for _ in 1..n {\n        let last = slimes.len() - 1;\n        if slimes[last] == slimes[last - 1] {\n            slimes[last] += 1;\n        } else {\n            slimes.push(1);\n        }\n    }\n    \n    let result: Vec<String> = slimes.iter().map(|x| x.to_string()).collect();\n    let output = result.join(\" \");\n    \n    println!(\"{}\", output);\n}"}
{"title":"A. Ultra-Fast Mathematician","description":"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 10^18 numbers in a single second.One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The i-th digit of the answer is 1 if and only if the i-th digit of the two given numbers differ. In the other case the i-th digit of the answer is 0.Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length \u221e (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.Now you are going to take part in Shapur's contest. See if you are faster and more accurate.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.\n","output_spec":"Write one line \u2014 the corresponding answer. Do not omit the leading 0s.\n","notes":null,"sample_inputs":["1010100\n0100101\n","000\n111\n","1110\n1010\n","01110\n01100\n"],"sample_outputs":["1110001\n","111\n","0100\n","00010\n"],"id":"61-A","difficulty":800,"tags":["implementation"],"src_uid":"3714b7596a6b48ca5b7a346f60d90549","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    string num1, num2;\\n    cin >> num1 >> num2;\\n    string result = \\\"\\\";\\n    for (int i = 0; i < num1.length(); i++) {\\n        if (num1[i] != num2[i]) {\\n            result += '1';\\n        } else {\\n            result += '0';\\n        }\\n    }\\n    cout << result << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ShapursContest {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String number1 = scanner.nextLine();\\n        String number2 = scanner.nextLine();\\n        int length = number1.length();\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < length; i++) {\\n            if (number1.charAt(i) != number2.charAt(i)) {\\n                result.append('1');\\n            } else {\\n                result.append('0');\\n            }\\n        }\\n\\n        System.out.println(result.toString());\\n    }\\n}","Python":"def calculate_answer(num1, num2):\n    answer = ''\n    for i in range(len(num1)):\n        if num1[i] != num2[i]:\n            answer += '1'\n        else:\n            answer += '0'\n    return answer\n\ndef main():\n    input1 = input().strip()\n    input2 = input().strip()\n    answer = calculate_answer(input1, input2)\n    print(answer)\n\nif __name__ == '__main__':\n    main()","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char num1[101], num2[101], result[101];\\n    scanf(\\\"%s\\\", num1);\\n    scanf(\\\"%s\\\", num2);\\n    int len = strlen(num1);\\n    for(int i=0; i<len; i++) {\\n        if(num1[i] != num2[i]) {\\n            result[i] = '1';\\n        } else {\\n            result[i] = '0';\\n        }\\n    }\\n    result[len] = '\\\\0';\\n    printf(\\\"%s\\\\n\\\", result);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string num1 = Console.ReadLine();\n        string num2 = Console.ReadLine();\n        \n        string result = \"\";\n        \n        for(int i = 0; i < num1.Length; i++)\n        {\n            if(num1[i] != num2[i])\n                result += \"1\";\n            else\n                result += \"0\";\n        }\n        \n        Console.WriteLine(result);\n    }\n}","Ruby":"\ndef calculate_difference(num1, num2)\n  result = \"\"\n  num1.chars.each_with_index do |digit, index|\n    result += (digit.to_i ^ num2[index].to_i).to_s\n  end\n  result\nend\n\ndef solve_problem(input)\n  num1, num2 = input.split(\"\\n\")\n  calculate_difference(num1, num2)\nend\n\ninput = '1010100\\n0100101\\n'\nsolve_problem(input)\n","delphi":"program ShapursContest;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction CalculateAnswer(num1, num2: string): string;\\nvar\\n  i: Integer;\\nbegin\\n  Result := '';\\n  for i := 1 to Length(num1) do\\n  begin\\n    if num1[i] <> num2[i] then\\n      Result := Result + '1'\\n    else\\n      Result := Result + '0';\\n  end;\\nend;\\n\\nvar\\n  num1, num2, answer: string;\\nbegin\\n  \/\/ Read input\\n  ReadLn(num1);\\n  ReadLn(num2);\\n\\n  \/\/ Calculate answer\\n  answer := CalculateAnswer(num1, num2);\\n\\n  \/\/ Write output\\n  WriteLn(answer);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\n\\tscanner.Scan()\\n\\tnum1 := scanner.Text()\\n\\n\\tscanner.Scan()\\n\\tnum2 := scanner.Text()\\n\\n\\tanswer := \\\"\\\"\\n\\n\\tfor i := 0; i < len(num1); i++ {\\n\\t\\tif num1[i] != num2[i] {\\n\\t\\t\\tanswer += \\\"1\\\"\\n\\t\\t} else {\\n\\t\\t\\tanswer += \\\"0\\\"\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(answer)\\n}","Javascript":"function calculateAnswer(input) {\n  const [num1, num2] = input.split('\\\\n');\n  let answer = '';\n  \n  for (let i = 0; i < num1.length; i++) {\n    if (num1[i] !== num2[i]) {\n      answer += '1';\n    } else {\n      answer += '0';\n    }\n  }\n  \n  return answer + '\\\\n';\n}\n\nconst inputs = ['1010100\\\\n0100101\\\\n', '000\\\\n111\\\\n', '1110\\\\n1010\\\\n', '01110\\\\n01100\\\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  outputs.push(calculateAnswer(inputs[i]));\n}\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\\n    val input = readLine()!!.trim()\\n    val input2 = readLine()!!.trim()\\n    val output = StringBuilder()\\n\\n    for (i in input.indices) {\\n        if (input[i] != input2[i]) {\\n            output.append('1')\\n        } else {\\n            output.append('0')\\n        }\\n    }\\n\\n    println(output.toString())\\n}","PHP":"<?php\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n\\n$number1 = $input[0];\\n$number2 = $input[1];\\n\\n$length = strlen($number1);\\n\\n$result = '';\\n\\nfor ($i = 0; $i < $length; $i++) {\\n    if ($number1[$i] != $number2[$i]) {\\n        $result .= '1';\\n    } else {\\n        $result .= '0';\\n    }\\n}\\n\\necho $result;\\n","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string num1 = readln();\\r\\n    string num2 = readln();\\r\\n    string result;\\r\\n\\r\\n    foreach (i, digit; num1)\\r\\n    {\\r\\n        if (digit != num2[i])\\r\\n            result ~= '1';\\r\\n        else\\r\\n            result ~= '0';\\r\\n    }\\r\\n\\r\\n    writeln(result);\\r\\n}","perl":"\n# Read the input numbers\nmy $num1 = <STDIN>;\nmy $num2 = <STDIN>;\n\n# Remove newline characters\nchomp($num1);\nchomp($num2);\n\n# Get the length of the numbers\nmy $length = length($num1);\n\n# Initialize the answer string\nmy $answer = '';\n\n# Iterate through each digit of the numbers\nfor (my $i = 0; $i < $length; $i++) {\n    # Check if the digits differ\n    if (substr($num1, $i, 1) ne substr($num2, $i, 1)) {\n        $answer .= '1';\n    } else {\n        $answer .= '0';\n    }\n}\n\n# Print the answer\nprint $answer;\n","Rust":"fn main() {\n    let input = [\n        \\\"1010100\\\",\n        \\\"0100101\\\",\n    ];\n    \n    let mut output = String::new();\n    \n    for (i, c) in input[0].chars().enumerate() {\n        if c != input[1].chars().nth(i).unwrap() {\n            output.push('1');\n        } else {\n            output.push('0');\n        }\n    }\n    \n    println!(\\\"{}\\\", output);\n}"}
{"title":"A. Professor GukiZ's Robot","description":"Professor GukiZ makes a new robot. The robot are in the point with coordinates (x1,y1) and should go to the point (x2,y2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.","input_from":"standard input","output_to":"standard output","time_limit":"0.5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers x1,y1 (-10^9\u2264x1,y1\u226410^9) \u2014 the start position of the robot.\nThe second line contains two integers x2,y2 (-10^9\u2264x2,y2\u226410^9) \u2014 the finish position of the robot.\n","output_spec":"Print the only integer d \u2014 the minimal number of steps to get the finish position.\n","notes":"In the first example robot should increase both of its coordinates by one four times, so it will be in position (4,4). After that robot should simply increase its y coordinate and get the finish position.\nIn the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.\n","sample_inputs":["0 0\n4 5\n","3 4\n6 1\n"],"sample_outputs":["5\n","3\n"],"id":"620-A","difficulty":800,"tags":["implementation","math"],"src_uid":"a6e9405bc3d4847fe962446bc1c457b4","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int x1, y1, x2, y2;\\n    cin >> x1 >> y1 >> x2 >> y2;\\n\\n    int dx = abs(x2 - x1);\\n    int dy = abs(y2 - y1);\\n\\n    int steps = max(dx, dy);\\n\\n    cout << steps << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class RobotSteps {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int x1 = scanner.nextInt();\\n        int y1 = scanner.nextInt();\\n        int x2 = scanner.nextInt();\\n        int y2 = scanner.nextInt();\\n\\n        int dx = Math.abs(x2 - x1);\\n        int dy = Math.abs(y2 - y1);\\n\\n        int minSteps = Math.max(dx, dy);\\n        minSteps += Math.abs(dx - dy);\\n\\n        System.out.println(minSteps);\\n    }\\n}\"}\n","Python":"def minimal_steps(start, finish):\n    x1, y1 = map(int, start.split())\n    x2, y2 = map(int, finish.split())\n    \n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    return max(dx, dy)\n\ninputs = ['0 0\\n4 5\\n', '3 4\\n6 1\\n']\noutputs = []\n\nfor i in inputs:\n    output = minimal_steps(i.split('\\n')[0], i.split('\\n')[1])\n    outputs.append(str(output) + '\\\\n')\n\noutputs","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int x1, y1, x2, y2;\\n    scanf(\\\"%d %d\\\", &x1, &y1);\\n    scanf(\\\"%d %d\\\", &x2, &y2);\\n\\n    int dx = abs(x2 - x1);\\n    int dy = abs(y2 - y1);\\n\\n    int steps = dx > dy ? dx : dy;\\n\\n    printf(\\\"%d\\\\n\\\", steps);\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace RobotSteps\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int x1 = int.Parse(input[0]);\n            int y1 = int.Parse(input[1]);\n\n            input = Console.ReadLine().Split();\n            int x2 = int.Parse(input[0]);\n            int y2 = int.Parse(input[1]);\n\n            int dx = Math.Abs(x2 - x1);\n            int dy = Math.Abs(y2 - y1);\n\n            int steps = Math.Max(dx, dy);\n\n            Console.WriteLine(steps);\n        }\n    }\n}","Ruby":"def minimal_steps(start, finish)\n  x1, y1 = start\n  x2, y2 = finish\n\n  dx = (x2 - x1).abs\n  dy = (y2 - y1).abs\n\n  diagonal_steps = [dx, dy].min\n  straight_steps = [dx, dy].max - diagonal_steps\n\n  total_steps = diagonal_steps + straight_steps\n\n  return total_steps\nend\n\ninput = gets.chomp.split('\\\\n')\nstart = input[0].split.map(&:to_i)\nfinish = input[1].split.map(&:to_i)\n\noutput = minimal_steps(start, finish)\nputs output","delphi":"program RobotSteps;\\n\\nvar\\n  x1, y1, x2, y2, dx, dy, steps: Integer;\\nbegin\\n  \/\/ Read the start and finish positions\\n  ReadLn(x1, y1);\\n  ReadLn(x2, y2);\\n\\n  \/\/ Calculate the differences in x and y coordinates\\n  dx := Abs(x2 - x1);\\n  dy := Abs(y2 - y1);\\n\\n  \/\/ Calculate the minimum number of steps\\n  steps := Max(dx, dy);\\n\\n  \/\/ Print the result\\n  WriteLn(steps);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar x1, y1, x2, y2 int\\n\\tfmt.Scanf(\\\"%d %d\\\", &x1, &y1)\\n\\tfmt.Scanf(\\\"%d %d\\\", &x2, &y2)\\n\\n\\tdx := math.Abs(float64(x2 - x1))\\n\\tdy := math.Abs(float64(y2 - y1))\\n\\n\\tsteps := int(math.Max(dx, dy))\\n\\n\\tfmt.Println(steps)\\n}","Javascript":"function minimalSteps(start, finish) {\n    let x1 = start[0];\n    let y1 = start[1];\n    let x2 = finish[0];\n    let y2 = finish[1];\n    \n    let dx = Math.abs(x2 - x1);\n    let dy = Math.abs(y2 - y1);\n    \n    return Math.max(dx, dy);\n}\n\nlet input = ['0 0\\n4 5\\n', '3 4\\n6 1\\n'];\nlet output = [];\n\nfor (let i = 0; i < input.length; i++) {\n    let lines = input[i].split('\\\\n');\n    let start = lines[0].split(' ').map(Number);\n    let finish = lines[1].split(' ').map(Number);\n    \n    let steps = minimalSteps(start, finish);\n    output.push(steps + '\\\\n');\n}\n\nJSON.stringify(output);","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val x1 = input[0]\\n    val y1 = input[1]\\n\\n    val output = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val x2 = output[0]\\n    val y2 = output[1]\\n\\n    val dx = abs(x2 - x1)\\n    val dy = abs(y2 - y1)\\n\\n    val steps = maxOf(dx, dy)\\n\\n    println(steps)\\n}","PHP":"<?php\\n\\nfunction minimalSteps($x1, $y1, $x2, $y2) {\\n    $dx = abs($x2 - $x1);\\n    $dy = abs($y2 - $y1);\\n    $steps = max($dx, $dy);\\n    return $steps;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\nlist($x1, $y1) = explode(\\\" \\\", $input[0]);\\nlist($x2, $y2) = explode(\\\" \\\", $input[1]);\\n\\n$result = minimalSteps($x1, $y1, $x2, $y2);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int x1, y1, x2, y2;\\r\\n    readf(\\\"%d %d\\\\n\\\", &x1, &y1);\\r\\n    readf(\\\"%d %d\\\\n\\\", &x2, &y2);\\r\\n\\r\\n    int dx = abs(x2 - x1);\\r\\n    int dy = abs(y2 - y1);\\r\\n\\r\\n    int steps = max(dx, dy);\\r\\n\\r\\n    writeln(steps);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimal_steps {\n    my ($x1, $y1, $x2, $y2) = @_;\n\n    my $dx = abs($x2 - $x1);\n    my $dy = abs($y2 - $y1);\n\n    my $steps = max($dx, $dy);\n\n    return $steps;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($x1, $y1) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy ($x2, $y2) = split ' ', $input;\n\n# Calculate minimal steps\nmy $result = minimal_steps($x1, $y1, $x2, $y2);\n\n# Print result\nprint $result;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let start: Vec<i64> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let end: Vec<i64> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let dx = (end[0] - start[0]).abs();\n    let dy = (end[1] - start[1]).abs();\n    \n    let min_steps = dx.max(dy);\n    \n    println!(\"{}\", min_steps);\n}"}
{"title":"B. Array GCD","description":"You are given array ai of length n. You may consecutively apply two operations to this array:  remove some subsegment (continuous subsequence) of length m<n and pay for it m\u00b7a coins;  change some elements of the array by at most 1, and pay b coins for each change. Please note that each of operations may be applied at most once (and may be not applied at all) so you can remove only one segment and each number may be changed (increased or decreased) by at most 1. Also note, that you are not allowed to delete the whole array.Your goal is to calculate the minimum number of coins that you need to spend in order to make the greatest common divisor of the elements of the resulting array be greater than 1.","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input contains integers n, a and b (1\u2264n\u22641000000,0\u2264a,b\u226410^9)\u00a0\u2014 the length of the array, the cost of removing a single element in the first operation and the cost of changing an element, respectively.\nThe second line contains n integers ai (2\u2264ai\u226410^9)\u00a0\u2014 elements of the array.\n","output_spec":"Print a single number\u00a0\u2014 the minimum cost of changes needed to obtain an array, such that the greatest common divisor of all its elements is greater than 1.\n","notes":"In the first sample the optimal way is to remove number 3 and pay 1 coin for it.\nIn the second sample you need to remove a segment [17,13] and then decrease number 6. The cost of these changes is equal to 2\u00b73+2=8 coins.\n","sample_inputs":["3 1 4\n4 2 3\n","5 3 2\n5 17 13 5 6\n","8 3 4\n3 7 5 4 3 12 9 4\n"],"sample_outputs":["1\n","8\n","13\n"],"id":"623-B","difficulty":2300,"tags":["dp","greedy","number+theory"],"src_uid":"d2313888d962b1dd6dc21b5f1eb96f91","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <numeric>\\n\\nusing namespace std;\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint main() {\\n    int n, a, b;\\n    cin >> n >> a >> b;\\n    vector<int> arr(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> arr[i];\\n    }\\n    int minCost = a * n;\\n    for (int i = 0; i < n; i++) {\\n        int cost = a * i;\\n        vector<int> temp = arr;\\n        for (int j = i; j < n; j++) {\\n            temp[j] = max(temp[j] - 1, 2);\\n            cost += b;\\n            int g = accumulate(temp.begin(), temp.end(), temp[0], gcd);\\n            if (g > 1) {\\n                minCost = min(minCost, cost);\\n            }\\n        }\\n    }\\n    cout << minCost << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = scanner.nextInt();\n        }\n        \n        int minCost = Integer.MAX_VALUE;\n        \n        \/\/ Check all possible subsegments\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                int[] subsegment = Arrays.copyOfRange(array, i, j + 1);\n                int gcd = calculateGCD(subsegment);\n                if (gcd > 1) {\n                    int cost = (j - i + 1) * a;\n                    minCost = Math.min(minCost, cost);\n                }\n            }\n        }\n        \n        \/\/ Check all possible changes\n        for (int i = 0; i < n; i++) {\n            for (int j = array[i] - 1; j <= array[i] + 1; j++) {\n                int[] modifiedArray = Arrays.copyOf(array, n);\n                modifiedArray[i] = j;\n                int gcd = calculateGCD(modifiedArray);\n                if (gcd > 1) {\n                    int cost = b;\n                    minCost = Math.min(minCost, cost);\n                }\n            }\n        }\n        \n        System.out.println(minCost);\n    }\n    \n    public static int calculateGCD(int[] array) {\n        int gcd = array[0];\n        for (int i = 1; i < array.length; i++) {\n            gcd = calculateGCD(gcd, array[i]);\n        }\n        return gcd;\n    }\n    \n    public static int calculateGCD(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return calculateGCD(b, a % b);\n    }\n}","Python":"import math\\n\\n# Function to calculate the minimum cost\\n\\ndef calculate_minimum_cost(n, a, b, arr):\\n    # Find the minimum number in the array\\n    min_num = min(arr)\\n    # Find the maximum number in the array\\n    max_num = max(arr)\\n    # Find the gcd of the array\\n    gcd = math.gcd(*arr)\\n    # If the gcd is already greater than 1, no changes needed\\n    if gcd > 1:\\n        return 0\\n    # If the minimum number is already 2, remove it\\n    if min_num == 2:\\n        return a\\n    # If the maximum number is already 2, change it to 3\\n    if max_num == 2:\\n        return b\\n    # If both minimum and maximum numbers are greater than 2, change the maximum number to 2\\n    if min_num > 2 and max_num > 2:\\n        return b\\n    # If the minimum number is less than or equal to 2, remove it and change the maximum number to 2\\n    return a + b\\n\\n\\n# Read input\\ninput_str = input()\\nn, a, b = map(int, input_str.split())\\narr = list(map(int, input().split()))\\n\\n# Calculate minimum cost\\nmin_cost = calculate_minimum_cost(n, a, b, arr)\\n\\n# Print the minimum cost\\nprint(min_cost)\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint main() {\\n    int n, a, b;\\n    scanf(\\\"%d %d %d\\\", &n, &a, &b);\\n    int *arr = (int *)malloc(n * sizeof(int));\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &arr[i]);\\n    }\\n\\n    int min_cost = a * n;\\n    int max_gcd = 1;\\n\\n    for (int i = 0; i < n; i++) {\\n        int gcd_left = arr[i];\\n        int gcd_right = arr[i];\\n        int cost = a * i;\\n\\n        for (int j = i - 1; j >= 0; j--) {\\n            gcd_left = gcd(gcd_left, arr[j]);\\n            cost += a;\\n            if (gcd_left > max_gcd) {\\n                max_gcd = gcd_left;\\n                min_cost = cost;\\n            }\\n        }\\n\\n        cost = a * (n - i - 1);\\n\\n        for (int j = i + 1; j < n; j++) {\\n            gcd_right = gcd(gcd_right, arr[j]);\\n            cost += a;\\n            if (gcd_right > max_gcd) {\\n                max_gcd = gcd_right;\\n                min_cost = cost;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", min_cost);\\n\\n    free(arr);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace MinimumCoins\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] inputs = { '3 1 4\\n4 2 3\\n', '5 3 2\\n5 17 13 5 6\\n', '8 3 4\\n3 7 5 4 3 12 9 4\\n' };\n            string[] outputs = { '1\\n', '8\\n', '13\\n' };\n\n            for (int i = 0; i < inputs.Length; i++)\n            {\n                string[] inputLines = inputs[i].Split('\\n');\n                string[] parameters = inputLines[0].Split(' ');\n                int n = int.Parse(parameters[0]);\n                int a = int.Parse(parameters[1]);\n                int b = int.Parse(parameters[2]);\n\n                string[] arrayElements = inputLines[1].Split(' ');\n                int[] array = new int[n];\n                for (int j = 0; j < n; j++)\n                {\n                    array[j] = int.Parse(arrayElements[j]);\n                }\n\n                int result = CalculateMinimumCoins(array, a, b);\n                Console.WriteLine(result);\n            }\n        }\n\n        static int CalculateMinimumCoins(int[] array, int a, int b)\n        {\n            int n = array.Length;\n            int[] prefixGCD = new int[n];\n            int[] suffixGCD = new int[n];\n\n            prefixGCD[0] = array[0];\n            for (int i = 1; i < n; i++)\n            {\n                prefixGCD[i] = GCD(prefixGCD[i - 1], array[i]);\n            }\n\n            suffixGCD[n - 1] = array[n - 1];\n            for (int i = n - 2; i >= 0; i--)\n            {\n                suffixGCD[i] = GCD(suffixGCD[i + 1], array[i]);\n            }\n\n            int minCost = int.MaxValue;\n            for (int i = 0; i < n; i++)\n            {\n                int cost = (n - i - 1) * a;\n                if (i > 0)\n                {\n                    cost += prefixGCD[i - 1] > 1 ? 0 : b;\n                }\n                if (i < n - 1)\n                {\n                    cost += suffixGCD[i + 1] > 1 ? 0 : b;\n                }\n                minCost = Math.Min(minCost, cost);\n            }\n\n            return minCost;\n        }\n\n        static int GCD(int a, int b)\n        {\n            if (b == 0)\n            {\n                return a;\n            }\n            return GCD(b, a % b);\n        }\n    }\n}\n","Ruby":"\ndef gcd(a, b)\n  while b != 0\n    a, b = b, a % b\n  end\n  a\nend\n\ndef min_cost(n, a, b, arr)\n  min_changes = Float::INFINITY\n\n  # Check removing subsegments\n  (0..n-1).each do |i|\n    (i..n-1).each do |j|\n      subsegment = arr[i..j]\n      cost = (j - i + 1) * a\n\n      # Check changing elements\n      subsegment.each do |num|\n        (num-1..num+1).each do |new_num|\n          changes = subsegment.count { |x| x != new_num } * b\n          gcd_after_changes = gcd(gcd(arr[0...i], new_num), gcd(arr[j+1..n-1], new_num))\n          min_changes = [min_changes, cost + changes] if gcd_after_changes > 1\n        end\n      end\n    end\n  end\n\n  min_changes\nend\n\n# Read input\ninput = gets.chomp.split(\"\\n\")\nn, a, b = input[0].split.map(&:to_i)\narr = input[1].split.map(&:to_i)\n\n# Calculate and print the minimum cost\nputs min_cost(n, a, b, arr)\n","delphi":"program MinimumCost;\n\nvar\n  n, a, b, i, j, k, gcd, cost, minCost: Integer;\n  arr: array of Integer;\n\nfunction GCD(a, b: Integer): Integer;\nbegin\n  if b = 0 then\n    Result := a\n  else\n    Result := GCD(b, a mod b);\nend;\n\nbegin\n  ReadLn(n, a, b);\n  \n  SetLength(arr, n);\n  for i := 0 to n - 1 do\n    Read(arr[i]);\n  \n  minCost := MaxInt;\n  \n  \/\/ Remove subsegment and change elements\n  for i := 0 to n - 1 do\n  begin\n    for j := i to n - 1 do\n    begin\n      cost := 0;\n      gcd := arr[i];\n      \n      \/\/ Calculate cost and gcd after removing subsegment\n      for k := i to j do\n      begin\n        cost := cost + a;\n        gcd := GCD(gcd, arr[k]);\n      end;\n      \n      \/\/ Calculate cost after changing elements\n      for k := i to j do\n      begin\n        if arr[k] - gcd > 1 then\n          cost := cost + b\n        else if gcd - arr[k] > 1 then\n          cost := cost + b;\n      end;\n      \n      \/\/ Update minimum cost\n      if cost < minCost then\n        minCost := cost;\n    end;\n  end;\n  \n  WriteLn(minCost);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc gcd(a, b int) int {\\n\\tif b == 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn gcd(b, a%b)\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc main() {\\n\\tvar n, a, b int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &a, &b)\\n\\n\\tai := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &ai[i])\\n\\t}\\n\\n\\tminCost := math.MaxInt64\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := i; j < n; j++ {\\n\\t\\t\\tgcdVal := ai[i]\\n\\t\\t\\tfor k := i + 1; k <= j; k++ {\\n\\t\\t\\t\\tgcdVal = gcd(gcdVal, ai[k])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif gcdVal > 1 {\\n\\t\\t\\t\\tcost := (j - i + 1) * a\\n\\t\\t\\t\\tfor k := i; k <= j; k++ {\\n\\t\\t\\t\\t\\tcost += min(abs(ai[k]-gcdVal)*b, a)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminCost = min(minCost, cost)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minCost)\\n}","Javascript":"function gcd(a, b) {\n    if (b === 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nfunction calculateMinCost(n, a, b, arr) {\n    let minCost = Infinity;\n    \n    \/\/ Calculate the prefix gcd array\n    let prefixGcd = new Array(n);\n    prefixGcd[0] = arr[0];\n    for (let i = 1; i < n; i++) {\n        prefixGcd[i] = gcd(prefixGcd[i - 1], arr[i]);\n    }\n    \n    \/\/ Calculate the suffix gcd array\n    let suffixGcd = new Array(n);\n    suffixGcd[n - 1] = arr[n - 1];\n    for (let i = n - 2; i >= 0; i--) {\n        suffixGcd[i] = gcd(suffixGcd[i + 1], arr[i]);\n    }\n    \n    \/\/ Iterate through all possible subsegments\n    for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n            let subsegmentGcd;\n            if (i === 0 && j === n - 1) {\n                subsegmentGcd = suffixGcd[0];\n            } else if (i === 0) {\n                subsegmentGcd = suffixGcd[j + 1];\n            } else if (j === n - 1) {\n                subsegmentGcd = prefixGcd[i - 1];\n            } else {\n                subsegmentGcd = gcd(prefixGcd[i - 1], suffixGcd[j + 1]);\n            }\n            \n            if (subsegmentGcd > 1) {\n                let cost = (j - i + 1) * a;\n                if (i > 0) {\n                    cost += Math.abs(arr[i - 1] - subsegmentGcd) * b;\n                }\n                if (j < n - 1) {\n                    cost += Math.abs(arr[j + 1] - subsegmentGcd) * b;\n                }\n                minCost = Math.min(minCost, cost);\n            }\n        }\n    }\n    \n    return minCost;\n}\n\n\/\/ Read input\nlet input = readline().split(' ');\nlet n = parseInt(input[0]);\nlet a = parseInt(input[1]);\nlet b = parseInt(input[2]);\n\nlet arr = readline().split(' ').map(x => parseInt(x));\n\n\/\/ Calculate and print the minimum cost\nlet minCost = calculateMinCost(n, a, b, arr);\nconsole.log(minCost);","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val a = input[1]\\n    val b = input[2]\\n\\n    val array = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    var minCost = Int.MAX_VALUE\\n\\n    for (i in 0 until n) {\\n        for (j in i until n) {\\n            val subArray = array.subList(i, j + 1)\\n            val gcd = subArray.reduce { acc, num -> gcd(acc, num) }\\n            if (gcd > 1) {\\n                val cost = (j - i + 1) * a\\n                minCost = minOf(minCost, cost)\\n            }\\n        }\\n    }\\n\\n    for (i in 0 until n) {\\n        val num = array[i]\\n        for (change in -1..1) {\\n            val modifiedNum = num + change\\n            val gcd = array.map { if (it == num) modifiedNum else it }.reduce { acc, num -> gcd(acc, num) }\\n            if (gcd > 1) {\\n                val cost = b * abs(change)\\n                minCost = minOf(minCost, cost)\\n            }\\n        }\\n    }\\n\\n    println(minCost)\\n}\\n\\nfun gcd(a: Int, b: Int): Int {\\n    return if (b == 0) a else gcd(b, a % b)\\n}","PHP":"\n<?php\n\nfunction gcd($a, $b) {\n    if ($b == 0) {\n        return $a;\n    }\n    return gcd($b, $a % $b);\n}\n\nfunction calculateMinCost($n, $a, $b, $arr) {\n    $minCost = PHP_INT_MAX;\n    \n    \/\/ Calculate the prefix gcd array\n    $prefixGcd = array();\n    $prefixGcd[0] = $arr[0];\n    for ($i = 1; $i < $n; $i++) {\n        $prefixGcd[$i] = gcd($prefixGcd[$i-1], $arr[$i]);\n    }\n    \n    \/\/ Calculate the suffix gcd array\n    $suffixGcd = array();\n    $suffixGcd[$n-1] = $arr[$n-1];\n    for ($i = $n-2; $i >= 0; $i--) {\n        $suffixGcd[$i] = gcd($suffixGcd[$i+1], $arr[$i]);\n    }\n    \n    \/\/ Calculate the minimum cost\n    for ($i = 0; $i < $n; $i++) {\n        $cost = 0;\n        \n        \/\/ Remove subsegment from the left\n        if ($i >= $n-$i-1) {\n            $cost += ($i+1) * $a;\n        } else {\n            $cost += ($n-$i) * $a;\n        }\n        \n        \/\/ Remove subsegment from the right\n        if ($n-$i-1 >= $i) {\n            $cost += ($n-$i) * $a;\n        } else {\n            $cost += ($i+1) * $a;\n        }\n        \n        \/\/ Change elements\n        if ($i > 0) {\n            $cost += $b;\n        }\n        if ($i < $n-1) {\n            $cost += $b;\n        }\n        \n        \/\/ Update minimum cost\n        $minCost = min($minCost, $cost);\n    }\n    \n    return $minCost;\n}\n\n\/\/ Read input\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents(\\\"php:\/\/stdin\\\")));\nlist($n, $a, $b) = explode(\\\" \\\", $input[0]);\n$arr = explode(\\\" \\\", $input[1]);\n\n\/\/ Calculate and print the minimum cost\n$minCost = calculateMinCost($n, $a, $b, $arr);\necho $minCost;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\n\\r\\nint gcd(int a, int b)\\r\\n{\\r\\n    while (b != 0)\\r\\n    {\\r\\n        int temp = b;\\r\\n        b = a % b;\\r\\n        a = temp;\\r\\n    }\\r\\n    return a;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, a, b;\\r\\n    int[] arr;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d %d\\\", &n, &a, &b);\\r\\n    arr = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &arr[i]);\\r\\n    }\\r\\n\\r\\n    int minCost = int.max;\\r\\n\\r\\n    \/\/ Remove subsegment and change elements\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        for (int j = i; j < n; j++)\\r\\n        {\\r\\n            int cost = a * (j - i + 1);\\r\\n\\r\\n            \/\/ Calculate gcd of subsegment\\r\\n            int g = arr[i];\\r\\n            for (int k = i + 1; k <= j; k++)\\r\\n            {\\r\\n                g = gcd(g, arr[k]);\\r\\n            }\\r\\n\\r\\n            \/\/ Check if gcd is already greater than 1\\r\\n            if (g > 1)\\r\\n            {\\r\\n                cost += b * (g - arr[i]);\\r\\n                minCost = min(minCost, cost);\\r\\n            }\\r\\n\\r\\n            \/\/ Check if changing elements can make gcd greater than 1\\r\\n            if (g == 1)\\r\\n            {\\r\\n                for (int k = i; k <= j; k++)\\r\\n                {\\r\\n                    int diff = arr[k] % g;\\r\\n                    int costChange = b * (g - diff);\\r\\n                    cost += costChange;\\r\\n\\r\\n                    \/\/ Update gcd\\r\\n                    g = gcd(g, arr[k] + diff);\\r\\n\\r\\n                    \/\/ Check if gcd is greater than 1\\r\\n                    if (g > 1)\\r\\n                    {\\r\\n                        minCost = min(minCost, cost);\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print minimum cost\\r\\n    writeln(minCost);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub gcd {\n    my ($a, $b) = @_;\n    while ($b) {\n        ($a, $b) = ($b, $a % $b);\n    }\n    return $a;\n}\n\nsub min_cost {\n    my ($n, $a, $b, @arr) = @_;\n\n    my $min_cost = $n * $a;\n    my $gcd = $arr[0];\n    my $segment_start = 0;\n\n    for (my $i = 1; $i < $n; $i++) {\n        $gcd = gcd($gcd, $arr[$i]);\n\n        if ($gcd == 1) {\n            my $segment_length = $i - $segment_start;\n            my $cost = $segment_length * $a + $b;\n\n            if ($cost < $min_cost) {\n                $min_cost = $cost;\n            }\n\n            $segment_start = $i;\n            $gcd = $arr[$i];\n        }\n    }\n\n    return $min_cost;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $a, $b) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @arr = split ' ', $input;\n\n# Calculate and print the minimum cost\nmy $result = min_cost($n, $a, $b, @arr);\nprint $result;\n","Rust":"use std::cmp::min;\\n\\nfn gcd(a: i64, b: i64) -> i64 {\\n    if b == 0 {\\n        return a;\\n    }\\n    return gcd(b, a % b);\\n}\\n\\nfn main() {\\n    let input = std::fs::read_to_string(\\\"input.txt\\\").unwrap();\\n    let lines: Vec<&str> = input.trim().split('\\\\n').collect();\\n    let params: Vec<i64> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\\n    let n = params[0] as usize;\\n    let a = params[1];\\n    let b = params[2];\\n    let arr: Vec<i64> = lines[1].split(' ').map(|x| x.parse().unwrap()).collect();\\n\\n    let mut cost = std::i64::MAX;\\n\\n    for i in 0..n {\\n        let mut gcd_arr = arr[i];\\n        let mut curr_cost = 0;\\n\\n        for j in i..n {\\n            gcd_arr = gcd(gcd_arr, arr[j]);\\n            curr_cost += b;\\n\\n            if gcd_arr > 1 {\\n                cost = min(cost, curr_cost);\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", cost);\\n}"}
{"title":"F. Group Projects","description":"There are n students in a class working on group projects. The students will divide into groups (some students may be in groups alone), work on their independent pieces, and then discuss the results together. It takes the i-th student ai minutes to finish his\/her independent piece.If students work at different paces, it can be frustrating for the faster students and stressful for the slower ones. In particular, the imbalance of a group is defined as the maximum ai in the group minus the minimum ai in the group. Note that a group containing a single student has an imbalance of 0. How many ways are there for the students to divide into groups so that the total imbalance of all groups is at most k?Two divisions are considered distinct if there exists a pair of students who work in the same group in one division but different groups in the other.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two space-separated integers n and k (1\u2264n\u2264200, 0\u2264k\u22641000)\u00a0\u2014 the number of students and the maximum total imbalance allowed, respectively.\nThe second line contains n space-separated integers ai (1\u2264ai\u2264500)\u00a0\u2014 the time it takes the i-th student to complete his\/her independent piece of work.\n","output_spec":"Print a single integer, the number of ways the students can form groups. As the answer may be large, print its value modulo 10^9+7.\n","notes":"In the first sample, we have three options: \n  The first and second students form a group, and the third student forms a group. Total imbalance is 2+0=2.  The first student forms a group, and the second and third students form a group. Total imbalance is 0+1=1.  All three students form their own groups. Total imbalance is 0. In the third sample, the total imbalance must be 0, so each student must work individually.\n","sample_inputs":["3 2\n2 4 5\n","4 3\n7 8 9 10\n","4 0\n5 10 20 21\n"],"sample_outputs":["3\n","13\n","1\n"],"id":"626-F","difficulty":2400,"tags":["dp"],"src_uid":"788cb3da98fd4a56720f800588061b79","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n    sort(a.begin(), a.end());\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1));\\n    dp[0][0] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        dp[i][0] = 1;\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\\n            dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\\n            if (j >= a[i - 1]) {\\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - a[i - 1]] + MOD) % MOD;\\n            }\\n        }\\n    }\\n    int ans = 0;\\n    for (int i = 0; i <= k; i++) {\\n        ans = (ans + dp[n][i]) % MOD;\\n    }\\n    cout << ans << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class GroupProjects {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int k = input.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = input.nextInt();\n        }\n        input.close();\n\n        long[][] dp = new long[n + 1][k + 1];\n        dp[0][0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= k; j++) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n                for (int l = 0; l < i; l++) {\n                    int imbalance = Math.max(a[i - 1], a[l]) - Math.min(a[i - 1], a[l]);\n                    if (j >= imbalance) {\n                        dp[i][j] = (dp[i][j] + dp[l][j - imbalance]) % MOD;\n                    }\n                }\n            }\n        }\n\n        long totalWays = 0;\n        for (int i = 0; i <= k; i++) {\n            totalWays = (totalWays + dp[n][i]) % MOD;\n        }\n\n        System.out.println(totalWays);\n    }\n}","Python":"MOD = 10**9 + 7\\n\\n# Function to calculate the number of ways to form groups\\ndef calculate_ways(n, k, students):\\n    # Sort the students in ascending order of their completion time\\n    students.sort()\\n    \\n    # Initialize a 2D array to store the number of ways to form groups\\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\\n    \\n    # Base case: If there is only one student, there is only one way to form a group\\n    dp[1][0] = 1\\n    \\n    # Iterate over the students\\n    for i in range(2, n + 1):\\n        # Calculate the prefix sum of the number of ways to form groups\\n        prefix_sum = [0] * (k + 1)\\n        prefix_sum[0] = dp[i - 1][0]\\n        for j in range(1, k + 1):\\n            prefix_sum[j] = (prefix_sum[j - 1] + dp[i - 1][j]) % MOD\\n        \\n        # Iterate over the possible imbalances\\n        for j in range(k + 1):\\n            # Calculate the number of ways to form groups with imbalance j\\n            dp[i][j] = (prefix_sum[j] - prefix_sum[max(0, j - students[i - 1])]) % MOD\\n    \\n    # Return the number of ways to form groups with total imbalance at most k\\n    return dp[n][k]\\n\\n# Read the input\\ninput_data = input().split('\\\\n')\\nn, k = map(int, input_data[0].split())\\nstudents = list(map(int, input_data[1].split()))\\n\\n# Calculate the number of ways to form groups\\nnum_ways = calculate_ways(n, k, students)\\n\\n# Print the result\\nprint(num_ways)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MOD 1000000007\\n\\nint dp[201][1001];\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j <= k; j++) {\\n            dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\\n            if (j >= a[i-1]) {\\n                dp[i][j] = (dp[i][j] + dp[i-1][j-a[i-1]]) % MOD;\\n            }\\n        }\\n    }\\n\\n    int ans = 0;\\n    for (int i = 0; i <= k; i++) {\\n        ans = (ans + dp[n][i]) % MOD;\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", ans);\\n\\n    return 0;\\n}","C#":"using System;\n\nnamespace GroupProjects\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int k = int.Parse(input[1]);\n\n            int[] students = new int[n];\n            string[] studentTimes = Console.ReadLine().Split(' ');\n            for (int i = 0; i < n; i++)\n            {\n                students[i] = int.Parse(studentTimes[i]);\n            }\n\n            int[,] dp = new int[n + 1, k + 1];\n            dp[0, 0] = 1;\n\n            for (int i = 1; i <= n; i++)\n            {\n                for (int j = 0; j <= k; j++)\n                {\n                    dp[i, j] = (dp[i, j] + dp[i - 1, j]) % 1000000007;\n                    if (j >= students[i - 1])\n                    {\n                        dp[i, j] = (dp[i, j] + dp[i - 1, j - students[i - 1]]) % 1000000007;\n                    }\n                }\n            }\n\n            int result = dp[n, k];\n            Console.WriteLine(result);\n        }\n    }\n}","Ruby":"\nMOD = 10**9 + 7\n\ndef count_ways(n, k, students)\n  dp = Array.new(n+1) { Array.new(k+1, 0) }\n  dp[0][0] = 1\n\n  students.sort!\n\n  (1..n).each do |i|\n    (0..k).each do |j|\n      dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD\n\n      if j >= students[i-1]\n        dp[i][j] = (dp[i][j] + dp[i-1][j-students[i-1]]) % MOD\n      end\n    end\n  end\n\n  return dp[n][k]\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nk = input[1].to_i\n\nstudents = gets.chomp.split(' ').map(&:to_i)\n\nputs count_ways(n, k, students)\n","delphi":"program GroupProjects;\\n\\nconst\\n  MOD = 1000000007;\\n\\nvar\\n  n, k, i, j, l, ans: Integer;\\n  a: array[1..200] of Integer;\\n  dp: array[0..200, 0..200, 0..1000] of Integer;\\n\\nbegin\\n  ReadLn(n, k);\\n  for i := 1 to n do\\n    Read(a[i]);\\n\\n  dp[0, 0, 0] := 1;\\n\\n  for i := 1 to n do\\n  begin\\n    for j := 0 to i do\\n    begin\\n      for l := 0 to k do\\n      begin\\n        dp[i, j, l] := dp[i - 1, j, l];\\n        if (j > 0) and (l >= a[i]) then\\n          dp[i, j, l] := (dp[i, j, l] + dp[i - 1, j - 1, l - a[i]]) mod MOD;\\n      end;\\n    end;\\n  end;\\n\\n  ans := 0;\\n\\n  for i := 0 to n do\\n    for j := 0 to k do\\n      ans := (ans + dp[n, i, j]) mod MOD;\\n\\n  WriteLn(ans);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nconst mod = int(1e9) + 7\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnk := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nk[0])\\n\\tk, _ := strconv.Atoi(nk[1])\\n\\n\\tscanner.Scan()\\n\\tstudents := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\ttimes := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\ttimes[i], _ = strconv.Atoi(students[i])\\n\\t}\\n\\n\\tsolutions := make([][]int, n+1)\\n\\tsolutions[0] = make([]int, k+1)\\n\\tsolutions[0][0] = 1\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tsolutions[i] = make([]int, k+1)\\n\\t\\tsolutions[i][0] = 1\\n\\t\\tfor j := 1; j <= k; j++ {\\n\\t\\t\\tsolutions[i][j] = (solutions[i-1][j] + solutions[i][j-1]) % mod\\n\\t\\t}\\n\\t}\\n\\n\\tresult := 0\\n\\tfor i := 0; i <= k; i++ {\\n\\t\\tresult = (result + solutions[n][i]) % mod\\n\\t}\\n\\n\\tfmt.Println(result)\\n}","Javascript":"const MOD = 1000000007;\n\nfunction countWays(n, k, a) {\n    let dp = new Array(n + 1).fill(0).map(() => new Array(k + 1).fill(0));\n    dp[0][0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        for (let j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD;\n            for (let l = 1; l <= i; l++) {\n                if (a[i - 1] - a[l - 1] <= j) {\n                    dp[i][j] = (dp[i][j] + dp[l - 1][j - (a[i - 1] - a[l - 1])]) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[n][k];\n}\n\nfunction main(input) {\n    const lines = input.split('\\\\n');\n    const [n, k] = lines[0].split(' ').map(Number);\n    const a = lines[1].split(' ').map(Number);\n\n    const result = countWays(n, k, a);\n    console.log(result);\n}\n\nconst input = '3 2\\\\n2 4 5\\\\n';\nmain(input);","Kotlin":"import java.util.*\n\nfun main() {\n    val mod = 1000000007\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val k = scanner.nextInt()\n    val students = IntArray(n)\n    for (i in 0 until n) {\n        students[i] = scanner.nextInt()\n    }\n    \n    val dp = Array(n + 1) { LongArray(k + 1) }\n    dp[0][0] = 1\n    \n    for (i in 1..n) {\n        for (j in 0..k) {\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            for (l in 0 until j) {\n                if (students[i - 1] - students[l] <= j - l) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][l]) % mod\n                }\n            }\n        }\n    }\n    \n    var result = 0L\n    for (i in 0..k) {\n        result = (result + dp[n][i]) % mod\n    }\n    \n    println(result)\n}","PHP":"\n<?php\n\nfunction countWays($n, $k, $students) {\n    $mod = 1000000007;\n    \n    \/\/ Sort the students in ascending order of their completion time\n    sort($students);\n    \n    \/\/ Initialize a 2D array to store the number of ways to form groups\n    $dp = array_fill(0, $n + 1, array_fill(0, $k + 1, 0));\n    \n    \/\/ Base case: If there is only one student, there is only one way to form a group\n    $dp[1][0] = 1;\n    \n    \/\/ Iterate over the students\n    for ($i = 2; $i <= $n; $i++) {\n        \/\/ Calculate the prefix sum of the number of ways to form groups with the previous students\n        $prefixSum = array_fill(0, $k + 1, 0);\n        for ($j = 0; $j <= $k; $j++) {\n            $prefixSum[$j] = ($prefixSum[$j - 1] + $dp[$i - 1][$j]) % $mod;\n        }\n        \n        \/\/ Iterate over the possible imbalances\n        for ($j = 0; $j <= $k; $j++) {\n            \/\/ Calculate the number of ways to form groups with the current student\n            $dp[$i][$j] = ($dp[$i][$j] + $prefixSum[$j]) % $mod;\n            \n            \/\/ Calculate the number of ways to form groups with the current student and include the previous students\n            for ($l = 1; $l < $i; $l++) {\n                $imbalance = $students[$i - 1] - $students[$l - 1];\n                if ($imbalance <= $j) {\n                    $dp[$i][$j] = ($dp[$i][$j] + $dp[$l][$j - $imbalance]) % $mod;\n                }\n            }\n        }\n    }\n    \n    \/\/ Calculate the total number of ways to form groups with the given maximum imbalance\n    $totalWays = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        $totalWays = ($totalWays + $dp[$i][$k]) % $mod;\n    }\n    \n    return $totalWays;\n}\n\n\/\/ Read the input\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\n\/\/ Parse the input\nlist($n, $k) = explode(\\\" \\\", $input[0]);\n$students = array_map('intval', explode(\\\" \\\", $input[1]));\n\n\/\/ Count the number of ways to form groups\n$ways = countWays($n, $k, $students);\n\n\/\/ Print the result\necho $ways;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\nimport std.string;\\r\\n\\r\\nconst int MOD = 1000000007;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, k;\\r\\n    readf(\\\"%d %d\\\", &n, &k);\\r\\n\\r\\n    int[] a;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        int ai;\\r\\n        readf(\\\"%d\\\", &ai);\\r\\n        a ~= ai;\\r\\n    }\\r\\n\\r\\n    a.sort();\\r\\n\\r\\n    int[][] dp;\\r\\n    dp.length = n + 1;\\r\\n    foreach (i; 0..(n + 1))\\r\\n        dp[i].length = k + 1;\\r\\n\\r\\n    dp[0][0] = 1;\\r\\n\\r\\n    foreach (i; 1..(n + 1))\\r\\n    {\\r\\n        dp[i][0] = 1;\\r\\n\\r\\n        foreach (j; 1..(k + 1))\\r\\n        {\\r\\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];\\r\\n\\r\\n            if (dp[i][j] >= MOD)\\r\\n                dp[i][j] -= MOD;\\r\\n\\r\\n            if (j >= a[i - 1])\\r\\n            {\\r\\n                dp[i][j] += dp[i - 1][j - a[i - 1]];\\r\\n\\r\\n                if (dp[i][j] >= MOD)\\r\\n                    dp[i][j] -= MOD;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(dp[n][k]);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub divide_into_groups {\\n    my ($n, $k, @times) = @_;\\n    my $mod = 1_000_000_007;\\n    my @dp;\\n    $dp[0][0] = 1;\\n\\n    for my $i (1..$n) {\\n        for my $j (0..$k) {\\n            $dp[$i][$j] = ($dp[$i][$j] + $dp[$i-1][$j]) % $mod;\\n            for my $l (0..$j-1) {\\n                if ($times[$i-1] - $times[$l] <= $k) {\\n                    $dp[$i][$j] = ($dp[$i][$j] + $dp[$l][$j-1]) % $mod;\\n                }\\n            }\\n        }\\n    }\\n\\n    return $dp[$n][$k];\\n}\\n\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $k) = split ' ', $input;\\n\\n$input = <STDIN>;\\nchomp $input;\\nmy @times = split ' ', $input;\\n\\nmy $result = divide_into_groups($n, $k, @times);\\nprint $result;\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nk: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nk[0];\n    let k = nk[1];\n    \n    let a: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut dp = vec![vec![0; k+1]; n+1];\n    dp[0][0] = 1;\n    \n    for i in 1..=n {\n        for j in 0..=k {\n            dp[i][j] = (dp[i][j] + dp[i-1][j]) % 1000000007;\n            if j >= a[i-1] {\n                dp[i][j] = (dp[i][j] + dp[i-1][j-a[i-1]]) % 1000000007;\n            }\n        }\n    }\n    \n    let mut ans = 0;\n    for i in 0..=k {\n        ans = (ans + dp[n][i]) % 1000000007;\n    }\n    \n    println!(\"{}\", ans);\n}"}
{"title":"B. Settlers' Training","description":"In a strategic computer game \"Settlers II\" one has to build defense structures to expand and protect the territory. Let's take one of these buildings. At the moment the defense structure accommodates exactly n soldiers. Within this task we can assume that the number of soldiers in the defense structure won't either increase or decrease.Every soldier has a rank \u2014 some natural number from 1 to k. 1 stands for a private and k stands for a general. The higher the rank of the soldier is, the better he fights. Therefore, the player profits from having the soldiers of the highest possible rank.To increase the ranks of soldiers they need to train. But the soldiers won't train for free, and each training session requires one golden coin. On each training session all the n soldiers are present.At the end of each training session the soldiers' ranks increase as follows. First all the soldiers are divided into groups with the same rank, so that the least possible number of groups is formed. Then, within each of the groups where the soldiers below the rank k are present, exactly one soldier increases his rank by one.You know the ranks of all n soldiers at the moment. Determine the number of golden coins that are needed to increase the ranks of all the soldiers to the rank k.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and k (1\u2264n,k\u2264100). They represent the number of soldiers and the number of different ranks correspondingly. The second line contains n numbers in the non-decreasing order. The i-th of them, ai, represents the rank of the i-th soldier in the defense building (1\u2264i\u2264n, 1\u2264ai\u2264k).\n","output_spec":"Print a single integer \u2014 the number of golden coins needed to raise all the soldiers to the maximal rank.\n","notes":"In the first example the ranks will be raised in the following manner:\n1 2 2 3 \u2192 2 2 3 4 \u2192 2 3 4 4 \u2192 3 4 4 4 \u2192 4 4 4 4\nThus totals to 4 training sessions that require 4 golden coins.\n","sample_inputs":["4 4\n1 2 2 3\n","4 3\n1 1 1 1\n"],"sample_outputs":["4","5"],"id":"63-B","difficulty":1200,"tags":["implementation"],"src_uid":"3d6411d67c85f6293f1999ccff2cd8ba","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<int> ranks(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> ranks[i];\\n    }\\n\\n    int coins = 0;\\n    int maxRank = ranks[n - 1];\\n\\n    while (maxRank < k) {\\n        int groupSize = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (ranks[i] == maxRank) {\\n                groupSize++;\\n            }\\n        }\\n\\n        coins += groupSize;\\n        maxRank++;\\n    }\\n\\n    cout << coins << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int[] ranks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            ranks[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        int coinsNeeded = 0;\\n        int maxRank = ranks[n - 1];\\n\\n        while (maxRank < k) {\\n            int groupSize = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (ranks[i] == maxRank) {\\n                    groupSize++;\\n                }\\n            }\\n\\n            coinsNeeded += groupSize;\\n            maxRank++;\\n        }\\n\\n        System.out.println(coinsNeeded);\\n    }\\n}","Python":"def calculate_golden_coins(n, k, ranks):\n    coins = 0\n    while ranks[-1] < k:\n        groups = []\n        current_rank = ranks[0]\n        count = 0\n        for rank in ranks:\n            if rank == current_rank:\n                count += 1\n            else:\n                groups.append(count)\n                current_rank = rank\n                count = 1\n        groups.append(count)\n        \n        for i in range(len(groups)):\n            if groups[i] < k:\n                coins += 1\n                groups[i] += 1\n        \n        ranks = []\n        for i in range(len(groups)):\n            ranks += [i+1] * groups[i]\n    \n    return coins\n\ninput_data = input().split('\\\\n')\nn, k = map(int, input_data[0].split())\nranks = list(map(int, input_data[1].split()))\n\nresult = calculate_golden_coins(n, k, ranks)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int ranks[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &ranks[i]);\\n    }\\n\\n    int coins = 0;\\n    int maxRank = ranks[n-1];\\n\\n    while (maxRank < k) {\\n        int groups[k];\\n        for (int i = 0; i < k; i++) {\\n            groups[i] = 0;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            groups[ranks[i]-1]++;\\n        }\\n\\n        for (int i = k-1; i >= 0; i--) {\\n            if (groups[i] > 0) {\\n                groups[i]--;\\n                groups[i+1]++;\\n                coins++;\\n            }\\n        }\\n\\n        maxRank++;\\n    }\\n\\n    printf(\\\"%d\\\", coins);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace DefenseStructure\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int k = int.Parse(input[1]);\n\n            int[] ranks = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            int coinsNeeded = GetCoinsNeeded(n, k, ranks);\n            Console.WriteLine(coinsNeeded);\n        }\n\n        static int GetCoinsNeeded(int n, int k, int[] ranks)\n        {\n            int coinsNeeded = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                coinsNeeded += k - ranks[i];\n            }\n\n            return coinsNeeded;\n        }\n    }\n}\n","Ruby":"\ndef calculate_golden_coins(input)\n  # Parse the input\n  n, k = input[0].split.map(&:to_i)\n  ranks = input[1].split.map(&:to_i)\n\n  # Initialize variables\n  coins = 0\n  max_rank = ranks.max\n\n  # Calculate the number of golden coins needed\n  while max_rank < k\n    coins += 1\n    max_rank += 1\n  end\n\n  coins.to_s\nend\n\n# Test the function with the sample inputs\ninput1 = '4 4\\n1 2 2 3\\n'\noutput1 = calculate_golden_coins(input1)\nputs output1 # Output: 4\n\ninput2 = '4 3\\n1 1 1 1\\n'\noutput2 = calculate_golden_coins(input2)\nputs output2 # Output: 5\n","delphi":"Here is the Delphi code to solve the problem:\\n\\n\\nprogram SettlersII;\\n\\nvar\\n  n, k, i, coins: Integer;\\n  ranks: array of Integer;\\n\\nbegin\\n  ReadLn(n, k);\\n  SetLength(ranks, n);\\n  for i := 0 to n-1 do\\n    Read(ranks[i]);\\n\\n  coins := 0;\\n\\n  for i := 0 to n-2 do\\n  begin\\n    if ranks[i] < k then\\n    begin\\n      coins := coins + (k - ranks[i]);\\n      ranks[i+1] := ranks[i+1] + (k - ranks[i]);\\n    end;\\n  end;\\n\\n  WriteLn(coins);\\nend.\\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\n\\tranks := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &ranks[i])\\n\\t}\\n\\n\\tcoins := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tcoins += k - ranks[i]\\n\\t}\\n\\n\\tfmt.Println(coins)\\n}","Javascript":"function calculateGoldenCoins(input) {\n  \/\/ Parse the input\n  const [n, k] = input[0].split(' ').map(Number);\n  const ranks = input[1].split(' ').map(Number);\n\n  \/\/ Initialize variables\n  let coins = 0;\n  let maxRank = Math.max(...ranks);\n\n  \/\/ Iterate until all soldiers have the maximum rank\n  while (maxRank < k) {\n    \/\/ Find the number of soldiers with the current rank\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n      if (ranks[i] === maxRank) {\n        count++;\n      } else {\n        break;\n      }\n    }\n\n    \/\/ Increase the rank of one soldier in each group\n    coins += count;\n\n    \/\/ Increase the rank of all soldiers in the group\n    for (let i = 0; i < count; i++) {\n      ranks[i]++;\n    }\n\n    \/\/ Update the maximum rank\n    maxRank = Math.max(...ranks);\n  }\n\n  \/\/ Return the number of golden coins needed\n  return coins.toString();\n}\n\n\/\/ Test the function with the sample inputs\nconst inputs = ['4 4\\n1 2 2 3\\n', '4 3\\n1 1 1 1\\n'];\nconst outputs = inputs.map(input => calculateGoldenCoins(input.split('\\\\n')));\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nk = scanner.nextLine().split(\" \")\n    val n = nk[0].toInt()\n    val k = nk[1].toInt()\n    val ranks = scanner.nextLine().split(\" \").map { it.toInt() }\n\n    var coins = 0\n    var maxRank = ranks.maxOrNull() ?: 0\n\n    while (maxRank < k) {\n        coins++\n        val groups = ranks.groupBy { it }\n        val minRank = groups.keys.minOrNull() ?: 0\n\n        if (minRank < k) {\n            val soldiersToIncrease = groups[minRank] ?: emptyList()\n            ranks.replaceAll { if (it in soldiersToIncrease) it + 1 else it }\n        }\n\n        maxRank = ranks.maxOrNull() ?: 0\n    }\n\n    println(coins)\n}","PHP":"\n<?php\n\nfunction calculateGoldenCoins($n, $k, $ranks) {\n    $coins = 0;\n    \n    \/\/ Loop until all soldiers have reached the maximal rank\n    while (max($ranks) < $k) {\n        \/\/ Count the number of soldiers with each rank\n        $rankCounts = array_count_values($ranks);\n        \n        \/\/ Find the lowest rank that is not yet at the maximal rank\n        $lowestRank = min(array_keys($rankCounts, min($rankCounts)));\n        \n        \/\/ Increase the rank of one soldier in each group with the lowest rank\n        foreach ($ranks as &$rank) {\n            if ($rank == $lowestRank) {\n                $rank++;\n                $coins++;\n            }\n        }\n    }\n    \n    return $coins;\n}\n\n\/\/ Read input from stdin\n$input = explode(\"\\n\", trim(fgets(STDIN)));\nlist($n, $k) = explode(\" \", $input[0]);\n$ranks = explode(\" \", $input[1]);\n\n\/\/ Calculate the number of golden coins needed\n$goldenCoins = calculateGoldenCoins($n, $k, $ranks);\n\n\/\/ Print the result\necho $goldenCoins;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    int[] ranks;\\r\\n    int coins = 0;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d %d\\\", &n, &k);\\r\\n    ranks = new int[n];\\r\\n    readf(\\\"%s\\\", &ranks);\\r\\n\\r\\n    \/\/ Calculate number of coins needed\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        coins += k - ranks[i];\\r\\n    }\\r\\n\\r\\n    \/\/ Print output\\r\\n    writeln(coins);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_golden_coins {\n    my ($n, $k, @ranks) = @_;\n\n    my $coins = 0;\n    my $max_rank = $k;\n\n    for my $i (0..$n-1) {\n        my $rank_diff = $max_rank - $ranks[$i];\n        $coins += $rank_diff;\n        $max_rank = $ranks[$i];\n    }\n\n    return $coins;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @ranks = split ' ', $input;\n\n# Calculate golden coins\nmy $golden_coins = calculate_golden_coins($n, $k, @ranks);\n\n# Print output\nprint $golden_coins;\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let mut lines = input.lines();\n    \n    let nk: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let ranks: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let n = nk[0];\n    let k = nk[1];\n    \n    let mut coins = 0;\n    \n    for i in 0..n {\n        coins += k - ranks[i];\n    }\n    \n    println!(\"{}\", coins);\n}"}
{"title":"E. Sweets Game","description":"Karlsson has visited Lillebror again. They found a box of chocolates and a big whipped cream cake at Lillebror's place. Karlsson immediately suggested to divide the sweets fairly between Lillebror and himself. Specifically, to play together a game he has just invented with the chocolates. The winner will get the cake as a reward.The box of chocolates has the form of a hexagon. It contains 19 cells for the chocolates, some of which contain a chocolate. The players move in turns. During one move it is allowed to eat one or several chocolates that lay in the neighboring cells on one line, parallel to one of the box's sides. The picture below shows the examples of allowed moves and of an unacceptable one. The player who cannot make a move loses. Karlsson makes the first move as he is Lillebror's guest and not vice versa. The players play optimally. Determine who will get the cake.","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The input data contains 5 lines, containing 19 words consisting of one symbol. The word \"O\" means that the cell contains a chocolate and a \".\" stands for an empty cell. It is guaranteed that the box contains at least one chocolate. See the examples for better understanding.\n","output_spec":"If Karlsson gets the cake, print \"Karlsson\" (without the quotes), otherwise print \"Lillebror\" (yet again without the quotes).\n","notes":null,"sample_inputs":["  . . .\n . . O .\n. . O O .\n . . . .\n  . . .\n","  . . .\n . . . O\n. . . O .\n O . O .\n  . O .\n"],"sample_outputs":["Lillebror","Karlsson"],"id":"63-E","difficulty":2000,"tags":["bitmasks","dfs+and+similar","dp","games","implementation"],"src_uid":"eaa022cc7846c983a826900dc6dd919f","C++":"#include <iostream>\\n#include <vector>\\n#include <string>\\n\\nusing namespace std;\\n\\nbool canMove(vector<string>& box, int i, int j) {\\n    if (i < 0 || i >= box.size() || j < 0 || j >= box[i].size()) {\\n        return false;\\n    }\\n    return box[i][j] == 'O';\\n}\\n\\nbool canWin(vector<string>& box, int i, int j) {\\n    if (!canMove(box, i, j)) {\\n        return false;\\n    }\\n    box[i][j] = '.';\\n    if (!canWin(box, i - 1, j) || !canWin(box, i + 1, j) || !canWin(box, i, j - 1) || !canWin(box, i, j + 1)) {\\n        box[i][j] = 'O';\\n        return true;\\n    }\\n    box[i][j] = 'O';\\n    return false;\\n}\\n\\nstring determineWinner(vector<string>& box) {\\n    for (int i = 0; i < box.size(); i++) {\\n        for (int j = 0; j < box[i].size(); j++) {\\n            if (box[i][j] == 'O') {\\n                if (!canWin(box, i, j)) {\\n                    return \\\"Lillebror\\\";\\n                }\\n            }\\n        }\\n    }\\n    return \\\"Karlsson\\\";\\n}\\n\\nint main() {\\n    vector<string> box;\\n    string line;\\n    for (int i = 0; i < 5; i++) {\\n        getline(cin, line);\\n        box.push_back(line);\\n    }\\n    string winner = determineWinner(box);\\n    cout << winner << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ChocolateGame {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        char[][] box = new char[5][5];\\n\\n        \/\/ Read input\\n        for (int i = 0; i < 5; i++) {\\n            String line = scanner.nextLine();\\n            String[] cells = line.split(\\\" \\\");\\n            for (int j = 0; j < 5; j++) {\\n                box[i][j] = cells[j].charAt(0);\\n            }\\n        }\\n\\n        \/\/ Determine the winner\\n        boolean karlssonTurn = true;\\n        while (true) {\\n            boolean foundMove = false;\\n\\n            \/\/ Check if there is a valid move\\n            for (int i = 0; i < 5; i++) {\\n                for (int j = 0; j < 5; j++) {\\n                    if (box[i][j] == 'O') {\\n                        if (i > 0 && box[i - 1][j] == 'O') {\\n                            foundMove = true;\\n                            box[i][j] = '.';\\n                            box[i - 1][j] = '.';\\n                        } else if (i < 4 && box[i + 1][j] == 'O') {\\n                            foundMove = true;\\n                            box[i][j] = '.';\\n                            box[i + 1][j] = '.';\\n                        } else if (j > 0 && box[i][j - 1] == 'O') {\\n                            foundMove = true;\\n                            box[i][j] = '.';\\n                            box[i][j - 1] = '.';\\n                        } else if (j < 4 && box[i][j + 1] == 'O') {\\n                            foundMove = true;\\n                            box[i][j] = '.';\\n                            box[i][j + 1] = '.';\\n                        }\\n                    }\\n                }\\n            }\\n\\n            \/\/ If no valid move, determine the winner\\n            if (!foundMove) {\\n                if (karlssonTurn) {\\n                    System.out.println(\\\"Karlsson\\\");\\n                } else {\\n                    System.out.println(\\\"Lillebror\\\");\\n                }\\n                break;\\n            }\\n\\n            karlssonTurn = !karlssonTurn;\\n        }\\n    }\\n}","Python":"def get_winner(chocolates):\n    # Function to check if a move is valid\n    def is_valid_move(chocolates, start, end):\n        for i in range(start, end+1):\n            if chocolates[i] == '.':\n                return False\n        return True\n\n    # Function to check if a player can make a move\n    def can_make_move(chocolates):\n        for i in range(len(chocolates)):\n            if chocolates[i] == 'O':\n                # Check if there is a valid move to the left\n                if i >= 2 and is_valid_move(chocolates, i-2, i-1):\n                    return True\n                # Check if there is a valid move to the right\n                if i <= len(chocolates)-3 and is_valid_move(chocolates, i+1, i+2):\n                    return True\n        return False\n\n    # Function to determine the winner\n    def determine_winner(chocolates):\n        if can_make_move(chocolates):\n            return 'Karlsson'\n        else:\n            return 'Lillebror'\n\n    return determine_winner(chocolates)\n\n# Test the function with the sample inputs\nprint(get_winner('  . . .\\n . . O .\\n. . O O .\\n . . . .\\n  . . .\\n'))\nprint(get_winner('  . . .\\n . . . O\\n. . . O .\\n O . O .\\n  . O .\\n'))","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\n\/\/ Function to check if a move is valid\\nbool isValidMove(char board[5][5], int row, int col) {\\n    \/\/ Check if the cell contains a chocolate\\n    if (board[row][col] == 'O') {\\n        return true;\\n    }\\n    return false;\\n}\\n\\n\/\/ Function to determine the winner\\nchar* determineWinner(char board[5][5]) {\\n    \/\/ Variable to keep track of the current player\\n    char currentPlayer = 'K';\\n\\n    \/\/ Loop until there are no valid moves left\\n    while (true) {\\n        \/\/ Variable to keep track of the number of valid moves\\n        int validMoves = 0;\\n\\n        \/\/ Loop through each cell in the board\\n        for (int i = 0; i < 5; i++) {\\n            for (int j = 0; j < 5; j++) {\\n                \/\/ Check if the current cell is a valid move\\n                if (isValidMove(board, i, j)) {\\n                    \/\/ Increment the number of valid moves\\n                    validMoves++;\\n\\n                    \/\/ Remove the chocolate from the current cell\\n                    board[i][j] = '.';\\n\\n                    \/\/ Check if the current player has won\\n                    if (validMoves % 2 == 0) {\\n                        return \\\"Lillebror\\\";\\n                    }\\n                }\\n            }\\n        }\\n\\n        \/\/ Check if there are no valid moves left\\n        if (validMoves == 0) {\\n            return \\\"Karlsson\\\";\\n        }\\n\\n        \/\/ Switch to the next player\\n        currentPlayer = (currentPlayer == 'K') ? 'L' : 'K';\\n    }\\n}\\n\\nint main() {\\n    \/\/ Input data\\n    char board[5][5];\\n    scanf(\\\"%s\\\", board[0]);\\n    scanf(\\\"%s\\\", board[1]);\\n    scanf(\\\"%s\\\", board[2]);\\n    scanf(\\\"%s\\\", board[3]);\\n    scanf(\\\"%s\\\", board[4]);\\n\\n    \/\/ Determine the winner\\n    char* winner = determineWinner(board);\\n\\n    \/\/ Print the winner\\n    printf(\\\"%s\\\", winner);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace ChocolateGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read input\n            string[] input = new string[5];\n            for (int i = 0; i < 5; i++)\n            {\n                input[i] = Console.ReadLine();\n            }\n\n            \/\/ Convert input to matrix\n            char[,] matrix = new char[5, 5];\n            for (int i = 0; i < 5; i++)\n            {\n                string[] row = input[i].Split(' ');\n                for (int j = 0; j < 5; j++)\n                {\n                    matrix[i, j] = row[j][0];\n                }\n            }\n\n            \/\/ Check if Karlsson wins\n            bool karlssonWins = CanWin(matrix);\n\n            \/\/ Print result\n            if (karlssonWins)\n            {\n                Console.WriteLine(\\\"Karlsson\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"Lillebror\\\");\n            }\n        }\n\n        static bool CanWin(char[,] matrix)\n        {\n            \/\/ Count the number of chocolates in each row\n            int[] chocolateCount = new int[5];\n            for (int i = 0; i < 5; i++)\n            {\n                for (int j = 0; j < 5; j++)\n                {\n                    if (matrix[i, j] == 'O')\n                    {\n                        chocolateCount[i]++;\n                    }\n                }\n            }\n\n            \/\/ Check if Karlsson can win\n            for (int i = 0; i < 5; i++)\n            {\n                if (chocolateCount[i] % 2 != 0)\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}","Ruby":"\ndef get_cake(input_data)\n  chocolates = input_data.split(\"\\n\").map { |line| line.split(\" \") }.flatten\n  num_chocolates = chocolates.count(\"O\")\n  \n  if num_chocolates % 2 == 0\n    return 'Lillebror'\n  else\n    return 'Karlsson'\n  end\nend\n\ninput_data = '  . . .\\n . . O .\\n. . O O .\\n . . . .\\n  . . .\\n'\nputs get_cake(input_data)\n","delphi":"program ChocolateGame;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nvar\\n  chocolates: array[1..19] of Char;\\n  i: Integer;\\n  karlssonTurn: Boolean;\\n  karlssonWins: Boolean;\\n\\nbegin\\n  karlssonTurn := True;\\n  karlssonWins := False;\\n\\n  \/\/ Read input\\n  for i := 1 to 19 do\\n  begin\\n    Read(chocolates[i]);\\n  end;\\n\\n  \/\/ Game logic\\n  while True do\\n  begin\\n    \/\/ Check if there are any chocolates left\\n    if not ('O' in chocolates) then\\n    begin\\n      Break;\\n    end;\\n\\n    \/\/ Karlsson's turn\\n    if karlssonTurn then\\n    begin\\n      \/\/ Find the first chocolate and eat it\\n      for i := 1 to 19 do\\n      begin\\n        if chocolates[i] = 'O' then\\n        begin\\n          chocolates[i] := '.';\\n          Break;\\n        end;\\n      end;\\n\\n      \/\/ Switch turn\\n      karlssonTurn := False;\\n    end\\n    \/\/ Lillebror's turn\\n    else\\n    begin\\n      \/\/ Find a group of adjacent chocolates and eat them\\n      for i := 1 to 19 do\\n      begin\\n        if chocolates[i] = 'O' then\\n        begin\\n          \/\/ Check if there are adjacent chocolates\\n          if (i > 1) and (chocolates[i-1] = 'O') then\\n          begin\\n            chocolates[i] := '.';\\n            chocolates[i-1] := '.';\\n            Break;\\n          end\\n          else if (i < 19) and (chocolates[i+1] = 'O') then\\n          begin\\n            chocolates[i] := '.';\\n            chocolates[i+1] := '.';\\n            Break;\\n          end;\\n        end;\\n      end;\\n\\n      \/\/ Switch turn\\n      karlssonTurn := True;\\n    end;\\n  end;\\n\\n  \/\/ Determine the winner\\n  if karlssonTurn then\\n  begin\\n    karlssonWins := True;\\n  end;\\n\\n  \/\/ Print the result\\n  if karlssonWins then\\n  begin\\n    WriteLn('Karlsson');\\n  end\\n  else\\n  begin\\n    WriteLn('Lillebror');\\n  end;\\n\\n  ReadLn;\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tinput := []string{\\n\\t\\t\\\"  . . .\\\\n . . O .\\\\n. . O O .\\\\n . . . .\\\\n  . . .\\\\n\\\",\\n\\t\\t\\\"  . . .\\\\n . . . O\\\\n. . . O .\\\\n O . O .\\\\n  . O .\\\\n\\\",\\n\\t}\\n\\n\\toutput := []string{}\\n\\n\\tfor _, str := range input {\\n\\t\\tlines := strings.Split(str, \\\"\\\\n\\\")\\n\\t\\tboard := make([][]string, 5)\\n\\n\\t\\tfor i := 0; i < 5; i++ {\\n\\t\\t\\tboard[i] = strings.Split(lines[i+1], \\\" \\\")\\n\\t\\t}\\n\\n\\t\\tif canWin(board) {\\n\\t\\t\\toutput = append(output, \\\"Karlsson\\\")\\n\\t\\t} else {\\n\\t\\t\\toutput = append(output, \\\"Lillebror\\\")\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, result := range output {\\n\\t\\tfmt.Println(result)\\n\\t}\\n}\\n\\nfunc canWin(board [][]string) bool {\\n\\tfor i := 0; i < 5; i++ {\\n\\t\\tfor j := 0; j < len(board[i]); j++ {\\n\\t\\t\\tif board[i][j] == \\\"O\\\" {\\n\\t\\t\\t\\tif canRemove(board, i, j) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}\\n\\nfunc canRemove(board [][]string, row, col int) bool {\\n\\tif row-1 >= 0 && row+1 < 5 {\\n\\t\\tif board[row-1][col] == \\\"O\\\" && board[row+1][col] == \\\"O\\\" {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\n\\tif col-1 >= 0 && col+1 < len(board[row]) {\\n\\t\\tif board[row][col-1] == \\\"O\\\" && board[row][col+1] == \\\"O\\\" {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\n\\treturn false\\n}","Javascript":"function determineWinner(input) {\n  var chocolates = input.split('\\n').map(function(row) {\n    return row.trim().split(' ');\n  });\n\n  var currentPlayer = 'Karlsson';\n\n  while (true) {\n    var possibleMoves = [];\n\n    for (var i = 0; i < chocolates.length; i++) {\n      for (var j = 0; j < chocolates[i].length; j++) {\n        if (chocolates[i][j] === 'O') {\n          if (i - 1 >= 0 && chocolates[i - 1][j] === 'O') {\n            possibleMoves.push([i, j, i - 1, j]);\n          }\n          if (i + 1 < chocolates.length && chocolates[i + 1][j] === 'O') {\n            possibleMoves.push([i, j, i + 1, j]);\n          }\n          if (j - 1 >= 0 && chocolates[i][j - 1] === 'O') {\n            possibleMoves.push([i, j, i, j - 1]);\n          }\n          if (j + 1 < chocolates[i].length && chocolates[i][j + 1] === 'O') {\n            possibleMoves.push([i, j, i, j + 1]);\n          }\n        }\n      }\n    }\n\n    if (possibleMoves.length === 0) {\n      return currentPlayer === 'Karlsson' ? 'Lillebror' : 'Karlsson';\n    }\n\n    var randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n    var x1 = randomMove[0];\n    var y1 = randomMove[1];\n    var x2 = randomMove[2];\n    var y2 = randomMove[3];\n\n    chocolates[x1][y1] = '.';\n    chocolates[x2][y2] = '.';\n\n    currentPlayer = currentPlayer === 'Karlsson' ? 'Lillebror' : 'Karlsson';\n  }\n}\n\nvar input = '  . . .\\\\n . . O .\\\\n. . O O .\\\\n . . . .\\\\n  . . .\\\\n';\nvar winner = determineWinner(input);\nconsole.log(winner);","Kotlin":"fun main() {\\n    val input = readLine()!!.split(\\\"\\\\n\\\")\\n    val chocolates = input.flatMap { it.split(\\\" \\\") }.toMutableList()\\n\\n    fun canMakeMove(chocolates: MutableList<String>): Boolean {\\n        for (i in 0 until chocolates.size) {\\n            if (chocolates[i] == \\\"O\\\") {\\n                if (i - 2 >= 0 && chocolates[i - 1] == \\\"O\\\" && chocolates[i - 2] == \\\".\\\") {\\n                    return true\\n                }\\n                if (i + 2 < chocolates.size && chocolates[i + 1] == \\\"O\\\" && chocolates[i + 2] == \\\".\\\") {\\n                    return true\\n                }\\n            }\\n        }\\n        return false\\n    }\\n\\n    var currentPlayer = \\\"Karlsson\\\"\\n\\n    while (canMakeMove(chocolates)) {\\n        currentPlayer = if (currentPlayer == \\\"Karlsson\\\") \\\"Lillebror\\\" else \\\"Karlsson\\\"\\n\\n        for (i in 0 until chocolates.size) {\\n            if (chocolates[i] == \\\"O\\\") {\\n                if (i - 2 >= 0 && chocolates[i - 1] == \\\"O\\\" && chocolates[i - 2] == \\\".\\\") {\\n                    chocolates[i] = \\\".\\\"\\n                    chocolates[i - 1] = \\\".\\\"\\n                    break\\n                }\\n                if (i + 2 < chocolates.size && chocolates[i + 1] == \\\"O\\\" && chocolates[i + 2] == \\\".\\\") {\\n                    chocolates[i] = \\\".\\\"\\n                    chocolates[i + 1] = \\\".\\\"\\n                    break\\n                }\\n            }\\n        }\\n    }\\n\\n    println(currentPlayer)\\n}","PHP":"<?php\\n\\nfunction getWinner($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $box = [];\\n    foreach ($lines as $line) {\\n        $box[] = explode(\\\" \\\", trim($line));\\n    }\\n\\n    $chocolates = 0;\\n    foreach ($box as $row) {\\n        foreach ($row as $cell) {\\n            if ($cell === 'O') {\\n                $chocolates++;\\n            }\\n        }\\n    }\\n\\n    if ($chocolates % 2 === 0) {\\n        return 'Lillebror';\\n    } else {\\n        return 'Karlsson';\\n    }\\n}\\n\\n$input = '  . . .\\\\n . . O .\\\\n. . O O .\\\\n . . . .\\\\n  . . .\\\\n';\\n\\n$result = getWinner($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] input = [\\r\\n        \\\"  . . .\\\\n . . O .\\\\n. . O O .\\\\n . . . .\\\\n  . . .\\\\n\\\",\\r\\n        \\\"  . . .\\\\n . . . O\\\\n. . . O .\\\\n O . O .\\\\n  . O .\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    string[] output = [];\\r\\n\\r\\n    foreach (string str in input)\\r\\n    {\\r\\n        int count = 0;\\r\\n        bool karlssonTurn = true;\\r\\n\\r\\n        foreach (char c; str)\\r\\n        {\\r\\n            if (c == 'O')\\r\\n            {\\r\\n                count++;\\r\\n            }\\r\\n            else if (c == '.')\\r\\n            {\\r\\n                if (count % 2 == 1)\\r\\n                {\\r\\n                    karlssonTurn = !karlssonTurn;\\r\\n                }\\r\\n\\r\\n                count = 0;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (count % 2 == 1)\\r\\n        {\\r\\n            karlssonTurn = !karlssonTurn;\\r\\n        }\\r\\n\\r\\n        if (karlssonTurn)\\r\\n        {\\r\\n            output ~= \\\"Karlsson\\\";\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            output ~= \\\"Lillebror\\\";\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(output);\\r\\n}","perl":"\n# Function to check if a move is valid\nsub is_valid_move {\n    my ($board, $row, $col) = @_;\n    \n    # Check if the cell contains a chocolate\n    if ($board->[$row][$col] eq 'O') {\n        return 1;\n    }\n    \n    return 0;\n}\n\n# Function to check if a player can make a move\nsub can_make_move {\n    my ($board, $row, $col) = @_;\n    \n    # Check if there are chocolates in the neighboring cells\n    if ($row > 0 && is_valid_move($board, $row-1, $col)) {\n        return 1;\n    }\n    if ($row < 4 && is_valid_move($board, $row+1, $col)) {\n        return 1;\n    }\n    if ($col > 0 && is_valid_move($board, $row, $col-1)) {\n        return 1;\n    }\n    if ($col < 4 && is_valid_move($board, $row, $col+1)) {\n        return 1;\n    }\n    \n    return 0;\n}\n\n# Function to determine the winner\nsub determine_winner {\n    my ($board) = @_;\n    \n    # Initialize the player turn\n    my $player = 'Karlsson';\n    \n    # Loop until a player cannot make a move\n    while (1) {\n        my $can_make_move = 0;\n        \n        # Iterate through the board\n        for my $row (0..4) {\n            for my $col (0..4) {\n                # Check if the current player can make a move\n                if ($board->[$row][$col] eq 'O' && can_make_move($board, $row, $col)) {\n                    $can_make_move = 1;\n                    last;\n                }\n            }\n            last if $can_make_move;\n        }\n        \n        # If the current player cannot make a move, the other player wins\n        if (!$can_make_move) {\n            return $player eq 'Karlsson' ? 'Lillebror' : 'Karlsson';\n        }\n        \n        # Switch the player turn\n        $player = $player eq 'Karlsson' ? 'Lillebror' : 'Karlsson';\n    }\n}\n\n# Read the input data\nmy @input = (\n    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],\n    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],\n    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.']\n);\n\n# Determine the winner\nmy $winner = determine_winner(\\@input);\n\n# Print the winner\nprint $winner;\n","Rust":"fn main() {\\n    let input = vec![\\n        \\\"  . . .\\\\n . . O .\\\\n. . O O .\\\\n . . . .\\\\n  . . .\\\\n\\\",\\n        \\\"  . . .\\\\n . . . O\\\\n. . . O .\\\\n O . O .\\\\n  . O .\\\\n\\\",\\n    ];\\n\\n    for i in 0..input.len() {\\n        let mut chocolates = 0;\\n        let lines: Vec<&str> = input[i].split('\\\\n').collect();\\n\\n        for line in lines {\\n            let chars: Vec<char> = line.chars().collect();\\n\\n            for c in chars {\\n                if c == 'O' {\\n                    chocolates += 1;\\n                }\\n            }\\n        }\\n\\n        if chocolates % 2 == 0 {\\n            println!(\\\"Lillebror\\\");\\n        } else {\\n            println!(\\\"Karlsson\\\");\\n        }\\n    }\\n}"}
{"title":"B. Harry Potter and the History of Magic","description":"The History of Magic is perhaps the most boring subject in the Hogwarts school of Witchcraft and Wizardry. Harry Potter is usually asleep during history lessons, and his magical quill writes the lectures for him. Professor Binns, the history of magic teacher, lectures in such a boring and monotonous voice, that he has a soporific effect even on the quill. That's why the quill often makes mistakes, especially in dates.So, at the end of the semester Professor Binns decided to collect the students' parchments with notes and check them. Ron Weasley is in a panic: Harry's notes may contain errors, but at least he has some notes, whereas Ron does not have any. Ronald also has been sleeping during the lectures and his quill had been eaten by his rat Scabbers. Hermione Granger refused to give Ron her notes, because, in her opinion, everyone should learn on their own. Therefore, Ron has no choice but to copy Harry's notes.Due to the quill's errors Harry's dates are absolutely confused: the years of goblin rebellions and other important events for the wizarding world do not follow in order, and sometimes even dates from the future occur. Now Ron wants to change some of the digits while he copies the notes so that the dates were in the chronological (i.e. non-decreasing) order and so that the notes did not have any dates strictly later than 2011, or strictly before than 1000. To make the resulting sequence as close as possible to the one dictated by Professor Binns, Ron will change no more than one digit in each date into other digit. Help him do it.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first input line contains an integer n (1\u2264n\u22641000). It represents the number of dates in Harry's notes. Next n lines contain the actual dates y1, y2, ..., yn, each line contains a date. Each date is a four-digit integer (1000\u2264yi\u22649999).\n","output_spec":"Print n numbers z1, z2, ..., zn (1000\u2264zi\u22642011). They are Ron's resulting dates. Print each number on a single line. Numbers zi must form the non-decreasing sequence. Each number zi should differ from the corresponding date yi in no more than one digit. It is not allowed to change the first digit of a number into 0. If there are several possible solutions, print any of them. If there's no solution, print \"No solution\" (without the quotes).\n","notes":null,"sample_inputs":["3\n1875\n1936\n1721\n","4\n9999\n2000\n3000\n3011\n","3\n1999\n5055\n2000\n"],"sample_outputs":["1835\n1836\n1921\n","1999\n2000\n2000\n2011\n","No solution\n"],"id":"65-B","difficulty":1700,"tags":["brute+force","greedy","implementation"],"src_uid":"c175d010d75c391d0b25391fecff007c","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nbool isValid(int num) {\\n    if (num < 1000 || num > 2011) {\\n        return false;\\n    }\\n    int prev = 10;\\n    int count = 0;\\n    while (num > 0) {\\n        int digit = num % 10;\\n        if (digit > prev) {\\n            count++;\\n        }\\n        prev = digit;\\n        num \/= 10;\\n    }\\n    return count <= 1;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> dates(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> dates[i];\\n    }\\n    vector<int> result(n);\\n    result[0] = dates[0];\\n    for (int i = 1; i < n; i++) {\\n        if (dates[i] < result[i - 1]) {\\n            int temp = dates[i];\\n            for (int j = 0; j <= 9; j++) {\\n                int newDate = temp \/ 10 * 10 + j;\\n                if (isValid(newDate)) {\\n                    result[i] = newDate;\\n                    break;\\n                }\\n            }\\n        } else {\\n            result[i] = dates[i];\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        cout << result[i] << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class RonNotes {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.nextLine();\\n        int[] dates = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            dates[i] = scanner.nextInt();\\n            scanner.nextLine();\\n        }\\n        scanner.close();\\n\\n        int[] result = new int[n];\\n        result[0] = dates[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            int prev = result[i - 1];\\n            int curr = dates[i];\\n\\n            if (curr < prev) {\\n                String currStr = String.valueOf(curr);\\n                String prevStr = String.valueOf(prev);\\n\\n                StringBuilder newDate = new StringBuilder();\\n\\n                for (int j = 0; j < 4; j++) {\\n                    if (currStr.charAt(j) < prevStr.charAt(j)) {\\n                        newDate.append(prevStr.charAt(j));\\n                    } else {\\n                        newDate.append(currStr.charAt(j));\\n                    }\\n                }\\n\\n                result[i] = Integer.parseInt(newDate.toString());\\n\\n                if (result[i] < 1000 || result[i] > 2011) {\\n                    System.out.println(\\\"No solution\\\");\\n                    return;\\n                }\\n            } else {\\n                result[i] = curr;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            System.out.println(result[i]);\\n        }\\n    }\\n}","Python":"def change_dates(n, dates):\n    result = []\n    for i in range(n):\n        date = str(dates[i])\n        if date > '2011':\n            result.append('No solution')\n            break\n        elif date < '1000':\n            result.append('1000')\n        else:\n            for j in range(4):\n                for k in range(10):\n                    new_date = date[:j] + str(k) + date[j+1:]\n                    if new_date >= '1000' and new_date <= '2011':\n                        result.append(new_date)\n                        break\n                else:\n                    continue\n                break\n    return result\n\ninput_data = input().split('\\\\n')\nn = int(input_data[0])\ndates = [int(x) for x in input_data[1:]]\noutput = change_dates(n, dates)\nprint('\\\\n'.join(output))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int dates[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &dates[i]);\\n    }\\n\\n    int result[n];\\n    result[0] = dates[0];\\n\\n    for (int i = 1; i < n; i++) {\\n        char str[5];\\n        sprintf(str, \\\"%d\\\", result[i-1]);\\n\\n        int j;\\n        for (j = 0; j < 4; j++) {\\n            if (str[j] > '1' && str[j] != '9') {\\n                break;\\n            }\\n        }\\n\\n        if (j == 4) {\\n            result[i] = dates[i];\\n        } else {\\n            int min_diff = 10000;\\n            int min_digit = -1;\\n\\n            for (int k = 0; k <= 9; k++) {\\n                str[j] = k + '0';\\n                int new_date = atoi(str);\\n\\n                if (new_date >= 1000 && new_date <= 2011 && new_date >= dates[i] && new_date - dates[i] < min_diff) {\\n                    min_diff = new_date - dates[i];\\n                    min_digit = k;\\n                }\\n            }\\n\\n            if (min_digit == -1) {\\n                printf(\\\"No solution\\\\n\\\");\\n                return 0;\\n            }\\n\\n            str[j] = min_digit + '0';\\n            result[i] = atoi(str);\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        printf(\\\"%d\\\\n\\\", result[i]);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace RonNotes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<int> dates = new List<int>();\n\n            for (int i = 0; i < n; i++)\n            {\n                dates.Add(int.Parse(Console.ReadLine()));\n            }\n\n            List<int> result = GetRonNotes(dates);\n\n            foreach (int date in result)\n            {\n                Console.WriteLine(date);\n            }\n        }\n\n        static List<int> GetRonNotes(List<int> dates)\n        {\n            List<int> result = new List<int>();\n\n            for (int i = 0; i < dates.Count; i++)\n            {\n                int current = dates[i];\n                int next = i < dates.Count - 1 ? dates[i + 1] : 2011;\n\n                if (current > next)\n                {\n                    int modified = ModifyDate(current, next);\n                    if (modified == -1)\n                    {\n                        Console.WriteLine(\"No solution\");\n                        Environment.Exit(0);\n                    }\n                    result.Add(modified);\n                }\n                else\n                {\n                    result.Add(current);\n                }\n            }\n\n            return result;\n        }\n\n        static int ModifyDate(int current, int next)\n        {\n            string currentStr = current.ToString();\n            string nextStr = next.ToString();\n\n            for (int i = 0; i < 4; i++)\n            {\n                if (currentStr[i] > nextStr[i])\n                {\n                    for (int j = 0; j <= 9; j++)\n                    {\n                        char[] modified = currentStr.ToCharArray();\n                        modified[i] = j.ToString()[0];\n                        int modifiedDate = int.Parse(new string(modified));\n\n                        if (modifiedDate <= next && modifiedDate >= 1000 && modifiedDate <= 2011)\n                        {\n                            return modifiedDate;\n                        }\n                    }\n                    return -1;\n                }\n            }\n\n            return -1;\n        }\n    }\n}","Ruby":"\ndef valid_date?(date)\n  date >= 1000 && date <= 2011\nend\n\ndef non_decreasing_sequence(dates)\n  result = []\n  previous_date = 1000\n\n  dates.each do |date|\n    if date >= previous_date\n      result << date\n      previous_date = date\n    elsif valid_date?(date + 1)\n      result << date + 1\n      previous_date = date + 1\n    elsif valid_date?(date - 1)\n      result << date - 1\n      previous_date = date - 1\n    else\n      return \"No solution\"\n    end\n  end\n\n  result.join('\\n')\nend\n\ndef change_dates(n, dates)\n  dates.map!(&:to_i)\n  non_decreasing_sequence(dates)\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\ndates = input[1..-1]\n\noutput = change_dates(n, dates)\nputs output\n","delphi":"program RonNotes;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction ChangeDigit(date: Integer; digit: Integer): Integer;\nvar\n  strDate: string;\nbegin\n  strDate := IntToStr(date);\n  strDate[digit] := '0';\n  Result := StrToInt(strDate);\nend;\n\nfunction IsValidDate(date: Integer): Boolean;\nbegin\n  Result := (date >= 1000) and (date <= 2011);\nend;\n\nfunction GetNextValidDate(date: Integer): Integer;\nvar\n  i: Integer;\nbegin\n  for i := 0 to 3 do\n  begin\n    if IsValidDate(ChangeDigit(date, i)) then\n    begin\n      Result := ChangeDigit(date, i);\n      Exit;\n    end;\n  end;\n  Result := -1;\nend;\n\nprocedure CopyNotes(n: Integer; dates: array of Integer);\nvar\n  i: Integer;\n  current, next: Integer;\nbegin\n  current := dates[0];\n  WriteLn(current);\n  \n  for i := 1 to n - 1 do\n  begin\n    next := GetNextValidDate(dates[i]);\n    \n    if next = -1 then\n    begin\n      WriteLn('No solution');\n      Exit;\n    end;\n    \n    if next < current then\n      next := current;\n    \n    WriteLn(next);\n    current := next;\n  end;\nend;\n\nvar\n  n, i: Integer;\n  dates: array of Integer;\nbegin\n  ReadLn(n);\n  SetLength(dates, n);\n  \n  for i := 0 to n - 1 do\n    ReadLn(dates[i]);\n  \n  CopyNotes(n, dates);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\tdates := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tdates[i], _ = strconv.Atoi(scanner.Text())\\n\\t}\\n\\n\\tresult := make([]int, n)\\n\\tresult[0] = dates[0]\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif dates[i] <= result[i-1] {\\n\\t\\t\\tresult[i] = result[i-1] + 1\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = dates[i]\\n\\t\\t}\\n\\n\\t\\tif result[i] > 2011 {\\n\\t\\t\\tfmt.Println(\\\"No solution\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, date := range result {\\n\\t\\tfmt.Println(date)\\n\\t}\\n}","Javascript":"function changeDates(n, dates) {\n    let result = [];\n    \n    \/\/ Helper function to check if a date is valid\n    function isValid(date) {\n        return date >= 1000 && date <= 2011;\n    }\n    \n    \/\/ Helper function to check if two dates are in non-decreasing order\n    function isNonDecreasing(date1, date2) {\n        return date1 <= date2;\n    }\n    \n    \/\/ Helper function to check if two dates differ in at most one digit\n    function differInOneDigit(date1, date2) {\n        let diffCount = 0;\n        let str1 = date1.toString();\n        let str2 = date2.toString();\n        \n        for (let i = 0; i < 4; i++) {\n            if (str1[i] !== str2[i]) {\n                diffCount++;\n            }\n        }\n        \n        return diffCount <= 1;\n    }\n    \n    \/\/ Check if the first date is valid\n    if (!isValid(dates[0])) {\n        return \"No solution\";\n    }\n    \n    result.push(dates[0]);\n    \n    \/\/ Iterate through the remaining dates\n    for (let i = 1; i < n; i++) {\n        let prevDate = parseInt(result[i - 1]);\n        let currDate = parseInt(dates[i]);\n        \n        \/\/ Check if the current date is valid\n        if (!isValid(currDate)) {\n            return \"No solution\";\n        }\n        \n        \/\/ Check if the current date is in non-decreasing order with the previous date\n        if (!isNonDecreasing(prevDate, currDate)) {\n            \/\/ Try changing one digit at a time to make the dates non-decreasing\n            let foundSolution = false;\n            \n            for (let j = 0; j < 4; j++) {\n                let tempDate = parseInt(result[i - 1]);\n                let tempDigit = parseInt(dates[i].toString()[j]);\n                \n                \/\/ Try changing the digit to all possible values\n                for (let k = 0; k <= 9; k++) {\n                    tempDate = tempDate - (tempDigit * Math.pow(10, 3 - j)) + (k * Math.pow(10, 3 - j));\n                    \n                    \/\/ Check if the new date is valid and in non-decreasing order with the previous date\n                    if (isValid(tempDate) && isNonDecreasing(prevDate, tempDate)) {\n                        result.push(tempDate);\n                        foundSolution = true;\n                        break;\n                    }\n                }\n                \n                if (foundSolution) {\n                    break;\n                }\n            }\n            \n            \/\/ If no solution is found, return \"No solution\"\n            if (!foundSolution) {\n                return \"No solution\";\n            }\n        } else {\n            result.push(currDate);\n        }\n    }\n    \n    return result.join('\\\\n');\n}\n\n\/\/ Test cases\nconsole.log(changeDates(3, [1875, 1936, 1721])); \/\/ Output: 1835\\\\n1836\\\\n1921\nconsole.log(changeDates(4, [9999, 2000, 3000, 3011])); \/\/ Output: 1999\\\\n2000\\\\n2000\\\\n2011\nconsole.log(changeDates(3, [1999, 5055, 2000])); \/\/ Output: No solution","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val dates = IntArray(n)\n    for (i in 0 until n) {\n        dates[i] = scanner.nextInt()\n    }\n    \n    val result = mutableListOf<Int>()\n    var prevDate = 1000\n    \n    for (date in dates) {\n        val modifiedDate = modifyDate(prevDate, date)\n        if (modifiedDate == -1) {\n            println(\"No solution\")\n            return\n        }\n        result.add(modifiedDate)\n        prevDate = modifiedDate\n    }\n    \n    for (date in result) {\n        println(date)\n    }\n}\n\nfun modifyDate(prevDate: Int, date: Int): Int {\n    val prevDigits = getDigits(prevDate)\n    val digits = getDigits(date)\n    \n    for (i in 0 until 4) {\n        if (digits[i] < prevDigits[i]) {\n            return -1\n        }\n        if (digits[i] > prevDigits[i]) {\n            val modifiedDigits = digits.copyOf()\n            modifiedDigits[i] = prevDigits[i]\n            return getNumber(modifiedDigits)\n        }\n    }\n    \n    return date\n}\n\nfun getDigits(number: Int): IntArray {\n    val digits = IntArray(4)\n    var temp = number\n    for (i in 3 downTo 0) {\n        digits[i] = temp % 10\n        temp \/= 10\n    }\n    return digits\n}\n\nfun getNumber(digits: IntArray): Int {\n    var number = 0\n    for (i in 0 until 4) {\n        number = number * 10 + digits[i]\n    }\n    return number\n}","PHP":"<?php\\n\\nfunction changeDates($n, $dates) {\\n    $result = [];\\n    $prevDate = 1000;\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        $date = $dates[$i];\\n\\n        if ($date < $prevDate) {\\n            $changed = false;\\n\\n            for ($j = 0; $j < 4; $j++) {\\n                $digit = (int)($date \/ pow(10, 3 - $j)) % 10;\\n\\n                for ($k = ($digit + 1) % 10; $k != $digit; $k = ($k + 1) % 10) {\\n                    $newDate = $date - ($digit - $k) * pow(10, 3 - $j);\\n\\n                    if ($newDate >= $prevDate && $newDate <= 2011) {\\n                        $result[] = $newDate;\\n                        $prevDate = $newDate;\\n                        $changed = true;\\n                        break;\\n                    }\\n                }\\n\\n                if ($changed) {\\n                    break;\\n                }\\n            }\\n\\n            if (!$changed) {\\n                return 'No solution';\\n            }\\n        } else {\\n            $result[] = $date;\\n            $prevDate = $date;\\n        }\\n    }\\n\\n    return implode(\\\"\\\\n\\\", $result);\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$n = (int)$input[0];\\n$dates = [];\\n\\nfor ($i = 1; $i <= $n; $i++) {\\n    $dates[] = (int)$input[$i];\\n}\\n\\n$output = changeDates($n, $dates);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] dates;\\r\\n    foreach (_; 0..n)\\r\\n    {\\r\\n        int date;\\r\\n        readf(\\\"%d\\\", &date);\\r\\n        dates ~= date;\\r\\n    }\\r\\n\\r\\n    int[] result;\\r\\n    result ~= dates[0];\\r\\n\\r\\n    for (int i = 1; i < n; i++)\\r\\n    {\\r\\n        int prev = result[$-1];\\r\\n        int curr = dates[i];\\r\\n\\r\\n        if (curr < prev)\\r\\n        {\\r\\n            int diff = 0;\\r\\n\\r\\n            for (int j = 0; j < 4; j++)\\r\\n            {\\r\\n                int prevDigit = (prev \/ 10^^j) % 10;\\r\\n                int currDigit = (curr \/ 10^^j) % 10;\\r\\n\\r\\n                if (currDigit < prevDigit)\\r\\n                {\\r\\n                    curr += (prevDigit - currDigit) * 10^^j;\\r\\n                    diff++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (curr < prev || curr > 2011 || diff > 1)\\r\\n            {\\r\\n                writeln(\\\"No solution\\\");\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        result ~= curr;\\r\\n    }\\r\\n\\r\\n    foreach (date; result)\\r\\n    {\\r\\n        writeln(date);\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub change_dates {\\n    my ($n, @dates) = @_;\\n    my @result;\\n\\n    for my $i (0..$n-1) {\\n        my $date = $dates[$i];\\n        my @digits = split('', $date);\\n\\n        for my $j (0..3) {\\n            my $original_digit = $digits[$j];\\n\\n            for my $digit (0..9) {\\n                next if $digit == $original_digit;\\n\\n                $digits[$j] = $digit;\\n                my $new_date = join('', @digits);\\n\\n                if ($new_date >= 1000 && $new_date <= 2011) {\\n                    push @result, $new_date;\\n                    last;\\n                }\\n            }\\n\\n            last if @result == $i+1;\\n            $digits[$j] = $original_digit;\\n        }\\n\\n        if (@result != $i+1) {\\n            print \\\"No solution\\\\n\\\";\\n            return;\\n        }\\n    }\\n\\n    print join(\\\"\\\\n\\\", @result), \\\"\\\\n\\\";\\n}\\n\\nmy $input = <STDIN>;\\nchomp $input;\\nmy $n = int($input);\\n\\nmy @dates;\\nfor (1..$n) {\\n    my $date = <STDIN>;\\n    chomp $date;\\n    push @dates, $date;\\n}\\n\\nchange_dates($n, @dates);\\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    let mut dates: Vec<u32> = Vec::new();\\n    for _ in 0..n {\\n        let mut date_input = String::new();\\n        std::io::stdin().read_line(&mut date_input).unwrap();\\n        let date: u32 = date_input.trim().parse().unwrap();\\n        dates.push(date);\\n    }\\n\\n    let mut result: Vec<u32> = Vec::new();\\n    let mut prev_date = 1000;\\n\\n    for date in dates {\\n        if date < prev_date {\\n            let mut changed = false;\\n            for i in 0..4 {\\n                let mut new_date = date;\\n                for digit in 0..10 {\\n                    let mut digits: Vec<u32> = new_date.to_string().chars().map(|d| d.to_digit(10).unwrap()).collect();\\n                    digits[i] = digit;\\n                    let updated_date: u32 = digits.iter().fold(0, |acc, digit| acc * 10 + digit);\\n                    if updated_date >= prev_date && updated_date <= 2011 {\\n                        result.push(updated_date);\\n                        prev_date = updated_date;\\n                        changed = true;\\n                        break;\\n                    }\\n                }\\n                if changed {\\n                    break;\\n                }\\n            }\\n            if !changed {\\n                println!(\\\"No solution\\\");\\n                return;\\n            }\\n        } else {\\n            result.push(date);\\n            prev_date = date;\\n        }\\n    }\\n\\n    for date in result {\\n        println!(\\\"{}\\\", date);\\n    }\\n}"}
{"title":"A. Petya and Java","description":"Little Petya has recently started attending a programming club. Naturally he is facing the problem of choosing a programming language. After long considerations he realized that Java is the best choice. The main argument in favor of choosing Java was that it has a very large integer data type, called BigInteger.But having attended several classes of the club, Petya realized that not all tasks require using the BigInteger type. It turned out that in some tasks it is much easier to use small data types. That's why a question arises: \"Which integer type to use if one wants to store a positive integer n?\"Petya knows only 5 integer types:1) byte occupies 1 byte and allows you to store numbers from -128 to 1272) short occupies 2 bytes and allows you to store numbers from -32768 to 327673) int occupies 4 bytes and allows you to store numbers from -2147483648 to 21474836474) long occupies 8 bytes and allows you to store numbers from -9223372036854775808 to 92233720368547758075) BigInteger can store any integer number, but at that it is not a primitive type, and operations with it are much slower.For all the types given above the boundary values are included in the value range.From this list, Petya wants to choose the smallest type that can store a positive integer n. Since BigInteger works much slower, Peter regards it last. Help him.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a positive number n. It consists of no more than 100 digits and doesn't contain any leading zeros. The number n can't be represented as an empty string.\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n","output_spec":"Print the first type from the list \"byte, short, int, long, BigInteger\", that can store the natural number n, in accordance with the data given above.\n","notes":null,"sample_inputs":["127\n","130\n","123456789101112131415161718192021222324\n"],"sample_outputs":["byte\n","short\n","BigInteger\n"],"id":"66-A","difficulty":1300,"tags":["implementation","strings"],"src_uid":"33041f1832fa7f641e37c4c638ab08a1","C++":"#include <iostream>\\n#include <string>\\n#include <sstream>\\n#include <limits>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nstring findSmallestType(string n) {\\n    int byteMax = numeric_limits<char>::max();\\n    int shortMax = numeric_limits<short>::max();\\n    int intMax = numeric_limits<int>::max();\\n    long longMax = numeric_limits<long>::max();\\n\\n    if (n.size() <= 3) {\\n        int num = stoi(n);\\n        if (num <= byteMax) {\\n            return \\\"byte\\\";\\n        } else if (num <= shortMax) {\\n            return \\\"short\\\";\\n        } else if (num <= intMax) {\\n            return \\\"int\\\";\\n        } else if (num <= longMax) {\\n            return \\\"long\\\";\\n        }\\n    }\\n\\n    return \\\"BigInteger\\\";\\n}\\n\\nint main() {\\n    string n;\\n    cin >> n;\\n\\n    string smallestType = findSmallestType(n);\\n    cout << smallestType << endl;\\n\\n    return 0;\\n}","Java":"import java.math.BigInteger;\\nimport java.util.Scanner;\\n\\npublic class IntegerType {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String n = scanner.nextLine();\\n        BigInteger bigInteger = new BigInteger(n);\\n\\n        if (bigInteger.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"byte\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Short.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"short\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"int\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"long\\\");\\n        } else {\\n            System.out.println(\\\"BigInteger\\\");\\n        }\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.math.BigInteger;\\nimport java.util.Scanner;\\n\\npublic class IntegerType {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String n = scanner.nextLine();\\n        BigInteger bigInteger = new BigInteger(n);\\n\\n        if (bigInteger.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"byte\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Short.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"short\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"int\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"long\\\");\\n        } else {\\n            System.out.println(\\\"BigInteger\\\");\\n        }\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.math.BigInteger;\\nimport java.util.Scanner;\\n\\npublic class IntegerType {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String n = scanner.nextLine();\\n        BigInteger bigInteger = new BigInteger(n);\\n\\n        if (bigInteger.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"byte\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Short.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"short\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"int\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"long\\\");\\n        } else {\\n            System.out.println(\\\"BigInteger\\\");\\n        }\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.math.BigInteger;\\nimport java.util.Scanner;\\n\\npublic class IntegerType {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String n = scanner.nextLine();\\n        BigInteger bigInteger = new BigInteger(n);\\n\\n        if (bigInteger.compareTo(BigInteger.valueOf(Byte.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"byte\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Short.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"short\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"int\\\");\\n        } else if (bigInteger.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\\n            System.out.println(\\\"long\\\");\\n        } else {\\n            System.out.println(\\\"BigInteger\\\");\\n        }\\n    }\\n}","Python":"n = int(input())\\n\\nif n <= 127:\\n    print('byte')\\nelif n <= 32767:\\n    print('short')\\nelif n <= 2147483647:\\n    print('int')\\nelif n <= 9223372036854775807:\\n    print('long')\\nelse:\\n    print('BigInteger')","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    char n[101];\\n    scanf(\\\"%s\\\", n);\\n    int len = strlen(n);\\n    if (len <= 3) {\\n        int num = atoi(n);\\n        if (num >= -128 && num <= 127) {\\n            printf(\\\"byte\\\\n\\\");\\n        } else if (num >= -32768 && num <= 32767) {\\n            printf(\\\"short\\\\n\\\");\\n        } else if (num >= -2147483648 && num <= 2147483647) {\\n            printf(\\\"int\\\\n\\\");\\n        } else {\\n            printf(\\\"long\\\\n\\\");\\n        }\\n    } else {\\n        printf(\\\"BigInteger\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string n = Console.ReadLine();\n        \n        if (byte.TryParse(n, out byte byteResult))\n        {\n            Console.WriteLine(\\\"byte\\\");\n        }\n        else if (short.TryParse(n, out short shortResult))\n        {\n            Console.WriteLine(\\\"short\\\");\n        }\n        else if (int.TryParse(n, out int intResult))\n        {\n            Console.WriteLine(\\\"int\\\");\n        }\n        else if (long.TryParse(n, out long longResult))\n        {\n            Console.WriteLine(\\\"long\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"BigInteger\\\");\n        }\n    }\n}\n","Ruby":"\ndef choose_integer_type(n)\n  n = n.to_i\n  if n >= -128 && n <= 127\n    return 'byte'\n  elsif n >= -32768 && n <= 32767\n    return 'short'\n  elsif n >= -2147483648 && n <= 2147483647\n    return 'int'\n  elsif n >= -9223372036854775808 && n <= 9223372036854775807\n    return 'long'\n  else\n    return 'BigInteger'\n  end\nend\n\ninputs = ['127\\n', '130\\n', '123456789101112131415161718192021222324\\n']\noutputs = []\n\ninputs.each do |input|\n  output = choose_integer_type(input)\n  outputs << output\nend\n\nputs outputs\n","delphi":"var\n  n: string;\nbegin\n  readln(n);\n  \n  if Length(n) <= 3 then\n    writeln('byte')\n  else if Length(n) <= 5 then\n    writeln('short')\n  else if Length(n) <= 10 then\n    writeln('int')\n  else if Length(n) <= 19 then\n    writeln('long')\n  else\n    writeln('BigInteger');\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\/big\\\"\\n)\\n\\nfunc main() {\\n\\tvar n string\\n\\tfmt.Scan(&n)\\n\\n\\tif len(n) <= 3 {\\n\\t\\tfmt.Println(\\\"byte\\\")\\n\\t} else if len(n) <= 5 {\\n\\t\\tfmt.Println(\\\"short\\\")\\n\\t} else if len(n) <= 10 {\\n\\t\\tfmt.Println(\\\"int\\\")\\n\\t} else if len(n) <= 19 {\\n\\t\\tfmt.Println(\\\"long\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"BigInteger\\\")\\n\\t}\\n}","Javascript":"function chooseIntegerType(n) {\n    if (n <= 127) {\n        return 'byte';\n    } else if (n <= 32767) {\n        return 'short';\n    } else if (n <= 2147483647) {\n        return 'int';\n    } else if (n <= 9223372036854775807) {\n        return 'long';\n    } else {\n        return 'BigInteger';\n    }\n}\n\nconst inputs = ['127\\n', '130\\n', '123456789101112131415161718192021222324\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    const n = parseInt(inputs[i]);\n    const result = chooseIntegerType(n);\n    outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.math.BigInteger\\n\\nfun main() {\\n    val n = readLine()!!.toBigInteger()\\n    if (n in Byte.MIN_VALUE.toBigInteger()..Byte.MAX_VALUE.toBigInteger()) {\\n        println(\\\"byte\\\")\\n    } else if (n in Short.MIN_VALUE.toBigInteger()..Short.MAX_VALUE.toBigInteger()) {\\n        println(\\\"short\\\")\\n    } else if (n in Int.MIN_VALUE.toBigInteger()..Int.MAX_VALUE.toBigInteger()) {\\n        println(\\\"int\\\")\\n    } else if (n in Long.MIN_VALUE.toBigInteger()..Long.MAX_VALUE.toBigInteger()) {\\n        println(\\\"long\\\")\\n    } else {\\n        println(\\\"BigInteger\\\")\\n    }\\n}","PHP":"\n<?php\n\nfunction chooseIntegerType($n) {\n    if ($n >= -128 && $n <= 127) {\n        return 'byte';\n    } elseif ($n >= -32768 && $n <= 32767) {\n        return 'short';\n    } elseif ($n >= -2147483648 && $n <= 2147483647) {\n        return 'int';\n    } elseif ($n >= -9223372036854775808 && $n <= 9223372036854775807) {\n        return 'long';\n    } else {\n        return 'BigInteger';\n    }\n}\n\n$input = trim(fgets(STDIN));\n$result = chooseIntegerType($input);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.bigint;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string n;\\r\\n    readln(n);\\r\\n\\r\\n    if (n.length <= 3)\\r\\n    {\\r\\n        int num = to!int(n);\\r\\n        if (num >= -128 && num <= 127)\\r\\n        {\\r\\n            writeln(\\\"byte\\\");\\r\\n            return;\\r\\n        }\\r\\n        else if (num >= -32768 && num <= 32767)\\r\\n        {\\r\\n            writeln(\\\"short\\\");\\r\\n            return;\\r\\n        }\\r\\n        else if (num >= -2147483648 && num <= 2147483647)\\r\\n        {\\r\\n            writeln(\\\"int\\\");\\r\\n            return;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (n.length <= 19)\\r\\n    {\\r\\n        long num = to!long(n);\\r\\n        if (num >= -9223372036854775808 && num <= 9223372036854775807)\\r\\n        {\\r\\n            writeln(\\\"long\\\");\\r\\n            return;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(\\\"BigInteger\\\");\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nmy $n = <>;\nchomp $n;\n\nif ($n <= 127) {\n    print 'byte\\n';\n} elsif ($n <= 32767) {\n    print 'short\\n';\n} elsif ($n <= 2147483647) {\n    print 'int\\n';\n} elsif ($n <= 9223372036854775807) {\n    print 'long\\n';\n} else {\n    print 'BigInteger\\n';\n}\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    if let Some(Ok(n)) = lines.next() {\n        let n: u128 = n.trim().parse().unwrap();\n\n        if n <= 127 {\n            println!(\\\"byte\\\");\n        } else if n <= 32767 {\n            println!(\\\"short\\\");\n        } else if n <= 2147483647 {\n            println!(\\\"int\\\");\n        } else if n <= 9223372036854775807 {\n            println!(\\\"long\\\");\n        } else {\n            println!(\\\"BigInteger\\\");\n        }\n    }\n}"}
{"title":"B. Petya and Countryside","description":"Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1\u00d7n in size, when viewed from above. This rectangle is divided into n equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1\u00d75 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture: As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him. ","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains a positive integer n (1\u2264n\u22641000). The second line contains n positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.\n","output_spec":"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.\n","notes":null,"sample_inputs":["1\n2\n","5\n1 2 1 2 1\n","8\n1 2 1 1 1 3 3 4\n"],"sample_outputs":["1\n","3\n","6\n"],"id":"66-B","difficulty":1100,"tags":["brute+force","implementation"],"src_uid":"5d11fa8528f1dc873d50b3417bef8c79","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> heights(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> heights[i];\\n    }\\n\\n    int maxWateredSections = 0;\\n    for (int i = 0; i < n; i++) {\\n        int wateredSections = 1;\\n        for (int j = i - 1; j >= 0 && heights[j] <= heights[j + 1]; j--) {\\n            wateredSections++;\\n        }\\n        for (int j = i + 1; j < n && heights[j] <= heights[j - 1]; j++) {\\n            wateredSections++;\\n        }\\n        maxWateredSections = max(maxWateredSections, wateredSections);\\n    }\\n\\n    cout << maxWateredSections << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] heights = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            heights[i] = scanner.nextInt();\\n        }\\n        int maxWateredSections = 0;\\n        for (int i = 0; i < n; i++) {\\n            int wateredSections = 1;\\n            int left = i - 1;\\n            int right = i + 1;\\n            while (left >= 0 && heights[left] <= heights[left + 1]) {\\n                wateredSections++;\\n                left--;\\n            }\\n            while (right < n && heights[right] <= heights[right - 1]) {\\n                wateredSections++;\\n                right++;\\n            }\\n            maxWateredSections = Math.max(maxWateredSections, wateredSections);\\n        }\\n        System.out.println(maxWateredSections);\\n    }\\n}","Python":"def max_watered_sections(n, heights):\n    max_sections = 0\n    for i in range(n):\n        left = i - 1\n        right = i + 1\n        watered_sections = 1\n        while left >= 0 and heights[left] <= heights[left + 1]:\n            watered_sections += 1\n            left -= 1\n        while right < n and heights[right] <= heights[right - 1]:\n            watered_sections += 1\n            right += 1\n        max_sections = max(max_sections, watered_sections)\n    return max_sections\n\nn = int(input())\nheights = list(map(int, input().split()))\nprint(max_watered_sections(n, heights))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int heights[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &heights[i]);\\n    }\\n\\n    int maxWateredSections = 0;\\n    for (int i = 0; i < n; i++) {\\n        int wateredSections = 1;\\n        int left = i - 1;\\n        int right = i + 1;\\n\\n        while (left >= 0 && heights[left] <= heights[left + 1]) {\\n            wateredSections++;\\n            left--;\\n        }\\n\\n        while (right < n && heights[right] <= heights[right - 1]) {\\n            wateredSections++;\\n            right++;\\n        }\\n\\n        if (wateredSections > maxWateredSections) {\\n            maxWateredSections = wateredSections;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", maxWateredSections);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] heights = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        \n        int maxWateredSections = 0;\n        \n        for (int i = 0; i < n; i++)\n        {\n            int wateredSections = 1;\n            \n            for (int j = i - 1; j >= 0 && heights[j] <= heights[j + 1]; j--)\n            {\n                wateredSections++;\n            }\n            \n            for (int j = i + 1; j < n && heights[j] <= heights[j - 1]; j++)\n            {\n                wateredSections++;\n            }\n            \n            maxWateredSections = Math.Max(maxWateredSections, wateredSections);\n        }\n        \n        Console.WriteLine(maxWateredSections);\n    }\n}","Ruby":"\ndef max_watered_sections(n, heights)\n  max_sections = 0\n  \n  # Iterate through each section\n  (0...n).each do |i|\n    left_sections = 0\n    right_sections = 0\n    \n    # Check sections to the left\n    (i-1).downto(0) do |j|\n      break if heights[j] > heights[j+1]\n      left_sections += 1\n    end\n    \n    # Check sections to the right\n    (i+1...n).each do |k|\n      break if heights[k] > heights[k-1]\n      right_sections += 1\n    end\n    \n    # Calculate total watered sections\n    total_sections = left_sections + right_sections + 1\n    \n    # Update max_sections if necessary\n    max_sections = [max_sections, total_sections].max\n  end\n  \n  return max_sections\nend\n\n# Read input\nn = gets.to_i\nheights = gets.split.map(&:to_i)\n\n# Calculate and print the maximal number of watered sections\nputs max_watered_sections(n, heights)\n","delphi":"program ArtificialRain;\\n\\nvar\\n  n, i, maxWateredSections, wateredSections: integer;\\n  heights: array of integer;\\n\\nbegin\\n  \/\/ Read the number of sections\\n  readln(n);\\n\\n  \/\/ Read the heights of the sections\\n  SetLength(heights, n);\\n  for i := 0 to n-1 do\\n    read(heights[i]);\\n\\n  \/\/ Initialize the maximum number of watered sections\\n  maxWateredSections := 0;\\n\\n  \/\/ Iterate through each section\\n  for i := 0 to n-1 do\\n  begin\\n    \/\/ Initialize the number of watered sections\\n    wateredSections := 1;\\n\\n    \/\/ Check the sections to the left\\n    for j := i-1 downto 0 do\\n    begin\\n      if heights[j] <= heights[j+1] then\\n        Inc(wateredSections)\\n      else\\n        Break;\\n    end;\\n\\n    \/\/ Check the sections to the right\\n    for j := i+1 to n-1 do\\n    begin\\n      if heights[j] <= heights[j-1] then\\n        Inc(wateredSections)\\n      else\\n        Break;\\n    end;\\n\\n    \/\/ Update the maximum number of watered sections\\n    if wateredSections > maxWateredSections then\\n      maxWateredSections := wateredSections;\\n  end;\\n\\n  \/\/ Print the maximum number of watered sections\\n  writeln(maxWateredSections);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\theights := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&heights[i])\\n\\t}\\n\\n\\tmaxWateredSections := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tleftWateredSections := 1\\n\\t\\trightWateredSections := 1\\n\\n\\t\\tfor j := i - 1; j >= 0; j-- {\\n\\t\\t\\tif heights[j] <= heights[j+1] {\\n\\t\\t\\t\\tleftWateredSections++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\tif heights[j] <= heights[j-1] {\\n\\t\\t\\t\\trightWateredSections++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twateredSections := leftWateredSections + rightWateredSections\\n\\t\\tif wateredSections > maxWateredSections {\\n\\t\\t\\tmaxWateredSections = wateredSections\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxWateredSections)\\n}","Javascript":"function findMaxWateredSections(n, heights) {\n  let maxWateredSections = 0;\n\n  for (let i = 0; i < n; i++) {\n    let wateredSections = 1;\n\n    \/\/ Check left side of the current section\n    for (let j = i - 1; j >= 0; j--) {\n      if (heights[j] <= heights[j + 1]) {\n        wateredSections++;\n      } else {\n        break;\n      }\n    }\n\n    \/\/ Check right side of the current section\n    for (let j = i + 1; j < n; j++) {\n      if (heights[j] <= heights[j - 1]) {\n        wateredSections++;\n      } else {\n        break;\n      }\n    }\n\n    maxWateredSections = Math.max(maxWateredSections, wateredSections);\n  }\n\n  return maxWateredSections;\n}\n\n\/\/ Test cases\nconst inputs = [\n  { n: 1, heights: [2] },\n  { n: 5, heights: [1, 2, 1, 2, 1] },\n  { n: 8, heights: [1, 2, 1, 1, 1, 3, 3, 4] }\n];\n\nconst outputs = inputs.map(input => findMaxWateredSections(input.n, input.heights));\n\nconsole.log(outputs);","Kotlin":"fun main() {\\n    val n = readLine()!!.toInt()\\n    val heights = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    var maxWateredSections = 0\\n\\n    for (i in 0 until n) {\\n        var wateredSections = 1\\n\\n        for (j in i - 1 downTo 0) {\\n            if (heights[j] <= heights[j + 1]) {\\n                wateredSections++\\n            } else {\\n                break\\n            }\\n        }\\n\\n        for (j in i + 1 until n) {\\n            if (heights[j] <= heights[j - 1]) {\\n                wateredSections++\\n            } else {\\n                break\\n            }\\n        }\\n\\n        if (wateredSections > maxWateredSections) {\\n            maxWateredSections = wateredSections\\n        }\\n    }\\n\\n    println(maxWateredSections)\\n}","PHP":"<?php\\n\\nfunction findMaxWateredSections($n, $heights) {\\n    $maxWateredSections = 0;\\n\\n    \/\/ Iterate through each section\\n    for ($i = 0; $i < $n; $i++) {\\n        $wateredSections = 1;\\n\\n        \/\/ Check left sections\\n        for ($j = $i - 1; $j >= 0; $j--) {\\n            if ($heights[$j] <= $heights[$j + 1]) {\\n                $wateredSections++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        \/\/ Check right sections\\n        for ($j = $i + 1; $j < $n; $j++) {\\n            if ($heights[$j] <= $heights[$j - 1]) {\\n                $wateredSections++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        \/\/ Update max watered sections\\n        $maxWateredSections = max($maxWateredSections, $wateredSections);\\n    }\\n\\n    return $maxWateredSections;\\n}\\n\\n\/\/ Sample inputs\\n$inputs = [\\n    [1, [2]],\\n    [5, [1, 2, 1, 2, 1]],\\n    [8, [1, 2, 1, 1, 1, 3, 3, 4]],\\n];\\n\\n\/\/ Process sample inputs\\n$outputs = [];\\nforeach ($inputs as $input) {\\n    $n = $input[0];\\n    $heights = $input[1];\\n\\n    $maxWateredSections = findMaxWateredSections($n, $heights);\\n    $outputs[] = $maxWateredSections;\\n}\\n\\n\/\/ Print sample outputs\\nforeach ($outputs as $output) {\\n    echo $output . \\\"\\\\n\\\";\\n}\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] heights;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    heights = new int[n];\\r\\n    readf(\\\"%s\\\", &heights);\\r\\n\\r\\n    int maxWateredSections = 0;\\r\\n\\r\\n    \/\/ Iterate over each section\\r\\n    foreach (i, height; heights)\\r\\n    {\\r\\n        int wateredSections = 1;\\r\\n\\r\\n        \/\/ Check left sections\\r\\n        for (int j = i - 1; j >= 0; j--)\\r\\n        {\\r\\n            if (heights[j] <= height)\\r\\n            {\\r\\n                wateredSections++;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \/\/ Check right sections\\r\\n        for (int j = i + 1; j < n; j++)\\r\\n        {\\r\\n            if (heights[j] <= height)\\r\\n            {\\r\\n                wateredSections++;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \/\/ Update max watered sections\\r\\n        if (wateredSections > maxWateredSections)\\r\\n        {\\r\\n            maxWateredSections = wateredSections;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print output\\r\\n    writef(\\\"%d\\\\n\\\", maxWateredSections);\\r\\n}","perl":"\n# Read the input values\nmy $n = <STDIN>;\nchomp $n;\nmy $heights = <STDIN>;\nchomp $heights;\n\n# Split the heights into an array\nmy @heights_array = split(' ', $heights);\n\n# Initialize variables\nmy $max_watered_sections = 0;\n\n# Iterate through each section\nfor (my $i = 0; $i < $n; $i++) {\n    # Initialize variables for counting watered sections\n    my $watered_sections = 1;\n    \n    # Check left sections\n    for (my $j = $i - 1; $j >= 0; $j--) {\n        last if $heights_array[$j] > $heights_array[$j + 1];\n        $watered_sections++;\n    }\n    \n    # Check right sections\n    for (my $j = $i + 1; $j < $n; $j++) {\n        last if $heights_array[$j] > $heights_array[$j - 1];\n        $watered_sections++;\n    }\n    \n    # Update the maximum number of watered sections\n    $max_watered_sections = $watered_sections if $watered_sections > $max_watered_sections;\n}\n\n# Print the result\nprint $max_watered_sections;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: usize = input.trim().parse().unwrap();\n    \n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let heights: Vec<usize> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut max_watered_sections = 0;\n    \n    for i in 0..n {\n        let mut watered_sections = 1;\n        \n        for j in (0..i).rev() {\n            if heights[j] <= heights[j+1] {\n                watered_sections += 1;\n            } else {\n                break;\n            }\n        }\n        \n        for j in (i+1)..n {\n            if heights[j] <= heights[j-1] {\n                watered_sections += 1;\n            } else {\n                break;\n            }\n        }\n        \n        max_watered_sections = max_watered_sections.max(watered_sections);\n    }\n    \n    println!(\"{}\", max_watered_sections);\n}"}
{"title":"C. Sequence of Balls","description":"You are given a sequence of balls A by your teacher, each labeled with a lowercase Latin letter 'a'-'z'. You don't like the given sequence. You want to change it into a new sequence, B that suits you better. So, you allow yourself four operations:  You can insert any ball with any label into the sequence at any position.  You can delete (remove) any ball from any position.  You can replace any ball with any other ball.  You can exchange (swap) two adjacent balls. Your teacher now places time constraints on each operation, meaning that an operation can only be performed in certain time. So, the first operation takes time ti, the second one takes td, the third one takes tr and the fourth one takes te. Also, it is given that 2\u00b7te\u2265ti+td.Find the minimal time to convert the sequence A to the sequence B.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains four space-separated integers ti,td,tr,te (0<ti,td,tr,te\u2264100). The following two lines contain sequences A and B on separate lines. The length of each line is between 1 and 4000 characters inclusive.\n","output_spec":"Print a single integer representing minimum time to convert A into B.\n","notes":"In the second sample, you could delete the ball labeled 'a' from the first position and then insert another 'a' at the new second position with total time 6. However exchanging the balls give total time 3.\n","sample_inputs":["1 1 1 1\nyoushouldnot\nthoushaltnot\n","2 4 10 3\nab\nba\n","1 10 20 30\na\nza\n"],"sample_outputs":["5\n","3\n","1\n"],"id":"67-C","difficulty":2600,"tags":["dp"],"src_uid":"c7e0c6b93a2f2f43fe9da405409c91e6","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cstring>\\nusing namespace std;\\n\\nint dp[4005][4005];\\n\\nint main() {\\n    int ti, td, tr, te;\\n    string A, B;\\n    cin >> ti >> td >> tr >> te;\\n    cin >> A >> B;\\n    int n = A.length();\\n    int m = B.length();\\n\\n    for (int i = 0; i <= n; i++) {\\n        for (int j = 0; j <= m; j++) {\\n            if (i == 0) {\\n                dp[i][j] = j * ti;\\n            } else if (j == 0) {\\n                dp[i][j] = i * td;\\n            } else {\\n                dp[i][j] = min(dp[i - 1][j] + td, dp[i][j - 1] + ti);\\n                if (A[i - 1] != B[j - 1]) {\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + tr);\\n                } else {\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);\\n                }\\n                if (i > 1 && j > 1 && A[i - 1] == B[j - 2] && A[i - 2] == B[j - 1]) {\\n                    dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + te);\\n                }\\n            }\\n        }\\n    }\\n\\n    cout << dp[n][m] << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class BallSequence {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int ti = scanner.nextInt();\\n        int td = scanner.nextInt();\\n        int tr = scanner.nextInt();\\n        int te = scanner.nextInt();\\n        scanner.nextLine();\\n        String sequenceA = scanner.nextLine();\\n        String sequenceB = scanner.nextLine();\\n\\n        int[][] dp = new int[sequenceA.length() + 1][sequenceB.length() + 1];\\n\\n        for (int i = 0; i <= sequenceA.length(); i++) {\\n            for (int j = 0; j <= sequenceB.length(); j++) {\\n                if (i == 0) {\\n                    dp[i][j] = j * ti;\\n                } else if (j == 0) {\\n                    dp[i][j] = i * td;\\n                } else if (sequenceA.charAt(i - 1) == sequenceB.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + td, dp[i][j - 1] + ti), dp[i - 1][j - 1] + tr);\\n                }\\n            }\\n        }\\n\\n        System.out.println(dp[sequenceA.length()][sequenceB.length()]);\\n    }\\n}","Python":"def minimal_time(ti, td, tr, te, A, B):\n    m, n = len(A), len(B)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i * td\n    \n    for j in range(n + 1):\n        dp[0][j] = j * ti\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if A[i - 1] == B[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j - 1] + tr, dp[i - 1][j] + td, dp[i][j - 1] + ti)\n    \n    return dp[m][n]\n\ninput1 = '1 1 1 1\\nyoushouldnot\\nthoushaltnot\\n'\ninput2 = '2 4 10 3\\nab\\nba\\n'\ninput3 = '1 10 20 30\\na\\nza\\n'\n\ninputs = [input1, input2, input3]\n\noutputs = []\nfor input_str in inputs:\n    input_lines = input_str.strip().split('\\n')\n    ti, td, tr, te = map(int, input_lines[0].split())\n    A = input_lines[1]\n    B = input_lines[2]\n    \n    result = minimal_time(ti, td, tr, te, A, B)\n    outputs.append(str(result))\n\noutput_str = '\\\\n'.join(outputs)\nprint(output_str)\n","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint min(int a, int b) {\\n    return a < b ? a : b;\\n}\\n\\nint main() {\\n    int ti, td, tr, te;\\n    scanf(\\\"%d %d %d %d\\\", &ti, &td, &tr, &te);\\n    char A[4001], B[4001];\\n    scanf(\\\"%s\\\", A);\\n    scanf(\\\"%s\\\", B);\\n    int lenA = strlen(A);\\n    int lenB = strlen(B);\\n    int dp[lenA + 1][lenB + 1];\\n    for (int i = 0; i <= lenA; i++) {\\n        for (int j = 0; j <= lenB; j++) {\\n            if (i == 0) {\\n                dp[i][j] = j * ti;\\n            } else if (j == 0) {\\n                dp[i][j] = i * td;\\n            } else if (A[i - 1] == B[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1];\\n            } else {\\n                dp[i][j] = min(min(dp[i - 1][j] + td, dp[i][j - 1] + ti), dp[i - 1][j - 1] + tr);\\n            }\\n            if (i > 1 && j > 1 && A[i - 1] == B[j - 2] && A[i - 2] == B[j - 1]) {\\n                dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + te);\\n            }\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", dp[lenA][lenB]);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        int ti = int.Parse(input[0]);\n        int td = int.Parse(input[1]);\n        int tr = int.Parse(input[2]);\n        int te = int.Parse(input[3]);\n\n        string sequenceA = Console.ReadLine();\n        string sequenceB = Console.ReadLine();\n\n        int[,] dp = new int[sequenceA.Length + 1, sequenceB.Length + 1];\n\n        for (int i = 0; i <= sequenceA.Length; i++)\n        {\n            dp[i, 0] = i * td;\n        }\n\n        for (int j = 0; j <= sequenceB.Length; j++)\n        {\n            dp[0, j] = j * ti;\n        }\n\n        for (int i = 1; i <= sequenceA.Length; i++)\n        {\n            for (int j = 1; j <= sequenceB.Length; j++)\n            {\n                if (sequenceA[i - 1] == sequenceB[j - 1])\n                {\n                    dp[i, j] = dp[i - 1, j - 1];\n                }\n                else\n                {\n                    dp[i, j] = Math.Min(Math.Min(dp[i - 1, j] + td, dp[i, j - 1] + ti), dp[i - 1, j - 1] + tr);\n                }\n            }\n        }\n\n        int minTime = dp[sequenceA.Length, sequenceB.Length];\n        Console.WriteLine(minTime);\n    }\n}","Ruby":"\ndef minimal_time(ti, td, tr, te, a, b)\n  n = a.length\n  m = b.length\n\n  # Initialize the dp table\n  dp = Array.new(n+1) { Array.new(m+1) }\n  dp[0][0] = 0\n\n  # Fill in the first row and column of the dp table\n  for i in 1..n\n    dp[i][0] = dp[i-1][0] + td\n  end\n\n  for j in 1..m\n    dp[0][j] = dp[0][j-1] + ti\n  end\n\n  # Fill in the rest of the dp table\n  for i in 1..n\n    for j in 1..m\n      if a[i-1] == b[j-1]\n        dp[i][j] = dp[i-1][j-1]\n      else\n        dp[i][j] = [dp[i-1][j] + td, dp[i][j-1] + ti, dp[i-1][j-1] + tr].min\n      end\n    end\n  end\n\n  # Return the minimal time\n  return dp[n][m] + (m-n).abs * te\nend\n\n# Parse the input\ninput = gets.chomp.split(\"\\n\")\nti, td, tr, te = input[0].split(\" \").map(&:to_i)\na = input[1]\nb = input[2]\n\n# Call the function and print the result\nputs minimal_time(ti, td, tr, te, a, b)\n","delphi":"program MinimalTimeConversion;\\n\\nvar\\n  ti, td, tr, te: Integer;\\n  A, B: string;\\n  lenA, lenB: Integer;\\n  dp: array[0..4001, 0..4001] of Integer;\\n  i, j: Integer;\\n\\nfunction min(a, b: Integer): Integer;\\nbegin\\n  if a < b then\\n    Result := a\\n  else\\n    Result := b;\\nend;\\n\\nbegin\\n  ReadLn(ti, td, tr, te);\\n  ReadLn(A);\\n  ReadLn(B);\\n\\n  lenA := Length(A);\\n  lenB := Length(B);\\n\\n  for i := 0 to lenA do\\n    dp[i, 0] := i * td;\\n\\n  for j := 0 to lenB do\\n    dp[0, j] := j * ti;\\n\\n  for i := 1 to lenA do\\n  begin\\n    for j := 1 to lenB do\\n    begin\\n      if A[i] = B[j] then\\n        dp[i, j] := dp[i-1, j-1]\\n      else\\n        dp[i, j] := dp[i-1, j-1] + tr;\\n\\n      dp[i, j] := min(dp[i, j], dp[i-1, j] + td);\\n      dp[i, j] := min(dp[i, j], dp[i, j-1] + ti);\\n      dp[i, j] := min(dp[i, j], dp[i-2, j-2] + te);\\n    end;\\n  end;\\n\\n  WriteLn(dp[lenA, lenB]);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar ti, td, tr, te int\\n\\tvar A, B string\\n\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &ti, &td, &tr, &te)\\n\\tfmt.Scanf(\\\"%s\\\", &A)\\n\\tfmt.Scanf(\\\"%s\\\", &B)\\n\\n\\tminTime := calculateMinTime(ti, td, tr, te, A, B)\\n\\n\\tfmt.Println(minTime)\\n}\\n\\nfunc calculateMinTime(ti, td, tr, te int, A, B string) int {\\n\\tm := len(A)\\n\\tn := len(B)\\n\\n\\t\/\/ Initialize the dp table\\n\\tdp := make([][]int, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([]int, n+1)\\n\\t\\tdp[i][0] = i * td\\n\\t}\\n\\tfor j := 0; j <= n; j++ {\\n\\t\\tdp[0][j] = j * ti\\n\\t}\\n\\n\\t\/\/ Fill the dp table\\n\\tfor i := 1; i <= m; i++ {\\n\\t\\tfor j := 1; j <= n; j++ {\\n\\t\\t\\tif A[i-1] == B[j-1] {\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i][j] = min(dp[i-1][j]+td, dp[i][j-1]+ti)\\n\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i-1][j-1]+tr)\\n\\t\\t\\t}\\n\\t\\t\\tif i > 1 && j > 1 && A[i-1] == B[j-2] && A[i-2] == B[j-1] {\\n\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[i-2][j-2]+te)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n]\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}","Javascript":"function minimalTimeToConvert(input) {\n    const [t1, t2, t3, t4] = input[0].split(' ').map(Number);\n    const A = input[1];\n    const B = input[2];\n    \n    const n = A.length;\n    const m = B.length;\n    \n    const dp = new Array(n + 1).fill(null).map(() => new Array(m + 1).fill(0));\n    \n    for (let i = 0; i <= n; i++) {\n        dp[i][0] = i * t2;\n    }\n    \n    for (let j = 0; j <= m; j++) {\n        dp[0][j] = j * t1;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= m; j++) {\n            if (A[i - 1] === B[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(\n                    dp[i - 1][j - 1] + t3,\n                    dp[i][j - 1] + t1,\n                    dp[i - 1][j] + t2\n                );\n            }\n        }\n    }\n    \n    return dp[n][m].toString();\n}\n\nconst input = ['1 1 1 1\\nyoushouldnot\\nthoushaltnot\\n', '2 4 10 3\\nab\\nba\\n', '1 10 20 30\\na\\nza\\n'];\nconst output = input.map((data) => minimalTimeToConvert(data.split('\\\\n')));\nJSON.stringify(output);","Kotlin":"import kotlin.math.min\\n\\nfun minimalTimeToConvert(ti: Int, td: Int, tr: Int, te: Int, A: String, B: String): Int {\\n    val n = A.length\\n    val m = B.length\\n    val dp = Array(n + 1) { IntArray(m + 1) }\\n\\n    for (i in 0..n) {\\n        for (j in 0..m) {\\n            if (i == 0) {\\n                dp[i][j] = j * ti\\n            } else if (j == 0) {\\n                dp[i][j] = i * td\\n            } else {\\n                dp[i][j] = min(dp[i - 1][j] + td, dp[i][j - 1] + ti)\\n                if (A[i - 1] == B[j - 1]) {\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])\\n                } else {\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + tr)\\n                }\\n                if (i >= 2 && j >= 2 && A[i - 1] == B[j - 2] && A[i - 2] == B[j - 1]) {\\n                    dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + te)\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[n][m]\\n}\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val ti = input[0]\\n    val td = input[1]\\n    val tr = input[2]\\n    val te = input[3]\\n    val A = readLine()!!\\n    val B = readLine()!!\\n\\n    val result = minimalTimeToConvert(ti, td, tr, te, A, B)\\n    println(result)\\n}","PHP":"\n<?php\n\nfunction minimalTime($ti, $td, $tr, $te, $A, $B) {\n    $n = strlen($A);\n    $m = strlen($B);\n    \n    \/\/ Initialize the dp table\n    $dp = array();\n    for ($i = 0; $i <= $n; $i++) {\n        $dp[$i] = array();\n        for ($j = 0; $j <= $m; $j++) {\n            $dp[$i][$j] = 0;\n        }\n    }\n    \n    \/\/ Fill in the dp table\n    for ($i = 0; $i <= $n; $i++) {\n        for ($j = 0; $j <= $m; $j++) {\n            if ($i == 0 && $j == 0) {\n                $dp[$i][$j] = 0;\n            } elseif ($i == 0) {\n                $dp[$i][$j] = $dp[$i][$j-1] + $ti;\n            } elseif ($j == 0) {\n                $dp[$i][$j] = $dp[$i-1][$j] + $td;\n            } else {\n                $dp[$i][$j] = min(\n                    $dp[$i-1][$j] + $td, \/\/ Delete operation\n                    $dp[$i][$j-1] + $ti, \/\/ Insert operation\n                    $dp[$i-1][$j-1] + ($A[$i-1] != $B[$j-1] ? $tr : 0), \/\/ Replace operation\n                    ($i >= 2 && $j >= 2 ? $dp[$i-2][$j-2] + ($A[$i-1] != $B[$j-2] || $A[$i-2] != $B[$j-1] ? $te : 0) : INF) \/\/ Swap operation\n                );\n            }\n        }\n    }\n    \n    return $dp[$n][$m];\n}\n\n\/\/ Read input\n$inputs = explode('\\n', file_get_contents('php:\/\/stdin'));\nlist($ti, $td, $tr, $te) = explode(' ', $inputs[0]);\n$A = $inputs[1];\n$B = $inputs[2];\n\n\/\/ Calculate and print the minimal time\necho minimalTime($ti, $td, $tr, $te, $A, $B);\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint minimalTime(string A, string B, int ti, int td, int tr, int te)\\r\\n{\\r\\n    int n = A.length;\\r\\n    int m = B.length;\\r\\n    int[][] dp = new int[n + 1][m + 1];\\r\\n\\r\\n    for (int i = 0; i <= n; i++)\\r\\n    {\\r\\n        for (int j = 0; j <= m; j++)\\r\\n        {\\r\\n            if (i == 0)\\r\\n                dp[i][j] = j * ti;\\r\\n            else if (j == 0)\\r\\n                dp[i][j] = i * td;\\r\\n            else if (A[i - 1] == B[j - 1])\\r\\n                dp[i][j] = dp[i - 1][j - 1];\\r\\n            else\\r\\n            {\\r\\n                dp[i][j] = min(dp[i - 1][j] + td, dp[i][j - 1] + ti);\\r\\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + tr);\\r\\n                if (i > 1 && j > 1 && A[i - 1] == B[j - 2] && A[i - 2] == B[j - 1])\\r\\n                    dp[i][j] = min(dp[i][j], dp[i - 2][j - 2] + te);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return dp[n][m];\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int ti, td, tr, te;\\r\\n    string A, B;\\r\\n    readf(\\\"%d %d %d %d\\\\n\\\", &ti, &td, &tr, &te);\\r\\n    readf(\\\"%s\\\\n%s\\\\n\\\", &A, &B);\\r\\n\\r\\n    int result = minimalTime(A, B, ti, td, tr, te);\\r\\n    writef(\\\"%d\\\\n\\\", result);\\r\\n}","perl":"\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($ti, $td, $tr, $te) = split ' ', $input;\n\nmy $sequenceA = <STDIN>;\nchomp $sequenceA;\n\nmy $sequenceB = <STDIN>;\nchomp $sequenceB;\n\n# Initialize the dynamic programming table\nmy $lengthA = length($sequenceA);\nmy $lengthB = length($sequenceB);\nmy @dp;\n\nfor (my $i = 0; $i <= $lengthA; $i++) {\n    $dp[$i][0] = $i * $td;\n}\n\nfor (my $j = 0; $j <= $lengthB; $j++) {\n    $dp[0][$j] = $j * $ti;\n}\n\n# Fill in the dynamic programming table\nfor (my $i = 1; $i <= $lengthA; $i++) {\n    for (my $j = 1; $j <= $lengthB; $j++) {\n        my $cost = ($sequenceA[$i-1] eq $sequenceB[$j-1]) ? 0 : $tr;\n        $dp[$i][$j] = min(\n            $dp[$i-1][$j] + $td,     # Deletion\n            $dp[$i][$j-1] + $ti,     # Insertion\n            $dp[$i-1][$j-1] + $cost, # Replacement\n        );\n        \n        if ($i > 1 && $j > 1 && $sequenceA[$i-1] eq $sequenceB[$j-2] && $sequenceA[$i-2] eq $sequenceB[$j-1]) {\n            $dp[$i][$j] = min($dp[$i][$j], $dp[$i-2][$j-2] + $te); # Swap\n        }\n    }\n}\n\n# Print the minimum time\nprint $dp[$lengthA][$lengthB];\n","Rust":"use std::cmp::min;\\n\\nfn main() {\\n    let input = r\\\"2 4 10 3\\\\nab\\\\nba\\\\n\\\";\\n    let mut lines = input.lines();\\n    let times: Vec<u32> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let a = lines.next().unwrap().chars().collect::<Vec<char>>();\\n    let b = lines.next().unwrap().chars().collect::<Vec<char>>();\\n\\n    let ti = times[0];\\n    let td = times[1];\\n    let tr = times[2];\\n    let te = times[3];\\n\\n    let mut dp = vec![vec![0; b.len() + 1]; a.len() + 1];\\n\\n    for i in 0..=a.len() {\\n        dp[i][0] = i as u32 * td;\\n    }\\n\\n    for j in 0..=b.len() {\\n        dp[0][j] = j as u32 * ti;\\n    }\\n\\n    for i in 1..=a.len() {\\n        for j in 1..=b.len() {\\n            if a[i - 1] == b[j - 1] {\\n                dp[i][j] = dp[i - 1][j - 1];\\n            } else {\\n                dp[i][j] = min(\\n                    min(dp[i - 1][j] + td, dp[i][j - 1] + ti),\\n                    min(dp[i - 1][j - 1] + tr, dp[i - 1][j - 1] + 2 * te),\\n                );\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", dp[a.len()][b.len()]);\\n}"}
{"title":"D. Optical Experiment","description":"Professor Phunsuk Wangdu has performed some experiments on rays. The setup for n rays is as follows.There is a rectangular box having exactly n holes on the opposite faces. All rays enter from the holes of the first side and exit from the holes of the other side of the box. Exactly one ray can enter or exit from each hole. The holes are in a straight line. Professor Wangdu is showing his experiment to his students. He shows that there are cases, when all the rays are intersected by every other ray. A curious student asked the professor: \"Sir, there are some groups of rays such that all rays in that group intersect every other ray in that group. Can we determine the number of rays in the largest of such groups?\".Professor Wangdu now is in trouble and knowing your intellect he asks you to help him.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains n (1\u2264n\u226410^6), the number of rays. The second line contains n distinct integers. The i-th integer xi (1\u2264xi\u2264n) shows that the xi-th ray enters from the i-th hole. Similarly, third line contains n distinct integers. The i-th integer yi (1\u2264yi\u2264n) shows that the yi-th ray exits from the i-th hole. All rays are numbered from 1 to n. \n","output_spec":"Output contains the only integer which is the number of rays in the largest group of rays all of which intersect each other.\n","notes":"For the first test case, the figure is shown above. The output of the first test case is 3, since the rays number 1, 4 and 3 are the ones which are intersected by each other one i.e. 1 is intersected by 4 and 3, 3 is intersected by 4 and 1, and 4 is intersected by 1 and 3. Hence every ray in this group is intersected by each other one. There does not exist any group containing more than 3 rays satisfying the above-mentioned constraint.\n","sample_inputs":["5\n1 4 5 2 3\n3 4 2 1 5\n","3\n3 1 2\n2 3 1\n"],"sample_outputs":["3\n","2\n"],"id":"67-D","difficulty":1900,"tags":["binary+search","data+structures","dp"],"src_uid":"b0ef9cda01a01cad22e7f4c49e74e85c","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> enter(n);\\n    vector<int> exit(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        cin >> enter[i];\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        cin >> exit[i];\\n    }\\n\\n    vector<int> intersect(n, 0);\\n\\n    for (int i = 0; i < n; i++) {\\n        intersect[enter[i] - 1] = i + 1;\\n    }\\n\\n    int maxGroupSize = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        int curr = i;\\n        int groupSize = 0;\\n\\n        while (curr != -1) {\\n            groupSize++;\\n            curr = intersect[exit[curr] - 1] - 1;\\n        }\\n\\n        maxGroupSize = max(maxGroupSize, groupSize);\\n    }\\n\\n    cout << maxGroupSize << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class RayIntersection {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        int[] enter = new int[n];\n        int[] exit = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            enter[i] = scanner.nextInt();\n        }\n        \n        for (int i = 0; i < n; i++) {\n            exit[i] = scanner.nextInt();\n        }\n        \n        int[] intersectionCount = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            int currentRay = enter[i];\n            \n            while (currentRay != exit[i]) {\n                intersectionCount[currentRay - 1]++;\n                currentRay = enter[currentRay - 1];\n            }\n            \n            intersectionCount[currentRay - 1]++;\n        }\n        \n        int maxIntersection = 0;\n        \n        for (int i = 0; i < n; i++) {\n            maxIntersection = Math.max(maxIntersection, intersectionCount[i]);\n        }\n        \n        System.out.println(maxIntersection);\n    }\n}","Python":"def largest_group_of_rays(n, enter, exit):\\n    intersected = [0] * (n+1)\\n    for i in range(n):\\n        intersected[enter[i]] += 1\\n        intersected[exit[i]] += 1\\n    max_group = max(intersected)\\n    return str(max_group)\\n\\ninput_data = input().split('\\\\n')\\nn = int(input_data[0])\\nenter = list(map(int, input_data[1].split()))\\nexit = list(map(int, input_data[2].split()))\\n\\noutput = largest_group_of_rays(n, enter, exit)\\nprint(output)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int enter[n], exit[n];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &enter[i]);\\n    }\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &exit[i]);\\n    }\\n    int count[n+1];\\n    for(int i=0; i<=n; i++) {\\n        count[i] = 0;\\n    }\\n    for(int i=0; i<n; i++) {\\n        count[enter[i]]++;\\n        count[exit[i]]++;\\n    }\\n    int max = 0;\\n    for(int i=1; i<=n; i++) {\\n        if(count[i] > max) {\\n            max = count[i];\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", max);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] enter = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        int[] exit = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int[] intersectCount = new int[n + 1];\n\n        for (int i = 0; i < n; i++)\n        {\n            intersectCount[enter[i]]++;\n            intersectCount[exit[i]]++;\n        }\n\n        int maxIntersect = intersectCount.Max();\n\n        Console.WriteLine(maxIntersect);\n    }\n}","Ruby":"\ndef largest_group_of_rays(n, enter, exit)\n  # Create a hash to store the count of intersecting rays for each ray\n  intersect_count = Hash.new(0)\n\n  # Iterate through each ray and count the number of intersecting rays\n  (0...n).each do |i|\n    intersect_count[enter[i]] += 1\n    intersect_count[exit[i]] += 1\n  end\n\n  # Find the maximum count of intersecting rays\n  max_count = intersect_count.values.max\n\n  # Return the maximum count\n  max_count\nend\n\n# Read the input\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nenter = input[1].split(' ').map(&:to_i)\nexit = input[2].split(' ').map(&:to_i)\n\n# Call the function and print the result\nresult = largest_group_of_rays(n, enter, exit)\nputs result\n","delphi":"program RaysIntersection;\\n\\nvar\\n  n, i, j, maxGroupSize, groupSize: integer;\\n  raysEnter, raysExit: array of integer;\\n  intersected: array of boolean;\\n\\nbegin\\n  \/\/ Read the number of rays\\n  readln(n);\\n\\n  \/\/ Read the rays enter and exit positions\\n  SetLength(raysEnter, n);\\n  SetLength(raysExit, n);\\n  for i := 0 to n-1 do\\n    read(raysEnter[i]);\\n  readln;\\n  for i := 0 to n-1 do\\n    read(raysExit[i]);\\n  readln;\\n\\n  \/\/ Initialize the intersected array\\n  SetLength(intersected, n);\\n  for i := 0 to n-1 do\\n    intersected[i] := true;\\n\\n  \/\/ Find the intersected rays\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to n-1 do\\n    begin\\n      if (raysEnter[i] = raysExit[j]) or (raysExit[i] = raysEnter[j]) then\\n        intersected[i] := intersected[i] and intersected[j];\\n    end;\\n  end;\\n\\n  \/\/ Find the maximum group size\\n  maxGroupSize := 0;\\n  for i := 0 to n-1 do\\n  begin\\n    if intersected[i] then\\n    begin\\n      groupSize := 0;\\n      for j := 0 to n-1 do\\n      begin\\n        if intersected[j] and ((raysEnter[i] = raysExit[j]) or (raysExit[i] = raysEnter[j])) then\\n          Inc(groupSize);\\n      end;\\n      if groupSize > maxGroupSize then\\n        maxGroupSize := groupSize;\\n    end;\\n  end;\\n\\n  \/\/ Print the result\\n  writeln(maxGroupSize);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\n\\t\/\/ Read n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\/\/ Read enter rays\\n\\tscanner.Scan()\\n\\tenterRays := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\t\/\/ Read exit rays\\n\\tscanner.Scan()\\n\\texitRays := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\t\/\/ Create a map to store the intersection count for each ray\\n\\tintersectionCount := make(map[string]int)\\n\\n\\t\/\/ Iterate over enter rays\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tray := enterRays[i]\\n\\t\\tintersectionCount[ray]++\\n\\t}\\n\\n\\t\/\/ Iterate over exit rays\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tray := exitRays[i]\\n\\t\\tintersectionCount[ray]++\\n\\t}\\n\\n\\t\/\/ Find the maximum intersection count\\n\\tmaxIntersectionCount := 0\\n\\tfor _, count := range intersectionCount {\\n\\t\\tif count > maxIntersectionCount {\\n\\t\\t\\tmaxIntersectionCount = count\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Print the result\\n\\tfmt.Println(maxIntersectionCount)\\n}","Javascript":"function findLargestGroup(n, enter, exit) {\n    let intersected = new Array(n).fill(0);\n    \n    for (let i = 0; i < n; i++) {\n        intersected[enter[i] - 1]++;\n        intersected[exit[i] - 1]++;\n    }\n    \n    let maxIntersected = Math.max(...intersected);\n    \n    return maxIntersected;\n}\n\n\/\/ Sample inputs\nlet inputs = [\n    { n: 5, enter: [1, 4, 5, 2, 3], exit: [3, 4, 2, 1, 5] },\n    { n: 3, enter: [3, 1, 2], exit: [2, 3, 1] }\n];\n\nlet outputs = [];\n\nfor (let input of inputs) {\n    let result = findLargestGroup(input.n, input.enter, input.exit);\n    outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val enter = IntArray(n)\n    val exit = IntArray(n)\n    \n    for (i in 0 until n) {\n        enter[i] = scanner.nextInt()\n    }\n    \n    for (i in 0 until n) {\n        exit[i] = scanner.nextInt()\n    }\n    \n    val intersected = IntArray(n)\n    \n    for (i in 0 until n) {\n        intersected[enter[i] - 1] = exit[i]\n    }\n    \n    var maxGroupSize = 0\n    \n    for (i in 0 until n) {\n        var count = 1\n        var next = intersected[i]\n        \n        while (next != i + 1) {\n            count++\n            next = intersected[next - 1]\n        }\n        \n        maxGroupSize = maxOf(maxGroupSize, count)\n    }\n    \n    println(maxGroupSize)\n}","PHP":"<?php\\n\\nfunction largestIntersectingGroup($n, $enter, $exit) {\\n    $intersectingGroups = [];\\n\\n    \/\/ Loop through each ray\\n    for ($i = 0; $i < $n; $i++) {\\n        $ray = $i + 1;\\n        $intersectingGroup = [$ray];\\n\\n        \/\/ Find all rays intersected by the current ray\\n        $intersectedRays = [$ray];\\n        $currentRay = $ray;\\n        while (true) {\\n            $nextRay = $exit[$enter[$currentRay - 1] - 1];\\n\\n            \/\/ If the next ray is already in the intersecting group, break the loop\\n            if (in_array($nextRay, $intersectingGroup)) {\\n                break;\\n            }\\n\\n            \/\/ If the next ray is already in the intersected rays, there is a loop\\n            if (in_array($nextRay, $intersectedRays)) {\\n                \/\/ Add all rays in the loop to the intersecting group\\n                $loopStartIndex = array_search($nextRay, $intersectedRays);\\n                $loopRays = array_slice($intersectedRays, $loopStartIndex);\\n                $intersectingGroup = array_merge($intersectingGroup, $loopRays);\\n                break;\\n            }\\n\\n            $intersectedRays[] = $nextRay;\\n            $intersectingGroup[] = $nextRay;\\n            $currentRay = $nextRay;\\n        }\\n\\n        $intersectingGroups[] = $intersectingGroup;\\n    }\\n\\n    \/\/ Find the largest intersecting group\\n    $largestGroupSize = 0;\\n    foreach ($intersectingGroups as $group) {\\n        $groupSize = count($group);\\n        if ($groupSize > $largestGroupSize) {\\n            $largestGroupSize = $groupSize;\\n        }\\n    }\\n\\n    return $largestGroupSize;\\n}\\n\\n\/\/ Sample inputs\\n$input1 = \\\"5\\\\n1 4 5 2 3\\\\n3 4 2 1 5\\\";\\n$input2 = \\\"3\\\\n3 1 2\\\\n2 3 1\\\";\\n\\n\/\/ Convert inputs to variables\\n[$n1, $enter1, $exit1] = explode(\\\"\\\\n\\\", $input1);\\n[$n2, $enter2, $exit2] = explode(\\\"\\\\n\\\", $input2);\\n$enter1 = array_map('intval', explode(\\\" \\\", $enter1));\\n$exit1 = array_map('intval', explode(\\\" \\\", $exit1));\\n$enter2 = array_map('intval', explode(\\\" \\\", $enter2));\\n$exit2 = array_map('intval', explode(\\\" \\\", $exit2));\\n\\n\/\/ Call the function for each sample input\\n$output1 = largestIntersectingGroup($n1, $enter1, $exit1);\\n$output2 = largestIntersectingGroup($n2, $enter2, $exit2);\\n\\n\/\/ Format the outputs\\n$output1 = \\\"$output1\\\\n\\\";\\n$output2 = \\\"$output2\\\\n\\\";\\n\\n\/\/ Print the outputs\\necho $output1;\\necho $output2;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int[] enter = new int[n];\\r\\n    int[] exit = new int[n];\\r\\n\\r\\n    readf(\\\"%s\\\", &enter);\\r\\n    readf(\\\"%s\\\", &exit);\\r\\n\\r\\n    int[] intersectCount = new int[n];\\r\\n\\r\\n    foreach (i, e; enter)\\r\\n    {\\r\\n        intersectCount[e - 1] = i + 1;\\r\\n    }\\r\\n\\r\\n    int maxGroupSize = 0;\\r\\n\\r\\n    foreach (i, e; exit)\\r\\n    {\\r\\n        int groupSize = 1;\\r\\n        int currentRay = e;\\r\\n\\r\\n        while (intersectCount[currentRay - 1] != e)\\r\\n        {\\r\\n            currentRay = intersectCount[currentRay - 1];\\r\\n            groupSize++;\\r\\n        }\\r\\n\\r\\n        if (groupSize > maxGroupSize)\\r\\n        {\\r\\n            maxGroupSize = groupSize;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxGroupSize);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub largest_group_of_rays {\n    my ($n, $enter, $exit) = @_;\n\n    my %intersect_count;\n    for my $i (0..$n-1) {\n        for my $j (0..$n-1) {\n            if ($i != $j) {\n                $intersect_count{$enter->[$i]}{$exit->[$j]}++;\n            }\n        }\n    }\n\n    my $max_group_size = 0;\n    for my $i (0..$n-1) {\n        my $group_size = 1;\n        for my $j (0..$n-1) {\n            if ($i != $j && $intersect_count{$enter->[$i]}{$exit->[$j]}) {\n                $group_size++;\n            }\n        }\n        $max_group_size = $group_size if $group_size > $max_group_size;\n    }\n\n    return $max_group_size;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $enter, $exit) = split ' ', $input;\n$enter = [split ' ', $enter];\n$exit = [split ' ', $exit];\n\n# Calculate largest group of rays\nmy $largest_group = largest_group_of_rays($n, $enter, $exit);\n\n# Print output\nprint $largest_group;\n","Rust":"fn main() {\\n    let input = \\\"5\\\\n1 4 5 2 3\\\\n3 4 2 1 5\\\\n\\\";\\n    let mut lines = input.lines();\\n    let n: usize = lines.next().unwrap().parse().unwrap();\\n    let enter: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n    let exit: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\\n\\n    let mut intersected = vec![0; n + 1];\\n\\n    for i in 0..n {\\n        intersected[enter[i]] = i + 1;\\n    }\\n\\n    let mut max_group = 0;\\n\\n    for i in 0..n {\\n        let mut group = 1;\\n        let mut current = exit[i];\\n\\n        while current != enter[i] {\\n            group += 1;\\n            current = exit[intersected[current] - 1];\\n        }\\n\\n        max_group = max_group.max(group);\\n    }\\n\\n    println!(\\\"{}\\\", max_group);\\n}"}
{"title":"E. Save the City!","description":"In the town of Aalam-Aara (meaning the Light of the Earth), previously there was no crime, no criminals but as the time progressed, sins started creeping into the hearts of once righteous people. Seeking solution to the problem, some of the elders found that as long as the corrupted part of population was kept away from the uncorrupted part, the crimes could be stopped. So, they are trying to set up a compound where they can keep the corrupted people. To ensure that the criminals don't escape the compound, a watchtower needs to be set up, so that they can be watched.Since the people of Aalam-Aara aren't very rich, they met up with a merchant from some rich town who agreed to sell them a land-plot which has already a straight line fence AB along which a few points are set up where they can put up a watchtower. Your task is to help them find out the number of points on that fence where the tower can be put up, so that all the criminals can be watched from there. Only one watchtower can be set up. A criminal is watchable from the watchtower if the line of visibility from the watchtower to him doesn't cross the plot-edges at any point between him and the tower i.e. as shown in figure 1 below, points X, Y, C and A are visible from point B but the points E and D are not.    Figure 1     Figure 2 Assume that the land plot is in the shape of a polygon and coordinate axes have been setup such that the fence AB is parallel to x-axis and the points where the watchtower can be set up are the integer points on the line. For example, in given figure 2, watchtower can be setup on any of five integer points on AB i.e. (4,8), (5,8), (6,8), (7,8) or (8,8). You can assume that no three consecutive points are collinear and all the corner points other than A and B, lie towards same side of fence AB. The given polygon doesn't contain self-intersections.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line of the test case will consist of the number of vertices n (3\u2264n\u22641000).\nNext n lines will contain the coordinates of the vertices in the clockwise order of the polygon. On the i-th line are integers xi and yi (0\u2264xi,yi\u226410^6) separated by a space.\nThe endpoints of the fence AB are the first two points, (x1,y1) and (x2,y2).\n","output_spec":"Output consists of a single line containing the number of points where the watchtower can be set up.\n","notes":"Figure 2 shows the first test case. All the points in the figure are watchable from any point on fence AB. Since, AB has 5 integer coordinates, so answer is 5.\nFor case two, fence CD and DE are not completely visible, thus answer is 0.\n","sample_inputs":["5\n4 8\n8 8\n9 4\n4 0\n0 4\n","5\n4 8\n5 8\n5 4\n7 4\n2 2\n"],"sample_outputs":["5\n","0\n"],"id":"67-E","difficulty":2500,"tags":["geometry"],"src_uid":"1503f0379bf8d7f25c191ddea9278842","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\nusing namespace std;\\n\\nstruct Point {\\n    int x, y;\\n};\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint countWatchtowers(vector<Point>& polygon, Point A, Point B) {\\n    int count = 0;\\n    int dx = abs(B.x - A.x);\\n    int dy = abs(B.y - A.y);\\n    int g = gcd(dx, dy);\\n    dx \/= g;\\n    dy \/= g;\\n\\n    for (int i = 0; i < polygon.size(); i++) {\\n        int x1 = polygon[i].x;\\n        int y1 = polygon[i].y;\\n        int x2 = polygon[(i + 1) % polygon.size()].x;\\n        int y2 = polygon[(i + 1) % polygon.size()].y;\\n\\n        if ((x1 - A.x) * dy - (y1 - A.y) * dx >= 0 && (x2 - A.x) * dy - (y2 - A.y) * dx <= 0)\\n            count++;\\n    }\\n\\n    return count;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    vector<Point> polygon(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> polygon[i].x >> polygon[i].y;\\n    }\\n\\n    Point A = polygon[0];\\n    Point B = polygon[1];\\n\\n    int result = countWatchtowers(polygon, A, B);\\n\\n    cout << result << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Watchtower {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = Integer.parseInt(scanner.nextLine());\n        int[][] vertices = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            String[] coordinates = scanner.nextLine().split(\" \");\n            vertices[i][0] = Integer.parseInt(coordinates[0]);\n            vertices[i][1] = Integer.parseInt(coordinates[1]);\n        }\n        \n        int x1 = vertices[0][0];\n        int y1 = vertices[0][1];\n        int x2 = vertices[1][0];\n        int y2 = vertices[1][1];\n        \n        int minX = Math.min(x1, x2);\n        int maxX = Math.max(x1, x2);\n        \n        int count = 0;\n        \n        for (int i = 2; i < n; i++) {\n            int x = vertices[i][0];\n            int y = vertices[i][1];\n            \n            if (x >= minX && x <= maxX && y >= y1 && y <= y2) {\n                count++;\n            }\n        }\n        \n        System.out.println(count);\n    }\n}","Python":"def count_watchtowers(vertices):\n    n = len(vertices)\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    \n    count = 0\n    \n    for i in range(1, n-1):\n        x, y = vertices[i]\n        if (y - y1) * (x2 - x1) == (y2 - y1) * (x - x1):\n            continue\n        count += 1\n    \n    return str(count)\n\ntest_cases = ['5\\n4 8\\n8 8\\n9 4\\n4 0\\n0 4\\n', '5\\n4 8\\n5 8\\n5 4\\n7 4\\n2 2\\n']\nresults = []\n\nfor test_case in test_cases:\n    lines = test_case.strip().split('\\n')\n    n = int(lines[0])\n    vertices = [list(map(int, line.split())) for line in lines[1:]]\n    result = count_watchtowers(vertices)\n    results.append(result)\n\noutput = '\\\\n'.join(results)\nprint(output)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n\/\/ Function to calculate the gcd of two numbers\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\n\/\/ Function to calculate the number of points where the watchtower can be set up\\nint calculateWatchtowerPoints(int x1, int y1, int x2, int y2) {\\n    int dx = abs(x2 - x1);\\n    int dy = abs(y2 - y1);\\n    int g = gcd(dx, dy);\\n    return g + 1;\\n}\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n\\n    int x1, y1, x2, y2;\\n    scanf(\\\"%d %d\\\", &x1, &y1);\\n    scanf(\\\"%d %d\\\", &x2, &y2);\\n\\n    int watchtowerPoints = calculateWatchtowerPoints(x1, y1, x2, y2);\\n    printf(\\\"%d\\\\n\\\", watchtowerPoints);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace Watchtower\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read the number of vertices\n            int n = int.Parse(Console.ReadLine());\n\n            \/\/ Read the coordinates of the vertices\n            List<Point> vertices = new List<Point>();\n            for (int i = 0; i < n; i++)\n            {\n                string[] coordinates = Console.ReadLine().Split(' ');\n                int x = int.Parse(coordinates[0]);\n                int y = int.Parse(coordinates[1]);\n                vertices.Add(new Point(x, y));\n            }\n\n            \/\/ Read the coordinates of the fence endpoints\n            string[] fenceCoordinates = Console.ReadLine().Split(' ');\n            int x1 = int.Parse(fenceCoordinates[0]);\n            int y1 = int.Parse(fenceCoordinates[1]);\n            int x2 = int.Parse(fenceCoordinates[2]);\n            int y2 = int.Parse(fenceCoordinates[3]);\n\n            \/\/ Calculate the number of watchtower points\n            int watchtowerPoints = CalculateWatchtowerPoints(vertices, x1, y1, x2, y2);\n\n            \/\/ Output the result\n            Console.WriteLine(watchtowerPoints);\n        }\n\n        static int CalculateWatchtowerPoints(List<Point> vertices, int x1, int y1, int x2, int y2)\n        {\n            int watchtowerPoints = 0;\n\n            \/\/ Calculate the slope of the fence\n            double slope = (double)(y2 - y1) \/ (x2 - x1);\n\n            \/\/ Check each integer point on the fence\n            for (int x = x1 + 1; x < x2; x++)\n            {\n                int y = (int)(slope * (x - x1) + y1);\n\n                \/\/ Check if the point is inside the polygon\n                if (IsInsidePolygon(vertices, x, y))\n                {\n                    watchtowerPoints++;\n                }\n            }\n\n            return watchtowerPoints;\n        }\n\n        static bool IsInsidePolygon(List<Point> vertices, int x, int y)\n        {\n            int count = 0;\n            int n = vertices.Count;\n\n            for (int i = 0; i < n; i++)\n            {\n                Point currentVertex = vertices[i];\n                Point nextVertex = vertices[(i + 1) % n];\n\n                if ((currentVertex.Y <= y && y < nextVertex.Y) || (nextVertex.Y <= y && y < currentVertex.Y))\n                {\n                    double intersectionX = (double)(y - currentVertex.Y) * (nextVertex.X - currentVertex.X) \/ (nextVertex.Y - currentVertex.Y) + currentVertex.X;\n\n                    if (x < intersectionX)\n                    {\n                        count++;\n                    }\n                }\n            }\n\n            return count % 2 == 1;\n        }\n    }\n\n    class Point\n    {\n        public int X { get; set; }\n        public int Y { get; set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n}","Ruby":"\ndef count_watchtowers(input)\n  # Parse the input\n  lines = input.split(\"\\n\")\n  n = lines[0].to_i\n  vertices = lines[1..n].map { |line| line.split(\" \").map(&:to_i) }\n  x1, y1 = vertices[0]\n  x2, y2 = vertices[1]\n\n  # Calculate the number of watchtowers\n  count = 0\n  (x1+1..x2-1).each do |x|\n    y = ((y2-y1).to_f \/ (x2-x1) * (x-x1) + y1).to_i\n    count += 1 if y == y.to_i\n  end\n\n  # Return the result\n  count.to_s\nend\n\n# Test the function with the sample inputs\ninputs = ['5\\n4 8\\n8 8\\n9 4\\n4 0\\n0 4\\n', '5\\n4 8\\n5 8\\n5 4\\n7 4\\n2 2\\n']\noutputs = ['5\\n', '0\\n']\n\nresults = []\ninputs.each_with_index do |input, i|\n  result = count_watchtowers(input)\n  expected_output = outputs[i]\n  results << (result == expected_output)\nend\n\nresults.all? ? 'All test cases passed' : 'Some test cases failed'\n","delphi":"program Watchtower;\n\nvar\n  n, i, count: Integer;\n  x, y: array[1..1000] of Integer;\n  visible: Boolean;\n\nbegin\n  \/\/ Read the number of vertices\n  ReadLn(n);\n  \n  \/\/ Read the coordinates of the vertices\n  for i := 1 to n do\n    ReadLn(x[i], y[i]);\n  \n  \/\/ Initialize the count of watchtower points\n  count := 0;\n  \n  \/\/ Check each point on the fence AB\n  for i := x[1] + 1 to x[2] - 1 do\n  begin\n    visible := True;\n    \n    \/\/ Check if the point is visible from the watchtower\n    for j := 3 to n do\n    begin\n      if (y[j] - y[1]) * (i - x[1]) <= (y[2] - y[1]) * (x[j] - x[1]) then\n      begin\n        visible := False;\n        Break;\n      end;\n    end;\n    \n    \/\/ Increment the count if the point is visible\n    if visible then\n      Inc(count);\n  end;\n  \n  \/\/ Print the number of watchtower points\n  WriteLn(count);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\n\/\/ Point struct to represent a point in 2D space\\ntype Point struct {\\n\\tx, y int\\n}\\n\\n\/\/ Line struct to represent a line segment\\ntype Line struct {\\n\\tp1, p2 Point\\n}\\n\\n\/\/ Function to check if a point is on the left side of a line\\nfunc isLeft(p, q, r Point) bool {\\n\\treturn (q.x-p.x)*(r.y-p.y)-(q.y-p.y)*(r.x-p.x) > 0\\n}\\n\\n\/\/ Function to check if a point is on the right side of a line\\nfunc isRight(p, q, r Point) bool {\\n\\treturn (q.x-p.x)*(r.y-p.y)-(q.y-p.y)*(r.x-p.x) < 0\\n}\\n\\n\/\/ Function to check if a point is collinear with a line\\nfunc isCollinear(p, q, r Point) bool {\\n\\treturn (q.x-p.x)*(r.y-p.y)-(q.y-p.y)*(r.x-p.x) == 0\\n}\\n\\n\/\/ Function to check if a point is inside a polygon\\nfunc isInsidePolygon(polygon []Point, point Point) bool {\\n\\tn := len(polygon)\\n\\tif n < 3 {\\n\\t\\treturn false\\n\\t}\\n\\tcount := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tj := (i + 1) % n\\n\\t\\tp1 := polygon[i]\\n\\t\\tp2 := polygon[j]\\n\\t\\tif isCollinear(p1, p2, point) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif isLeft(p1, p2, point) && isRight(p1, p2, point) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\treturn count%2 == 1\\n}\\n\\n\/\/ Function to calculate the number of points where the watchtower can be set up\\nfunc calculateWatchtowerPoints(vertices []Point, fence Line) int {\\n\\tminX := int(math.Min(float64(fence.p1.x), float64(fence.p2.x)))\\n\\tmaxX := int(math.Max(float64(fence.p1.x), float64(fence.p2.x)))\\n\\twatchtowerPoints := 0\\n\\tfor x := minX; x <= maxX; x++ {\\n\\t\\tpoint := Point{x: x, y: fence.p1.y}\\n\\t\\tif isInsidePolygon(vertices, point) {\\n\\t\\t\\twatchtowerPoints++\\n\\t\\t}\\n\\t}\\n\\treturn watchtowerPoints\\n}\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\tvertices := make([]Point, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&vertices[i].x, &vertices[i].y)\\n\\t}\\n\\tfence := Line{p1: vertices[0], p2: vertices[1]}\\n\\twatchtowerPoints := calculateWatchtowerPoints(vertices, fence)\\n\\tfmt.Println(watchtowerPoints)\\n}","Javascript":"function countWatchtowerPoints(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const vertices = [];\n  for (let i = 1; i <= n; i++) {\n    const [x, y] = lines[i].split(' ').map(Number);\n    vertices.push({ x, y });\n  }\n  const [x1, y1] = lines[n + 1].split(' ').map(Number);\n  const [x2, y2] = lines[n + 2].split(' ').map(Number);\n\n  let count = 0;\n  for (let i = Math.min(x1, x2) + 1; i < Math.max(x1, x2); i++) {\n    let visible = true;\n    for (let j = 0; j < n; j++) {\n      const p1 = vertices[j];\n      const p2 = vertices[(j + 1) % n];\n      if (isPointOnLine(p1, p2, { x: i, y: y1 })) {\n        visible = false;\n        break;\n      }\n    }\n    if (visible) {\n      count++;\n    }\n  }\n\n  return count.toString();\n}\n\nfunction isPointOnLine(p1, p2, point) {\n  const slope = (p2.y - p1.y) \/ (p2.x - p1.x);\n  const yIntercept = p1.y - slope * p1.x;\n  const expectedY = slope * point.x + yIntercept;\n  return Math.abs(expectedY - point.y) < 1e-9;\n}\n\nconst inputs = ['5\\\\n4 8\\\\n8 8\\\\n9 4\\\\n4 0\\\\n0 4\\\\n', '5\\\\n4 8\\\\n5 8\\\\n5 4\\\\n7 4\\\\n2 2\\\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const output = countWatchtowerPoints(inputs[i]);\n  outputs.push(output);\n}\n\nJSON.stringify([{ \"version\": \"JavaScript\", \"source code\": countWatchtowerPoints.toString() }, { \"outputs\": outputs }]);","Kotlin":"import java.util.*\n\ndata class Point(val x: Int, val y: Int)\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val vertices = mutableListOf<Point>()\n    for (i in 0 until n) {\n        val x = scanner.nextInt()\n        val y = scanner.nextInt()\n        vertices.add(Point(x, y))\n    }\n    val fenceStart = vertices[0]\n    val fenceEnd = vertices[1]\n    \n    val watchtowerPoints = mutableListOf<Point>()\n    for (i in fenceStart.x + 1 until fenceEnd.x) {\n        watchtowerPoints.add(Point(i, fenceStart.y))\n    }\n    \n    var count = 0\n    for (point in watchtowerPoints) {\n        if (isWatchable(point, vertices)) {\n            count++\n        }\n    }\n    \n    println(count)\n}\n\nfun isWatchable(point: Point, vertices: List<Point>): Boolean {\n    for (i in 0 until vertices.size - 1) {\n        val p1 = vertices[i]\n        val p2 = vertices[i + 1]\n        if (isIntersecting(point, p1, p2)) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isIntersecting(point: Point, p1: Point, p2: Point): Boolean {\n    val slope = (p2.y - p1.y).toDouble() \/ (p2.x - p1.x)\n    val yIntercept = p1.y - slope * p1.x\n    val expectedY = slope * point.x + yIntercept\n    return point.y <= expectedY\n}","PHP":"<?php\\n\\nfunction countWatchtowerPoints($input) {\\n    $lines = explode('\\n', $input);\\n    $n = intval($lines[0]);\\n    $vertices = [];\\n    for ($i = 1; $i <= $n; $i++) {\\n        $coords = explode(' ', $lines[$i]);\\n        $x = intval($coords[0]);\\n        $y = intval($coords[1]);\\n        $vertices[] = [$x, $y];\\n    }\\n    $x1 = $vertices[0][0];\\n    $x2 = $vertices[1][0];\\n    $y1 = $vertices[0][1];\\n    $y2 = $vertices[1][1];\\n    $count = abs($x2 - $x1) - 1;\\n    return $count;\\n}\\n\\n$input = '5\\\\n4 8\\\\n8 8\\\\n9 4\\\\n4 0\\\\n0 4\\\\n';\\n$output = countWatchtowerPoints($input);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\n\\r\\nstruct Point {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isCollinear(Point a, Point b, Point c) {\\r\\n    return (b.y - a.y) * (c.x - b.x) == (c.y - b.y) * (b.x - a.x);\\r\\n}\\r\\n\\r\\nbool isWatchable(Point a, Point b, Point c) {\\r\\n    return !isCollinear(a, b, c) && (b.y - a.y) * (c.x - b.x) >= (c.y - b.y) * (b.x - a.x);\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    Point[] vertices;\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        vertices ~= Point(x, y);\\r\\n    }\\r\\n\\r\\n    int x1 = vertices[0].x;\\r\\n    int y1 = vertices[0].y;\\r\\n    int x2 = vertices[1].x;\\r\\n    int y2 = vertices[1].y;\\r\\n\\r\\n    int count = 0;\\r\\n    foreach (i; 0 .. vertices.length) {\\r\\n        if (isWatchable(Point(x1, y1), Point(x2, y2), vertices[i])) {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(to!string(count));\\r\\n\\r\\n    return 0;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub count_watchtowers {\\n    my ($vertices) = @_;\\n    my $n = scalar(@$vertices);\\n    my ($x1, $y1) = @{$vertices->[0]};\\n    my ($x2, $y2) = @{$vertices->[1]};\\n    my $count = 0;\\n\\n    for my $x ($x1..$x2) {\\n        my $y = $y1 + int(($y2 - $y1) * ($x - $x1) \/ ($x2 - $x1));\\n        my $visible = 1;\\n\\n        for my $i (2..$n-1) {\\n            my ($x3, $y3) = @{$vertices->[$i]};\\n            my ($x4, $y4) = @{$vertices->[$i+1]};\\n\\n            if (($y3 - $y1) * ($x - $x1) - ($y - $y1) * ($x3 - $x1) > 0 &&\\n                ($y4 - $y1) * ($x - $x1) - ($y - $y1) * ($x4 - $x1) < 0) {\\n                $visible = 0;\\n                last;\\n            }\\n        }\\n\\n        $count++ if $visible;\\n    }\\n\\n    return $count;\\n}\\n\\nsub main {\\n    my $input = <STDIN>;\\n    chomp $input;\\n    my $n = int($input);\\n    my @vertices;\\n\\n    for (1..$n) {\\n        $input = <STDIN>;\\n        chomp $input;\\n        my ($x, $y) = split(' ', $input);\\n        push @vertices, [$x, $y];\\n    }\\n\\n    my $result = count_watchtowers(\\@vertices);\\n    print $result . \\\"\\\\n\\\";\\n}\\n\\nmain();\\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|line| line.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let vertices: Vec<(i32, i32)> = lines\n        .take(n)\n        .map(|line| {\n            let mut coords = line.split_whitespace();\n            let x: i32 = coords.next().unwrap().parse().unwrap();\n            let y: i32 = coords.next().unwrap().parse().unwrap();\n            (x, y)\n        })\n        .collect();\n    \n    let (x1, y1) = vertices[0];\n    let (x2, y2) = vertices[1];\n    \n    let mut count = 0;\n    for x in x1..=x2 {\n        let y = y1 + (x - x1) * (y2 - y1) \/ (x2 - x1);\n        let mut visible = true;\n        \n        for i in 2..n {\n            let (x3, y3) = vertices[i];\n            let (x4, y4) = vertices[(i + 1) % n];\n            \n            if intersects(x1, y1, x, y, x3, y3, x4, y4) {\n                visible = false;\n                break;\n            }\n        }\n        \n        if visible {\n            count += 1;\n        }\n    }\n    \n    println!(\"{}\", count);\n}\n\nfn intersects(x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32, x4: i32, y4: i32) -> bool {\n    let d1 = direction(x3, y3, x4, y4, x1, y1);\n    let d2 = direction(x3, y3, x4, y4, x2, y2);\n    let d3 = direction(x1, y1, x2, y2, x3, y3);\n    let d4 = direction(x1, y1, x2, y2, x4, y4);\n    \n    (d1 > 0 && d2 < 0 || d1 < 0 && d2 > 0) && (d3 > 0 && d4 < 0 || d3 < 0 && d4 > 0)\n}\n\nfn direction(x1: i32, y1: i32, x2: i32, y2: i32, x3: i32, y3: i32) -> i32 {\n    (x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)\n}"}
{"title":"E. Contact","description":"Little Petya is preparing for the first contact with aliens. He knows that alien spaceships have shapes of non-degenerate triangles and there will be exactly 4 ships. Landing platform for a ship can be made of 3 special columns located at some points of a Cartesian plane such that these 3 points form a triangle equal to the ship with respect to rotations, translations (parallel shifts along some vector) and reflections (symmetries along the edges). The ships can overlap after the landing.Each column can be used to land more than one ship, for example, if there are two equal ships, we don't need to build 6 columns to land both ships, 3 will be enough. Petya wants to know what minimum number of columns will be enough to land all ships. ","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"Each of 4 lines will contain 6 integers x1 y1 x2 y2 x3 y3 (0\u2264x1,y1,x2,y2,x3,y3\u226420), representing 3 points that describe the shape of each of 4 ships. It is guaranteed that 3 points in each line will represent a non-degenerate triangle.\n","output_spec":"First line should contain minimum number of columns enough to land all spaceships.\n","notes":"In the first test case columns can be put in these points: (0,0),(1,0),(3,0),(1,2). Note that the second ship can land using last 3 columns.\nIn the second test case following points can be chosen: (0,0),(0,1),(1,0),(0,2),(2,0),(0,5),(5,0),(0,17),(17,0). It is impossible to use less than 9 columns.\n","sample_inputs":["0 0 1 0 1 2\n0 0 0 2 2 2\n0 0 3 0 1 2\n0 0 3 0 2 2\n","0 0 0 1 1 1\n0 0 0 2 2 2\n0 0 0 5 5 5\n0 0 0 17 17 17\n"],"sample_outputs":["4\n","9\n"],"id":"68-E","difficulty":2900,"tags":["geometry"],"src_uid":"369f37d3487ba8c158e24f5ca759287b","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\nusing namespace std;\\n\\nstruct Point {\\n    int x, y;\\n};\\n\\nbool isSameTriangle(Point p1, Point p2, Point p3, Point q1, Point q2, Point q3) {\\n    vector<Point> p = {p1, p2, p3};\\n    vector<Point> q = {q1, q2, q3};\\n    sort(p.begin(), p.end(), [](Point a, Point b) {\\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\\n    });\\n    sort(q.begin(), q.end(), [](Point a, Point b) {\\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\\n    });\\n    for (int i = 0; i < 3; i++) {\\n        if (p[i].x != q[i].x || p[i].y != q[i].y) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    vector<vector<Point>> ships(4);\\n    for (int i = 0; i < 4; i++) {\\n        int x1, y1, x2, y2, x3, y3;\\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\\n        ships[i] = {{x1, y1}, {x2, y2}, {x3, y3}};\\n    }\\n    int minColumns = 3;\\n    for (int i = 0; i < 4; i++) {\\n        for (int j = i + 1; j < 4; j++) {\\n            for (int k = j + 1; k < 4; k++) {\\n                bool valid = true;\\n                for (int l = 0; l < 4; l++) {\\n                    if (l != i && l != j && l != k) {\\n                        if (!isSameTriangle(ships[i][0], ships[i][1], ships[i][2], ships[l][0], ships[l][1], ships[l][2])) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid) {\\n                    minColumns = min(minColumns, 3);\\n                }\\n            }\\n        }\\n    }\\n    cout << minColumns << endl;\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Scanner;\\nimport java.util.Set;\\n\\npublic class AlienSpaceships {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        List<String> input = new ArrayList<>();\\n        for (int i = 0; i < 4; i++) {\\n            input.add(scanner.nextLine());\\n        }\\n        scanner.close();\\n\\n        int minColumns = findMinimumColumns(input);\\n        System.out.println(minColumns);\\n    }\\n\\n    private static int findMinimumColumns(List<String> input) {\\n        Set<String> columns = new HashSet<>();\\n\\n        for (String line : input) {\\n            String[] points = line.split(\\\" \\\");\\n            for (int i = 0; i < 6; i += 2) {\\n                String column = points[i] + \\\" \\\" + points[i + 1];\\n                columns.add(column);\\n            }\\n        }\\n\\n        return columns.size();\\n    }\\n}\" }","Python":"def minimum_columns(ship_points):\n    columns = set()\n    for points in ship_points:\n        for point in points:\n            columns.add(point)\n    return str(len(columns))\n\ninput_data = ['0 0 1 0 1 2\\n0 0 0 2 2 2\\n0 0 3 0 1 2\\n0 0 3 0 2 2\\n', '0 0 0 1 1 1\\n0 0 0 2 2 2\\n0 0 0 5 5 5\\n0 0 0 17 17 17\\n']\noutput_data = []\n\nfor data in input_data:\n    ships = data.strip().split('\\\\n')\n    ship_points = []\n    for ship in ships:\n        points = ship.split()\n        ship_points.append([(int(points[i]), int(points[i+1])) for i in range(0, len(points), 2)])\n    output_data.append(minimum_columns(ship_points))\n\noutput = [{'version': 'Python 3', 'source code': source_code}]\nprint(output)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <math.h>\\n\\n\/\/ Function to calculate the distance between two points\\nfloat distance(int x1, int y1, int x2, int y2) {\\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\\n}\\n\\n\/\/ Function to check if three points form a triangle\\nint isTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {\\n    float d1 = distance(x1, y1, x2, y2);\\n    float d2 = distance(x2, y2, x3, y3);\\n    float d3 = distance(x3, y3, x1, y1);\\n    if (d1 + d2 > d3 && d2 + d3 > d1 && d3 + d1 > d2) {\\n        return 1;\\n    }\\n    return 0;\\n}\\n\\nint main() {\\n    int columns = 0;\\n    int points[4][3][2];\\n\\n    \/\/ Read input\\n    for (int i = 0; i < 4; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            scanf(\\\"%d %d\\\", &points[i][j][0], &points[i][j][1]);\\n        }\\n    }\\n\\n    \/\/ Check if each ship can land on the same columns\\n    for (int i = 0; i < 4; i++) {\\n        int landed = 0;\\n        for (int j = 0; j < 3; j++) {\\n            int x1 = points[i][j][0];\\n            int y1 = points[i][j][1];\\n            int x2 = points[i][(j + 1) % 3][0];\\n            int y2 = points[i][(j + 1) % 3][1];\\n            int x3 = points[i][(j + 2) % 3][0];\\n            int y3 = points[i][(j + 2) % 3][1];\\n            int valid = 1;\\n            for (int k = 0; k < 4; k++) {\\n                if (k != i) {\\n                    if (!isTriangle(x1, y1, x2, y2, x3, y3)) {\\n                        valid = 0;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (valid) {\\n                landed = 1;\\n                break;\\n            }\\n        }\\n        if (landed) {\\n            columns += 3;\\n        }\\n    }\\n\\n    \/\/ Output the minimum number of columns\\n    printf(\\\"%d\\\\n\\\", columns);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlienSpaceships\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<List<int>> ships = new List<List<int>>();\n            \n            \/\/ Read input\n            for (int i = 0; i < 4; i++)\n            {\n                string[] points = Console.ReadLine().Split(' ');\n                List<int> ship = new List<int>();\n                foreach (string point in points)\n                {\n                    ship.Add(int.Parse(point));\n                }\n                ships.Add(ship);\n            }\n            \n            \/\/ Find minimum number of columns\n            int minColumns = GetMinimumColumns(ships);\n            \n            \/\/ Print output\n            Console.WriteLine(minColumns);\n        }\n        \n        static int GetMinimumColumns(List<List<int>> ships)\n        {\n            List<List<int>> columns = new List<List<int>>();\n            \n            foreach (List<int> ship in ships)\n            {\n                List<int> column1 = new List<int>() { ship[0], ship[1] };\n                List<int> column2 = new List<int>() { ship[2], ship[3] };\n                List<int> column3 = new List<int>() { ship[4], ship[5] };\n                \n                if (!columns.Contains(column1))\n                {\n                    columns.Add(column1);\n                }\n                if (!columns.Contains(column2))\n                {\n                    columns.Add(column2);\n                }\n                if (!columns.Contains(column3))\n                {\n                    columns.Add(column3);\n                }\n            }\n            \n            return columns.Count;\n        }\n    }\n}","Ruby":"def minimum_columns(ship_points)\n  columns = []\n  ship_points.each do |points|\n    points = points.split.map(&:to_i)\n    columns << points[0..3:2].minmax\n    columns << points[1..4:2].minmax\n    columns << points[2..5:2].minmax\n  end\n  columns.uniq.size\nend\n\ninput = ['0 0 1 0 1 2\\n0 0 0 2 2 2\\n0 0 3 0 1 2\\n0 0 3 0 2 2\\n']\noutput = [minimum_columns(input)]\nputs output.to_json","delphi":"program AlienSpaceships;\\n\\nvar\\n  ships: array[1..4] of array[1..3] of record\\n    x, y: Integer;\\n  end;\\n  columns: array[1..9] of record\\n    x, y: Integer;\\n  end;\\n  numColumns: Integer;\\n\\nfunction IsEqual(p1, p2: record x, y: Integer end): Boolean;\\nbegin\\n  IsEqual := (p1.x = p2.x) and (p1.y = p2.y);\\nend;\\n\\nfunction IsTriangle(p1, p2, p3: record x, y: Integer end): Boolean;\\nbegin\\n  IsTriangle := (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) <> 0;\\nend;\\n\\nfunction IsColumnUsed(p: record x, y: Integer end): Boolean;\\nvar\\n  i: Integer;\\nbegin\\n  IsColumnUsed := False;\\n  for i := 1 to numColumns do\\n  begin\\n    if IsEqual(columns[i], p) then\\n    begin\\n      IsColumnUsed := True;\\n      Break;\\n    end;\\n  end;\\nend;\\n\\nprocedure AddColumn(p: record x, y: Integer end);\\nbegin\\n  Inc(numColumns);\\n  columns[numColumns] := p;\\nend;\\n\\nprocedure Main;\\nvar\\n  i, j, k: Integer;\\n  used: array[1..4] of Boolean;\\nbegin\\n  for i := 1 to 4 do\\n  begin\\n    for j := 1 to 3 do\\n    begin\\n      Read(ships[i, j].x, ships[i, j].y);\\n    end;\\n  end;\\n\\n  numColumns := 0;\\n\\n  for i := 1 to 4 do\\n  begin\\n    if not used[i] then\\n    begin\\n      AddColumn(ships[i, 1]);\\n      AddColumn(ships[i, 2]);\\n      AddColumn(ships[i, 3]);\\n\\n      used[i] := True;\\n\\n      for j := i + 1 to 4 do\\n      begin\\n        if not used[j] then\\n        begin\\n          for k := 1 to 3 do\\n          begin\\n            if not IsColumnUsed(ships[j, k]) then\\n            begin\\n              AddColumn(ships[j, k]);\\n            end;\\n          end;\\n\\n          used[j] := True;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  Write(numColumns);\\nend;\\n\\nbegin\\n  Main;\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tinput := []string{\\\"0 0 1 0 1 2\\\", \\\"0 0 0 2 2 2\\\", \\\"0 0 3 0 1 2\\\", \\\"0 0 3 0 2 2\\\"}\\n\\toutput := []string{}\\n\\n\\tfor _, line := range input {\\n\\t\\tpoints := strings.Split(line, \\\" \\\")\\n\\t\\tcolumns := make(map[string]bool)\\n\\n\\t\\tfor i := 0; i < len(points); i += 2 {\\n\\t\\t\\tx := points[i]\\n\\t\\t\\ty := points[i+1]\\n\\t\\t\\tcolumns[x+\\\" \\\"+y] = true\\n\\t\\t}\\n\\n\\t\\toutput = append(output, fmt.Sprintf(\\\"%d\\\", len(columns)))\\n\\t}\\n\\n\\tresult := strings.Join(output, \\\"\\\\n\\\")\\n\\tfmt.Println(result)\\n}","Javascript":"function minimumColumns(shipPoints) {\n  let columns = new Set();\n  \n  for (let i = 0; i < shipPoints.length; i++) {\n    let points = shipPoints[i].split(' ').map(Number);\n    let column1 = [points[0], points[1]];\n    let column2 = [points[2], points[3]];\n    let column3 = [points[4], points[5]];\n    \n    columns.add(column1.join(','));\n    columns.add(column2.join(','));\n    columns.add(column3.join(','));\n  }\n  \n  return columns.size;\n}\n\nlet input = ['0 0 1 0 1 2\\\\n0 0 0 2 2 2\\\\n0 0 3 0 1 2\\\\n0 0 3 0 2 2\\\\n'];\nlet shipPoints = input[0].split('\\\\n');\nshipPoints.pop();\n\nlet result = minimumColumns(shipPoints);\nconsole.log(result);","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\"\\\\n\\\")\\n    val ships = input.map { line ->\\n        line.split(\\\" \\\").map { it.toInt() }\\n    }\\n\\n    val columns = mutableSetOf<Pair<Int, Int>>()\\n\\n    for (i in 0 until 4) {\\n        for (j in i + 1 until 4) {\\n            for (k in j + 1 until 4) {\\n                val triangle = listOf(ships[i], ships[j], ships[k])\\n                val minX = triangle.map { it[0] }.min()!!\\n                val maxX = triangle.map { it[0] }.max()!!\\n                val minY = triangle.map { it[1] }.min()!!\\n                val maxY = triangle.map { it[1] }.max()!!\\n\\n                for (x in minX..maxX) {\\n                    for (y in minY..maxY) {\\n                        if (isInsideTriangle(x, y, triangle)) {\\n                            columns.add(Pair(x, y))\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    println(columns.size)\\n}\\n\\nfun isInsideTriangle(x: Int, y: Int, triangle: List<List<Int>>): Boolean {\\n    val x1 = triangle[0][0]\\n    val y1 = triangle[0][1]\\n    val x2 = triangle[1][0]\\n    val y2 = triangle[1][1]\\n    val x3 = triangle[2][0]\\n    val y3 = triangle[2][1]\\n\\n    val area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) \/ 2)\\n\\n    val area1 = abs((x1 * (y2 - y) + x2 * (y - y1) + x * (y1 - y2)) \/ 2)\\n    val area2 = abs((x1 * (y - y3) + x * (y3 - y1) + x3 * (y1 - y)) \/ 2)\\n    val area3 = abs((x * (y2 - y3) + x2 * (y3 - y) + x3 * (y - y2)) \/ 2)\\n\\n    return area == area1 + area2 + area3\\n}","PHP":"","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.string;\\r\\n\\r\\nstruct Point\\r\\n{\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isSameTriangle(Point[] points1, Point[] points2)\\r\\n{\\r\\n    auto sortedPoints1 = points1.sort!((a, b) => a.x < b.x);\\r\\n    auto sortedPoints2 = points2.sort!((a, b) => a.x < b.x);\\r\\n\\r\\n    return sortedPoints1[0].x == sortedPoints2[0].x && sortedPoints1[0].y == sortedPoints2[0].y &&\\r\\n           sortedPoints1[1].x == sortedPoints2[1].x && sortedPoints1[1].y == sortedPoints2[1].y &&\\r\\n           sortedPoints1[2].x == sortedPoints2[2].x && sortedPoints1[2].y == sortedPoints2[2].y;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n    Point[][] ships = new Point[][];\\r\\n\\r\\n    foreach (line; stdin.byLine())\\r\\n    {\\r\\n        auto shipPoints = line.split;\\r\\n        Point[] points;\\r\\n\\r\\n        foreach (i, pointStr; shipPoints)\\r\\n        {\\r\\n            auto coordinates = pointStr.split.map!(to!int);\\r\\n            points ~= Point(coordinates[0], coordinates[1]);\\r\\n        }\\r\\n\\r\\n        ships ~= points;\\r\\n    }\\r\\n\\r\\n    int columns = 0;\\r\\n\\r\\n    foreach (i, shipPoints; ships)\\r\\n    {\\r\\n        bool isNewTriangle = true;\\r\\n\\r\\n        foreach (j, existingPoints; ships[0..i])\\r\\n        {\\r\\n            if (isSameTriangle(shipPoints, existingPoints))\\r\\n            {\\r\\n                isNewTriangle = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (isNewTriangle)\\r\\n        {\\r\\n            columns += 3;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(columns);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_minimum_columns {\n    my @ships = @_;\n\n    my %columns;\n    foreach my $ship (@ships) {\n        my ($x1, $y1, $x2, $y2, $x3, $y3) = split(' ', $ship);\n\n        # Calculate the bounding box of the ship\n        my $min_x = min($x1, $x2, $x3);\n        my $max_x = max($x1, $x2, $x3);\n        my $min_y = min($y1, $y2, $y3);\n        my $max_y = max($y1, $y2, $y3);\n\n        # Add all points within the bounding box to the columns hash\n        for (my $x = $min_x; $x <= $max_x; $x++) {\n            for (my $y = $min_y; $y <= $max_y; $y++) {\n                $columns{\"$x,$y\"} = 1;\n            }\n        }\n    }\n\n    return scalar(keys %columns);\n}\n\n# Read input from STDIN\nmy @ships;\nforeach my $line (<STDIN>) {\n    chomp $line;\n    push @ships, $line;\n}\n\n# Calculate the minimum number of columns\nmy $minimum_columns = calculate_minimum_columns(@ships);\n\n# Print the result\nprint $minimum_columns;\n","Rust":"fn main() {\\n    use std::collections::HashSet;\\n    use std::io::{self, BufRead};\\n\\n    fn get_triangle_points(line: &str) -> Vec<(i32, i32)> {\\n        let mut points = Vec::new();\\n        let coords: Vec<i32> = line\\n            .split_whitespace()\\n            .map(|x| x.parse().unwrap())\\n            .collect();\\n\\n        for i in (0..coords.len()).step_by(2) {\\n            points.push((coords[i], coords[i + 1]));\\n        }\\n\\n        points\\n    }\\n\\n    fn is_same_triangle(triangle1: &Vec<(i32, i32)>, triangle2: &Vec<(i32, i32)>) -> bool {\\n        let mut set1: HashSet<(i32, i32)> = HashSet::new();\\n        let mut set2: HashSet<(i32, i32)> = HashSet::new();\\n\\n        for point in triangle1.iter() {\\n            set1.insert(*point);\\n        }\\n\\n        for point in triangle2.iter() {\\n            set2.insert(*point);\\n        }\\n\\n        set1 == set2\\n    }\\n\\n    let stdin = io::stdin();\\n    let mut lines = stdin.lock().lines();\\n\\n    let mut triangles: Vec<Vec<(i32, i32)>> = Vec::new();\\n\\n    for _ in 0..4 {\\n        let line = lines.next().unwrap().unwrap();\\n        let triangle = get_triangle_points(&line);\\n        triangles.push(triangle);\\n    }\\n\\n    let mut columns: HashSet<(i32, i32)> = HashSet::new();\\n\\n    for i in 0..4 {\\n        let mut found = false;\\n\\n        for j in 0..4 {\\n            if i != j && is_same_triangle(&triangles[i], &triangles[j]) {\\n                found = true;\\n                break;\\n            }\\n        }\\n\\n        if !found {\\n            for point in triangles[i].iter() {\\n                columns.insert(*point);\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", columns.len());\\n}"}
{"title":"D. Dot","description":"Anton and Dasha like to play different games during breaks on checkered paper. By the 11th grade they managed to play all the games of this type and asked Vova the programmer to come up with a new game. Vova suggested to them to play a game under the code name \"dot\" with the following rules:  On the checkered paper a coordinate system is drawn. A dot is initially put in the position (x,y).  A move is shifting a dot to one of the pre-selected vectors. Also each player can once per game symmetrically reflect a dot relatively to the line y=x.  Anton and Dasha take turns. Anton goes first.  The player after whose move the distance from the dot to the coordinates' origin exceeds d, loses. Help them to determine the winner.","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input file contains 4 integers x, y, n, d (-200\u2264x,y\u2264200,1\u2264d\u2264200,1\u2264n\u226420) \u2014 the initial coordinates of the dot, the distance d and the number of vectors. It is guaranteed that the initial dot is at the distance less than d from the origin of the coordinates. The following n lines each contain two non-negative numbers xi and yi (0\u2264xi,yi\u2264200) \u2014 the coordinates of the i-th vector. It is guaranteed that all the vectors are nonzero and different.\n","output_spec":"You should print \"Anton\", if the winner is Anton in case of both players play the game optimally, and \"Dasha\" otherwise.\n","notes":"In the first test, Anton goes to the vector (1;2), and Dasha loses. In the second test Dasha with her first move shifts the dot so that its coordinates are (2;3), and Anton loses, as he has the only possible move \u2014 to reflect relatively to the line y=x. Dasha will respond to it with the same move and return the dot in position (2;3).\n","sample_inputs":["0 0 2 3\n1 1\n1 2\n","0 0 2 4\n1 1\n1 2\n"],"sample_outputs":["Anton","Dasha"],"id":"69-D","difficulty":1900,"tags":["dp","games"],"src_uid":"645a6ca9a8dda6946c2cc055a4beb08f","C++":"#include <iostream>\\n#include <vector>\\n#include <cmath>\\nusing namespace std;\\n\\nint main() {\\n    int x, y, n, d;\\n    cin >> x >> y >> n >> d;\\n    vector<pair<int, int>> vectors(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> vectors[i].first >> vectors[i].second;\\n    }\\n\\n    bool antonWins = false;\\n    for (int i = 0; i < n; i++) {\\n        int newX = x + vectors[i].first;\\n        int newY = y + vectors[i].second;\\n        if (sqrt(newX * newX + newY * newY) > d) {\\n            antonWins = true;\\n            break;\\n        }\\n    }\\n\\n    if (antonWins) {\\n        cout << \\\"Anton\\\" << endl;\\n    } else {\\n        cout << \\\"Dasha\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class DotGame {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] input = scanner.nextLine().split(\\\" \\\");\n        int x = Integer.parseInt(input[0]);\n        int y = Integer.parseInt(input[1]);\n        int n = Integer.parseInt(input[2]);\n        int d = Integer.parseInt(input[3]);\n        \n        List<int[]> vectors = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            String[] vectorInput = scanner.nextLine().split(\\\" \\\");\n            int xi = Integer.parseInt(vectorInput[0]);\n            int yi = Integer.parseInt(vectorInput[1]);\n            vectors.add(new int[]{xi, yi});\n        }\n        \n        boolean antonWins = playGame(x, y, vectors, d, true);\n        \n        if (antonWins) {\n            System.out.println(\\\"Anton\\\");\n        } else {\n            System.out.println(\\\"Dasha\\\");\n        }\n    }\n    \n    public static boolean playGame(int x, int y, List<int[]> vectors, int d, boolean antonTurn) {\n        if (Math.sqrt(x * x + y * y) > d) {\n            return !antonTurn;\n        }\n        \n        if (antonTurn) {\n            for (int[] vector : vectors) {\n                int newX = x + vector[0];\n                int newY = y + vector[1];\n                boolean antonWins = playGame(newX, newY, vectors, d, false);\n                if (!antonWins) {\n                    return true;\n                }\n            }\n        } else {\n            for (int[] vector : vectors) {\n                int newX = x - vector[0];\n                int newY = y - vector[1];\n                boolean antonWins = playGame(newX, newY, vectors, d, true);\n                if (!antonWins) {\n                    return true;\n                }\n            }\n        }\n        \n        int reflectedX = y;\n        int reflectedY = x;\n        boolean antonWins = playGame(reflectedX, reflectedY, vectors, d, !antonTurn);\n        if (!antonWins) {\n            return true;\n        }\n        \n        return false;\n    }\n}","Python":"\ndef dot_game(x, y, n, d, vectors):\n    def distance(x, y):\n        return (x**2 + y**2)**0.5\n\n    def is_valid_move(x, y, vector):\n        new_x = x + vector[0]\n        new_y = y + vector[1]\n        return distance(new_x, new_y) <= d\n\n    def reflect(x, y):\n        return y, x\n\n    def play_game(x, y, vectors, is_antons_turn):\n        if distance(x, y) > d:\n            return not is_antons_turn\n\n        if is_antons_turn:\n            for vector in vectors:\n                if is_valid_move(x, y, vector):\n                    new_x = x + vector[0]\n                    new_y = y + vector[1]\n                    if play_game(new_x, new_y, vectors, False):\n                        return True\n            if play_game(*reflect(x, y), vectors, False):\n                return True\n        else:\n            for vector in vectors:\n                if is_valid_move(x, y, vector):\n                    new_x = x + vector[0]\n                    new_y = y + vector[1]\n                    if not play_game(new_x, new_y, vectors, True):\n                        return False\n            if not play_game(*reflect(x, y), vectors, True):\n                return False\n\n        return not is_antons_turn\n\n    if play_game(x, y, vectors, True):\n        return 'Anton'\n    else:\n        return 'Dasha'\n\n# Sample inputs\ninputs = ['0 0 2 3\\n1 1\\n1 2\\n', '0 0 2 4\\n1 1\\n1 2\\n']\n\n# Parse inputs\nx, y, n, d = map(int, inputs[0].split()[:4])\nvectors = [tuple(map(int, line.split())) for line in inputs[0].split()[4:]]\n\n# Call the function and print the result\nresult = dot_game(x, y, n, d, vectors)\nprint(result)\n","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\nint main() {\\n    int x, y, n, d;\\n    scanf(\\\"%d %d %d %d\\\", &x, &y, &n, &d);\\n    int vectors[n][2];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d %d\\\", &vectors[i][0], &vectors[i][1]);\\n    }\\n\\n    bool antonWins = false;\\n\\n    for (int i = 0; i < n; i++) {\\n        int newX = x + vectors[i][0];\\n        int newY = y + vectors[i][1];\\n\\n        if (newX * newX + newY * newY > d * d) {\\n            antonWins = true;\\n            break;\\n        }\\n\\n        int reflectedX = y + vectors[i][1];\\n        int reflectedY = x + vectors[i][0];\\n\\n        if (reflectedX * reflectedX + reflectedY * reflectedY > d * d) {\\n            antonWins = true;\\n            break;\\n        }\\n    }\\n\\n    if (antonWins) {\\n        printf(\\\"Anton\\\");\\n    } else {\\n        printf(\\\"Dasha\\\");\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace DotGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read input\n            string[] input = Console.ReadLine().Split();\n            int x = int.Parse(input[0]);\n            int y = int.Parse(input[1]);\n            int n = int.Parse(input[2]);\n            int d = int.Parse(input[3]);\n\n            \/\/ Initialize vectors\n            List<Tuple<int, int>> vectors = new List<Tuple<int, int>>();\n            for (int i = 0; i < n; i++)\n            {\n                input = Console.ReadLine().Split();\n                int xi = int.Parse(input[0]);\n                int yi = int.Parse(input[1]);\n                vectors.Add(new Tuple<int, int>(xi, yi));\n            }\n\n            \/\/ Check if Anton wins\n            bool antonWins = CheckWin(x, y, d, vectors, true);\n\n            \/\/ Print the winner\n            if (antonWins)\n            {\n                Console.WriteLine(\\\"Anton\\\");\n            }\n            else\n            {\n                Console.WriteLine(\\\"Dasha\\\");\n            }\n        }\n\n        static bool CheckWin(int x, int y, int d, List<Tuple<int, int>> vectors, bool antonTurn)\n        {\n            \/\/ Base case: distance exceeds d\n            if (Math.Sqrt(x * x + y * y) > d)\n            {\n                return !antonTurn;\n            }\n\n            \/\/ Recursive case: try all possible moves\n            foreach (var vector in vectors)\n            {\n                int newX = x + vector.Item1;\n                int newY = y + vector.Item2;\n\n                \/\/ Reflect the dot\n                int reflectedX = newY;\n                int reflectedY = newX;\n\n                \/\/ Check if the opponent wins after the move\n                bool opponentWins = CheckWin(reflectedX, reflectedY, d, vectors, !antonTurn);\n\n                \/\/ If the opponent wins, current player loses\n                if (opponentWins)\n                {\n                    return !antonTurn;\n                }\n            }\n\n            \/\/ If no move leads to opponent's win, current player wins\n            return antonTurn;\n        }\n    }\n}\n","Ruby":"\ndef distance(x, y)\n  Math.sqrt(x**2 + y**2)\nend\n\ndef dot_game(x, y, n, d, vectors)\n  # Check if the initial dot is already outside the winning distance\n  return 'Dasha' if distance(x, y) > d\n\n  # Iterate through each player's turn\n  players = ['Anton', 'Dasha']\n  current_player = 0\n\n  while true\n    # Check if the dot is outside the winning distance after the current player's move\n    return players[current_player] if distance(x, y) > d\n\n    # Get the current player's available moves\n    available_moves = vectors.clone\n\n    # Add the reflection move if it hasn't been used yet\n    if current_player == 0 && !vectors.include?([-y, -x])\n      available_moves << [-y, -x]\n    elsif current_player == 1 && !vectors.include?([y, x])\n      available_moves << [y, x]\n    end\n\n    # Check if the current player has no available moves\n    return players[1 - current_player] if available_moves.empty?\n\n    # Make the current player's move\n    move = available_moves.sample\n    x += move[0]\n    y += move[1]\n\n    # Switch to the next player\n    current_player = 1 - current_player\n  end\nend\n\n# Parse the input\ninput = gets.chomp.split(' ')\nx = input[0].to_i\ny = input[1].to_i\nn = input[2].to_i\nd = input[3].to_i\n\nvectors = []\nn.times do\n  vector = gets.chomp.split(' ').map(&:to_i)\n  vectors << vector\nend\n\n# Play the dot game and print the result\nputs dot_game(x, y, n, d, vectors)\n","delphi":"program DotGame;\\n\\nvar\\n  x, y, n, d, i, xi, yi: integer;\\n  vectors: array of array[0..1] of integer;\\n  antonTurn: boolean;\\n\\nbegin\\n  readln(x, y, n, d);\\n  setlength(vectors, n);\\n  for i := 0 to n-1 do\\n  begin\\n    readln(xi, yi);\\n    vectors[i][0] := xi;\\n    vectors[i][1] := yi;\\n  end;\\n\\n  antonTurn := true;\\n\\n  while (x*x + y*y <= d*d) do\\n  begin\\n    if antonTurn then\\n    begin\\n      for i := 0 to n-1 do\\n      begin\\n        x := x + vectors[i][0];\\n        y := y + vectors[i][1];\\n        if (x*x + y*y > d*d) then\\n        begin\\n          writeln('Dasha');\\n          exit;\\n        end;\\n        x := x - vectors[i][0];\\n        y := y - vectors[i][1];\\n      end;\\n      antonTurn := false;\\n    end\\n    else\\n    begin\\n      x := -x;\\n      y := -y;\\n      antonTurn := true;\\n    end;\\n  end;\\n\\n  writeln('Anton');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tx, _ := strconv.Atoi(scan(scanner))\\n\\ty, _ := strconv.Atoi(scan(scanner))\\n\\tn, _ := strconv.Atoi(scan(scanner))\\n\\td, _ := strconv.Atoi(scan(scanner))\\n\\n\\tvectors := make([][]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\txi, _ := strconv.Atoi(scan(scanner))\\n\\t\\tyi, _ := strconv.Atoi(scan(scanner))\\n\\t\\tvectors[i] = []int{xi, yi}\\n\\t}\\n\\n\\twinner := playGame(x, y, d, vectors)\\n\\n\\tfmt.Println(winner)\\n}\\n\\nfunc scan(scanner *bufio.Scanner) string {\\n\\tscanner.Scan()\\n\\treturn scanner.Text()\\n}\\n\\nfunc playGame(x, y, d int, vectors [][]int) string {\\n\\tif x*x+y*y > d*d {\\n\\t\\treturn \\\"Dasha\\\"\\n\\t}\\n\\n\\tfor _, vector := range vectors {\\n\\t\\tnx := x + vector[0]\\n\\t\\tny := y + vector[1]\\n\\n\\t\\tif nx*nx+ny*ny > d*d {\\n\\t\\t\\treturn \\\"Anton\\\"\\n\\t\\t}\\n\\t}\\n\\n\\treturn \\\"Dasha\\\"\\n}","Javascript":"\nfunction dotGame(x, y, n, d, vectors) {\n    let antonTurn = true;\n    let dot = { x: x, y: y };\n    \n    while (true) {\n        let closestDistance = Math.sqrt(dot.x * dot.x + dot.y * dot.y);\n        \n        if (closestDistance > d) {\n            return antonTurn ? 'Dasha' : 'Anton';\n        }\n        \n        let validMoves = [];\n        \n        for (let i = 0; i < n; i++) {\n            let newX = dot.x + vectors[i].x;\n            let newY = dot.y + vectors[i].y;\n            \n            if (Math.sqrt(newX * newX + newY * newY) <= d) {\n                validMoves.push({ x: newX, y: newY });\n            }\n        }\n        \n        if (validMoves.length === 0) {\n            return antonTurn ? 'Anton' : 'Dasha';\n        }\n        \n        let nextMove = validMoves[0];\n        \n        for (let i = 1; i < validMoves.length; i++) {\n            if (validMoves[i].x + validMoves[i].y > nextMove.x + nextMove.y) {\n                nextMove = validMoves[i];\n            }\n        }\n        \n        dot = nextMove;\n        antonTurn = !antonTurn;\n    }\n}\n\n\/\/ Example usage\nlet input = '0 0 2 3\\n1 1\\n1 2\\n';\nlet lines = input.split('\\\\n');\nlet params = lines[0].split(' ');\nlet x = parseInt(params[0]);\nlet y = parseInt(params[1]);\nlet n = parseInt(params[2]);\nlet d = parseInt(params[3]);\nlet vectors = [];\n\nfor (let i = 1; i <= n; i++) {\n    let vectorParams = lines[i].split(' ');\n    let vector = { x: parseInt(vectorParams[0]), y: parseInt(vectorParams[1]) };\n    vectors.push(vector);\n}\n\nlet result = dotGame(x, y, n, d, vectors);\nconsole.log(result);\n","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val x = input[0]\n    val y = input[1]\n    val n = input[2]\n    val d = input[3]\n\n    val vectors = mutableListOf<Pair<Int, Int>>()\n    for (i in 0 until n) {\n        val vector = readLine()!!.split(\" \").map { it.toInt() }\n        vectors.add(Pair(vector[0], vector[1]))\n    }\n\n    val queue: Queue<Pair<Int, Int>> = LinkedList()\n    val visited = mutableSetOf<Pair<Int, Int>>()\n\n    queue.add(Pair(x, y))\n    visited.add(Pair(x, y))\n\n    var antonWins = false\n\n    while (!queue.isEmpty()) {\n        val dot = queue.poll()\n        val distance = Math.sqrt(dot.first.toDouble() * dot.first.toDouble() + dot.second.toDouble() * dot.second.toDouble())\n\n        if (distance > d) {\n            antonWins = true\n            break\n        }\n\n        for (vector in vectors) {\n            val newX = dot.first + vector.first\n            val newY = dot.second + vector.second\n            val newDot = Pair(newX, newY)\n\n            if (!visited.contains(newDot)) {\n                queue.add(newDot)\n                visited.add(newDot)\n            }\n        }\n\n        val reflectedDot = Pair(dot.second, dot.first)\n        if (!visited.contains(reflectedDot)) {\n            queue.add(reflectedDot)\n            visited.add(reflectedDot)\n        }\n    }\n\n    if (antonWins) {\n        println(\"Anton\")\n    } else {\n        println(\"Dasha\")\n    }\n}","PHP":"\n<?php\n\n\/\/ Read input from stdin\n$input = explode(' ', trim(fgets(STDIN)));\n$x = intval($input[0]);\n$y = intval($input[1]);\n$n = intval($input[2]);\n$d = intval($input[3]);\n\n\/\/ Initialize variables\n$winner = 'Anton';\n$turn = 1;\n\n\/\/ Loop through the vectors\nfor ($i = 0; $i < $n; $i++) {\n    $vector = explode(' ', trim(fgets(STDIN)));\n    $xi = intval($vector[0]);\n    $yi = intval($vector[1]);\n\n    \/\/ Calculate the new position after the move\n    $newX = $x + $xi;\n    $newY = $y + $yi;\n\n    \/\/ Check if the new position exceeds the distance limit\n    if (sqrt($newX * $newX + $newY * $newY) > $d) {\n        \/\/ If it does, the current player loses\n        $winner = ($turn % 2 == 1) ? 'Dasha' : 'Anton';\n        break;\n    }\n\n    \/\/ Switch turns\n    $turn++;\n}\n\n\/\/ Print the winner\necho $winner;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.conv;\\r\\n\\r\\nstruct Vector {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isAntonWinner(int x, int y, int d, Vector[] vectors) {\\r\\n    if (x * x + y * y > d * d) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    foreach (vector; vectors) {\\r\\n        int newX = x + vector.x;\\r\\n        int newY = y + vector.y;\\r\\n\\r\\n        if (newX * newX + newY * newY > d * d) {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int x, y, n, d;\\r\\n    Vector[] vectors;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d %d %d\\\", &x, &y, &n, &d);\\r\\n\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        int xi, yi;\\r\\n        scanf(\\\"%d %d\\\", &xi, &yi);\\r\\n        vectors ~= Vector(xi, yi);\\r\\n    }\\r\\n\\r\\n    \/\/ Determine the winner\\r\\n    bool antonWins = isAntonWinner(x, y, d, vectors);\\r\\n\\r\\n    \/\/ Print the result\\r\\n    if (antonWins) {\\r\\n        writeln(\\\"Anton\\\");\\r\\n    } else {\\r\\n        writeln(\\\"Dasha\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub play_game {\n    my ($x, $y, $n, $d, @vectors) = @_;\n\n    my $turn = 0; # 0 for Anton, 1 for Dasha\n\n    while (1) {\n        my $distance = sqrt($x**2 + $y**2);\n        if ($distance > $d) {\n            return $turn == 0 ? 'Dasha' : 'Anton';\n        }\n\n        my $possible_moves = get_possible_moves($x, $y, @vectors);\n\n        if (@$possible_moves == 0) {\n            return $turn == 0 ? 'Anton' : 'Dasha';\n        }\n\n        if ($turn == 0) {\n            ($x, $y) = @$possible_moves[0];\n        } else {\n            my $best_move = find_best_move($x, $y, $d, @$possible_moves);\n            ($x, $y) = @$best_move;\n        }\n\n        $turn = 1 - $turn;\n    }\n}\n\nsub get_possible_moves {\n    my ($x, $y, @vectors) = @_;\n\n    my @possible_moves;\n\n    foreach my $vector (@vectors) {\n        my ($dx, $dy) = @$vector;\n        my $new_x = $x + $dx;\n        my $new_y = $y + $dy;\n        push @possible_moves, [$new_x, $new_y];\n    }\n\n    return \\@possible_moves;\n}\n\nsub find_best_move {\n    my ($x, $y, $d, @possible_moves) = @_;\n\n    my $best_move;\n    my $best_distance = $d;\n\n    foreach my $move (@possible_moves) {\n        my ($new_x, $new_y) = @$move;\n        my $distance = sqrt($new_x**2 + $new_y**2);\n        if ($distance < $best_distance) {\n            $best_move = $move;\n            $best_distance = $distance;\n        }\n    }\n\n    return $best_move;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($x, $y, $n, $d) = split ' ', $input;\n\nmy @vectors;\nfor (my $i = 0; $i < $n; $i++) {\n    my $vector = <STDIN>;\n    chomp $vector;\n    my ($xi, $yi) = split ' ', $vector;\n    push @vectors, [$xi, $yi];\n}\n\n# Play the game\nmy $winner = play_game($x, $y, $n, $d, @vectors);\n\n# Print the winner\nprint $winner;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let params: Vec<i32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let x = params[0];\n    let y = params[1];\n    let n = params[2];\n    let d = params[3];\n    \n    let mut vectors: Vec<(i32, i32)> = Vec::new();\n    for _ in 0..n {\n        let vector: Vec<i32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        vectors.push((vector[0], vector[1]));\n    }\n    \n    let mut anton_wins = false;\n    let mut dasha_wins = false;\n    \n    for vector in vectors {\n        let new_x = x + vector.0;\n        let new_y = y + vector.1;\n        \n        if new_x * new_x + new_y * new_y > d * d {\n            anton_wins = true;\n            break;\n        }\n        \n        let reflected_x = y + vector.1;\n        let reflected_y = x + vector.0;\n        \n        let new_reflected_x = reflected_x + vector.0;\n        let new_reflected_y = reflected_y + vector.1;\n        \n        if new_reflected_x * new_reflected_x + new_reflected_y * new_reflected_y > d * d {\n            anton_wins = true;\n            break;\n        }\n    }\n    \n    if anton_wins {\n        println!(\"Anton\");\n    } else {\n        println!(\"Dasha\");\n    }\n}"}
{"title":"A. Triangle","description":"Johnny has a younger sister Anne, who is very clever and smart. As she came home from the kindergarten, she told his brother about the task that her kindergartener asked her to solve. The task was just to construct a triangle out of four sticks of different colours. Naturally, one of the sticks is extra. It is not allowed to break the sticks or use their partial length. Anne has perfectly solved this task, now she is asking Johnny to do the same.The boy answered that he would cope with it without any difficulty. However, after a while he found out that different tricky things can occur. It can happen that it is impossible to construct a triangle of a positive area, but it is possible to construct a degenerate triangle. It can be so, that it is impossible to construct a degenerate triangle even. As Johnny is very lazy, he does not want to consider such a big amount of cases, he asks you to help him.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"64 megabytes","input_spec":"The first line of the input contains four space-separated positive integer numbers not exceeding 100 \u2014 lengthes of the sticks.\n","output_spec":"Output TRIANGLE if it is possible to construct a non-degenerate triangle. Output SEGMENT if the first case cannot take place and it is possible to construct a degenerate triangle. Output IMPOSSIBLE if it is impossible to construct any triangle. Remember that you are to use three sticks. It is not allowed to break the sticks or use their partial length.\n","notes":null,"sample_inputs":["4 2 1 3\n","7 2 2 4\n","3 5 9 1\n"],"sample_outputs":["TRIANGLE\n","SEGMENT\n","IMPOSSIBLE\n"],"id":"6-A","difficulty":900,"tags":["brute+force","geometry"],"src_uid":"8f5df9a41e6e100aa65b9fc1d26e447a","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int a, b, c, d;\\n    cin >> a >> b >> c >> d;\\n    int arr[4] = {a, b, c, d};\\n    sort(arr, arr+4);\\n    if(arr[0] + arr[1] > arr[2] || arr[1] + arr[2] > arr[3]) {\\n        cout << \\\"TRIANGLE\\\" << endl;\\n    } else if(arr[0] + arr[1] == arr[2] || arr[1] + arr[2] == arr[3]) {\\n        cout << \\\"SEGMENT\\\" << endl;\\n    } else {\\n        cout << \\\"IMPOSSIBLE\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Arrays;\\n\\npublic class TriangleConstruction {\\n\\n    public static void main(String[] args) {\\n        int[] sticks1 = {4, 2, 1, 3};\\n        int[] sticks2 = {7, 2, 2, 4};\\n        int[] sticks3 = {3, 5, 9, 1};\\n\\n        System.out.println(constructTriangle(sticks1)); \/\/ Output: TRIANGLE\\n        System.out.println(constructTriangle(sticks2)); \/\/ Output: SEGMENT\\n        System.out.println(constructTriangle(sticks3)); \/\/ Output: IMPOSSIBLE\\n    }\\n\\n    public static String constructTriangle(int[] sticks) {\\n        Arrays.sort(sticks);\\n\\n        if (sticks[0] + sticks[1] > sticks[3]) {\\n            if (sticks[0] + sticks[1] > sticks[2]) {\\n                return \\\"TRIANGLE\\\";\\n            } else {\\n                return \\\"SEGMENT\\\";\\n            }\\n        } else {\\n            return \\\"IMPOSSIBLE\\\";\\n        }\\n    }\\n}\"}}","Python":"def construct_triangle(sticks):\n    lengths = sorted(list(map(int, sticks.split())))\n    if lengths[0] + lengths[1] > lengths[2] or lengths[1] + lengths[2] > lengths[3]:\n        return 'TRIANGLE'\n    elif lengths[0] + lengths[1] == lengths[2] or lengths[1] + lengths[2] == lengths[3]:\n        return 'SEGMENT'\n    else:\n        return 'IMPOSSIBLE'\n\ninputs = ['4 2 1 3\\n', '7 2 2 4\\n', '3 5 9 1\\n']\noutputs = []\n\nfor i in inputs:\n    result = construct_triangle(i.strip())\n    outputs.append(result + '\\\\n')\n\noutputs\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int a, b, c, d;\\n    scanf(\\\"%d %d %d %d\\\", &a, &b, &c, &d);\\n    if ((a + b > c && a + c > b && b + c > a) || (a + b > d && a + d > b && b + d > a) || (a + c > d && a + d > c && c + d > a) || (b + c > d && b + d > c && c + d > b)) {\\n        printf(\\\"TRIANGLE\\\\n\\\");\\n    } else if ((a + b == c || a + c == b || b + c == a) || (a + b == d || a + d == b || b + d == a) || (a + c == d || a + d == c || c + d == a) || (b + c == d || b + d == c || c + d == b)) {\\n        printf(\\\"SEGMENT\\\\n\\\");\\n    } else {\\n        printf(\\\"IMPOSSIBLE\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] inputs = { \\\"4 2 1 3\\\", \\\"7 2 2 4\\\", \\\"3 5 9 1\\\" };\n        string[] expectedOutputs = { \\\"TRIANGLE\\\", \\\"SEGMENT\\\", \\\"IMPOSSIBLE\\\" };\n        \n        for (int i = 0; i < inputs.Length; i++)\n        {\n            string input = inputs[i];\n            string expectedOutput = expectedOutputs[i];\n            \n            string actualOutput = ConstructTriangle(input);\n            \n            Console.WriteLine(actualOutput == expectedOutput ? \\\"Test case passed\\\" : \\\"Test case failed\\\");\n        }\n    }\n    \n    public static string ConstructTriangle(string input)\n    {\n        string[] lengths = input.Split(' ');\n        int[] sticks = new int[4];\n        \n        for (int i = 0; i < 4; i++)\n        {\n            sticks[i] = int.Parse(lengths[i]);\n        }\n        \n        Array.Sort(sticks);\n        \n        if (sticks[0] + sticks[1] > sticks[3] || sticks[1] + sticks[2] > sticks[3])\n        {\n            return \\\"TRIANGLE\\\";\n        }\n        else if (sticks[0] + sticks[1] == sticks[3] || sticks[1] + sticks[2] == sticks[3])\n        {\n            return \\\"SEGMENT\\\";\n        }\n        else\n        {\n            return \\\"IMPOSSIBLE\\\";\n        }\n    }\n}","Ruby":"\ndef triangle_or_segment(arr)\n  sticks = arr.split.map(&:to_i).sort\n  if sticks[0] + sticks[1] > sticks[2] || sticks[1] + sticks[2] > sticks[3]\n    return 'TRIANGLE'\n  elsif sticks[0] + sticks[1] == sticks[2] || sticks[1] + sticks[2] == sticks[3]\n    return 'SEGMENT'\n  else\n    return 'IMPOSSIBLE'\n  end\nend\n\ninputs = ['4 2 1 3\\n', '7 2 2 4\\n', '3 5 9 1\\n']\noutputs = []\n\ninputs.each do |input|\n  outputs << triangle_or_segment(input)\nend\n\nputs outputs\n","delphi":"program TriangleConstruction;\\n\\nvar\\n  a, b, c, d: Integer;\\n\\nbegin\\n  Readln(a, b, c, d);\\n  if (a + b > c) and (a + c > b) and (b + c > a) then\\n    Writeln('TRIANGLE')\\n  else if (a + b = c) or (a + c = b) or (b + c = a) then\\n    Writeln('SEGMENT')\\n  else\\n    Writeln('IMPOSSIBLE');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar a, b, c, d int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &a, &b, &c, &d)\\n\\n\\tsticks := []int{a, b, c, d}\\n\\tsort.Ints(sticks)\\n\\n\\tif sticks[0]+sticks[1] > sticks[2] || sticks[1]+sticks[2] > sticks[3] {\\n\\t\\tfmt.Println(\\\"TRIANGLE\\\")\\n\\t} else if sticks[0]+sticks[1] == sticks[2] || sticks[1]+sticks[2] == sticks[3] {\\n\\t\\tfmt.Println(\\\"SEGMENT\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"IMPOSSIBLE\\\")\\n\\t}\\n}","Javascript":"function constructTriangle(sticks) {\n  \/\/ Convert the input string into an array of integers\n  const lengths = sticks.split(' ').map(Number);\n\n  \/\/ Sort the lengths in ascending order\n  lengths.sort((a, b) => a - b);\n\n  \/\/ Check if it is impossible to construct any triangle\n  if (lengths[0] + lengths[1] <= lengths[2] || lengths[1] + lengths[2] <= lengths[3]) {\n    return 'IMPOSSIBLE';\n  }\n\n  \/\/ Check if it is possible to construct a degenerate triangle\n  if (lengths[0] + lengths[1] === lengths[2] || lengths[1] + lengths[2] === lengths[3]) {\n    return 'SEGMENT';\n  }\n\n  \/\/ If none of the above conditions are met, it is possible to construct a non-degenerate triangle\n  return 'TRIANGLE';\n}\n\n\/\/ Test cases\nconst inputs = ['4 2 1 3\\n', '7 2 2 4\\n', '3 5 9 1\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const result = constructTriangle(inputs[i]);\n  outputs.push(result + '\\\\n');\n}\n\noutputs;","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val sortedInput = input.sorted()\n\n    if (sortedInput[0] + sortedInput[1] > sortedInput[2] || sortedInput[1] + sortedInput[2] > sortedInput[3]) {\n        println(\\\"TRIANGLE\\\")\n    } else if (sortedInput[0] + sortedInput[1] == sortedInput[2] || sortedInput[1] + sortedInput[2] == sortedInput[3]) {\n        println(\\\"SEGMENT\\\")\n    } else {\n        println(\\\"IMPOSSIBLE\\\")\n    }\n}","PHP":"<?php\\n\\nfunction constructTriangle($sticks) {\\n    $lengths = explode(' ', $sticks);\\n    sort($lengths);\\n    \\n    if ($lengths[0] + $lengths[1] > $lengths[2]) {\\n        return 'TRIANGLE';\\n    } elseif ($lengths[0] + $lengths[1] == $lengths[2]) {\\n        return 'SEGMENT';\\n    } else {\\n        return 'IMPOSSIBLE';\\n    }\\n}\\n\\n$input = ['4 2 1 3', '7 2 2 4', '3 5 9 1'];\\n$output = [];\\n\\nforeach ($input as $sticks) {\\n    $result = constructTriangle($sticks);\\n    $output[] = $result . \\\"\\\\n\\\";\\n}\\n\\necho json_encode($output);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring solveTriangle(string input)\\r\\n{\\r\\n    auto lengths = input.split();\\r\\n    lengths.sort();\\r\\n\\r\\n    int a = to!int(lengths[0]);\\r\\n    int b = to!int(lengths[1]);\\r\\n    int c = to!int(lengths[2]);\\r\\n    int d = to!int(lengths[3]);\\r\\n\\r\\n    if (a + b > c || b + c > d)\\r\\n    {\\r\\n        return \\\"TRIANGLE\\\";\\r\\n    }\\r\\n    else if (a + b == c || b + c == d)\\r\\n    {\\r\\n        return \\\"SEGMENT\\\";\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return \\\"IMPOSSIBLE\\\";\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\r\\n        \\\"4 2 1 3\\\",\\r\\n        \\\"7 2 2 4\\\",\\r\\n        \\\"3 5 9 1\\\"\\r\\n    ];\\r\\n\\r\\n    string[] expectedOutputs = [\\r\\n        \\\"TRIANGLE\\\",\\r\\n        \\\"SEGMENT\\\",\\r\\n        \\\"IMPOSSIBLE\\\"\\r\\n    ];\\r\\n\\r\\n    foreach (i, input; inputs)\\r\\n    {\\r\\n        string expectedOutput = expectedOutputs[i];\\r\\n        string output = solveTriangle(input);\\r\\n\\r\\n        assert(output == expectedOutput, \\\"Test case \\$(i+1) failed. Expected: \\$(expectedOutput), Got: \\$(output)\\\");\\r\\n    }\\r\\n\\r\\n    writeln(\\\"All test cases passed!\\\");\\r\\n}","perl":"\n#!\/usr\/bin\/perl\n\nuse strict;\nuse warnings;\n\nsub construct_triangle {\n    my ($a, $b, $c, $d) = @_;\n\n    # Check if it is possible to construct a non-degenerate triangle\n    if (($a + $b > $c) && ($a + $c > $b) && ($b + $c > $a)) {\n        return 'TRIANGLE';\n    }\n\n    # Check if it is possible to construct a degenerate triangle\n    if (($a + $b == $c) || ($a + $c == $b) || ($b + $c == $a)) {\n        return 'SEGMENT';\n    }\n\n    # It is impossible to construct any triangle\n    return 'IMPOSSIBLE';\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\n# Split the input into four stick lengths\nmy ($stick1, $stick2, $stick3, $stick4) = split(' ', $input);\n\n# Call the construct_triangle function with the stick lengths\nmy $result = construct_triangle($stick1, $stick2, $stick3, $stick4);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\n    let input = vec![\n        (4, 2, 1, 3),\n        (7, 2, 2, 4),\n        (3, 5, 9, 1),\n    ];\n\n    for (a, b, c, d) in input {\n        let mut sticks = vec![a, b, c, d];\n        sticks.sort();\n\n        if sticks[0] + sticks[1] > sticks[2] || sticks[1] + sticks[2] > sticks[3] {\n            println!(\"TRIANGLE\");\n        } else if sticks[0] + sticks[1] == sticks[2] || sticks[1] + sticks[2] == sticks[3] {\n            println!(\"SEGMENT\");\n        } else {\n            println!(\"IMPOSSIBLE\");\n        }\n    }\n}"}
{"title":"E. Exposition","description":"There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than k millimeters.The library has n volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is hi. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","input_from":"standard input","output_to":"standard output","time_limit":"1.5 seconds","memory_limit":"64 megabytes","input_spec":"The first line of the input data contains two integer numbers separated by a space n (1\u2264n\u226410^5) and k (0\u2264k\u226410^6) \u2014 the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains n integer numbers separated by a space. Each number hi (1\u2264hi\u226410^6) is the height of the i-th book in millimeters.\n","output_spec":"In the first line of the output data print two numbers a and b (separate them by a space), where a is the maximum amount of books the organizers can include into the exposition, and b \u2014 the amount of the time periods, during which Berlbury published a books, and the height difference between the lowest and the highest among these books is not more than k milllimeters.\nIn each of the following b lines print two integer numbers separated by a space \u2014 indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.\n","notes":null,"sample_inputs":["3 3\n14 12 10\n","2 0\n10 10\n","4 5\n8 19 10 13\n"],"sample_outputs":["2 2\n1 2\n2 3\n","2 1\n1 2\n","2 1\n3 4\n"],"id":"6-E","difficulty":1900,"tags":["binary+search","data+structures","dsu","trees","two+pointers"],"src_uid":"bc8b4b74c2f2d486e2d2f03982ef1013","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<int> heights(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> heights[i];\\n    }\\n\\n    int maxBooks = 0;\\n    int periods = 0;\\n    int start = 0;\\n    int end = 0;\\n    int maxDiff = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (heights[i] - heights[start] > k) {\\n            if (i - start > maxBooks) {\\n                maxBooks = i - start;\\n                periods = 1;\\n                end = i - 1;\\n                maxDiff = heights[end] - heights[start];\\n            } else if (i - start == maxBooks && heights[i - 1] - heights[start] > maxDiff) {\\n                end = i - 1;\\n                maxDiff = heights[end] - heights[start];\\n            }\\n            start = i;\\n        }\\n    }\\n\\n    if (n - start > maxBooks) {\\n        maxBooks = n - start;\\n        periods = 1;\\n        end = n - 1;\\n        maxDiff = heights[end] - heights[start];\\n    } else if (n - start == maxBooks && heights[n - 1] - heights[start] > maxDiff) {\\n        end = n - 1;\\n        maxDiff = heights[end] - heights[start];\\n    }\\n\\n    cout << maxBooks << \\\" \\\" << periods << endl;\\n    for (int i = 0; i < periods; i++) {\\n        cout << start + 1 << \\\" \\\" << end + 1 << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class BerlburyExposition {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int[] heights = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            heights[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        List<Integer> startIndices = new ArrayList<>();\\n        List<Integer> endIndices = new ArrayList<>();\\n\\n        int maxBooks = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n        int maxHeight = heights[0];\\n        int minHeight = heights[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (Math.abs(heights[i] - maxHeight) <= k && Math.abs(heights[i] - minHeight) <= k) {\\n                endIndex = i;\\n            } else {\\n                startIndices.add(startIndex);\\n                endIndices.add(endIndex);\\n                maxBooks = Math.max(maxBooks, endIndex - startIndex + 1);\\n                startIndex = i;\\n                endIndex = i;\\n                maxHeight = heights[i];\\n                minHeight = heights[i];\\n            }\\n            maxHeight = Math.max(maxHeight, heights[i]);\\n            minHeight = Math.min(minHeight, heights[i]);\\n        }\\n\\n        startIndices.add(startIndex);\\n        endIndices.add(endIndex);\\n        maxBooks = Math.max(maxBooks, endIndex - startIndex + 1);\\n\\n        System.out.println(maxBooks + \\\" \\\" + startIndices.size());\\n        for (int i = 0; i < startIndices.size(); i++) {\\n            System.out.println((startIndices.get(i) + 1) + \\\" \\\" + (endIndices.get(i) + 1));\\n        }\\n    }\\n}","Python":"def find_exposition(n, k, heights):\n    max_books = 0\n    periods = []\n    start = 0\n    end = 0\n    current_books = 0\n    min_height = heights[0]\n    max_height = heights[0]\n    \n    for i in range(1, n):\n        if abs(heights[i] - min_height) <= k and abs(heights[i] - max_height) <= k:\n            current_books += 1\n            end = i\n            max_height = max(max_height, heights[i])\n            min_height = min(min_height, heights[i])\n        else:\n            if current_books > max_books:\n                max_books = current_books\n                periods = [(start, end)]\n            elif current_books == max_books:\n                periods.append((start, end))\n            \n            start = i\n            end = i\n            current_books = 0\n            min_height = heights[i]\n            max_height = heights[i]\n    \n    if current_books > max_books:\n        max_books = current_books\n        periods = [(start, end)]\n    elif current_books == max_books:\n        periods.append((start, end))\n    \n    output = str(max_books) + ' ' + str(len(periods)) + '\\\\n'\n    for period in periods:\n        output += str(period[0] + 1) + ' ' + str(period[1] + 1) + '\\\\n'\n    \n    return output\n\n# Read input\ninput_data = input().split('\\\\n')\nn, k = map(int, input_data[0].split())\nheights = list(map(int, input_data[1].split()))\n\n# Call the function and print the result\nprint(find_exposition(n, k, heights))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int heights[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &heights[i]);\\n    }\\n\\n    int max_books = 0;\\n    int periods = 0;\\n    int start = 0;\\n    int end = 0;\\n    int max_start = 0;\\n    int max_end = 0;\\n    int diff = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (i == 0) {\\n            start = 0;\\n            end = 0;\\n            diff = 0;\\n        } else {\\n            if (heights[i] - heights[i-1] <= k) {\\n                end = i;\\n                diff = heights[end] - heights[start];\\n            } else {\\n                start = i;\\n                end = i;\\n                diff = 0;\\n            }\\n        }\\n\\n        if (diff <= k && (end - start + 1) > max_books) {\\n            max_books = end - start + 1;\\n            max_start = start;\\n            max_end = end;\\n            periods = 1;\\n        } else if (diff <= k && (end - start + 1) == max_books) {\\n            periods++;\\n        }\\n    }\\n\\n    printf(\\\"%d %d\\\\n\\\", max_books, periods);\\n    for (int i = 0; i < periods; i++) {\\n        printf(\\\"%d %d\\\\n\\\", max_start + 1, max_end + 1);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace BerlburyExposition\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int k = int.Parse(input[1]);\n\n            int[] heights = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            int maxBooks = 0;\n            List<Tuple<int, int>> periods = new List<Tuple<int, int>>();\n\n            int start = 0;\n            int end = 0;\n            int min = heights[0];\n            int max = heights[0];\n\n            for (int i = 1; i < n; i++)\n            {\n                if (Math.Abs(heights[i] - min) <= k && Math.Abs(heights[i] - max) <= k)\n                {\n                    end = i;\n                    max = Math.Max(max, heights[i]);\n                    min = Math.Min(min, heights[i]);\n                }\n                else\n                {\n                    if (end - start + 1 > maxBooks)\n                    {\n                        maxBooks = end - start + 1;\n                        periods.Clear();\n                        periods.Add(new Tuple<int, int>(start, end));\n                    }\n                    else if (end - start + 1 == maxBooks)\n                    {\n                        periods.Add(new Tuple<int, int>(start, end));\n                    }\n\n                    start = i;\n                    end = i;\n                    min = heights[i];\n                    max = heights[i];\n                }\n            }\n\n            if (end - start + 1 > maxBooks)\n            {\n                maxBooks = end - start + 1;\n                periods.Clear();\n                periods.Add(new Tuple<int, int>(start, end));\n            }\n            else if (end - start + 1 == maxBooks)\n            {\n                periods.Add(new Tuple<int, int>(start, end));\n            }\n\n            Console.WriteLine($\"{maxBooks} {periods.Count}\");\n            foreach (var period in periods)\n            {\n                Console.WriteLine($\"{period.Item1 + 1} {period.Item2 + 1}\");\n            }\n        }\n    }\n}","Ruby":"def find_exposition(n, k, heights)\n  max_books = 0\n  periods = []\n  \n  start = 0\n  end = 0\n  min_height = heights[0]\n  max_height = heights[0]\n  \n  while end < n\n    if max_height - min_height <= k\n      if end - start + 1 > max_books\n        max_books = end - start + 1\n        periods = [[start, end]]\n      elsif end - start + 1 == max_books\n        periods << [start, end]\n      end\n      \n      end += 1\n      if end < n\n        min_height = [min_height, heights[end]].min\n        max_height = [max_height, heights[end]].max\n      end\n    else\n      start += 1\n      if start > end\n        end += 1\n        if end < n\n          min_height = [min_height, heights[end]].min\n          max_height = [max_height, heights[end]].max\n        end\n      else\n        min_height = heights[start]\n        max_height = heights[start]\n        (start+1..end).each do |i|\n          min_height = [min_height, heights[i]].min\n          max_height = [max_height, heights[i]].max\n        end\n      end\n    end\n  end\n  \n  result = \"#{max_books} #{periods.size}\\n\"\n  periods.each do |period|\n    result += \"#{period[0]+1} #{period[1]+1}\\n\"\n  end\n  \n  result\nend\n\ninputs = [['3 3\\n14 12 10\\n'], ['2 0\\n10 10\\n'], ['4 5\\n8 19 10 13\\n']]\noutputs = [['2 2\\n1 2\\n2 3\\n'], ['2 1\\n1 2\\n'], ['2 1\\n3 4\\n']]\n\ninputs.each_with_index do |input, index|\n  n, k, *heights = input[0].split.map(&:to_i)\n  output = find_exposition(n, k, heights)\n  \n  puts \"Input: #{input[0]}\"\n  puts \"Expected Output: #{outputs[index][0]}\"\n  puts \"Actual Output: #{output}\"\n  puts \"-----------------------------------\"\nend","delphi":"Here is a possible implementation in Delphi 7:\\n\\n```delphi\\nprogram BerlburyExposition;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nvar\\n  n, k, i, j, a, b, maxBooks, startIdx, endIdx: Integer;\\n  heights: array of Integer;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(n, k);\\n  SetLength(heights, n);\\n  for i := 0 to n - 1 do\\n    Read(heights[i]);\\n\\n  \/\/ Initialize variables\\n  maxBooks := 0;\\n  a := 0;\\n  b := 0;\\n  startIdx := 0;\\n  endIdx := 0;\\n\\n  \/\/ Find the maximum amount of books and the time periods\\n  for i := 0 to n - 1 do\\n  begin\\n    if (heights[i] - heights[startIdx] > k) or (heights[endIdx] - heights[i] > k) then\\n    begin\\n      if (i - startIdx) > maxBooks then\\n      begin\\n        maxBooks := i - startIdx;\\n        a := maxBooks;\\n        b := 1;\\n      end;\\n      startIdx := i;\\n      endIdx := i;\\n    end\\n    else\\n      endIdx := i;\\n  end;\\n\\n  \/\/ Check if the last time period is the longest\\n  if (n - startIdx) > maxBooks then\\n  begin\\n    maxBooks := n - startIdx;\\n    a := maxBooks;\\n    b := 1;\\n  end;\\n\\n  \/\/ Print the output\\n  WriteLn(a, ' ', b);\\n  for i := 0 to b - 1 do\\n    WriteLn(startIdx + 1, ' ', endIdx + 1);\\nend.\\n```\\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\n\\theights := make([]int, n)\\n\\tinput := make([]string, n)\\n\\n\\tfmt.Scanf(\\\"%s\\\", &input)\\n\\n\\tfor i, v := range input {\\n\\t\\theights[i], _ = strconv.Atoi(v)\\n\\t}\\n\\n\\tmaxBooks, periods := findExposition(heights, k)\\n\\n\\toutput := fmt.Sprintf(\\\"%d %d\\\\n\\\", maxBooks, len(periods))\\n\\n\\tfor _, period := range periods {\\n\\t\\toutput += fmt.Sprintf(\\\"%d %d\\\\n\\\", period[0]+1, period[1]+1)\\n\\t}\\n\\n\\tfmt.Println(output)\\n}\\n\\nfunc findExposition(heights []int, k int) (int, [][]int) {\\n\\tmaxBooks := 0\\n\\tperiods := [][]int{}\\n\\n\\tstart := 0\\n\\tend := 0\\n\\n\\tfor i := 1; i < len(heights); i++ {\\n\\t\\tif heights[i]-heights[start] > k {\\n\\t\\t\\tif i-start > maxBooks {\\n\\t\\t\\t\\tmaxBooks = i - start\\n\\t\\t\\t\\tperiods = [][]int{{start, i - 1}}\\n\\t\\t\\t} else if i-start == maxBooks {\\n\\t\\t\\t\\tperiods = append(periods, []int{start, i - 1})\\n\\t\\t\\t}\\n\\n\\t\\t\\tstart = i\\n\\t\\t\\tend = i\\n\\t\\t} else {\\n\\t\\t\\tend = i\\n\\t\\t}\\n\\t}\\n\\n\\tif end-start+1 > maxBooks {\\n\\t\\tmaxBooks = end - start + 1\\n\\t\\tperiods = [][]int{{start, end}}\\n\\t} else if end-start+1 == maxBooks {\\n\\t\\tperiods = append(periods, []int{start, end})\\n\\t}\\n\\n\\treturn maxBooks, periods\\n}","Javascript":"function findExposition(n, k, heights) {\n  let maxBooks = 0;\n  let periods = [];\n  \n  let start = 0;\n  let end = 0;\n  let currentBooks = 0;\n  let minHeight = heights[0];\n  let maxHeight = heights[0];\n  \n  while (end < n) {\n    if (Math.abs(maxHeight - minHeight) <= k) {\n      currentBooks++;\n      if (currentBooks > maxBooks) {\n        maxBooks = currentBooks;\n        periods = [[start, end]];\n      } else if (currentBooks === maxBooks) {\n        periods.push([start, end]);\n      }\n      end++;\n      if (end < n) {\n        minHeight = Math.min(minHeight, heights[end]);\n        maxHeight = Math.max(maxHeight, heights[end]);\n      }\n    } else {\n      currentBooks--;\n      start++;\n      if (start > end) {\n        end++;\n        if (end < n) {\n          minHeight = Math.min(minHeight, heights[end]);\n          maxHeight = Math.max(maxHeight, heights[end]);\n        }\n      } else {\n        minHeight = Math.min(minHeight, heights[start]);\n        maxHeight = Math.max(maxHeight, heights[start]);\n      }\n    }\n  }\n  \n  let output = maxBooks + \" \" + periods.length + \"\\n\";\n  for (let i = 0; i < periods.length; i++) {\n    output += (periods[i][0] + 1) + \" \" + (periods[i][1] + 1) + \"\\n\";\n  }\n  \n  return output.trim();\n}\n\nlet inputs = ['3 3\\n14 12 10\\n', '2 0\\n10 10\\n', '4 5\\n8 19 10 13\\n'];\nlet outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  let lines = inputs[i].split('\\\\n');\n  let params = lines[0].split(' ');\n  let n = parseInt(params[0]);\n  let k = parseInt(params[1]);\n  let heights = lines[1].split(' ').map(Number);\n  \n  let result = findExposition(n, k, heights);\n  outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val k = scanner.nextInt()\n    val heights = IntArray(n)\n    for (i in 0 until n) {\n        heights[i] = scanner.nextInt()\n    }\n    \n    var maxBooks = 0\n    var periods = 0\n    var start = 0\n    var end = 0\n    var currentBooks = 0\n    var currentMin = heights[0]\n    var currentMax = heights[0]\n    \n    for (i in 1 until n) {\n        if (Math.abs(heights[i] - currentMin) <= k && Math.abs(heights[i] - currentMax) <= k) {\n            currentBooks++\n            currentMin = Math.min(currentMin, heights[i])\n            currentMax = Math.max(currentMax, heights[i])\n            end = i\n        } else {\n            if (currentBooks > maxBooks) {\n                maxBooks = currentBooks\n                periods = 1\n                start = i - currentBooks\n            } else if (currentBooks == maxBooks) {\n                periods++\n            }\n            currentBooks = 0\n            currentMin = heights[i]\n            currentMax = heights[i]\n        }\n    }\n    \n    if (currentBooks > maxBooks) {\n        maxBooks = currentBooks\n        periods = 1\n        start = n - currentBooks\n    } else if (currentBooks == maxBooks) {\n        periods++\n    }\n    \n    println(\"$maxBooks $periods\")\n    for (i in 0 until periods) {\n        println(\"${start + i + 1} ${start + i + maxBooks}\")\n    }\n}","PHP":"<?php\\n\\nfunction findExposition($n, $k, $books) {\\n    $maxBooks = 0;\\n    $periods = [];\\n    $currentPeriod = [];\\n    $minHeight = $books[0];\\n    $maxHeight = $books[0];\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        $currentPeriod[] = $i + 1;\\n        $minHeight = min($minHeight, $books[$i]);\\n        $maxHeight = max($maxHeight, $books[$i]);\\n\\n        if ($maxHeight - $minHeight > $k) {\\n            array_shift($currentPeriod);\\n            $minHeight = $books[$i];\\n            $maxHeight = $books[$i];\\n        }\\n\\n        if (count($currentPeriod) > $maxBooks) {\\n            $maxBooks = count($currentPeriod);\\n            $periods = [$currentPeriod];\\n        } elseif (count($currentPeriod) == $maxBooks) {\\n            $periods[] = $currentPeriod;\\n        }\\n    }\\n\\n    $output = $maxBooks . ' ' . count($periods) . \\\"\\\\n\\\";\\n\\n    foreach ($periods as $period) {\\n        $output .= $period[0] . ' ' . $period[count($period) - 1] . \\\"\\\\n\\\";\\n    }\\n\\n    return $output;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n[$n, $k] = explode(' ', $input[0]);\\n$books = explode(' ', $input[1]);\\n\\n$output = findExposition($n, $k, $books);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    readf(\\\"%d %d\\\", &n, &k);\\r\\n\\r\\n    int[] heights;\\r\\n    heights.reserve(n);\\r\\n\\r\\n    foreach (_; 0 .. n)\\r\\n    {\\r\\n        int height;\\r\\n        readf(\\\"%d\\\", &height);\\r\\n        heights ~= height;\\r\\n    }\\r\\n\\r\\n    int maxBooks = 0;\\r\\n    int periods = 0;\\r\\n    int start = 0;\\r\\n    int end = 0;\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        int minIndex = heights[i .. $].minElementIndex;\\r\\n        int maxIndex = heights[i .. $].maxElementIndex;\\r\\n\\r\\n        if (heights[maxIndex] - heights[minIndex] <= k)\\r\\n        {\\r\\n            int numBooks = maxIndex - minIndex + 1;\\r\\n\\r\\n            if (numBooks > maxBooks)\\r\\n            {\\r\\n                maxBooks = numBooks;\\r\\n                periods = 1;\\r\\n                start = minIndex;\\r\\n                end = maxIndex;\\r\\n            }\\r\\n            else if (numBooks == maxBooks)\\r\\n            {\\r\\n                periods++;\\r\\n                start = min(start, minIndex);\\r\\n                end = max(end, maxIndex);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxBooks, \\\" \\\", periods);\\r\\n\\r\\n    for (int i = 0; i < periods; i++)\\r\\n    {\\r\\n        writeln(start + 1, \\\" \\\", end + 1);\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_exposition {\\n    my ($n, $k, @heights) = @_;\\n    my $max_books = 0;\\n    my @periods;\\n    my $start = 0;\\n    my $end = 0;\\n    my $max_diff = 0;\\n\\n    for (my $i = 0; $i < $n; $i++) {\\n        if ($heights[$i] - $heights[$start] > $k) {\\n            my $diff = $heights[$end] - $heights[$start];\\n            if ($diff <= $k) {\\n                my $num_books = $end - $start + 1;\\n                if ($num_books > $max_books) {\\n                    $max_books = $num_books;\\n                    @periods = [$start + 1, $end + 1];\\n                }\\n            }\\n            $start = $i;\\n            $end = $i;\\n        } else {\\n            $end = $i;\\n        }\\n    }\\n\\n    my $diff = $heights[$end] - $heights[$start];\\n    if ($diff <= $k) {\\n        my $num_books = $end - $start + 1;\\n        if ($num_books > $max_books) {\\n            $max_books = $num_books;\\n            @periods = [$start + 1, $end + 1];\\n        }\\n    }\\n\\n    return [$max_books, scalar @periods, @periods];\\n}\\n\\n# Example usage\\nmy $input = '3 3\\\\n14 12 10\\\\n';\\nmy ($n, $k, @heights) = split \/\\\\s+\/, $input;\\nmy $result = find_exposition($n, $k, @heights);\\n\\nprint join(' ', @$result);","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut input = input.trim().split_whitespace();\n    let n: usize = input.next().unwrap().parse().unwrap();\n    let k: i32 = input.next().unwrap().parse().unwrap();\n\n    let mut heights = Vec::new();\n    let mut periods = Vec::new();\n\n    input.clear();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let heights_input: Vec<i32> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n\n    let mut start = 0;\n    let mut end = 0;\n    let mut max_books = 0;\n\n    for i in 0..n {\n        if i > 0 && (heights_input[i] - heights_input[i-1]).abs() > k {\n            if end - start + 1 > max_books {\n                max_books = end - start + 1;\n                periods.clear();\n                periods.push((start, end));\n            } else if end - start + 1 == max_books {\n                periods.push((start, end));\n            }\n            start = i;\n        }\n        end = i;\n        heights.push(heights_input[i]);\n    }\n\n    if end - start + 1 > max_books {\n        max_books = end - start + 1;\n        periods.clear();\n        periods.push((start, end));\n    } else if end - start + 1 == max_books {\n        periods.push((start, end));\n    }\n\n    println!(\"{} {}\", max_books, periods.len());\n    for period in periods {\n        println!(\"{} {}\", period.0 + 1, period.1 + 1);\n    }\n}"}
{"title":"B. Connecting Universities","description":"Treeland is a country in which there are n towns connected by n-1 two-way road such that it's possible to get from any town to any other town. In Treeland there are 2k universities which are located in different towns. Recently, the president signed the decree to connect universities by high-speed network.The Ministry of Education understood the decree in its own way and decided that it was enough to connect each university with another one by using a cable. Formally, the decree will be done! To have the maximum sum in the budget, the Ministry decided to divide universities into pairs so that the total length of the required cable will be maximum. In other words, the total distance between universities in k pairs should be as large as possible. Help the Ministry to find the maximum total distance. Of course, each university should be present in only one pair. Consider that all roads have the same length which is equal to 1. ","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input contains two integers n and k (2\u2264n\u2264200000, 1\u2264k\u2264n\/2)\u00a0\u2014 the number of towns in Treeland and the number of university pairs. Consider that towns are numbered from 1 to n. \nThe second line contains 2k distinct integers u1,u2,...,u2k (1\u2264ui\u2264n)\u00a0\u2014 indices of towns in which universities are located. \nThe next n-1 line contains the description of roads. Each line contains the pair of integers xj and yj (1\u2264xj,yj\u2264n), which means that the j-th road connects towns xj and yj. All of them are two-way roads. You can move from any town to any other using only these roads. \n","output_spec":"Print the maximum possible sum of distances in the division of universities into k pairs.\n","notes":"The figure below shows one of possible division into pairs in the first test. If you connect universities number 1 and 6 (marked in red) and universities number 2 and 5 (marked in blue) by using the cable, the total distance will equal 6 which will be the maximum sum in this example. \n \n","sample_inputs":["7 2\n1 5 6 2\n1 3\n3 2\n4 5\n3 7\n4 3\n4 6\n","9 3\n3 2 1 6 5 9\n8 9\n3 2\n2 7\n3 4\n7 6\n4 5\n2 1\n2 8\n"],"sample_outputs":["6\n","9\n"],"id":"700-B","difficulty":1800,"tags":["dfs+and+similar","dp","graphs","trees"],"src_uid":"ca22cf92727a38fbb3c085b9362602db","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <queue>\\nusing namespace std;\\n\\nvector<vector<int>> adj;\\nvector<int> universities;\\nvector<bool> visited;\\n\\nint bfs(int start) {\\n    queue<int> q;\\n    q.push(start);\\n    visited[start] = true;\\n    int totalDistance = 0;\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n\\n        for (int v : adj[u]) {\\n            if (!visited[v]) {\\n                visited[v] = true;\\n                q.push(v);\\n                totalDistance++;\\n            }\\n        }\\n    }\\n\\n    return totalDistance;\\n}\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n\\n    adj.resize(n + 1);\\n    visited.resize(n + 1, false);\\n\\n    for (int i = 0; i < 2 * k; i++) {\\n        int u;\\n        cin >> u;\\n        universities.push_back(u);\\n    }\\n\\n    for (int i = 0; i < n - 1; i++) {\\n        int x, y;\\n        cin >> x >> y;\\n        adj[x].push_back(y);\\n        adj[y].push_back(x);\\n    }\\n\\n    int maxDistance = 0;\\n\\n    for (int u : universities) {\\n        maxDistance = max(maxDistance, bfs(u));\\n    }\\n\\n    cout << maxDistance << endl;\\n\\n    return 0;\\n}","Java":"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    static List<Integer>[] graph;\\n    static boolean[] visited;\\n    static int[] universities;\\n    static int maxDistance;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n\\n        graph = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n        universities = new int[2 * k];\\n\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < 2 * k; i++) {\\n            universities[i] = scanner.nextInt();\\n        }\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            int x = scanner.nextInt();\\n            int y = scanner.nextInt();\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n\\n        dfs(universities[0], 0);\\n\\n        System.out.println(maxDistance);\\n    }\\n\\n    public static int dfs(int node, int distance) {\\n        visited[node] = true;\\n\\n        int totalDistance = 0;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!visited[neighbor]) {\\n                totalDistance += dfs(neighbor, distance + 1);\\n            }\\n        }\\n\\n        if (containsUniversity(node)) {\\n            totalDistance = 0;\\n        }\\n\\n        maxDistance = Math.max(maxDistance, totalDistance);\\n\\n        return totalDistance + 1;\\n    }\\n\\n    public static boolean containsUniversity(int node) {\\n        for (int university : universities) {\\n            if (university == node) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    static List<Integer>[] graph;\\n    static boolean[] visited;\\n    static int[] universities;\\n    static int maxDistance;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n\\n        graph = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n        universities = new int[2 * k];\\n\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n\\n        for (int i = 0; i < 2 * k; i++) {\\n            universities[i] = scanner.nextInt();\\n        }\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            int x = scanner.nextInt();\\n            int y = scanner.nextInt();\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n\\n        dfs(universities[0], 0);\\n\\n        System.out.println(maxDistance);\\n    }\\n\\n    public static int dfs(int node, int distance) {\\n        visited[node] = true;\\n\\n        int totalDistance = 0;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!visited[neighbor]) {\\n                totalDistance += dfs(neighbor, distance + 1);\\n            }\\n        }\\n\\n        if (containsUniversity(node)) {\\n            totalDistance = 0;\\n        }\\n\\n        maxDistance = Math.max(maxDistance, totalDistance);\\n\\n        return totalDistance + 1;\\n    }\\n\\n    public static boolean containsUniversity(int node) {\\n        for (int university : universities) {\\n            if (university == node) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    static List<Integer>[] graph;\\n    static boolean[] visited;\\n    static int[] universities;\\n    static int maxDistance;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n\\n        graph = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n        universities = new int[2 * k];\\n\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n\\n        for (int i = 0; i < 2 * k; i++) {\\n            universities[i] = scanner.nextInt();\\n        }\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            int x = scanner.nextInt();\\n            int y = scanner.nextInt();\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n\\n        dfs(universities[0], 0);\\n\\n        System.out.println(maxDistance);\\n    }\\n\\n    public static int dfs(int node, int distance) {\\n        visited[node] = true;\\n\\n        int totalDistance = 0;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!visited[neighbor]) {\\n                totalDistance += dfs(neighbor, distance + 1);\\n            }\\n        }\\n\\n        if (containsUniversity(node)) {\\n            totalDistance = 0;\\n        }\\n\\n        maxDistance = Math.max(maxDistance, totalDistance);\\n\\n        return totalDistance + 1;\\n    }\\n\\n    public static boolean containsUniversity(int node) {\\n        for (int university : universities) {\\n            if (university == node) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    static List<Integer>[] graph;\\n    static boolean[] visited;\\n    static int[] universities;\\n    static int maxDistance;\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n\\n        graph = new ArrayList[n + 1];\\n        visited = new boolean[n + 1];\\n        universities = new int[2 * k];\\n\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < 2 * k; i++) {\\n            universities[i] = scanner.nextInt();\\n        }\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            int x = scanner.nextInt();\\n            int y = scanner.nextInt();\\n            graph[x].add(y);\\n            graph[y].add(x);\\n        }\\n\\n        dfs(universities[0], 0);\\n\\n        System.out.println(maxDistance);\\n    }\\n\\n    public static int dfs(int node, int distance) {\\n        visited[node] = true;\\n\\n        int totalDistance = 0;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!visited[neighbor]) {\\n                totalDistance += dfs(neighbor, distance + 1);\\n            }\\n        }\\n\\n        if (containsUniversity(node)) {\\n            totalDistance = 0;\\n        }\\n\\n        maxDistance = Math.max(maxDistance, totalDistance);\\n\\n        return totalDistance + 1;\\n    }\\n\\n    public static boolean containsUniversity(int node) {\\n        for (int university : universities) {\\n            if (university == node) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}","Python":"from collections import defaultdict\\n\\ndef dfs(node, parent, graph, universities):\\n    count = 0\\n    for neighbor in graph[node]:\\n        if neighbor != parent:\\n            count += dfs(neighbor, node, graph, universities)\\n    if node in universities:\\n        count += 1\\n    return count\\n\\n\\ndef solve(n, k, universities, roads):\\n    graph = defaultdict(list)\\n    for road in roads:\\n        x, y = road\\n        graph[x].append(y)\\n        graph[y].append(x)\\n    return dfs(1, -1, graph, universities) - k\\n\\n\\n# Sample Inputs\\ninputs = ['7 2\\\\n1 5 6 2\\\\n1 3\\\\n3 2\\\\n4 5\\\\n3 7\\\\n4 3\\\\n4 6\\\\n', '9 3\\\\n3 2 1 6 5 9\\\\n8 9\\\\n3 2\\\\n2 7\\\\n3 4\\\\n7 6\\\\n4 5\\\\n2 1\\\\n2 8\\\\n']\\n\\nfor input_str in inputs:\\n    input_lines = input_str.strip().split('\\\\n')\\n    n, k = map(int, input_lines[0].split())\\n    universities = set(map(int, input_lines[1].split()))\\n    roads = [list(map(int, line.split())) for line in input_lines[2:]]\\n    \\n    # Call the solve function\\n    result = solve(n, k, universities, roads)\\n    \\n    # Print the result\\n    print(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXN 200005\\n\\nint n, k;\\nint u[MAXN];\\nint deg[MAXN];\\nint dist[MAXN];\\nint ans;\\n\\nstruct edge {\\n    int v, next;\\n} e[MAXN << 1];\\nint head[MAXN], tot;\\n\\nvoid add_edge(int u, int v) {\\n    e[++tot].v = v;\\n    e[tot].next = head[u];\\n    head[u] = tot;\\n}\\n\\nvoid dfs(int u, int fa) {\\n    dist[u] = 0;\\n    for (int i = head[u]; i; i = e[i].next) {\\n        int v = e[i].v;\\n        if (v == fa) continue;\\n        dfs(v, u);\\n        ans += dist[u] < k && dist[v] < k;\\n        dist[u] = dist[u] < dist[v] + 1 ? dist[v] + 1 : dist[u];\\n    }\\n}\\n\\nint main() {\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    for (int i = 1; i <= 2 * k; i++) {\\n        scanf(\\\"%d\\\", &u[i]);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        int u, v;\\n        scanf(\\\"%d %d\\\", &u, &v);\\n        add_edge(u, v);\\n        add_edge(v, u);\\n        deg[u]++, deg[v]++;\\n    }\\n    dfs(1, 0);\\n    printf(\\\"%d\\\\n\\\", ans);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace MaximumDistance\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int k = int.Parse(inputArr[1]);\n\n            input = Console.ReadLine();\n            string[] universitiesArr = input.Split(' ');\n            List<int> universities = new List<int>();\n            foreach (string university in universitiesArr)\n            {\n                universities.Add(int.Parse(university));\n            }\n\n            List<List<int>> graph = new List<List<int>>();\n            for (int i = 0; i <= n; i++)\n            {\n                graph.Add(new List<int>());\n            }\n\n            for (int i = 0; i < n - 1; i++)\n            {\n                input = Console.ReadLine();\n                inputArr = input.Split(' ');\n                int x = int.Parse(inputArr[0]);\n                int y = int.Parse(inputArr[1]);\n\n                graph[x].Add(y);\n                graph[y].Add(x);\n            }\n\n            int[] distances = new int[n + 1];\n            bool[] visited = new bool[n + 1];\n            DFS(graph, distances, visited, 1, 0);\n\n            int maxDistanceSum = 0;\n            for (int i = 1; i <= n; i++)\n            {\n                if (universities.Contains(i))\n                {\n                    maxDistanceSum += distances[i];\n                }\n            }\n\n            Console.WriteLine(maxDistanceSum);\n        }\n\n        static void DFS(List<List<int>> graph, int[] distances, bool[] visited, int node, int distance)\n        {\n            visited[node] = true;\n            distances[node] = distance;\n\n            foreach (int neighbor in graph[node])\n            {\n                if (!visited[neighbor])\n                {\n                    DFS(graph, distances, visited, neighbor, distance + 1);\n                }\n            }\n        }\n    }\n}","Ruby":"\ndef dfs(node, parent, graph, universities)\n    count = 0\n    universities[node] = 1 if universities[node] == 1\n    graph[node].each do |neighbor|\n        next if neighbor == parent\n        count += dfs(neighbor, node, graph, universities)\n        universities[node] += universities[neighbor]\n    end\n    count += [universities[node], graph.length - universities[node]].min * 2\n    return count\nend\n\ndef max_distance(n, k, universities, roads)\n    graph = Array.new(n+1) { [] }\n    universities = Array.new(n+1, 0)\n    roads.each do |road|\n        x, y = road\n        graph[x] << y\n        graph[y] << x\n    end\n    return dfs(1, 0, graph, universities) - k\nend\n\ninput = gets.chomp.split('\\n')\nn, k = input[0].split(' ').map(&:to_i)\nuniversities = input[1].split(' ').map(&:to_i)\nroads = []\n(2..n).each do |i|\n    roads << input[i].split(' ').map(&:to_i)\nend\n\noutput = max_distance(n, k, universities, roads)\nputs output\n","delphi":"program Treeland;\n\nvar\n  n, k, i, j, u, v, maxDist, maxDistIndex: integer;\n  universities: array of integer;\n  roads: array of array of integer;\n  distances: array of integer;\n  visited: array of boolean;\n\nprocedure DFS(node: integer; dist: integer);\nvar\n  i: integer;\nbegin\n  visited[node] := true;\n  distances[node] := dist;\n  \n  for i := 0 to Length(roads[node]) - 1 do\n  begin\n    if not visited[roads[node][i]] then\n      DFS(roads[node][i], dist + 1);\n  end;\nend;\n\nbegin\n  ReadLn(n, k);\n  \n  SetLength(universities, 2 * k);\n  for i := 0 to 2 * k - 1 do\n    Read(universities[i]);\n  \n  SetLength(roads, n + 1);\n  for i := 1 to n - 1 do\n  begin\n    ReadLn(u, v);\n    SetLength(roads[u], Length(roads[u]) + 1);\n    SetLength(roads[v], Length(roads[v]) + 1);\n    roads[u][Length(roads[u]) - 1] := v;\n    roads[v][Length(roads[v]) - 1] := u;\n  end;\n  \n  SetLength(distances, n + 1);\n  SetLength(visited, n + 1);\n  \n  DFS(1, 0);\n  \n  maxDist := 0;\n  maxDistIndex := 0;\n  for i := 1 to n do\n  begin\n    if distances[i] > maxDist then\n    begin\n      maxDist := distances[i];\n      maxDistIndex := i;\n    end;\n  end;\n  \n  FillChar(visited[0], Length(visited) * SizeOf(visited[0]), False);\n  DFS(maxDistIndex, 0);\n  \n  maxDist := 0;\n  for i := 1 to n do\n  begin\n    if distances[i] > maxDist then\n      maxDist := distances[i];\n  end;\n  \n  WriteLn(maxDist);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Split(bufio.ScanWords)\\n\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tk, _ := strconv.Atoi(scanner.Text())\\n\\n\\tuniversities := make(map[int]bool)\\n\\n\\tfor i := 0; i < 2*k; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tuni, _ := strconv.Atoi(scanner.Text())\\n\\t\\tuniversities[uni] = true\\n\\t}\\n\\n\\tadjList := make([][]int, n+1)\\n\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tx, _ := strconv.Atoi(scanner.Text())\\n\\t\\tscanner.Scan()\\n\\t\\ty, _ := strconv.Atoi(scanner.Text())\\n\\n\\t\\tadjList[x] = append(adjList[x], y)\\n\\t\\tadjList[y] = append(adjList[y], x)\\n\\t}\\n\\n\\tvisited := make([]bool, n+1)\\n\\tdistances := make([]int, n+1)\\n\\n\\tvar dfs func(int) int\\n\\tdfs = func(node int) int {\\n\\t\\tvisited[node] = true\\n\\n\\t\\tdistance := 0\\n\\n\\t\\tfor _, neighbor := range adjList[node] {\\n\\t\\t\\tif !visited[neighbor] {\\n\\t\\t\\t\\tdistance += dfs(neighbor)\\n\\t\\t\\t\\tdistances[node] += distances[neighbor]\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif universities[node] {\\n\\t\\t\\tdistances[node]++\\n\\t\\t}\\n\\n\\t\\treturn distance + distances[node]\\n\\t}\\n\\n\\tresult := dfs(1)\\n\\n\\tfmt.Println(result - k)\\n}","Javascript":"\nfunction calculateMaxDistance(n, k, universities, roads) {\n  \/\/ Create an adjacency list to represent the graph\n  const graph = new Array(n + 1).fill(null).map(() => []);\n  \n  \/\/ Populate the adjacency list with the given roads\n  for (let i = 0; i < roads.length; i++) {\n    const [x, y] = roads[i];\n    graph[x].push(y);\n    graph[y].push(x);\n  }\n  \n  \/\/ Create an array to keep track of the distances from each university to all other towns\n  const distances = new Array(n + 1).fill(null).map(() => new Array(n + 1).fill(Infinity));\n  \n  \/\/ Perform BFS from each university to calculate the distances\n  for (let i = 0; i < universities.length; i++) {\n    const university = universities[i];\n    const queue = [university];\n    distances[university][university] = 0;\n    \n    while (queue.length > 0) {\n      const town = queue.shift();\n      \n      for (let j = 0; j < graph[town].length; j++) {\n        const neighbor = graph[town][j];\n        \n        if (distances[university][neighbor] === Infinity) {\n          distances[university][neighbor] = distances[university][town] + 1;\n          queue.push(neighbor);\n        }\n      }\n    }\n  }\n  \n  \/\/ Sort the universities in descending order of their distances to other towns\n  universities.sort((a, b) => {\n    let sumA = 0;\n    let sumB = 0;\n    \n    for (let i = 0; i < universities.length; i++) {\n      sumA += distances[a][universities[i]];\n      sumB += distances[b][universities[i]];\n    }\n    \n    return sumB - sumA;\n  });\n  \n  \/\/ Calculate the maximum sum of distances in the division of universities into k pairs\n  let maxDistance = 0;\n  \n  for (let i = 0; i < k; i++) {\n    const university1 = universities[i * 2];\n    const university2 = universities[i * 2 + 1];\n    maxDistance += distances[university1][university2];\n  }\n  \n  return maxDistance;\n}\n\n\/\/ Test case 1\nconst input1 = '7 2\\\\n1 5 6 2\\\\n1 3\\\\n3 2\\\\n4 5\\\\n3 7\\\\n4 3\\\\n4 6\\\\n';\nconst [n1, k1, universities1, ...roads1] = input1.split('\\\\n');\nconst universitiesArr1 = universities1.split(' ').map(Number);\nconst roadsArr1 = roads1.map((road) => road.split(' ').map(Number));\nconst output1 = calculateMaxDistance(Number(n1.split(' ')[0]), Number(k1), universitiesArr1, roadsArr1);\n\nconsole.log(output1); \/\/ Output: 6\n\n\/\/ Test case 2\nconst input2 = '9 3\\\\n3 2 1 6 5 9\\\\n8 9\\\\n3 2\\\\n2 7\\\\n3 4\\\\n7 6\\\\n4 5\\\\n2 1\\\\n2 8\\\\n';\nconst [n2, k2, universities2, ...roads2] = input2.split('\\\\n');\nconst universitiesArr2 = universities2.split(' ').map(Number);\nconst roadsArr2 = roads2.map((road) => road.split(' ').map(Number));\nconst output2 = calculateMaxDistance(Number(n2.split(' ')[0]), Number(k2), universitiesArr2, roadsArr2);\n\nconsole.log(output2); \/\/ Output: 9\n","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val k = input[1].toInt()\n\n    val universities = readLine()!!.split(\" \").map { it.toInt() }\n\n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    repeat(n - 1) {\n        val (x, y) = readLine()!!.split(\" \").map { it.toInt() }\n        graph[x].add(y)\n        graph[y].add(x)\n    }\n\n    val distances = IntArray(n + 1)\n    val visited = BooleanArray(n + 1)\n\n    fun dfs(node: Int): Int {\n        visited[node] = true\n        var distance = 0\n        for (neighbor in graph[node]) {\n            if (!visited[neighbor]) {\n                distance += dfs(neighbor) + 1\n            }\n        }\n        distances[node] = distance\n        return distance\n    }\n\n    dfs(1)\n\n    val sortedUniversities = universities.sortedByDescending { distances[it] }\n\n    var totalDistance = 0\n    for (i in 0 until 2 * k step 2) {\n        totalDistance += distances[sortedUniversities[i]] + distances[sortedUniversities[i + 1]] - 2 * distances[lowestCommonAncestor(sortedUniversities[i], sortedUniversities[i + 1])]\n    }\n\n    println(totalDistance)\n}\n\nfun lowestCommonAncestor(u: Int, v: Int): Int {\n    val depth = IntArray(200001)\n    val parent = IntArray(200001)\n    val visited = BooleanArray(200001)\n\n    fun dfs(node: Int, d: Int, p: Int) {\n        visited[node] = true\n        depth[node] = d\n        parent[node] = p\n        for (neighbor in graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, d + 1, node)\n            }\n        }\n    }\n\n    dfs(1, 0, -1)\n\n    var uNode = u\n    var vNode = v\n\n    while (depth[uNode] > depth[vNode]) {\n        uNode = parent[uNode]\n    }\n\n    while (depth[vNode] > depth[uNode]) {\n        vNode = parent[vNode]\n    }\n\n    while (uNode != vNode) {\n        uNode = parent[uNode]\n        vNode = parent[vNode]\n    }\n\n    return uNode\n}","PHP":"\n<?php\n\nfunction dfs($node, $parent, $adj, &$distances) {\n    $dist = 0;\n    foreach ($adj[$node] as $child) {\n        if ($child != $parent) {\n            $dist += dfs($child, $node, $adj, $distances) + 1;\n        }\n    }\n    $distances[$node] = $dist;\n    return $dist;\n}\n\nfunction solve($n, $k, $universities, $roads) {\n    $adj = array_fill(1, $n, []);\n    foreach ($roads as $road) {\n        $x = $road[0];\n        $y = $road[1];\n        $adj[$x][] = $y;\n        $adj[$y][] = $x;\n    }\n    \n    $distances = array_fill(1, $n, 0);\n    dfs(1, 0, $adj, $distances);\n    \n    $universityDistances = [];\n    foreach ($universities as $university) {\n        $universityDistances[] = $distances[$university];\n    }\n    \n    sort($universityDistances);\n    \n    $maxSum = 0;\n    for ($i = 0; $i < $k; $i++) {\n        $maxSum += $universityDistances[$i];\n    }\n    \n    return $maxSum;\n}\n\n$input = explode(\\\"\\\\n\\\", \\\"7 2\\n1 5 6 2\\n1 3\\n3 2\\n4 5\\n3 7\\n4 3\\n4 6\\\");\n$nk = explode(\\\" \\\", $input[0]);\n$n = intval($nk[0]);\n$k = intval($nk[1]);\n\n$universities = explode(\\\" \\\", $input[1]);\n$universities = array_map('intval', $universities);\n\n$roads = [];\nfor ($i = 2; $i < $n; $i++) {\n    $road = explode(\\\" \\\", $input[$i]);\n    $roads[] = [intval($road[0]), intval($road[1])];\n}\n\n$result = solve($n, $k, $universities, $roads);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.functional;\\r\\nimport std.range;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Node {\\r\\n    int id;\\r\\n    int parent;\\r\\n    int depth;\\r\\n    int numUniversities;\\r\\n    int maxDistance;\\r\\n    int[] children;\\r\\n}\\r\\n\\r\\nvoid dfs(int currentNode, int parent, int depth, Node[] nodes, int[][] adjacencyList) {\\r\\n    nodes[currentNode].parent = parent;\\r\\n    nodes[currentNode].depth = depth;\\r\\n\\r\\n    foreach (int child; adjacencyList[currentNode]) {\\r\\n        if (child != parent) {\\r\\n            nodes[currentNode].children ~= child;\\r\\n            dfs(child, currentNode, depth + 1, nodes, adjacencyList);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nint calculateMaxDistance(int currentNode, Node[] nodes, int[][] adjacencyList) {\\r\\n    int maxDistance = 0;\\r\\n\\r\\n    foreach (int child; nodes[currentNode].children) {\\r\\n        maxDistance = max(maxDistance, calculateMaxDistance(child, nodes, adjacencyList));\\r\\n    }\\r\\n\\r\\n    nodes[currentNode].maxDistance = maxDistance;\\r\\n\\r\\n    if (nodes[currentNode].numUniversities > 0) {\\r\\n        maxDistance = max(maxDistance, nodes[currentNode].depth);\\r\\n    }\\r\\n\\r\\n    return maxDistance;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, k;\\r\\n    int[] universities;\\r\\n    int[][] roads;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d %d\\\\n\\\", &n, &k);\\r\\n\\r\\n    universities = readln.split.map!(to!int).array;\\r\\n\\r\\n    roads = new int[][](n - 1);\\r\\n    foreach (i; 0..(n - 1)) {\\r\\n        roads[i] = readln.split.map!(to!int).array;\\r\\n    }\\r\\n\\r\\n    \/\/ Build adjacency list\\r\\n    int[][] adjacencyList = new int[][](n);\\r\\n    foreach (road; roads) {\\r\\n        adjacencyList[road[0] - 1] ~= road[1] - 1;\\r\\n        adjacencyList[road[1] - 1] ~= road[0] - 1;\\r\\n    }\\r\\n\\r\\n    \/\/ Initialize nodes\\r\\n    Node[] nodes = new Node[](n);\\r\\n    foreach (i; 0..n) {\\r\\n        nodes[i] = Node(i, -1, 0, 0, 0, []);\\r\\n    }\\r\\n\\r\\n    \/\/ Count universities in each town\\r\\n    foreach (university; universities) {\\r\\n        nodes[university - 1].numUniversities++;\\r\\n    }\\r\\n\\r\\n    \/\/ Perform depth-first search\\r\\n    dfs(0, -1, 0, nodes, adjacencyList);\\r\\n\\r\\n    \/\/ Calculate maximum distance for each node\\r\\n    calculateMaxDistance(0, nodes, adjacencyList);\\r\\n\\r\\n    \/\/ Sort nodes by maximum distance\\r\\n    nodes.sort!((a, b) => a.maxDistance > b.maxDistance);\\r\\n\\r\\n    \/\/ Calculate maximum sum of distances\\r\\n    int maxSum = 0;\\r\\n    foreach (i; 0..k) {\\r\\n        maxSum += nodes[i].maxDistance;\\r\\n    }\\r\\n\\r\\n    \/\/ Print result\\r\\n    writeln(maxSum);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub dfs {\n    my ($adj_list, $visited, $distances, $node) = @_;\n    $visited->[$node] = 1;\n    my $max_distance = 0;\n    foreach my $neighbor (@{$adj_list->[$node]}) {\n        next if $visited->[$neighbor];\n        my $distance = dfs($adj_list, $visited, $distances, $neighbor) + 1;\n        $max_distance = $distance if $distance > $max_distance;\n    }\n    $distances->[$node] = $max_distance;\n    return $max_distance;\n}\n\nsub calculate_max_distance {\n    my ($n, $k, $universities, $roads) = @_;\n    my @adj_list;\n    foreach my $i (1..$n) {\n        $adj_list[$i] = [];\n    }\n    foreach my $road (@$roads) {\n        my ($x, $y) = @$road;\n        push @{$adj_list[$x]}, $y;\n        push @{$adj_list[$y]}, $x;\n    }\n    my @visited = (0) x ($n+1);\n    my @distances = (0) x ($n+1);\n    dfs(\\@adj_list, \\@visited, \\@distances, 1);\n    my @sorted_universities = sort { $distances[$b] <=> $distances[$a] } @$universities;\n    my $max_sum = 0;\n    for (my $i = 0; $i < 2*$k; $i += 2) {\n        $max_sum += $distances[$sorted_universities[$i]] + $distances[$sorted_universities[$i+1]] - 2*$distances[1];\n    }\n    return $max_sum;\n}\n\nsub main {\n    my $input = <>;\n    chomp $input;\n    my ($n, $k) = split ' ', $input;\n    $input = <>;\n    chomp $input;\n    my @universities = split ' ', $input;\n    my @roads;\n    for (my $i = 0; $i < $n-1; $i++) {\n        $input = <>;\n        chomp $input;\n        my ($x, $y) = split ' ', $input;\n        push @roads, [$x, $y];\n    }\n    my $result = calculate_max_distance($n, $k, \\@universities, \\@roads);\n    print $result;\n}\n\nmain();\n","Rust":"use std::collections::HashMap;\\n\\nfn dfs(v: usize, parent: usize, graph: &HashMap<usize, Vec<usize>>, universities: &Vec<bool>, distances: &mut Vec<usize>) -> usize {\\n    let mut distance = 0;\\n    for &u in &graph[&v] {\\n        if u != parent {\\n            distance += dfs(u, v, graph, universities, distances);\\n        }\\n    }\\n    if universities[v] {\\n        distances.push(distance);\\n        distance = 0;\\n    }\\n    distance + 1\\n}\\n\\nfn main() {\\n    let input = \\\"7 2\\\\n1 5 6 2\\\\n1 3\\\\n3 2\\\\n4 5\\\\n3 7\\\\n4 3\\\\n4 6\\\\n\\\";\\n    let lines: Vec<&str> = input.trim().split('\\\\n').collect();\\n    let nk: Vec<usize> = lines[0].split(' ').map(|x| x.parse().unwrap()).collect();\\n    let n = nk[0];\\n    let k = nk[1];\\n    let universities: Vec<bool> = lines[1].split(' ').map(|x| true).collect();\\n    let mut graph: HashMap<usize, Vec<usize>> = HashMap::new();\\n    for i in 0..n-1 {\\n        let road: Vec<usize> = lines[i+2].split(' ').map(|x| x.parse().unwrap()).collect();\\n        graph.entry(road[0]).or_insert(Vec::new()).push(road[1]);\\n        graph.entry(road[1]).or_insert(Vec::new()).push(road[0]);\\n    }\\n    let mut distances: Vec<usize> = Vec::new();\\n    dfs(1, 0, &graph, &universities, &mut distances);\\n    distances.sort();\\n    distances.reverse();\\n    let mut sum = 0;\\n    for i in 0..k {\\n        sum += distances[i];\\n    }\\n    println!(\\\"{}\\\", sum);\\n}"}
{"title":"D. Professor's task","description":"Once a walrus professor Plato asked his programming students to perform the following practical task. The students had to implement such a data structure that would support a convex hull on some set of points S. The input to the program had q queries of two types: 1. Add a point with coordinates (x,y) into the set S. Note that in this case the convex hull of S could have changed, and could have remained the same. 2. Say whether a point with coordinates (x,y) belongs to an area limited by the convex hull, including the border. All the students coped with the task. What about you?","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains an integer q (4\u2264q\u226410^5). \nThen follow q lines in the following way: \"t x y\", where t is the query type (1 or 2), and (x,y) are the coordinates of the point (-10^6\u2264x,y\u226410^6, x and y are integers). \nThere is at least one query of type 2.\nIt is guaranteed that the three queries of the first type follow first and the points given in the queries form a non-degenerative triangle. Also all the points added in S are distinct.\n","output_spec":"For each query of the second type print one string containing \"YES\", if the point lies inside the convex hull or on its border. Otherwise, print \"NO\".\n","notes":null,"sample_inputs":["8\n1 0 0\n1 2 0\n1 2 2\n2 1 0\n1 0 2\n2 1 1\n2 2 1\n2 20 -1\n"],"sample_outputs":["YES\nYES\nYES\nNO\n"],"id":"70-D","difficulty":2700,"tags":["data+structures","geometry"],"src_uid":"6220f4058f9325dfb211fb1dd86e9464","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nstruct Point {\\n    int x, y;\\n};\\n\\nint orientation(Point p, Point q, Point r) {\\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n    if (val == 0) {\\n        return 0; \/\/ collinear\\n    } else if (val > 0) {\\n        return 1; \/\/ clockwise\\n    } else {\\n        return 2; \/\/ counterclockwise\\n    }\\n}\\n\\nbool isInsideConvexHull(vector<Point>& hull, Point p) {\\n    int n = hull.size();\\n    if (n < 3) {\\n        return false;\\n    }\\n    int left = 1, right = n - 1;\\n    while (right - left > 1) {\\n        int mid = (left + right) \/ 2;\\n        if (orientation(hull[0], hull[mid], p) == 2) {\\n            right = mid;\\n        } else {\\n            left = mid;\\n        }\\n    }\\n    return orientation(hull[0], hull[left], p) != 2 && orientation(hull[left], hull[right], p) != 2;\\n}\\n\\nint main() {\\n    int q;\\n    cin >> q;\\n    vector<Point> points;\\n    for (int i = 0; i < q; i++) {\\n        int t, x, y;\\n        cin >> t >> x >> y;\\n        if (t == 1) {\\n            Point p;\\n            p.x = x;\\n            p.y = y;\\n            points.push_back(p);\\n        } else {\\n            vector<Point> hull;\\n            hull.push_back(points[0]);\\n            hull.push_back(points[1]);\\n            hull.push_back(points[2]);\\n            if (isInsideConvexHull(hull, {x, y})) {\\n                cout << \\\"YES\\\" << endl;\\n            } else {\\n                cout << \\\"NO\\\" << endl;\\n            }\\n        }\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class ConvexHull {\n    static class Point {\n        int x, y;\n        \n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int q = scanner.nextInt();\n        List<Point> points = new ArrayList<>();\n        \n        for (int i = 0; i < 3; i++) {\n            int t = scanner.nextInt();\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            \n            points.add(new Point(x, y));\n        }\n        \n        List<Point> convexHull = computeConvexHull(points);\n        \n        for (int i = 3; i < q; i++) {\n            int t = scanner.nextInt();\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            \n            if (t == 1) {\n                points.add(new Point(x, y));\n                convexHull = computeConvexHull(points);\n            } else {\n                if (isInsideConvexHull(convexHull, new Point(x, y))) {\n                    System.out.println(\"YES\");\n                } else {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n    }\n    \n    public static List<Point> computeConvexHull(List<Point> points) {\n        List<Point> hull = new ArrayList<>();\n        \n        \/\/ Find the leftmost point\n        Point leftmost = points.get(0);\n        for (int i = 1; i < points.size(); i++) {\n            if (points.get(i).x < leftmost.x) {\n                leftmost = points.get(i);\n            }\n        }\n        \n        Point current = leftmost;\n        Point next;\n        \n        do {\n            hull.add(current);\n            next = points.get(0);\n            \n            for (int i = 1; i < points.size(); i++) {\n                if (points.get(i) == current) {\n                    continue;\n                }\n                \n                int cross = crossProduct(current, next, points.get(i));\n                \n                if (next == current || cross > 0 || (cross == 0 && distance(current, points.get(i)) > distance(current, next))) {\n                    next = points.get(i);\n                }\n            }\n            \n            current = next;\n        } while (current != leftmost);\n        \n        return hull;\n    }\n    \n    public static int crossProduct(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n    \n    public static int distance(Point a, Point b) {\n        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n    }\n    \n    public static boolean isInsideConvexHull(List<Point> convexHull, Point point) {\n        for (int i = 0; i < convexHull.size(); i++) {\n            int cross = crossProduct(convexHull.get(i), convexHull.get((i + 1) % convexHull.size()), point);\n            \n            if (cross < 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}","Python":"import math\\n\\n\\nclass Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n\\n\\ndef orientation(p, q, r):\\n    val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)\\n\\n    if val == 0:\\n        return 0\\n    elif val > 0:\\n        return 1\\n    else:\\n        return 2\\n\\n\\ndef is_inside(points, n, p):\\n    if n < 3:\\n        return False\\n\\n    extreme = Point(math.inf, p.y)\\n\\n    count = i = 0\\n    while True:\\n        next = (i + 1) % n\\n\\n        if (orientation(points[i], points[next], p) == 0 and on_segment(points[i], p, points[next])):\\n            return True\\n\\n        if (orientation(points[i], p, extreme) == 0 and on_segment(points[i], p, extreme)):\\n            return True\\n\\n        if (orientation(points[next], p, extreme) == 0 and on_segment(points[next], p, extreme)):\\n            return True\\n\\n        if (orientation(points[i], points[next], p) == 1):\\n            count += 1\\n\\n        i = next\\n\\n        if i == 0:\\n            break\\n\\n    return count % 2 == 1\\n\\n\\ndef on_segment(p, q, r):\\n    if (q.x <= max(p.x, r.x) and q.x >= min(p.x, r.x) and\\n            q.y <= max(p.y, r.y) and q.y >= min(p.y, r.y)):\\n        return True\\n\\n    return False\\n\\n\\nq = int(input())\\npoints = []\\n\\nfor _ in range(q):\\n    t, x, y = map(int, input().split())\\n\\n    if t == 1:\\n        points.append(Point(x, y))\\n        if len(points) == 3:\\n            break\\n    else:\\n        if is_inside(points, 3, Point(x, y)):\\n            print('YES')\\n        else:\\n            print('NO')","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n\/\/ Structure to represent a point\\nstruct Point\\n{\\n    int x, y;\\n};\\n\\n\/\/ Function to find orientation of triplet (p, q, r)\\nint orientation(struct Point p, struct Point q, struct Point r)\\n{\\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\n\\n    if (val == 0)\\n        return 0; \/\/ collinear\\n    else if (val > 0)\\n        return 1; \/\/ clockwise\\n    else\\n        return 2; \/\/ counterclockwise\\n}\\n\\n\/\/ Function to check if a point lies inside the convex hull\\nint isInsideConvexHull(struct Point points[], int n, struct Point p)\\n{\\n    \/\/ There must be at least 3 points\\n    if (n < 3)\\n        return 0;\\n\\n    \/\/ Create a point for line segment from p to infinite\\n    struct Point extreme = {10000000, p.y};\\n\\n    \/\/ Count intersections of the above line with sides of polygon\\n    int count = 0, i = 0;\\n    do\\n    {\\n        int next = (i + 1) % n;\\n\\n        \/\/ Check if the line segment from 'p' to 'extreme' intersects with the line segment from 'points[i]' to 'points[next]'\\n        if (orientation(points[i], p, points[next]) == 0)\\n            return 1;\\n\\n        if (points[i].y <= p.y && points[next].y > p.y || points[i].y > p.y && points[next].y <= p.y)\\n        {\\n            if (orientation(points[i], p, extreme) == 0)\\n                return 1;\\n\\n            count++;\\n        }\\n        i = next;\\n    } while (i != 0);\\n\\n    \/\/ Return true if count is odd, false otherwise\\n    return count % 2 == 1;\\n}\\n\\nint main()\\n{\\n    int q;\\n    scanf(\\\"%d\\\", &q);\\n\\n    struct Point points[3];\\n\\n    \/\/ Read the first three points\\n    for (int i = 0; i < 3; i++)\\n    {\\n        int t, x, y;\\n        scanf(\\\"%d %d %d\\\", &t, &x, &y);\\n        points[i].x = x;\\n        points[i].y = y;\\n    }\\n\\n    \/\/ Calculate the convex hull of the first three points\\n    int n = 3;\\n\\n    \/\/ Read the remaining queries\\n    for (int i = 3; i < q; i++)\\n    {\\n        int t, x, y;\\n        scanf(\\\"%d %d %d\\\", &t, &x, &y);\\n\\n        if (t == 1)\\n        {\\n            \/\/ Add the point to the set\\n            struct Point p;\\n            p.x = x;\\n            p.y = y;\\n            points[n++] = p;\\n        }\\n        else if (t == 2)\\n        {\\n            \/\/ Check if the point lies inside the convex hull\\n            struct Point p;\\n            p.x = x;\\n            p.y = y;\\n\\n            if (isInsideConvexHull(points, n, p))\\n                printf(\\\"YES\\\\n\\\");\\n            else\\n                printf(\\\"NO\\\\n\\\");\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace ConvexHull\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int q = int.Parse(Console.ReadLine());\n            List<Point> points = new List<Point>();\n\n            for (int i = 0; i < 3; i++)\n            {\n                string[] query = Console.ReadLine().Split();\n                int t = int.Parse(query[0]);\n                int x = int.Parse(query[1]);\n                int y = int.Parse(query[2]);\n\n                if (t == 1)\n                {\n                    points.Add(new Point(x, y));\n                }\n                else if (t == 2)\n                {\n                    if (IsInsideConvexHull(points, new Point(x, y)))\n                    {\n                        Console.WriteLine(\"YES\");\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"NO\");\n                    }\n                }\n            }\n\n            for (int i = 3; i < q; i++)\n            {\n                string[] query = Console.ReadLine().Split();\n                int t = int.Parse(query[0]);\n                int x = int.Parse(query[1]);\n                int y = int.Parse(query[2]);\n\n                if (t == 1)\n                {\n                    points.Add(new Point(x, y));\n                }\n                else if (t == 2)\n                {\n                    if (IsInsideConvexHull(points, new Point(x, y)))\n                    {\n                        Console.WriteLine(\"YES\");\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"NO\");\n                    }\n                }\n            }\n        }\n\n        static bool IsInsideConvexHull(List<Point> points, Point p)\n        {\n            if (points.Count < 3)\n            {\n                return false;\n            }\n\n            int orientation = GetOrientation(points[0], points[1], p);\n\n            for (int i = 1; i < points.Count; i++)\n            {\n                int currentOrientation = GetOrientation(points[i], points[(i + 1) % points.Count], p);\n\n                if (currentOrientation != orientation)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static int GetOrientation(Point p1, Point p2, Point p3)\n        {\n            int val = (p2.Y - p1.Y) * (p3.X - p2.X) - (p2.X - p1.X) * (p3.Y - p2.Y);\n\n            if (val == 0)\n            {\n                return 0;\n            }\n            else if (val > 0)\n            {\n                return 1;\n            }\n            else\n            {\n                return 2;\n            }\n        }\n    }\n\n    class Point\n    {\n        public int X { get; set; }\n        public int Y { get; set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n}","Ruby":"require 'matrix'\\n\\n# Function to check if a point is inside the convex hull\\n# Parameters:\\n# - hull: an array of points representing the convex hull\\n# - point: the point to check\\n# Returns: true if the point is inside the convex hull, false otherwise\\n\\n# Function to calculate the cross product of two vectors\\n# Parameters:\\n# - v1: the first vector\\n# - v2: the second vector\\n# Returns: the cross product of the two vectors\\n\\ndef cross_product(v1, v2)\\n  v1[0] * v2[1] - v1[1] * v2[0]\\nend\\n\\n# Function to check if a point is inside the convex hull\\n# Parameters:\\n# - hull: an array of points representing the convex hull\\n# - point: the point to check\\n# Returns: true if the point is inside the convex hull, false otherwise\\n\\ndef point_inside_convex_hull(hull, point)\\n  n = hull.length\\n  for i in 0..n-1\\n    v1 = [hull[i][0] - point[0], hull[i][1] - point[1]]\\n    v2 = [hull[(i+1) % n][0] - point[0], hull[(i+1) % n][1] - point[1]]\\n    if cross_product(v1, v2) < 0\\n      return false\\n    end\\n  end\\n  return true\\nend\\n\\n# Function to calculate the convex hull of a set of points\\n# Parameters:\\n# - points: an array of points\\n# Returns: an array of points representing the convex hull\\n\\ndef convex_hull(points)\\n  n = points.length\\n  hull = []\\n  l = 0\\n  for i in 1..n-1\\n    if points[i][0] < points[l][0]\\n      l = i\\n    end\\n  end\\n  p = l\\n  begin\\n    q = (p + 1) % n\\n    for i in 0..n-1\\n      if cross_product([points[i][0] - points[p][0], points[i][1] - points[p][1]], [points[q][0] - points[p][0], points[q][1] - points[p][1]]) < 0\\n        q = i\\n      end\\n    end\\n    hull.push(points[q])\\n    p = q\\n  end while p != l\\n  return hull\\nend\\n\\n# Read the number of queries\\nq = gets.chomp.to_i\\n\\n# Read the first three points\\npoints = []\\nfor i in 1..3\\n  t, x, y = gets.chomp.split.map(&:to_i)\\n  points.push([x, y])\\nend\\n\\n# Calculate the convex hull\\nhull = convex_hull(points)\\n\\n# Process the remaining queries\\nfor i in 4..q\\n  t, x, y = gets.chomp.split.map(&:to_i)\\n  if t == 2\\n    if point_inside_convex_hull(hull, [x, y])\\n      puts 'YES'\\n    else\\n      puts 'NO'\\n    end\\n  else\\n    points.push([x, y])\\n    hull = convex_hull(points)\\n  end\\nend","delphi":"Here is an example implementation in Delphi 7:","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\n\/\/ Point represents a point in 2D space\\ntype Point struct {\\n\\tx, y int\\n}\\n\\n\/\/ Orientation returns the orientation of three points (p, q, r)\\nfunc Orientation(p, q, r Point) int {\\n\\tval := (q.y-p.y)*(r.x-q.x) - (q.x-p.x)*(r.y-q.y)\\n\\tif val == 0 {\\n\\t\\treturn 0 \/\/ collinear\\n\\t} else if val > 0 {\\n\\t\\treturn 1 \/\/ clockwise\\n\\t} else {\\n\\t\\treturn 2 \/\/ counterclockwise\\n\\t}\\n}\\n\\n\/\/ ConvexHull returns the convex hull of a set of points\\nfunc ConvexHull(points []Point) []Point {\\n\\tn := len(points)\\n\\tif n < 3 {\\n\\t\\treturn nil\\n\\t}\\n\\n\t\/\/ Find the leftmost point\\n\tleftmost := 0\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif points[i].x < points[leftmost].x {\\n\\t\\t\\tleftmost = i\\n\\t\\t} else if points[i].x == points[leftmost].x && points[i].y < points[leftmost].y {\\n\\t\\t\\tleftmost = i\\n\\t\\t}\\n\\t}\\n\\n\thull := make([]Point, 0)\\n\\n\tp := leftmost\\n\\tq := 0\\n\\tfor {\\n\\t\\thull = append(hull, points[p])\\n\\t\\tq = (p + 1) % n\\n\\n\\t\\tfor i := 0; i < n; i++ {\\n\\t\\t\\tif Orientation(points[p], points[i], points[q]) == 2 {\\n\\t\\t\\t\\tq = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tp = q\\n\\n\\t\\tif p == leftmost {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn hull\\n}\\n\\nfunc main() {\\n\\tvar q int\\n\\tfmt.Scan(&q)\\n\\n\\tpoints := make([]Point, 0)\\n\\n\\tfor i := 0; i < q; i++ {\\n\\t\\tvar t, x, y int\\n\\t\\tfmt.Scan(&t, &x, &y)\\n\\n\\t\\tif t == 1 {\\n\\t\\t\\tpoints = append(points, Point{x, y})\\n\\t\\t} else {\\n\\t\\t\\tconvexHull := ConvexHull(points)\\n\\t\\t\\tinside := false\\n\\n\\t\\t\\tfor _, p := range convexHull {\\n\\t\\t\\t\\tif p.x == x && p.y == y {\\n\\t\\t\\t\\t\\tinside = true\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif inside {\\n\\t\\t\\t\\tfmt.Println(\\\"YES\\\")\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}","Javascript":"class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass ConvexHull {\n    constructor() {\n        this.points = [];\n    }\n\n    addPoint(x, y) {\n        const point = new Point(x, y);\n        this.points.push(point);\n    }\n\n    isInsideConvexHull(x, y) {\n        const point = new Point(x, y);\n        const n = this.points.length;\n\n        if (n < 3) {\n            return false;\n        }\n\n        let orientation = this.getOrientation(this.points[0], this.points[1], point);\n        if (orientation === 0) {\n            return this.isOnSegment(this.points[0], this.points[1], point);\n        }\n\n        for (let i = 1; i < n; i++) {\n            const currentOrientation = this.getOrientation(this.points[i], this.points[(i + 1) % n], point);\n            if (currentOrientation === 0) {\n                return this.isOnSegment(this.points[i], this.points[(i + 1) % n], point);\n            }\n\n            if (currentOrientation !== orientation) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    getOrientation(p, q, r) {\n        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\n        if (val === 0) {\n            return 0;\n        }\n\n        return (val > 0) ? 1 : 2;\n    }\n\n    isOnSegment(p, q, r) {\n        if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\n            q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n\nfunction solve(q, queries) {\n    const convexHull = new ConvexHull();\n    const result = [];\n\n    for (let i = 0; i < q; i++) {\n        const query = queries[i].split(' ');\n        const type = parseInt(query[0]);\n        const x = parseInt(query[1]);\n        const y = parseInt(query[2]);\n\n        if (type === 1) {\n            convexHull.addPoint(x, y);\n        } else if (type === 2) {\n            const isInside = convexHull.isInsideConvexHull(x, y);\n            result.push(isInside ? 'YES' : 'NO');\n        }\n    }\n\n    return result;\n}\n\nconst input = '8\\\\n1 0 0\\\\n1 2 0\\\\n1 2 2\\\\n2 1 0\\\\n1 0 2\\\\n2 1 1\\\\n2 2 1\\\\n2 20 -1\\\\n';\nconst lines = input.split('\\\\n');\nconst q = parseInt(lines[0]);\nconst queries = lines.slice(1, q + 1);\n\nconst output = solve(q, queries);\nconsole.log(output.join('\\\\n'));","Kotlin":"import java.util.*\\n\\n\/\/ Point class to represent a point in 2D space\\ndata class Point(val x: Int, val y: Int)\\n\\n\/\/ Function to calculate the cross product of two vectors\\nfun crossProduct(p1: Point, p2: Point, p3: Point): Int {\\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\\n}\\n\\n\/\/ Function to check if a point lies inside the convex hull\\nfun isInsideConvexHull(points: List<Point>, queryPoint: Point): Boolean {\\n    val n = points.size\\n    if (n < 3) return false\\n\\n    val extremePoint = Point(Int.MAX_VALUE, queryPoint.y)\\n    var count = 0\\n\\n    var i = 0\\n    var j = (i + 1) % n\\n    while (i < n) {\\n        if (crossProduct(points[i], points[j], queryPoint) > 0 && crossProduct(points[i], points[j], extremePoint) > 0) {\\n            count++\\n        }\\n        i = j\\n        j = (i + 1) % n\\n    }\\n\\n    return count % 2 == 1\\n}\\n\\nfun main() {\\n    val scanner = Scanner(System.`in`)\\n    val q = scanner.nextInt()\\n    val points = mutableListOf<Point>()\\n\\n    for (i in 0 until 3) {\\n        val t = scanner.nextInt()\\n        val x = scanner.nextInt()\\n        val y = scanner.nextInt()\\n        points.add(Point(x, y))\\n    }\\n\\n    for (i in 3 until q) {\\n        val t = scanner.nextInt()\\n        val x = scanner.nextInt()\\n        val y = scanner.nextInt()\\n        val queryPoint = Point(x, y)\\n\\n        if (isInsideConvexHull(points, queryPoint)) {\\n            println(\\\"YES\\\")\\n        } else {\\n            println(\\\"NO\\\")\\n        }\\n    }\\n}","PHP":"<?php\\n\\n\/\/ Define a class to represent a point\\nclass Point {\\n    public $x;\\n    public $y;\\n\\n    public function __construct($x, $y) {\\n        $this->x = $x;\\n        $this->y = $y;\\n    }\\n}\\n\\n\/\/ Define a class to represent the convex hull\\nclass ConvexHull {\\n    public $points;\\n\\n    public function __construct() {\\n        $this->points = [];\\n    }\\n\\n    \/\/ Function to add a point to the convex hull\\n    public function addPoint($x, $y) {\\n        $point = new Point($x, $y);\\n        $this->points[] = $point;\\n    }\\n\\n    \/\/ Function to check if a point is inside the convex hull\\n    public function isInside($x, $y) {\\n        $point = new Point($x, $y);\\n        \/\/ Check if the point is inside the convex hull using a suitable algorithm\\n        \/\/ ... implementation of the algorithm ...\\n        \/\/ Return \"YES\" if the point is inside the convex hull, otherwise return \"NO\"\\n        return \\\"YES\\\";\\n    }\\n}\\n\\n\/\/ Read the input\\n$input = file_get_contents('php:\/\/stdin');\\n$lines = explode(\\\"\\\\n\\\", $input);\\n$q = intval($lines[0]);\\n\\n\/\/ Create a new convex hull\\n$convexHull = new ConvexHull();\\n\\n\/\/ Process the queries\\nfor ($i = 1; $i <= $q; $i++) {\\n    $query = explode(\\\" \\\", $lines[$i]);\\n    $t = intval($query[0]);\\n    $x = intval($query[1]);\\n    $y = intval($query[2]);\\n\\n    if ($t == 1) {\\n        \/\/ Add a point to the convex hull\\n        $convexHull->addPoint($x, $y);\\n    } else if ($t == 2) {\\n        \/\/ Check if a point is inside the convex hull\\n        $result = $convexHull->isInside($x, $y);\\n        echo $result . \\\"\\\\n\\\";\\n    }\\n}\\n?>","d":"import std.algorithm;\\r\\nimport std.conv;\\r\\nimport std.stdio;\\r\\nimport std.string;\\r\\n\\r\\nstruct Point {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nbool isLeftTurn(Point a, Point b, Point c) {\\r\\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) > 0;\\r\\n}\\r\\n\\r\\nbool isInsideConvexHull(Point[] points, Point p) {\\r\\n    if (points.length < 3) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    for (size_t i = 1; i < points.length - 1; i++) {\\r\\n        if (!isLeftTurn(points[0], points[i], p)) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int q;\\r\\n    readf(\\\"%d\\\", &q);\\r\\n\\r\\n    Point[] points;\\r\\n\\r\\n    for (int i = 0; i < q; i++) {\\r\\n        int t, x, y;\\r\\n        readf(\\\"%d %d %d\\\", &t, &x, &y);\\r\\n\\r\\n        if (t == 1) {\\r\\n            points ~= Point(x, y);\\r\\n        } else {\\r\\n            writeln(isInsideConvexHull(points, Point(x, y)) ? \\\"YES\\\" : \\\"NO\\\");\\r\\n        }\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub orientation {\\n    my ($x1, $y1, $x2, $y2, $x3, $y3) = @_;\\n    my $val = ($y2 - $y1) * ($x3 - $x2) - ($x2 - $x1) * ($y3 - $y2);\\n    return 0 if $val == 0; # collinear\\n    return 1 if $val > 0; # clockwise\\n    return 2; # counterclockwise\\n}\\n\\nsub on_segment {\\n    my ($x1, $y1, $x2, $y2, $x, $y) = @_;\\n    return ($x >= $x1 && $x <= $x2 && $y >= $y1 && $y <= $y2) || ($x >= $x2 && $x <= $x1 && $y >= $y2 && $y <= $y1);\\n}\\n\\nsub is_inside_convex_hull {\\n    my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\\n    my $o1 = orientation($x1, $y1, $x2, $y2, $x, $y);\\n    my $o2 = orientation($x2, $y2, $x3, $y3, $x, $y);\\n    my $o3 = orientation($x3, $y3, $x1, $y1, $x, $y);\\n    return 1 if ($o1 == 0 && on_segment($x1, $y1, $x2, $y2, $x, $y)) || ($o2 == 0 && on_segment($x2, $y2, $x3, $y3, $x, $y)) || ($o3 == 0 && on_segment($x3, $y3, $x1, $y1, $x, $y));\\n    return ($o1 == $o2 && $o2 == $o3);\\n}\\n\\nmy $q = <STDIN>;\\nchomp $q;\\n\\nmy @results;\\n\\nmy ($x1, $y1) = split ' ', <STDIN>;\\nmy ($x2, $y2) = split ' ', <STDIN>;\\nmy ($x3, $y3) = split ' ', <STDIN>;\\n\\nfor (1..$q-3) {\\n    my ($t, $x, $y) = split ' ', <STDIN>;\\n    if ($t == 2) {\\n        push @results, is_inside_convex_hull($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) ? 'YES' : 'NO';\\n    }\\n}\\n\\nprint join(\\\"\\\\n\\\", @results);","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let q: usize = lines.next().unwrap().parse().unwrap();\n    \n    let mut points: Vec<(i64, i64)> = Vec::new();\n    \n    for _ in 0..3 {\n        let line = lines.next().unwrap();\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        let x: i64 = parts[1].parse().unwrap();\n        let y: i64 = parts[2].parse().unwrap();\n        points.push((x, y));\n    }\n    \n    let mut convex_hull: Vec<(i64, i64)> = Vec::new();\n    convex_hull.push(points[0]);\n    convex_hull.push(points[1]);\n    convex_hull.push(points[2]);\n    \n    for _ in 0..(q - 3) {\n        let line = lines.next().unwrap();\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        let t: i64 = parts[0].parse().unwrap();\n        let x: i64 = parts[1].parse().unwrap();\n        let y: i64 = parts[2].parse().unwrap();\n        \n        if t == 1 {\n            points.push((x, y));\n            convex_hull.push((x, y));\n            \n            let n = convex_hull.len();\n            let mut i = n - 1;\n            \n            while i >= 2 && ccw(convex_hull[i - 2], convex_hull[i - 1], convex_hull[i]) <= 0 {\n                convex_hull.swap(i - 1, i);\n                i -= 1;\n            }\n        } else {\n            let mut inside = true;\n            \n            for i in 1..convex_hull.len() {\n                if ccw(convex_hull[i - 1], convex_hull[i], (x, y)) < 0 {\n                    inside = false;\n                    break;\n                }\n            }\n            \n            if inside {\n                println!(\"YES\");\n            } else {\n                println!(\"NO\");\n            }\n        }\n    }\n}\n\nfn ccw(p1: (i64, i64), p2: (i64, i64), p3: (i64, i64)) -> i64 {\n    let x1 = p1.0;\n    let y1 = p1.1;\n    let x2 = p2.0;\n    let y2 = p2.1;\n    let x3 = p3.0;\n    let y3 = p3.1;\n    \n    (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n}"}
{"title":"A. Vitya in the Countryside","description":"Every summer Vitya comes to visit his grandmother in the countryside. This summer, he got a huge wart. Every grandma knows that one should treat warts when the moon goes down. Thus, Vitya has to catch the moment when the moon is down.Moon cycle lasts 30 days. The size of the visible part of the moon (in Vitya's units) for each day is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, and then cycle repeats, thus after the second 1 again goes 0.As there is no internet in the countryside, Vitya has been watching the moon for n consecutive days and for each of these days he wrote down the size of the visible part of the moon. Help him find out whether the moon will be up or down next day, or this cannot be determined by the data he has.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line of the input contains a single integer n (1\u2264n\u226492)\u00a0\u2014 the number of consecutive days Vitya was watching the size of the visible part of the moon. \nThe second line contains n integers ai (0\u2264ai\u226415)\u00a0\u2014 Vitya's records.\nIt's guaranteed that the input data is consistent.\n","output_spec":"If Vitya can be sure that the size of visible part of the moon on day n+1 will be less than the size of the visible part on day n, then print \"DOWN\" at the only line of the output. If he might be sure that the size of the visible part will increase, then print \"UP\". If it's impossible to determine what exactly will happen with the moon, print -1.\n","notes":"In the first sample, the size of the moon on the next day will be equal to 8, thus the answer is \"UP\".\nIn the second sample, the size of the moon on the next day will be 11, thus the answer is \"DOWN\".\nIn the third sample, there is no way to determine whether the size of the moon on the next day will be 7 or 9, thus the answer is -1.\n","sample_inputs":["5\n3 4 5 6 7\n","7\n12 13 14 15 14 13 12\n","1\n8\n"],"sample_outputs":["UP\n","DOWN\n","-1\n"],"id":"719-A","difficulty":1100,"tags":["implementation"],"src_uid":"8330d9fea8d50a79741507b878da0a75","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> sizes(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> sizes[i];\\n    }\\n\\n    int currentSize = sizes[n-1];\\n    int prevSize = sizes[n-2];\\n\\n    if (currentSize > prevSize) {\\n        cout << \\\"UP\\\" << endl;\\n    } else if (currentSize < prevSize) {\\n        cout << \\\"DOWN\\\" << endl;\\n    } else {\\n        cout << -1 << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class MoonCycle {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] sizes = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            sizes[i] = scanner.nextInt();\\n        }\\n        String result = determineMoonStatus(sizes);\\n        System.out.println(result);\\n    }\\n\\n    public static String determineMoonStatus(int[] sizes) {\\n        int lastSize = sizes[sizes.length - 1];\\n        int nextSize = (lastSize + 1) % 16;\\n        int prevSize = (lastSize + 15) % 16;\\n\\n        if (nextSize == sizes[0]) {\\n            return \\\"UP\\\";\\n        } else if (prevSize == sizes[0]) {\\n            return \\\"DOWN\\\";\\n        } else {\\n            return \\\"-1\\\";\\n        }\\n    }\\n}","Python":"def determine_moon_status(n, sizes):\n    if sizes[-1] > sizes[-2]:\n        return 'UP'\n    elif sizes[-1] < sizes[-2]:\n        return 'DOWN'\n    else:\n        return -1\n\nn = int(input())\nsizes = list(map(int, input().split()))\n\nresult = determine_moon_status(n, sizes)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int diff = a[n-1] - a[n-2];\\n    if (diff > 0) {\\n        printf(\\\"UP\\\\n\\\");\\n    } else if (diff < 0) {\\n        printf(\\\"DOWN\\\\n\\\");\\n    } else {\\n        printf(\\\"-1\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\n\npublic class MoonCycle\n{\n    public static string DetermineMoonStatus(int[] sizes)\n    {\n        int n = sizes.Length;\n        \n        \/\/ Check if the size of the moon is increasing\n        bool increasing = true;\n        for (int i = 1; i < n; i++)\n        {\n            if (sizes[i] <= sizes[i-1])\n            {\n                increasing = false;\n                break;\n            }\n        }\n        \n        \/\/ Check if the size of the moon is decreasing\n        bool decreasing = true;\n        for (int i = 1; i < n; i++)\n        {\n            if (sizes[i] >= sizes[i-1])\n            {\n                decreasing = false;\n                break;\n            }\n        }\n        \n        \/\/ Determine the moon status based on the observations\n        if (increasing)\n        {\n            return \"UP\";\n        }\n        else if (decreasing)\n        {\n            return \"DOWN\";\n        }\n        else\n        {\n            return \"-1\";\n        }\n    }\n    \n    public static void Main(string[] args)\n    {\n        \/\/ Read the input\n        int n = int.Parse(Console.ReadLine());\n        int[] sizes = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n        \n        \/\/ Determine the moon status\n        string moonStatus = DetermineMoonStatus(sizes);\n        \n        \/\/ Print the result\n        Console.WriteLine(moonStatus);\n    }\n}\n","Ruby":"\ndef determine_moon_status(n, sizes)\n  # Check if the moon is going up or down based on the given sizes\n  if sizes[-1] > sizes[-2]\n    return 'UP'\n  elsif sizes[-1] < sizes[-2]\n    return 'DOWN'\n  else\n    return -1\n  end\nend\n\n# Read input\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\nsizes = input[1].split(' ').map(&:to_i)\n\n# Call the function and print the result\nputs determine_moon_status(n, sizes)\n","delphi":"program MoonCycle;\\n\\nvar\\n  n, i: Integer;\\n  sizes: array of Integer;\\n  isUp, isDown: Boolean;\\nbegin\\n  \/\/ Read the number of consecutive days\\n  ReadLn(n);\\n\\n  \/\/ Read the sizes of the visible part of the moon\\n  SetLength(sizes, n);\\n  for i := 0 to n-1 do\\n    Read(sizes[i]);\\n\\n  \/\/ Check if the moon will be up or down next day\\n  isUp := False;\\n  isDown := False;\\n  for i := 0 to n-2 do\\n  begin\\n    if sizes[i] < sizes[i+1] then\\n      isUp := True\\n    else if sizes[i] > sizes[i+1] then\\n      isDown := True;\\n  end;\\n\\n  \/\/ Print the result\\n  if isUp and not isDown then\\n    WriteLn('UP')\\n  else if isDown and not isUp then\\n    WriteLn('DOWN')\\n  else\\n    WriteLn('-1');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar sizes []int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar size int\\n\\t\\tfmt.Scan(&size)\\n\\t\\tsizes = append(sizes, size)\\n\\t}\\n\\n\\tvar result string\\n\\n\\tif sizes[n-1] > sizes[n-2] {\\n\\t\\tresult = \\\"UP\\\"\\n\\t} else if sizes[n-1] < sizes[n-2] {\\n\\t\\tresult = \\\"DOWN\\\"\\n\\t} else {\\n\\t\\tresult = \\\"-1\\\"\\n\\t}\\n\\n\\tfmt.Println(result)\\n}","Javascript":"function determineMoonStatus(n, sizes) {\n    var currentSize = sizes[n-1];\n    var nextSize = sizes[n];\n    \n    if (nextSize === currentSize) {\n        return -1;\n    } else if (nextSize > currentSize) {\n        return 'UP';\n    } else {\n        return 'DOWN';\n    }\n}\n\nvar input = '5\\n3 4 5 6 7\\n';\nvar lines = input.split('\\\\n');\nvar n = parseInt(lines[0]);\nvar sizes = lines[1].split(' ').map(Number);\n\nvar result = determineMoonStatus(n, sizes);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val sizes = IntArray(n)\n    for (i in 0 until n) {\n        sizes[i] = sc.nextInt()\n    }\n    \n    val currentSize = sizes[n - 1]\n    val previousSize = sizes[n - 2]\n    \n    if (currentSize > previousSize) {\n        println(\\\"UP\\\")\n    } else if (currentSize < previousSize) {\n        println(\\\"DOWN\\\")\n    } else {\n        println(-1)\n    }\n}","PHP":"\n<?php\n\nfunction determineMoonStatus($n, $sizes) {\n    $sizeCount = count($sizes);\n    \n    \/\/ Check if the moon is going up\n    for ($i = 0; $i < $sizeCount - 1; $i++) {\n        if ($sizes[$i] >= $sizes[$i+1]) {\n            return 'UP';\n        }\n    }\n    \n    \/\/ Check if the moon is going down\n    for ($i = 0; $i < $sizeCount - 1; $i++) {\n        if ($sizes[$i] <= $sizes[$i+1]) {\n            return 'DOWN';\n        }\n    }\n    \n    \/\/ If neither up nor down, return -1\n    return -1;\n}\n\n\/\/ Read input\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\n$n = intval($input[0]);\n$sizes = array_map('intval', explode(' ', $input[1]));\n\n\/\/ Determine moon status\n$status = determineMoonStatus($n, $sizes);\n\n\/\/ Print output\necho $status;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] sizes;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    sizes.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &sizes[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Check if moon will be up or down\\r\\n    if (sizes[n-1] < sizes[n-2])\\r\\n    {\\r\\n        writeln(\\\"DOWN\\\");\\r\\n    }\\r\\n    else if (sizes[n-1] > sizes[n-2])\\r\\n    {\\r\\n        writeln(\\\"UP\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"-1\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub determine_moon_status {\n    my ($n, @sizes) = @_;\n\n    my $current_size = $sizes[-1];\n    my $previous_size = $sizes[-2];\n\n    if ($current_size > $previous_size) {\n        return 'UP';\n    } elsif ($current_size < $previous_size) {\n        return 'DOWN';\n    } else {\n        return -1;\n    }\n}\n\n# Read input\nmy $n = <>;\nchomp $n;\nmy @sizes = split ' ', <>;\nchomp @sizes;\n\n# Determine moon status\nmy $moon_status = determine_moon_status($n, @sizes);\n\n# Print output\nprint $moon_status;\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let mut lines = input.lines();\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let sizes: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let last_size = sizes[n-1];\n    let next_size = sizes[n];\n    \n    if next_size > last_size {\n        println!(\\\"UP\\\");\n    } else if next_size < last_size {\n        println!(\\\"DOWN\\\");\n    } else {\n        println!(-1);\n    }\n}"}
{"title":"C. Round Table Knights","description":"There are n knights sitting at the Round Table at an equal distance from each other. Each of them is either in a good or in a bad mood.Merlin, the wizard predicted to King Arthur that the next month will turn out to be particularly fortunate if the regular polygon can be found. On all vertices of the polygon knights in a good mood should be located. Otherwise, the next month will bring misfortunes.A convex polygon is regular if all its sides have same length and all his angles are equal. In this problem we consider only regular polygons with at least 3 vertices, i. e. only nondegenerated.On a picture below some examples of such polygons are present. Green points mean knights in a good mood. Red points mean ones in a bad mood. King Arthur knows the knights' moods. Help him find out if the next month will be fortunate or not.","input_from":"standard input","output_to":"standard output","time_limit":"0.5 second","memory_limit":"256 megabytes","input_spec":"The first line contains number n, which is the number of knights at the round table (3\u2264n\u226410^5). The second line contains space-separated moods of all the n knights in the order of passing them around the table. \"1\" means that the knight is in a good mood an \"0\" means that he is in a bad mood.\n","output_spec":"Print \"YES\" without the quotes if the following month will turn out to be lucky. Otherwise, print \"NO\".\n","notes":null,"sample_inputs":["3\n1 1 1\n","6\n1 0 1 1 1 0\n","6\n1 0 0 1 0 1\n"],"sample_outputs":["YES","YES","NO"],"id":"71-C","difficulty":1600,"tags":["dp","math","number+theory"],"src_uid":"d3a0402de1338a1a542a86ac5b484acc","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nbool isRegularPolygon(vector<int>& moods) {\\n    int n = moods.size();\\n    int countGood = 0;\\n    int countBad = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (moods[i] == 1) {\\n            countGood++;\\n        } else {\\n            countBad++;\\n        }\\n    }\\n    if (countGood == 0 || countBad == 0) {\\n        return false;\\n    }\\n    if (countGood == 1 || countBad == 1) {\\n        return true;\\n    }\\n    if (n % 2 == 0) {\\n        if (countGood % 2 == 0 && countBad % 2 == 0) {\\n            return true;\\n        }\\n    } else {\\n        if (countGood % 2 == 0 && countBad % 2 == 1) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> moods(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> moods[i];\\n    }\\n    if (isRegularPolygon(moods)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class RegularPolygon {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] moods = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            moods[i] = scanner.nextInt();\\n        }\\n\\n        boolean allGoodMoods = true;\\n        boolean allBadMoods = true;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (moods[i] == 0) {\\n                allGoodMoods = false;\\n            } else {\\n                allBadMoods = false;\\n            }\\n        }\\n\\n        if (allGoodMoods || allBadMoods) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n}","Python":"def is_regular_polygon(n, moods):\n    # Count the number of knights in a good mood\n    good_moods = moods.count(1)\n    \n    # Check if the number of knights in a good mood is a divisor of the total number of knights\n    if n % good_moods == 0:\n        # Check if the number of knights in a bad mood is also a divisor of the total number of knights\n        if n % (n - good_moods) == 0:\n            return 'YES'\n    \n    return 'NO'\n\n# Read input\nn = int(input())\nmoods = list(map(int, input().split()))\n\n# Check if the next month will be fortunate\nresult = is_regular_polygon(n, moods)\n\n# Print the result\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int moods[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &moods[i]);\\n    }\\n\\n    int goodMoods = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (moods[i] == 1) {\\n            goodMoods++;\\n        }\\n    }\\n\\n    if (goodMoods >= 3 && goodMoods == n) {\\n        printf(\\\"YES\\\");\\n    } else {\\n        printf(\\\"NO\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        string[] moods = Console.ReadLine().Split();\n\n        \/\/ Count the number of knights in a good mood\n        int goodMoodCount = 0;\n        foreach (string mood in moods)\n        {\n            if (mood == \\\"1\\\")\n            {\n                goodMoodCount++;\n            }\n        }\n\n        \/\/ Check if the number of knights in a good mood is a divisor of n\n        if (n % goodMoodCount == 0)\n        {\n            Console.WriteLine(\\\"YES\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"NO\\\");\n        }\n    }\n}","Ruby":"def lucky_month(n, moods)\\n  # Count the number of knights in a good mood\\n  good_mood_count = moods.count(1)\\n\\n  # Check if the number of knights in a good mood is a divisor of the total number of knights\\n  if n % good_mood_count == 0\\n    # Check if all knights in a good mood are equally spaced\\n    spacing = n \/ good_mood_count\\n    for i in 0..(good_mood_count - 1)\\n      if moods[i * spacing] != 1\\n        return 'NO'\\n      end\\n    end\\n    return 'YES'\\n  else\\n    return 'NO'\\n  end\\nend\\n\\n# Read input\\ninput = gets.chomp.split('\\\\n')\\nn = input[0].to_i\\nmoods = input[1].split.map(&:to_i)\\n\\n# Call the function and print the result\\nputs lucky_month(n, moods)\\n","delphi":"var\n  n, i, count: integer;\n  moods: array of integer;\n  lucky: boolean;\nbegin\n  readln(n);\n  SetLength(moods, n);\n  \n  for i := 0 to n-1 do\n    read(moods[i]);\n  \n  count := 0;\n  for i := 0 to n-1 do\n  begin\n    if moods[i] = 1 then\n      count := count + 1;\n  end;\n  \n  if (count = n) or (count = 0) then\n    lucky := true\n  else if (n mod count = 0) or (n mod (n - count) = 0) then\n    lucky := true\n  else\n    lucky := false;\n  \n  if lucky then\n    writeln('YES')\n  else\n    writeln('NO');\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar moods string\\n\\tfmt.Scan(&moods)\\n\\n\\tmoodArr := strings.Split(moods, \\\" \\\")\\n\\n\\tgoodMoodCount := 0\\n\\tfor _, mood := range moodArr {\\n\\t\\tif mood == \\\"1\\\" {\\n\\t\\t\\tgoodMoodCount++\\n\\t\\t}\\n\\t}\\n\\n\\tif goodMoodCount >= 3 {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function isRegularPolygon(n, moods) {\n    let countGood = 0;\n    for (let i = 0; i < n; i++) {\n        if (moods[i] === 1) {\n            countGood++;\n        }\n    }\n    \n    if (countGood === n || countGood === 0) {\n        return 'YES';\n    } else if (n % countGood === 0) {\n        return 'YES';\n    } else {\n        return 'NO';\n    }\n}\n\nconst input = '6\\n1 0 0 1 0 1\\n';\nconst lines = input.split('\\\\n');\nconst n = parseInt(lines[0]);\nconst moods = lines[1].split(' ').map(Number);\n\nconst result = isRegularPolygon(n, moods);\nconsole.log(result);","Kotlin":"fun main() {\n    val n = readLine()!!.toInt()\n    val moods = readLine()!!.split(\" \").map { it.toInt() }\n    \n    \/\/ Check if all knights have the same mood\n    if (moods.distinct().size == 1) {\n        println(\"YES\")\n        return\n    }\n    \n    \/\/ Check if the number of knights in a good mood is a divisor of n\n    val countGoodMood = moods.count { it == 1 }\n    for (i in 1..countGoodMood) {\n        if (countGoodMood % i == 0 && n % i == 0) {\n            println(\"YES\")\n            return\n        }\n    }\n    \n    println(\"NO\")\n}","PHP":"<?php\\n\\nfunction isRegularPolygon($n, $moods) {\\n    \/\/ Count the number of knights in a good mood\\n    $goodMoodCount = array_count_values($moods)[1];\\n    \\n    \/\/ Check if the number of knights in a good mood is a divisor of the total number of knights\\n    if ($n % $goodMoodCount == 0) {\\n        \/\/ Check if the number of knights in a good mood is equal to the number of sides of the regular polygon\\n        if ($goodMoodCount == $n \/ $goodMoodCount) {\\n            return 'YES';\\n        }\\n    }\\n    \\n    return 'NO';\\n}\\n\\n\/\/ Read input\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$n = (int) $input[0];\\n$moods = array_map('intval', explode(' ', $input[1]));\\n\\n\/\/ Check if the next month will be lucky\\n$result = isRegularPolygon($n, $moods);\\n\\n\/\/ Print the result\\necho $result;\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring checkNextMonth(int n, int[] moods)\\r\\n{\\r\\n    int countGood = count(moods, 1);\\r\\n    int countBad = count(moods, 0);\\r\\n    \\r\\n    if (countGood == 0 || countBad == 0)\\r\\n    {\\r\\n        return \\\"NO\\\";\\r\\n    }\\r\\n    \\r\\n    if (n % 2 == 0 && countGood == n \/ 2)\\r\\n    {\\r\\n        return \\\"YES\\\";\\r\\n    }\\r\\n    \\r\\n    if (n % 2 != 0 && countGood == n \/ 2 + 1)\\r\\n    {\\r\\n        return \\\"YES\\\";\\r\\n    }\\r\\n    \\r\\n    return \\\"NO\\\";\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    \\r\\n    int[] moods = new int[n];\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &moods[i]);\\r\\n    }\\r\\n    \\r\\n    string result = checkNextMonth(n, moods);\\r\\n    writeln(result);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub is_regular_polygon {\\n    my ($n, @moods) = @_;\\n    my $good_moods = grep { $_ == 1 } @moods;\\n    my $bad_moods = grep { $_ == 0 } @moods;\\n\\n    if ($good_moods == 0 || $bad_moods == 0) {\\n        return 'YES';\\n    }\\n\\n    if ($n % 2 == 0) {\\n        if ($good_moods % 2 == 0) {\\n            return 'YES';\\n        }\\n    } else {\\n        if ($good_moods % 2 == 1) {\\n            return 'YES';\\n        }\\n    }\\n\\n    return 'NO';\\n}\\n\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $moods) = split \/\\\\n\/, $input;\\nmy @moods = split \/ \/, $moods;\\n\\nmy $result = is_regular_polygon($n, @moods);\\nprint $result;\\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: usize = input.trim().parse().unwrap();\n    \n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let moods: Vec<u32> = input.trim().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut good_moods = 0;\n    for mood in &moods {\n        if *mood == 1 {\n            good_moods += 1;\n        }\n    }\n    \n    if good_moods >= 3 && good_moods == n {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"D. FreeDiv","description":"Vasya plays FreeDiv. In this game he manages a huge state, which has n cities and m two-way roads between them. Unfortunately, not from every city you can reach any other one moving along these roads. Therefore Vasya decided to divide the state into provinces so that in every province, one could reach from every city all the cities of the province, but there are no roads between provinces. Unlike other turn-based strategies, in FreeDiv a player has the opportunity to build tunnels between cities. The tunnels are two-way roads along which one can move armies undetected by the enemy. However, no more than one tunnel can be connected to each city. As for Vasya, he wants to build a network of tunnels so that any pair of cities in his state were reachable by some path consisting of roads and a tunnels. But at that no more than k tunnels are connected to each province (otherwise, the province will be difficult to keep in case other provinces are captured by enemy armies).Vasya discovered that maybe he will not be able to build such a network for the current condition of the state. Maybe he'll have first to build several roads between cities in different provinces to merge the provinces. Your task is to determine the minimum number of roads Vasya needs to build so that it was possible to build the required network of tunnels in the resulting state.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains three integers n, m and k (1\u2264n,k\u226410^6,0\u2264m\u226410^6). Each of the next m lines contains two integers. They are the numbers of cities connected by a corresponding road. No road connects city to itself and there is at most one road between each pair of cities.\n","output_spec":"Print a single number, the minimum number of additional roads.\n","notes":"In the first example only one province exists, so it is not necessary to build any tunnels or roads.\nIn the second example two provinces exist. It is possible to merge the provinces by building a tunnel between cities 1 and 3.\nIn the third example at least one additional road is necessary. For example it is possible to build additional road between cities 1 and 2 and build two tunnels between cities 1 and 3, 2 and 4 after that.\n","sample_inputs":["3 3 2\n1 2\n2 3\n3 1\n","4 2 2\n1 2\n3 4\n","4 0 2\n"],"sample_outputs":["0","0","1"],"id":"73-D","difficulty":2200,"tags":["dfs+and+similar","graphs","greedy"],"src_uid":"560d70425c765c325f412152c8124d2d","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <set>\\nusing namespace std;\\n\\nvector<vector<int>> adj;\\nvector<int> province;\\nvector<int> tunnels;\\n\\nvoid bfs(int start, int p) {\\n    queue<int> q;\\n    q.push(start);\\n    province[start] = p;\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n\\n        for (int v : adj[u]) {\\n            if (province[v] == -1) {\\n                province[v] = p;\\n                q.push(v);\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    int n, m, k;\\n    cin >> n >> m >> k;\\n\\n    adj.resize(n + 1);\\n    province.resize(n + 1, -1);\\n    tunnels.resize(n + 1, 0);\\n\\n    for (int i = 0; i < m; i++) {\\n        int u, v;\\n        cin >> u >> v;\\n        adj[u].push_back(v);\\n        adj[v].push_back(u);\\n    }\\n\\n    int p = 0;\\n    for (int i = 1; i <= n; i++) {\\n        if (province[i] == -1) {\\n            bfs(i, p);\\n            p++;\\n        }\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        tunnels[province[i]]++;\\n    }\\n\\n    int additionalRoads = 0;\\n    for (int i = 0; i < p; i++) {\\n        if (tunnels[i] > k) {\\n            additionalRoads += (tunnels[i] + k - 1) \/ k - 1;\\n        }\\n    }\\n\\n    cout << additionalRoads << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    static int[] parent;\n    static int[] size;\n    static int[] tunnels;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int k = scanner.nextInt();\n        \n        parent = new int[n+1];\n        size = new int[n+1];\n        tunnels = new int[n+1];\n        \n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n            tunnels[i] = 0;\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int city1 = scanner.nextInt();\n            int city2 = scanner.nextInt();\n            union(city1, city2);\n        }\n        \n        int provinces = 0;\n        for (int i = 1; i <= n; i++) {\n            if (parent[i] == i) {\n                provinces++;\n            }\n        }\n        \n        int additionalRoads = provinces - 1;\n        int additionalTunnels = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            if (parent[i] == i) {\n                additionalTunnels += Math.max(0, size[i] - k);\n            }\n        }\n        \n        int minAdditionalRoads = Math.max(0, additionalTunnels - additionalRoads);\n        System.out.println(minAdditionalRoads);\n    }\n    \n    public static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    public static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX != rootY) {\n            if (size[rootX] < size[rootY]) {\n                parent[rootX] = rootY;\n                size[rootY] += size[rootX];\n                tunnels[rootY] += tunnels[rootX];\n            } else {\n                parent[rootY] = rootX;\n                size[rootX] += size[rootY];\n                tunnels[rootX] += tunnels[rootY];\n            }\n        } else {\n            tunnels[rootX]++;\n        }\n    }\n}","Python":"from collections import defaultdict\\n\\ndef dfs(v, visited, adj_list):\\n    visited[v] = True\\n    for u in adj_list[v]:\\n        if not visited[u]:\\n            dfs(u, visited, adj_list)\\n\\n\\ndef find_provinces(adj_list, n):\\n    visited = [False] * (n+1)\\n    provinces = 0\\n    for i in range(1, n+1):\\n        if not visited[i]:\\n            provinces += 1\\n            dfs(i, visited, adj_list)\\n    return provinces\\n\\n\\ndef build_network(n, m, k, roads):\\n    adj_list = defaultdict(list)\\n    for u, v in roads:\\n        adj_list[u].append(v)\\n        adj_list[v].append(u)\\n    provinces = find_provinces(adj_list, n)\\n    additional_roads = max(0, provinces - 1)\\n    return str(additional_roads)\\n\\n\\n# Sample Inputs\\ninputs = ['3 3 2\\\\n1 2\\\\n2 3\\\\n3 1\\\\n', '4 2 2\\\\n1 2\\\\n3 4\\\\n', '4 0 2\\\\n']\\n\\n# Parsing Inputs\\nn, m, k = map(int, inputs[0].split())\\nroads = [list(map(int, line.split())) for line in inputs[1].splitlines()]\\n\\n# Calling the Function\\noutput = build_network(n, m, k, roads)\\n\\n# Printing the Output\\nprint(output)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAXN 1000005\\n\\nint parent[MAXN];\\nint size[MAXN];\\n\\nvoid make_set(int v) {\\n    parent[v] = v;\\n    size[v] = 1;\\n}\\n\\nint find_set(int v) {\\n    if (v == parent[v])\\n        return v;\\n    return parent[v] = find_set(parent[v]);\\n}\\n\\nvoid union_sets(int a, int b) {\\n    a = find_set(a);\\n    b = find_set(b);\\n    if (a != b) {\\n        if (size[a] < size[b])\\n            swap(a, b);\\n        parent[b] = a;\\n        size[a] += size[b];\\n    }\\n}\\n\\nint main() {\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n\\n    for (int i = 1; i <= n; i++) {\\n        make_set(i);\\n    }\\n\\n    int additional_roads = 0;\\n    int provinces = n;\\n\\n    for (int i = 0; i < m; i++) {\\n        int u, v;\\n        scanf(\\\"%d %d\\\", &u, &v);\\n\\n        if (find_set(u) != find_set(v)) {\\n            union_sets(u, v);\\n            provinces--;\\n        } else {\\n            additional_roads++;\\n        }\\n    }\\n\\n    int tunnels = provinces - 1;\\n    int tunnels_needed = tunnels * k;\\n\\n    if (tunnels_needed > additional_roads) {\\n        additional_roads = tunnels_needed;\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", additional_roads);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace ProvinceNetwork\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n            int k = int.Parse(inputArr[2]);\n\n            List<int>[] adjacencyList = new List<int>[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                adjacencyList[i] = new List<int>();\n            }\n\n            for (int i = 0; i < m; i++)\n            {\n                string road = Console.ReadLine();\n                string[] roadArr = road.Split(' ');\n                int city1 = int.Parse(roadArr[0]);\n                int city2 = int.Parse(roadArr[1]);\n\n                adjacencyList[city1].Add(city2);\n                adjacencyList[city2].Add(city1);\n            }\n\n            int[] province = new int[n + 1];\n            int provinceCount = 0;\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (province[i] == 0)\n                {\n                    provinceCount++;\n                    DFS(i, provinceCount, adjacencyList, province);\n                }\n            }\n\n            int[] provinceSize = new int[provinceCount + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                provinceSize[province[i]]++;\n            }\n\n            int additionalRoads = 0;\n            for (int i = 1; i <= provinceCount; i++)\n            {\n                if (provinceSize[i] > k)\n                {\n                    additionalRoads += (provinceSize[i] - 1) \/ k;\n                }\n            }\n\n            Console.WriteLine(additionalRoads);\n        }\n\n        static void DFS(int city, int provinceCount, List<int>[] adjacencyList, int[] province)\n        {\n            province[city] = provinceCount;\n\n            foreach (int neighbor in adjacencyList[city])\n            {\n                if (province[neighbor] == 0)\n                {\n                    DFS(neighbor, provinceCount, adjacencyList, province);\n                }\n            }\n        }\n    }\n}","Ruby":"\ndef minimum_roads(input)\n  # Parse the input\n  n, m, k = input[0].split.map(&:to_i)\n  roads = input[1..-1].map { |line| line.split.map(&:to_i) }\n\n  # Create a graph representation of the state\n  graph = Array.new(n) { [] }\n  roads.each do |road|\n    city1, city2 = road\n    graph[city1 - 1] << city2 - 1\n    graph[city2 - 1] << city1 - 1\n  end\n\n  # Perform a depth-first search to find the number of provinces\n  provinces = 0\n  visited = Array.new(n, false)\n  (0...n).each do |city|\n    next if visited[city]\n    provinces += 1\n    stack = [city]\n    while !stack.empty?\n      current_city = stack.pop\n      visited[current_city] = true\n      graph[current_city].each do |neighbor|\n        next if visited[neighbor]\n        stack << neighbor\n      end\n    end\n  end\n\n  # Calculate the number of additional roads needed\n  additional_roads = [provinces - 1, 0].max\n\n  additional_roads.to_s\nend\n\n# Test the function with the sample inputs\ninputs = ['3 3 2\\n1 2\\n2 3\\n3 1\\n', '4 2 2\\n1 2\\n3 4\\n', '4 0 2\\n']\noutputs = ['0', '0', '1']\n\nresults = []\ninputs.each_with_index do |input, index|\n  result = minimum_roads(input.split(\"\\n\"))\n  expected_output = outputs[index]\n  results << (result == expected_output)\nend\n\nresults.all? ? 'All test cases passed' : 'Some test cases failed'\n","delphi":"program MinimumRoads;\n\nvar\n  n, m, k, i, j, x, y, provinceCount, roadCount: Integer;\n  provinces: array of Integer;\n  roads: array of array of Integer;\n  visited: array of Boolean;\n\nprocedure DFS(city: Integer);\nvar\n  i: Integer;\nbegin\n  visited[city] := True;\n  provinces[city] := provinceCount;\n  \n  for i := 0 to Length(roads[city]) - 1 do\n  begin\n    if not visited[roads[city][i]] then\n      DFS(roads[city][i]);\n  end;\nend;\n\nbegin\n  ReadLn(n, m, k);\n  \n  SetLength(provinces, n + 1);\n  SetLength(roads, n + 1);\n  SetLength(visited, n + 1);\n  \n  for i := 1 to m do\n  begin\n    ReadLn(x, y);\n    SetLength(roads[x], Length(roads[x]) + 1);\n    SetLength(roads[y], Length(roads[y]) + 1);\n    roads[x][Length(roads[x]) - 1] := y;\n    roads[y][Length(roads[y]) - 1] := x;\n  end;\n  \n  provinceCount := 0;\n  \n  for i := 1 to n do\n  begin\n    if not visited[i] then\n    begin\n      Inc(provinceCount);\n      DFS(i);\n    end;\n  end;\n  \n  roadCount := 0;\n  \n  for i := 1 to provinceCount do\n  begin\n    if Length(provinces) <= k then\n      Continue;\n    \n    for j := 1 to n do\n    begin\n      if provinces[j] = i then\n      begin\n        if Length(roads[j]) < k then\n          Inc(roadCount, k - Length(roads[j]));\n      end;\n    end;\n  end;\n  \n  WriteLn(roadCount);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnmk := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nmk[0])\\n\\tm, _ := strconv.Atoi(nmk[1])\\n\\tk, _ := strconv.Atoi(nmk[2])\\n\\n\\tprovinces := make([]int, n+1)\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tprovinces[i] = i\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\troad := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\tcity1, _ := strconv.Atoi(road[0])\\n\\t\\tcity2, _ := strconv.Atoi(road[1])\\n\\n\\t\\tif provinces[city1] != provinces[city2] {\\n\\t\\t\\tprovinces[city2] = provinces[city1]\\n\\t\\t}\\n\\t}\\n\\n\\tuniqueProvinces := make(map[int]bool)\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tuniqueProvinces[provinces[i]] = true\\n\\t}\\n\\n\\tnumProvinces := len(uniqueProvinces)\\n\\n\\tif numProvinces <= k {\\n\\t\\tfmt.Println(0)\\n\\t} else {\\n\\t\\tnumAdditionalRoads := numProvinces - k\\n\\t\\tfmt.Println(numAdditionalRoads)\\n\\t}\\n}","Javascript":"function minimumAdditionalRoads(input) {\n  const lines = input.split('\\\\n');\n  const [n, m, k] = lines[0].split(' ').map(Number);\n  const roads = lines.slice(1, m + 1).map(line => line.split(' ').map(Number));\n\n  const provinces = [];\n  const visited = new Array(n + 1).fill(false);\n\n  function dfs(city, province) {\n    visited[city] = true;\n    provinces[city] = province;\n\n    for (let i = 0; i < m; i++) {\n      const [u, v] = roads[i];\n      if (u === city && !visited[v]) {\n        dfs(v, province);\n      } else if (v === city && !visited[u]) {\n        dfs(u, province);\n      }\n    }\n  }\n\n  let provinceCount = 0;\n  for (let i = 1; i <= n; i++) {\n    if (!visited[i]) {\n      provinceCount++;\n      dfs(i, provinceCount);\n    }\n  }\n\n  const provinceTunnels = new Array(provinceCount + 1).fill(0);\n  for (let i = 0; i < m; i++) {\n    const [u, v] = roads[i];\n    if (provinces[u] !== provinces[v]) {\n      provinceTunnels[provinces[u]]++;\n      provinceTunnels[provinces[v]]++;\n    }\n  }\n\n  let additionalRoads = 0;\n  for (let i = 1; i <= provinceCount; i++) {\n    additionalRoads += Math.max(0, provinceTunnels[i] - k);\n  }\n\n  return additionalRoads.toString();\n}\n\nconst inputs = ['3 3 2\\\\n1 2\\\\n2 3\\\\n3 1\\\\n', '4 2 2\\\\n1 2\\\\n3 4\\\\n', '4 0 2\\\\n'];\nconst outputs = inputs.map(minimumAdditionalRoads);\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val n = input[0]\n    val m = input[1]\n    val k = input[2]\n\n    val graph = Array(n + 1) { mutableListOf<Int>() }\n    val visited = BooleanArray(n + 1) { false }\n    val provinces = mutableListOf<MutableList<Int>>()\n\n    for (i in 0 until m) {\n        val road = readLine()!!.split(\" \").map { it.toInt() }\n        graph[road[0]].add(road[1])\n        graph[road[1]].add(road[0])\n    }\n\n    fun dfs(node: Int, province: MutableList<Int>) {\n        visited[node] = true\n        province.add(node)\n\n        for (neighbor in graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor, province)\n            }\n        }\n    }\n\n    for (i in 1..n) {\n        if (!visited[i]) {\n            val province = mutableListOf<Int>()\n            dfs(i, province)\n            provinces.add(province)\n        }\n    }\n\n    var additionalRoads = 0\n\n    for (province in provinces) {\n        val provinceSize = province.size\n        val requiredTunnels = (provinceSize - 1) \/ k\n        additionalRoads += requiredTunnels\n    }\n\n    println(additionalRoads)\n}","PHP":"\n<?php\n\nfunction findMinRoads($n, $m, $k, $roads) {\n    $adjList = array_fill(1, $n, []);\n    $visited = array_fill(1, $n, false);\n    $provinces = [];\n    $numProvinces = 0;\n    \n    \/\/ Build adjacency list\n    foreach ($roads as $road) {\n        $u = $road[0];\n        $v = $road[1];\n        $adjList[$u][] = $v;\n        $adjList[$v][] = $u;\n    }\n    \n    \/\/ DFS to find provinces\n    for ($i = 1; $i <= $n; $i++) {\n        if (!$visited[$i]) {\n            $numProvinces++;\n            $province = [];\n            dfs($i, $adjList, $visited, $province);\n            $provinces[] = $province;\n        }\n    }\n    \n    \/\/ Check if each province has at most k tunnels\n    foreach ($provinces as $province) {\n        if (count($province) > $k) {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nfunction dfs($node, $adjList, &$visited, &$province) {\n    $visited[$node] = true;\n    $province[] = $node;\n    \n    foreach ($adjList[$node] as $neighbor) {\n        if (!$visited[$neighbor]) {\n            dfs($neighbor, $adjList, $visited, $province);\n        }\n    }\n}\n\n\/\/ Sample inputs\n$inputs = [\n    ['3 3 2\\n1 2\\n2 3\\n3 1\\n'],\n    ['4 2 2\\n1 2\\n3 4\\n'],\n    ['4 0 2\\n']\n];\n\n\/\/ Process each input\nforeach ($inputs as $input) {\n    $lines = explode('\\n', $input);\n    $params = explode(' ', $lines[0]);\n    $n = intval($params[0]);\n    $m = intval($params[1]);\n    $k = intval($params[2]);\n    $roads = [];\n    \n    \/\/ Parse roads\n    for ($i = 1; $i <= $m; $i++) {\n        $road = explode(' ', $lines[$i]);\n        $u = intval($road[0]);\n        $v = intval($road[1]);\n        $roads[] = [$u, $v];\n    }\n    \n    \/\/ Find minimum number of roads\n    $minRoads = findMinRoads($n, $m, $k, $roads);\n    \n    \/\/ Print output\n    echo $minRoads . '\\n';\n}\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, k;\\r\\n    readf(\\\"%d %d %d\\\", &n, &m, &k);\\r\\n\\r\\n    \/\/ Create a graph to represent the cities and roads\\r\\n    auto graph = new Graph!int();\\r\\n\\r\\n    \/\/ Read the roads and add them to the graph\\r\\n    for (int i = 0; i < m; i++)\\r\\n    {\\r\\n        int city1, city2;\\r\\n        readf(\\\"%d %d\\\", &city1, &city2);\\r\\n        graph.addEdge(city1, city2);\\r\\n    }\\r\\n\\r\\n    \/\/ Find the connected components in the graph\\r\\n    auto components = graph.connectedComponents();\\r\\n\\r\\n    \/\/ Count the number of components that have more than k tunnels\\r\\n    int additionalRoads = 0;\\r\\n    foreach (component; components)\\r\\n    {\\r\\n        if (component.length > k)\\r\\n        {\\r\\n            additionalRoads += component.length - k;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(additionalRoads);\\r\\n}\\r\\n\\r\\nclass Graph(T)\\r\\n{\\r\\n    private\\r\\n    {\\r\\n        T[] vertices;\\r\\n        T[][] edges;\\r\\n    }\\r\\n\\r\\n    this()\\r\\n    {\\r\\n        vertices = new T[]();\\r\\n        edges = new T[][]();\\r\\n    }\\r\\n\\r\\n    void addEdge(T v1, T v2)\\r\\n    {\\r\\n        if (!vertices.contains(v1))\\r\\n        {\\r\\n            vertices ~= v1;\\r\\n            edges ~= new T[]();\\r\\n        }\\r\\n\\r\\n        if (!vertices.contains(v2))\\r\\n        {\\r\\n            vertices ~= v2;\\r\\n            edges ~= new T[]();\\r\\n        }\\r\\n\\r\\n        edges[vertices.indexOf(v1)] ~= v2;\\r\\n        edges[vertices.indexOf(v2)] ~= v1;\\r\\n    }\\r\\n\\r\\n    T[][] connectedComponents()\\r\\n    {\\r\\n        T[][] components;\\r\\n        bool[] visited = new bool[](vertices.length);\\r\\n\\r\\n        foreach (vertex; vertices)\\r\\n        {\\r\\n            if (!visited[vertices.indexOf(vertex)])\\r\\n            {\\r\\n                T[] component = new T[]();\\r\\n                dfs(vertex, visited, component);\\r\\n                components ~= component;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return components;\\r\\n    }\\r\\n\\r\\n    void dfs(T vertex, bool[] visited, T[] component)\\r\\n    {\\r\\n        visited[vertices.indexOf(vertex)] = true;\\r\\n        component ~= vertex;\\r\\n\\r\\n        foreach (edge; edges[vertices.indexOf(vertex)])\\r\\n        {\\r\\n            if (!visited[vertices.indexOf(edge)])\\r\\n            {\\r\\n                dfs(edge, visited, component);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub find_min_additional_roads {\n    my ($n, $m, $k, @roads) = @_;\n\n    my @provinces;\n    my %province_map;\n    my $province_count = 0;\n\n    # Create initial provinces\n    for my $i (1..$n) {\n        $provinces[$i] = [$i];\n        $province_map{$i} = $i;\n        $province_count++;\n    }\n\n    # Merge provinces if necessary\n    for my $road (@roads) {\n        my ($city1, $city2) = split(' ', $road);\n\n        my $province1 = $province_map{$city1};\n        my $province2 = $province_map{$city2};\n\n        next if $province1 == $province2;\n\n        # Merge provinces\n        if (@{$provinces[$province1]} + @{$provinces[$province2]} <= $k) {\n            push @{$provinces[$province1]}, @{$provinces[$province2]};\n            for my $city (@{$provinces[$province2]}) {\n                $province_map{$city} = $province1;\n            }\n            $province_count--;\n        }\n    }\n\n    # Calculate the minimum number of additional roads\n    my $additional_roads = $province_count - 1;\n\n    return $additional_roads;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $k) = split(' ', $input);\nmy @roads;\nfor (1..$m) {\n    my $road = <STDIN>;\n    chomp $road;\n    push @roads, $road;\n}\n\n# Find the minimum number of additional roads\nmy $min_additional_roads = find_min_additional_roads($n, $m, $k, @roads);\n\n# Print the result\nprint $min_additional_roads;\n","Rust":"fn main() {\n    let input = [\n        \\\"3 3 2\\\",\n        \\\"1 2\\\",\n        \\\"2 3\\\",\n        \\\"3 1\\\",\n    ];\n    \n    let mut lines = input.iter();\n    let first_line: Vec<usize> = lines\n        .next()\n        .unwrap()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    \n    let n = first_line[0];\n    let m = first_line[1];\n    let k = first_line[2];\n    \n    let mut provinces = vec![vec![]];\n    let mut visited = vec![false; n];\n    \n    for _ in 0..m {\n        let road: Vec<usize> = lines\n            .next()\n            .unwrap()\n            .split_whitespace()\n            .map(|x| x.parse().unwrap())\n            .collect();\n        \n        let city1 = road[0] - 1;\n        let city2 = road[1] - 1;\n        \n        provinces[0].push((city1, city2));\n    }\n    \n    let mut queue = vec![0];\n    visited[0] = true;\n    \n    while let Some(province) = queue.pop() {\n        for &(city1, city2) in &provinces[province] {\n            if !visited[city1] {\n                visited[city1] = true;\n                queue.push(city1);\n            }\n            if !visited[city2] {\n                visited[city2] = true;\n                queue.push(city2);\n            }\n        }\n    }\n    \n    let mut additional_roads = 0;\n    \n    for i in 0..n {\n        if !visited[i] {\n            additional_roads += 1;\n        }\n    }\n    \n    println!(\\\"{}\\\", additional_roads);\n}"}
{"title":"E. Morrowindows","description":"Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and x (0\u2264n\u226410^5,2\u2264x\u226410^9). The second line contains integers ai (1\u2264ai\u226410^9). Some numbers among all ai may be equal.\n","output_spec":"Output the fewest amount of modes required to uniquely determine amount of items in the inventory. If there is no solution output -1.\n","notes":"In the second example Vasya is not able to determine items count uniquely because 3 items, as well as 4 items, can be displayed on two pages.\n","sample_inputs":["2 4\n2 3\n","1 4\n2\n"],"sample_outputs":["2\n","-1\n"],"id":"73-E","difficulty":2400,"tags":["math","number+theory"],"src_uid":"0f49b4a5696ee71ebbc8f83d1ec3b901","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, x;\\n    cin >> n >> x;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n    sort(a.begin(), a.end());\\n    int modes = 1;\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] > x) {\\n            break;\\n        }\\n        int pages = (x + a[i] - 1) \/ a[i];\\n        if (pages > modes) {\\n            modes = pages;\\n        }\\n    }\\n    cout << modes << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class InventoryModes {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input\n        String[] input = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input[0]);\n        int x = Integer.parseInt(input[1]);\n        \n        int[] ai = new int[n];\n        input = scanner.nextLine().split(\\\" \\\");\n        for (int i = 0; i < n; i++) {\n            ai[i] = Integer.parseInt(input[i]);\n        }\n        \n        \/\/ Sort the array in ascending order\n        Arrays.sort(ai);\n        \n        \/\/ Check if there is a mode that can uniquely determine the inventory size\n        boolean unique = false;\n        int modes = 0;\n        for (int i = 0; i < n; i++) {\n            if (ai[i] == x) {\n                unique = true;\n                modes = 1;\n                break;\n            } else if (ai[i] > x) {\n                break;\n            }\n        }\n        \n        \/\/ If there is no unique mode, check if there is a combination of modes that can uniquely determine the inventory size\n        if (!unique) {\n            for (int i = 0; i < n - 1; i++) {\n                if (ai[i] + ai[i + 1] - 1 >= x) {\n                    unique = true;\n                    modes = 2;\n                    break;\n                }\n            }\n        }\n        \n        \/\/ Output the result\n        if (unique) {\n            System.out.println(modes);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}","Python":"def determine_modes(n, x, ai):\\n    # Sort the ai list in ascending order\\n    ai.sort()\\n    \\n    # Initialize the number of modes\\n    modes = 1\\n    \\n    # Iterate through the ai list\\n    for i in range(1, n):\\n        # Check if the current ai is equal to the previous ai\\n        if ai[i] == ai[i-1]:\\n            # Check if the current ai is greater than x\\n            if ai[i] > x:\\n                # Return -1 if there is no solution\\n                return -1\\n            # Increment the number of modes\\n            modes += 1\\n        else:\\n            # Check if the current ai is greater than x\\n            if ai[i] > x:\\n                # Return -1 if there is no solution\\n                return -1\\n            # Check if the current ai is equal to x\\n            if ai[i] == x:\\n                # Return the number of modes\\n                return modes\\n            # Increment the number of modes\\n            modes += 1\\n    \\n    # Return -1 if there is no solution\\n    return -1\\n\\n\\n# Read the input\\ninput_data = input().split('\\\\n')\\nn, x = map(int, input_data[0].split())\\nai = list(map(int, input_data[1].split()))\\n\\n# Call the determine_modes function\\nresult = determine_modes(n, x, ai)\\n\\n# Print the result\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, x;\\n    scanf(\\\"%d %d\\\", &n, &x);\\n    int ai[n];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &ai[i]);\\n    }\\n    int unique = 1;\\n    for(int i=0; i<n; i++) {\\n        if(ai[i] == x) {\\n            unique = 0;\\n            break;\\n        }\\n    }\\n    if(unique) {\\n        printf(\\\"%d\\\\n\\\", n);\\n    } else {\\n        printf(\\\"-1\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int x = int.Parse(input[1]);\n\n        int[] ai = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int minModes = GetMinModes(n, x, ai);\n\n        Console.WriteLine(minModes);\n    }\n\n    public static int GetMinModes(int n, int x, int[] ai)\n    {\n        int minModes = int.MaxValue;\n\n        for (int i = 1; i <= x; i++)\n        {\n            if (x % i == 0)\n            {\n                int pages = x \/ i;\n                int modes = 0;\n\n                foreach (int a in ai)\n                {\n                    if (a % i == 0 && a \/ i <= pages)\n                    {\n                        modes++;\n                    }\n                }\n\n                if (modes == n)\n                {\n                    minModes = Math.Min(minModes, pages);\n                }\n            }\n        }\n\n        return minModes == int.MaxValue ? -1 : minModes;\n    }\n}","Ruby":"def determine_modes(n, x, ai)\\n  # Sort the ai array in ascending order\\n  ai.sort!\\n\\n  # Initialize the count of modes\\n  modes = 0\\n\\n  # Iterate through each ai value\\n  ai.each do |a|\\n    # Check if the current ai value is greater than x\\n    if a > x\\n      # If it is, return -1 as there is no solution\\n      return -1\\n    end\\n\\n    # Check if the current ai value is equal to x\\n    if a == x\\n      # If it is, increment the count of modes and return the current count\\n      modes += 1\\n      return modes\\n    end\\n\\n    # Check if the current ai value is less than x\\n    if a < x\\n      # If it is, increment the count of modes\\n      modes += 1\\n\\n      # Calculate the number of pages for the current ai value\\n      pages = (x.to_f \/ a).ceil\\n\\n      # Check if the number of pages is greater than 1\\n      if pages > 1\\n        # If it is, return the current count of modes\\n        return modes\\n      end\\n    end\\n  end\\n\\n  # If no solution is found, return -1\\n  return -1\\nend\\n\\n# Parse the input\\ninput = gets.chomp.split('\\\\n')\\nn, x = input[0].split.map(&:to_i)\\nai = input[1].split.map(&:to_i)\\n\\n# Call the determine_modes function and print the result\\nputs determine_modes(n, x, ai)\\n","delphi":"program InventoryModes;\n\nvar\n  n, x, i, ai, maxPages, totalModes: Integer;\n  a: array of Integer;\n  unique: Boolean;\n\nbegin\n  \/\/ Read input values\n  ReadLn(n, x);\n  \n  \/\/ Initialize variables\n  SetLength(a, n);\n  maxPages := 0;\n  totalModes := 0;\n  unique := True;\n  \n  \/\/ Read ai values and calculate maximum number of pages\n  for i := 0 to n - 1 do\n  begin\n    Read(ai);\n    a[i] := ai;\n    maxPages := Max(maxPages, (ai + x - 1) div x);\n  end;\n  \n  \/\/ Check if there is a mode that can have multiple page counts\n  for i := 0 to n - 1 do\n  begin\n    if (a[i] > x) and (a[i] <= 2 * x) then\n    begin\n      unique := False;\n      Break;\n    end;\n  end;\n  \n  \/\/ Calculate the total number of modes required\n  if unique then\n    totalModes := maxPages\n  else\n    totalModes := -1;\n  \n  \/\/ Output the result\n  WriteLn(totalModes);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, x int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &x)\\n\\n\\tvar a []int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar ai int\\n\\t\\tfmt.Scanf(\\\"%d\\\", &ai)\\n\\t\\ta = append(a, ai)\\n\\t}\\n\\n\\tsort.Ints(a)\\n\\n\\tvar modes int\\n\\tvar prevPages int\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif a[i] == prevPages {\\n\\t\\t\\tmodes = -1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tpages := (a[i] + x - 1) \/ x\\n\\n\\t\\tif i == 0 || pages > prevPages {\\n\\t\\t\\tmodes++\\n\\t\\t\\tprevPages = pages\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(modes)\\n}","Javascript":"function determineModes(input) {\n  const lines = input.split('\\\\n');\n  const [n, x] = lines[0].split(' ').map(Number);\n  const ai = lines[1].split(' ').map(Number);\n  \n  const maxAi = Math.max(...ai);\n  const minAi = Math.min(...ai);\n  \n  if (maxAi === minAi) {\n    if (x % maxAi === 0) {\n      return '1\\\\n';\n    } else {\n      return '-1\\\\n';\n    }\n  }\n  \n  const maxPages = Math.ceil(x \/ minAi);\n  const minPages = Math.ceil(x \/ maxAi);\n  \n  if (maxPages === minPages) {\n    return '1\\\\n';\n  } else {\n    return '2\\\\n';\n  }\n}\n\nconst input = '2 4\\\\n2 3\\\\n';\nconsole.log(determineModes(input));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val x = input[1].toInt()\n    \n    val ai = scanner.nextLine().split(\" \").map { it.toInt() }\n    \n    val maxAi = ai.maxOrNull() ?: 0\n    val minAi = ai.minOrNull() ?: 0\n    \n    if (maxAi > x || minAi * n < x) {\n        println(\"-1\")\n    } else {\n        val modes = ai.count { it == maxAi }\n        println(modes)\n    }\n}","PHP":"\n<?php\n\nfunction determineModes($n, $x, $ai) {\n    \/\/ Sort the array of ai in ascending order\n    sort($ai);\n    \n    \/\/ Check if the maximum value of ai is greater than x\n    if ($ai[count($ai)-1] > $x) {\n        return -1;\n    }\n    \n    \/\/ Initialize variables\n    $modes = 0;\n    $pages = 0;\n    \n    \/\/ Iterate through each ai value\n    foreach ($ai as $value) {\n        \/\/ Calculate the number of pages for the current ai value\n        $currentPages = ceil($x \/ $value);\n        \n        \/\/ Check if the number of pages is greater than the previous maximum\n        if ($currentPages > $pages) {\n            $pages = $currentPages;\n            $modes++;\n        }\n    }\n    \n    return $modes;\n}\n\n\/\/ Read input from stdin\n$input = explode(\"\\n\", trim(file_get_contents(\"php:\/\/stdin\")));\nlist($n, $x) = explode(\" \", $input[0]);\n$ai = array_map('intval', explode(\" \", $input[1]));\n\n\/\/ Call the determineModes function and output the result\n$result = determineModes($n, $x, $ai);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] inputs = [\\r\\n        \\\"2 4\\\\n2 3\\\\n\\\",\\r\\n        \\\"1 4\\\\n2\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    string[] outputs = [\\r\\n        \\\"2\\\\n\\\",\\r\\n        \\\"-1\\\\n\\\"\\r\\n    ];\\r\\n\\r\\n    for (size_t i = 0; i < inputs.length; i++)\\r\\n    {\\r\\n        string[] lines = inputs[i].split(\\\"\\\\n\\\");\\r\\n        int n, x;\\r\\n        int[] ai;\\r\\n\\r\\n        sscanf(lines[0], \\\"%d %d\\\", &n, &x);\\r\\n        ai = lines[1].split(\\\" \\\").map!(a => to!int(a)).array;\\r\\n\\r\\n        int result = determineModes(n, x, ai);\\r\\n        string output = to!string(result) ~ \\\"\\\\n\\\";\\r\\n\\r\\n        assert(output == outputs[i]);\\r\\n    }\\r\\n}\\r\\n\\r\\nint determineModes(int n, int x, int[] ai)\\r\\n{\\r\\n    int minModes = int.max;\\r\\n\\r\\n    foreach (int a; ai)\\r\\n    {\\r\\n        int maxPages = (x + a - 1) \/ a;\\r\\n\\r\\n        if (maxPages <= n)\\r\\n        {\\r\\n            int modes = (maxPages + n - 1) \/ n;\\r\\n            minModes = min(minModes, modes);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return minModes == int.max ? -1 : minModes;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub determine_modes {\\n    my ($n, $x, @ai) = @_;\\n    my %counts;\\n    foreach my $a (@ai) {\\n        $counts{$a}++;\\n    }\\n    my $min_modes = $n;\\n    foreach my $a (keys %counts) {\\n        my $pages = int($x \/ $a) + ($x % $a ? 1 : 0);\\n        if ($pages <= $counts{$a}) {\\n            my $modes = int($counts{$a} \/ $pages) + ($counts{$a} % $pages ? 1 : 0);\\n            $min_modes = $modes if $modes < $min_modes;\\n        }\\n    }\\n    return $min_modes;\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $x) = split ' ', $input;\\n\\n$input = <STDIN>;\\nchomp $input;\\nmy @ai = split ' ', $input;\\n\\n# Call the function\\nmy $result = determine_modes($n, $x, @ai);\\n\\n# Print the result\\nprint $result . \\\"\\\\n\\\";\\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut input = input.trim().split(' ');\\n    let n: usize = input.next().unwrap().parse().unwrap();\\n    let x: u32 = input.next().unwrap().parse().unwrap();\\n\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let a: Vec<u32> = input.trim().split(' ').map(|x| x.parse().unwrap()).collect();\\n\\n    let mut modes = 0;\\n    let mut unique = true;\\n\\n    for i in 0..n {\\n        let b: u32 = (a[i] + x - 1) \/ x;\\n        if b > 1 {\\n            if unique {\\n                modes += 1;\\n                unique = false;\\n            }\\n        } else {\\n            unique = true;\\n        }\\n    }\\n\\n    if modes == 0 {\\n        println!(\\\"-1\\\");\\n    } else {\\n        println!(\\\"{}\\\", modes);\\n    }\\n}"}
{"title":"A. Room Leader","description":"Let us remind you part of the rules of Codeforces. The given rules slightly simplified, use the problem statement as a formal document.In the beginning of the round the contestants are divided into rooms. Each room contains exactly n participants. During the contest the participants are suggested to solve five problems, A, B, C, D and E. For each of these problem, depending on when the given problem was solved and whether it was solved at all, the participants receive some points. Besides, a contestant can perform hacks on other contestants. For each successful hack a contestant earns 100 points, for each unsuccessful hack a contestant loses 50 points. The number of points for every contestant is represented by the sum of points he has received from all his problems, including hacks.You are suggested to determine the leader for some room; the leader is a participant who has maximum points.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n, which is the number of contestants in the room (1\u2264n\u226450). The next n lines contain the participants of a given room. The i-th line has the format of \"handlei plusi minusi ai bi ci di ei\" \u2014 it is the handle of a contestant, the number of successful hacks, the number of unsuccessful hacks and the number of points he has received from problems A, B, C, D, E correspondingly. The handle of each participant consists of Latin letters, digits and underscores and has the length from 1 to 20 characters. There are the following limitations imposed upon the numbers: \n  0\u2264plusi,minusi\u226450;  150\u2264ai\u2264500 or ai=0, if problem A is not solved;  300\u2264bi\u22641000 or bi=0, if problem B is not solved;  450\u2264ci\u22641500 or ci=0, if problem C is not solved;  600\u2264di\u22642000 or di=0, if problem D is not solved;  750\u2264ei\u22642500 or ei=0, if problem E is not solved. All the numbers are integer. All the participants have different handles. It is guaranteed that there is exactly one leader in the room (i.e. there are no two participants with the maximal number of points).\n","output_spec":"Print on the single line the handle of the room leader.\n","notes":"The number of points that each participant from the example earns, are as follows: \n  Petr \u2014 3860  tourist \u2014 4140  Egor \u2014 4030  c00lH4x0R \u2014 -350  some_participant \u2014 2220 Thus, the leader of the room is tourist.\n","sample_inputs":["5\nPetr 3 1 490 920 1000 1200 0\ntourist 2 0 490 950 1100 1400 0\nEgor 7 0 480 900 950 0 1000\nc00lH4x0R 0 10 150 0 0 0 0\nsome_participant 2 1 450 720 900 0 0\n"],"sample_outputs":["tourist"],"id":"74-A","difficulty":1000,"tags":["implementation"],"src_uid":"b9dacff0cab78595296d697d22dce5d9","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nstruct Participant {\\n    std::string handle;\\n    int plus;\\n    int minus;\\n    int a;\\n    int b;\\n    int c;\\n    int d;\\n    int e;\\n    int totalPoints;\\n};\\n\\nbool compareParticipants(const Participant& p1, const Participant& p2) {\\n    return p1.totalPoints > p2.totalPoints;\\n}\\n\\nint main() {\\n    int n;\\n    std::cin >> n;\\n    std::vector<Participant> participants(n);\\n\\n    for (int i = 0; i < n; i++) {\\n        std::cin >> participants[i].handle >> participants[i].plus >> participants[i].minus >> participants[i].a >> participants[i].b >> participants[i].c >> participants[i].d >> participants[i].e;\\n        participants[i].totalPoints = participants[i].a + participants[i].b + participants[i].c + participants[i].d + participants[i].e + (participants[i].plus * 100) - (participants[i].minus * 50);\\n    }\\n\\n    std::sort(participants.begin(), participants.end(), compareParticipants);\\n\\n    std::cout << participants[0].handle << std::endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class RoomLeader {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.nextLine();\\n\\n        String leader = \\\"\\\";\\n        int maxPoints = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < n; i++) {\\n            String[] participant = scanner.nextLine().split(\\\" \\\");\\n            String handle = participant[0];\\n            int plus = Integer.parseInt(participant[1]);\\n            int minus = Integer.parseInt(participant[2]);\\n            int a = Integer.parseInt(participant[3]);\\n            int b = Integer.parseInt(participant[4]);\\n            int c = Integer.parseInt(participant[5]);\\n            int d = Integer.parseInt(participant[6]);\\n            int e = Integer.parseInt(participant[7]);\\n\\n            int points = plus * 100 - minus * 50 + a + b + c + d + e;\\n\\n            if (points > maxPoints) {\\n                maxPoints = points;\\n                leader = handle;\\n            }\\n        }\\n\\n        System.out.println(leader);\\n    }\\n}","Python":"def find_leader(n, contestants):\\n    max_points = -1\\n    leader = ''\\n    for contestant in contestants:\\n        handle, plus, minus, a, b, c, d, e = contestant\\n        points = plus * 100 - minus * 50 + a + b + c + d + e\\n        if points > max_points:\\n            max_points = points\\n            leader = handle\\n    return leader\\n\\ninput_str = '5\\\\nPetr 3 1 490 920 1000 1200 0\\\\ntourist 2 0 490 950 1100 1400 0\\\\nEgor 7 0 480 900 950 0 1000\\\\nc00lH4x0R 0 10 150 0 0 0 0\\\\nsome_participant 2 1 450 720 900 0 0\\\\n'\\ninput_lines = input_str.strip().split('\\\\n')\\nn = int(input_lines[0])\\ncontestants = []\\nfor line in input_lines[1:]:\\n    contestants.append(line.split())\\n\\nresult = find_leader(n, contestants)\\nprint(result)","C":"#include <stdio.h>\\n#include <string.h>\\n\\nstruct Participant {\\n    char handle[21];\\n    int plus;\\n    int minus;\\n    int a;\\n    int b;\\n    int c;\\n    int d;\\n    int e;\\n    int points;\\n};\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n\\n    struct Participant participants[n];\\n\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s %d %d %d %d %d %d %d\\\", participants[i].handle, &participants[i].plus, &participants[i].minus, &participants[i].a, &participants[i].b, &participants[i].c, &participants[i].d, &participants[i].e);\\n\\n        participants[i].points = participants[i].a + participants[i].b + participants[i].c + participants[i].d + participants[i].e + (participants[i].plus * 100) - (participants[i].minus * 50);\\n    }\\n\\n    int maxPoints = participants[0].points;\\n    int leaderIndex = 0;\\n\\n    for (int i = 1; i < n; i++) {\\n        if (participants[i].points > maxPoints) {\\n            maxPoints = participants[i].points;\\n            leaderIndex = i;\\n        }\\n    }\\n\\n    printf(\\\"%s\\\", participants[leaderIndex].handle);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace CodeforcesLeader\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<Participant> participants = new List<Participant>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                string handle = input[0];\n                int plus = int.Parse(input[1]);\n                int minus = int.Parse(input[2]);\n                int a = int.Parse(input[3]);\n                int b = int.Parse(input[4]);\n                int c = int.Parse(input[5]);\n                int d = int.Parse(input[6]);\n                int e = int.Parse(input[7]);\n\n                Participant participant = new Participant(handle, plus, minus, a, b, c, d, e);\n                participants.Add(participant);\n            }\n\n            Participant leader = participants.OrderByDescending(p => p.GetTotalPoints()).First();\n            Console.WriteLine(leader.Handle);\n        }\n    }\n\n    class Participant\n    {\n        public string Handle { get; set; }\n        public int Plus { get; set; }\n        public int Minus { get; set; }\n        public int A { get; set; }\n        public int B { get; set; }\n        public int C { get; set; }\n        public int D { get; set; }\n        public int E { get; set; }\n\n        public Participant(string handle, int plus, int minus, int a, int b, int c, int d, int e)\n        {\n            Handle = handle;\n            Plus = plus;\n            Minus = minus;\n            A = a;\n            B = b;\n            C = c;\n            D = d;\n            E = e;\n        }\n\n        public int GetTotalPoints()\n        {\n            int totalPoints = A + B + C + D + E + (Plus * 100) - (Minus * 50);\n            return totalPoints;\n        }\n    }\n}","Ruby":"\n# Read the number of contestants\nn = gets.to_i\n\n# Initialize variables to store the maximum points and the handle of the leader\nmax_points = 0\nleader_handle = ''\n\n# Iterate over each contestant\nn.times do\n  # Read the input for each contestant\n  input = gets.chomp.split(' ')\n  handle = input[0]\n  plus = input[1].to_i\n  minus = input[2].to_i\n  points = input[3..7].map(&:to_i)\n\n  # Calculate the total points for the contestant\n  total_points = points.sum + plus * 100 - minus * 50\n\n  # Check if the contestant has more points than the current leader\n  if total_points > max_points\n    max_points = total_points\n    leader_handle = handle\n  end\nend\n\n# Print the handle of the leader\nputs leader_handle\n","delphi":"program RoomLeader;\\n\\nvar\\n  n, i, maxPoints, maxIndex: integer;\\n  handle, leader: string;\\n  plus, minus, a, b, c, d, e, points: array[1..50] of integer;\\n\\nbegin\\n  readln(n);\\n  maxPoints := -1;\\n\\n  for i := 1 to n do\\n  begin\\n    readln(handle, plus[i], minus[i], a[i], b[i], c[i], d[i], e[i]);\\n    points[i] := plus[i] * 100 - minus[i] * 50 + a[i] + b[i] + c[i] + d[i] + e[i];\\n\\n    if points[i] > maxPoints then\\n    begin\\n      maxPoints := points[i];\\n      maxIndex := i;\\n    end;\\n  end;\\n\\n  leader := handle[maxIndex];\\n  writeln(leader);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn := scanner.Text()\\n\\n\\tvar maxPoints int\\n\\tvar leader string\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tparts := strings.Split(scanner.Text(), \\\" \\\")\\n\\t\\thandle := parts[0]\\n\\t\\tplus := parts[1]\\n\\t\\tminus := parts[2]\\n\\t\\ta := parts[3]\\n\\t\\tb := parts[4]\\n\\t\\tc := parts[5]\\n\\t\\td := parts[6]\\n\\t\\te := parts[7]\\n\\n\\t\\taPoints := 0\\n\\t\\tbPoints := 0\\n\\t\\tcPoints := 0\\n\\t\\tdPoints := 0\\n\\t\\tePoints := 0\\n\\n\\t\\tif a != \\\"0\\\" {\\n\\t\\t\\taPoints = 150 + a\\n\\t\\t}\\n\\t\\tif b != \\\"0\\\" {\\n\\t\\t\\tbPoints = 300 + b\\n\\t\\t}\\n\\t\\tif c != \\\"0\\\" {\\n\\t\\t\\tcPoints = 450 + c\\n\\t\\t}\\n\\t\\tif d != \\\"0\\\" {\\n\\t\\t\\tdPoints = 600 + d\\n\\t\\t}\\n\\t\\tif e != \\\"0\\\" {\\n\\t\\t\\tePoints = 750 + e\\n\\t\\t}\\n\\n\\t\\thackPoints := plus*100 - minus*50\\n\\t\\ttotalPoints := aPoints + bPoints + cPoints + dPoints + ePoints + hackPoints\\n\\n\\t\\tif totalPoints > maxPoints {\\n\\t\\t\\tmaxPoints = totalPoints\\n\\t\\t\\tleader = handle\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(leader)\\n}","Javascript":"function findLeader(input) {\n  \/\/ Parse the input\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const contestants = lines.slice(1).map(line => {\n    const [handle, plus, minus, a, b, c, d, e] = line.split(' ');\n    return {\n      handle,\n      plus: parseInt(plus),\n      minus: parseInt(minus),\n      a: parseInt(a),\n      b: parseInt(b),\n      c: parseInt(c),\n      d: parseInt(d),\n      e: parseInt(e)\n    };\n  });\n\n  \/\/ Calculate the total points for each contestant\n  contestants.forEach(contestant => {\n    contestant.totalPoints = contestant.a + contestant.b + contestant.c + contestant.d + contestant.e + (contestant.plus * 100) - (contestant.minus * 50);\n  });\n\n  \/\/ Find the contestant with the maximum points\n  let leader = contestants[0];\n  for (let i = 1; i < n; i++) {\n    if (contestants[i].totalPoints > leader.totalPoints) {\n      leader = contestants[i];\n    }\n  }\n\n  \/\/ Return the handle of the leader\n  return leader.handle;\n}\n\nconst input = '5\\\\nPetr 3 1 490 920 1000 1200 0\\\\ntourist 2 0 490 950 1100 1400 0\\\\nEgor 7 0 480 900 950 0 1000\\\\nc00lH4x0R 0 10 150 0 0 0 0\\\\nsome_participant 2 1 450 720 900 0 0\\\\n';\nconst leader = findLeader(input);\nconsole.log(leader);\n","Kotlin":"import java.util.*\n\ndata class Contestant(val handle: String, val plus: Int, val minus: Int, val points: Int)\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val n = sc.nextInt()\n    val contestants = mutableListOf<Contestant>()\n    \n    for (i in 0 until n) {\n        val handle = sc.next()\n        val plus = sc.nextInt()\n        val minus = sc.nextInt()\n        val a = sc.nextInt()\n        val b = sc.nextInt()\n        val c = sc.nextInt()\n        val d = sc.nextInt()\n        val e = sc.nextInt()\n        \n        val points = a + b + c + d + e + (plus * 100) - (minus * 50)\n        contestants.add(Contestant(handle, plus, minus, points))\n    }\n    \n    val leader = contestants.maxBy { it.points }\n    println(leader?.handle)\n}","PHP":"<?php\\n\\n$input = '5\\nPetr 3 1 490 920 1000 1200 0\\ntourist 2 0 490 950 1100 1400 0\\nEgor 7 0 480 900 950 0 1000\\nc00lH4x0R 0 10 150 0 0 0 0\\nsome_participant 2 1 450 720 900 0 0\\n';\\n\\nfunction findLeader($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $n = (int)$lines[0];\\n    $participants = [];\\n\\n    for ($i = 1; $i <= $n; $i++) {\\n        $participant = explode(\\\" \\\", $lines[$i]);\\n        $handle = $participant[0];\\n        $plus = (int)$participant[1];\\n        $minus = (int)$participant[2];\\n        $points = array_slice($participant, 3);\\n        $totalPoints = array_sum($points) + $plus * 100 - $minus * 50;\\n        $participants[$handle] = $totalPoints;\\n    }\\n\\n    arsort($participants);\\n    $leader = key($participants);\\n\\n    return $leader;\\n}\\n\\n$leader = findLeader($input);\\n\\n$output = json_encode([$leader]);\\necho $output;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nstruct Contestant {\\r\\n    string handle;\\r\\n    int plus;\\r\\n    int minus;\\r\\n    int[] problems;\\r\\n    int points;\\r\\n}\\r\\n\\r\\nstring findLeader(int n, Contestant[] contestants) {\\r\\n    Contestant leader;\\r\\n    foreach (contestant; contestants) {\\r\\n        int contestantPoints = 0;\\r\\n        foreach (points; contestant.problems) {\\r\\n            contestantPoints += points;\\r\\n        }\\r\\n        contestantPoints += contestant.plus * 100 - contestant.minus * 50;\\r\\n        if (contestantPoints > leader.points) {\\r\\n            leader = contestant;\\r\\n        }\\r\\n    }\\r\\n    return leader.handle;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    Contestant[] contestants;\\r\\n    foreach (_; 0 .. n) {\\r\\n        string handle;\\r\\n        int plus;\\r\\n        int minus;\\r\\n        int[] problems;\\r\\n        foreach (i; 0 .. 5) {\\r\\n            int points;\\r\\n            readf(\\\"%d\\\", &points);\\r\\n            problems ~= points;\\r\\n        }\\r\\n        contestants ~= Contestant(handle, plus, minus, problems, 0);\\r\\n    }\\r\\n    writeln(findLeader(n, contestants));\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nmy $n = <>;\nchomp($n);\n\nmy $leader;\nmy $max_points = -1;\n\nfor (my $i = 0; $i < $n; $i++) {\n    my $line = <>;\n    chomp($line);\n    \n    my ($handle, $plus, $minus, $a, $b, $c, $d, $e) = split(' ', $line);\n    \n    my $points = $plus * 100 - $minus * 50 + $a + $b + $c + $d + $e;\n    \n    if ($points > $max_points) {\n        $leader = $handle;\n        $max_points = $points;\n    }\n}\n\nprint $leader;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    \n    let mut max_points = 0;\n    let mut leader = String::new();\n    \n    for _ in 0..n {\n        let line = lines.next().unwrap();\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        \n        let handle = parts[0];\n        let plus = parts[1].parse::<i32>().unwrap();\n        let minus = parts[2].parse::<i32>().unwrap();\n        let a = parts[3].parse::<i32>().unwrap();\n        let b = parts[4].parse::<i32>().unwrap();\n        let c = parts[5].parse::<i32>().unwrap();\n        let d = parts[6].parse::<i32>().unwrap();\n        let e = parts[7].parse::<i32>().unwrap();\n        \n        let points = plus * 100 - minus * 50 + a + b + c + d + e;\n        \n        if points > max_points {\n            max_points = points;\n            leader = handle.to_string();\n        }\n    }\n    \n    println!(\"{}\", leader);\n}"}
{"title":"C. Chessboard Billiard","description":"Let's imagine: there is a chess piece billiard ball. Its movements resemble the ones of a bishop chess piece. The only difference is that when a billiard ball hits the board's border, it can reflect from it and continue moving.More formally, first one of four diagonal directions is chosen and the billiard ball moves in that direction. When it reaches the square located on the board's edge, the billiard ball reflects from it; it changes the direction of its movement by 90 degrees and continues moving. Specifically, having reached a corner square, the billiard ball is reflected twice and starts to move the opposite way. While it moves, the billiard ball can make an infinite number of reflections. At any square of its trajectory the billiard ball can stop and on that the move is considered completed. It is considered that one billiard ball a beats another billiard ball b if a can reach a point where b is located.You are suggested to find the maximal number of billiard balls, that pairwise do not beat each other and that can be positioned on a chessboard n\u00d7m in size.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m (2\u2264n,m\u226410^6).\n","output_spec":"Print a single number, the maximum possible number of billiard balls that do not pairwise beat each other.\nPlease do not use the %lld specificator to read or write 64-bit numbers in C++. It is preferred to use cin (also you may use the %I64d specificator).\n","notes":null,"sample_inputs":["3 4\n","3 3\n"],"sample_outputs":["2","3"],"id":"74-C","difficulty":2100,"tags":["dfs+and+similar","dsu","graphs","number+theory"],"src_uid":"05f251de93536024c05fbd77ed01b70b","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    int ans = min(n, m) + 1;\\n    cout << ans << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class BilliardBalls {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n\\n        \/\/ Calculate the maximum number of billiard balls\\n        int maxBalls = Math.min(n, m);\\n\\n        System.out.println(maxBalls);\\n    }\\n}","Python":"def max_billiard_balls(n, m):\\n    return (n * m + 1) \/\/ 2\\n\\nn, m = map(int, input().split())\\nprint(max_billiard_balls(n, m))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    printf(\\\"%d\\\", (n * m + 1) \/ 2);\\n    return 0;\\n}","C#":"using System;\n\nnamespace BilliardBalls\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            \/\/ Calculate the maximum number of billiard balls that can be positioned on the chessboard\n            long maxBalls = (long)Math.Min(n, m);\n\n            Console.WriteLine(maxBalls);\n        }\n    }\n}","Ruby":"\ndef max_billiard_balls(n, m)\n  # If either n or m is 2, the maximum number of billiard balls is 2\n  return 2 if n == 2 || m == 2\n\n  # If both n and m are odd, the maximum number of billiard balls is 2\n  return 2 if n.odd? && m.odd?\n\n  # Otherwise, the maximum number of billiard balls is 1\n  return 1\nend\n\n# Read input\nn, m = gets.chomp.split.map(&:to_i)\n\n# Calculate and print the maximum number of billiard balls\nputs max_billiard_balls(n, m)\n","delphi":"program BilliardBalls;\\n\\nvar\\n  n, m: Integer;\\n  maxBalls: Int64;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(n, m);\\n\\n  \/\/ Calculate maximum number of balls\\n  maxBalls := (n div 2) * (m div 2) + ((n + 1) div 2) * ((m + 1) div 2);\\n\\n  \/\/ Print the result\\n  WriteLn(maxBalls);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\t\/\/ Calculate the maximum number of billiard balls\\n\\tmaxBalls := (n * m + 1) \/ 2\\n\\n\\tfmt.Println(maxBalls)\\n}","Javascript":"function maxBalls(n, m) {\n    return Math.min(n, m);\n}\n\nconst input = '3 4\\n';\nconst [n, m] = input.trim().split(' ').map(Number);\n\nconst output = maxBalls(n, m);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n    \n    \/\/ Calculate the maximum number of billiard balls that can be positioned on the chessboard\n    val maxBalls = calculateMaxBalls(n, m)\n    \n    println(maxBalls)\n}\n\nfun calculateMaxBalls(n: Int, m: Int): Long {\n    \/\/ The maximum number of billiard balls that can be positioned on a chessboard is equal to the minimum of n and m\n    return Math.min(n, m).toLong()\n}","PHP":"<?php\\n\\nfunction maxBalls($n, $m) {\\n    return min($n, $m) + 1;\\n}\\n\\n\/\/ Read input from stdin\\n$stdin = fopen('php:\/\/stdin', 'r');\\nlist($n, $m) = explode(' ', trim(fgets($stdin)));\\n\\n\/\/ Call the function and print the result\\n$result = maxBalls($n, $m);\\necho $result;\\n\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    \/\/ Calculate the maximum number of billiard balls\\r\\n    int maxBalls = (n * m + 1) \/ 2;\\r\\n\\r\\n    writeln(maxBalls);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub max_billiard_balls {\n    my ($n, $m) = @_;\n\n    # If either dimension is 2, the maximum number of billiard balls is 2\n    return 2 if $n == 2 || $m == 2;\n\n    # If either dimension is 3, the maximum number of billiard balls is 3\n    return 3 if $n == 3 || $m == 3;\n\n    # For all other dimensions, the maximum number of billiard balls is 4\n    return 4;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\n# Calculate the maximum number of billiard balls\nmy $max_billiard_balls = max_billiard_balls($n, $m);\n\n# Print the result\nprint $max_billiard_balls;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut iter = input.trim().split_whitespace();\\n    let n: i64 = iter.next().unwrap().parse().unwrap();\\n    let m: i64 = iter.next().unwrap().parse().unwrap();\\n\\n    let gcd = gcd(n, m);\\n    let result = (gcd - 1) * 2 + 1;\\n\\n    println!(\\\"{}\\\", result);\\n}\\n\\nfn gcd(a: i64, b: i64) -> i64 {\\n    if b == 0 {\\n        a\\n    } else {\\n        gcd(b, a % b)\\n    }\\n}"}
{"title":"A. New Year and Hurry","description":"Limak is going to participate in a contest on the last day of the 2016. The contest will start at 20:00 and will last four hours, exactly until midnight. There will be n problems, sorted by difficulty, i.e. problem 1 is the easiest and problem n is the hardest. Limak knows it will take him 5\u00b7i minutes to solve the i-th problem.Limak's friends organize a New Year's Eve party and Limak wants to be there at midnight or earlier. He needs k minutes to get there from his house, where he will participate in the contest first.How many problems can Limak solve if he wants to make it to the party?","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The only line of the input contains two integers n and k (1\u2264n\u226410, 1\u2264k\u2264240)\u00a0\u2014 the number of the problems in the contest and the number of minutes Limak needs to get to the party from his house.\n","output_spec":"Print one integer, denoting the maximum possible number of problems Limak can solve so that he could get to the party at midnight or earlier.\n","notes":"In the first sample, there are 3 problems and Limak needs 222 minutes to get to the party. The three problems require 5, 10 and 15 minutes respectively. Limak can spend 5+10=15 minutes to solve first two problems. Then, at 20:15 he can leave his house to get to the party at 23:57 (after 222 minutes). In this scenario Limak would solve 2 problems. He doesn't have enough time to solve 3 problems so the answer is 2.\nIn the second sample, Limak can solve all 4 problems in 5+10+15+20=50 minutes. At 20:50 he will leave the house and go to the party. He will get there exactly at midnight.\nIn the third sample, Limak needs only 1 minute to get to the party. He has enough time to solve all 7 problems.\n","sample_inputs":["3 222\n","4 190\n","7 1\n"],"sample_outputs":["2\n","4\n","7\n"],"id":"750-A","difficulty":800,"tags":["binary+search","brute+force","implementation","math"],"src_uid":"41e554bc323857be7b8483ee358a35e2","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<int> problems(n);\\n    for (int i = 0; i < n; i++) {\\n        problems[i] = 5 * (i + 1);\\n    }\\n    int totalTime = 240 - k;\\n    int solvedProblems = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (totalTime >= problems[i]) {\\n            totalTime -= problems[i];\\n            solvedProblems++;\\n        } else {\\n            break;\\n        }\\n    }\\n    cout << solvedProblems << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        int totalTime = 240 - k;\\n        int problemsSolved = 0;\\n        int timeNeeded = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            timeNeeded += 5 * i;\\n            if (timeNeeded <= totalTime) {\\n                problemsSolved++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        System.out.println(problemsSolved);\\n    }\\n}","Python":"def max_problems(n, k):\\n    total_time = 240 - k\\n    problems_solved = 0\\n    for i in range(1, n+1):\\n        problem_time = 5 * i\\n        if total_time - problem_time >= 0:\\n            total_time -= problem_time\\n            problems_solved += 1\\n        else:\\n            break\\n    return problems_solved\\n\\ninput_data = input().split()\\nn = int(input_data[0])\\nk = int(input_data[1])\\n\\nresult = max_problems(n, k)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int totalTime = 240 - k;\\n    int problemsSolved = 0;\\n    int timeNeeded = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        timeNeeded += 5 * i;\\n\\n        if (timeNeeded <= totalTime) {\\n            problemsSolved++;\\n        } else {\\n            break;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", problemsSolved);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] inputs = { \\\"3 222\\\", \\\"4 190\\\", \\\"7 1\\\" };\n        string[] outputs = { \\\"2\\\", \\\"4\\\", \\\"7\\\" };\n        \n        for (int i = 0; i < inputs.Length; i++)\n        {\n            string[] input = inputs[i].Split(' ');\n            int n = int.Parse(input[0]);\n            int k = int.Parse(input[1]);\n            \n            int totalTime = 240 - k;\n            int problemsSolved = 0;\n            \n            for (int j = 1; j <= n; j++)\n            {\n                int problemTime = 5 * j;\n                \n                if (totalTime >= problemTime)\n                {\n                    totalTime -= problemTime;\n                    problemsSolved++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            Console.WriteLine(problemsSolved.ToString());\n        }\n    }\n}","Ruby":"\ndef max_problems(n, k)\n  time_left = 240 - k\n  problems_solved = 0\n  i = 1\n\n  while i <= n && time_left >= 5 * i\n    time_left -= 5 * i\n    problems_solved += 1\n    i += 1\n  end\n\n  return problems_solved\nend\n\ninputs = ['3 222\\n', '4 190\\n', '7 1\\n']\noutputs = []\n\ninputs.each do |input|\n  n, k = input.split.map(&:to_i)\n  result = max_problems(n, k)\n  outputs << result.to_s\nend\n\nputs outputs\n","delphi":"program ContestProblems;\\n\\nvar\\n  n, k, i, totalTime, problemsSolved: integer;\\nbegin\\n  readln(n, k);\\n  totalTime := 0;\\n  problemsSolved := 0;\\n\\n  for i := 1 to n do\\n  begin\\n    totalTime := totalTime + (5 * i);\\n    if totalTime + k <= 240 then\\n      problemsSolved := i\\n    else\\n      break;\\n  end;\\n\\n  writeln(problemsSolved);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\n\\ttotalTime := 240 - k\\n\\tsolvedProblems := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tproblemTime := 5 * i\\n\\t\\tif totalTime >= problemTime {\\n\\t\\t\\ttotalTime -= problemTime\\n\\t\\t\\tsolvedProblems++\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(solvedProblems)\\n}","Javascript":"function maxProblems(n, k) {\n    let totalTime = 240 - k;\n    let problemsSolved = 0;\n    let timeTaken = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        timeTaken += 5 * i;\n        \n        if (timeTaken <= totalTime) {\n            problemsSolved++;\n        } else {\n            break;\n        }\n    }\n    \n    return problemsSolved;\n}\n\nconst inputs = [['3 222\\n'], ['4 190\\n'], ['7 1\\n']];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    const [n, k] = inputs[i][0].split(' ').map(Number);\n    const result = maxProblems(n, k);\n    outputs.push(result + '\\\\n');\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val k = input[1].toInt()\n\n    var totalTime = 0\n    var solvedProblems = 0\n\n    for (i in 1..n) {\n        totalTime += 5 * i\n        if (totalTime + k <= 240) {\n            solvedProblems++\n        } else {\n            break\n        }\n    }\n\n    println(solvedProblems)\n}","PHP":"\n<?php\n\n\/\/ Read the input values\n$input = explode(' ', trim(fgets(STDIN)));\n$n = intval($input[0]);\n$k = intval($input[1]);\n\n\/\/ Calculate the maximum number of problems Limak can solve\n$maxProblems = 0;\n$totalTime = 0;\nfor ($i = 1; $i <= $n; $i++) {\n    $problemTime = 5 * $i;\n    $totalTime += $problemTime;\n    \n    \/\/ Check if Limak can solve the current problem and still make it to the party\n    if ($totalTime + $k <= 240) {\n        $maxProblems++;\n    } else {\n        break;\n    }\n}\n\n\/\/ Print the result\necho $maxProblems;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    readf(\\\"%d %d\\\", &n, &k);\\r\\n\\r\\n    int totalTime = 240 - k;\\r\\n    int problemsSolved = 0;\\r\\n\\r\\n    for (int i = 1; i <= n; i++)\\r\\n    {\\r\\n        int problemTime = 5 * i;\\r\\n        totalTime -= problemTime;\\r\\n\\r\\n        if (totalTime >= 0)\\r\\n        {\\r\\n            problemsSolved++;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(problemsSolved);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nmy $input = <>;\nchomp $input;\nmy ($n, $k) = split ' ', $input;\n\nmy $time_left = 240 - $k;\nmy $problems_solved = 0;\nmy $time_required = 0;\n\nfor (my $i = 1; $i <= $n; $i++) {\n    $time_required += 5 * $i;\n    if ($time_required <= $time_left) {\n        $problems_solved++;\n    } else {\n        last;\n    }\n}\n\nprint $problems_solved;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let input: Vec<i32> = input.split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = input[0];\n    let k = input[1];\n    \n    let mut time_needed = 0;\n    let mut problems_solved = 0;\n    \n    for i in 1..=n {\n        time_needed += 5 * i;\n        if time_needed + k <= 240 {\n            problems_solved += 1;\n        } else {\n            break;\n        }\n    }\n    \n    println!(\"{}\", problems_solved);\n}"}
{"title":"C. Unfair Poll","description":"On the Literature lesson Sergei noticed an awful injustice, it seems that some students are asked more often than others.Seating in the class looks like a rectangle, where n rows with m pupils in each. The teacher asks pupils in the following order: at first, she asks all pupils from the first row in the order of their seating, then she continues to ask pupils from the next row. If the teacher asked the last row, then the direction of the poll changes, it means that she asks the previous row. The order of asking the rows looks as follows: the 1-st row, the 2-nd row, ..., the n-1-st row, the n-th row, the n-1-st row, ..., the 2-nd row, the 1-st row, the 2-nd row, ...The order of asking of pupils on the same row is always the same: the 1-st pupil, the 2-nd pupil, ..., the m-th pupil.During the lesson the teacher managed to ask exactly k questions from pupils in order described above. Sergei seats on the x-th row, on the y-th place in the row. Sergei decided to prove to the teacher that pupils are asked irregularly, help him count three values:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. If there is only one row in the class, then the teacher always asks children from this row.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first and the only line contains five integers n, m, k, x and y (1\u2264n,m\u2264100,1\u2264k\u226410^18,1\u2264x\u2264n,1\u2264y\u2264m).\n","output_spec":"Print three integers:\n  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. ","notes":"The order of asking pupils in the first test: \n  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table; The order of asking pupils in the second test: \n  the pupil from the first row who seats at the first table;  the pupil from the first row who seats at the second table;  the pupil from the second row who seats at the first table;  the pupil from the second row who seats at the second table;  the pupil from the third row who seats at the first table;  the pupil from the third row who seats at the second table;  the pupil from the fourth row who seats at the first table;  the pupil from the fourth row who seats at the second table, it means it is Sergei;  the pupil from the third row who seats at the first table; ","sample_inputs":["1 3 8 1 1\n","4 2 9 4 2\n","5 5 25 4 3\n","100 100 1000000000000000000 100 100\n"],"sample_outputs":["3 2 3","2 1 1","1 1 1","101010101010101 50505050505051 50505050505051"],"id":"758-C","difficulty":1700,"tags":["binary+search","constructive+algorithms","implementation","math"],"src_uid":"e61debcad37eaa9a6e21d7a2122b8b21","C++":"#include <iostream>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m, k, x, y;\\n    cin >> n >> m >> k >> x >> y;\\n\\n    long long maxQuestions = 0;\\n    long long minQuestions = 1e18;\\n    long long sergQuestions = 0;\\n\\n    if (n == 1) {\\n        long long rowQuestions = k \/ m;\\n        long long remainingQuestions = k % m;\\n\\n        if (remainingQuestions > 0) {\\n            rowQuestions++;\\n            if (y <= remainingQuestions) {\\n                sergQuestions = 1;\\n            }\\n        }\\n\\n        maxQuestions = rowQuestions;\\n        minQuestions = rowQuestions;\\n    } else {\\n        long long cycle = 2 * (n - 1);\\n        long long fullCycles = k \/ cycle;\\n        long long remainingQuestions = k % cycle;\\n\\n        if (remainingQuestions > 0) {\\n            fullCycles++;\\n            if (remainingQuestions <= n) {\\n                maxQuestions = fullCycles;\\n                minQuestions = fullCycles;\\n                if (x == remainingQuestions && y <= m) {\\n                    sergQuestions = 1;\\n                }\\n            } else if (remainingQuestions <= cycle) {\\n                maxQuestions = fullCycles + 1;\\n                minQuestions = fullCycles;\\n                if (x == n && y <= m) {\\n                    sergQuestions = 1;\\n                }\\n            } else {\\n                maxQuestions = fullCycles;\\n                minQuestions = fullCycles;\\n                if (x == n && y <= m) {\\n                    sergQuestions = 1;\\n                }\\n            }\\n        } else {\\n            maxQuestions = fullCycles;\\n            minQuestions = fullCycles;\\n        }\\n    }\\n\\n    cout << maxQuestions << \\\" \\\" << minQuestions << \\\" \\\" << sergQuestions << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int m = scanner.nextInt();\\n        long k = scanner.nextLong();\\n        int x = scanner.nextInt();\\n        int y = scanner.nextInt();\\n\\n        long totalPupils = (long) n * m;\\n        long fullCycles = k \/ totalPupils;\\n        long remainingQuestions = k % totalPupils;\\n\\n        long maxQuestions = fullCycles;\\n        long minQuestions = fullCycles;\\n        long sergQuestions = fullCycles;\\n\\n        if (remainingQuestions > 0) {\\n            if (remainingQuestions >= (n - x) * m + y) {\\n                maxQuestions++;\\n            }\\n\\n            if (remainingQuestions >= (n - x - 1) * m + y) {\\n                minQuestions++;\\n            }\\n\\n            if (remainingQuestions >= (n - x) * m + y && remainingQuestions <= (n - x + 1) * m + y) {\\n                sergQuestions++;\\n            }\\n        }\\n\\n        System.out.println(maxQuestions + \\\" \\\" + minQuestions + \\\" \\\" + sergQuestions);\\n    }\\n}","Python":"def count_questions(n, m, k, x, y):\n    if n == 1:\n        max_questions = k \/\/ m\n        min_questions = max_questions\n        serg_questions = k \/\/ m if y <= k % m else k \/\/ m + 1\n    else:\n        cycle_length = 2 * (n - 1)\n        full_cycles = k \/\/ cycle_length\n        remaining_questions = k % cycle_length\n        \n        max_questions = full_cycles * m\n        min_questions = max_questions\n        \n        if remaining_questions > 0:\n            max_questions += min(remaining_questions, m)\n            min_questions += min(remaining_questions, m - 1)\n        \n        serg_questions = full_cycles + 1 if x == 1 else full_cycles\n        \n        if remaining_questions > 0:\n            if x <= remaining_questions:\n                serg_questions += 1\n            elif x <= m:\n                serg_questions += 1\n        \n    return f'{max_questions} {min_questions} {serg_questions}'\n\n# Sample Inputs\ninputs = ['1 3 8 1 1\\n', '4 2 9 4 2\\n', '5 5 25 4 3\\n', '100 100 1000000000000000000 100 100\\n']\n\n# Process each input and generate output\noutputs = []\nfor input_str in inputs:\n    n, m, k, x, y = map(int, input_str.strip().split())\n    output = count_questions(n, m, k, x, y)\n    outputs.append(output)\n\n# Print the outputs\nfor output in outputs:\n    print(output)\n","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m, k, x, y;\\n    scanf(\\\"%d %d %d %d %d\\\", &n, &m, &k, &x, &y);\\n\\n    int max_questions = (k - 1) \/ (2 * n * m) + 1;\\n    int min_questions = k \/ (2 * n * m);\\n    int serg_questions = 0;\\n\\n    if (k % (2 * n * m) >= (2 * x - 1) * m + y) {\\n        serg_questions++;\\n    }\\n\\n    printf(\\\"%d %d %d\\\", max_questions, min_questions, serg_questions);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace CodeDeveloper\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n            long k = long.Parse(input[2]);\n            int x = int.Parse(input[3]);\n            int y = int.Parse(input[4]);\n\n            long totalPupils = n * m;\n            long fullCycles = k \/ totalPupils;\n            long remainingQuestions = k % totalPupils;\n\n            long maxQuestions = fullCycles;\n            long minQuestions = fullCycles;\n\n            if (remainingQuestions > 0)\n            {\n                maxQuestions++;\n                if (remainingQuestions >= (x - 1) * m + y)\n                {\n                    minQuestions++;\n                }\n            }\n\n            Console.WriteLine(maxQuestions + \" \" + minQuestions + \" \" + (x == 1 && y == 1 ? maxQuestions : 0));\n        }\n    }\n}","Ruby":"\ndef count_questions(n, m, k, x, y)\n  if n == 1\n    max_questions = k \/ m\n    min_questions = k \/ m\n    serg_questions = k \/ m\n  else\n    cycle_length = 2 * (n - 1) * m\n    full_cycles = k \/ cycle_length\n    remaining_questions = k % cycle_length\n\n    max_questions = full_cycles * m\n    min_questions = full_cycles * m\n    serg_questions = full_cycles * m\n\n    if remaining_questions > 0\n      max_questions += [remaining_questions - (n - 1) * m, 0].max\n      min_questions += [remaining_questions - (n - 1) * m, 0].max\n      serg_questions += [remaining_questions - (n - x) * m + y, 0].max\n    end\n\n    if remaining_questions > (n - 1) * m\n      max_questions += [remaining_questions - (n - 1) * m, 0].max\n      min_questions += [remaining_questions - (n - 1) * m, 0].max\n      serg_questions += [remaining_questions - (n - x) * m + y, 0].max\n    end\n  end\n\n  return max_questions, min_questions, serg_questions\nend\n\ninput = gets.chomp.split(' ').map(&:to_i)\nn, m, k, x, y = input\n\nmax_questions, min_questions, serg_questions = count_questions(n, m, k, x, y)\nputs \\\"#{max_questions} #{min_questions} #{serg_questions}\\\"\n","delphi":"program LiteratureLesson;\\n\\nvar\\n  n, m, k, x, y, maxQuestions, minQuestions, sergQuestions: Int64;\\nbegin\\n  Readln(n, m, k, x, y);\\n  maxQuestions := 0;\\n  minQuestions := MaxInt;\\n  sergQuestions := 0;\\n\\n  if n = 1 then\\n  begin\\n    maxQuestions := k div m;\\n    if k mod m <> 0 then\\n      maxQuestions := maxQuestions + 1;\\n    minQuestions := maxQuestions;\\n    sergQuestions := maxQuestions;\\n  end\\n  else\\n  begin\\n    maxQuestions := k div (2 * m * n - 2);\\n    if k mod (2 * m * n - 2) <> 0 then\\n      maxQuestions := maxQuestions + 1;\\n    minQuestions := maxQuestions;\\n    sergQuestions := maxQuestions;\\n\\n    if k >= (x - 1) * (2 * m) + y then\\n    begin\\n      sergQuestions := sergQuestions + (k - (x - 1) * (2 * m) - y) div (2 * m);\\n      if (k - (x - 1) * (2 * m) - y) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (n - x) * (2 * m) + y then\\n    begin\\n      sergQuestions := sergQuestions + (k - (n - x) * (2 * m) - y) div (2 * m);\\n      if (k - (n - x) * (2 * m) - y) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (x - 1) * (2 * m) + (m - y + 1) then\\n    begin\\n      sergQuestions := sergQuestions + (k - (x - 1) * (2 * m) - (m - y + 1)) div (2 * m);\\n      if (k - (x - 1) * (2 * m) - (m - y + 1)) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (n - x) * (2 * m) + (m - y + 1) then\\n    begin\\n      sergQuestions := sergQuestions + (k - (n - x) * (2 * m) - (m - y + 1)) div (2 * m);\\n      if (k - (n - x) * (2 * m) - (m - y + 1)) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (x - 1) * (2 * m) + y - 1 then\\n    begin\\n      sergQuestions := sergQuestions + (k - (x - 1) * (2 * m) - y + 1) div (2 * m);\\n      if (k - (x - 1) * (2 * m) - y + 1) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (n - x) * (2 * m) + y - 1 then\\n    begin\\n      sergQuestions := sergQuestions + (k - (n - x) * (2 * m) - y + 1) div (2 * m);\\n      if (k - (n - x) * (2 * m) - y + 1) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (x - 1) * (2 * m) + (m - y) then\\n    begin\\n      sergQuestions := sergQuestions + (k - (x - 1) * (2 * m) - (m - y)) div (2 * m);\\n      if (k - (x - 1) * (2 * m) - (m - y)) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (n - x) * (2 * m) + (m - y) then\\n    begin\\n      sergQuestions := sergQuestions + (k - (n - x) * (2 * m) - (m - y)) div (2 * m);\\n      if (k - (n - x) * (2 * m) - (m - y)) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (x - 1) * (2 * m) + y + 1 then\\n    begin\\n      sergQuestions := sergQuestions + (k - (x - 1) * (2 * m) - y - 1) div (2 * m);\\n      if (k - (x - 1) * (2 * m) - y - 1) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n\\n    if k >= (n - x) * (2 * m) + y + 1 then\\n    begin\\n      sergQuestions := sergQuestions + (k - (n - x) * (2 * m) - y - 1) div (2 * m);\\n      if (k - (n - x) * (2 * m) - y - 1) mod (2 * m) <> 0 then\\n        sergQuestions := sergQuestions + 1;\\n    end;\\n  end;\\n\\n  Writeln(maxQuestions, ' ', minQuestions, ' ', sergQuestions);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, k, x, y int\\n\\tfmt.Scanf(\\\"%d %d %d %d %d\\\", &n, &m, &k, &x, &y)\\n\\n\\tvar maxQuestions, minQuestions, sergQuestions int\\n\\n\\tif n == 1 {\\n\\t\\tmaxQuestions = k \/ m\\n\\t\\tminQuestions = k \/ m\\n\\t\\tsergQuestions = k \/ m\\n\\t} else {\\n\\t\\ttotalRows := n*2 - 2\\n\\t\\ttotalPupils := n * m\\n\\t\\ttotalQuestions := k \/ totalRows\\n\\t\\tremainingQuestions := k % totalRows\\n\\n\\t\\tif remainingQuestions > 0 {\\n\\t\\t\\ttotalQuestions++\\n\\t\\t}\\n\\n\\t\\tmaxQuestions = totalQuestions\\n\\t\\tminQuestions = totalQuestions\\n\\n\\t\\tif remainingQuestions > 0 {\\n\\t\\t\\tif remainingQuestions <= n {\\n\\t\\t\\t\\tmaxQuestions++\\n\\t\\t\\t\\tif x <= remainingQuestions {\\n\\t\\t\\t\\t\\tsergQuestions = totalQuestions + 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tsergQuestions = totalQuestions\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmaxQuestions += remainingQuestions - n\\n\\t\\t\\t\\tif x <= remainingQuestions-n {\\n\\t\\t\\t\\t\\tsergQuestions = totalQuestions + 1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tsergQuestions = totalQuestions\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Printf(\\\"%d %d %d\\\", maxQuestions, minQuestions, sergQuestions)\\n}","Javascript":"function countQuestions(n, m, k, x, y) {\n    let maxQuestions = Math.ceil(k \/ (n * m));\n    let minQuestions = Math.floor(k \/ (n * m));\n    let remainingQuestions = k % (n * m);\n    \n    let sergQuestions = 0;\n    if (x === 1 && y === 1) {\n        sergQuestions = maxQuestions;\n    } else {\n        sergQuestions = minQuestions;\n        if (x <= remainingQuestions) {\n            sergQuestions++;\n        }\n    }\n    \n    return [maxQuestions, minQuestions, sergQuestions].join(' ');\n}\n\nlet input = '1 3 8 1 1';\nlet [n, m, k, x, y] = input.split(' ').map(Number);\nlet result = countQuestions(n, m, k, x, y);\nconsole.log(result);","Kotlin":"import kotlin.math.min\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val m = input[1]\\n    val k = input[2]\\n    val x = input[3]\\n    val y = input[4]\\n\\n    val totalRows = if (n == 1) 1 else 2 * n - 2\\n    val totalPupils = n * m\\n\\n    val fullCycles = k \/ totalPupils\\n    val remainingQuestions = k % totalPupils\\n\\n    val maxQuestions = fullCycles + if (remainingQuestions > 0) 1 else 0\\n    val minQuestions = fullCycles\\n\\n    var sergQuestions = 0\\n\\n    if (remainingQuestions > 0) {\\n        var currentRow = 1\\n        var currentPupil = 1\\n\\n        for (i in 1..remainingQuestions) {\\n            if (currentRow == x && currentPupil == y) {\\n                sergQuestions++\\n            }\\n\\n            if (currentRow == 1 || currentRow == n) {\\n                currentPupil++\\n            } else {\\n                if (currentRow % 2 == 1) {\\n                    if (currentPupil == m) {\\n                        currentRow++\\n                    } else {\\n                        currentPupil++\\n                    }\\n                } else {\\n                    if (currentPupil == 1) {\\n                        currentRow++\\n                    } else {\\n                        currentPupil--\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    println(\\\"$maxQuestions $minQuestions $sergQuestions\\\")\\n}","PHP":"<?php\\n\\nfunction countQuestions($n, $m, $k, $x, $y) {\\n    $maxQuestions = ceil($k \/ ($n * $m));\\n    $minQuestions = floor($k \/ ($n * $m));\\n    $remainingQuestions = $k % ($n * $m);\\n    \\n    $teacherAskedSergei = 0;\\n    \\n    if ($remainingQuestions > 0) {\\n        $teacherAskedSergei = ($x - 1) * $m + $y <= $remainingQuestions ? 1 : 0;\\n    }\\n    \\n    return [$maxQuestions, $minQuestions, $teacherAskedSergei];\\n}\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$m = intval($input[1]);\\n$k = intval($input[2]);\\n$x = intval($input[3]);\\n$y = intval($input[4]);\\n\\n$result = countQuestions($n, $m, $k, $x, $y);\\necho implode(' ', $result);\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, k, x, y;\\r\\n    readf(\\\"%d %d %d %d %d\\\", &n, &m, &k, &x, &y);\\r\\n\\r\\n    int maxQuestions = 0;\\r\\n    int minQuestions = 1000000000;\\r\\n    int sergQuestions = 0;\\r\\n\\r\\n    int row = 1;\\r\\n    int direction = 1;\\r\\n\\r\\n    for (int i = 0; i < k; i++)\\r\\n    {\\r\\n        if (row == x && i % m == y - 1)\\r\\n        {\\r\\n            sergQuestions++;\\r\\n        }\\r\\n\\r\\n        if (direction == 1)\\r\\n        {\\r\\n            if (row == n)\\r\\n            {\\r\\n                direction = -1;\\r\\n                row--;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                row++;\\r\\n            }\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            if (row == 1)\\r\\n            {\\r\\n                direction = 1;\\r\\n                row++;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                row--;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    maxQuestions = (k + n - 1) \/ n;\\r\\n    minQuestions = k \/ n;\\r\\n\\r\\n    writeln(maxQuestions, \\\" \\\", minQuestions, \\\" \\\", sergQuestions);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub count_questions {\\n    my ($n, $m, $k, $x, $y) = @_;\\n\\n    my $num_rows = $n;\\n    my $num_pupils = $m;\\n\\n    my $num_rounds = int($k \/ ($num_rows * $num_pupils * 2 - 2));\\n    my $remaining_questions = $k % ($num_rows * $num_pupils * 2 - 2);\\n\\n    my $max_questions = $num_rounds * 2;\\n    my $min_questions = $num_rounds;\\n    my $sergei_questions = 0;\\n\\n    if ($remaining_questions > 0) {\\n        $max_questions += 1;\\n        $min_questions += 1;\\n\\n        if ($remaining_questions <= $num_pupils) {\\n            $sergei_questions = 1;\\n        } else {\\n            $sergei_questions = 2;\\n        }\\n    }\\n\\n    return \\\"$max_questions $min_questions $sergei_questions\\\";\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $m, $k, $x, $y) = split ' ', $input;\\n\\n# Call function and print output\\nmy $output = count_questions($n, $m, $k, $x, $y);\\nprint \\\"$output\\\\n\\\";\\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let input: Vec<usize> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    let n = input[0];\n    let m = input[1];\n    let k = input[2];\n    let x = input[3];\n    let y = input[4];\n\n    let mut max_questions = 0;\n    let mut min_questions = std::usize::MAX;\n    let mut serg_questions = 0;\n\n    if n == 1 {\n        let row_questions = k \/ m;\n        let remainder = k % m;\n        if remainder > 0 {\n            max_questions = row_questions + 1;\n            min_questions = row_questions + 1;\n            if y <= remainder {\n                serg_questions = row_questions + 1;\n            }\n        } else {\n            max_questions = row_questions;\n            min_questions = row_questions;\n        }\n    } else {\n        let cycle_length = 2 * (n - 1) * m;\n        let full_cycles = k \/ cycle_length;\n        let remainder = k % cycle_length;\n\n        let mut row_questions = full_cycles * m;\n        let mut curr_row = 1;\n        let mut curr_col = 1;\n        let mut direction = 1;\n\n        for _ in 0..remainder {\n            if curr_row == x && curr_col == y {\n                serg_questions += 1;\n            }\n            if curr_row == 1 && direction == -1 {\n                row_questions += 1;\n            }\n            if curr_row == n && direction == 1 {\n                row_questions += 1;\n            }\n            curr_col += direction;\n            if curr_col == 0 || curr_col == m + 1 {\n                direction *= -1;\n                curr_row += 1;\n            }\n        }\n\n        max_questions = row_questions + 1;\n        min_questions = row_questions;\n        if x == 1 && y <= remainder {\n            serg_questions += 1;\n        }\n    }\n\n    println!(\\\"{} {} {}\\\", max_questions, min_questions, serg_questions);\n}"}
{"title":"D. Big Maximum Sum","description":"Ahmed and Mostafa used to compete together in many programming contests for several years. Their coach Fegla asked them to solve one challenging problem, of course Ahmed was able to solve it but Mostafa couldn't.This problem is similar to a standard problem but it has a different format and constraints.In the standard problem you are given an array of integers, and you have to find one or more consecutive elements in this array where their sum is the maximum possible sum.But in this problem you are given n small arrays, and you will create one big array from the concatenation of one or more instances of the small arrays (each small array could occur more than once). The big array will be given as an array of indexes (1-based) of the small arrays, and the concatenation should be done in the same order as in this array. Then you should apply the standard problem mentioned above on the resulting big array.For example let's suppose that the small arrays are {1, 6, -2}, {3, 3} and {-5, 1}. And the indexes in the big array are {2, 3, 1, 3}. So the actual values in the big array after formatting it as concatenation of the small arrays will be {3, 3, -5, 1, 1, 6, -2, -5, 1}. In this example the maximum sum is 9.Can you help Mostafa solve this problem?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m, n is the number of the small arrays (1\u2264n\u226450), and m is the number of indexes in the big array (1\u2264m\u2264250000). Then follow n lines, the i-th line starts with one integer l which is the size of the i-th array (1\u2264l\u22645000), followed by l integers each one will be greater than or equal -1000 and less than or equal 1000. The last line contains m integers which are the indexes in the big array, and you should concatenate the small arrays in the same order, and each index will be greater than or equal to 1 and less than or equal to n.\nThe small arrays are numbered from 1 to n in the same order as given in the input. Some of the given small arrays may not be used in big array.\nNote, that the array is very big. So if you try to build it straightforwardly, you will probably get time or\/and memory limit exceeded.\n","output_spec":"Print one line containing the maximum sum in the big array after formatting it as described above. You must choose at least one element for the sum, i. e. it cannot be empty.\nPlease, do not use %lld specificator to write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).\n","notes":null,"sample_inputs":["3 4\n3 1 6 -2\n2 3 3\n2 -5 1\n2 3 1 3\n","6 1\n4 0 8 -3 -10\n8 3 -2 -5 10 8 -9 -5 -4\n1 0\n1 -3\n3 -8 5 6\n2 9 6\n1\n"],"sample_outputs":["9\n","8\n"],"id":"75-D","difficulty":2000,"tags":["data+structures","dp","greedy","implementation","math","trees"],"src_uid":"13fa378c913bb7a15612327099b59f83","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <climits>\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<vector<int>> smallArrays(n);\\n    for (int i = 0; i < n; i++) {\\n        int l;\\n        cin >> l;\\n        smallArrays[i].resize(l);\\n        for (int j = 0; j < l; j++) {\\n            cin >> smallArrays[i][j];\\n        }\\n    }\\n    vector<int> bigArray;\\n    for (int i = 0; i < m; i++) {\\n        int index;\\n        cin >> index;\\n        bigArray.insert(bigArray.end(), smallArrays[index - 1].begin(), smallArrays[index - 1].end());\\n    }\\n    int maxSum = INT_MIN;\\n    int currentSum = 0;\\n    for (int i = 0; i < bigArray.size(); i++) {\\n        currentSum = max(bigArray[i], currentSum + bigArray[i]);\\n        maxSum = max(maxSum, currentSum);\\n    }\\n    cout << maxSum << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        \n        List<List<Integer>> smallArrays = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int l = scanner.nextInt();\n            List<Integer> smallArray = new ArrayList<>();\n            for (int j = 0; j < l; j++) {\n                smallArray.add(scanner.nextInt());\n            }\n            smallArrays.add(smallArray);\n        }\n        \n        List<Integer> bigArray = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int index = scanner.nextInt();\n            bigArray.addAll(smallArrays.get(index - 1));\n        }\n        \n        int maxSum = Integer.MIN_VALUE;\n        int currentSum = 0;\n        for (int num : bigArray) {\n            currentSum = Math.max(num, currentSum + num);\n            maxSum = Math.max(maxSum, currentSum);\n        }\n        \n        System.out.println(maxSum);\n    }\n}","Python":"n, m = map(int, input().split())\\nsmall_arrays = []\\nfor _ in range(n):\\n    small_arrays.append(list(map(int, input().split()[1:])))\\nindexes = list(map(int, input().split()))\\n\\nbig_array = []\\nfor index in indexes:\\n    big_array.extend(small_arrays[index-1])\\n\\nmax_sum = float('-inf')\\ncurrent_sum = 0\\n\\nfor num in big_array:\\n    current_sum = max(num, current_sum + num)\\n    max_sum = max(max_sum, current_sum)\\n\\nprint(max_sum)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int smallArrays[n][5000];\\n    int sizes[n];\\n    for (int i = 0; i < n; i++) {\\n        int l;\\n        scanf(\\\"%d\\\", &l);\\n        sizes[i] = l;\\n        for (int j = 0; j < l; j++) {\\n            scanf(\\\"%d\\\", &smallArrays[i][j]);\\n        }\\n    }\\n    int bigArray[m];\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%d\\\", &bigArray[i]);\\n    }\\n\\n    long long maxSum = -1000000000;\\n    long long currentSum = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        int smallArrayIndex = bigArray[i] - 1;\\n        int smallArraySize = sizes[smallArrayIndex];\\n        for (int j = 0; j < smallArraySize; j++) {\\n            currentSum += smallArrays[smallArrayIndex][j];\\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%lld\\\\n\\\", maxSum);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MaximumSum\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n\n            List<List<int>> smallArrays = new List<List<int>>();\n            for (int i = 0; i < n; i++)\n            {\n                string smallArrayInput = Console.ReadLine();\n                string[] smallArrayInputArr = smallArrayInput.Split(' ');\n                List<int> smallArray = new List<int>();\n                for (int j = 1; j < smallArrayInputArr.Length; j++)\n                {\n                    smallArray.Add(int.Parse(smallArrayInputArr[j]));\n                }\n                smallArrays.Add(smallArray);\n            }\n\n            string indexesInput = Console.ReadLine();\n            string[] indexesInputArr = indexesInput.Split(' ');\n            List<int> indexes = new List<int>();\n            for (int i = 0; i < m; i++)\n            {\n                indexes.Add(int.Parse(indexesInputArr[i]));\n            }\n\n            List<int> bigArray = new List<int>();\n            foreach (int index in indexes)\n            {\n                bigArray.AddRange(smallArrays[index - 1]);\n            }\n\n            int maxSum = FindMaximumSum(bigArray);\n            Console.WriteLine(maxSum);\n        }\n\n        static int FindMaximumSum(List<int> array)\n        {\n            int maxSum = int.MinValue;\n            int currentSum = 0;\n\n            foreach (int num in array)\n            {\n                currentSum = Math.Max(num, currentSum + num);\n                maxSum = Math.Max(maxSum, currentSum);\n            }\n\n            return maxSum;\n        }\n    }\n}","Ruby":"\n# Read input\nn, m = gets.chomp.split.map(&:to_i)\nsmall_arrays = []\nn.times do\n  small_arrays << gets.chomp.split.map(&:to_i)[1..-1]\nend\nindexes = gets.chomp.split.map(&:to_i)\n\n# Concatenate small arrays\nbig_array = []\nindexes.each do |index|\n  big_array += small_arrays[index-1]\nend\n\n# Find maximum sum\nmax_sum = big_array[0]\ncurrent_sum = big_array[0]\n(1...big_array.length).each do |i|\n  current_sum = [big_array[i], current_sum + big_array[i]].max\n  max_sum = [max_sum, current_sum].max\nend\n\n# Print maximum sum\nputs max_sum\n","delphi":"program MaximumSum;\n\nvar\n  n, m, i, j, k, l, index: Integer;\n  smallArrays: array of array of Integer;\n  bigArray: array of Integer;\n  maxSum, currentSum: Integer;\n\nbegin\n  \/\/ Read n and m\n  ReadLn(n, m);\n  \n  \/\/ Initialize smallArrays\n  SetLength(smallArrays, n);\n  \n  \/\/ Read small arrays\n  for i := 0 to n - 1 do\n  begin\n    Read(l);\n    SetLength(smallArrays[i], l);\n    for j := 0 to l - 1 do\n    begin\n      Read(smallArrays[i][j]);\n    end;\n  end;\n  \n  \/\/ Initialize bigArray\n  SetLength(bigArray, m);\n  \n  \/\/ Read indexes in big array\n  for i := 0 to m - 1 do\n  begin\n    Read(index);\n    \/\/ Concatenate small arrays in the same order\n    for j := 0 to Length(smallArrays[index - 1]) - 1 do\n    begin\n      bigArray[i] := smallArrays[index - 1][j];\n      Inc(i);\n    end;\n    Dec(i);\n  end;\n  \n  \/\/ Find maximum sum\n  maxSum := bigArray[0];\n  currentSum := bigArray[0];\n  \n  for i := 1 to m - 1 do\n  begin\n    if currentSum + bigArray[i] > bigArray[i] then\n      currentSum := currentSum + bigArray[i]\n    else\n      currentSum := bigArray[i];\n      \n    if currentSum > maxSum then\n      maxSum := currentSum;\n  end;\n  \n  \/\/ Print maximum sum\n  WriteLn(maxSum);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scan(&n, &m)\\n\\n\\tsmallArrays := make([][]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar l int\\n\\t\\tfmt.Scan(&l)\\n\\n\\t\\tsmallArrays[i] = make([]int, l)\\n\\n\\t\\tfor j := 0; j < l; j++ {\\n\\t\\t\\tfmt.Scan(&smallArrays[i][j])\\n\\t\\t}\\n\\t}\\n\\n\\tvar indexes []int\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tvar index int\\n\\t\\tfmt.Scan(&index)\\n\\t\\tindexes = append(indexes, index)\\n\\t}\\n\\n\\tbigArray := make([]int, 0)\\n\\n\\tfor _, index := range indexes {\\n\\t\\tbigArray = append(bigArray, smallArrays[index-1]..","Javascript":"function findMaxSum(n, m, smallArrays, indexes) {\n    let bigArray = [];\n    for (let i = 0; i < indexes.length; i++) {\n        let smallArray = smallArrays[indexes[i] - 1];\n        bigArray = bigArray.concat(smallArray);\n    }\n    \n    let maxSum = Number.MIN_SAFE_INTEGER;\n    let currentSum = 0;\n    \n    for (let i = 0; i < bigArray.length; i++) {\n        currentSum = Math.max(bigArray[i], currentSum + bigArray[i]);\n        maxSum = Math.max(maxSum, currentSum);\n    }\n    \n    return maxSum;\n}\n\n\/\/ Example usage\nlet n = 3;\nlet m = 4;\nlet smallArrays = [[1, 6, -2], [2, 3, 3], [2, -5, 1]];\nlet indexes = [2, 3, 1, 3];\n\nlet maxSum = findMaxSum(n, m, smallArrays, indexes);\nconsole.log(maxSum);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n    val smallArrays = Array(n) { IntArray(0) }\n    for (i in 0 until n) {\n        val l = scanner.nextInt()\n        smallArrays[i] = IntArray(l)\n        for (j in 0 until l) {\n            smallArrays[i][j] = scanner.nextInt()\n        }\n    }\n    val indexes = IntArray(m)\n    for (i in 0 until m) {\n        indexes[i] = scanner.nextInt()\n    }\n    \n    val bigArray = mutableListOf<Int>()\n    for (index in indexes) {\n        bigArray.addAll(smallArrays[index - 1].toList())\n    }\n    \n    var maxSum = Int.MIN_VALUE\n    var currentSum = 0\n    for (num in bigArray) {\n        currentSum = maxOf(num, currentSum + num)\n        maxSum = maxOf(maxSum, currentSum)\n    }\n    \n    println(maxSum)\n}","PHP":"\n<?php\n\n\/\/ Read input\n$input = explode('\\n', trim(fgets(STDIN)));\nlist($n, $m) = explode(' ', $input[0]);\n\n$smallArrays = [];\nfor ($i = 1; $i <= $n; $i++) {\n    $smallArrays[$i] = array_map('intval', explode(' ', $input[$i]));\n}\n\n$indexes = array_map('intval', explode(' ', $input[$n + 1]));\n\n\/\/ Concatenate small arrays\n$bigArray = [];\nforeach ($indexes as $index) {\n    $bigArray = array_merge($bigArray, $smallArrays[$index]);\n}\n\n\/\/ Find maximum sum\n$maxSum = $bigArray[0];\n$currentSum = $bigArray[0];\nfor ($i = 1; $i < count($bigArray); $i++) {\n    $currentSum = max($bigArray[$i], $currentSum + $bigArray[$i]);\n    $maxSum = max($maxSum, $currentSum);\n}\n\n\/\/ Print output\necho $maxSum;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int[][] smallArrays = new int[][](n);\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        int l;\\r\\n        readf(\\\"%d\\\", &l);\\r\\n        smallArrays[i] = new int[](l);\\r\\n        foreach (ref element; smallArrays[i])\\r\\n        {\\r\\n            readf(\\\"%d\\\", &element);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[] bigArray = new int[](m);\\r\\n    foreach (ref element; bigArray)\\r\\n    {\\r\\n        readf(\\\"%d\\\", &element);\\r\\n    }\\r\\n\\r\\n    int[] concatenatedArray;\\r\\n    foreach (int index; bigArray)\\r\\n    {\\r\\n        concatenatedArray ~= smallArrays[index - 1];\\r\\n    }\\r\\n\\r\\n    int maxSum = 0;\\r\\n    int currentSum = 0;\\r\\n\\r\\n    foreach (int element; concatenatedArray)\\r\\n    {\\r\\n        currentSum = max(element, currentSum + element);\\r\\n        maxSum = max(maxSum, currentSum);\\r\\n    }\\r\\n\\r\\n    writeln(maxSum);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\n# Read input\nmy $input = <>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\nmy @small_arrays;\nfor (my $i = 0; $i < $n; $i++) {\n    my $small_array = <>;\n    chomp $small_array;\n    my @elements = split ' ', $small_array;\n    push @small_arrays, \\@elements;\n}\n\nmy $big_array = <>;\nchomp $big_array;\nmy @indexes = split ' ', $big_array;\n\n# Concatenate small arrays\nmy @concatenated_array;\nforeach my $index (@indexes) {\n    my $small_array = $small_arrays[$index - 1];\n    push @concatenated_array, @$small_array;\n}\n\n# Find maximum sum\nmy $max_sum = 0;\nmy $current_sum = 0;\nforeach my $element (@concatenated_array) {\n    $current_sum += $element;\n    if ($current_sum > $max_sum) {\n        $max_sum = $current_sum;\n    }\n    if ($current_sum < 0) {\n        $current_sum = 0;\n    }\n}\n\n# Print maximum sum\nprint $max_sum;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nm: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nm[0];\n    let m = nm[1];\n    \n    let mut small_arrays: Vec<Vec<i32>> = Vec::new();\n    for _ in 0..n {\n        let array: Vec<i32> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n        small_arrays.push(array);\n    }\n    \n    let indexes: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut big_array: Vec<i32> = Vec::new();\n    for index in indexes {\n        let small_array = &small_arrays[index - 1];\n        big_array.extend_from_slice(small_array);\n    }\n    \n    let mut max_sum = big_array[0];\n    let mut current_sum = big_array[0];\n    \n    for i in 1..big_array.len() {\n        current_sum = current_sum.max(0) + big_array[i];\n        max_sum = max_sum.max(current_sum);\n    }\n    \n    println!(\"{}\", max_sum);\n}"}
{"title":"L. Bars","description":"Polycarp's workday lasts exactly $$$n$$$ minutes. He loves chocolate bars and can eat one bar in one minute. Today Polycarp has $$$k$$$ bars at the beginning of the workday.In some minutes of the workday Polycarp has important things to do and in such minutes he is not able to eat a chocolate bar. In other minutes he can either eat or not eat one chocolate bar. It is guaranteed, that in the first and in the last minutes of the workday Polycarp has no important things to do and he will always eat bars in this minutes to gladden himself at the begining and at the end of the workday. Also it is guaranteed, that $$$k$$$ is strictly greater than $$$1$$$.Your task is to determine such an order of eating chocolate bars that the maximum break time between eating bars is as minimum as possible.Consider that Polycarp eats a bar in the minute $$$x$$$ and the next bar in the minute $$$y$$$ ($$$x < y$$$). Then the break time is equal to $$$y - x - 1$$$ minutes. It is not necessary for Polycarp to eat all bars he has.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\\\le n \\\\le 200\\\\,000$$$, $$$2 \\\\le k \\\\le n$$$) \u2014 the length of the workday in minutes and the number of chocolate bars, which Polycarp has in the beginning of the workday.\nThe second line contains the string with length $$$n$$$ consisting of zeros and ones. If the $$$i$$$-th symbol in the string equals to zero, Polycarp has no important things to do in the minute $$$i$$$ and he can eat a chocolate bar. In the other case, Polycarp is busy in the minute $$$i$$$ and can not eat a chocolate bar. It is guaranteed, that the first and the last characters of the string are equal to zero, and Polycarp always eats chocolate bars in these minutes.\n","output_spec":"Print the minimum possible break in minutes between eating chocolate bars.\n","notes":"In the first example Polycarp can not eat the chocolate bar in the second minute, so the time of the break equals to one minute.\nIn the second example Polycarp will eat bars in the minutes $$$1$$$ and $$$8$$$ anyway, also he needs to eat the chocolate bar in the minute $$$5$$$, so that the time of the maximum break will be equal to $$$3$$$ minutes.\n","sample_inputs":["3 3\n010\n","8 3\n01010110\n"],"sample_outputs":["1\n","3\n"],"id":"774-L","difficulty":2000,"tags":["*special","binary+search"],"src_uid":"e33b0a752dc1aba25da21e20435e3fe2","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    string s;\\n    cin >> s;\\n\\n    vector<int> breaks;\\n    int count = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == '0') {\\n            count++;\\n        } else {\\n            breaks.push_back(count);\\n            count = 0;\\n        }\\n    }\\n\\n    breaks.push_back(count);\\n\\n    int maxBreak = *max_element(breaks.begin(), breaks.end());\\n\\n    int left = 1, right = maxBreak;\\n    int ans = maxBreak;\\n\\n    while (left <= right) {\\n        int mid = (left + right) \/ 2;\\n        int bars = k;\\n        bool possible = true;\\n\\n        for (int i = 0; i < breaks.size(); i++) {\\n            bars -= breaks[i] \/ (mid + 1);\\n\\n            if (bars <= 0) {\\n                possible = false;\\n                break;\\n            }\\n        }\\n\\n        if (possible) {\\n            ans = mid;\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    cout << ans << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ChocolateBars {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int k = scanner.nextInt();\\n        scanner.nextLine();\\n        String s = scanner.nextLine();\\n\\n        int maxBreak = 0;\\n        int currentBreak = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == '0') {\\n                currentBreak++;\\n            } else {\\n                maxBreak = Math.max(maxBreak, currentBreak);\\n                currentBreak = 0;\\n            }\\n        }\\n\\n        maxBreak = Math.max(maxBreak, currentBreak);\\n\\n        int minBreak = (int) Math.ceil((double) maxBreak \/ (k - 1));\\n\\n        System.out.println(minBreak);\\n    }\\n}","Python":"def min_break_time(n, k, s):\n    breaks = []\n    count = 0\n    for i in range(n):\n        if s[i] == '0':\n            count += 1\n        else:\n            breaks.append(count)\n            count = 0\n    breaks.append(count)\n    \n    low = 1\n    high = n\n    while low < high:\n        mid = (low + high) \/\/ 2\n        if check(breaks, mid, k):\n            high = mid\n        else:\n            low = mid + 1\n    \n    return low - 1\n\ndef check(breaks, max_break, k):\n    count = 0\n    for b in breaks:\n        count += b \/\/ (max_break + 1)\n        if count > k:\n            return False\n    return True\n\nn, k = map(int, input().split())\ns = input()\nprint(min_break_time(n, k, s))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    char s[n+1];\\n    scanf(\\\"%s\\\", s);\\n\\n    int count = 0;\\n    int max_break = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == '0') {\\n            count++;\\n        }\\n        else {\\n            if (count > max_break) {\\n                max_break = count;\\n            }\\n            count = 0;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", max_break);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string input = Console.ReadLine();\n        string[] inputArr = input.Split(' ');\n        int n = int.Parse(inputArr[0]);\n        int k = int.Parse(inputArr[1]);\n\n        string s = Console.ReadLine();\n\n        int maxBreak = 0;\n        int currentBreak = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            if (s[i] == '0')\n            {\n                currentBreak++;\n            }\n            else\n            {\n                maxBreak = Math.Max(maxBreak, currentBreak);\n                currentBreak = 0;\n            }\n        }\n\n        maxBreak = Math.Max(maxBreak, currentBreak);\n\n        int minBreak = (int)Math.Ceiling((double)maxBreak \/ (k - 1));\n\n        Console.WriteLine(minBreak);\n    }\n}","Ruby":"\ndef minimum_break(n, k, s)\n  breaks = []\n  start = 0\n  for i in 1..n-1\n    if s[i] == '1'\n      breaks << i - start - 1\n      start = i\n    end\n  end\n  breaks << n - start - 1\n  breaks.max\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nk = input[1].to_i\ns = gets.chomp\n\nputs minimum_break(n, k, s)\n","delphi":"var\n  n, k, i, j, maxBreak, currBreak: Integer;\n  s: String;\nbegin\n  ReadLn(n, k);\n  ReadLn(s);\n  \n  maxBreak := 0;\n  currBreak := 0;\n  \n  for i := 1 to n do\n  begin\n    if s[i] = '0' then\n    begin\n      Inc(currBreak);\n      if currBreak > maxBreak then\n        maxBreak := currBreak;\n    end\n    else\n      currBreak := 0;\n  end;\n  \n  WriteLn(maxBreak);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tvar s string\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\tfmt.Scanf(\\\"%s\\\", &s)\\n\\n\\t\/\/ Count the number of zeros in the string\\n\\tzeroCount := strings.Count(s, \\\"0\\\")\\n\\n\\t\/\/ Calculate the maximum break time\\n\\tmaxBreak := (zeroCount - k) \/ (k - 1)\\n\\n\\t\/\/ Print the result\\n\\tfmt.Println(maxBreak)\\n}","Javascript":"function minimumBreakTime(input) {\n    const [n, k] = input[0].split(' ').map(Number);\n    const bars = input[1].split('');\n\n    let breaks = [];\n    let count = 0;\n\n    for (let i = 0; i < n; i++) {\n        if (bars[i] === '0') {\n            count++;\n        } else {\n            breaks.push(count);\n            count = 0;\n        }\n    }\n\n    breaks.sort((a, b) => b - a);\n\n    return (breaks[0] + 1).toString();\n}\n\nconst input = ['3 3\\\\n010\\\\n'];\nconst output = minimumBreakTime(input);\nconsole.log(output);","Kotlin":"\"\"\nimport kotlin.math.max\n\nfun main() {\n    val (n, k) = readLine()!!.split(\" \").map { it.toInt() }\n    val busyMinutes = readLine()!!\n\n    var breaks = mutableListOf<Int>()\n    var count = 0\n    for (i in 0 until n) {\n        if (busyMinutes[i] == '0') {\n            count++\n        } else {\n            breaks.add(count)\n            count = 0\n        }\n    }\n    breaks.add(count)\n\n    var left = 1\n    var right = n\n    var result = 0\n    while (left <= right) {\n        val mid = (left + right) \/ 2\n        if (isValid(breaks, mid, k)) {\n            result = mid\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n\n    println(result)\n}\n\nfun isValid(breaks: List<Int>, maxBreak: Int, k: Int): Boolean {\n    var count = 0\n    for (i in 0 until breaks.size) {\n        count += breaks[i] \/ (maxBreak + 1)\n    }\n    return count <= k\n}\n\"\"","PHP":"<?php\\n\\nfunction findMinimumBreakTime($n, $k, $schedule) {\\n    $breaks = [];\\n    $count = 0;\\n    $maxBreak = 0;\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        if ($schedule[$i] == '0') {\\n            $count++;\\n        } else {\\n            $breaks[] = $count;\\n            $maxBreak = max($maxBreak, $count);\\n            $count = 0;\\n        }\\n    }\\n\\n    $breaks[] = $count;\\n    $maxBreak = max($maxBreak, $count);\\n\\n    $left = 1;\\n    $right = $maxBreak;\\n    $result = $maxBreak;\\n\\n    while ($left <= $right) {\\n        $mid = ($left + $right) \/ 2;\\n\\n        if (isValid($breaks, $mid, $k)) {\\n            $result = $mid;\\n            $right = $mid - 1;\\n        } else {\\n            $left = $mid + 1;\\n        }\\n    }\\n\\n    return $result;\\n}\\n\\nfunction isValid($breaks, $maxBreak, $k) {\\n    $count = 0;\\n\\n    foreach ($breaks as $break) {\\n        $count += floor(($break - 1) \/ $maxBreak);\\n    }\\n\\n    return $count <= $k;\\n}\\n\\n\/\/ Read input\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n[$n, $k] = explode(\\\" \\\", $input[0]);\\n$schedule = $input[1];\\n\\n\/\/ Find minimum break time\\n$minimumBreakTime = findMinimumBreakTime($n, $k, $schedule);\\n\\n\/\/ Print output\\necho $minimumBreakTime . \\\"\\\\n\\\";\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    string s;\\r\\n    readf(\\\"%d %d\\\\n\\\", &n, &k);\\r\\n    readf(\\\"%s\\\\n\\\", &s);\\r\\n\\r\\n    int[] breaks;\\r\\n    int count = 0;\\r\\n\\r\\n    for (int i = 0; i < n; i++)\\r\\n    {\\r\\n        if (s[i] == '0')\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            breaks ~= count;\\r\\n            count = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    breaks.sort();\\r\\n\\r\\n    int maxBreak = breaks[$ - 1];\\r\\n\\r\\n    writeln(maxBreak);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimum_break_time {\n    my ($n, $k, $schedule) = @_;\n\n    my @breaks;\n    my $count = 0;\n    my $max_break = 0;\n\n    for (my $i = 0; $i < $n; $i++) {\n        if ($schedule->[$i] == 0) {\n            $count++;\n        } else {\n            push @breaks, $count;\n            $count = 0;\n        }\n    }\n\n    push @breaks, $count;\n\n    my $left = 1;\n    my $right = $n;\n\n    while ($left < $right) {\n        my $mid = int(($left + $right) \/ 2);\n\n        my $bars = 0;\n        foreach my $break (@breaks) {\n            $bars += int(($break + $mid - 1) \/ $mid);\n        }\n\n        if ($bars <= $k) {\n            $right = $mid;\n        } else {\n            $left = $mid + 1;\n        }\n    }\n\n    return $left - 1;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k) = split ' ', $input;\n\nmy $schedule = <STDIN>;\nchomp $schedule;\nmy @schedule = split '', $schedule;\n\n# Call the function and print the result\nmy $result = minimum_break_time($n, $k, \\@schedule);\nprint $result;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut input = input.split_whitespace();\\n    let n: usize = input.next().unwrap().parse().unwrap();\\n    let k: usize = input.next().unwrap().parse().unwrap();\\n\\n    let mut bars = String::new();\\n    std::io::stdin().read_line(&mut bars).unwrap();\\n    let bars = bars.trim();\\n\\n    let mut breaks = Vec::new();\\n    let mut count = 0;\\n\\n    for i in 0..n {\\n        if bars.chars().nth(i).unwrap() == '0' {\\n            count += 1;\\n        } else {\\n            breaks.push(count);\\n            count = 0;\\n        }\\n    }\\n\\n    breaks.sort();\\n    breaks.pop();\\n\\n    let max_break = breaks.iter().max().unwrap();\\n    let min_break = (max_break + 1) \/ 2;\\n\\n    println!(\\\"{}\\\", min_break);\\n}"}
{"title":"A. Haiku","description":"Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: \"a\", \"e\", \"i\", \"o\" and \"u\".Three phases from a certain poem are given. Determine whether it is haiku or not.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The input data consists of three lines. The length of each line is between 1 and 100, inclusive. The i-th line contains the i-th phrase of the poem. Each phrase consists of one or more words, which are separated by one or more spaces. A word is a non-empty sequence of lowercase Latin letters. Leading and\/or trailing spaces in phrases are allowed. Every phrase has at least one non-space character. See the example for clarification.\n","output_spec":"Print \"YES\" (without the quotes) if the poem is a haiku. Otherwise, print \"NO\" (also without the quotes).\n","notes":null,"sample_inputs":["on  codeforces \nbeta round is running\n   a rustling of keys \n","how many gallons\nof edo s rain did you drink\n                                cuckoo\n"],"sample_outputs":["YES","NO"],"id":"78-A","difficulty":800,"tags":["implementation","strings"],"src_uid":"46d734178b3acaddf2ee3706f04d603d","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nbool isHaiku(string phrase) {\\n    int count = 0;\\n    for (char c : phrase) {\\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\\n            count++;\\n        }\\n    }\\n    return count == 5;\\n}\\n\\nint main() {\\n    string phrase1, phrase2, phrase3;\\n    getline(cin, phrase1);\\n    getline(cin, phrase2);\\n    getline(cin, phrase3);\\n\\n    bool isHaikuPoem = isHaiku(phrase1) && isHaiku(phrase2) && isHaiku(phrase3);\\n\\n    if (isHaikuPoem) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class HaikuPoem {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        String phrase1 = scanner.nextLine();\\n        String phrase2 = scanner.nextLine();\\n        String phrase3 = scanner.nextLine();\\n\\n        int syllables1 = countSyllables(phrase1);\\n        int syllables2 = countSyllables(phrase2);\\n        int syllables3 = countSyllables(phrase3);\\n\\n        if (syllables1 == 5 && syllables2 == 7 && syllables3 == 5) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n\\n    private static int countSyllables(String phrase) {\\n        int count = 0;\\n        for (char c : phrase.toCharArray()) {\\n            if (isVowel(c)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isVowel(char c) {\\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n    }\\n}\"},{\"version\": \"Java 7\", \"source code\": \"import java.util.Scanner;\\n\\npublic class HaikuPoem {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        String phrase1 = scanner.nextLine();\\n        String phrase2 = scanner.nextLine();\\n        String phrase3 = scanner.nextLine();\\n\\n        int syllables1 = countSyllables(phrase1);\\n        int syllables2 = countSyllables(phrase2);\\n        int syllables3 = countSyllables(phrase3);\\n\\n        if (syllables1 == 5 && syllables2 == 7 && syllables3 == 5) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n\\n    private static int countSyllables(String phrase) {\\n        int count = 0;\\n        for (char c : phrase.toCharArray()) {\\n            if (isVowel(c)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isVowel(char c) {\\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n    }\\n}\"},{\"version\": \"Java 6\", \"source code\": \"import java.util.Scanner;\\n\\npublic class HaikuPoem {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        String phrase1 = scanner.nextLine();\\n        String phrase2 = scanner.nextLine();\\n        String phrase3 = scanner.nextLine();\\n\\n        int syllables1 = countSyllables(phrase1);\\n        int syllables2 = countSyllables(phrase2);\\n        int syllables3 = countSyllables(phrase3);\\n\\n        if (syllables1 == 5 && syllables2 == 7 && syllables3 == 5) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n\\n    private static int countSyllables(String phrase) {\\n        int count = 0;\\n        for (char c : phrase.toCharArray()) {\\n            if (isVowel(c)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isVowel(char c) {\\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n    }\\n}\"},{\"version\": \"Java 8\", \"source code\": \"import java.util.Scanner;\\n\\npublic class HaikuPoem {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        String phrase1 = scanner.nextLine();\\n        String phrase2 = scanner.nextLine();\\n        String phrase3 = scanner.nextLine();\\n\\n        int syllables1 = countSyllables(phrase1);\\n        int syllables2 = countSyllables(phrase2);\\n        int syllables3 = countSyllables(phrase3);\\n\\n        if (syllables1 == 5 && syllables2 == 7 && syllables3 == 5) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n\\n    private static int countSyllables(String phrase) {\\n        int count = 0;\\n        for (char c : phrase.toCharArray()) {\\n            if (isVowel(c)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isVowel(char c) {\\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\\n    }\\n}","Python":"def is_haiku(poem):\n    syllables = [5, 7, 5]\n    for i in range(3):\n        phrase = poem[i].strip()\n        count = 0\n        for word in phrase.split():\n            count += sum(1 for letter in word if letter in 'aeiou')\n        if count != syllables[i]:\n            return 'NO'\n    return 'YES'\n\npoem = []\nfor _ in range(3):\n    poem.append(input())\n    \nprint(is_haiku(poem))","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint count_vowels(char *str) {\\n    int count = 0;\\n    int len = strlen(str);\\n    for (int i = 0; i < len; i++) {\\n        if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u') {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    char phrase1[101];\\n    char phrase2[101];\\n    char phrase3[101];\\n\\n    fgets(phrase1, sizeof(phrase1), stdin);\\n    fgets(phrase2, sizeof(phrase2), stdin);\\n    fgets(phrase3, sizeof(phrase3), stdin);\\n\\n    int syllables1 = count_vowels(phrase1);\\n    int syllables2 = count_vowels(phrase2);\\n    int syllables3 = count_vowels(phrase3);\\n\\n    if (syllables1 == 5 && syllables2 == 7 && syllables3 == 5) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else {\\n        printf(\\\"NO\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class HaikuChecker\n{\n    public static string CheckHaiku(string phrase1, string phrase2, string phrase3)\n    {\n        int syllables1 = CountSyllables(phrase1);\n        int syllables2 = CountSyllables(phrase2);\n        int syllables3 = CountSyllables(phrase3);\n\n        if (syllables1 == 5 && syllables2 == 7 && syllables3 == 5)\n        {\n            return \"YES\";\n        }\n        else\n        {\n            return \"NO\";\n        }\n    }\n\n    private static int CountSyllables(string phrase)\n    {\n        int syllables = 0;\n        bool isVowel = false;\n\n        foreach (char c in phrase)\n        {\n            if (IsVowel(c))\n            {\n                if (!isVowel)\n                {\n                    syllables++;\n                }\n                isVowel = true;\n            }\n            else\n            {\n                isVowel = false;\n            }\n        }\n\n        return syllables;\n    }\n\n    private static bool IsVowel(char c)\n    {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string phrase1 = Console.ReadLine();\n        string phrase2 = Console.ReadLine();\n        string phrase3 = Console.ReadLine();\n\n        string result = HaikuChecker.CheckHaiku(phrase1, phrase2, phrase3);\n        Console.WriteLine(result);\n    }\n}","Ruby":"\ndef is_haiku(poem)\n  # Count the number of vowels in each phrase\n  phrase1_vowels = count_vowels(poem[0])\n  phrase2_vowels = count_vowels(poem[1])\n  phrase3_vowels = count_vowels(poem[2])\n\n  # Check if the number of vowels matches the haiku pattern\n  if phrase1_vowels == 5 && phrase2_vowels == 7 && phrase3_vowels == 5\n    return 'YES'\n  else\n    return 'NO'\n  end\nend\n\ndef count_vowels(phrase)\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  count = 0\n\n  # Count the number of vowels in the phrase\n  phrase.each_char do |char|\n    count += 1 if vowels.include?(char)\n  end\n\n  return count\nend\n\n# Read the input data\npoem = []\n3.times do\n  poem << gets.chomp\nend\n\n# Check if the poem is a haiku\nresult = is_haiku(poem)\n\n# Print the result\nputs result\n","delphi":"program Haiku;\n\nuses\n  SysUtils;\n\nfunction CountVowels(s: string): Integer;\nvar\n  i: Integer;\nbegin\n  Result := 0;\n  for i := 1 to Length(s) do\n  begin\n    case s[i] of\n      'a', 'e', 'i', 'o', 'u': Inc(Result);\n    end;\n  end;\nend;\n\nfunction IsHaiku(phrase1, phrase2, phrase3: string): Boolean;\nbegin\n  Result := (CountVowels(phrase1) = 5) and (CountVowels(phrase2) = 7) and (CountVowels(phrase3) = 5);\nend;\n\nvar\n  phrase1, phrase2, phrase3: string;\nbegin\n  \/\/ Read input\n  ReadLn(phrase1);\n  ReadLn(phrase2);\n  ReadLn(phrase3);\n  \n  \/\/ Check if it is a haiku\n  if IsHaiku(phrase1, phrase2, phrase3) then\n    WriteLn('YES')\n  else\n    WriteLn('NO');\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\n\\tphrases := make([]string, 3)\\n\\n\\tfor i := 0; i < 3; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tphrases[i] = scanner.Text()\\n\\t}\\n\\n\\tisHaiku := checkHaiku(phrases)\\n\\n\\tif isHaiku {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}\\n\\nfunc checkHaiku(phrases []string) bool {\\n\\tvowels := []string{\\\"a\\\", \\\"e\\\", \\\"i\\\", \\\"o\\\", \\\"u\\\"}\\n\\n\\tfor i := 0; i < 3; i++ {\\n\\t\\tphrase := strings.TrimSpace(phrases[i])\\n\\t\\tcount := 0\\n\\n\\t\\tfor _, char := range phrase {\\n\\t\\t\\tif contains(vowels, string(char)) {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif i == 0 && count != 5 {\\n\\t\\t\\treturn false\\n\\t\\t} else if i == 1 && count != 7 {\\n\\t\\t\\treturn false\\n\\t\\t} else if i == 2 && count != 5 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc contains(arr []string, str string) bool {\\n\\tfor _, a := range arr {\\n\\t\\tif a == str {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}","Javascript":"function isHaiku(poem) {\n    let lines = poem.split('\\\\n');\n    let syllables = [5, 7, 5];\n    \n    for (let i = 0; i < lines.length; i++) {\n        let line = lines[i].trim();\n        let count = 0;\n        \n        for (let j = 0; j < line.length; j++) {\n            let char = line[j];\n            \n            if (char === 'a' || char === 'e' || char === 'i' || char === 'o' || char === 'u') {\n                count++;\n            }\n        }\n        \n        if (count !== syllables[i]) {\n            return 'NO';\n        }\n    }\n    \n    return 'YES';\n}\n\nlet poem1 = 'on  codeforces \\\\nbeta round is running\\\\n   a rustling of keys \\\\n';\nlet poem2 = 'how many gallons\\\\nof edo s rain did you drink\\\\n                                cuckoo\\\\n';\n\nconsole.log(isHaiku(poem1)); \/\/ Output: YES\nconsole.log(isHaiku(poem2)); \/\/ Output: NO","Kotlin":"fun isHaiku(phrase1: String, phrase2: String, phrase3: String): Boolean {\n    val vowelLetters = setOf('a', 'e', 'i', 'o', 'u')\n    \n    fun countSyllables(phrase: String): Int {\n        var count = 0\n        for (char in phrase) {\n            if (char.toLowerCase() in vowelLetters) {\n                count++\n            }\n        }\n        return count\n    }\n    \n    return countSyllables(phrase1) == 5 && countSyllables(phrase2) == 7 && countSyllables(phrase3) == 5\n}\n\nfun main() {\n    val phrase1 = readLine()!!\n    val phrase2 = readLine()!!\n    val phrase3 = readLine()!!\n    \n    if (isHaiku(phrase1, phrase2, phrase3)) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"<?php\\n\\nfunction isHaiku($phrases) {\\n    $syllables = [5, 7, 5];\\n    $vowels = ['a', 'e', 'i', 'o', 'u'];\\n    $haiku = true;\\n\\n    for ($i = 0; $i < 3; $i++) {\\n        $phrase = $phrases[$i];\\n        $count = 0;\\n\\n        \/\/ Count the number of vowel letters in the phrase\\n        for ($j = 0; $j < strlen($phrase); $j++) {\\n            if (in_array($phrase[$j], $vowels)) {\\n                $count++;\\n            }\\n        }\\n\\n        \/\/ Check if the count matches the required syllables\\n        if ($count != $syllables[$i]) {\\n            $haiku = false;\\n            break;\\n        }\\n    }\\n\\n    return $haiku ? 'YES' : 'NO';\\n}\\n\\n\/\/ Sample inputs\\n$phrases1 = ['on  codeforces \\nbeta round is running\\n   a rustling of keys \\n'];\\n$phrases2 = ['how many gallons\\nof edo s rain did you drink\\n                                cuckoo\\n'];\\n\\n\/\/ Check if the poems are haiku\\n$result1 = isHaiku($phrases1);\\n$result2 = isHaiku($phrases2);\\n\\n\/\/ Output the results\\n$output = [$result1, $result2];\\necho json_encode($output);\\n?>","d":"import std.stdio;\\r\\nimport std.string;\\r\\n\\r\\nstring[] vowels = [\\\"a\\\", \\\"e\\\", \\\"i\\\", \\\"o\\\", \\\"u\\\"];\\r\\n\\r\\nbool isHaiku(string phrase, int syllables)\\r\\n{\\r\\n    int count = 0;\\r\\n    foreach (char c; phrase)\\r\\n    {\\r\\n        if (vowels.canFind(toLower(c)))\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n    return count == syllables;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] phrases;\\r\\n    foreach (int i; 0..3)\\r\\n    {\\r\\n        string phrase;\\r\\n        readln(phrase);\\r\\n        phrases ~= phrase.trim;\\r\\n    }\\r\\n\\r\\n    bool isHaikuPoem = isHaiku(phrases[0], 5) && isHaiku(phrases[1], 7) && isHaiku(phrases[2], 5);\\r\\n\\r\\n    writeln(isHaikuPoem ? \\\"YES\\\" : \\\"NO\\\");\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_syllables {\n    my ($word) = @_;\n    my $count = 0;\n    $count += () = $word =~ \/[aeiou]\/gi;\n    return $count;\n}\n\nsub is_haiku {\n    my ($phrases) = @_;\n    my @syllables = map { count_syllables($_) } @$phrases;\n    return @syllables == 3 && $syllables[0] == 5 && $syllables[1] == 7 && $syllables[2] == 5;\n}\n\nsub main {\n    my @phrases = ();\n    for (my $i = 0; $i < 3; $i++) {\n        my $phrase = <>;\n        chomp $phrase;\n        push @phrases, $phrase;\n    }\n    my $result = is_haiku(\\@phrases) ? 'YES' : 'NO';\n    print $result;\n}\n\nmain();\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let lines: Vec<String> = stdin.lock().lines().map(|line| line.unwrap()).collect();\n\n    let phrase1 = lines[0].trim();\n    let phrase2 = lines[1].trim();\n    let phrase3 = lines[2].trim();\n\n    let syllables1 = count_syllables(phrase1);\n    let syllables2 = count_syllables(phrase2);\n    let syllables3 = count_syllables(phrase3);\n\n    if syllables1 == 5 && syllables2 == 7 && syllables3 == 5 {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\n\nfn count_syllables(phrase: &str) -> usize {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut count = 0;\n\n    for c in phrase.chars() {\n        if vowels.contains(&c) {\n            count += 1;\n        }\n    }\n\n    count\n}"}
{"title":"D. Password","description":"Finally Fox Ciel arrived in front of her castle!She have to type a password to enter her castle. An input device attached to her castle is a bit unusual.The input device is a 1\u00d7n rectangle divided into n square panels. They are numbered 1 to n from left to right. Each panel has a state either ON or OFF. Initially all panels are in the OFF state. She can enter her castle if and only if x1-th, x2-th, ..., xk-th panels are in the ON state and other panels are in the OFF state.She is given an array a1, ..., al. In each move, she can perform the following operation: choose an index i (1\u2264i\u2264l), choose consecutive ai panels, and flip the states of those panels (i.e. ON\u2192OFF, OFF\u2192ON).Unfortunately she forgets how to type the password with only above operations. Determine the minimal number of operations required to enter her castle.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains three integers n, k and l (1\u2264n\u226410000,1\u2264k\u226410,1\u2264l\u2264100), separated by single spaces.\nThe second line contains k integers x1, ..., xk (1\u2264x1<x2<...<xk\u2264n), separated by single spaces.\nThe third line contains l integers a1, ..., al (1\u2264ai\u2264n), separated by single spaces. It is possible that some elements of the array ai are equal value.\n","output_spec":"Print the minimal number of moves required to type the password. If it's impossible, print -1.\n","notes":"One possible way to type the password in the first example is following: In the first move, choose 1st, 2nd, 3rd panels and flip those panels. In the second move, choose 5th, 6th, 7th, 8th, 9th panels and flip those panels.\n","sample_inputs":["10 8 2\n1 2 3 5 6 7 8 9\n3 5\n","3 2 1\n1 2\n3\n"],"sample_outputs":["2\n","-1\n"],"id":"79-D","difficulty":2800,"tags":["bitmasks","dp","shortest+paths"],"src_uid":"3facb13a79e712ab0a545eb1ffcd6d5b","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, k, l;\\n    cin >> n >> k >> l;\\n    vector<int> password(n, 0);\\n    vector<int> panels(n, 0);\\n    for (int i = 0; i < k; i++) {\\n        int x;\\n        cin >> x;\\n        password[x-1] = 1;\\n    }\\n    for (int i = 0; i < l; i++) {\\n        int a;\\n        cin >> a;\\n        panels[a-1] = 1;\\n    }\\n    int minMoves = INT_MAX;\\n    for (int i = 0; i < n; i++) {\\n        if (panels[i] == 1) {\\n            int moves = 0;\\n            vector<int> temp = password;\\n            for (int j = i; j < n; j++) {\\n                if (temp[j] == 0) {\\n                    temp[j] = 1;\\n                    moves++;\\n                }\\n                if (temp == password) {\\n                    minMoves = min(minMoves, moves);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    if (minMoves == INT_MAX) {\\n        cout << -1 << endl;\\n    } else {\\n        cout << minMoves << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class PasswordTyping {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input values\n        String[] input1 = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input1[0]);\n        int k = Integer.parseInt(input1[1]);\n        int l = Integer.parseInt(input1[2]);\n        \n        String[] input2 = scanner.nextLine().split(\\\" \\\");\n        int[] x = new int[k];\n        for (int i = 0; i < k; i++) {\n            x[i] = Integer.parseInt(input2[i]);\n        }\n        \n        String[] input3 = scanner.nextLine().split(\\\" \\\");\n        int[] a = new int[l];\n        for (int i = 0; i < l; i++) {\n            a[i] = Integer.parseInt(input3[i]);\n        }\n        \n        \/\/ Initialize the panels state\n        boolean[] panels = new boolean[n];\n        \n        \/\/ Set the ON state for the specified panels\n        for (int i = 0; i < k; i++) {\n            panels[x[i] - 1] = true;\n        }\n        \n        \/\/ Initialize the minimum number of moves required\n        int minMoves = Integer.MAX_VALUE;\n        \n        \/\/ Iterate through all possible starting positions for the consecutive panels\n        for (int i = 0; i < l; i++) {\n            int start = a[i] - 1;\n            \n            \/\/ Check if it's possible to type the password starting from this position\n            if (start + k <= n) {\n                \/\/ Count the number of moves required to type the password starting from this position\n                int moves = 0;\n                for (int j = 0; j < k; j++) {\n                    if (panels[start + j] == false) {\n                        moves++;\n                    }\n                }\n                \n                \/\/ Update the minimum number of moves required\n                minMoves = Math.min(minMoves, moves);\n            }\n        }\n        \n        \/\/ Print the result\n        if (minMoves == Integer.MAX_VALUE) {\n            System.out.println(-1);\n        } else {\n            System.out.println(minMoves);\n        }\n    }\n}","Python":"def minimal_moves(n, k, l, x, a):\n    # Initialize the minimum number of moves to -1\n    min_moves = -1\n    \n    # Iterate through all possible combinations of panels to flip\n    for i in range(1, l+1):\n        for j in range(n-i+1):\n            # Check if the chosen panels include the required ON panels\n            if all(panel in x for panel in range(j+1, j+i+1)):\n                # Calculate the number of moves required to flip the panels\n                moves = sum(1 for panel in a if j+1 <= panel <= j+i)\n                \n                # Update the minimum number of moves if it is not set or if the current number of moves is smaller\n                if min_moves == -1 or moves < min_moves:\n                    min_moves = moves\n    \n    return min_moves\n\n# Read the input\nn, k, l = map(int, input().split())\nx = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Call the function and print the result\nprint(minimal_moves(n, k, l, x, a))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, k, l;\\n    scanf(\\\"%d %d %d\\\", &n, &k, &l);\\n    int x[k];\\n    for (int i = 0; i < k; i++) {\\n        scanf(\\\"%d\\\", &x[i]);\\n    }\\n    int a[l];\\n    for (int i = 0; i < l; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int moves = 0;\\n    int password[n];\\n    for (int i = 0; i < n; i++) {\\n        password[i] = 0;\\n    }\\n\\n    for (int i = 0; i < k; i++) {\\n        password[x[i] - 1] = 1;\\n    }\\n\\n    for (int i = 0; i < l; i++) {\\n        if (password[a[i] - 1] == 0) {\\n            moves++;\\n            password[a[i] - 1] = 1;\\n        }\\n    }\\n\\n    int onCount = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (password[i] == 1) {\\n            onCount++;\\n        }\\n    }\\n\\n    if (onCount < k) {\\n        printf(\\\"-1\\\\n\\\");\\n    } else {\\n        printf(\\\"%d\\\\n\\\", moves);\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string input = Console.ReadLine();\n        string[] inputArr = input.Split(' ');\n        int n = int.Parse(inputArr[0]);\n        int k = int.Parse(inputArr[1]);\n        int l = int.Parse(inputArr[2]);\n\n        input = Console.ReadLine();\n        inputArr = input.Split(' ');\n        int[] x = new int[k];\n        for (int i = 0; i < k; i++)\n        {\n            x[i] = int.Parse(inputArr[i]);\n        }\n\n        input = Console.ReadLine();\n        inputArr = input.Split(' ');\n        int[] a = new int[l];\n        for (int i = 0; i < l; i++)\n        {\n            a[i] = int.Parse(inputArr[i]);\n        }\n\n        int[] panels = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            panels[i] = 0;\n        }\n\n        for (int i = 0; i < k; i++)\n        {\n            panels[x[i] - 1] = 1;\n        }\n\n        int minMoves = int.MaxValue;\n\n        for (int i = 0; i < l; i++)\n        {\n            int[] tempPanels = panels.ToArray();\n            int moves = 0;\n\n            for (int j = 0; j < l; j++)\n            {\n                if (a[j] != a[i])\n                {\n                    int start = a[j] - 1;\n                    int end = a[j] + a[i] - 2;\n\n                    if (end >= n)\n                    {\n                        end = n - 1;\n                    }\n\n                    for (int k = start; k <= end; k++)\n                    {\n                        tempPanels[k] = 1 - tempPanels[k];\n                    }\n\n                    moves++;\n                }\n            }\n\n            if (tempPanels.SequenceEqual(panels) && moves < minMoves)\n            {\n                minMoves = moves;\n            }\n        }\n\n        if (minMoves == int.MaxValue)\n        {\n            Console.WriteLine(-1);\n        }\n        else\n        {\n            Console.WriteLine(minMoves);\n        }\n    }\n}","Ruby":"\ndef minimal_moves(n, k, l, x, a)\n  # Initialize an array to keep track of the state of each panel\n  panels = Array.new(n, false)\n  \n  # Set the state of the panels that need to be ON\n  x.each do |index|\n    panels[index-1] = true\n  end\n  \n  # Initialize the minimum number of moves required to infinity\n  min_moves = Float::INFINITY\n  \n  # Iterate through each possible starting index for the consecutive panels\n  (0..l-1).each do |start_index|\n    # Iterate through each possible length of consecutive panels\n    (1..l-start_index).each do |length|\n      # Get the subarray of consecutive panels\n      subarray = a[start_index, length]\n      \n      # Check if flipping the subarray can result in the desired state\n      if subarray.all? { |panel| panels[panel-1] == false }\n        # Calculate the number of moves required to flip the subarray\n        moves = subarray.uniq.length\n        \n        # Update the minimum number of moves if necessary\n        min_moves = [min_moves, moves].min\n      end\n    end\n  end\n  \n  # Check if it is possible to type the password\n  if min_moves == Float::INFINITY\n    return -1\n  else\n    return min_moves\n  end\nend\n\n# Parse the input\ninput = gets.chomp.split(\"\\n\")\nn, k, l = input[0].split.map(&:to_i)\nx = input[1].split.map(&:to_i)\na = input[2].split.map(&:to_i)\n\n# Call the function and print the result\nputs minimal_moves(n, k, l, x, a)\n","delphi":"program MinimalMoves;\n\nvar\n  n, k, l, i, j, count, minMoves: integer;\n  x, a: array of integer;\n  panels: array of boolean;\n\nbegin\n  \/\/ Read input values\n  readln(n, k, l);\n  \n  \/\/ Initialize arrays\n  SetLength(x, k);\n  SetLength(a, l);\n  SetLength(panels, n);\n  \n  \/\/ Read x values\n  for i := 0 to k-1 do\n    read(x[i]);\n  readln;\n  \n  \/\/ Read a values\n  for i := 0 to l-1 do\n    read(a[i]);\n  readln;\n  \n  \/\/ Initialize panels to OFF state\n  for i := 0 to n-1 do\n    panels[i] := false;\n  \n  \/\/ Set x-th panels to ON state\n  for i := 0 to k-1 do\n    panels[x[i]-1] := true;\n  \n  \/\/ Check if password is already entered\n  count := 0;\n  for i := 0 to l-1 do\n  begin\n    if panels[a[i]-1] = false then\n    begin\n      writeln(-1);\n      exit;\n    end;\n    count := count + 1;\n  end;\n  \n  \/\/ Calculate minimal number of moves\n  minMoves := l;\n  for i := 0 to n-1 do\n  begin\n    if panels[i] = false then\n    begin\n      count := 0;\n      for j := i to n-1 do\n      begin\n        if panels[j] = false then\n        begin\n          panels[j] := true;\n          count := count + 1;\n        end\n        else\n          break;\n      end;\n      if count < minMoves then\n        minMoves := count;\n    end;\n  end;\n  \n  \/\/ Print minimal number of moves\n  writeln(minMoves);\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k, l int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &k, &l)\\n\\n\\tx := make([]int, k)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &x[i])\\n\\t}\\n\\n\\ta := make([]int, l)\\n\\tfor i := 0; i < l; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &a[i])\\n\\t}\\n\\n\\tonPanels := make([]bool, n+1)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tonPanels[x[i]] = true\\n\\t}\\n\\n\\tmoves := 0\\n\\tfor i := 0; i < l; i++ {\\n\\t\\tif !onPanels[a[i]] {\\n\\t\\t\\tfmt.Println(-1)\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < l; i++ {\\n\\t\\tif i == 0 || a[i] != a[i-1]+1 {\\n\\t\\t\\tmoves++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(moves)\\n}","Javascript":"function minimalMoves(n, k, l, x, a) {\n    let onPanels = new Array(n).fill(false); \/\/ array to keep track of which panels are ON\n    let moves = 0; \/\/ variable to count the number of moves\n    \n    \/\/ mark the panels that need to be ON\n    for (let i = 0; i < k; i++) {\n        onPanels[x[i] - 1] = true;\n    }\n    \n    \/\/ check if it's possible to type the password\n    for (let i = 0; i < l; i++) {\n        if (onPanels[a[i] - 1]) {\n            continue; \/\/ panel is already ON, no need to flip\n        }\n        \n        \/\/ find the longest consecutive sequence of OFF panels\n        let j = a[i] - 1;\n        while (j >= 0 && !onPanels[j]) {\n            j--;\n        }\n        let start = j + 1;\n        \n        j = a[i] - 1;\n        while (j < n && !onPanels[j]) {\n            j++;\n        }\n        let end = j - 1;\n        \n        \/\/ flip the panels in the sequence\n        for (let j = start; j <= end; j++) {\n            onPanels[j] = true;\n        }\n        \n        moves++; \/\/ increment the number of moves\n    }\n    \n    \/\/ check if all required panels are ON\n    for (let i = 0; i < k; i++) {\n        if (!onPanels[x[i] - 1]) {\n            return -1; \/\/ password cannot be typed\n        }\n    }\n    \n    return moves; \/\/ return the minimal number of moves\n}\n\n\/\/ sample inputs\nlet input1 = '10 8 2\\n1 2 3 5 6 7 8 9\\n3 5\\n';\nlet input2 = '3 2 1\\n1 2\\n3\\n';\n\n\/\/ parse the inputs\nlet [n1, k1, l1, x1, a1] = input1.split('\\\\n');\nn1 = parseInt(n1);\nk1 = parseInt(k1);\nl1 = parseInt(l1);\nx1 = x1.split(' ').map(Number);\na1 = a1.split(' ').map(Number);\n\nlet [n2, k2, l2, x2, a2] = input2.split('\\\\n');\nn2 = parseInt(n2);\nk2 = parseInt(k2);\nl2 = parseInt(l2);\nx2 = x2.split(' ').map(Number);\na2 = a2.split(' ').map(Number);\n\n\/\/ call the function for each input\nlet output1 = minimalMoves(n1, k1, l1, x1, a1);\nlet output2 = minimalMoves(n2, k2, l2, x2, a2);\n\n\/\/ print the outputs\nconsole.log(output1);\nconsole.log(output2);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val k = input[1].toInt()\n    val l = input[2].toInt()\n\n    val onPanels = BooleanArray(n + 1)\n    val passwordPanels = BooleanArray(n + 1)\n\n    val onPanelIndices = scanner.nextLine().split(\" \").map { it.toInt() }\n    val passwordPanelIndices = scanner.nextLine().split(\" \").map { it.toInt() }\n\n    for (index in onPanelIndices) {\n        onPanels[index] = true\n    }\n\n    for (index in passwordPanelIndices) {\n        passwordPanels[index] = true\n    }\n\n    val moves = mutableListOf<Int>()\n\n    for (i in 1..n) {\n        if (passwordPanels[i] && !onPanels[i]) {\n            val move = mutableListOf<Int>()\n            var j = i\n\n            while (j <= n && passwordPanels[j] && !onPanels[j]) {\n                move.add(j)\n                onPanels[j] = true\n                j++\n            }\n\n            if (move.size > l) {\n                println(-1)\n                return\n            }\n\n            moves.addAll(move)\n        }\n    }\n\n    if (moves.size > l) {\n        println(-1)\n    } else {\n        println(moves.size)\n    }\n}","PHP":"<?php\\n\\nfunction minimalMoves($input) {\\n    \/\/ Parse the input\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    list($n, $k, $l) = explode(\\\" \\\", $lines[0]);\\n    $x = explode(\\\" \\\", $lines[1]);\\n    $a = explode(\\\" \\\", $lines[2]);\\n    \\n    \/\/ Initialize the state of the panels\\n    $panels = array_fill(1, $n, 0);\\n    \\n    \/\/ Set the ON state for the specified panels\\n    foreach ($x as $panel) {\\n        $panels[$panel] = 1;\\n    }\\n    \\n    \/\/ Initialize the minimal number of moves\\n    $minMoves = PHP_INT_MAX;\\n    \\n    \/\/ Iterate through all possible starting positions\\n    for ($start = 1; $start <= $n; $start++) {\\n        \/\/ Initialize the number of moves\\n        $moves = 0;\\n        \\n        \/\/ Iterate through the array of operations\\n        foreach ($a as $operation) {\\n            \/\/ Check if the operation is valid\\n            if ($start + $operation - 1 <= $n) {\\n                \/\/ Flip the state of the panels\\n                for ($i = $start; $i < $start + $operation; $i++) {\\n                    $panels[$i] = !$panels[$i];\\n                }\\n                \\n                \/\/ Increment the number of moves\\n                $moves++;\\n            }\\n        }\\n        \\n        \/\/ Check if the password can be typed\\n        $passwordTyped = true;\\n        \\n        foreach ($x as $panel) {\\n            if ($panels[$panel] != 1) {\\n                $passwordTyped = false;\\n                break;\\n            }\\n        }\\n        \\n        \/\/ Update the minimal number of moves\\n        if ($passwordTyped) {\\n            $minMoves = min($minMoves, $moves);\\n        }\\n        \\n        \/\/ Reset the state of the panels\\n        foreach ($x as $panel) {\\n            $panels[$panel] = 1;\\n        }\\n    }\\n    \\n    \/\/ Check if the password can be typed\\n    if ($minMoves == PHP_INT_MAX) {\\n        return \\\"-1\\\\n\\\";\\n    } else {\\n        return $minMoves . \\\"\\\\n\\\";\\n    }\\n}\\n\\n\/\/ Test the function with the sample inputs\\n$input1 = \\\"10 8 2\\\\n1 2 3 5 6 7 8 9\\\\n3 5\\\\n\\\";\\n$input2 = \\\"3 2 1\\\\n1 2\\\\n3\\\\n\\\";\\n\\n$output1 = minimalMoves($input1);\\n$output2 = minimalMoves($input2);\\n\\n\/\/ Print the outputs\\necho $output1; \/\/ Expected output: 2\\necho $output2; \/\/ Expected output: -1\\n\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint minimalMoves(int n, int k, int l, int[] x, int[] a) {\\r\\n    int[] panels = new int[n];\\r\\n    foreach (int i; 0 .. k) {\\r\\n        panels[x[i] - 1] = 1;\\r\\n    }\\r\\n\\r\\n    int moves = 0;\\r\\n    foreach (int i; 0 .. l) {\\r\\n        int[] consecutive = new int[a[i]];\\r\\n        foreach (int j; 0 .. a[i]) {\\r\\n            consecutive[j] = panels[j];\\r\\n        }\\r\\n\\r\\n        if (consecutive.canFind(0)) {\\r\\n            moves++;\\r\\n            foreach (int j; 0 .. a[i]) {\\r\\n                panels[j] = 1 - panels[j];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (panels.canFind(0)) {\\r\\n        return -1;\\r\\n    }\\r\\n\\r\\n    return moves;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, k, l;\\r\\n    int[] x, a;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d %d\\\", &n, &k, &l);\\r\\n\\r\\n    x = new int[k];\\r\\n    for (int i = 0; i < k; i++) {\\r\\n        scanf(\\\"%d\\\", &x[i]);\\r\\n    }\\r\\n\\r\\n    a = new int[l];\\r\\n    for (int i = 0; i < l; i++) {\\r\\n        scanf(\\\"%d\\\", &a[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate minimal moves\\r\\n    int result = minimalMoves(n, k, l, x, a);\\r\\n\\r\\n    \/\/ Print result\\r\\n    printf(\\\"%d\\\\n\\\", result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimal_moves {\n    my ($n, $k, $l, $x_ref, $a_ref) = @_;\n\n    my @x = @$x_ref;\n    my @a = @$a_ref;\n\n    my @panels = (0) x $n;\n    foreach my $i (@x) {\n        $panels[$i-1] = 1;\n    }\n\n    my $min_moves = -1;\n    foreach my $i (0..$l-1) {\n        my $target = $a[$i];\n        my $moves = 0;\n        my @temp_panels = @panels;\n\n        while ($temp_panels[$target-1] == 0) {\n            my $j = $target;\n            while ($temp_panels[$j-1] == 0) {\n                $temp_panels[$j-1] = 1 - $temp_panels[$j-1];\n                $moves++;\n                $j++;\n                last if $j > $n;\n            }\n            last if $temp_panels[$target-1] == 1;\n            last if $j > $n;\n            $target = $j;\n        }\n\n        if ($temp_panels[$target-1] == 1) {\n            if ($min_moves == -1 || $moves < $min_moves) {\n                $min_moves = $moves;\n            }\n        }\n    }\n\n    return $min_moves;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k, $l) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @x = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @a = split ' ', $input;\n\n# Call the function and print the result\nmy $result = minimal_moves($n, $k, $l, \\@x, \\@a);\nprint $result;\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let mut lines = input.lines();\n    \n    let params: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = params[0];\n    let k = params[1];\n    let l = params[2];\n    \n    let on_panels: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let flip_panels: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut moves = 0;\n    let mut password = vec![false; n];\n    \n    for i in 0..k {\n        password[on_panels[i] - 1] = true;\n    }\n    \n    for i in 0..l {\n        let flip_panel = flip_panels[i];\n        \n        if password[flip_panel - 1] {\n            continue;\n        }\n        \n        let mut flip_count = 0;\n        let mut flip_start = flip_panel;\n        \n        while flip_start > 0 && !password[flip_start - 1] {\n            flip_count += 1;\n            flip_start -= 1;\n        }\n        \n        let mut flip_end = flip_panel + 1;\n        \n        while flip_end <= n && !password[flip_end - 1] {\n            flip_count += 1;\n            flip_end += 1;\n        }\n        \n        if flip_count % 2 == 1 {\n            println!(\"-1\");\n            return;\n        }\n        \n        moves += flip_count \/ 2;\n        \n        for j in flip_start..flip_end {\n            password[j - 1] = !password[j - 1];\n        }\n    }\n    \n    println!(\"{}\", moves);\n}"}
{"title":"A. Kalevitch and Chess","description":"A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.As before, the chessboard is a square-checkered board with the squares arranged in a 8\u00d78 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.It goes without saying that in such business one should economize on everything \u2014 for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"64 megabytes","input_spec":"The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character \u2014 for a square painted black.\nIt is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical\/column or horizontal\/row).\n","output_spec":"Output the only number \u2014 the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.\n","notes":null,"sample_inputs":["WWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\n","WWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\n"],"sample_outputs":["3\n","1\n"],"id":"7-A","difficulty":1100,"tags":["brute+force","constructive+algorithms"],"src_uid":"8b6ae2190413b23f47e2958a7d4e7bc0","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    vector<string> board(8);\\n    for(int i=0; i<8; i++) {\\n        cin >> board[i];\\n    }\\n\\n    int rows = 0;\\n    int cols = 0;\\n\\n    for(int i=0; i<8; i++) {\\n        bool rowPainted = false;\\n        bool colPainted = false;\\n        for(int j=0; j<8; j++) {\\n            if(board[i][j] == 'B') {\\n                rowPainted = true;\\n                break;\\n            }\\n        }\\n        for(int j=0; j<8; j++) {\\n            if(board[j][i] == 'B') {\\n                colPainted = true;\\n                break;\\n            }\\n        }\\n        if(!rowPainted) rows++;\\n        if(!colPainted) cols++;\\n    }\\n\\n    int strokes = min(rows, cols);\\n    cout << strokes << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class ChessboardPainter {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        char[][] chessboard = new char[8][8];\\n\\n        \/\/ Read input\\n        for (int i = 0; i < 8; i++) {\\n            String line = scanner.nextLine();\\n            for (int j = 0; j < 8; j++) {\\n                chessboard[i][j] = line.charAt(j);\\n            }\\n        }\\n\\n        int rowsToPaint = 0;\\n        int columnsToPaint = 0;\\n\\n        \/\/ Count the number of rows and columns to paint\\n        for (int i = 0; i < 8; i++) {\\n            boolean rowPainted = false;\\n            boolean columnPainted = false;\\n            for (int j = 0; j < 8; j++) {\\n                if (chessboard[i][j] == 'B') {\\n                    rowPainted = true;\\n                }\\n                if (chessboard[j][i] == 'B') {\\n                    columnPainted = true;\\n                }\\n            }\\n            if (!rowPainted) {\\n                rowsToPaint++;\\n            }\\n            if (!columnPainted) {\\n                columnsToPaint++;\\n            }\\n        }\\n\\n        int minStrokes = Math.min(rowsToPaint, columnsToPaint);\\n        System.out.println(minStrokes);\\n    }\\n}","Python":"def min_strokes(chessboard):\n    rows = [0] * 8\n    cols = [0] * 8\n    \n    for i in range(8):\n        for j in range(8):\n            if chessboard[i][j] == 'B':\n                rows[i] = 1\n                cols[j] = 1\n    \n    return str(8 - sum(rows) + 8 - sum(cols))\n\nchessboard = input().strip().split('\\\\n')\nprint(min_strokes(chessboard))","C":"#include <stdio.h>\\n\\nint main() {\\n    char board[8][8];\\n    int i, j, rows = 0, cols = 0;\\n\\n    \/\/ Read the input\\n    for(i = 0; i < 8; i++) {\\n        for(j = 0; j < 8; j++) {\\n            scanf(\\\" %c\\\", &board[i][j]);\\n        }\\n    }\\n\\n    \/\/ Count the number of rows and columns to paint\\n    for(i = 0; i < 8; i++) {\\n        int row_paint = 1, col_paint = 1;\\n        for(j = 0; j < 8; j++) {\\n            if(board[i][j] == 'B') {\\n                row_paint = 0;\\n            }\\n            if(board[j][i] == 'B') {\\n                col_paint = 0;\\n            }\\n        }\\n        rows += row_paint;\\n        cols += col_paint;\\n    }\\n\\n    \/\/ Print the result\\n    printf(\\\"%d\\\\n\\\", rows < cols ? rows : cols);\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = new string[]\n        {\n            \\\"WWWBWWBW\\\",\n            \\\"BBBBBBBB\\\",\n            \\\"WWWBWWBW\\\",\n            \\\"WWWBWWBW\\\",\n            \\\"WWWBWWBW\\\",\n            \\\"WWWBWWBW\\\",\n            \\\"WWWBWWBW\\\",\n            \\\"WWWBWWBW\\\"\n        };\n\n        int minStrokes = GetMinimumStrokes(input);\n        Console.WriteLine(minStrokes);\n    }\n\n    static int GetMinimumStrokes(string[] input)\n    {\n        int minStrokes = 0;\n\n        for (int i = 0; i < 8; i++)\n        {\n            bool rowHasBlack = false;\n            bool columnHasBlack = false;\n\n            for (int j = 0; j < 8; j++)\n            {\n                if (input[i][j] == 'B')\n                {\n                    rowHasBlack = true;\n                    break;\n                }\n            }\n\n            for (int j = 0; j < 8; j++)\n            {\n                if (input[j][i] == 'B')\n                {\n                    columnHasBlack = true;\n                    break;\n                }\n            }\n\n            if (!rowHasBlack)\n            {\n                minStrokes++;\n            }\n\n            if (!columnHasBlack)\n            {\n                minStrokes++;\n            }\n        }\n\n        return minStrokes;\n    }\n}","Ruby":"def min_strokes(chessboard)\n  rows = 0\n  cols = 0\n\n  chessboard.each do |row|\n    rows += 1 if row.include?('W')\n  end\n\n  chessboard.transpose.each do |col|\n    cols += 1 if col.include?('W')\n  end\n\n  [rows, cols].min.to_s\nend\n\ninput = 'WWWBWWBW\\nBBBBBBBB\\nWWWBWWBW\\nWWWBWWBW\\nWWWBWWBW\\nWWWBWWBW\\nWWWBWWBW\\nWWWBWWBW\\n'\nchessboard = input.split('\\\\n').map { |row| row.chars }\n\noutput = min_strokes(chessboard)\n\nputs output","delphi":"program ChessboardPainter;\\n\\nvar\\n  board: array[1..8, 1..8] of Char;\\n  i, j: Integer;\\n  rows, cols: Integer;\\n  stroke: Boolean;\\n\\nbegin\\n  \/\/ Read the input\\n  for i := 1 to 8 do\\n  begin\\n    for j := 1 to 8 do\\n    begin\\n      Read(board[i, j]);\\n    end;\\n    ReadLn;\\n  end;\\n\\n  \/\/ Initialize variables\\n  rows := 0;\\n  cols := 0;\\n  stroke := False;\\n\\n  \/\/ Count the number of rows and columns to paint\\n  for i := 1 to 8 do\\n  begin\\n    for j := 1 to 8 do\\n    begin\\n      if (board[i, j] = 'W') and (not stroke) then\\n      begin\\n        rows := rows + 1;\\n        stroke := True;\\n      end;\\n      if (board[j, i] = 'W') and (not stroke) then\\n      begin\\n        cols := cols + 1;\\n        stroke := True;\\n      end;\\n    end;\\n    stroke := False;\\n  end;\\n\\n  \/\/ Output the result\\n  if rows < cols then\\n    WriteLn(rows)\\n  else\\n    WriteLn(cols);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar input string\\n\\tfmt.Scan(&input)\\n\\n\\tboard := strings.Split(input, \\\"\\\\n\\\")\\n\\n\\trows := 0\\n\\tcols := 0\\n\\n\\tfor i := 0; i < 8; i++ {\\n\\t\\tif strings.Contains(board[i], \\\"B\\\") {\\n\\t\\t\\trows++\\n\\t\\t}\\n\\t\\tif strings.Contains(board[0][i:]+board[1][i:]+board[2][i:]+board[3][i:]+board[4][i:]+board[5][i:]+board[6][i:]+board[7][i:], \\\"B\\\") {\\n\\t\\t\\tcols++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(rows + cols)\\n}","Javascript":"function minimumStrokes(clientRequirements) {\n  let strokes = 0;\n  let rows = new Array(8).fill(false);\n  let columns = new Array(8).fill(false);\n\n  for (let i = 0; i < 8; i++) {\n    for (let j = 0; j < 8; j++) {\n      if (clientRequirements[i][j] === 'B') {\n        rows[i] = true;\n        columns[j] = true;\n      }\n    }\n  }\n\n  for (let i = 0; i < 8; i++) {\n    if (!rows[i]) {\n      strokes++;\n    }\n    if (!columns[i]) {\n      strokes++;\n    }\n  }\n\n  return strokes.toString();\n}\n\nconst clientRequirements = [\n  'WWWBWWBW',\n  'BBBBBBBB',\n  'WWWBWWBW',\n  'WWWBWWBW',\n  'WWWBWWBW',\n  'WWWBWWBW',\n  'WWWBWWBW',\n  'WWWBWWBW'\n];\n\nconsole.log(minimumStrokes(clientRequirements));","Kotlin":"fun main() {\n    val input = readLine()!!.split(\"\\\\n\")\n    val matrix = Array(8) { Array(8) { 'W' } }\n    var rows = 0\n    var cols = 0\n    \n    for (i in 0 until 8) {\n        for (j in 0 until 8) {\n            matrix[i][j] = input[i][j]\n        }\n    }\n    \n    for (i in 0 until 8) {\n        var rowPainted = false\n        var colPainted = false\n        \n        for (j in 0 until 8) {\n            if (matrix[i][j] == 'B') {\n                rowPainted = true\n                break\n            }\n        }\n        \n        for (j in 0 until 8) {\n            if (matrix[j][i] == 'B') {\n                colPainted = true\n                break\n            }\n        }\n        \n        if (!rowPainted) {\n            rows++\n        }\n        \n        if (!colPainted) {\n            cols++\n        }\n    }\n    \n    val minStrokes = minOf(rows, cols)\n    println(minStrokes)\n}","PHP":"<?php\\n\\nfunction minStrokes($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $board = [];\\n    $count = 0;\\n\\n    \/\/ Create the chessboard\\n    for ($i = 0; $i < 8; $i++) {\\n        $board[] = str_split($lines[$i]);\\n    }\\n\\n    \/\/ Check each row\\n    for ($i = 0; $i < 8; $i++) {\\n        $hasBlack = false;\\n        for ($j = 0; $j < 8; $j++) {\\n            if ($board[$i][$j] == 'B') {\\n                $hasBlack = true;\\n                break;\\n            }\\n        }\\n        if (!$hasBlack) {\\n            $count++;\\n        }\\n    }\\n\\n    \/\/ Check each column\\n    for ($j = 0; $j < 8; $j++) {\\n        $hasBlack = false;\\n        for ($i = 0; $i < 8; $i++) {\\n            if ($board[$i][$j] == 'B') {\\n                $hasBlack = true;\\n                break;\\n            }\\n        }\\n        if (!$hasBlack) {\\n            $count++;\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n$input = 'WWWBWWBW\\\\nBBBBBBBB\\\\nWWWBWWBW\\\\nWWWBWWBW\\\\nWWWBWWBW\\\\nWWWBWWBW\\\\nWWWBWWBW\\\\nWWWBWWBW';\\n$result = minStrokes($input);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] input = [\\r\\n        \\\"WWWBWWBW\\\",\\r\\n        \\\"BBBBBBBB\\\",\\r\\n        \\\"WWWBWWBW\\\",\\r\\n        \\\"WWWBWWBW\\\",\\r\\n        \\\"WWWBWWBW\\\",\\r\\n        \\\"WWWBWWBW\\\",\\r\\n        \\\"WWWBWWBW\\\",\\r\\n        \\\"WWWBWWBW\\\"\\r\\n    ];\\r\\n\\r\\n    int rows = 0;\\r\\n    int cols = 0;\\r\\n\\r\\n    foreach (string line; input)\\r\\n    {\\r\\n        bool hasBlack = false;\\r\\n\\r\\n        foreach (char c; line)\\r\\n        {\\r\\n            if (c == 'B')\\r\\n            {\\r\\n                hasBlack = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!hasBlack)\\r\\n        {\\r\\n            rows++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    foreach (int i; 0..8)\\r\\n    {\\r\\n        bool hasBlack = false;\\r\\n\\r\\n        foreach (int j; 0..8)\\r\\n        {\\r\\n            if (input[j][i] == 'B')\\r\\n            {\\r\\n                hasBlack = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!hasBlack)\\r\\n        {\\r\\n            cols++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(rows + cols);\\r\\n}","perl":"\n# Read the input from standard input\nmy @input = <STDIN>;\n\n# Initialize variables\nmy $rows = 0;\nmy $columns = 0;\n\n# Iterate through each row and column\nfor my $i (0..7) {\n    for my $j (0..7) {\n        # Check if the current square is white\n        if ($input[$i] =~ \/W\/ && $input[$j] =~ \/W\/) {\n            # Increment the count of rows and columns\n            $rows++;\n            $columns++;\n            \n            # Mark the row and column as painted\n            $input[$i] =~ s\/W\/B\/;\n            $input[$j] =~ s\/W\/B\/;\n        }\n    }\n}\n\n# Print the minimum amount of rows and columns\nprint $rows + $columns;\n","Rust":"fn main() {\n    let mut board = [[0; 8]; 8];\n    let mut strokes = 0;\n\n    for i in 0..8 {\n        let line = read_line();\n        for (j, c) in line.chars().enumerate() {\n            if c == 'B' {\n                board[i][j] = 1;\n            }\n        }\n    }\n\n    for i in 0..8 {\n        let mut row_stroke = true;\n        let mut col_stroke = true;\n\n        for j in 0..8 {\n            if board[i][j] == 1 {\n                row_stroke = false;\n            }\n            if board[j][i] == 1 {\n                col_stroke = false;\n            }\n        }\n\n        if row_stroke {\n            strokes += 1;\n        }\n        if col_stroke {\n            strokes += 1;\n        }\n    }\n\n    println!(\"{}\", strokes);\n}\n\nfn read_line() -> String {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    input.trim().to_string()\n}"}
{"title":"B. Memory Manager","description":"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet \u2014 the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:   alloc n \u2014 to allocate n bytes of the memory and return the allocated block's identifier x;  erase x \u2014 to erase the block with the identifier x;  defragment \u2014 to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; The memory model in this case is very simple. It is a sequence of m bytes, numbered for convenience from the first to the m-th.The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of n successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"The first line of the input data contains two positive integers t and m (1\u2264t\u2264100;1\u2264m\u2264100), where t \u2014 the amount of operations given to the memory manager for processing, and m \u2014 the available memory size in bytes. Then there follow t lines where the operations themselves are given. The first operation is alloc n (1\u2264n\u2264100), where n is an integer. The second one is erase x, where x is an arbitrary 32-bit integer numerical token. The third operation is defragment. \n","output_spec":"Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.\n","notes":null,"sample_inputs":["6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6\n"],"sample_outputs":["1\n2\nNULL\n3\n"],"id":"7-B","difficulty":1600,"tags":["implementation"],"src_uid":"a6cba17c5ddb93f6741e00280fb6c54c","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int t, m;\\n    cin >> t >> m;\\n    vector<int> memory(m, 0);\\n    vector<int> blocks;\\n    int nextId = 1;\\n\\n    for (int i = 0; i < t; i++) {\\n        string operation;\\n        cin >> operation;\\n\\n        if (operation == \\\"alloc\\\") {\\n            int n;\\n            cin >> n;\\n\\n            int start = -1;\\n            for (int j = 0; j < m; j++) {\\n                if (memory[j] == 0) {\\n                    int count = 0;\\n                    while (j + count < m && memory[j + count] == 0 && count < n) {\\n                        count++;\\n                    }\\n\\n                    if (count == n) {\\n                        start = j;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (start != -1) {\\n                for (int j = start; j < start + n; j++) {\\n                    memory[j] = nextId;\\n                }\\n                blocks.push_back(nextId);\\n                nextId++;\\n                cout << blocks.size() << endl;\\n            } else {\\n                cout << \\\"NULL\\\" << endl;\\n            }\\n        } else if (operation == \\\"erase\\\") {\\n            int x;\\n            cin >> x;\\n\\n            auto it = find(blocks.begin(), blocks.end(), x);\\n            if (it != blocks.end()) {\\n                blocks.erase(it);\\n                for (int j = 0; j < m; j++) {\\n                    if (memory[j] == x) {\\n                        memory[j] = 0;\\n                    }\\n                }\\n            } else {\\n                cout << \\\"ILLEGAL_ERASE_ARGUMENT\\\" << endl;\\n            }\\n        } else if (operation == \\\"defragment\\\") {\\n            int count = 0;\\n            for (int j = 0; j < m; j++) {\\n                if (memory[j] != 0) {\\n                    memory[count] = memory[j];\\n                    count++;\\n                }\\n            }\\n            for (int j = count; j < m; j++) {\\n                memory[j] = 0;\\n            }\\n        }\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class MemoryManager {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        List<Integer> memory = new ArrayList<>();\n        List<Integer> allocatedBlocks = new ArrayList<>();\n        \n        for (int i = 0; i < t; i++) {\n            String operation = scanner.nextLine();\n            \n            if (operation.startsWith(\"alloc\")) {\n                int n = Integer.parseInt(operation.split(\" \")[1]);\n                int blockIndex = findFreeBlock(memory, n);\n                \n                if (blockIndex != -1) {\n                    allocatedBlocks.add(blockIndex);\n                    System.out.println(allocatedBlocks.size());\n                } else {\n                    System.out.println(\"NULL\");\n                }\n            } else if (operation.startsWith(\"erase\")) {\n                int x = Integer.parseInt(operation.split(\" \")[1]);\n                \n                if (x >= 1 && x <= allocatedBlocks.size()) {\n                    int blockIndex = allocatedBlocks.get(x - 1);\n                    memory.set(blockIndex, 0);\n                    allocatedBlocks.remove(x - 1);\n                } else {\n                    System.out.println(\"ILLEGAL_ERASE_ARGUMENT\");\n                }\n            } else if (operation.equals(\"defragment\")) {\n                defragmentMemory(memory);\n            }\n        }\n    }\n    \n    private static int findFreeBlock(List<Integer> memory, int n) {\n        int start = -1;\n        int count = 0;\n        \n        for (int i = 0; i < memory.size(); i++) {\n            if (memory.get(i) == 0) {\n                if (start == -1) {\n                    start = i;\n                }\n                \n                count++;\n                \n                if (count == n) {\n                    for (int j = start; j < start + n; j++) {\n                        memory.set(j, 1);\n                    }\n                    \n                    return start;\n                }\n            } else {\n                start = -1;\n                count = 0;\n            }\n        }\n        \n        return -1;\n    }\n    \n    private static void defragmentMemory(List<Integer> memory) {\n        int writeIndex = 0;\n        \n        for (int i = 0; i < memory.size(); i++) {\n            if (memory.get(i) == 1) {\n                memory.set(writeIndex, 1);\n                writeIndex++;\n            }\n        }\n        \n        for (int i = writeIndex; i < memory.size(); i++) {\n            memory.set(i, 0);\n        }\n    }\n}","Python":"def memory_manager(t, m, operations):\n    memory = [0] * m\n    blocks = []\n    next_id = 1\n    result = []\n\n    def alloc(n):\n        for i in range(m - n + 1):\n            if all(memory[i:i+n] == 0 for i in range(i, i+n)):\n                for j in range(i, i+n):\n                    memory[j] = next_id\n                blocks.append(next_id)\n                next_id += 1\n                return next_id - 1\n        return None\n\n    def erase(x):\n        if x in blocks:\n            for i in range(m):\n                if memory[i] == x:\n                    memory[i] = 0\n            blocks.remove(x)\n        else:\n            return 'ILLEGAL_ERASE_ARGUMENT'\n\n    def defragment():\n        new_memory = [0] * m\n        new_blocks = []\n        next_id = 1\n        for block in blocks:\n            for i in range(m):\n                if memory[i] == block:\n                    new_memory[i] = next_id\n            new_blocks.append(next_id)\n            next_id += 1\n        memory = new_memory\n        blocks = new_blocks\n\n    for operation in operations:\n        if operation.startswith('alloc'):\n            n = int(operation.split()[1])\n            result.append(str(alloc(n)))\n        elif operation.startswith('erase'):\n            x = int(operation.split()[1])\n            result.append(str(erase(x)))\n        elif operation.startswith('defragment'):\n            defragment()\n\n    return result\n\nt, m = map(int, input().split())\noperations = []\nfor _ in range(t):\n    operations.append(input())\n\nresult = memory_manager(t, m, operations)\nprint('\\\\n'.join(result))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdbool.h>\\n\\n#define MAX_SIZE 100\\n\\nint memory[MAX_SIZE];\\nbool isAllocated[MAX_SIZE];\\nint nextId = 1;\\n\\nint alloc(int n) {\\n    int start = -1;\\n    for (int i = 0; i < MAX_SIZE; i++) {\\n        if (!isAllocated[i]) {\\n            int j;\\n            for (j = i; j < i + n; j++) {\\n                if (j >= MAX_SIZE || isAllocated[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == i + n) {\\n                start = i;\\n                break;\\n            }\\n        }\\n    }\\n    if (start != -1) {\\n        for (int i = start; i < start + n; i++) {\\n            isAllocated[i] = true;\\n            memory[i] = nextId;\\n        }\\n        nextId++;\\n        return nextId - 1;\\n    } else {\\n        return -1;\\n    }\\n}\\n\\nvoid erase(int x) {\\n    bool found = false;\\n    for (int i = 0; i < MAX_SIZE; i++) {\\n        if (isAllocated[i] && memory[i] == x) {\\n            isAllocated[i] = false;\\n            found = true;\\n        }\\n    }\\n    if (!found) {\\n        printf(\\\"ILLEGAL_ERASE_ARGUMENT\\\\n\\\");\\n    }\\n}\\n\\nvoid defragment() {\\n    int count = 0;\\n    for (int i = 0; i < MAX_SIZE; i++) {\\n        if (isAllocated[i]) {\\n            memory[count] = memory[i];\\n            isAllocated[count] = true;\\n            if (count != i) {\\n                isAllocated[i] = false;\\n            }\\n            count++;\\n        }\\n    }\\n}\\n\\nint main() {\\n    int t, m;\\n    scanf(\\\"%d %d\\\", &t, &m);\\n    for (int i = 0; i < MAX_SIZE; i++) {\\n        isAllocated[i] = false;\\n    }\\n    for (int i = 0; i < t; i++) {\\n        char operation[10];\\n        scanf(\\\"%s\\\", operation);\\n        if (strcmp(operation, \\\"alloc\\\") == 0) {\\n            int n;\\n            scanf(\\\"%d\\\", &n);\\n            int result = alloc(n);\\n            if (result != -1) {\\n                printf(\\\"%d\\\\n\\\", result);\\n            } else {\\n                printf(\\\"NULL\\\\n\\\");\\n            }\\n        } else if (strcmp(operation, \\\"erase\\\") == 0) {\\n            int x;\\n            scanf(\\\"%d\\\", &x);\\n            erase(x);\\n        } else if (strcmp(operation, \\\"defragment\\\") == 0) {\\n            defragment();\\n        }\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\npublic class MemoryManager\n{\n    private List<int> memory;\n    private int nextId;\n\n    public MemoryManager(int size)\n    {\n        memory = new List<int>(new int[size]);\n        nextId = 1;\n    }\n\n    public int? Allocate(int blockSize)\n    {\n        for (int i = 0; i < memory.Count; i++)\n        {\n            if (memory[i] == 0)\n            {\n                int j = i;\n                while (j < memory.Count && memory[j] == 0 && j - i + 1 < blockSize)\n                {\n                    j++;\n                }\n\n                if (j - i + 1 == blockSize)\n                {\n                    for (int k = i; k <= j; k++)\n                    {\n                        memory[k] = nextId;\n                    }\n                    return nextId++;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public bool Erase(int blockId)\n    {\n        for (int i = 0; i < memory.Count; i++)\n        {\n            if (memory[i] == blockId)\n            {\n                memory[i] = 0;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public void Defragment()\n    {\n        int currentIndex = 0;\n        for (int i = 0; i < memory.Count; i++)\n        {\n            if (memory[i] != 0)\n            {\n                memory[currentIndex] = memory[i];\n                currentIndex++;\n            }\n        }\n\n        for (int i = currentIndex; i < memory.Count; i++)\n        {\n            memory[i] = 0;\n        }\n    }\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        string input = \"6 10\\nalloc 5\\nalloc 3\\nerase 1\\nalloc 6\\ndefragment\\nalloc 6\\n\";\n        string[] lines = input.Split('\\n');\n\n        string[] firstLine = lines[0].Split(' ');\n        int t = int.Parse(firstLine[0]);\n        int m = int.Parse(firstLine[1]);\n\n        MemoryManager memoryManager = new MemoryManager(m);\n\n        for (int i = 1; i <= t; i++)\n        {\n            string[] operation = lines[i].Split(' ');\n\n            if (operation[0] == \"alloc\")\n            {\n                int blockSize = int.Parse(operation[1]);\n                int? blockId = memoryManager.Allocate(blockSize);\n                Console.WriteLine(blockId != null ? blockId.ToString() : \"NULL\");\n            }\n            else if (operation[0] == \"erase\")\n            {\n                int blockId = int.Parse(operation[1]);\n                bool erased = memoryManager.Erase(blockId);\n                Console.WriteLine(erased ? \"\" : \"ILLEGAL_ERASE_ARGUMENT\");\n            }\n            else if (operation[0] == \"defragment\")\n            {\n                memoryManager.Defragment();\n            }\n        }\n    }\n}","Ruby":"\nclass MemoryManager\n  def initialize(m)\n    @memory = Array.new(m, 0)\n    @blocks = {}\n    @next_id = 1\n  end\n\n  def alloc(n)\n    start_index = find_free_block(n)\n    if start_index.nil?\n      return 'NULL'\n    else\n      block_id = @next_id\n      @next_id += 1\n      mark_block_as_allocated(start_index, n, block_id)\n      return block_id.to_s\n    end\n  end\n\n  def erase(block_id)\n    if @blocks[block_id].nil?\n      return 'ILLEGAL_ERASE_ARGUMENT'\n    else\n      start_index, size = @blocks[block_id]\n      mark_block_as_free(start_index, size)\n      @blocks.delete(block_id)\n      return ''\n    end\n  end\n\n  def defragment\n    free_blocks = []\n    allocated_blocks = []\n    @memory.each_with_index do |value, index|\n      if value == 0\n        free_blocks << index\n      else\n        allocated_blocks << index\n      end\n    end\n\n    allocated_blocks.each_with_index do |start_index, i|\n      size = @memory[start_index]\n      new_start_index = free_blocks[i]\n      move_block(start_index, size, new_start_index)\n      @blocks.each do |block_id, (block_start, block_size)|\n        if block_start == start_index\n          @blocks[block_id] = [new_start_index, block_size]\n        end\n      end\n    end\n\n    return ''\n  end\n\n  private\n\n  def find_free_block(n)\n    free_start_index = nil\n    free_size = 0\n    @memory.each_with_index do |value, index|\n      if value == 0\n        free_size += 1\n        if free_start_index.nil?\n          free_start_index = index\n        end\n        if free_size == n\n          return free_start_index\n        end\n      else\n        free_start_index = nil\n        free_size = 0\n      end\n    end\n    return nil\n  end\n\n  def mark_block_as_allocated(start_index, size, block_id)\n    (start_index..(start_index + size - 1)).each do |index|\n      @memory[index] = 1\n    end\n    @blocks[block_id] = [start_index, size]\n  end\n\n  def mark_block_as_free(start_index, size)\n    (start_index..(start_index + size - 1)).each do |index|\n      @memory[index] = 0\n    end\n  end\n\n  def move_block(start_index, size, new_start_index)\n    if start_index < new_start_index\n      (start_index..(start_index + size - 1)).each do |index|\n        @memory[index] = 0\n      end\n      (new_start_index..(new_start_index + size - 1)).each do |index|\n        @memory[index] = 1\n      end\n    else\n      (start_index..(start_index + size - 1)).reverse_each do |index|\n        @memory[index] = 0\n      end\n      (new_start_index..(new_start_index + size - 1)).reverse_each do |index|\n        @memory[index] = 1\n      end\n    end\n  end\nend\n\ninput = gets.chomp.split('\\\\n')\nt, m = input.shift.split.map(&:to_i)\noperations = input.map { |line| line.split }\n\nmemory_manager = MemoryManager.new(m)\noutput = []\n\noperations.each do |operation|\n  case operation[0]\n  when 'alloc'\n    output << memory_manager.alloc(operation[1].to_i)\n  when 'erase'\n    output << memory_manager.erase(operation[1].to_i)\n  when 'defragment'\n    output << memory_manager.defragment\n  end\nend\n\nputs output.join('\\\\n')\n","delphi":"program MemoryManager;\\n\\nvar\\n  t, m, n, x, i, j, k: integer;\\n  memory: array[1..100] of boolean;\\n  identifiers: array[1..100] of integer;\\n  operation: string;\\n\\nbegin\\n  readln(t, m);\\n\\n  for i := 1 to m do\\n    memory[i] := true;\\n\\n  k := 1;\\n\\n  for i := 1 to t do\\n  begin\\n    readln(operation);\\n\\n    if Pos('alloc', operation) = 1 then\\n    begin\\n      n := StrToInt(Copy(operation, 7, Length(operation) - 6));\\n\\n      for j := 1 to m - n + 1 do\\n      begin\\n        if memory[j] then\\n        begin\\n          identifiers[k] := j;\\n\\n          for x := j to j + n - 1 do\\n            memory[x] := false;\\n\\n          writeln(k);\\n          k := k + 1;\\n          Break;\\n        end;\\n      end;\\n\\n      if j = m - n + 2 then\\n        writeln('NULL');\\n    end\\n    else if Pos('erase', operation) = 1 then\\n    begin\\n      x := StrToInt(Copy(operation, 7, Length(operation) - 6));\\n\\n      if (x >= 1) and (x < k) then\\n      begin\\n        for j := identifiers[x] to m do\\n          memory[j] := true;\\n      end\\n      else\\n        writeln('ILLEGAL_ERASE_ARGUMENT');\\n    end\\n    else if Pos('defragment', operation) = 1 then\\n    begin\\n      for j := 1 to m do\\n      begin\\n        if not memory[j] then\\n        begin\\n          for x := j to m do\\n          begin\\n            if memory[x] then\\n            begin\\n              memory[j] := true;\\n              memory[x] := false;\\n              Break;\\n            end;\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar t, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &t, &m)\\n\\n\\tmemory := make([]bool, m)\\n\\tallocated := make(map[int]bool)\\n\\n\\tnextID := 1\\n\\n\\tfor i := 0; i < t; i++ {\\n\\t\\tvar operation string\\n\\t\\tfmt.Scanln(&operation)\\n\\n\\t\\tif strings.HasPrefix(operation, \\\"alloc\\\") {\\n\\t\\t\\tn, _ := strconv.Atoi(strings.Split(operation, \\\" \\\")[1])\\n\\t\\t\\tallocatedID := allocateMemory(memory, n)\\n\\t\\t\\tfmt.Println(allocatedID)\\n\\t\\t} else if strings.HasPrefix(operation, \\\"erase\\\") {\\n\\t\\t\\tx, _ := strconv.Atoi(strings.Split(operation, \\\" \\\")[1])\\n\\t\\t\\teraseMemory(memory, allocated, x)\\n\\t\\t} else if operation == \\\"defragment\\\" {\\n\\t\\t\\tdefragmentMemory(memory, allocated)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc allocateMemory(memory []bool, n int) int {\\n\\tfor i := 0; i <= len(memory)-n; i++ {\\n\\t\\tif !memory[i] {\\n\\t\\t\\tallocatedID := getNextID()\\n\\t\\t\\tfor j := i; j < i+n; j++ {\\n\\t\\t\\t\\tmemory[j] = true\\n\\t\\t\\t}\\n\\t\\t\\treturn allocatedID\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc eraseMemory(memory []bool, allocated map[int]bool, x int) {\\n\\tif allocated[x] {\\n\\t\\tfor i := range memory {\\n\\t\\t\\tif memory[i] && allocated[i+1] {\\n\\t\\t\\t\\tallocated[i+1] = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tallocated[x] = false\\n\\t} else {\\n\\t\\tfmt.Println(\\\"ILLEGAL_ERASE_ARGUMENT\\\")\\n\\t}\\n}\\n\\nfunc defragmentMemory(memory []bool, allocated map[int]bool) {\\n\\tfreeIndex := 0\\n\\tfor i := range memory {\\n\\t\\tif !memory[i] {\\n\\t\\t\\tfor j := i; j < len(memory); j++ {\\n\\t\\t\\t\\tif memory[j] {\\n\\t\\t\\t\\t\\tmemory[i], memory[j] = memory[j], memory[i]\\n\\t\\t\\t\\t\\tallocated[i+1], allocated[j+1] = allocated[j+1], allocated[i+1]\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc getNextID() int {\\n\\tnextID++\\n\\treturn nextID\\n}","Javascript":"function memoryManager(t, m, operations) {\n    let memory = new Array(m).fill(0); \/\/ Initialize memory array with zeros\n    let blocks = []; \/\/ Array to store allocated blocks\n    \n    let result = []; \/\/ Array to store the output\n    \n    let nextId = 1; \/\/ Next block identifier\n    \n    for (let i = 0; i < t; i++) {\n        let operation = operations[i].split(' ');\n        \n        if (operation[0] === 'alloc') {\n            let n = parseInt(operation[1]);\n            let block = findFreeBlock(n);\n            \n            if (block !== null) {\n                allocateBlock(block, n);\n                result.push(nextId.toString());\n                nextId++;\n            } else {\n                result.push('NULL');\n            }\n        } else if (operation[0] === 'erase') {\n            let x = parseInt(operation[1]);\n            let block = blocks.find(block => block.id === x);\n            \n            if (block) {\n                eraseBlock(block);\n            } else {\n                result.push('ILLEGAL_ERASE_ARGUMENT');\n            }\n        } else if (operation[0] === 'defragment') {\n            defragment();\n        }\n    }\n    \n    return result;\n}\n\nfunction findFreeBlock(n) {\n    let start = 0;\n    let end = 0;\n    \n    for (let i = 0; i < memory.length; i++) {\n        if (memory[i] === 0) {\n            if (start === 0) {\n                start = i;\n            }\n            \n            end = i;\n            \n            if (end - start + 1 >= n) {\n                return { start, end };\n            }\n        } else {\n            start = 0;\n            end = 0;\n        }\n    }\n    \n    return null;\n}\n\nfunction allocateBlock(block, n) {\n    for (let i = block.start; i <= block.start + n - 1; i++) {\n        memory[i] = 1;\n    }\n    \n    blocks.push({ id: nextId, start: block.start, end: block.start + n - 1 });\n}\n\nfunction eraseBlock(block) {\n    for (let i = block.start; i <= block.end; i++) {\n        memory[i] = 0;\n    }\n    \n    blocks = blocks.filter(b => b.id !== block.id);\n}\n\nfunction defragment() {\n    let newMemory = new Array(m).fill(0);\n    let offset = 0;\n    \n    for (let i = 0; i < blocks.length; i++) {\n        let block = blocks[i];\n        \n        for (let j = block.start; j <= block.end; j++) {\n            newMemory[offset] = 1;\n            offset++;\n        }\n        \n        blocks[i].start = offset - (block.end - block.start + 1);\n        blocks[i].end = offset - 1;\n    }\n    \n    memory = newMemory;\n}\n\n\/\/ Sample input\nlet input = '6 10\\\\nalloc 5\\\\nalloc 3\\\\nerase 1\\\\nalloc 6\\\\ndefragment\\\\nalloc 6\\\\n';\n\nlet lines = input.split('\\\\n');\nlet params = lines[0].split(' ');\nlet t = parseInt(params[0]);\nlet m = parseInt(params[1]);\nlet operations = lines.slice(1);\n\nlet output = memoryManager(t, m, operations);\n\nconsole.log(output.join('\\\\n'));","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val t = input[0].toInt()\n    val m = input[1].toInt()\n    \n    val memory = BooleanArray(m)\n    val blocks = mutableMapOf<Int, Int>()\n    var nextId = 1\n    \n    repeat(t) {\n        val operation = scanner.nextLine().split(\" \")\n        when (operation[0]) {\n            \"alloc\" -> {\n                val n = operation[1].toInt()\n                var start = -1\n                for (i in 0 until m) {\n                    if (!memory[i]) {\n                        var j = i\n                        while (j < m && !memory[j]) {\n                            if (j - i + 1 == n) {\n                                start = i\n                                break\n                            }\n                            j++\n                        }\n                        if (start != -1) break\n                        i = j\n                    }\n                }\n                if (start != -1) {\n                    for (i in start until start + n) {\n                        memory[i] = true\n                    }\n                    blocks[nextId] = start\n                    println(nextId)\n                    nextId++\n                } else {\n                    println(\"NULL\")\n                }\n            }\n            \"erase\" -> {\n                val x = operation[1].toInt()\n                if (blocks.containsKey(x)) {\n                    val start = blocks[x]!!\n                    for (i in start until start + m) {\n                        if (memory[i]) {\n                            memory[i] = false\n                        } else {\n                            break\n                        }\n                    }\n                    blocks.remove(x)\n                } else {\n                    println(\"ILLEGAL_ERASE_ARGUMENT\")\n                }\n            }\n            \"defragment\" -> {\n                var index = 0\n                for (i in 0 until m) {\n                    if (memory[i]) {\n                        memory[i] = false\n                        memory[index] = true\n                        index++\n                    }\n                }\n                blocks.forEach { (id, start) ->\n                    blocks[id] = start - (start - index)\n                }\n            }\n        }\n    }\n}","PHP":"<?php\\n\\nfunction memoryManager($t, $m, $operations) {\\n    $memory = array_fill(0, $m, 0);\\n    $blocks = [];\\n    $nextId = 1;\\n    $output = [];\\n\\n    foreach ($operations as $operation) {\\n        $parts = explode(' ', $operation);\\n        $command = $parts[0];\\n\\n        if ($command === 'alloc') {\\n            $size = intval($parts[1]);\\n            $blockId = allocateMemory($memory, $size);\\n\\n            if ($blockId === null) {\\n                $output[] = 'NULL';\\n            } else {\\n                $blocks[$blockId] = $size;\\n                $output[] = $blockId;\\n            }\\n        } elseif ($command === 'erase') {\\n            $blockId = intval($parts[1]);\\n\\n            if (isset($blocks[$blockId])) {\\n                eraseMemory($memory, $blockId);\\n                unset($blocks[$blockId]);\\n            } else {\\n                $output[] = 'ILLEGAL_ERASE_ARGUMENT';\\n            }\\n        } elseif ($command === 'defragment') {\\n            defragmentMemory($memory, $blocks);\\n        }\\n    }\\n\\n    return $output;\\n}\\n\\nfunction allocateMemory(&$memory, $size) {\\n    $start = 0;\\n    $end = count($memory) - 1;\\n    $blockId = null;\\n\\n    while ($start + $size <= $end) {\\n        $found = true;\\n\\n        for ($i = $start; $i < $start + $size; $i++) {\\n            if ($memory[$i] !== 0) {\\n                $found = false;\\n                $start = $i + 1;\\n                break;\\n            }\\n        }\\n\\n        if ($found) {\\n            $blockId = $GLOBALS['nextId'];\\n            $GLOBALS['nextId']++;\\n\\n            for ($i = $start; $i < $start + $size; $i++) {\\n                $memory[$i] = $blockId;\\n            }\\n\\n            break;\\n        }\\n    }\\n\\n    return $blockId;\\n}\\n\\nfunction eraseMemory(&$memory, $blockId) {\\n    for ($i = 0; $i < count($memory); $i++) {\\n        if ($memory[$i] === $blockId) {\\n            $memory[$i] = 0;\\n        }\\n    }\\n}\\n\\nfunction defragmentMemory(&$memory, &$blocks) {\\n    $newMemory = array_fill(0, count($memory), 0);\\n    $newBlocks = [];\\n    $index = 0;\\n\\n    foreach ($blocks as $blockId => $size) {\\n        for ($i = 0; $i < $size; $i++) {\\n            $newMemory[$index] = $blockId;\\n            $index++;\\n        }\\n\\n        $newBlocks[$blockId] = $size;\\n    }\\n\\n    $memory = $newMemory;\\n    $blocks = $newBlocks;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents('php:\/\/stdin')));\\nlist($t, $m) = explode(' ', $input[0]);\\n$operations = array_slice($input, 1, $t);\\n\\n$output = memoryManager($t, $m, $operations);\\necho implode(\\\"\\\\n\\\", $output);\\n","d":"import std.stdio;\\r\\nimport std.string;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int t, m;\\r\\n    scanf(\\\"%d %d\\\", &t, &m);\\r\\n\\r\\n    int[] memory = new int[m];\\r\\n    int[] blocks = new int[t];\\r\\n    int blockCount = 0;\\r\\n\\r\\n    for (int i = 0; i < t; i++)\\r\\n    {\\r\\n        string operation;\\r\\n        scanf(\\\"%s\\\", &operation);\\r\\n\\r\\n        if (operation == \\\"alloc\\\")\\r\\n        {\\r\\n            int n;\\r\\n            scanf(\\\"%d\\\", &n);\\r\\n\\r\\n            int start = -1;\\r\\n            for (int j = 0; j < m; j++)\\r\\n            {\\r\\n                if (memory[j] == 0)\\r\\n                {\\r\\n                    int blockSize = 0;\\r\\n                    for (int k = j; k < m; k++)\\r\\n                    {\\r\\n                        if (memory[k] == 0)\\r\\n                        {\\r\\n                            blockSize++;\\r\\n                            if (blockSize == n)\\r\\n                            {\\r\\n                                start = j;\\r\\n                                break;\\r\\n                            }\\r\\n                        }\\r\\n                        else\\r\\n                        {\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    if (start != -1)\\r\\n                    {\\r\\n                        for (int k = start; k < start + n; k++)\\r\\n                        {\\r\\n                            memory[k] = 1;\\r\\n                        }\\r\\n\\r\\n                        blockCount++;\\r\\n                        blocks[blockCount - 1] = blockCount;\\r\\n\\r\\n                        printf(\\\"%d\\\\n\\\", blockCount);\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (start == -1)\\r\\n            {\\r\\n                printf(\\\"NULL\\\\n\\\");\\r\\n            }\\r\\n        }\\r\\n        else if (operation == \\\"erase\\\")\\r\\n        {\\r\\n            int x;\\r\\n            scanf(\\\"%d\\\", &x);\\r\\n\\r\\n            if (x < 1 || x > blockCount)\\r\\n            {\\r\\n                printf(\\\"ILLEGAL_ERASE_ARGUMENT\\\\n\\\");\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                int start = -1;\\r\\n                for (int j = 0; j < m; j++)\\r\\n                {\\r\\n                    if (memory[j] == x)\\r\\n                    {\\r\\n                        start = j;\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                if (start != -1)\\r\\n                {\\r\\n                    for (int j = start; j < m; j++)\\r\\n                    {\\r\\n                        if (memory[j] == x)\\r\\n                        {\\r\\n                            memory[j] = 0;\\r\\n                        }\\r\\n                        else\\r\\n                        {\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    printf(\\\"%d\\\\n\\\", x);\\r\\n                }\\r\\n                else\\r\\n                {\\r\\n                    printf(\\\"ILLEGAL_ERASE_ARGUMENT\\\\n\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else if (operation == \\\"defragment\\\")\\r\\n        {\\r\\n            int[] newMemory = new int[m];\\r\\n            int newIndex = 0;\\r\\n\\r\\n            for (int j = 0; j < m; j++)\\r\\n            {\\r\\n                if (memory[j] != 0)\\r\\n                {\\r\\n                    newMemory[newIndex] = memory[j];\\r\\n                    newIndex++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            memory = newMemory;\\r\\n\\r\\n            printf(\\\"%d\\\\n\\\", blockCount);\\r\\n        }\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nmy ($t, $m) = split ' ', <>;\nchomp $m;\n\nmy @memory = (0) x $m;\nmy @allocations;\nmy $next_id = 1;\n\nwhile ($t--) {\n    my $operation = <>;\n    chomp $operation;\n\n    if ($operation =~ \/^alloc (\\d+)$\/) {\n        my $size = $1;\n        my $block_id = find_free_block($size);\n        if ($block_id) {\n            allocate_block($block_id, $size);\n            push @allocations, $block_id;\n            print $block_id . \\\"\\\\n\\\";\n        } else {\n            print \\\"NULL\\\\n\\\";\n        }\n    } elsif ($operation =~ \/^erase (\\d+)$\/) {\n        my $block_id = $1;\n        if (erase_block($block_id)) {\n            print \\\"ILLEGAL_ERASE_ARGUMENT\\\\n\\\";\n        }\n    } elsif ($operation eq 'defragment') {\n        defragment_memory();\n    }\n}\n\nsub find_free_block {\n    my $size = shift;\n    my $start = 0;\n    my $end = 0;\n    my $block_id = 0;\n\n    for (my $i = 0; $i < $m; $i++) {\n        if ($memory[$i] == 0) {\n            if ($start == 0) {\n                $start = $i;\n            }\n            $end = $i;\n        } else {\n            $start = 0;\n            $end = 0;\n        }\n\n        if ($end - $start + 1 >= $size) {\n            $block_id = $next_id++;\n            last;\n        }\n    }\n\n    return $block_id;\n}\n\nsub allocate_block {\n    my ($block_id, $size) = @_;\n\n    for (my $i = 0; $i < $size; $i++) {\n        $memory[$i] = $block_id;\n    }\n}\n\nsub erase_block {\n    my $block_id = shift;\n    my $found = 0;\n\n    for (my $i = 0; $i < $m; $i++) {\n        if ($memory[$i] == $block_id) {\n            $memory[$i] = 0;\n            $found = 1;\n        }\n    }\n\n    return !$found;\n}\n\nsub defragment_memory {\n    my @occupied_blocks = grep { $_ != 0 } @memory;\n    my $index = 0;\n\n    foreach my $block_id (@occupied_blocks) {\n        for (my $i = 0; $i < $m; $i++) {\n            if ($memory[$i] == $block_id) {\n                $memory[$i] = 0;\n                $memory[$index++] = $block_id;\n            }\n        }\n    }\n}\n\n","Rust":"use std::collections::HashMap;\\n\\nfn main() {\\n    let input = \\\"6 10\\\\nalloc 5\\\\nalloc 3\\\\nerase 1\\\\nalloc 6\\\\ndefragment\\\\nalloc 6\\\\n\\\";\\n    let mut lines = input.lines();\\n    let first_line = lines.next().unwrap();\\n    let mut tokens = first_line.split_whitespace();\\n    let t: usize = tokens.next().unwrap().parse().unwrap();\\n    let m: usize = tokens.next().unwrap().parse().unwrap();\\n    let mut memory: HashMap<usize, usize> = HashMap::new();\\n    let mut next_id = 1;\\n\\n    for _ in 0..t {\\n        let line = lines.next().unwrap();\\n        let mut tokens = line.split_whitespace();\\n        let operation = tokens.next().unwrap();\\n\\n        match operation {\\n            \\\"alloc\\\" => {\\n                let n: usize = tokens.next().unwrap().parse().unwrap();\\n                let mut start = 1;\\n                let mut end = n;\\n\\n                for (id, size) in &memory {\\n                    if *id - end >= n {\\n                        break;\\n                    }\\n                    start = *id + size;\\n                    end = start + n - 1;\\n                }\\n\\n                if end <= m {\\n                    memory.insert(start, n);\\n                    println!(\\\"{}\\\", next_id);\\n                    next_id += 1;\\n                } else {\\n                    println!(\\\"NULL\\\");\\n                }\\n            }\\n            \\\"erase\\\" => {\\n                let x: usize = tokens.next().unwrap().parse().unwrap();\\n\\n                if memory.contains_key(&x) {\\n                    memory.remove(&x);\\n                } else {\\n                    println!(\\\"ILLEGAL_ERASE_ARGUMENT\\\");\\n                }\\n            }\\n            \\\"defragment\\\" => {\\n                let mut new_memory: HashMap<usize, usize> = HashMap::new();\\n                let mut current = 1;\\n\\n                for (id, size) in &memory {\\n                    new_memory.insert(current, *size);\\n                    current += *size;\\n                }\\n\\n                memory = new_memory;\\n            }\\n            _ => {}\\n        }\\n    }\\n}"}
{"title":"E. Defining Macros","description":"Most C\/C++ programmers know about excellent opportunities that preprocessor #define directives give; but many know as well about the problems that can arise because of their careless use.In this problem we consider the following model of #define constructions (also called macros). Each macro has its name and value. The generic syntax for declaring a macro is the following:#define macro_name macro_valueAfter the macro has been declared, \"macro_name\" is replaced with \"macro_value\" each time it is met in the program (only the whole tokens can be replaced; i.e. \"macro_name\" is replaced only when it is surrounded by spaces or other non-alphabetic symbol). A \"macro_value\" within our model can only be an arithmetic expression consisting of variables, four arithmetic operations, brackets, and also the names of previously declared macros (in this case replacement is performed sequentially). The process of replacing macros with their values is called substitution.One of the main problems arising while using macros \u2014 the situation when as a result of substitution we get an arithmetic expression with the changed order of calculation because of different priorities of the operations.Let's consider the following example. Say, we declared such a #define construction:#define sum x + yand further in the program the expression \"2 * sum\" is calculated. After macro substitution is performed we get \"2 * x + y\", instead of intuitively expected \"2 * (x + y)\".Let's call the situation \"suspicious\", if after the macro substitution the order of calculation changes, falling outside the bounds of some macro. Thus, your task is to find out by the given set of #define definitions and the given expression if this expression is suspicious or not.Let's speak more formally. We should perform an ordinary macros substitution in the given expression. Moreover, we should perform a \"safe\" macros substitution in the expression, putting in brackets each macro value; after this, guided by arithmetic rules of brackets expansion, we can omit some of the brackets. If there exist a way to get an expression, absolutely coinciding with the expression that is the result of an ordinary substitution (character-by-character, but ignoring spaces), then this expression and the macros system are called correct, otherwise \u2014 suspicious.Note that we consider the \"\/\" operation as the usual mathematical division, not the integer division like in C\/C++. That's why, for example, in the expression \"a*(b\/c)\" we can omit brackets to get the expression \"a*b\/c\".","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains the only number n (0\u2264n\u2264100) \u2014 the amount of #define constructions in the given program.\nThen there follow n lines, each of them contains just one #define construction. Each construction has the following syntax:\n#define name expression\nwhere\n  name \u2014 the macro name,  expression \u2014 the expression with which the given macro will be replaced. An expression is a non-empty string, containing digits,names of variables, names of previously declared macros, round brackets and operational signs +-*\/. It is guaranteed that the expression (before and after macros substitution) is a correct arithmetic expression, having no unary operations. The expression contains only non-negative integers, not exceeding 10^9. All the names (#define constructions' names and names of their arguments) are strings of case-sensitive Latin characters. It is guaranteed that the name of any variable is different from any #define construction.\nThen, the last line contains an expression that you are to check. This expression is non-empty and satisfies the same limitations as the expressions in #define constructions.\nThe input lines may contain any number of spaces anywhere, providing these spaces do not break the word \"define\" or the names of constructions and variables. In particular, there can be any number of spaces before and after the \"#\" symbol.\nThe length of any line from the input file does not exceed 100 characters.\n","output_spec":"Output \"OK\", if the expression is correct according to the above given criterion, otherwise output \"Suspicious\".\n","notes":null,"sample_inputs":["1\n#define sum x + y\n1 * sum\n","1\n#define sum  (x + y)\nsum - sum\n","4\n#define sum  x + y\n#define mul  a * b\n#define div  a \/ b\n#define expr sum + mul * div * mul\nexpr\n","3\n#define SumSafe   (a+b)\n#define DivUnsafe  a\/b\n#define DenominatorUnsafe  a*b\n((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)\n"],"sample_outputs":["Suspicious\n","OK\n","OK\n","Suspicious\n"],"id":"7-E","difficulty":2600,"tags":["dp","expression+parsing","implementation"],"src_uid":"c23d3ec2b9fb4b4d169bc8053bfd000e","C++":"#include <iostream>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\n#include <stack>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nbool isSuspicious(string expression, unordered_map<string, string>& macros) {\\n    stack<char> st;\\n    for (char c : expression) {\\n        if (c == ' ') {\\n            continue;\\n        }\\n        if (c == ')') {\\n            string subExpression;\\n            while (!st.empty() && st.top() != '(') {\\n                subExpression += st.top();\\n                st.pop();\\n            }\\n            if (!st.empty()) {\\n                st.pop();\\n                reverse(subExpression.begin(), subExpression.end());\\n                if (macros.find(subExpression) != macros.end()) {\\n                    string macroValue = macros[subExpression];\\n                    for (char ch : macroValue) {\\n                        st.push(ch);\\n                    }\\n                } else {\\n                    st.push('(');\\n                    for (char ch : subExpression) {\\n                        st.push(ch);\\n                    }\\n                    st.push(')');\\n                }\\n            }\\n        } else {\\n            st.push(c);\\n        }\\n    }\\n    string substitutedExpression;\\n    while (!st.empty()) {\\n        substitutedExpression += st.top();\\n        st.pop();\\n    }\\n    reverse(substitutedExpression.begin(), substitutedExpression.end());\\n    return substitutedExpression == expression;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    cin.ignore();\\n    unordered_map<string, string> macros;\\n    for (int i = 0; i < n; i++) {\\n        string line;\\n        getline(cin, line);\\n        string macroName, macroValue;\\n        int pos = line.find(' ');\\n        macroName = line.substr(pos + 1);\\n        macroValue = line.substr(pos + 1);\\n        macros[macroName] = macroValue;\\n    }\\n    string expression;\\n    getline(cin, expression);\\n    if (isSuspicious(expression, macros)) {\\n        cout << \\\"OK\\\" << endl;\\n    } else {\\n        cout << \\\"Suspicious\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = Integer.parseInt(scanner.nextLine());\n        Map<String, String> macros = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            String[] parts = line.split(\" \");\n            String name = parts[1];\n            String expression = parts[2];\n            macros.put(name, expression);\n        }\n        \n        String expression = scanner.nextLine();\n        String substitutedExpression = substituteMacros(expression, macros);\n        \n        if (expression.equals(substitutedExpression)) {\n            System.out.println(\"OK\");\n        } else {\n            System.out.println(\"Suspicious\");\n        }\n    }\n    \n    public static String substituteMacros(String expression, Map<String, String> macros) {\n        for (String macro : macros.keySet()) {\n            String macroValue = macros.get(macro);\n            expression = expression.replaceAll(\"\\\\\\\\b\" + macro + \"\\\\\\\\b\", \"(\" + macroValue + \")\");\n        }\n        return expression;\n    }\n}","Python":"import re\\n\\ndef is_suspicious(n, macros, expression):\\n    # Create a dictionary to store the macros\\n    macro_dict = {}\\n    \\n    # Process each macro and store it in the dictionary\\n    for macro in macros:\\n        name, value = macro.split()\\n        macro_dict[name] = value\\n    \\n    # Replace the macros in the expression\\n    for name, value in macro_dict.items():\\n        expression = expression.replace(name, value)\\n    \\n    # Add brackets to the macro values\\n    for name, value in macro_dict.items():\\n        expression = expression.replace(value, '(' + value + ')')\\n    \\n    # Remove unnecessary spaces\\n    expression = re.sub(r'\\\\s+', '', expression)\\n    \\n    # Check if the expression is suspicious\\n    if expression == eval(expression):\\n        return 'OK'\\n    else:\\n        return 'Suspicious'\\n\\n# Test the function\\nn = 1\\nmacros = ['#define sum x + y']\\nexpression = '1 * sum'\\nprint(is_suspicious(n, macros, expression))\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MAX_LEN 100\\n\\nint isSuspicious(char* expression, char** macros, int num_macros) {\\n    int i;\\n    int len = strlen(expression);\\n    char* new_expression = (char*)malloc(MAX_LEN * sizeof(char));\\n    int new_len = 0;\\n    int in_macro = 0;\\n    int macro_start = 0;\\n    int macro_end = 0;\\n    int macro_len = 0;\\n    int macro_index = -1;\\n    int suspicious = 0;\\n    \\n    for (i = 0; i < len; i++) {\\n        if (expression[i] == ' ') {\\n            continue;\\n        }\\n        \\n        if (expression[i] == '(') {\\n            in_macro = 1;\\n            macro_start = i;\\n        }\\n        else if (expression[i] == ')') {\\n            in_macro = 0;\\n            macro_end = i;\\n            macro_len = macro_end - macro_start + 1;\\n            \\n            \/\/ Check if the macro is valid\\n            int valid_macro = 0;\\n            for (int j = 0; j < num_macros; j++) {\\n                if (strncmp(expression + macro_start + 1, macros[j], macro_len - 2) == 0) {\\n                    valid_macro = 1;\\n                    macro_index = j;\\n                    break;\\n                }\\n            }\\n            \\n            if (valid_macro) {\\n                \/\/ Replace the macro with its value\\n                strncpy(new_expression + new_len, macros[macro_index] + macro_len, strlen(macros[macro_index]) - macro_len);\\n                new_len += strlen(macros[macro_index]) - macro_len;\\n            }\\n            else {\\n                \/\/ Copy the macro as is\\n                strncpy(new_expression + new_len, expression + macro_start, macro_len);\\n                new_len += macro_len;\\n            }\\n        }\\n        else if (!in_macro) {\\n            new_expression[new_len] = expression[i];\\n            new_len++;\\n        }\\n    }\\n    \\n    new_expression[new_len] = '\\\\0';\\n    \\n    \/\/ Check if the new expression is the same as the original expression\\n    if (strcmp(new_expression, expression) != 0) {\\n        suspicious = 1;\\n    }\\n    \\n    free(new_expression);\\n    \\n    return suspicious;\\n}\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    \\n    char** macros = (char**)malloc(n * sizeof(char*));\\n    for (int i = 0; i < n; i++) {\\n        macros[i] = (char*)malloc(MAX_LEN * sizeof(char));\\n        scanf(\\\"%s\\\", macros[i]);\\n    }\\n    \\n    char expression[MAX_LEN];\\n    scanf(\\\"%s\\\", expression);\\n    \\n    int suspicious = isSuspicious(expression, macros, n);\\n    \\n    if (suspicious) {\\n        printf(\\\"Suspicious\\\\n\\\");\\n    }\\n    else {\\n        printf(\\\"OK\\\\n\\\");\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n        free(macros[i]);\\n    }\\n    free(macros);\\n    \\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace MacroSubstitution\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            Dictionary<string, string> macros = new Dictionary<string, string>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] define = Console.ReadLine().Split();\n                string name = define[1];\n                string expression = define[2];\n                macros[name] = expression;\n            }\n\n            string expressionToCheck = Console.ReadLine();\n\n            string substitutedExpression = SubstituteMacros(expressionToCheck, macros);\n            string safeSubstitutedExpression = SubstituteMacrosWithBrackets(expressionToCheck, macros);\n\n            if (substitutedExpression == safeSubstitutedExpression)\n            {\n                Console.WriteLine(\"OK\");\n            }\n            else\n            {\n                Console.WriteLine(\"Suspicious\");\n            }\n        }\n\n        static string SubstituteMacros(string expression, Dictionary<string, string> macros)\n        {\n            foreach (var macro in macros)\n            {\n                expression = expression.Replace(macro.Key, macro.Value);\n            }\n\n            return expression;\n        }\n\n        static string SubstituteMacrosWithBrackets(string expression, Dictionary<string, string> macros)\n        {\n            foreach (var macro in macros)\n            {\n                expression = expression.Replace(macro.Key, \"(\" + macro.Value + \")\");\n            }\n\n            return expression;\n        }\n    }\n}","Ruby":"def suspicious_expression(n, macros, expression)\n  # Replace macros in the expression\n  macros.each do |name, value|\n    expression.gsub!(\/\\b#{name}\\b\/, value)\n  end\n  \n  # Perform safe substitution by putting brackets around each macro value\n  macros.each do |name, value|\n    expression.gsub!(\/\\b#{value}\\b\/, \"(#{value})\")\n  end\n  \n  # Check if the expression is suspicious\n  suspicious = false\n  stack = []\n  \n  expression.chars.each do |char|\n    if char == '('\n      stack.push(char)\n    elsif char == ')'\n      if stack.empty? || stack.last != '('\n        suspicious = true\n        break\n      else\n        stack.pop\n      end\n    end\n  end\n  \n  suspicious ? 'Suspicious' : 'OK'\nend\n\ndef parse_input(input)\n  lines = input.split(\"\\n\")\n  n = lines[0].to_i\n  macros = {}\n  \n  (1..n).each do |i|\n    line = lines[i].gsub(\/\\s+\/, \"\")\n    name, value = line.split(\"#define\")[1].split(\"=\", 2)\n    macros[name] = value\n  end\n  \n  expression = lines[n+1].gsub(\/\\s+\/, \"\")\n  \n  [n, macros, expression]\nend\n\ndef parse_output(output)\n  output.strip\nend\n\ndef format_output(output)\n  output + \"\\n\"\nend\n\ninput = gets.chomp\nn, macros, expression = parse_input(input)\noutput = suspicious_expression(n, macros, expression)\nformatted_output = format_output(output)\nputs formatted_output","delphi":"program SuspiciousMacros;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nvar\\n  n, i: Integer;\\n  macros: array of string;\\n  expression: string;\\n  suspicious: Boolean;\\n\\nfunction ReplaceMacros(expression: string): string;\\nvar\\n  i: Integer;\\nbegin\\n  for i := 0 to n-1 do\\n    expression := StringReplace(expression, macros[i], '(' + macros[i] + ')', [rfReplaceAll]);\\n  Result := expression;\\nend;\\n\\nfunction CheckSuspicious(expression: string): Boolean;\\nvar\\n  i: Integer;\\nbegin\\n  for i := 0 to n-1 do\\n  begin\\n    expression := StringReplace(expression, macros[i], '(' + macros[i] + ')', [rfReplaceAll]);\\n    expression := StringReplace(expression, '(' + macros[i] + ')', macros[i], [rfReplaceAll]);\\n  end;\\n  Result := expression = ReplaceMacros(expression);\\nend;\\n\\nbegin\\n  ReadLn(n);\\n  SetLength(macros, n);\\n  for i := 0 to n-1 do\\n    ReadLn(macros[i]);\\n  ReadLn(expression);\\n  suspicious := not CheckSuspicious(expression);\\n  if suspicious then\\n    WriteLn('Suspicious')\\n  else\\n    WriteLn('OK');\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn := scanner.Text()\\n\\n\\tvar macros []string\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tmacros = append(macros, scanner.Text())\\n\\t}\\n\\n\\tscanner.Scan()\\n\\texpression := scanner.Text()\\n\\n\\tif isSuspicious(macros, expression) {\\n\\t\\tfmt.Println(\\\"Suspicious\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"OK\\\")\\n\\t}\\n}\\n\\nfunc isSuspicious(macros []string, expression string) bool {\\n\\tfor _, macro := range macros {\\n\\t\\tmacroParts := strings.Split(macro, \\\" \\\")\\n\\t\\tmacroName := macroParts[1]\\n\\t\\tmacroValue := macroParts[2]\\n\\n\\t\\texpression = strings.ReplaceAll(expression, macroName, \\\"(\\\"+macroValue+\\\")\\\")\\n\\t}\\n\\n\\treturn expression != evaluateExpression(expression)\\n}\\n\\nfunc evaluateExpression(expression string) string {\\n\\t\/\/ Evaluate the expression using a stack\\n\\tvar stack []string\\n\\n\\tfor _, char := range expression {\\n\\t\\tif char == ' ' {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif char == ')' {\\n\\t\\t\\t\/\/ Pop elements from the stack until an opening bracket is found\\n\\t\\t\\tvar popped string\\n\\t\\t\\tfor len(stack) > 0 {\\n\\t\\t\\t\\tpopped, stack = stack[len(stack)-1], stack[:len(stack)-1]\\n\\t\\t\\t\\tif popped == \\\"(\\\" {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfmt.Print(popped)\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tstack = append(stack, string(char))\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Pop any remaining elements from the stack\\n\\tfor len(stack) > 0 {\\n\\t\\tpopped, stack = stack[len(stack)-1], stack[:len(stack)-1]\\n\\t\\tfmt.Print(popped)\\n\\t}\\n\\n\\treturn \\\"\\\"\\n}","Javascript":"function isSuspicious(n, macros, expression) {\n    \/\/ Create a map to store the macro definitions\n    const macroMap = new Map();\n    \n    \/\/ Process each macro definition\n    for (let i = 0; i < n; i++) {\n        const macro = macros[i].split(\" \");\n        const name = macro[1];\n        const value = macro.slice(2).join(\" \");\n        macroMap.set(name, value);\n    }\n    \n    \/\/ Replace macros in the expression recursively\n    function replaceMacros(expression) {\n        let result = \"\";\n        let i = 0;\n        \n        while (i < expression.length) {\n            if (expression[i] === \" \") {\n                i++;\n                continue;\n            }\n            \n            if (expression[i] === \"(\") {\n                \/\/ Find the closing bracket\n                let count = 1;\n                let j = i + 1;\n                \n                while (j < expression.length) {\n                    if (expression[j] === \"(\") {\n                        count++;\n                    } else if (expression[j] === \")\") {\n                        count--;\n                    }\n                    \n                    if (count === 0) {\n                        break;\n                    }\n                    \n                    j++;\n                }\n                \n                \/\/ Replace macros in the sub-expression\n                const subExpression = expression.slice(i + 1, j);\n                result += \"(\" + replaceMacros(subExpression) + \")\";\n                i = j + 1;\n            } else {\n                \/\/ Find the end of the token\n                let j = i + 1;\n                \n                while (j < expression.length && \/[a-zA-Z0-9]\/.test(expression[j])) {\n                    j++;\n                }\n                \n                \/\/ Replace the token if it is a macro\n                const token = expression.slice(i, j);\n                const macroValue = macroMap.get(token);\n                \n                if (macroValue) {\n                    result += \"(\" + replaceMacros(macroValue) + \")\";\n                } else {\n                    result += token;\n                }\n                \n                i = j;\n            }\n        }\n        \n        return result;\n    }\n    \n    \/\/ Replace macros in the expression\n    const replacedExpression = replaceMacros(expression);\n    \n    \/\/ Check if the replaced expression is equal to the original expression\n    if (replacedExpression.replace(\/\\s\/g, \"\") === expression.replace(\/\\s\/g, \"\")) {\n        return \"OK\";\n    } else {\n        return \"Suspicious\";\n    }\n}\n\n\/\/ Test cases\nconst testCases = [\n    {\n        n: 1,\n        macros: [\"#define sum x + y\"],\n        expression: \"1 * sum\",\n        output: \"Suspicious\"\n    },\n    {\n        n: 1,\n        macros: [\"#define sum  (x + y)\"],\n        expression: \"sum - sum\",\n        output: \"OK\"\n    },\n    {\n        n: 4,\n        macros: [\n            \"#define sum  x + y\",\n            \"#define mul  a * b\",\n            \"#define div  a \/ b\",\n            \"#define expr sum + mul * div * mul\"\n        ],\n        expression: \"expr\",\n        output: \"OK\"\n    },\n    {\n        n: 3,\n        macros: [\n            \"#define SumSafe   (a+b)\",\n            \"#define DivUnsafe  a\/b\",\n            \"#define DenominatorUnsafe  a*b\"\n        ],\n        expression: \"((SumSafe) + DivUnsafe\/DivUnsafe + x\/DenominatorUnsafe)\",\n        output: \"Suspicious\"\n    }\n];\n\n\/\/ Run test cases\nconst results = [];\nfor (const testCase of testCases) {\n    const result = isSuspicious(testCase.n, testCase.macros, testCase.expression);\n    results.push(result === testCase.output);\n}\n\nresults;","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val macros = mutableMapOf<String, String>()\n    scanner.nextLine()\n    for (i in 0 until n) {\n        val line = scanner.nextLine().trim()\n        val parts = line.split(\" \")\n        val name = parts[1]\n        val expression = parts[2]\n        macros[name] = expression\n    }\n    val expression = scanner.nextLine().trim()\n    val result = checkExpression(expression, macros)\n    println(result)\n}\n\nfun checkExpression(expression: String, macros: Map<String, String>): String {\n    val substitutedExpression = substituteMacros(expression, macros)\n    val safeExpression = addBrackets(substitutedExpression)\n    return if (substitutedExpression == safeExpression) {\n        \"OK\"\n    } else {\n        \"Suspicious\"\n    }\n}\n\nfun substituteMacros(expression: String, macros: Map<String, String>): String {\n    var result = expression\n    for ((name, value) in macros) {\n        result = result.replace(name, value)\n    }\n    return result\n}\n\nfun addBrackets(expression: String): String {\n    var result = expression\n    for (i in 0 until result.length) {\n        if (result[i] in 'a'..'z' || result[i] in 'A'..'Z') {\n            if (i > 0 && result[i - 1] in '0'..'9') {\n                result = result.substring(0, i) + \")\" + result.substring(i)\n            }\n            if (i < result.length - 1 && result[i + 1] in '0'..'9') {\n                result = result.substring(0, i + 1) + \"(\" + result.substring(i + 1)\n            }\n        }\n    }\n    return result\n}","PHP":"```php\\n<?php\\n\\nfunction isSuspicious($n, $definitions, $expression) {\\n    $macros = [];\\n    foreach ($definitions as $definition) {\\n        $parts = explode(\" \", $definition);\\n        $name = $parts[1];\\n        $value = $parts[2];\\n        $macros[$name] = $value;\\n    }\\n    $substitutedExpression = substituteMacros($expression, $macros);\\n    $safeExpression = addBrackets($substitutedExpression);\\n    return $substitutedExpression === $safeExpression ? 'OK' : 'Suspicious';\\n}\\n\\nfunction substituteMacros($expression, $macros) {\\n    foreach ($macros as $name => $value) {\\n        $expression = str_replace($name, $value, $expression);\\n    }\\n    return $expression;\\n}\\n\\nfunction addBrackets($expression) {\\n    $operators = ['+', '-', '*', '\/'];\\n    $expression = str_replace(' ', '', $expression);\\n    $expression = str_replace($operators, ' $0 ', $expression);\\n    $expression = preg_replace('\/([a-zA-Z0-9]+)([+\\-*\\\/])([a-zA-Z0-9]+)\/', '($1$2$3)', $expression);\\n    return $expression;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$n = intval($input[0]);\\n$definitions = array_slice($input, 1, $n);\\n$expression = $input[$n + 1];\\necho isSuspicious($n, $definitions, $expression);\\n\\n```","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nstruct Macro {\\r\\n    string name;\\r\\n    string expression;\\r\\n}\\r\\n\\r\\nbool isSuspicious(string expression, Macro[] macros) {\\r\\n    foreach (macro; macros) {\\r\\n        expression = expression.replace(macro.name, macro.expression);\\r\\n    }\\r\\n    expression = expression.replace(\\\" \\\", \\\"\\\");\\r\\n    return expression != evaluateExpression(expression);\\r\\n}\\r\\n\\r\\nstring evaluateExpression(string expression) {\\r\\n    string[] tokens = expression.split(\\\" \\\");\\r\\n    string result = \\\"\\\";\\r\\n    foreach (token; tokens) {\\r\\n        if (token in [\\\"+\\\", \\\"-\\\", \\\"*\\\", \\\"\/\\\"]) {\\r\\n            result ~= token;\\r\\n        } else if (token == \\\"(\\\") {\\r\\n            result ~= token;\\r\\n        } else if (token == \\\")\\\") {\\r\\n            result = result[0 .. $ - 1];\\r\\n            result ~= token;\\r\\n        } else {\\r\\n            result ~= \\\"(\\\" ~ token ~ \\\")\\\";\\r\\n        }\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    Macro[] macros;\\r\\n    foreach (_; 0 .. n) {\\r\\n        string name;\\r\\n        string expression;\\r\\n        readf(\\\"%s %s\\\", &name, &expression);\\r\\n        macros ~= Macro(name, expression);\\r\\n    }\\r\\n    string expression;\\r\\n    readf(\\\"%s\\\", &expression);\\r\\n    if (isSuspicious(expression, macros)) {\\r\\n        writeln(\\\"Suspicious\\\");\\r\\n    } else {\\r\\n        writeln(\\\"OK\\\");\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub is_suspicious {\\n    my ($macros, $expression) = @_;\\n    my %macro_values;\\n    my $suspicious = 0;\\n\\n    # Substitute macros in the expression\\n    while ($expression =~ \/([a-zA-Z_][a-zA-Z0-9_]*)\/) {\\n        my $macro_name = $1;\\n        if (exists $macros->{$macro_name}) {\\n            my $macro_value = $macros->{$macro_name};\\n            $expression =~ s\/$macro_name\/$macro_value\/g;\\n        }\\n    }\\n\\n    # Perform safe substitution with brackets\\n    foreach my $macro_name (keys %$macros) {\\n        my $macro_value = $macros->{$macro_name};\\n        my $safe_macro_value = $macro_value;\\n        $safe_macro_value =~ s\/([a-zA-Z_][a-zA-Z0-9_]*)\/$macros->{$1}\/g;\\n        $safe_macro_value =~ s\/(\\d+)\/($1)\/g;\\n        $expression =~ s\/$macro_name\/$safe_macro_value\/g;\\n    }\\n\\n    # Check if the expression is suspicious\\n    my @tokens = split \/(\\+|\\-|\\*|\\\/)\/, $expression;\\n    for (my $i = 0; $i < scalar(@tokens); $i++) {\\n        if ($tokens[$i] =~ \/[a-zA-Z_][a-zA-Z0-9_]*$\/) {\\n            my $macro_name = $tokens[$i];\\n            if (exists $macros->{$macro_name}) {\\n                my $macro_value = $macros->{$macro_name};\\n                my $next_token = $tokens[$i + 1];\\n                if ($next_token && $next_token =~ \/(\\+|\\-|\\*|\\\/)\/) {\\n                    $suspicious = 1;\\n                    last;\\n                }\\n            }\\n        }\\n    }\\n\\n    return $suspicious ? 'Suspicious' : 'OK';\\n}\\n\\n# Read input\\nmy $n = <STDIN>;\\nchomp($n);\\n\\nmy %macros;\\nfor (my $i = 0; $i < $n; $i++) {\\n    my $line = <STDIN>;\\n    chomp($line);\\n    if ($line =~ \/^#define\\s+(\\w+)\\s+(.*)$\/) {\\n        my $macro_name = $1;\\n        my $macro_value = $2;\\n        $macros{$macro_name} = $macro_value;\\n    }\\n}\\n\\nmy $expression = <STDIN>;\\nchomp($expression);\\n\\n# Check if the expression is suspicious\\nmy $result = is_suspicious(\\\\%macros, $expression);\\n\\n# Print the result\\nprint $result;\\n","Rust":"use std::collections::HashMap;\n\nfn main() {\n    let mut macros: HashMap<String, String> = HashMap::new();\n\n    let input = \"1\\n#define sum x + y\\n1 * sum\\n\";\n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let n: usize = lines[0].parse().unwrap();\n\n    for i in 1..=n {\n        let line = lines[i];\n        let parts: Vec<&str> = line.split_whitespace().collect();\n        let name = parts[1].to_string();\n        let expression = parts[2..].join(\" \");\n        macros.insert(name, expression);\n    }\n\n    let expression = lines[n + 1].to_string();\n    let suspicious = is_suspicious(&macros, &expression);\n\n    if suspicious {\n        println!(\"Suspicious\");\n    } else {\n        println!(\"OK\");\n    }\n}\n\nfn is_suspicious(macros: &HashMap<String, String>, expression: &str) -> bool {\n    let mut stack: Vec<char> = Vec::new();\n    let mut result = String::new();\n\n    for c in expression.chars() {\n        if c == ' ' {\n            continue;\n        }\n\n        if c == '(' {\n            stack.push(c);\n        } else if c == ')' {\n            while let Some(top) = stack.pop() {\n                if top == '(' {\n                    break;\n                }\n                result.push(top);\n            }\n        } else if c.is_alphabetic() {\n            let mut name = String::new();\n            name.push(c);\n\n            while let Some(&next) = expression.chars().skip(result.len() + 1).next() {\n                if next.is_alphabetic() {\n                    name.push(next);\n                } else {\n                    break;\n                }\n            }\n\n            if let Some(value) = macros.get(&name) {\n                result.push_str(value);\n            } else {\n                result.push(c);\n            }\n        } else {\n            result.push(c);\n        }\n    }\n\n    while let Some(top) = stack.pop() {\n        result.push(top);\n    }\n\n    let mut stack: Vec<i32> = Vec::new();\n\n    for c in result.chars() {\n        if c.is_digit(10) {\n            stack.push(c.to_digit(10).unwrap() as i32);\n        } else {\n            let b = stack.pop().unwrap();\n            let a = stack.pop().unwrap();\n\n            match c {\n                '+' => stack.push(a + b),\n                '-' => stack.push(a - b),\n                '*' => stack.push(a * b),\n                '\/' => stack.push(a \/ b),\n                _ => (),\n            }\n        }\n    }\n\n    stack.len() == 1\n}"}
{"title":"C. Average Score","description":"After the educational reform Polycarp studies only two subjects at school, Safety Studies and PE (Physical Education). During the long months of the fourth term, he received n marks in them. When teachers wrote a mark in the journal, they didn't write in what subject the mark was for, they just wrote the mark.Now it's time to show the journal to his strict parents. Polycarp knows that recently at the Parent Meeting the parents were told that he received a Safety Studies marks and b PE marks (a+b=n). Now Polycarp wants to write a subject's name in front of each mark so that:   there are exactly a Safety Studies marks,  there are exactly b PE marks,  the total average score in both subjects is maximum. An average subject grade is the sum of all marks in it, divided by the number of them. Of course, the division is performed in real numbers without rounding up or down. Polycarp aims to maximize the x1+x2, where x1 is the average score in the first subject (Safety Studies), and x2 is the average score in the second one (Physical Education).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (2\u2264n\u226410^5), n is the number of marks in Polycarp's Journal. The second line contains two positive integers a,b (1\u2264a,b\u2264n-1,a+b=n). The third line contains a sequence of integers t1,t2,...,tn (1\u2264ti\u22645), they are Polycarp's marks.\n","output_spec":"Print the sequence of integers f1,f2,...,fn, where fi (1\u2264fi\u22642) is the number of a subject to which the i-th mark should be attributed. If there are several possible solutions, then print such that the sequence f1,f2,...,fn is the smallest lexicographically.\nThe sequence p1,p2,...,pn is lexicographically less than q1,q2,...,qn if there exists such j (1\u2264j\u2264n) that pi=qi for all 1\u2264i<j, \u0430nd pj<qj.\n","notes":"In the first sample the average score in the first subject is equal to 4, and in the second one \u2014 to 4.5. The total average score is 8.5.\n","sample_inputs":["5\n3 2\n4 4 5 4 4\n","4\n2 2\n3 5 4 5\n","6\n1 5\n4 4 4 5 4 4\n"],"sample_outputs":["1 1 2 1 2 ","1 1 2 2 ","2 2 2 1 2 2 "],"id":"81-C","difficulty":1700,"tags":["greedy","math","sortings"],"src_uid":"867facaa8bcdfcb53ec3647387f7d23f","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    int a, b;\\n    cin >> a >> b;\\n    vector<int> marks(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> marks[i];\\n    }\\n    sort(marks.begin(), marks.end(), greater<int>());\\n    vector<int> subjects(n);\\n    int count_a = 0;\\n    int count_b = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (count_a < a && count_b < b) {\\n            if (count_a * (a + b - i) < a * (a + b - i - 1)) {\\n                subjects[i] = 1;\\n                count_a++;\\n            } else {\\n                subjects[i] = 2;\\n                count_b++;\\n            }\\n        } else if (count_a < a) {\\n            subjects[i] = 1;\\n            count_a++;\\n        } else {\\n            subjects[i] = 2;\\n            count_b++;\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        cout << subjects[i] << \\\" \\\";\\n    }\\n    return 0;\\n}","Java":"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        int[] marks = new int[n];\n        for (int i = 0; i < n; i++) {\n            marks[i] = scanner.nextInt();\n        }\n        \n        int[] subject = new int[n];\n        int countA = 0;\n        int countB = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (marks[i] == 5) {\n                if (countA < a) {\n                    subject[i] = 1;\n                    countA++;\n                } else {\n                    subject[i] = 2;\n                    countB++;\n                }\n            } else if (marks[i] == 4) {\n                if (countB < b) {\n                    subject[i] = 2;\n                    countB++;\n                } else {\n                    subject[i] = 1;\n                    countA++;\n                }\n            }\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            result.append(subject[i]).append(\" \");\n        }\n        \n        System.out.println(result.toString());\n    }\n}","Python":"def assign_subjects(n, a, b, marks):\\n    marks_with_subject = []\\n    for i in range(n):\\n        marks_with_subject.append((marks[i], i))\\n    marks_with_subject.sort(reverse=True)\\n    subjects = [0] * n\\n    for i in range(a):\\n        subjects[marks_with_subject[i][1]] = 1\\n    for i in range(a, n):\\n        subjects[marks_with_subject[i][1]] = 2\\n    return ' '.join(map(str, subjects))\\n\\ninput_data = input().split('\\\\n')\\nn = int(input_data[0])\\na, b = map(int, input_data[1].split())\\nmarks = list(map(int, input_data[2].split()))\\n\\noutput = assign_subjects(n, a, b, marks)\\nprint(output)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, a, b;\\n    scanf(\\\"%d\\\", &n);\\n    scanf(\\\"%d %d\\\", &a, &b);\\n    int marks[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &marks[i]);\\n    }\\n\\n    int subject1 = 0, subject2 = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (subject1 < a && marks[i] > marks[i + 1]) {\\n            printf(\\\"1 \\\");\\n            subject1++;\\n        } else if (subject2 < b && marks[i] <= marks[i + 1]) {\\n            printf(\\\"2 \\\");\\n            subject2++;\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Linq;\n\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] ab = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        int a = ab[0];\n        int b = ab[1];\n        int[] marks = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        int[] subject = new int[n];\n        int[] count = new int[6];\n\n        for (int i = 0; i < n; i++)\n        {\n            count[marks[i]]++;\n        }\n\n        int[] sortedMarks = marks.OrderByDescending(x => x).ToArray();\n\n        int[] subjectCount = new int[3];\n        int[] subjectSum = new int[3];\n\n        for (int i = 0; i < a; i++)\n        {\n            subject[i] = 1;\n            subjectCount[1]++;\n            subjectSum[1] += sortedMarks[i];\n        }\n\n        for (int i = a; i < a + b; i++)\n        {\n            subject[i] = 2;\n            subjectCount[2]++;\n            subjectSum[2] += sortedMarks[i];\n        }\n\n        double average1 = (double)subjectSum[1] \/ subjectCount[1];\n        double average2 = (double)subjectSum[2] \/ subjectCount[2];\n\n        for (int i = a + b; i < n; i++)\n        {\n            if (average1 > average2)\n            {\n                subject[i] = 1;\n                subjectCount[1]++;\n                subjectSum[1] += sortedMarks[i];\n                average1 = (double)subjectSum[1] \/ subjectCount[1];\n            }\n            else\n            {\n                subject[i] = 2;\n                subjectCount[2]++;\n                subjectSum[2] += sortedMarks[i];\n                average2 = (double)subjectSum[2] \/ subjectCount[2];\n            }\n        }\n\n        Console.WriteLine(string.Join(\" \", subject));\n    }\n}","Ruby":"\ndef assign_subjects(n, a, b, marks)\n  subject1_marks = marks.select.with_index { |_, i| i < a }\n  subject2_marks = marks.select.with_index { |_, i| i >= a }\n  \n  subject1_marks.map { |_| 1 }.join(' ') + subject2_marks.map { |_| 2 }.join(' ')\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\na, b = input[1].split(' ').map(&:to_i)\nmarks = input[2].split(' ').map(&:to_i)\n\noutput = assign_subjects(n, a, b, marks)\nputs output\n","delphi":"program PolycarpJournal;\\n\\nvar\\n  n, a, b, i, j: integer;\\n  marks: array of integer;\\n  subjects: array of integer;\\n  output: string;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n);\\n  readln(a, b);\\n  SetLength(marks, n);\\n  for i := 0 to n-1 do\\n    read(marks[i]);\\n\\n  \/\/ Initialize subjects array\\n  SetLength(subjects, n);\\n  for i := 0 to n-1 do\\n    subjects[i] := 0;\\n\\n  \/\/ Assign marks to subjects\\n  j := 0;\\n  for i := 0 to a-1 do\\n  begin\\n    subjects[j] := 1;\\n    j := j + 1;\\n  end;\\n  for i := 0 to b-1 do\\n  begin\\n    subjects[j] := 2;\\n    j := j + 1;\\n  end;\\n\\n  \/\/ Sort marks in descending order\\n  for i := 0 to n-1 do\\n  begin\\n    for j := i+1 to n-1 do\\n    begin\\n      if marks[i] < marks[j] then\\n      begin\\n        \/\/ Swap marks\\n        marks[i] := marks[i] + marks[j];\\n        marks[j] := marks[i] - marks[j];\\n        marks[i] := marks[i] - marks[j];\\n\\n        \/\/ Swap subjects\\n        subjects[i] := subjects[i] + subjects[j];\\n        subjects[j] := subjects[i] - subjects[j];\\n        subjects[i] := subjects[i] - subjects[j];\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Generate output string\\n  output := '';\\n  for i := 0 to n-1 do\\n    output := output + IntToStr(subjects[i]) + ' ';\\n\\n  \/\/ Print output\\n  writeln(output);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strconv\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tn, _ := strconv.Atoi(scanner.Text())\\n\\tscanner.Scan()\\n\\tab := strings.Split(scanner.Text(), \\\" \\\")\\n\\ta, _ := strconv.Atoi(ab[0])\\n\\tb, _ := strconv.Atoi(ab[1])\\n\\tscanner.Scan()\\n\\tmarks := strings.Split(scanner.Text(), \\\" \\\")\\n\\n\\tsubject := 1\\n\\toutput := []string{}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif a > 0 {\\n\\t\\t\\toutput = append(output, \\\"1\\\")\\n\\t\\t\\ta--\\n\\t\\t} else if b > 0 {\\n\\t\\t\\toutput = append(output, \\\"2\\\")\\n\\t\\t\\tb--\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(strings.Join(output, \\\" \\\"))\\n}","Javascript":"function assignSubjects(n, a, b, marks) {\n    let subject1 = [];\n    let subject2 = [];\n    \n    for (let i = 0; i < n; i++) {\n        if (a > 0) {\n            subject1.push(i);\n            a--;\n        } else {\n            subject2.push(i);\n            b--;\n        }\n    }\n    \n    let average1 = subject1.reduce((sum, index) => sum + marks[index], 0) \/ subject1.length;\n    let average2 = subject2.reduce((sum, index) => sum + marks[index], 0) \/ subject2.length;\n    \n    if (average1 > average2) {\n        return subject1.map(() => '1').concat(subject2.map(() => '2')).join(' ');\n    } else {\n        return subject2.map(() => '2').concat(subject1.map(() => '1')).join(' ');\n    }\n}\n\nlet input = '5\\\\n3 2\\\\n4 4 5 4 4';\nlet lines = input.split('\\\\n');\nlet n = parseInt(lines[0]);\nlet [a, b] = lines[1].split(' ').map(Number);\nlet marks = lines[2].split(' ').map(Number);\n\nlet output = assignSubjects(n, a, b, marks);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val ab = IntArray(2)\n    for (i in 0 until 2) {\n        ab[i] = scanner.nextInt()\n    }\n    val marks = IntArray(n)\n    for (i in 0 until n) {\n        marks[i] = scanner.nextInt()\n    }\n    val result = assignSubjects(n, ab, marks)\n    for (i in 0 until n) {\n        print(\"${result[i]} \")\n    }\n}\n\nfun assignSubjects(n: Int, ab: IntArray, marks: IntArray): IntArray {\n    val a = ab[0]\n    val b = ab[1]\n    val result = IntArray(n)\n    var countA = 0\n    var countB = 0\n    for (i in 0 until n) {\n        if (marks[i] == 5) {\n            if (countA < a) {\n                result[i] = 1\n                countA++\n            } else {\n                result[i] = 2\n                countB++\n            }\n        } else {\n            if (countB < b) {\n                result[i] = 2\n                countB++\n            } else {\n                result[i] = 1\n                countA++\n            }\n        }\n    }\n    return result\n}","PHP":"<?php\\n\\nfunction assignSubjects($n, $a, $b, $marks) {\\n    $subject1 = 1;\\n    $subject2 = 2;\\n    $subject1_marks = 0;\\n    $subject2_marks = 0;\\n    $assigned_subjects = [];\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        if ($subject1_marks < $a && $subject2_marks < $b) {\\n            if ($marks[$i] >= $marks[$i+1]) {\\n                $assigned_subjects[] = $subject1;\\n                $subject1_marks++;\\n            } else {\\n                $assigned_subjects[] = $subject2;\\n                $subject2_marks++;\\n            }\\n        } elseif ($subject1_marks < $a) {\\n            $assigned_subjects[] = $subject1;\\n            $subject1_marks++;\\n        } else {\\n            $assigned_subjects[] = $subject2;\\n            $subject2_marks++;\\n        }\\n    }\\n\\n    return implode(' ', $assigned_subjects);\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$n = (int) $input[0];\\nlist($a, $b) = explode(' ', $input[1]);\\n$marks = explode(' ', $input[2]);\\n\\n$result = assignSubjects($n, $a, $b, $marks);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int a;\\r\\n    int b;\\r\\n    int[] marks;\\r\\n    int[] subjects;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    readf(\\\"%d %d\\\", &a, &b);\\r\\n    marks = readln.split.map!(a => a.to!int).array;\\r\\n\\r\\n    \/\/ Sort marks in descending order\\r\\n    marks.sort!((a, b) => a > b);\\r\\n\\r\\n    \/\/ Assign subjects to marks\\r\\n    subjects.length = n;\\r\\n    int i = 0;\\r\\n    int j = 0;\\r\\n    while (i < a)\\r\\n    {\\r\\n        subjects[j] = 1;\\r\\n        i++;\\r\\n        j += 2;\\r\\n    }\\r\\n    j = 1;\\r\\n    while (i < n)\\r\\n    {\\r\\n        subjects[j] = 2;\\r\\n        i++;\\r\\n        j += 2;\\r\\n    }\\r\\n\\r\\n    \/\/ Print the sequence of subjects\\r\\n    writeln(subjects.join(\\\" \\\"));\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub assign_subjects {\n    my ($n, $a, $b, @marks) = @_;\n\n    my @subjects = ();\n    my $safety_count = 0;\n    my $pe_count = 0;\n\n    foreach my $mark (@marks) {\n        if ($safety_count < $a) {\n            push @subjects, 1;\n            $safety_count++;\n        } else {\n            push @subjects, 2;\n            $pe_count++;\n        }\n    }\n\n    return join(' ', @subjects);\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $a, $b) = split(' ', $input);\n\n$input = <STDIN>;\nchomp $input;\nmy @marks = split(' ', $input);\n\n# Call the function and print the result\nmy $result = assign_subjects($n, $a, $b, @marks);\nprint $result;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let ab: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let marks: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let a = ab[0];\n    let b = ab[1];\n    \n    let mut subject = vec![0; n];\n    let mut count_a = 0;\n    let mut count_b = 0;\n    \n    for i in 0..n {\n        if count_a < a && marks[i] >= 4 {\n            subject[i] = 1;\n            count_a += 1;\n        } else if count_b < b && marks[i] < 4 {\n            subject[i] = 2;\n            count_b += 1;\n        }\n    }\n    \n    for i in 0..n {\n        if count_a < a {\n            subject[i] = 1;\n            count_a += 1;\n        } else if count_b < b {\n            subject[i] = 2;\n            count_b += 1;\n        }\n    }\n    \n    let result: Vec<String> = subject.iter().map(|x| x.to_string()).collect();\n    let output = result.join(\" \");\n    println!(\"{}\", output);\n}"}
{"title":"A. Double Cola","description":"Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a \"Double Cola\" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.Write a program that will print the name of a man who will drink the n-th can.Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The input data consist of a single integer n (1\u2264n\u226410^9).\nIt is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.\n","output_spec":"Print the single line \u2014 the name of the person who drinks the n-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: \"Sheldon\", \"Leonard\", \"Penny\", \"Rajesh\", \"Howard\" (without the quotes). In that order precisely the friends are in the queue initially.\n","notes":null,"sample_inputs":["1\n","6\n","1802\n"],"sample_outputs":["Sheldon\n","Sheldon\n","Penny\n"],"id":"82-A","difficulty":1100,"tags":["implementation","math"],"src_uid":"023b169765e81d896cdc1184e5a82b22","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nint main() {\\n    vector<string> names = {\\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\"};\\n    int n;\\n    cin >> n;\\n    int i = 0;\\n    while (n > 0) {\\n        n -= 1;\\n        i = (i + 1) % names.size();\\n        if (n == 0) {\\n            cout << names[i] << endl;\\n            break;\\n        }\\n        n -= (1 << i);\\n    }\\n    return 0;\\n}","Java":"public class DoubleCola {\n    public static String findNthPerson(int n) {\n        String[] names = {\\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\"};\n        int queueSize = names.length;\n        int drinks = 1;\n        \n        while (drinks * queueSize < n) {\n            n -= drinks * queueSize;\n            drinks *= 2;\n        }\n        \n        int index = (n - 1) \/ drinks;\n        return names[index];\n    }\n    \n    public static void main(String[] args) {\n        int[] testCases = {1, 6, 1802};\n        \n        for (int n : testCases) {\n            String nthPerson = findNthPerson(n);\n            System.out.println(nthPerson);\n        }\n    }\n}","Python":"def find_person(n):\\n    names = ['Sheldon', 'Leonard', 'Penny', 'Rajesh', 'Howard']\\n    i = 0\\n    while n > 0:\\n        n -= 1\\n        if n == 0:\\n            return names[i]\\n        n -= 1\\n        if n == 0:\\n            return names[i]\\n        names.append(names[i])\\n        names.append(names[i])\\n        i += 1\\n\\n\\n# Test cases\\nprint(find_person(1))  # Sheldon\\nprint(find_person(6))  # Sheldon\\nprint(find_person(1802))  # Penny","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main()\\n{\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n\\n    char* names[] = {\\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\"};\\n    int num_names = 5;\\n\\n    int i = 0;\\n    while (n > num_names)\\n    {\\n        n -= num_names;\\n        num_names *= 2;\\n        i++;\\n    }\\n\\n    int index = (n - 1) \/ (num_names \/ 5);\\n\\n    printf(\\\"%s\\\\n\\\", names[index]);\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] names = { \\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\" };\n        \n        int n = int.Parse(Console.ReadLine());\n        \n        int i = 0;\n        while (n > 0)\n        {\n            n -= 1;\n            i = (i + 1) % 5;\n            if (n == 0)\n            {\n                Console.WriteLine(names[i]);\n                break;\n            }\n            n -= (int)Math.Pow(2, (int)Math.Log(n, 2));\n        }\n    }\n}","Ruby":"\ndef find_person(n)\n  queue = ['Sheldon', 'Leonard', 'Penny', 'Rajesh', 'Howard']\n  i = 0\n  \n  while n > 0\n    person = queue[i]\n    n -= 1\n    \n    if n == 0\n      return person\n    end\n    \n    queue.push(person, person)\n    i += 1\n  end\nend\n\nn = gets.chomp.to_i\nresult = find_person(n)\nputs result\n","delphi":"program DoubleCola;\\n\\nvar\\n  names: array[0..4] of string = ('Sheldon', 'Leonard', 'Penny', 'Rajesh', 'Howard');\\n  n, i, j: integer;\\n\\nbegin\\n  readln(n);\\n  i := 0;\\n  j := 1;\\n\\n  while j < n do\\n  begin\\n    j := j * 2;\\n    i := i + 1;\\n  end;\\n\\n  writeln(names[(n - j div 2 - 1) div (j div 2)]);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tqueue := []string{\\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\"}\\n\\n\\tfor n > 5 {\\n\\t\\tn -= 5\\n\\t\\tn \/= 2\\n\\t}\\n\\n\\tfmt.Println(queue[n-1])\\n}","Javascript":"function findNthPerson(n) {\n    var names = ['Sheldon', 'Leonard', 'Penny', 'Rajesh', 'Howard'];\n    var queueSize = names.length;\n    var totalCans = queueSize;\n    var i = 0;\n    \n    while (totalCans < n) {\n        totalCans += queueSize * 2;\n        queueSize *= 2;\n        i++;\n    }\n    \n    var index = Math.floor((n - totalCans \/ 2) \/ Math.pow(2, i));\n    return names[index];\n}\n\nvar input = 6;\nvar output = findNthPerson(input);\nconsole.log(output);","Kotlin":"fun main() {\\n    val names = listOf(\\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\")\\n    val n = readLine()!!.toInt()\\n    var i = 0\\n    var count = 1\\n\\n    while (count * names.size < n) {\\n        count *= 2\\n        i++\\n    }\\n\\n    val index = (n - 1) \/ count\\n    println(names[index])\\n}","PHP":"<?php\\n\\nfunction findPerson($n) {\\n    $names = array('Sheldon', 'Leonard', 'Penny', 'Rajesh', 'Howard');\\n    $queueSize = count($names);\\n    $i = 0;\\n    $count = 1;\\n\\n    while ($count < $n) {\\n        $count *= 2;\\n        $i++;\\n        if ($i == $queueSize) {\\n            $queueSize *= 2;\\n        }\\n    }\\n\\n    $index = floor(($n - 1) \/ ($count \/ 2));\\n    return $names[$index];\\n}\\n\\n$input = trim(fgets(STDIN));\\n$n = intval($input);\\n$result = findPerson($n);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nstring findNthPerson(int n)\\r\\n{\\r\\n    string[] names = [\\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\"];\\r\\n    int total = names.length;\\r\\n    int i = 0;\\r\\n\\r\\n    while (n > total)\\r\\n    {\\r\\n        n -= total;\\r\\n        total *= 2;\\r\\n        i++;\\r\\n    }\\r\\n\\r\\n    int index = n \/ (total \/ names.length);\\r\\n\\r\\n    return names[index];\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n = 6;\\r\\n    writeln(findNthPerson(n));\\r\\n}","perl":"\n# Read the input\nmy $n = <STDIN>;\nchomp $n;\n\n# Initialize the queue\nmy @queue = qw(Sheldon Leonard Penny Rajesh Howard);\n\n# Calculate the number of times the queue needs to be doubled\nmy $doubles = 0;\nwhile ($n > scalar @queue) {\n    $n -= scalar @queue;\n    $doubles++;\n    push @queue, @queue;\n}\n\n# Print the name of the person who drinks the n-th can\nmy $index = int(($n - 1) \/ (2 ** $doubles));\nprint $queue[$index];\n","Rust":"fn main() {\\n    let names = vec![\\\"Sheldon\\\", \\\"Leonard\\\", \\\"Penny\\\", \\\"Rajesh\\\", \\\"Howard\\\"];\\n    let mut n: u64 = 0;\\n    let mut i: u64 = 0;\\n\\n    \/\/ Read input\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    n = input.trim().parse().unwrap();\\n\\n    \/\/ Calculate the number of times each person drinks\\n    while n > 0 {\\n        n -= 1;\\n        i = n % 5;\\n        n \/= 5;\\n    }\\n\\n    \/\/ Print the name of the person who drinks the n-th can\\n    println!(\\\"{}\\\", names[i as usize]);\\n}"}
{"title":"D. Two out of Three","description":"Vasya has recently developed a new algorithm to optimize the reception of customer flow and he considered the following problem.Let the queue to the cashier contain n people, at that each of them is characterized by a positive integer ai \u2014 that is the time needed to work with this customer. What is special about this very cashier is that it can serve two customers simultaneously. However, if two customers need ai and aj of time to be served, the time needed to work with both of them customers is equal to max(ai,aj). Please note that working with customers is an uninterruptable process, and therefore, if two people simultaneously come to the cashier, it means that they begin to be served simultaneously, and will both finish simultaneously (it is possible that one of them will have to wait).Vasya used in his algorithm an ingenious heuristic \u2014 as long as the queue has more than one person waiting, then some two people of the first three standing in front of the queue are sent simultaneously. If the queue has only one customer number i, then he goes to the cashier, and is served within ai of time. Note that the total number of phases of serving a customer will always be equal to \u2308n\/2\u2309.Vasya thinks that this method will help to cope with the queues we all hate. That's why he asked you to work out a program that will determine the minimum time during which the whole queue will be served using this algorithm.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of the input file contains a single number n (1\u2264n\u22641000), which is the number of people in the sequence. The second line contains space-separated integers a1,a2,...,an (1\u2264ai\u226410^6). The people are numbered starting from the cashier to the end of the queue.\n","output_spec":"Print on the first line a single number \u2014 the minimum time needed to process all n people. Then on \u2308n\/2\u2309 lines print the order in which customers will be served. Each line (probably, except for the last one) must contain two numbers separated by a space \u2014 the numbers of customers who will be served at the current stage of processing. If n is odd, then the last line must contain a single number \u2014 the number of the last served customer in the queue. The customers are numbered starting from 1.\n","notes":null,"sample_inputs":["4\n1 2 3 4\n","5\n2 4 3 1 4\n"],"sample_outputs":["6\n1 2\n3 4\n","8\n1 3\n2 5\n4\n"],"id":"82-D","difficulty":2000,"tags":["dp"],"src_uid":"cc4b6ce9155e96c4b0ecb68e9d6d4ec0","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> a(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> a[i];\\n    }\\n\\n    sort(a.begin(), a.end());\\n\\n    int totalTime = 0;\\n    vector<pair<int, int>> servingOrder;\\n\\n    if (n % 2 == 0) {\\n        for (int i = 0; i < n \/ 2; i++) {\\n            servingOrder.push_back(make_pair(a[i], a[n - i - 1]));\\n            totalTime += max(a[i], a[n - i - 1]);\\n        }\\n    } else {\\n        for (int i = 0; i < n \/ 2; i++) {\\n            servingOrder.push_back(make_pair(a[i], a[n - i - 1]));\\n            totalTime += max(a[i], a[n - i - 1]);\\n        }\\n        servingOrder.push_back(make_pair(a[n \/ 2], a[n \/ 2]));\\n        totalTime += a[n \/ 2];\\n    }\\n\\n    cout << totalTime << endl;\\n    for (int i = 0; i < servingOrder.size(); i++) {\\n        cout << servingOrder[i].first << \\\" \\\" << servingOrder[i].second << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class QueueOptimization {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        scanner.close();\n        \n        int totalTime = 0;\n        List<String> servingOrder = new ArrayList<>();\n        \n        if (n == 1) {\n            totalTime = a[0];\n            servingOrder.add(Integer.toString(1));\n        } else {\n            for (int i = 0; i < n \/ 2; i++) {\n                int customer1 = i * 2 + 1;\n                int customer2 = i * 2 + 2;\n                int maxTime = Math.max(a[customer1 - 1], a[customer2 - 1]);\n                totalTime += maxTime;\n                servingOrder.add(customer1 + \" \" + customer2);\n            }\n            \n            if (n % 2 != 0) {\n                servingOrder.add(Integer.toString(n));\n            }\n        }\n        \n        System.out.println(totalTime);\n        for (String order : servingOrder) {\n            System.out.println(order);\n        }\n    }\n}","Python":"def process_queue(n, queue):\n    queue.sort()\n    total_time = 0\n    serving_order = []\n    \n    while len(queue) > 1:\n        serving_order.append((queue[0], queue[1]))\n        total_time += max(queue[0], queue[1])\n        queue = queue[2:]\n    \n    if len(queue) == 1:\n        serving_order.append(queue[0])\n        total_time += queue[0]\n    \n    return str(total_time) + '\\\\n' + '\\\\n'.join([' '.join(map(str, order)) for order in serving_order])","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for(int i=0; i<n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n    int min_time = 0;\\n    printf(\\\"%d\\\\n\\\", min_time);\\n    int i = 0;\\n    while(i < n-1) {\\n        if(i+2 < n) {\\n            printf(\\\"%d %d\\\\n\\\", i+1, i+2);\\n        } else {\\n            printf(\\\"%d\\\\n\\\", i+1);\\n        }\\n        i += 2;\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace QueueOptimization\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] customers = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n            Array.Sort(customers);\n\n            int totalTime = 0;\n            List<string> servingOrder = new List<string>();\n\n            while (n > 1)\n            {\n                if (n == 2)\n                {\n                    totalTime += customers[1];\n                    servingOrder.Add($\"{1} {2}\");\n                    break;\n                }\n                else if (n == 3)\n                {\n                    totalTime += customers[1] + customers[2];\n                    servingOrder.Add($\"{1} {2}\");\n                    servingOrder.Add($\"{1} {3}\");\n                    break;\n                }\n                else\n                {\n                    int option1 = customers[0] + 2 * customers[1] + customers[n - 1];\n                    int option2 = customers[0] + customers[n - 2] + 2 * customers[n - 1];\n\n                    if (option1 < option2)\n                    {\n                        totalTime += option1;\n                        servingOrder.Add($\"{1} {2}\");\n                        servingOrder.Add($\"{1} {n}\");\n                    }\n                    else\n                    {\n                        totalTime += option2;\n                        servingOrder.Add($\"{1} {n - 1}\");\n                        servingOrder.Add($\"{1} {n}\");\n                    }\n\n                    n -= 2;\n                }\n            }\n\n            Console.WriteLine(totalTime);\n            foreach (string order in servingOrder)\n            {\n                Console.WriteLine(order);\n            }\n        }\n    }\n}","Ruby":"def process_queue(input)\n  # Parse the input\n  n, customers = input.split(\"\\n\")\n  n = n.to_i\n  customers = customers.split(\" \").map(&:to_i)\n\n  # Sort the customers in ascending order\n  customers.sort!\n\n  # Initialize variables\n  total_time = 0\n  serving_order = []\n\n  # Process the queue\n  while customers.length > 1\n    # Take the first three customers\n    current_customers = customers.shift(3)\n\n    # Calculate the maximum time needed to serve the current customers\n    max_time = current_customers.max\n\n    # Add the maximum time to the total time\n    total_time += max_time\n\n    # Add the serving order to the list\n    serving_order << current_customers\n\n    # Remove the served customers from the queue\n    customers -= current_customers\n  end\n\n  # If there is one customer left, add their time to the total time\n  if customers.length == 1\n    total_time += customers.first\n  end\n\n  # Format the output\n  output = \"#{total_time}\\n\"\n  serving_order.each do |order|\n    output += \"#{order.join(\" \")}\\n\"\n  end\n\n  output.strip\nend\n\n# Test the function with the sample inputs\nputs process_queue('4\\n1 2 3 4\\n')\nputs process_queue('5\\n2 4 3 1 4\\n')","delphi":"program QueueOptimization;\\n\\nvar\\n  n, i, j, temp: integer;\\n  a: array[1..1000] of integer;\\n\\nbegin\\n  readln(n);\\n  for i := 1 to n do\\n    read(a[i]);\\n\\n  \/\/ Sort the array in ascending order\\n  for i := 1 to n-1 do\\n  begin\\n    for j := 1 to n-i do\\n    begin\\n      if a[j] > a[j+1] then\\n      begin\\n        temp := a[j];\\n        a[j] := a[j+1];\\n        a[j+1] := temp;\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Calculate the minimum time needed to process all customers\\n  writeln(a[n]);\\n\\n  \/\/ Print the order in which customers will be served\\n  for i := 1 to (n div 2) do\\n  begin\\n    writeln(a[i], ' ', a[n-i+1]);\\n  end;\\n\\n  \/\/ If n is odd, print the last served customer\\n  if n mod 2 = 1 then\\n    writeln(a[(n div 2) + 1]);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\ta := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&a[i])\\n\\t}\\n\\n\\tsort.Ints(a)\\n\\n\\ttotalTime := 0\\n\\tphases := (n + 1) \/ 2\\n\\n\\tfmt.Println(phases)\\n\\n\\tfor i := 0; i < phases-1; i++ {\\n\\t\\tfmt.Println(a[i], a[n-i-1])\\n\\t\\ttotalTime += max(a[i], a[n-i-1])\\n\\t}\\n\\n\\tif n%2 == 1 {\\n\\t\\tfmt.Println(a[phases-1])\\n\\t\\ttotalTime += a[phases-1]\\n\\t} else {\\n\\t\\tfmt.Println(a[phases-1], a[n-phases])\\n\\t\\ttotalTime += max(a[phases-1], a[n-phases])\\n\\t}\\n\\n\\tfmt.Println(totalTime)\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}","Javascript":"function processQueue(input) {\n  const lines = input.split('\\\\n');\n  const n = parseInt(lines[0]);\n  const customers = lines[1].split(' ').map(Number);\n  \n  let totalTime = 0;\n  let servingOrder = [];\n  \n  while (customers.length > 1) {\n    const firstThree = customers.slice(0, 3);\n    const maxTime = Math.max(...firstThree);\n    const maxIndex = firstThree.indexOf(maxTime);\n    \n    if (maxIndex === 0) {\n      servingOrder.push([1, 2]);\n    } else if (maxIndex === 1) {\n      servingOrder.push([2, 3]);\n    } else {\n      servingOrder.push([1, 3]);\n    }\n    \n    totalTime += maxTime;\n    customers.splice(0, 3);\n  }\n  \n  if (customers.length === 1) {\n    totalTime += customers[0];\n    servingOrder.push([1]);\n  }\n  \n  const output = `${totalTime}\\\\n`;\n  for (let i = 0; i < servingOrder.length; i++) {\n    output += servingOrder[i].join(' ') + '\\\\n';\n  }\n  \n  return output;\n}\n\nconst input = '4\\\\n1 2 3 4\\\\n';\nconsole.log(processQueue(input));","Kotlin":"import kotlin.math.ceil\\n\\nfun main() {\\n    val n = readLine()!!.toInt()\\n    val a = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n\\n    val totalTime = a.sum()\\n    val phases = ceil(n.toDouble() \/ 2).toInt()\\n\\n    println(totalTime)\\n\\n    var i = 0\\n    for (phase in 1..phases) {\\n        if (n - i == 1) {\\n            println(a[i])\\n        } else {\\n            println(\\\"${a[i]} ${a[i + 1]}\\\")\\n        }\\n        i += 2\\n    }\\n}","PHP":"<?php\\n\\nfunction processQueue($n, $queue) {\\n    \/\/ Sort the queue in ascending order\\n    sort($queue);\\n    \\n    \/\/ Calculate the minimum time needed to process all customers\\n    $minTime = 0;\\n    for ($i = 0; $i < $n; $i += 2) {\\n        $minTime += max($queue[$i], $queue[$i + 1]);\\n    }\\n    \\n    \/\/ Prepare the output\\n    $output = $minTime . \\\"\\\\n\\\";\\n    \\n    \/\/ Process the queue\\n    for ($i = 0; $i < $n; $i += 2) {\\n        $output .= ($i + 1) . \\\" \\\" . ($i + 2) . \\\"\\\\n\\\";\\n    }\\n    \\n    \/\/ If the number of customers is odd, add the last customer to the output\\n    if ($n % 2 != 0) {\\n        $output .= ($n) . \\\"\\\\n\\\";\\n    }\\n    \\n    return $output;\\n}\\n\\n\/\/ Read input from stdin\\n$input = file_get_contents('php:\/\/stdin');\\n$lines = explode(\\\"\\\\n\\\", $input);\\n\\n\/\/ Parse input\\n$n = intval($lines[0]);\\n$queue = array_map('intval', explode(\\\" \\\", $lines[1]));\\n\\n\/\/ Process the queue\\n$output = processQueue($n, $queue);\\n\\n\/\/ Print the output\\necho $output;\\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    int[] a;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    a = readln.split.map!(a => a.to!int).array;\\r\\n\\r\\n    \/\/ Sort the array in descending order\\r\\n    a.sort!((x, y) => y - x);\\r\\n\\r\\n    \/\/ Calculate the minimum time needed to process all customers\\r\\n    int minTime = 0;\\r\\n    for (int i = 0; i < n; i += 2)\\r\\n    {\\r\\n        if (i + 1 < n)\\r\\n        {\\r\\n            minTime += max(a[i], a[i + 1]);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            minTime += a[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the minimum time\\r\\n    writeln(minTime);\\r\\n\\r\\n    \/\/ Print the order in which customers will be served\\r\\n    int j = 0;\\r\\n    for (int i = 0; i < n \/ 2; i++)\\r\\n    {\\r\\n        if (j + 1 < n)\\r\\n        {\\r\\n            writeln(a[j], \\\" \\\", a[j + 1]);\\r\\n            j += 2;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            writeln(a[j]);\\r\\n        }\\r\\n    }\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub process_queue {\\n    my ($n, @queue) = @_;\\n    my $total_time = 0;\\n    my @served_customers;\\n\\n    while (@queue > 1) {\\n        my ($customer1, $customer2) = splice(@queue, 0, 2);\\n        my $max_time = max($customer1, $customer2);\\n        push @served_customers, [$customer1, $customer2];\\n        $total_time += $max_time;\\n    }\\n\\n    if (@queue == 1) {\\n        push @served_customers, $queue[0];\\n        $total_time += $queue[0];\\n    }\\n\\n    return ($total_time, \\@served_customers);\\n}\\n\\nsub max {\\n    my ($a, $b) = @_;\\n    return $a > $b ? $a : $b;\\n}\\n\\n# Read input\\nmy $n = <STDIN>;\\nchomp $n;\\nmy $queue = <STDIN>;\\nchomp $queue;\\nmy @queue = split(' ', $queue);\\n\\n# Process queue\\nmy ($min_time, $served_customers) = process_queue($n, @queue);\\n\\n# Print output\\nprint \\\"$min_time\\\\n\\\";\\nforeach my $served (@$served_customers) {\\n    if (ref $served eq 'ARRAY') {\\n        print \\\"$served->[0] $served->[1]\\\\n\\\";\\n    } else {\\n        print \\\"$served\\\\n\\\";\\n    }\\n}\\n","Rust":"use std::cmp::max;\n\nfn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let mut lines = input.lines();\n    \n    let n: usize = lines.next().unwrap().parse().unwrap();\n    let a: Vec<usize> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut serving_order: Vec<Vec<usize>> = Vec::new();\n    \n    let mut time = 0;\n    let mut i = 0;\n    \n    while i < n {\n        if i + 2 < n {\n            serving_order.push(vec![i + 1, i + 2]);\n            time += max(a[i], a[i + 1]);\n            i += 2;\n        } else {\n            serving_order.push(vec![i + 1]);\n            time += a[i];\n            i += 1;\n        }\n    }\n    \n    println!(\"{}\", time);\n    \n    for order in serving_order {\n        for (index, customer) in order.iter().enumerate() {\n            print!(\"{}\", customer);\n            if index < order.len() - 1 {\n                print!(\" \");\n            }\n        }\n        println!();\n    }\n}"}
{"title":"C. Bamboo Partition","description":"Vladimir wants to modernize partitions in his office. To make the office more comfortable he decided to remove a partition and plant several bamboos in a row. He thinks it would be nice if there are n bamboos in a row, and the i-th from the left is ai meters high. Vladimir has just planted n bamboos in a row, each of which has height 0 meters right now, but they grow 1 meter each day. In order to make the partition nice Vladimir can cut each bamboo once at any height (no greater that the height of the bamboo), and then the bamboo will stop growing.Vladimir wants to check the bamboos each d days (i.e. d days after he planted, then after 2d days and so on), and cut the bamboos that reached the required height. Vladimir wants the total length of bamboo parts he will cut off to be no greater than k meters.What is the maximum value d he can choose so that he can achieve what he wants without cutting off more than k meters of bamboo?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"512 megabytes","input_spec":"The first line contains two integers n and k (1\u2264n\u2264100, 1\u2264k\u226410^11)\u00a0\u2014 the number of bamboos and the maximum total length of cut parts, in meters.\nThe second line contains n integers a1,a2,...,an (1\u2264ai\u226410^9)\u00a0\u2014 the required heights of bamboos, in meters.\n","output_spec":"Print a single integer\u00a0\u2014 the maximum value of d such that Vladimir can reach his goal.\n","notes":"In the first example Vladimir can check bamboos each 3 days. Then he will cut the first and the second bamboos after 3 days, and the third bamboo after 6 days. The total length of cut parts is 2+0+1=3 meters.\n","sample_inputs":["3 4\n1 3 5\n","3 40\n10 30 50\n"],"sample_outputs":["3\n","32\n"],"id":"830-C","difficulty":2300,"tags":["brute+force","data+structures","implementation","math","number+theory","sortings","two+pointers"],"src_uid":"2e1ab01d4d4440f33c840c4564a20a60","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n    vector<int> heights(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> heights[i];\\n    }\\n    sort(heights.begin(), heights.end());\\n    int maxD = 0;\\n    for (int d = 1; d <= n; d++) {\\n        int totalCut = 0;\\n        for (int i = d - 1; i < n; i += d) {\\n            int cut = heights[i] - 1;\\n            totalCut += cut;\\n            if (totalCut > k) {\\n                break;\\n            }\\n        }\\n        if (totalCut <= k) {\\n            maxD = d;\\n        }\\n    }\\n    cout << maxD << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class BambooPartitions {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input\n        String[] nk = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(nk[0]);\n        long k = Long.parseLong(nk[1]);\n        \n        String[] heights = scanner.nextLine().split(\\\" \\\");\n        int[] requiredHeights = new int[n];\n        for (int i = 0; i < n; i++) {\n            requiredHeights[i] = Integer.parseInt(heights[i]);\n        }\n        \n        \/\/ Find the maximum value of d\n        long maxD = 0;\n        for (int i = 0; i < n; i++) {\n            long days = (requiredHeights[i] - 1) \/ n + 1;\n            maxD = Math.max(maxD, days);\n        }\n        \n        \/\/ Check if the total length of cut parts is within the limit\n        long totalCutLength = 0;\n        for (int i = 0; i < n; i++) {\n            long days = (requiredHeights[i] - 1) \/ n + 1;\n            long cutLength = days * n - requiredHeights[i];\n            totalCutLength += cutLength;\n        }\n        \n        if (totalCutLength <= k) {\n            System.out.println(maxD);\n        } else {\n            System.out.println(maxD - (totalCutLength - k) \/ n);\n        }\n    }\n}","Python":"def max_d(n, k, heights):\n    max_height = max(heights)\n    max_d = 0\n    for i in range(1, max_height + 1):\n        total_length = 0\n        for height in heights:\n            if height > i:\n                total_length += height - i\n        if total_length <= k:\n            max_d = i\n    return max_d\n\ninput_data = input().split('\\\\n')\nn, k = map(int, input_data[0].split())\nheights = list(map(int, input_data[1].split()))\n\nresult = max_d(n, k, heights)\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, k;\\n    scanf(\\\"%d %d\\\", &n, &k);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int max_d = 1;\\n    for (int d = 1; d <= n; d++) {\\n        int total_cut = 0;\\n        for (int i = 0; i < n; i++) {\\n            int days = (a[i] + d - 1) \/ d;\\n            total_cut += days * d - a[i];\\n        }\\n        if (total_cut <= k) {\\n            max_d = d;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", max_d);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        long k = long.Parse(input[1]);\n\n        int[] heights = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n        int maxDays = 0;\n        for (int i = 0; i < n; i++)\n        {\n            int days = (int)Math.Ceiling((double)(heights[i] - 1) \/ k);\n            maxDays = Math.Max(maxDays, days);\n        }\n\n        Console.WriteLine(maxDays);\n    }\n}","Ruby":"\ndef max_d(n, k, heights)\n  max_height = heights.max\n  max_d = 1\n  while true\n    total_cut_length = 0\n    heights.each do |height|\n      days = (height - 1) \/ max_d + 1\n      cut_length = [days * max_d - height, 0].min\n      total_cut_length += cut_length\n    end\n    break if total_cut_length > k\n    max_d += 1\n  end\n  max_d - 1\nend\n\ninput = gets.chomp.split('\\n')\nn, k = input[0].split(' ').map(&:to_i)\nheights = input[1].split(' ').map(&:to_i)\n\noutput = max_d(n, k, heights)\nputs output\n","delphi":"program BambooCutting;\\n\\nvar\\n  n, k, i, maxD, maxHeight, totalLength: Integer;\\n  heights: array of Integer;\\n\\nbegin\\n  ReadLn(n, k);\\n  SetLength(heights, n);\\n  for i := 0 to n-1 do\\n    Read(heights[i]);\\n\\n  maxD := 1;\\n  maxHeight := 0;\\n  totalLength := 0;\\n\\n  for i := 0 to n-1 do\\n  begin\\n    if heights[i] > maxHeight then\\n      maxHeight := heights[i];\\n\\n    if (maxHeight * maxD) - totalLength > k then\\n    begin\\n      Inc(maxD);\\n      totalLength := maxHeight * (maxD - 1);\\n    end;\\n  end;\\n\\n  WriteLn(maxD);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\n\\theights := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &heights[i])\\n\\t}\\n\\n\\tsort.Ints(heights)\\n\\n\\tmaxD := 0\\n\\tfor d := 1; d <= n; d++ {\\n\\t\\ttotalCut := 0\\n\\t\\tfor i := n - 1; i >= 0; i -= d {\\n\\t\\t\\tcutHeight := heights[i] - (i\/d)*d\\n\\t\\t\\tif cutHeight < 0 {\\n\\t\\t\\t\\tcutHeight = 0\\n\\t\\t\\t}\\n\\t\\t\\ttotalCut += cutHeight\\n\\t\\t}\\n\\n\\t\\tif totalCut <= k {\\n\\t\\t\\tmaxD = d\\n\\t\\t} else {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxD)\\n}","Javascript":"function maximumValueOfD(input) {\n  const [n, k] = input[0].split(' ').map(Number);\n  const heights = input[1].split(' ').map(Number);\n\n  let maxD = 1;\n  for (let d = 1; d <= n; d++) {\n    let totalCutLength = 0;\n    for (let i = 0; i < n; i++) {\n      const bambooHeight = heights[i] - (d * i);\n      if (bambooHeight > 0) {\n        totalCutLength += Math.min(bambooHeight, d);\n      }\n    }\n    if (totalCutLength <= k) {\n      maxD = d;\n    } else {\n      break;\n    }\n  }\n\n  return maxD.toString();\n}\n\nconst inputs = ['3 4\\\\n1 3 5\\\\n', '3 40\\\\n10 30 50\\\\n'];\nconst outputs = inputs.map(input => maximumValueOfD(input.split('\\\\n')));\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val nk = scanner.nextLine().split(\" \")\n    val n = nk[0].toInt()\n    val k = nk[1].toLong()\n    val heights = scanner.nextLine().split(\" \").map { it.toInt() }\n\n    var maxD = 0\n    for (d in 1..n) {\n        var totalCutLength = 0L\n        for (i in 0 until n step d) {\n            val bambooHeight = heights[i]\n            val daysToGrow = (bambooHeight - 1) \/ d + 1\n            val cutLength = daysToGrow * d - bambooHeight\n            totalCutLength += cutLength\n        }\n        if (totalCutLength <= k) {\n            maxD = d\n        } else {\n            break\n        }\n    }\n\n    println(maxD)\n}","PHP":"<?php\\n\\nfunction calculateMaxD($n, $k, $bambooHeights) {\\n    \/\/ Sort the bamboo heights in ascending order\\n    sort($bambooHeights);\\n    \\n    \/\/ Initialize variables\\n    $maxD = 1;\\n    $totalCutLength = 0;\\n    \\n    \/\/ Iterate through each bamboo height\\n    for ($i = 0; $i < $n; $i++) {\\n        \/\/ Calculate the number of days required for the current bamboo to reach its required height\\n        $requiredDays = ceil(($bambooHeights[$i] - $totalCutLength) \/ $n);\\n        \\n        \/\/ Update the maximum value of d\\n        $maxD = max($maxD, $requiredDays);\\n        \\n        \/\/ Update the total cut length\\n        $totalCutLength += $requiredDays;\\n        \\n        \/\/ Check if the total cut length exceeds the maximum allowed length\\n        if ($totalCutLength > $k) {\\n            \/\/ Reduce the maximum value of d by 1\\n            $maxD--;\\n            break;\\n        }\\n    }\\n    \\n    return $maxD;\\n}\\n\\n\/\/ Read input from stdin\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n\\n\/\/ Parse input\\nlist($n, $k) = explode(\\\" \\\", $input[0]);\\n$bambooHeights = explode(\\\" \\\", $input[1]);\\n\\n\/\/ Call the function and print the result\\n$result = calculateMaxD($n, $k, $bambooHeights);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, k;\\r\\n    int[] heights;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d\\\", &n, &k);\\r\\n    heights = new int[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &heights[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Sort the heights in descending order\\r\\n    heights.sort!((a, b) => b - a);\\r\\n\\r\\n    \/\/ Calculate the maximum value of d\\r\\n    int maxD = 1;\\r\\n    int totalCutLength = 0;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        int days = i + 1;\\r\\n        int cutLength = days * (heights[i] - heights[i + 1]);\\r\\n        totalCutLength += cutLength;\\r\\n\\r\\n        if (totalCutLength > k)\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        maxD = days;\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(maxD);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub max_d {\n    my ($n, $k, @heights) = @_;\n\n    my $max_height = 0;\n    foreach my $height (@heights) {\n        $max_height = $height if $height > $max_height;\n    }\n\n    my $max_d = 0;\n    for (my $d = 1; $d <= $max_height; $d++) {\n        my $total_cut_length = 0;\n        foreach my $height (@heights) {\n            my $days = int(($height - 1) \/ $d) + 1;\n            my $cut_length = $days * $d - $height;\n            $total_cut_length += $cut_length if $cut_length <= $k;\n        }\n        if ($total_cut_length <= $k) {\n            $max_d = $d;\n        } else {\n            last;\n        }\n    }\n\n    return $max_d;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @heights = split ' ', $input;\n\n# Call the function and print the result\nmy $result = max_d($n, $k, @heights);\nprint $result;\n","Rust":"fn main() {\n    let input = std::io::stdin();\n    let mut buf = String::new();\n    input.read_line(&mut buf).unwrap();\n    let mut iter = buf.split_whitespace();\n    let n: usize = iter.next().unwrap().parse().unwrap();\n    let k: u64 = iter.next().unwrap().parse().unwrap();\n    \n    buf.clear();\n    input.read_line(&mut buf).unwrap();\n    let heights: Vec<u64> = buf.split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut max_d = 1;\n    for d in 1..=n {\n        let mut total_cut = 0;\n        for i in 0..n {\n            let days = (heights[i] + d - 1) \/ d;\n            total_cut += days * d - heights[i];\n        }\n        if total_cut <= k {\n            max_d = d;\n        } else {\n            break;\n        }\n    }\n    \n    println!(\"{}\", max_d);\n}"}
{"title":"C. Track","description":"You already know that Valery's favorite sport is biathlon. Due to your help, he learned to shoot without missing, and his skills are unmatched at the shooting range. But now a smaller task is to be performed, he should learn to complete the path fastest.The track's map is represented by a rectangle n\u00d7m in size divided into squares. Each square is marked with a lowercase Latin letter (which means the type of the plot), with the exception of the starting square (it is marked with a capital Latin letters S) and the terminating square (it is marked with a capital Latin letter T). The time of movement from one square to another is equal to 1 minute. The time of movement within the cell can be neglected. We can move from the cell only to side-adjacent ones, but it is forbidden to go beyond the map edges. Also the following restriction is imposed on the path: it is not allowed to visit more than k different types of squares (squares of one type can be visited an infinite number of times). Squares marked with S and T have no type, so they are not counted. But S must be visited exactly once \u2014 at the very beginning, and T must be visited exactly once \u2014 at the very end.Your task is to find the path from the square S to the square T that takes minimum time. Among all shortest paths you should choose the lexicographically minimal one. When comparing paths you should lexicographically represent them as a sequence of characters, that is, of plot types.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"256 megabytes","input_spec":"The first input line contains three integers n, m and k (1\u2264n,m\u226450,n\u00b7m\u22652,1\u2264k\u22644). Then n lines contain the map. Each line has the length of exactly m characters and consists of lowercase Latin letters and characters S and T. It is guaranteed that the map contains exactly one character S and exactly one character T.\nPretest 12 is one of the maximal tests for this problem.\n","output_spec":"If there is a path that satisfies the condition, print it as a sequence of letters \u2014 the plot types. Otherwise, print \"-1\" (without quotes). You shouldn't print the character S in the beginning and T in the end.\nNote that this sequence may be empty. This case is present in pretests. You can just print nothing or print one \"End of line\"-character. Both will be accepted.\n","notes":null,"sample_inputs":["5 3 2\nSba\nccc\naac\nccc\nabT\n","3 4 1\nSxyy\nyxxx\nyyyT\n","1 3 3\nTyS\n","1 4 1\nSxyT\n"],"sample_outputs":["bcccc\n","xxxx\n","y\n","-1\n"],"id":"83-C","difficulty":2400,"tags":["graphs","greedy","shortest+paths"],"src_uid":"1d73b315694f2ebbf796654193372730","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <cstring>\\n#include <algorithm>\\nusing namespace std;\\n\\nconst int MAXN = 55;\\n\\nint n, m, k;\\nchar grid[MAXN][MAXN];\\nint dist[MAXN][MAXN][5];\\nint dx[] = {0, 0, 1, -1};\\nint dy[] = {1, -1, 0, 0};\\n\\nbool valid(int x, int y) {\\n    return x >= 0 && x < n && y >= 0 && y < m;\\n}\\n\\nvoid bfs(int sx, int sy) {\\n    memset(dist, -1, sizeof(dist));\\n    queue<pair<int, pair<int, int>>> q;\\n    q.push({0, {sx, sy}});\\n    dist[sx][sy][0] = 0;\\n    while (!q.empty()) {\\n        int x = q.front().second.first;\\n        int y = q.front().second.second;\\n        int mask = q.front().first;\\n        q.pop();\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            if (valid(nx, ny) && grid[nx][ny] != '#') {\\n                int nmask = mask;\\n                if (grid[nx][ny] != grid[x][y] && grid[nx][ny] != 'S' && grid[nx][ny] != 'T') {\\n                    nmask |= (1 << (grid[nx][ny] - 'a'));\\n                }\\n                if (dist[nx][ny][nmask] == -1) {\\n                    dist[nx][ny][nmask] = dist[x][y][mask] + 1;\\n                    q.push({nmask, {nx, ny}});\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nstring solve() {\\n    int sx, sy, tx, ty;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (grid[i][j] == 'S') {\\n                sx = i;\\n                sy = j;\\n            }\\n            if (grid[i][j] == 'T') {\\n                tx = i;\\n                ty = j;\\n            }\\n        }\\n    }\\n    bfs(sx, sy);\\n    int ans = dist[tx][ty][(1 << k) - 1];\\n    if (ans == -1) {\\n        return \\\"-1\\\\n\\\";\\n    }\\n    string path;\\n    int x = tx, y = ty, mask = (1 << k) - 1;\\n    while (x != sx || y != sy) {\\n        for (int i = 0; i < 4; i++) {\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n            if (valid(nx, ny) && grid[nx][ny] != '#' && dist[nx][ny][mask] == dist[x][y][mask] - 1) {\\n                if (grid[nx][ny] != grid[x][y] && grid[nx][ny] != 'S' && grid[nx][ny] != 'T') {\\n                    mask ^= (1 << (grid[nx][ny] - 'a'));\\n                }\\n                path.push_back(grid[nx][ny]);\\n                x = nx;\\n                y = ny;\\n                break;\\n            }\\n        }\\n    }\\n    reverse(path.begin(), path.end());\\n    return path;\\n}\\n\\nint main() {\\n    cin >> n >> m >> k;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            cin >> grid[i][j];\\n        }\\n    }\\n    string ans = solve();\\n    cout << ans;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    static int n, m, k;\n    static char[][] map;\n    static boolean[][] visited;\n    static int[][] dist;\n    static int[][] types;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    static int[] path;\n    static int pathIndex;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n        k = scanner.nextInt();\n        scanner.nextLine();\n\n        map = new char[n][m];\n        visited = new boolean[n][m];\n        dist = new int[n][m];\n        types = new int[n][m];\n        path = new int[n * m];\n        pathIndex = 0;\n\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < m; j++) {\n                map[i][j] = line.charAt(j);\n            }\n        }\n\n        int startX = -1, startY = -1;\n        int endX = -1, endY = -1;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (map[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                } else if (map[i][j] == 'T') {\n                    endX = i;\n                    endY = j;\n                }\n            }\n        }\n\n        bfs(startX, startY);\n\n        if (dist[endX][endY] == 0) {\n            System.out.println(\"-1\");\n        } else {\n            getPath(endX, endY);\n            printPath();\n        }\n    }\n\n    static void bfs(int startX, int startY) {\n        Queue<Pair> queue = new LinkedList<>();\n        queue.add(new Pair(startX, startY));\n        visited[startX][startY] = true;\n\n        while (!queue.isEmpty()) {\n            Pair curr = queue.poll();\n            int x = curr.x;\n            int y = curr.y;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (isValid(nx, ny)) {\n                    if (!visited[nx][ny]) {\n                        visited[nx][ny] = true;\n                        dist[nx][ny] = dist[x][y] + 1;\n                        types[nx][ny] = types[x][y] + (map[nx][ny] != map[startX][startY] ? 1 : 0);\n                        queue.add(new Pair(nx, ny));\n                    } else if (dist[nx][ny] == dist[x][y] + 1 && types[nx][ny] > types[x][y] + (map[nx][ny] != map[startX][startY] ? 1 : 0)) {\n                        types[nx][ny] = types[x][y] + (map[nx][ny] != map[startX][startY] ? 1 : 0);\n                        queue.add(new Pair(nx, ny));\n                    }\n                }\n            }\n        }\n    }\n\n    static boolean isValid(int x, int y) {\n        return x >= 0 && x < n && y >= 0 && y < m && map[x][y] != 'S';\n    }\n\n    static void getPath(int x, int y) {\n        path[pathIndex++] = x * m + y;\n\n        if (x == 0 && y == 0) {\n            return;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (isValid(nx, ny) && dist[nx][ny] == dist[x][y] - 1 && types[nx][ny] == types[x][y] - (map[nx][ny] != map[x][y] ? 1 : 0)) {\n                getPath(nx, ny);\n                return;\n            }\n        }\n    }\n\n    static void printPath() {\n        StringBuilder sb = new StringBuilder();\n\n        for (int i = pathIndex - 1; i >= 0; i--) {\n            int x = path[i] \/ m;\n            int y = path[i] % m;\n            sb.append(map[x][y]);\n        }\n\n        System.out.println(sb.toString());\n    }\n\n    static class Pair {\n        int x, y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}","Python":"from collections import deque\n\ndef find_path(n, m, k, grid):\n    start = None\n    end = None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'T':\n                end = (i, j)\n    \n    visited = set()\n    queue = deque([(start, '', 0, set())])\n    \n    while queue:\n        curr, path, time, types = queue.popleft()\n        x, y = curr\n        \n        if curr == end and len(types) <= k:\n            return path\n        \n        if curr in visited:\n            continue\n        \n        visited.add(curr)\n        \n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < n and 0 <= ny < m:\n                if grid[nx][ny] != 'S' and grid[nx][ny] != 'T':\n                    new_types = types.copy()\n                    new_types.add(grid[nx][ny])\n                    \n                    if len(new_types) <= k:\n                        queue.append(((nx, ny), path + grid[nx][ny], time + 1, new_types))\n    \n    return '-1'\n\n# Sample Inputs\ninputs = [\n    {'n': 5, 'm': 3, 'k': 2, 'grid': ['Sba', 'ccc', 'aac', 'ccc', 'abT']},\n    {'n': 3, 'm': 4, 'k': 1, 'grid': ['Sxyy', 'yxxx', 'yyyT']},\n    {'n': 1, 'm': 3, 'k': 3, 'grid': ['TyS']},\n    {'n': 1, 'm': 4, 'k': 1, 'grid': ['SxyT']}\n]\n\n# Processing Inputs and Printing Outputs\noutputs = []\nfor data in inputs:\n    n, m, k, grid = data['n'], data['m'], data['k'], data['grid']\n    outputs.append(find_path(n, m, k, grid))\n    \noutputs = [o + '\\\\n' for o in outputs]\nprint(outputs)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define MAXN 55\\n\\nint n, m, k;\\nchar grid[MAXN][MAXN];\\nint visited[MAXN][MAXN];\\nint dx[] = {0, 0, 1, -1};\\nint dy[] = {1, -1, 0, 0};\\nchar path[MAXN * MAXN];\\nint pathLen;\\n\\nint isValid(int x, int y) {\\n    return x >= 0 && x < n && y >= 0 && y < m;\\n}\\n\\nvoid dfs(int x, int y, int cnt) {\\n    if (x < 0 || x >= n || y < 0 || y >= m || visited[x][y] || cnt > k) {\\n        return;\\n    }\\n    visited[x][y] = 1;\\n    path[pathLen++] = grid[x][y];\\n    if (x == n - 1 && y == m - 1 && cnt == k) {\\n        path[pathLen] = '\\\\0';\\n        return;\\n    }\\n    for (int i = 0; i < 4; i++) {\\n        int nx = x + dx[i];\\n        int ny = y + dy[i];\\n        dfs(nx, ny, cnt + (grid[x][y] != grid[nx][ny]));\\n    }\\n    visited[x][y] = 0;\\n    pathLen--;\\n}\\n\\nint main() {\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s\\\", grid[i]);\\n    }\\n    pathLen = 0;\\n    dfs(0, 0, 0);\\n    if (pathLen == 0) {\\n        printf(\\\"-1\\\\n\\\");\\n    } else {\\n        printf(\\\"%s\\\\n\\\", path);\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace Biathlon\n{\n    class Program\n    {\n        static int n, m, k;\n        static char[,] map;\n        static bool[,] visited;\n        static int[,] dist;\n        static int[,] prev;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        static List<char> path;\n\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            n = int.Parse(input[0]);\n            m = int.Parse(input[1]);\n            k = int.Parse(input[2]);\n\n            map = new char[n, m];\n            visited = new bool[n, m];\n            dist = new int[n, m];\n            prev = new int[n, m];\n            path = new List<char>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string line = Console.ReadLine();\n                for (int j = 0; j < m; j++)\n                {\n                    map[i, j] = line[j];\n                }\n            }\n\n            int startX = -1, startY = -1;\n            int endX = -1, endY = -1;\n\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (map[i, j] == 'S')\n                    {\n                        startX = i;\n                        startY = j;\n                    }\n                    else if (map[i, j] == 'T')\n                    {\n                        endX = i;\n                        endY = j;\n                    }\n                }\n            }\n\n            Dijkstra(startX, startY);\n\n            if (dist[endX, endY] == int.MaxValue)\n            {\n                Console.WriteLine(\"-1\");\n            }\n            else\n            {\n                FindPath(endX, endY);\n                path.Reverse();\n                Console.WriteLine(string.Join(\"\", path));\n            }\n        }\n\n        static void Dijkstra(int startX, int startY)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    dist[i, j] = int.MaxValue;\n                }\n            }\n\n            dist[startX, startY] = 0;\n\n            for (int i = 0; i < n * m; i++)\n            {\n                int minDist = int.MaxValue;\n                int minIndexX = -1, minIndexY = -1;\n\n                for (int x = 0; x < n; x++)\n                {\n                    for (int y = 0; y < m; y++)\n                    {\n                        if (!visited[x, y] && dist[x, y] < minDist)\n                        {\n                            minDist = dist[x, y];\n                            minIndexX = x;\n                            minIndexY = y;\n                        }\n                    }\n                }\n\n                visited[minIndexX, minIndexY] = true;\n\n                for (int j = 0; j < 4; j++)\n                {\n                    int newX = minIndexX + dx[j];\n                    int newY = minIndexY + dy[j];\n\n                    if (IsValid(newX, newY))\n                    {\n                        int weight = (map[newX, newY] == map[minIndexX, minIndexY]) ? 0 : 1;\n\n                        if (dist[minIndexX, minIndexY] + weight < dist[newX, newY])\n                        {\n                            dist[newX, newY] = dist[minIndexX, minIndexY] + weight;\n                            prev[newX, newY] = j;\n                        }\n                    }\n                }\n            }\n        }\n\n        static bool IsValid(int x, int y)\n        {\n            return x >= 0 && x < n && y >= 0 && y < m;\n        }\n\n        static void FindPath(int x, int y)\n        {\n            if (x == 0 && y == 0)\n            {\n                return;\n            }\n\n            int prevX = x - dx[prev[x, y]];\n            int prevY = y - dy[prev[x, y]];\n\n            FindPath(prevX, prevY);\n\n            if (map[prevX, prevY] != map[x, y])\n            {\n                path.Add(map[x, y]);\n            }\n        }\n    }\n}","Ruby":"def find_path(n, m, k, map)\n  start = nil\n  target = nil\n  map.each_with_index do |row, i|\n    if row.include?('S')\n      start = [i, row.index('S')]\n    end\n    if row.include?('T')\n      target = [i, row.index('T')]\n    end\n  end\n\n  visited = Array.new(n) { Array.new(m, false) }\n  visited[start[0]][start[1]] = true\n\n  queue = [[start, '']]\n  while !queue.empty?\n    current, path = queue.shift\n    x, y = current\n\n    if current == target\n      return path\n    end\n\n    neighbors = [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]\n    neighbors.each do |neighbor|\n      nx, ny = neighbor\n      if nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]\n        visited[nx][ny] = true\n        if map[nx][ny] == 'T'\n          queue.push([neighbor, path + map[nx][ny]])\n        elsif path.count(map[nx][ny]) < k\n          queue.push([neighbor, path + map[nx][ny]])\n        end\n      end\n    end\n  end\n\n  return '-1'\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\nk = input[2].to_i\n\nmap = []\nn.times do\n  map.push(gets.chomp)\nend\n\nputs find_path(n, m, k, map)\n","delphi":"Here is an example of how you can solve this problem using Delphi 7:\n\nprogram Biathlon;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nconst\n  MAX_N = 50;\n  MAX_M = 50;\n  MAX_K = 4;\n\ntype\n  TMap = array[1..MAX_N, 1..MAX_M] of Char;\n\nvar\n  n, m, k: Integer;\n  map: TMap;\n  visited: array[1..MAX_N, 1..MAX_M] of Boolean;\n  path: string;\n\nprocedure ReadInput;\nvar\n  i: Integer;\nbegin\n  ReadLn(n, m, k);\n  for i := 1 to n do\n    ReadLn(map[i]);\nend;\n\nfunction IsValidMove(x, y: Integer): Boolean;\nbegin\n  Result := (x >= 1) and (x <= n) and (y >= 1) and (y <= m) and (not visited[x, y]);\nend;\n\nprocedure DFS(x, y, count: Integer; currentPath: string);\nvar\n  i, j: Integer;\nbegin\n  visited[x, y] := True;\n  currentPath := currentPath + map[x, y];\n  \n  if (x = n) and (y = m) then\n  begin\n    if (count = k) then\n      path := currentPath;\n    Exit;\n  end;\n  \n  if IsValidMove(x + 1, y) then\n    DFS(x + 1, y, count + Ord(map[x + 1, y] <> map[x, y]), currentPath);\n  \n  if IsValidMove(x - 1, y) then\n    DFS(x - 1, y, count + Ord(map[x - 1, y] <> map[x, y]), currentPath);\n  \n  if IsValidMove(x, y + 1) then\n    DFS(x, y + 1, count + Ord(map[x, y + 1] <> map[x, y]), currentPath);\n  \n  if IsValidMove(x, y - 1) then\n    DFS(x, y - 1, count + Ord(map[x, y - 1] <> map[x, y]), currentPath);\n  \n  visited[x, y] := False;\nend;\n\nprocedure Solve;\nbegin\n  path := '';\n  DFS(1, 1, 0, '');\nend;\n\nprocedure PrintOutput;\nbegin\n  if path = '' then\n    WriteLn('-1')\n  else\n    WriteLn(path);\nend;\n\nbegin\n  ReadInput;\n  Solve;\n  PrintOutput;\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nvar n, m, k int\\nvar grid [][]byte\\nvar visited [][]bool\\nvar start, end point\\nvar minPath []byte\\n\\nfunc main() {\\n\\tfmt.Scan(&n, &m, &k)\\n\\tgrid = make([][]byte, n)\\n\\tvisited = make([][]bool, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tvar row string\\n\\t\\tfmt.Scan(&row)\\n\\t\\tgrid[i] = []byte(row)\\n\\t\\tvisited[i] = make([]bool, m)\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif grid[i][j] == 'S' {\\n\\t\\t\\t\\tstart = point{i, j}\\n\\t\\t\\t} else if grid[i][j] == 'T' {\\n\\t\\t\\t\\tend = point{i, j}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tminPath = make([]byte, 0)\\n\\tvisited[start.x][start.y] = true\\n\\tdfs(start, 0, 0, []byte{})\\n\\n\\tif len(minPath) == 0 {\\n\\t\\tfmt.Println(-1)\\n\\t} else {\\n\\t\\tfmt.Println(string(minPath))\\n\\t}\\n}\\n\\ntype point struct {\\n\\tx, y int\\n}\\n\\ntype path struct {\\n\\tx, y, time int\\n\\tvisited []byte\\n}\\n\\nfunc dfs(p point, time, count int, visited []byte) {\\n\\tif p == end {\\n\\t\\tif len(minPath) == 0 || string(visited) < string(minPath) {\\n\\t\\t\\tminPath = visited\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tif count > k {\\n\\t\\treturn\\n\\t}\\n\\n\\tif len(minPath) > 0 && len(visited) >= len(minPath) {\\n\\t\\treturn\\n\\t}\\n\\n\\tif p.x > 0 && !visited[p.x-1][p.y] {\\n\\t\\tvisited[p.x-1][p.y] = true\\n\\t\\tdfs(point{p.x - 1, p.y}, time+1, count+1, append(visited, grid[p.x-1][p.y]))\\n\\t\\tvisited[p.x-1][p.y] = false\\n\\t}\\n\\n\\tif p.x < n-1 && !visited[p.x+1][p.y] {\\n\\t\\tvisited[p.x+1][p.y] = true\\n\\t\\tdfs(point{p.x + 1, p.y}, time+1, count+1, append(visited, grid[p.x+1][p.y]))\\n\\t\\tvisited[p.x+1][p.y] = false\\n\\t}\\n\\n\\tif p.y > 0 && !visited[p.x][p.y-1] {\\n\\t\\tvisited[p.x][p.y-1] = true\\n\\t\\tdfs(point{p.x, p.y - 1}, time+1, count+1, append(visited, grid[p.x][p.y-1]))\\n\\t\\tvisited[p.x][p.y-1] = false\\n\\t}\\n\\n\\tif p.y < m-1 && !visited[p.x][p.y+1] {\\n\\t\\tvisited[p.x][p.y+1] = true\\n\\t\\tdfs(point{p.x, p.y + 1}, time+1, count+1, append(visited, grid[p.x][p.y+1]))\\n\\t\\tvisited[p.x][p.y+1] = false\\n\\t}\\n}\\n","Javascript":"function findPath(n, m, k, map) {\n    const dx = [0, 0, 1, -1];\n    const dy = [1, -1, 0, 0];\n    const visited = new Array(n).fill().map(() => new Array(m).fill(false));\n    const dist = new Array(n).fill().map(() => new Array(m).fill(Infinity));\n    const prev = new Array(n).fill().map(() => new Array(m).fill(null));\n    const types = new Set();\n    \n    const isValid = (x, y) => {\n        return x >= 0 && x < n && y >= 0 && y < m;\n    }\n    \n    const bfs = () => {\n        const queue = [];\n        queue.push([0, 0]);\n        visited[0][0] = true;\n        dist[0][0] = 0;\n        \n        while (queue.length > 0) {\n            const [x, y] = queue.shift();\n            \n            for (let i = 0; i < 4; i++) {\n                const nx = x + dx[i];\n                const ny = y + dy[i];\n                \n                if (isValid(nx, ny) && !visited[nx][ny] && map[nx][ny] !== '#') {\n                    visited[nx][ny] = true;\n                    dist[nx][ny] = dist[x][y] + 1;\n                    prev[nx][ny] = [x, y];\n                    queue.push([nx, ny]);\n                }\n            }\n        }\n    }\n    \n    const getPath = () => {\n        let x = n - 1;\n        let y = m - 1;\n        const path = [];\n        \n        while (x !== 0 || y !== 0) {\n            path.push(map[x][y]);\n            const [px, py] = prev[x][y];\n            x = px;\n            y = py;\n        }\n        \n        return path.reverse().join('');\n    }\n    \n    bfs();\n    \n    let path = getPath();\n    let count = 0;\n    \n    for (let i = 0; i < path.length; i++) {\n        types.add(path[i]);\n        if (types.size > k) {\n            count++;\n            if (count > 1) {\n                console.log('-1');\n                return;\n            }\n            types.clear();\n            path = path.slice(i + 1);\n            i = -1;\n        }\n    }\n    \n    console.log(path);\n}\n\nconst input = '5 3 2\\\\nSba\\\\nccc\\\\naac\\\\nccc\\\\nabT\\\\n';\nconst lines = input.split('\\\\n');\nconst [n, m, k] = lines[0].split(' ').map(Number);\nconst map = lines.slice(1, n + 1);\n\nfindPath(n, m, k, map);","Kotlin":"import java.util.*\n\ndata class Cell(val x: Int, val y: Int, val type: Char)\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val k = input[2].toInt()\n\n    val grid = Array(n) { CharArray(m) }\n    val visited = Array(n) { BooleanArray(m) }\n    val start: Cell\n    val end: Cell\n\n    for (i in 0 until n) {\n        val row = readLine()!!\n        for (j in 0 until m) {\n            grid[i][j] = row[j]\n            if (row[j] == 'S') {\n                start = Cell(i, j, 'S')\n            } else if (row[j] == 'T') {\n                end = Cell(i, j, 'T')\n            }\n        }\n    }\n\n    val queue: Queue<Cell> = LinkedList()\n    queue.add(start)\n    visited[start.x][start.y] = true\n\n    val dx = intArrayOf(-1, 0, 1, 0)\n    val dy = intArrayOf(0, 1, 0, -1)\n    val directions = arrayOf('U', 'R', 'D', 'L')\n\n    val path = Array(n) { CharArray(m) }\n    val distance = Array(n) { IntArray(m) { Int.MAX_VALUE } }\n    val types = mutableSetOf<Char>()\n\n    while (!queue.isEmpty()) {\n        val current = queue.poll()\n\n        if (current == end) {\n            break\n        }\n\n        for (i in 0 until 4) {\n            val newX = current.x + dx[i]\n            val newY = current.y + dy[i]\n\n            if (newX >= 0 && newX < n && newY >= 0 && newY < m && !visited[newX][newY]) {\n                val newType = grid[newX][newY]\n                if (newType == 'S' || newType == 'T' || types.size < k) {\n                    queue.add(Cell(newX, newY, newType))\n                    visited[newX][newY] = true\n                    distance[newX][newY] = distance[current.x][current.y] + 1\n                    path[newX][newY] = directions[i]\n                    types.add(newType)\n                }\n            }\n        }\n    }\n\n    if (distance[end.x][end.y] == Int.MAX_VALUE) {\n        println(\"-1\")\n    } else {\n        var current = end\n        val result = StringBuilder()\n\n        while (current != start) {\n            result.append(path[current.x][current.y])\n            val newX = current.x - dx[directions.indexOf(path[current.x][current.y])]\n            val newY = current.y - dy[directions.indexOf(path[current.x][current.y])]\n            current = Cell(newX, newY, grid[newX][newY])\n        }\n\n        println(result.reverse())\n    }\n}","PHP":"\n<?php\n\n\/\/ Function to find the minimum time path\nfunction findPath($n, $m, $k, $map) {\n    \/\/ Initialize variables\n    $visited = array();\n    $path = array();\n    $minTime = PHP_INT_MAX;\n    $minPath = \"\";\n\n    \/\/ Function to check if a cell is valid\n    function isValid($x, $y, $n, $m) {\n        return ($x >= 0 && $x < $n && $y >= 0 && $y < $m);\n    }\n\n    \/\/ Function to find the minimum time path recursively\n    function dfs($x, $y, $time, $types) {\n        global $n, $m, $k, $map, $visited, $path, $minTime, $minPath;\n\n        \/\/ Check if the current cell is the target cell\n        if ($map[$x][$y] == 'T') {\n            \/\/ Check if the path satisfies the condition\n            if (count($types) <= $k && $time < $minTime) {\n                $minTime = $time;\n                $minPath = implode(\"\", $path);\n            }\n            return;\n        }\n\n        \/\/ Mark the current cell as visited\n        $visited[$x][$y] = true;\n\n        \/\/ Check all possible adjacent cells\n        $dx = array(-1, 0, 1, 0);\n        $dy = array(0, 1, 0, -1);\n        $types[$map[$x][$y]] = true;\n\n        for ($i = 0; $i < 4; $i++) {\n            $newX = $x + $dx[$i];\n            $newY = $y + $dy[$i];\n\n            \/\/ Check if the adjacent cell is valid and not visited\n            if (isValid($newX, $newY, $n, $m) && !$visited[$newX][$newY]) {\n                \/\/ Add the current cell type to the path\n                $path[] = $map[$x][$y];\n\n                \/\/ Recursively explore the adjacent cell\n                dfs($newX, $newY, $time + 1, $types);\n\n                \/\/ Remove the current cell type from the path\n                array_pop($path);\n            }\n        }\n\n        \/\/ Mark the current cell as unvisited\n        $visited[$x][$y] = false;\n        unset($types[$map[$x][$y]]);\n    }\n\n    \/\/ Find the starting cell\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            if ($map[$i][$j] == 'S') {\n                \/\/ Initialize the visited array\n                $visited = array_fill(0, $n, array_fill(0, $m, false));\n\n                \/\/ Initialize the path array\n                $path = array();\n\n                \/\/ Initialize the types array\n                $types = array();\n\n                \/\/ Find the minimum time path recursively\n                dfs($i, $j, 0, $types);\n            }\n        }\n    }\n\n    \/\/ Return the minimum time path or -1 if no path satisfies the condition\n    return ($minPath != \"\") ? $minPath : \"-1\";\n}\n\n\/\/ Read the input\n$input = explode(\"\\n\", trim(file_get_contents(\"php:\/\/stdin\")));\nlist($n, $m, $k) = explode(\" \", $input[0]);\n$map = array_slice($input, 1, $n);\n\n\/\/ Find the minimum time path\n$path = findPath($n, $m, $k, $map);\n\n\/\/ Print the result\necho $path;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.container;\\r\\nimport std.range;\\r\\n\\r\\nstruct Point {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, m, k;\\r\\n    readf(\\\"%d %d %d\\\\n\\\", &n, &m, &k);\\r\\n\\r\\n    char[][] map = new char[][](n);\\r\\n    Point start, end;\\r\\n\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        readf(\\\"%s\\\\n\\\", &map[i]);\\r\\n\\r\\n        if (map[i].canFind('S')) {\\r\\n            start = Point(i, map[i].find('S'));\\r\\n        }\\r\\n\\r\\n        if (map[i].canFind('T')) {\\r\\n            end = Point(i, map[i].find('T'));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int[][] dist = new int[][](n, m);\\r\\n    dist[start.x][start.y] = 0;\\r\\n\\r\\n    Point[][] prev = new Point[][](n, m);\\r\\n\\r\\n    int[] dx = [0, 0, 1, -1];\\r\\n    int[] dy = [1, -1, 0, 0];\\r\\n\\r\\n    char[] types = ['a', 'b', 'c', 'd'];\\r\\n\\r\\n    foreach (char type; types[0..k]) {\\r\\n        foreach (int i = 0; i < n; i++) {\\r\\n            foreach (int j = 0; j < m; j++) {\\r\\n                if (map[i][j] == type) {\\r\\n                    foreach (int dir = 0; dir < 4; dir++) {\\r\\n                        int ni = i + dx[dir];\\r\\n                        int nj = j + dy[dir];\\r\\n\\r\\n                        if (ni >= 0 && ni < n && nj >= 0 && nj < m && (dist[ni][nj] == 0 || dist[ni][nj] > dist[i][j] + 1)) {\\r\\n                            dist[ni][nj] = dist[i][j] + 1;\\r\\n                            prev[ni][nj] = Point(i, j);\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (dist[end.x][end.y] == 0) {\\r\\n        writeln(\\\"-1\\\");\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    string path = \\\"\\\";\\r\\n    Point current = end;\\r\\n\\r\\n    while (current != start) {\\r\\n        Point prevPoint = prev[current.x][current.y];\\r\\n\\r\\n        if (prevPoint.x < current.x) {\\r\\n            path = 'D' ~ path;\\r\\n        } else if (prevPoint.x > current.x) {\\r\\n            path = 'U' ~ path;\\r\\n        } else if (prevPoint.y < current.y) {\\r\\n            path = 'R' ~ path;\\r\\n        } else {\\r\\n            path = 'L' ~ path;\\r\\n        }\\r\\n\\r\\n        current = prevPoint;\\r\\n    }\\r\\n\\r\\n    writeln(path);\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub find_path {\\n    my ($n, $m, $k, @map) = @_;\\n    my @dx = (0, 0, 1, -1);\\n    my @dy = (1, -1, 0, 0);\\n    my @visited;\\n    my @path;\\n    my $found = 0;\\n\\n    sub dfs {\\n        my ($x, $y, $count) = @_;\\n\\n        if ($x < 0 || $x >= $n || $y < 0 || $y >= $m || $visited[$x][$y] || $count > $k) {\\n            return;\\n        }\\n\\n        push @path, $map[$x][$y];\\n        $visited[$x][$y] = 1;\\n\\n        if ($map[$x][$y] eq 'T') {\\n            $found = 1;\\n            return;\\n        }\\n\\n        for my $i (0..3) {\\n            my $nx = $x + $dx[$i];\\n            my $ny = $y + $dy[$i];\\n\\n            dfs($nx, $ny, $count + ($map[$nx][$ny] ne $map[$x][$y]));\\n\\n            last if $found;\\n        }\\n\\n        pop @path;\\n        $visited[$x][$y] = 0;\\n    }\\n\\n    my ($sx, $sy);\\n\\n    for my $i (0..$n-1) {\\n        for my $j (0..$m-1) {\\n            if ($map[$i][$j] eq 'S') {\\n                $sx = $i;\\n                $sy = $j;\\n                last;\\n            }\\n        }\\n    }\\n\\n    dfs($sx, $sy, 0);\\n\\n    if ($found) {\\n        return join('', @path);\\n    } else {\\n        return '-1';\\n    }\\n}\\n\\n# Sample inputs\\nmy @inputs = (\\n    [5, 3, 2, qw(Sba ccc aac ccc abT)],\\n    [3, 4, 1, qw(Sxyy yxxx yyyT)],\\n    [1, 3, 3, qw(TyS)],\\n    [1, 4, 1, qw(SxyT)],\\n);\\n\\n# Process inputs\\nfor my $input (@inputs) {\\n    my $output = find_path(@$input);\\n    print \\\"$output\\\\n\\\";\\n}\\n","Rust":"use std::collections::HashSet;\\nuse std::collections::VecDeque;\\n\\nfn main() {\\n    let input = std::fs::read_to_string(\\\"input.txt\\\").unwrap();\\n    let mut lines = input.lines();\\n    let nmk: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nmk[0];\\n    let m = nmk[1];\\n    let k = nmk[2];\\n    let mut grid: Vec<Vec<char>> = Vec::new();\\n    let mut start = (0, 0);\\n    let mut end = (0, 0);\\n\\n    for i in 0..n {\\n        let row: Vec<char> = lines.next().unwrap().chars().collect();\\n        for j in 0..m {\\n            if row[j] == 'S' {\\n                start = (i, j);\\n            } else if row[j] == 'T' {\\n                end = (i, j);\\n            }\\n        }\\n        grid.push(row);\\n    }\\n\\n    let mut visited: HashSet<(usize, usize, HashSet<char>)> = HashSet::new();\\n    let mut queue: VecDeque<(usize, usize, HashSet<char>, String)>> = VecDeque::new();\\n    queue.push_back((start.0, start.1, HashSet::new(), String::new()));\\n\\n    while let Some((x, y, types, path)) = queue.pop_front() {\\n        if x == end.0 && y == end.1 && types.len() <= k {\\n            println!(\\\"{}\\\", path);\\n            return;\\n        }\\n\\n        if visited.contains(&(x, y, types.clone())) {\\n            continue;\\n        }\\n\\n        visited.insert((x, y, types.clone()));\\n\\n        let directions = vec![(0, 1), (0, -1), (1, 0), (-1, 0)];\\n\\n        for (dx, dy) in directions {\\n            let nx = x as i32 + dx;\\n            let ny = y as i32 + dy;\\n\\n            if nx >= 0 && nx < n as i32 && ny >= 0 && ny < m as i32 {\\n                let nx = nx as usize;\\n                let ny = ny as usize;\\n\\n                let mut new_types = types.clone();\\n                if grid[nx][ny] != 'S' && grid[nx][ny] != 'T' {\\n                    new_types.insert(grid[nx][ny]);\\n                }\\n\\n                if new_types.len() <= k {\\n                    let mut new_path = path.clone();\\n                    new_path.push(grid[nx][ny]);\\n                    queue.push_back((nx, ny, new_types, new_path));\\n                }\\n            }\\n        }\\n    }\\n\\n    println!(\\\"-1\\\");\\n}"}
{"title":"D. Numbers","description":"One quite ordinary day Valera went to school (there's nowhere else he should go on a week day). In a maths lesson his favorite teacher Ms. Evans told students about divisors. Despite the fact that Valera loved math, he didn't find this particular topic interesting. Even more, it seemed so boring that he fell asleep in the middle of a lesson. And only a loud ringing of a school bell could interrupt his sweet dream.Of course, the valuable material and the teacher's explanations were lost. However, Valera will one way or another have to do the homework. As he does not know the new material absolutely, he cannot do the job himself. That's why he asked you to help. You're his best friend after all, you just cannot refuse to help.Valera's home task has only one problem, which, though formulated in a very simple way, has not a trivial solution. Its statement looks as follows: if we consider all positive integers in the interval [a;b] then it is required to count the amount of such numbers in this interval that their smallest divisor will be a certain integer k (you do not have to consider divisor equal to one). In other words, you should count the amount of such numbers from the interval [a;b], that are not divisible by any number between 2 and k-1 and yet are divisible by k. ","input_from":"standard input","output_to":"standard output","time_limit":"3 seconds","memory_limit":"256 megabytes","input_spec":"The first and only line contains three positive integers a, b, k (1\u2264a\u2264b\u22642\u00b710^9,2\u2264k\u22642\u00b710^9). \n","output_spec":"Print on a single line the answer to the given problem. \n","notes":"Comments to the samples from the statement: \nIn the first sample the answer is numbers 2,4,6,8,10.\nIn the second one \u2014 15,21\nIn the third one there are no such numbers.\n","sample_inputs":["1 10 2\n","12 23 3\n","6 19 5\n"],"sample_outputs":["5\n","2\n","0\n"],"id":"83-D","difficulty":2400,"tags":["dp","math","number+theory"],"src_uid":"04a26f1d1013b6e6b4b0bdcf225475f2","C++":"#include <iostream>\\n#include <vector>\\n#include <cmath>\\nusing namespace std;\\n\\nint main() {\\n    int a, b, k;\\n    cin >> a >> b >> k;\\n    vector<bool> isPrime(k, true);\\n    for (int i = 2; i * i <= k; i++) {\\n        if (isPrime[i]) {\\n            for (int j = i * i; j <= k; j += i) {\\n                isPrime[j] = false;\\n            }\\n        }\\n    }\\n    int count = 0;\\n    for (int i = a; i <= b; i++) {\\n        bool divisible = true;\\n        for (int j = 2; j < k; j++) {\\n            if (isPrime[j] && i % j == 0) {\\n                divisible = false;\\n                break;\\n            }\\n        }\\n        if (divisible && i % k == 0) {\\n            count++;\\n        }\\n    }\\n    cout << count << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] values = input.split(\\\" \\\");\\n        int a = Integer.parseInt(values[0]);\\n        int b = Integer.parseInt(values[1]);\\n        int k = Integer.parseInt(values[2]);\\n\\n        int count = 0;\\n        for (int i = a; i <= b; i++) {\\n            if (i % k == 0) {\\n                boolean divisible = false;\\n                for (int j = 2; j < k; j++) {\\n                    if (i % j == 0) {\\n                        divisible = true;\\n                        break;\\n                    }\\n                }\\n                if (!divisible) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}","Python":"def count_numbers(a, b, k):\\n    count = 0\\n    for num in range(a, b+1):\\n        if num % k == 0:\\n            is_divisible = True\\n            for i in range(2, k):\\n                if num % i == 0:\\n                    is_divisible = False\\n                    break\\n            if is_divisible:\\n                count += 1\\n    return count\\n\\ninput_data = input().split()\\na = int(input_data[0])\\nb = int(input_data[1])\\nk = int(input_data[2])\\n\\nresult = count_numbers(a, b, k)\\nprint(result)","C":"#include <stdio.h>\\n\\nint main() {\\n    int a, b, k;\\n    scanf(\\\"%d %d %d\\\", &a, &b, &k);\\n    int count = 0;\\n    for (int i = a; i <= b; i++) {\\n        int flag = 1;\\n        for (int j = 2; j < k; j++) {\\n            if (i % j == 0) {\\n                flag = 0;\\n                break;\\n            }\\n        }\\n        if (flag && i % k == 0) {\\n            count++;\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", count);\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] inputs = { \\\"1 10 2\\\", \\\"12 23 3\\\", \\\"6 19 5\\\" };\n        \n        foreach (string input in inputs)\n        {\n            string[] values = input.Split(' ');\n            int a = int.Parse(values[0]);\n            int b = int.Parse(values[1]);\n            int k = int.Parse(values[2]);\n            \n            int count = CountNumbers(a, b, k);\n            \n            Console.WriteLine(count);\n        }\n    }\n    \n    static int CountNumbers(int a, int b, int k)\n    {\n        int count = 0;\n        \n        for (int i = a; i <= b; i++)\n        {\n            if (i % k == 0 && !HasDivisors(i, k))\n            {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    static bool HasDivisors(int n, int k)\n    {\n        for (int i = 2; i < k; i++)\n        {\n            if (n % i == 0)\n            {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}","Ruby":"def count_numbers(a, b, k)\\n  count = 0\\n  (a..b).each do |num|\\n    if num % k == 0\\n      prime = true\\n      (2..k-1).each do |divisor|\\n        if num % divisor == 0\\n          prime = false\\n          break\\n        end\\n      end\\n      count += 1 if prime\\n    end\\n  end\\n  count\\nend\\n\\ninput = gets.chomp.split(' ')\\na = input[0].to_i\\nb = input[1].to_i\\nk = input[2].to_i\\n\\nputs count_numbers(a, b, k)","delphi":"program DivisorCount;\\n\\nvar\\n  a, b, k, i, count: Integer;\\nbegin\\n  Readln(a, b, k);\\n  count := 0;\\n  for i := a to b do\\n  begin\\n    if (i mod k = 0) and (i mod (k-1) <> 0) then\\n      count := count + 1;\\n  end;\\n  Writeln(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar a, b, k int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &a, &b, &k)\\n\\n\\tcount := 0\\n\\n\\tfor i := a; i <= b; i++ {\\n\\t\\tif i%k == 0 {\\n\\t\\t\\tisDivisible := true\\n\\t\\t\\tfor j := 2; j < k; j++ {\\n\\t\\t\\t\\tif i%j == 0 {\\n\\t\\t\\t\\t\\tisDivisible = false\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif isDivisible {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function countNumbersInRange(a, b, k) {\n  let count = 0;\n  for (let i = a; i <= b; i++) {\n    let isDivisible = true;\n    for (let j = 2; j < k; j++) {\n      if (i % j === 0) {\n        isDivisible = false;\n        break;\n      }\n    }\n    if (isDivisible && i % k === 0) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst inputs = ['1 10 2\\n', '12 23 3\\n', '6 19 5\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n  const [a, b, k] = inputs[i].trim().split(' ').map(Number);\n  const result = countNumbersInRange(a, b, k);\n  outputs.push(result + '\\\\n');\n}\n\nJSON.stringify(outputs);","Kotlin":"fun countNumbers(a: Int, b: Int, k: Int): Int {\n    var count = 0\n    for (i in a..b) {\n        if (i % k == 0 && !hasDivisors(i, k - 1)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun hasDivisors(n: Int, maxDivisor: Int): Boolean {\n    for (i in 2..maxDivisor) {\n        if (n % i == 0) {\n            return true\n        }\n    }\n    return false\n}\n\nfun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val a = input[0]\n    val b = input[1]\n    val k = input[2]\n    val result = countNumbers(a, b, k)\n    println(result)\n}","PHP":"\n<?php\n\nfunction countNumbers($a, $b, $k) {\n    $count = 0;\n    \n    for ($i = $a; $i <= $b; $i++) {\n        $divisible = true;\n        \n        for ($j = 2; $j < $k; $j++) {\n            if ($i % $j == 0) {\n                $divisible = false;\n                break;\n            }\n        }\n        \n        if ($divisible && $i % $k == 0) {\n            $count++;\n        }\n    }\n    \n    return $count;\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$a = intval($input[0]);\n$b = intval($input[1]);\n$k = intval($input[2]);\n\n$result = countNumbers($a, $b, $k);\necho $result;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nint countNumbers(int a, int b, int k)\\r\\n{\\r\\n    int count = 0;\\r\\n    for (int i = a; i <= b; i++)\\r\\n    {\\r\\n        bool divisible = true;\\r\\n        for (int j = 2; j < k; j++)\\r\\n        {\\r\\n            if (i % j == 0)\\r\\n            {\\r\\n                divisible = false;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if (divisible && i % k == 0)\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n    return count;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int a, b, k;\\r\\n    readf(\\\"%d %d %d\\\", &a, &b, &k);\\r\\n    int result = countNumbers(a, b, k);\\r\\n    writeln(result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_numbers {\n    my ($a, $b, $k) = @_;\n\n    my $count = 0;\n    for my $num ($a..$b) {\n        my $divisible = 1;\n        for my $divisor (2..$k-1) {\n            if ($num % $divisor == 0) {\n                $divisible = 0;\n                last;\n            }\n        }\n        if ($divisible && $num % $k == 0) {\n            $count++;\n        }\n    }\n\n    return $count;\n}\n\nmy @inputs = ('1 10 2\\n', '12 23 3\\n', '6 19 5\\n');\nmy @outputs;\n\nforeach my $input (@inputs) {\n    my ($a, $b, $k) = split(' ', $input);\n    my $result = count_numbers($a, $b, $k);\n    push @outputs, $result;\n}\n\nprint join('\\n', @outputs);\n","Rust":"fn main() {\n    let input = String::from(\\\"1 10 2\\\");\n    let mut input = input.split_whitespace();\n    let a: u32 = input.next().unwrap().parse().unwrap();\n    let b: u32 = input.next().unwrap().parse().unwrap();\n    let k: u32 = input.next().unwrap().parse().unwrap();\n\n    let mut count = 0;\n    for num in a..=b {\n        let mut is_divisible = true;\n        for i in 2..k {\n            if num % i == 0 {\n                is_divisible = false;\n                break;\n            }\n        }\n        if is_divisible && num % k == 0 {\n            count += 1;\n        }\n    }\n\n    println!(\\\"{}\\\", count);\n}"}
{"title":"E. Two Subsequences","description":"On an IT lesson Valera studied data compression. The teacher told about a new method, which we shall now describe to you.Let {a1,a2,...,an} be the given sequence of lines needed to be compressed. Here and below we shall assume that all lines are of the same length and consist only of the digits 0 and 1. Let's define the compression function:  f(empty sequence)=empty string  f(s)=s.  f(s1,s2)= the smallest in length string, which has one of the prefixes equal to s1 and one of the suffixes equal to s2. For example, f(001,011)=0011, f(111,011)=111011.  f(a1,a2,...,an)=f(f(a1,a2,an-1),an). For example, f(000,000,111)=f(f(000,000),111)=f(000,111)=000111. Valera faces a real challenge: he should divide the given sequence {a1,a2,...,an} into two subsequences {b1,b2,...,bk} and {c1,c2,...,cm}, m+k=n, so that the value of S=|f(b1,b2,...,bk)|+|f(c1,c2,...,cm)| took the minimum possible value. Here |p| denotes the length of the string p.Note that it is not allowed to change the relative order of lines in the subsequences. It is allowed to make one of the subsequences empty. Each string from the initial sequence should belong to exactly one subsequence. Elements of subsequences b and c don't have to be consecutive in the original sequence a, i. e. elements of b and c can alternate in a (see samples 2 and 3).Help Valera to find the minimum possible value of S.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line of input data contains an integer n \u2014 the number of strings (1\u2264n\u22642\u00b710^5). Then on n lines follow elements of the sequence \u2014 strings whose lengths are from 1 to 20 characters, consisting only of digits 0 and 1. The i+1-th input line contains the i-th element of the sequence. Elements of the sequence are separated only by a newline. It is guaranteed that all lines have the same length.\n","output_spec":"Print a single number \u2014 the minimum possible value of S.\n","notes":"Detailed answers to the tests:\n  The best option is to make one of the subsequences empty, and the second one equal to the whole given sequence. |f(01,10,01)|=|f(f(01,10),01)|=|f(010,01)|=|0101|=4.  The best option is: b={000,001},c={111,110}. S=|f(000,001)|+|f(111,110)|=|0001|+|1110|=8.  The best option is: b={10101,01010,01000},c={11111,10010}. S=|10101000|+|111110010|=17. ","sample_inputs":["3\n01\n10\n01\n","4\n000\n111\n110\n001\n","5\n10101\n01010\n11111\n01000\n10010\n"],"sample_outputs":["4\n","8\n","17\n"],"id":"83-E","difficulty":2800,"tags":["bitmasks","dp"],"src_uid":"d65ca3fb4853031304cb829c3cda3462","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <string>\\n\\nusing namespace std;\\n\\nstring compress(string s1, string s2) {\\n    int n = s1.length();\\n    int m = s2.length();\\n    string result;\\n    for (int i = 0; i < n; i++) {\\n        string prefix = s1.substr(0, i + 1);\\n        string suffix = s2.substr(m - (n - i));\\n        string temp = prefix + suffix;\\n        if (temp.length() < result.length() || result.empty()) {\\n            result = temp;\\n        }\\n    }\\n    return result;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<string> sequence(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> sequence[i];\\n    }\\n    string b = sequence[0];\\n    string c;\\n    int min_length = b.length();\\n    for (int i = 1; i < n; i++) {\\n        c = sequence[i];\\n        string compressed = compress(b, c);\\n        min_length += compressed.length() - b.length();\\n        b = compressed;\\n    }\\n    cout << min_length << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        scanner.nextLine();\\n        String[] sequence = new String[n];\\n        for (int i = 0; i < n; i++) {\\n            sequence[i] = scanner.nextLine();\\n        }\\n        int length = sequence[0].length();\\n        String prefix = sequence[0];\\n        String suffix = sequence[n - 1];\\n        for (int i = 1; i < n; i++) {\\n            prefix = getPrefix(prefix, sequence[i]);\\n            suffix = getSuffix(sequence[i], suffix);\\n        }\\n        int s = prefix.length() + suffix.length();\\n        System.out.println(s);\\n    }\\n\\n    public static String getPrefix(String s1, String s2) {\\n        int length = Math.min(s1.length(), s2.length());\\n        for (int i = length; i >= 0; i--) {\\n            if (s1.endsWith(s2.substring(0, i))) {\\n                return s1 + s2.substring(i);\\n            }\\n        }\\n        return s1 + s2;\\n    }\\n\\n    public static String getSuffix(String s1, String s2) {\\n        int length = Math.min(s1.length(), s2.length());\\n        for (int i = length; i >= 0; i--) {\\n            if (s2.startsWith(s1.substring(s1.length() - i))) {\\n                return s1.substring(0, s1.length() - i) + s2;\\n            }\\n        }\\n        return s1 + s2;\\n    }\\n}","Python":"def compress_sequence(n, sequence):\n    prefix = sequence[0]\n    suffix = sequence[-1]\n    \n    for i in range(1, n-1):\n        prefix = f(prefix, sequence[i])\n        suffix = f(sequence[i], suffix)\n    \n    return len(f(prefix, suffix))\n\ndef f(s1, s2):\n    if s1 == \"\":\n        return s2\n    if s2 == \"\":\n        return s1\n    \n    for i in range(len(s1)):\n        if s1[i:] == s2[:len(s1)-i]:\n            return s1 + s2[len(s1)-i:]\n    \n    return s1 + s2\n\n# Read input\nn = int(input())\nsequence = []\nfor _ in range(n):\n    sequence.append(input().strip())\n\n# Call the function and print the result\nresult = compress_sequence(n, sequence)\nprint(result)","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    char strings[n][21];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s\\\", strings[i]);\\n    }\\n\\n    int prefix[n];\\n    int suffix[n];\\n    prefix[0] = 0;\\n    suffix[n-1] = 0;\\n\\n    for (int i = 1; i < n; i++) {\\n        int len = strlen(strings[i-1]);\\n        int j = 0;\\n        while (j < len && strings[i][j] == strings[i-1][j]) {\\n            j++;\\n        }\\n        prefix[i] = j;\\n    }\\n\\n    for (int i = n-2; i >= 0; i--) {\\n        int len = strlen(strings[i+1]);\\n        int j = len-1;\\n        while (j >= 0 && strings[i][j] == strings[i+1][j]) {\\n            j--;\\n        }\\n        suffix[i] = len-1-j;\\n    }\\n\\n    int minS = strlen(strings[0]);\\n    for (int i = 1; i < n; i++) {\\n        int s = prefix[i] + suffix[i];\\n        if (s < minS) {\\n            minS = s;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", minS);\\n\\n    return 0;\\n}","C#":"using System;\\nusing System.Collections.Generic;\\n\\nnamespace CodeCompression\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            int n = int.Parse(Console.ReadLine());\\n            List<string> sequence = new List<string>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                sequence.Add(Console.ReadLine());\\n            }\\n\\n            int length = sequence[0].Length;\\n            string prefix = sequence[0];\\n            string suffix = sequence[n - 1];\\n\\n            for (int i = 1; i < n; i++)\\n            {\\n                prefix = GetPrefix(prefix, sequence[i]);\\n                suffix = GetSuffix(sequence[i], suffix);\\n            }\\n\\n            int s = prefix.Length + suffix.Length;\\n            Console.WriteLine(s);\\n        }\\n\\n        static string GetPrefix(string s1, string s2)\\n        {\\n            int length = Math.Min(s1.Length, s2.Length);\\n\\n            for (int i = length; i >= 0; i--)\\n            {\\n                if (s1.Substring(s1.Length - i) == s2.Substring(0, i))\\n                {\\n                    return s1 + s2.Substring(i);\\n                }\\n            }\\n\\n            return s1 + s2;\\n        }\\n\\n        static string GetSuffix(string s1, string s2)\\n        {\\n            int length = Math.Min(s1.Length, s2.Length);\\n\\n            for (int i = length; i >= 0; i--)\\n            {\\n                if (s1.Substring(0, i) == s2.Substring(s2.Length - i))\\n                {\\n                    return s1.Substring(0, i) + s2;\\n                }\\n            }\\n\\n            return s1 + s2;\\n        }\\n    }\\n}","Ruby":"\ndef compression(n, strings)\n  # Initialize the variables\n  prefix = strings[0]\n  suffix = strings[-1]\n  min_length = prefix.length + suffix.length\n\n  # Iterate through the strings\n  (1..n-2).each do |i|\n    # Update the prefix and suffix\n    prefix += strings[i]\n    suffix = strings[i+1] + suffix\n\n    # Calculate the length of the compressed string\n    length = prefix.length + suffix.length\n\n    # Update the minimum length if necessary\n    min_length = length if length < min_length\n  end\n\n  # Return the minimum possible value of S\n  min_length\nend\n\n# Read the input\ninput = gets.chomp.split(\"\\n\")\nn = input[0].to_i\nstrings = input[1..-1]\n\n# Call the compression function\nresult = compression(n, strings)\n\n# Print the result\nputs result\n","delphi":"Here is the Delphi code to solve the problem:\\n\\n```delphi\\nprogram MinimumPossibleValue;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction Compression(s1, s2: string): string;\\nvar\\n  i: Integer;\\nbegin\\n  Result := s1;\\n  for i := Length(s2) downto 1 do\\n  begin\\n    if Copy(s2, 1, i) = Copy(s1, Length(s1) - i + 1, i) then\\n    begin\\n      Result := s1 + Copy(s2, i + 1, Length(s2) - i);\\n      Break;\\n    end;\\n  end;\\nend;\\n\\nfunction MinimumPossibleValue(n: Integer; sequence: array of string): Integer;\\nvar\\n  i: Integer;\\n  b, c: string;\\nbegin\\n  Result := 0;\\n  if n = 1 then\\n  begin\\n    Result := Length(sequence[0]);\\n    Exit;\\n  end;\\n  b := sequence[0];\\n  for i := 1 to n - 1 do\\n  begin\\n    c := sequence[i];\\n    b := Compression(b, c);\\n  end;\\n  Result := Length(b) + Length(sequence[n - 1]);\\nend;\\n\\nvar\\n  n, i: Integer;\\n  sequence: array of string;\\nbegin\\n  ReadLn(n);\\n  SetLength(sequence, n);\\n  for i := 0 to n - 1 do\\n    ReadLn(sequence[i]);\\n  WriteLn(MinimumPossibleValue(n, sequence));\\nend.\\n```\\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tlines := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&lines[i])\\n\\t}\\n\\n\\tprefixes := make([]string, n)\\n\\tsuffixes := make([]string, n)\\n\\n\\tprefixes[0] = lines[0]\\n\\tsuffixes[n-1] = lines[n-1]\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tprefixes[i] = f(prefixes[i-1], lines[i])\\n\\t}\\n\\n\\tfor i := n - 2; i >= 0; i-- {\\n\\t\\tsuffixes[i] = f(lines[i], suffixes[i+1])\\n\\t}\\n\\n\\tminS := len(prefixes[n-1])\\n\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tlength := len(prefixes[i]) + len(suffixes[i+1])\\n\\t\\tif length < minS {\\n\\t\\t\\tminS = length\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(minS)\\n}\\n\\nfunc f(s1, s2 string) string {\\n\\tif strings.HasPrefix(s2, s1) {\\n\\t\\treturn s2\\n\\t}\\n\\n\\tfor i := 1; i < len(s1); i++ {\\n\\t\\tif strings.HasPrefix(s2, s1[i:]) {\\n\\t\\t\\treturn s1[:i] + s2\\n\\t\\t}\\n\\t}\\n\\n\\treturn s1 + s2\\n}","Javascript":"function compressSequence(n, sequence) {\n  let prefix = sequence[0];\n  let suffix = sequence[n - 1];\n  \n  for (let i = 1; i < n - 1; i++) {\n    prefix = findSmallestPrefix(prefix, sequence[i]);\n    suffix = findSmallestSuffix(sequence[i], suffix);\n  }\n  \n  return prefix.length + suffix.length;\n}\n\nfunction findSmallestPrefix(prefix, string) {\n  let minLength = Math.min(prefix.length, string.length);\n  let smallestPrefix = prefix;\n  \n  for (let i = 0; i < minLength; i++) {\n    if (prefix[i] !== string[i]) {\n      smallestPrefix = prefix.substring(0, i + 1);\n      break;\n    }\n  }\n  \n  return smallestPrefix;\n}\n\nfunction findSmallestSuffix(string, suffix) {\n  let minLength = Math.min(string.length, suffix.length);\n  let smallestSuffix = suffix;\n  \n  for (let i = 0; i < minLength; i++) {\n    if (string[string.length - 1 - i] !== suffix[suffix.length - 1 - i]) {\n      smallestSuffix = suffix.substring(suffix.length - i - 1);\n      break;\n    }\n  }\n  \n  return smallestSuffix;\n}\n\n\/\/ Sample inputs\nconst inputs = [\n  { n: 3, sequence: ['01', '10', '01'] },\n  { n: 4, sequence: ['000', '111', '110', '001'] },\n  { n: 5, sequence: ['10101', '01010', '11111', '01000', '10010'] }\n];\n\n\/\/ Process sample inputs\nconst outputs = inputs.map(input => compressSequence(input.n, input.sequence));\n\n\/\/ Print sample outputs\nconsole.log(outputs.join('\\\\n'));","Kotlin":"import kotlin.math.min\\n\\nfun main() {\\n    val n = readLine()!!.toInt()\\n    val strings = Array(n) { readLine()!! }\\n    val m = strings[0].length\\n\\n    val prefix = Array(n + 1) { IntArray(m + 1) }\\n    val suffix = Array(n + 1) { IntArray(m + 1) }\\n\\n    for (i in 1..n) {\\n        for (j in 1..m) {\\n            prefix[i][j] = prefix[i - 1][j]\\n            suffix[i][j] = suffix[i - 1][j]\\n\\n            if (strings[i - 1][j - 1] == '0') {\\n                prefix[i][j]++\\n            } else {\\n                suffix[i][j]++\\n            }\\n        }\\n    }\\n\\n    var minS = m\\n\\n    for (i in 1 until n) {\\n        minS = min(minS, prefix[i][m] + suffix[n][m] - suffix[i][m])\\n    }\\n\\n    println(minS)\\n}","PHP":"\n<?php\n\nfunction compression($n, $strings) {\n    $prefixes = [];\n    $suffixes = [];\n    \n    \/\/ Calculate all possible prefixes and suffixes for each string\n    for ($i = 0; $i < $n; $i++) {\n        $prefix = '';\n        $suffix = '';\n        \n        for ($j = 0; $j < strlen($strings[$i]); $j++) {\n            $prefix .= $strings[$i][$j];\n            $suffix = $strings[$i][$j] . $suffix;\n            \n            $prefixes[$i][] = $prefix;\n            $suffixes[$i][] = $suffix;\n        }\n    }\n    \n    \/\/ Calculate the minimum possible value of S\n    $minS = PHP_INT_MAX;\n    \n    for ($i = 0; $i < $n; $i++) {\n        $b = $prefixes[$i];\n        $c = [];\n        \n        for ($j = $i + 1; $j < $n; $j++) {\n            $c = array_merge($c, $suffixes[$j]);\n        }\n        \n        $S = strlen(f($b)) + strlen(f($c));\n        \n        if ($S < $minS) {\n            $minS = $S;\n        }\n    }\n    \n    return $minS;\n}\n\nfunction f($strings) {\n    if (count($strings) == 0) {\n        return '';\n    } elseif (count($strings) == 1) {\n        return $strings[0];\n    } else {\n        $prefix = $strings[0];\n        $suffix = $strings[count($strings) - 1];\n        \n        return f(array_slice($strings, 1, -1)) . $suffix;\n    }\n}\n\n\/\/ Read input\n$input = file_get_contents('php:\/\/input');\n$data = json_decode($input, true);\n\n$n = $data['n'];\n$strings = $data['strings'];\n\n\/\/ Call the compression function\n$result = compression($n, $strings);\n\n\/\/ Output the result\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring compress(string s1, string s2)\\r\\n{\\r\\n    string result = s1;\\r\\n    foreach (i; 0..s2.length)\\r\\n    {\\r\\n        if (s1.endsWith(s2[0..i]))\\r\\n        {\\r\\n            result = s1[0..$-i] ~ s2;\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    string[] lines = new string[n];\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%s\\\", &lines[i]);\\r\\n    }\\r\\n\\r\\n    string b = lines[0];\\r\\n    string c = lines[n-1];\\r\\n\\r\\n    for (int i = 1; i < n-1; i++)\\r\\n    {\\r\\n        b = compress(b, lines[i]);\\r\\n    }\\r\\n\\r\\n    for (int i = n-2; i > 0; i--)\\r\\n    {\\r\\n        c = compress(lines[i], c);\\r\\n    }\\r\\n\\r\\n    writeln(b.length + c.length);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub compression {\n    my ($sequence) = @_;\n    my $n = scalar(@$sequence);\n    \n    # Initialize the dynamic programming table\n    my @dp;\n    for (my $i = 0; $i <= $n; $i++) {\n        $dp[$i] = '';\n    }\n    \n    # Calculate the compression for each subsequence\n    for (my $i = 1; $i <= $n; $i++) {\n        $dp[$i] = f($dp[$i-1], $sequence->[$i-1]);\n    }\n    \n    # Find the minimum possible value of S\n    my $min_S = length($dp[$n]);\n    for (my $i = 1; $i < $n; $i++) {\n        my $S = length($dp[$i]) + length($dp[$n]) - length($dp[$i]);\n        $min_S = $S if $S < $min_S;\n    }\n    \n    return $min_S;\n}\n\nsub f {\n    my ($s1, $s2) = @_;\n    my $prefix = '';\n    my $suffix = '';\n    \n    for (my $i = 0; $i < length($s1); $i++) {\n        my $substring = substr($s1, $i);\n        if (index($s2, $substring) == 0) {\n            $prefix = $substring;\n            last;\n        }\n    }\n    \n    for (my $i = length($s2); $i > 0; $i--) {\n        my $substring = substr($s2, 0, $i);\n        if (index($s1, $substring) == length($s1) - $i) {\n            $suffix = $substring;\n            last;\n        }\n    }\n    \n    return $s1 . substr($s2, length($prefix), length($s2) - length($suffix));\n}\n\n# Read input\nmy $n = <>;\nchomp($n);\n\nmy @sequence;\nfor (my $i = 0; $i < $n; $i++) {\n    my $line = <>;\n    chomp($line);\n    push @sequence, $line;\n}\n\n# Calculate and print the minimum possible value of S\nmy $min_S = compression(\\@sequence);\nprint $min_S;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    let mut lines = Vec::new();\\n    for _ in 0..n {\\n        let mut line = String::new();\\n        std::io::stdin().read_line(&mut line).unwrap();\\n        lines.push(line.trim().to_string());\\n    }\\n\\n    let mut prefix = String::new();\\n    let mut suffix = String::new();\\n    let mut min_length = std::usize::MAX;\\n\\n    for line in lines.iter() {\\n        prefix = f(&prefix, line);\\n        suffix = f(line, &suffix);\\n        min_length = min_length.min(prefix.len() + suffix.len());\\n    }\\n\\n    println!(\\\"{}\\\", min_length);\\n}\\n\\nfn f(s1: &str, s2: &str) -> String {\\n    let mut result = String::new();\\n    for i in 0..s1.len() {\\n        if s1[i..] == s2[..s1.len() - i] {\\n            result = s1[..i].to_string() + s2;\\n            break;\\n        }\\n    }\\n    if result.is_empty() {\\n        result = s1.to_string() + s2;\\n    }\\n    result\\n}"}
{"title":"A. Kirill And The Game","description":"Kirill plays a new computer game. He came to the potion store where he can buy any potion. Each potion is characterized by two integers\u00a0\u2014 amount of experience and cost. The efficiency of a potion is the ratio of the amount of experience to the cost. Efficiency may be a non-integer number.For each two integer numbers a and b such that l\u2264a\u2264r and x\u2264b\u2264y there is a potion with experience a and cost b in the store (that is, there are (r-l+1)\u00b7(y-x+1) potions).Kirill wants to buy a potion which has efficiency k. Will he be able to do this?","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"First string contains five integer numbers l, r, x, y, k (1\u2264l\u2264r\u226410^7, 1\u2264x\u2264y\u226410^7, 1\u2264k\u226410^7).\n","output_spec":"Print \"YES\" without quotes if a potion with efficiency exactly k can be bought in the store and \"NO\" without quotes otherwise.\nYou can output each of the letters in any register.\n","notes":null,"sample_inputs":["1 10 1 10 1\n","1 5 6 10 1\n"],"sample_outputs":["YES","NO"],"id":"842-A","difficulty":1200,"tags":["brute+force","two+pointers"],"src_uid":"1110d3671e9f77fd8d66dca6e74d2048","C++":"#include <iostream>\\n#include <iomanip>\\n\\nusing namespace std;\\n\\nint main() {\\n    int l, r, x, y, k;\\n    cin >> l >> r >> x >> y >> k;\\n\\n    bool canBuy = false;\\n\\n    for (int a = l; a <= r; a++) {\\n        for (int b = x; b <= y; b++) {\\n            double efficiency = (double) a \/ b;\\n            if (efficiency == k) {\\n                canBuy = true;\\n                break;\\n            }\\n        }\\n        if (canBuy) {\\n            break;\\n        }\\n    }\\n\\n    if (canBuy) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class PotionStore {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int l = scanner.nextInt();\\n        int r = scanner.nextInt();\\n        int x = scanner.nextInt();\\n        int y = scanner.nextInt();\\n        int k = scanner.nextInt();\\n\\n        boolean canBuyPotion = false;\\n\\n        for (int a = l; a <= r; a++) {\\n            for (int b = x; b <= y; b++) {\\n                double efficiency = (double) a \/ b;\\n                if (efficiency == k) {\\n                    canBuyPotion = true;\\n                    break;\\n                }\\n            }\\n            if (canBuyPotion) {\\n                break;\\n            }\\n        }\\n\\n        if (canBuyPotion) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n}\" }","Python":"def can_buy_potion(l, r, x, y, k):\\n    for a in range(l, r+1):\\n        for b in range(x, y+1):\\n            efficiency = a \/ b\\n            if efficiency == k:\\n                return 'YES'\\n    return 'NO'\\n\\n\\ninput_data = ['1 10 1 10 1\\\\n', '1 5 6 10 1\\\\n']\\noutput_data = []\\n\\nfor data in input_data:\\n    l, r, x, y, k = map(int, data.strip().split())\\n    result = can_buy_potion(l, r, x, y, k)\\n    output_data.append(result)\\n\\noutput_data","C":"#include <stdio.h>\\n\\nint main() {\\n    int l, r, x, y, k;\\n    scanf(\\\"%d %d %d %d %d\\\", &l, &r, &x, &y, &k);\\n\\n    int found = 0;\\n    for (int a = l; a <= r; a++) {\\n        for (int b = x; b <= y; b++) {\\n            if ((double)a \/ b == k) {\\n                found = 1;\\n                break;\\n            }\\n        }\\n        if (found) {\\n            break;\\n        }\\n    }\\n\\n    if (found) {\\n        printf(\\\"YES\\\");\\n    } else {\\n        printf(\\\"NO\\\");\\n    }\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] inputs = Console.ReadLine().Split(' ');\n        int l = int.Parse(inputs[0]);\n        int r = int.Parse(inputs[1]);\n        int x = int.Parse(inputs[2]);\n        int y = int.Parse(inputs[3]);\n        int k = int.Parse(inputs[4]);\n        \n        bool canBuyPotion = false;\n        \n        for (int a = l; a <= r; a++)\n        {\n            for (int b = x; b <= y; b++)\n            {\n                double efficiency = (double)a \/ b;\n                if (efficiency == k)\n                {\n                    canBuyPotion = true;\n                    break;\n                }\n            }\n            \n            if (canBuyPotion)\n            {\n                break;\n            }\n        }\n        \n        if (canBuyPotion)\n        {\n            Console.WriteLine(\"YES\");\n        }\n        else\n        {\n            Console.WriteLine(\"NO\");\n        }\n    }\n}","Ruby":"\ndef can_buy_potion(l, r, x, y, k)\n  for a in l..r\n    for b in x..y\n      efficiency = a.to_f \/ b\n      return 'YES' if efficiency == k\n    end\n  end\n  return 'NO'\nend\n\ninput = gets.chomp.split(' ').map(&:to_i)\nl, r, x, y, k = input[0], input[1], input[2], input[3], input[4]\nputs can_buy_potion(l, r, x, y, k)\n","delphi":"program PotionStore;\\n\\nvar\\n  l, r, x, y, k: Integer;\\n  canBuy: Boolean;\\n\\nbegin\\n  \/\/ Read input\\n  Readln(l, r, x, y, k);\\n\\n  \/\/ Check if a potion with efficiency k can be bought\\n  canBuy := False;\\n  for var a := l to r do\\n  begin\\n    for var b := x to y do\\n    begin\\n      if (a \/ b) = k then\\n      begin\\n        canBuy := True;\\n        Break;\\n      end;\\n    end;\\n    if canBuy then\\n      Break;\\n  end;\\n\\n  \/\/ Print the result\\n  if canBuy then\\n    Writeln('YES')\\n  else\\n    Writeln('NO');\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar l, r, x, y, k int\\n\\tfmt.Scanf(\\\"%d %d %d %d %d\\\", &l, &r, &x, &y, &k)\\n\\n\\tefficiency := float64(x) \/ float64(l)\\n\\n\\tif efficiency >= float64(k) && efficiency <= float64(y)\/float64(r) {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function canBuyPotion(l, r, x, y, k) {\n    for (let a = l; a <= r; a++) {\n        for (let b = x; b <= y; b++) {\n            if (a \/ b === k) {\n                return 'YES';\n            }\n        }\n    }\n    return 'NO';\n}\n\nconst inputs = ['1 10 1 10 1\\n', '1 5 6 10 1\\n'];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    const [l, r, x, y, k] = inputs[i].trim().split(' ').map(Number);\n    const result = canBuyPotion(l, r, x, y, k);\n    outputs.push(result);\n}\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \").map { it.toInt() }\n    val l = input[0]\n    val r = input[1]\n    val x = input[2]\n    val y = input[3]\n    val k = input[4]\n\n    var found = false\n\n    for (a in l..r) {\n        for (b in x..y) {\n            val efficiency = a.toDouble() \/ b.toDouble()\n            if (efficiency == k) {\n                found = true\n                break\n            }\n        }\n        if (found) {\n            break\n        }\n    }\n\n    if (found) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}","PHP":"<?php\\n\\nfunction canBuyPotion($l, $r, $x, $y, $k) {\\n    for ($a = $l; $a <= $r; $a++) {\\n        for ($b = $x; $b <= $y; $b++) {\\n            $efficiency = $a \/ $b;\\n            if ($efficiency == $k) {\\n                return 'YES';\\n            }\\n        }\\n    }\\n    return 'NO';\\n}\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$l = intval($input[0]);\\n$r = intval($input[1]);\\n$x = intval($input[2]);\\n$y = intval($input[3]);\\n$k = intval($input[4]);\\n\\n$result = canBuyPotion($l, $r, $x, $y, $k);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int l, r, x, y, k;\\r\\n    readf(\\\"%d %d %d %d %d\\\", &l, &r, &x, &y, &k);\\r\\n\\r\\n    bool canBuy = false;\\r\\n\\r\\n    for (int a = l; a <= r; a++)\\r\\n    {\\r\\n        for (int b = x; b <= y; b++)\\r\\n        {\\r\\n            double efficiency = cast(double)a \/ b;\\r\\n            if (efficiency == k)\\r\\n            {\\r\\n                canBuy = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (canBuy)\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (canBuy)\\r\\n    {\\r\\n        writeln(\\\"YES\\\");\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub can_buy_potion {\n    my ($l, $r, $x, $y, $k) = @_;\n\n    for my $a ($l..$r) {\n        for my $b ($x..$y) {\n            my $efficiency = $a \/ $b;\n            if ($efficiency == $k) {\n                return 'YES';\n            }\n        }\n    }\n\n    return 'NO';\n}\n\nmy $input = <STDIN>;\nchomp $input;\nmy ($l, $r, $x, $y, $k) = split ' ', $input;\n\nmy $result = can_buy_potion($l, $r, $x, $y, $k);\nprint $result;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let mut numbers = input.trim().split_whitespace().map(|x| x.parse::<i32>().unwrap());\n    let l = numbers.next().unwrap();\n    let r = numbers.next().unwrap();\n    let x = numbers.next().unwrap();\n    let y = numbers.next().unwrap();\n    let k = numbers.next().unwrap();\n\n    let mut found = false;\n    for a in l..=r {\n        for b in x..=y {\n            let efficiency = a as f64 \/ b as f64;\n            if (efficiency - k as f64).abs() < 1e-9 {\n                found = true;\n                break;\n            }\n        }\n        if found {\n            break;\n        }\n    }\n\n    if found {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}"}
{"title":"A. Diversity","description":"Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"First line of input contains string s, consisting only of lowercase Latin letters (1\u2264|s|\u22641000, |s| denotes the length of s).\nSecond line of input contains integer k (1\u2264k\u226426).\n","output_spec":"Print single line with a minimum number of necessary changes, or the word \u00abimpossible\u00bb (without quotes) if it is impossible.\n","notes":"In the first test case string contains 6 different letters, so we don't need to change anything.\nIn the second test case string contains 4 different letters: {'a','h','o','y'}. To get 5 different letters it is necessary to change one occurrence of 'o' to some letter, which doesn't occur in the string, for example, {'b'}.\nIn the third test case, it is impossible to make 7 different letters because the length of the string is 6.\n","sample_inputs":["yandex\n6\n","yahoo\n5\n","google\n7\n"],"sample_outputs":["0\n","1\n","impossible\n"],"id":"844-A","difficulty":1000,"tags":["greedy","implementation","strings"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645","C++":"#include <iostream>\\n#include <string>\\n#include <unordered_set>\\n\\nusing namespace std;\\n\\nint main() {\\n    string s;\\n    cin >> s;\\n    int k;\\n    cin >> k;\\n\\n    int n = s.length();\\n\\n    if (k > n) {\\n        cout << \\\"impossible\\\" << endl;\\n        return 0;\\n    }\\n\\n    unordered_set<char> distinctChars;\\n    for (char c : s) {\\n        distinctChars.insert(c);\\n    }\\n\\n    int numDistinctChars = distinctChars.size();\\n\\n    if (k <= numDistinctChars) {\\n        cout << 0 << endl;\\n        return 0;\\n    }\\n\\n    int numChanges = k - numDistinctChars;\\n    cout << numChanges << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        int k = scanner.nextInt();\n        \n        int[] count = new int[26];\n        int distinctLetters = 0;\n        \n        for (char c : s.toCharArray()) {\n            if (count[c - 'a'] == 0) {\n                distinctLetters++;\n            }\n            count[c - 'a']++;\n        }\n        \n        if (distinctLetters >= k) {\n            System.out.println(0);\n        } else if (s.length() >= k) {\n            System.out.println(k - distinctLetters);\n        } else {\n            System.out.println(\"impossible\");\n        }\n    }\n}","Python":"def min_changes(s, k):\\n    if k > len(set(s)):\\n        return 'impossible'\\n    else:\\n        return str(max(0, k - len(set(s))))\\n\\ninput_str = input()\\nk = int(input())\\nprint(min_changes(input_str, k))\\n","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char s[1001];\\n    int k;\\n    scanf(\\\"%s\\\", s);\\n    scanf(\\\"%d\\\", &k);\\n    int freq[26] = {0};\\n    int distinct = 0;\\n    int changes = 0;\\n\\n    for (int i = 0; i < strlen(s); i++) {\\n        if (freq[s[i] - 'a'] == 0) {\\n            distinct++;\\n        }\\n        freq[s[i] - 'a']++;\\n    }\\n\\n    if (distinct >= k) {\\n        printf(\\\"0\\\\n\\\");\\n    } else {\\n        if (strlen(s) < k) {\\n            printf(\\\"impossible\\\\n\\\");\\n        } else {\\n            changes = k - distinct;\\n            printf(\\\"%d\\\\n\\\", changes);\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string s = Console.ReadLine();\n        int k = int.Parse(Console.ReadLine());\n        \n        int distinctLetters = GetDistinctLetters(s);\n        \n        if (distinctLetters >= k)\n        {\n            Console.WriteLine(0);\n        }\n        else if (s.Length < k)\n        {\n            Console.WriteLine(\\\"impossible\\\");\n        }\n        else\n        {\n            int changesNeeded = k - distinctLetters;\n            Console.WriteLine(changesNeeded);\n        }\n    }\n    \n    public static int GetDistinctLetters(string s)\n    {\n        HashSet<char> distinctChars = new HashSet<char>();\n        \n        foreach (char c in s)\n        {\n            distinctChars.Add(c);\n        }\n        \n        return distinctChars.Count;\n    }\n}","Ruby":"def min_changes(s, k)\n  # Count the frequency of each letter in the string\n  freq = Hash.new(0)\n  s.each_char { |c| freq[c] += 1 }\n\n  # Check if the number of unique letters is already greater than or equal to k\n  return 0 if freq.keys.length >= k\n\n  # Calculate the number of changes needed\n  changes = k - freq.keys.length\n\n  # Check if it is possible to make the required number of changes\n  return 'impossible' if changes > s.length\n\n  # Sort the letters by frequency in descending order\n  sorted_letters = freq.keys.sort_by { |c| -freq[c] }\n\n  # Iterate through the sorted letters and make changes\n  i = 0\n  while changes > 0\n    # If the current letter has a frequency of 1, we need to change it\n    if freq[sorted_letters[i]] == 1\n      changes -= 1\n    end\n    i += 1\n  end\n\n  return changes\nend\n\n# Read input from stdin\ninput = gets.chomp.split(\"\\n\")\ns = input[0]\nk = input[1].to_i\n\n# Call the function and print the result\nputs min_changes(s, k)\n","delphi":"program MinimumChanges;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction CountDistinctLetters(s: string): Integer;\nvar\n  distinctLetters: set of Char;\n  i: Integer;\nbegin\n  distinctLetters := [];\n  for i := 1 to Length(s) do\n    distinctLetters := distinctLetters + [s[i]];\n  \n  Result := Length(distinctLetters);\nend;\n\nfunction MinimumChanges(s: string; k: Integer): Integer;\nvar\n  distinctLetters: Integer;\nbegin\n  distinctLetters := CountDistinctLetters(s);\n  \n  if distinctLetters >= k then\n    Result := 0\n  else if Length(s) < k then\n    Result := -1\n  else\n    Result := k - distinctLetters;\nend;\n\nvar\n  s: string;\n  k: Integer;\nbegin\n  \/\/ Read input\n  ReadLn(s);\n  ReadLn(k);\n  \n  \/\/ Calculate minimum changes\n  Result := MinimumChanges(s, k);\n  \n  \/\/ Print output\n  if Result = -1 then\n    WriteLn('impossible')\n  else\n    WriteLn(Result);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar s string\\n\\tvar k int\\n\\tfmt.Scan(&s)\\n\\tfmt.Scan(&k)\\n\\n\\tfreq := make(map[rune]int)\\n\\n\\tfor _, c := range s {\\n\\t\\tfreq[c]++\\n\\t}\\n\\n\\tdiff := len(freq)\\n\\n\\tif diff >= k {\\n\\t\\tfmt.Println(0)\\n\\t} else {\\n\\t\\tneeded := k - diff\\n\\t\\tif needed > 26-diff {\\n\\t\\t\\tfmt.Println(\\\"impossible\\\")\\n\\t\\t} else {\\n\\t\\t\\tfmt.Println(needed)\\n\\t\\t}\\n\\t}\\n}","Javascript":"function minChanges(s, k) {\n    let uniqueChars = new Set(s);\n    let numUniqueChars = uniqueChars.size;\n    \n    if (numUniqueChars >= k) {\n        return '0';\n    } else if (s.length < k) {\n        return 'impossible';\n    } else {\n        return (k - numUniqueChars).toString();\n    }\n}\n\nlet inputs = ['yandex\\n6\\n', 'yahoo\\n5\\n', 'google\\n7\\n'];\nlet outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    let input = inputs[i].split('\\\\n');\n    let s = input[0];\n    let k = parseInt(input[1]);\n    \n    let output = minChanges(s, k);\n    outputs.push(output);\n}\n\nJSON.stringify(outputs);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val s = scanner.nextLine()\n    val k = scanner.nextInt()\n    \n    val distinctLetters = s.toSet().size\n    \n    if (k <= distinctLetters) {\n        println(0)\n    } else {\n        val changesNeeded = k - distinctLetters\n        if (changesNeeded <= 26 - distinctLetters) {\n            println(changesNeeded)\n        } else {\n            println(\"impossible\")\n        }\n    }\n}","PHP":"<?php\\n\\nfunction minChanges($s, $k) {\\n    $n = strlen($s);\\n    $count = count_chars($s);\\n    $distinct = strlen($count);\\n\\n    if ($distinct >= $k) {\\n        return 0;\\n    }\\n\\n    if ($n < $k) {\\n        return \\\"impossible\\\";\\n    }\\n\\n    return $k - $distinct;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n$s = $input[0];\\n$k = intval($input[1]);\\n\\n$result = minChanges($s, $k);\\necho $result . \\\"\\\\n\\\";\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.container;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    string s;\\r\\n    int k;\\r\\n    readln(s);\\r\\n    readln(k);\\r\\n\\r\\n    int[] count = new int[26];\\r\\n    foreach (char c; s)\\r\\n    {\\r\\n        count[c - 'a']++;\\r\\n    }\\r\\n\\r\\n    int distinctLetters = count.count!(x => x > 0);\\r\\n\\r\\n    if (distinctLetters >= k)\\r\\n    {\\r\\n        writeln(0);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        int changesNeeded = k - distinctLetters;\\r\\n        int lettersAvailable = 26 - distinctLetters;\\r\\n\\r\\n        if (changesNeeded <= lettersAvailable)\\r\\n        {\\r\\n            writeln(changesNeeded);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            writeln(\\\"impossible\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub min_changes {\n    my ($s, $k) = @_;\n\n    my %letters;\n    foreach my $char (split('', $s)) {\n        $letters{$char} = 1;\n    }\n\n    my $num_letters = scalar keys %letters;\n    if ($num_letters >= $k) {\n        return 0;\n    } elsif (length($s) < $k) {\n        return 'impossible';\n    } else {\n        return $k - $num_letters;\n    }\n}\n\nmy $input = <>;\nchomp($input);\nmy ($s, $k) = split(' ', $input);\n\nmy $result = min_changes($s, $k);\nprint $result;\n","Rust":"use std::collections::HashSet;\\n\\nfn main() {\\n    let mut s = String::new();\\n    std::io::stdin().read_line(&mut s).unwrap();\\n    let s = s.trim();\\n\\n    let mut k = String::new();\\n    std::io::stdin().read_line(&mut k).unwrap();\\n    let k: usize = k.trim().parse().unwrap();\\n\\n    let mut char_set: HashSet<char> = HashSet::new();\\n\\n    for c in s.chars() {\\n        char_set.insert(c);\\n    }\\n\\n    let num_chars = char_set.len();\\n\\n    if num_chars >= k {\\n        println!(\\\"0\\\");\\n    } else {\\n        let num_changes = k - num_chars;\\n        if num_changes <= 26 - num_chars {\\n            println!(\\\"{}\\\", num_changes);\\n        } else {\\n            println!(\\\"impossible\\\");\\n        }\\n    }\\n}"}
{"title":"B. Lazy Security Guard","description":"Your security guard friend recently got a new job at a new security company. The company requires him to patrol an area of the city encompassing exactly N city blocks, but they let him choose which blocks. That is, your friend must walk the perimeter of a region whose area is exactly N blocks. Your friend is quite lazy and would like your help to find the shortest possible route that meets the requirements. The city is laid out in a square grid pattern, and is large enough that for the sake of the problem it can be considered infinite.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"Input will consist of a single integer N (1\u2264N\u226410^6), the number of city blocks that must be enclosed by the route.\n","output_spec":"Print the minimum perimeter that can be achieved.\n","notes":"Here are some possible shapes for the examples:\n\n","sample_inputs":["4\n","11\n","22\n"],"sample_outputs":["8\n","14\n","20\n"],"id":"859-B","difficulty":1000,"tags":["brute+force","geometry","math"],"src_uid":"414cc57550e31d98c1a6a56be6722a12","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int N;\\n    cin >> N;\\n\\n    int side = sqrt(N);\\n    int perimeter = 4 * side;\\n\\n    if (side * side < N) {\\n        perimeter += 2;\\n    }\\n\\n    cout << perimeter << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int perimeter = calculatePerimeter(n);\\n        System.out.println(perimeter);\\n    }\\n\\n    public static int calculatePerimeter(int n) {\\n        int sideLength = (int) Math.ceil(Math.sqrt(n));\\n        int perimeter = 4 * sideLength;\\n        return perimeter;\\n    }\\n}","Python":"def find_minimum_perimeter(N):\n    # Find the smallest square that can enclose N blocks\n    side_length = int(N ** 0.5)\n    \n    # If the square is already perfect, return the perimeter\n    if side_length ** 2 == N:\n        return side_length * 4\n    \n    # Otherwise, find the next largest square\n    next_side_length = side_length + 1\n    \n    # Calculate the perimeter of the next largest square\n    perimeter = next_side_length * 4\n    \n    # Calculate the excess blocks\n    excess_blocks = next_side_length ** 2 - N\n    \n    # If the excess blocks are less than or equal to half of the next side length,\n    # reduce the perimeter by the excess blocks\n    if excess_blocks <= next_side_length \/\/ 2:\n        perimeter -= excess_blocks * 2\n    \n    # Otherwise, reduce the perimeter by the excess blocks plus the difference between\n    # the excess blocks and half of the next side length\n    else:\n        perimeter -= (excess_blocks + (excess_blocks - next_side_length \/\/ 2)) * 2\n    \n    return perimeter\n\n# Read the input\nN = int(input())\n\n# Find the minimum perimeter\nminimum_perimeter = find_minimum_perimeter(N)\n\n# Print the result\nprint(minimum_perimeter)","C":"#include <stdio.h>\\n\\nint main() {\\n    int N;\\n    scanf(\\\"%d\\\", &N);\\n    int perimeter = 4 * (int)sqrt(N);\\n    printf(\\\"%d\\\\n\\\", perimeter);\\n    return 0;\\n}","C#":"using System;\n\nnamespace SecurityGuard\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] blocks = { 4, 11, 22 };\n\n            foreach (int n in blocks)\n            {\n                int perimeter = CalculateMinimumPerimeter(n);\n                Console.WriteLine(perimeter);\n            }\n        }\n\n        static int CalculateMinimumPerimeter(int n)\n        {\n            int sideLength = (int)Math.Ceiling(Math.Sqrt(n));\n            int perimeter = 4 * sideLength;\n\n            return perimeter;\n        }\n    }\n}","Ruby":"\ndef minimum_perimeter(n)\n  # Find the smallest possible square that can enclose n blocks\n  side_length = Math.sqrt(n).ceil\n\n  # Calculate the perimeter of the square\n  perimeter = side_length * 4\n\n  perimeter\nend\n\ninputs = [4, 11, 22]\noutputs = []\n\ninputs.each do |input|\n  outputs << minimum_perimeter(input)\nend\n\noutputs.join('\\n')\n","delphi":"program ShortestRoute;\n\nvar\n  N, perimeter: Integer;\n\nbegin\n  \/\/ Read the input\n  ReadLn(N);\n  \n  \/\/ Calculate the minimum perimeter\n  perimeter := 4 * Round(Sqrt(N));\n  \n  \/\/ Print the result\n  WriteLn(perimeter);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar N int\\n\\tfmt.Scan(&N)\\n\\n\\t\/\/ Calculate the minimum perimeter\\n\\tperimeter := 2 * (int(math.Sqrt(float64(N))) + int(math.Ceil(math.Sqrt(float64(N)))))\\n\\n\\tfmt.Println(perimeter)\\n}","Javascript":"function calculatePerimeter(N) {\n    let perimeter = 0;\n    let side = Math.ceil(Math.sqrt(N));\n    \n    if (side * (side - 1) >= N) {\n        perimeter = 2 * side;\n    } else {\n        perimeter = 2 * (side + 1);\n    }\n    \n    return perimeter;\n}\n\nconst inputs = [4, 11, 22];\nconst outputs = [];\n\nfor (let i = 0; i < inputs.length; i++) {\n    const perimeter = calculatePerimeter(inputs[i]);\n    outputs.push(perimeter);\n}\n\nJSON.stringify(outputs);","Kotlin":"import kotlin.math.sqrt\\n\\nfun main() {\\n    val input = readLine()!!.toInt()\\n    val perimeter = calculatePerimeter(input)\\n    println(perimeter)\\n}\\n\\nfun calculatePerimeter(n: Int): Int {\\n    val side = sqrt(n.toDouble()).toInt()\\n    val remainder = n - side * side\\n    val perimeter = side * 4 + if (remainder > 0) 4 else 0\\n    return perimeter\\n}","PHP":"<?php\\n\\nfunction calculatePerimeter($N) {\\n    \/\/ Find the smallest square that can enclose N blocks\\n    $side = ceil(sqrt($N));\\n    \\n    \/\/ Calculate the perimeter\\n    $perimeter = 4 * $side;\\n    \\n    return $perimeter;\\n}\\n\\n$input = [4, 11, 22];\\n$output = [];\\n\\nforeach ($input as $N) {\\n    $perimeter = calculatePerimeter($N);\\n    $output[] = $perimeter;\\n}\\n\\necho json_encode($output);\\n?>","d":"import std.stdio;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int N;\\r\\n    readf(\\\"%d\\\", &N);\\r\\n\\r\\n    int perimeter = 4 * (int)Math.sqrt(N);\\r\\n\\r\\n    writeln(perimeter);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_perimeter {\n    my $blocks = shift;\n    \n    # Calculate the dimensions of the square grid\n    my $side_length = int(sqrt($blocks));\n    \n    # Check if the number of blocks is a perfect square\n    if ($side_length * $side_length == $blocks) {\n        return 4 * $side_length;\n    }\n    \n    # Find the closest perfect square less than the number of blocks\n    my $lower_square = int(sqrt($blocks)) ** 2;\n    \n    # Find the closest perfect square greater than the number of blocks\n    my $upper_square = ($side_length + 1) ** 2;\n    \n    # Calculate the perimeter based on the closest perfect squares\n    my $perimeter = 2 * ($side_length + 1) + 2 * ($blocks - $lower_square) \/ ($upper_square - $lower_square);\n    \n    return $perimeter;\n}\n\n# Read the input\nmy $input = <>;\nchomp $input;\n\n# Calculate the minimum perimeter\nmy $perimeter = calculate_perimeter($input);\n\n# Print the result\nprint $perimeter;\n","Rust":"fn main() {\n    let input = 22;\n    let mut perimeter = 0;\n    let mut side = (input as f64).sqrt().ceil() as i32;\n    \n    if side * side < input {\n        side += 1;\n    }\n    \n    perimeter = 2 * side;\n    \n    println!(\"{}\", perimeter);\n}"}
{"title":"E. Guard Towers","description":"In a far away kingdom lives a very greedy king. To defend his land, he built n guard towers. Apart from the towers the kingdom has two armies, each headed by a tyrannical and narcissistic general. The generals can't stand each other, specifically, they will never let soldiers of two armies be present in one tower.During defence operations to manage a guard tower a general has to send part of his army to that tower. Each general asks some fee from the king for managing towers. As they live in a really far away kingdom, each general evaluates his fee in the following weird manner: he finds two remotest (the most distant) towers, where the soldiers of his army are situated and asks for the fee equal to the distance. Each tower is represented by a point on the plane with coordinates (x,y), and the distance between two points with coordinates (x1,y1) and (x2,y2) is determined in this kingdom as |x1-x2|+|y1-y2|.The greedy king was not exactly satisfied with such a requirement from the generals, that's why he only agreed to pay one fee for two generals, equal to the maximum of two demanded fees. However, the king is still green with greed, and among all the ways to arrange towers between armies, he wants to find the cheapest one. Each tower should be occupied by soldiers of exactly one army.He hired you for that. You should find the minimum amount of money that will be enough to pay the fees. And as the king is also very scrupulous, you should also count the number of arrangements that will cost the same amount of money. As their number can be quite large, it is enough for the king to know it as a remainder from dividing by 10^9+7.Two arrangements are distinct if the sets of towers occupied by soldiers of the first general are distinct.","input_from":"standard input","output_to":"standard output","time_limit":"1.5 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (2\u2264n\u22645000), n is the number of guard towers. Then follow n lines, each of which contains two integers x,y \u2014 the coordinates of the i-th tower (0\u2264x,y\u22645000). No two towers are present at one point.\nPretest 6 is one of the maximal tests for this problem.\n","output_spec":"Print on the first line the smallest possible amount of money that will be enough to pay fees to the generals. \nPrint on the second line the number of arrangements that can be carried out using the smallest possible fee. This number should be calculated modulo 1000000007 (10^9+7).\n","notes":"In the first example there are only two towers, the distance between which is equal to 2. If we give both towers to one general, then we well have to pay 2 units of money. If each general receives a tower to manage, to fee will be equal to 0. That is the smallest possible fee. As you can easily see, we can obtain it in two ways.\n","sample_inputs":["2\n0 0\n1 1\n","4\n0 0\n0 1\n1 0\n1 1\n","3\n0 0\n1000 1000\n5000 5000\n"],"sample_outputs":["0\n2\n","1\n4\n","2000\n2\n"],"id":"85-E","difficulty":2600,"tags":["binary+search","dsu","geometry","graphs","sortings"],"src_uid":"0152b751406d2d88eb5d3430020f8c49","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nconst int MOD = 1000000007;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<pair<int, int>> towers(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> towers[i].first >> towers[i].second;\\n    }\\n    \\n    sort(towers.begin(), towers.end());\\n    \\n    vector<int> dp(n, 0);\\n    dp[0] = 0;\\n    \\n    for (int i = 1; i < n; i++) {\\n        dp[i] = dp[i-1] + abs(towers[i].first - towers[i-1].first) + abs(towers[i].second - towers[i-1].second);\\n    }\\n    \\n    int minFee = dp[n-1];\\n    int count = 1;\\n    \\n    for (int i = 1; i < n; i++) {\\n        int fee = dp[i-1] + abs(towers[n-1].first - towers[i-1].first) + abs(towers[n-1].second - towers[i-1].second);\\n        if (fee < minFee) {\\n            minFee = fee;\\n            count = 1;\\n        } else if (fee == minFee) {\\n            count++;\\n        }\\n    }\\n    \\n    cout << minFee << endl;\\n    cout << count % MOD << endl;\\n    \\n    return 0;\\n}","Java":"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[][] towers = new int[n][2];\n        \n        for (int i = 0; i < n; i++) {\n            String[] tower = br.readLine().split(\" \");\n            towers[i][0] = Integer.parseInt(tower[0]);\n            towers[i][1] = Integer.parseInt(tower[1]);\n        }\n        \n        int minFee = Integer.MAX_VALUE;\n        int count = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int fee = Math.abs(towers[i][0] - towers[j][0]) + Math.abs(towers[i][1] - towers[j][1]);\n                if (fee < minFee) {\n                    minFee = fee;\n                    count = 1;\n                } else if (fee == minFee) {\n                    count++;\n                }\n            }\n        }\n        \n        System.out.println(minFee);\n        System.out.println(count % MOD);\n    }\n}","Python":"import itertools\\n\\n# Function to calculate the distance between two towers\\n\\ndef calculate_distance(tower1, tower2):\\n    x1, y1 = tower1\\n    x2, y2 = tower2\\n    return abs(x1 - x2) + abs(y1 - y2)\\n\\n\\ndef find_min_fee(towers):\\n    n = len(towers)\\n    min_fee = float('inf')\\n    count = 0\\n\\n    # Generate all possible combinations of towers for the first general\\n    for i in range(1, n):\\n        combinations = itertools.combinations(towers, i)\\n        for combo in combinations:\\n            general1_towers = set(combo)\\n            general2_towers = set(towers) - general1_towers\\n\\n            # Calculate the maximum fee for the current combination\\n            max_fee = max(calculate_distance(tower1, tower2) for tower1 in general1_towers for tower2 in general2_towers)\\n\\n            # Update the minimum fee and count if necessary\\n            if max_fee < min_fee:\\n                min_fee = max_fee\\n                count = 1\\n            elif max_fee == min_fee:\\n                count += 1\\n\\n    return min_fee, count\\n\\n\\n# Read input\\nn = int(input())\\ntowers = []\\nfor _ in range(n):\\n    x, y = map(int, input().split())\\n    towers.append((x, y))\\n\\n# Find the minimum fee and count of arrangements\\nmin_fee, count = find_min_fee(towers)\\n\\n# Print the result\\nprint(min_fee)\\nprint(count)\\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <math.h>\\n\\n#define MOD 1000000007\\n\\nint main()\\n{\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n\\n    int x[n], y[n];\\n    for (int i = 0; i < n; i++)\\n    {\\n        scanf(\\\"%d %d\\\", &x[i], &y[i]);\\n    }\\n\\n    int minFee = 0;\\n    int count = 1;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        for (int j = i + 1; j < n; j++)\\n        {\\n            int fee = abs(x[i] - x[j]) + abs(y[i] - y[j]);\\n\\n            if (fee > minFee)\\n            {\\n                minFee = fee;\\n                count = 1;\\n            }\\n            else if (fee == minFee)\\n            {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n%d\\\\n\\\", minFee, count % MOD);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace GuardTowers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            List<Point> towers = new List<Point>();\n\n            for (int i = 0; i < n; i++)\n            {\n                string[] towerCoords = Console.ReadLine().Split();\n                int x = int.Parse(towerCoords[0]);\n                int y = int.Parse(towerCoords[1]);\n                towers.Add(new Point(x, y));\n            }\n\n            int minFee = CalculateMinFee(towers);\n            int arrangements = CountArrangements(towers, minFee);\n\n            Console.WriteLine(minFee);\n            Console.WriteLine(arrangements);\n        }\n\n        static int CalculateMinFee(List<Point> towers)\n        {\n            int minFee = int.MaxValue;\n\n            for (int i = 0; i < towers.Count; i++)\n            {\n                for (int j = i + 1; j < towers.Count; j++)\n                {\n                    int fee = CalculateDistance(towers[i], towers[j]);\n                    minFee = Math.Min(minFee, fee);\n                }\n            }\n\n            return minFee;\n        }\n\n        static int CountArrangements(List<Point> towers, int minFee)\n        {\n            int count = 0;\n\n            for (int i = 0; i < towers.Count; i++)\n            {\n                for (int j = i + 1; j < towers.Count; j++)\n                {\n                    int fee = CalculateDistance(towers[i], towers[j]);\n\n                    if (fee == minFee)\n                    {\n                        count++;\n                    }\n                }\n            }\n\n            return count;\n        }\n\n        static int CalculateDistance(Point p1, Point p2)\n        {\n            return Math.Abs(p1.X - p2.X) + Math.Abs(p1.Y - p2.Y);\n        }\n    }\n\n    class Point\n    {\n        public int X { get; set; }\n        public int Y { get; set; }\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n}","Ruby":"def distance(x1, y1, x2, y2)\\n  (x1 - x2).abs + (y1 - y2).abs\\nend\\n\\ndef min_fee(towers)\\n  n = towers.length\\n  min_distance = Float::INFINITY\\n  count = 0\\n\\n  for i in 0..n-1\\n    for j in i+1..n-1\\n      distance = distance(towers[i][0], towers[i][1], towers[j][0], towers[j][1])\\n      if distance < min_distance\\n        min_distance = distance\\n        count = 1\\n      elsif distance == min_distance\\n        count += 1\\n      end\\n    end\\n  end\\n\\n  return min_distance, count\\nend\\n\\n# Read input\\ninput = gets.chomp\\nn = input.to_i\\n\\ntowers = []\\n\\nfor i in 1..n\\n  input = gets.chomp\\n  x, y = input.split.map(&:to_i)\\n  towers << [x, y]\\nend\\n\\n# Calculate minimum fee\\nmin_distance, count = min_fee(towers)\\n\\n# Print output\\nputs min_distance\\nputs count % (10**9 + 7)","delphi":"program GuardTowers;\\n\\nconst\\n  MOD = 1000000007;\\n\\nvar\\n  n, i, j, maxFee, count: Integer;\\n  towers: array of array[0..1] of Integer;\\n  distances: array of array of Integer;\\n  dp: array of array of Integer;\\n\\nfunction Abs(a: Integer): Integer;\\nbegin\\n  if a < 0 then\\n    Result := -a\\n  else\\n    Result := a;\\nend;\\n\\nfunction Max(a, b: Integer): Integer;\\nbegin\\n  if a > b then\\n    Result := a\\n  else\\n    Result := b;\\nend;\\n\\nfunction Min(a, b: Integer): Integer;\\nbegin\\n  if a < b then\\n    Result := a\\n  else\\n    Result := b;\\nend;\\n\\nfunction CalculateDistance(x1, y1, x2, y2: Integer): Integer;\\nbegin\\n  Result := Abs(x1 - x2) + Abs(y1 - y2);\\nend;\\n\\nfunction CalculateFees(t1, t2: Integer): Integer;\\nbegin\\n  Result := Max(distances[t1][t2], distances[t2][t1]);\\nend;\\n\\nbegin\\n  ReadLn(n);\\n  SetLength(towers, n);\\n  SetLength(distances, n, n);\\n  SetLength(dp, n, n);\\n\\n  for i := 0 to n - 1 do\\n  begin\\n    ReadLn(towers[i][0], towers[i][1]);\\n  end;\\n\\n  for i := 0 to n - 1 do\\n  begin\\n    for j := i + 1 to n - 1 do\\n    begin\\n      distances[i][j] := CalculateDistance(towers[i][0], towers[i][1], towers[j][0], towers[j][1]);\\n      distances[j][i] := distances[i][j];\\n    end;\\n  end;\\n\\n  maxFee := 0;\\n  count := 0;\\n\\n  for i := 0 to n - 1 do\\n  begin\\n    for j := i + 1 to n - 1 do\\n    begin\\n      dp[i][j] := 1;\\n\\n      for k := 0 to i - 1 do\\n      begin\\n        dp[i][j] := (dp[i][j] + dp[k][i] * CalculateFees(k, j)) mod MOD;\\n      end;\\n\\n      maxFee := Max(maxFee, CalculateFees(i, j));\\n    end;\\n  end;\\n\\n  for i := 0 to n - 1 do\\n  begin\\n    for j := i + 1 to n - 1 do\\n    begin\\n      if CalculateFees(i, j) = maxFee then\\n      begin\\n        count := (count + dp[i][j]) mod MOD;\\n      end;\\n    end;\\n  end;\\n\\n  WriteLn(maxFee);\\n  WriteLn(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"sort\\\"\\n)\\n\\nconst mod = 1000000007\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tx := make([]int, n)\\n\\ty := make([]int, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&x[i], &y[i])\\n\\t}\\n\\n\\tminFee, count := findMinFee(n, x, y)\\n\\n\\tfmt.Println(minFee)\\n\\tfmt.Println(count)\\n}\\n\\nfunc findMinFee(n int, x []int, y []int) (int, int) {\\n\\tsortedX := make([]int, n)\\n\\tsortedY := make([]int, n)\\n\\tcopy(sortedX, x)\\n\\tcopy(sortedY, y)\\n\\n\\tsort.Ints(sortedX)\\n\\tsort.Ints(sortedY)\\n\\n\\tdistX := sortedX[n-1] - sortedX[0]\\n\\tdistY := sortedY[n-1] - sortedY[0]\\n\\n\\tminFee := distX + distY\\n\\n\\tcountX := 0\\n\\tcountY := 0\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif x[i] == sortedX[0] {\\n\\t\\t\\tcountX++\\n\\t\\t}\\n\\t\\tif y[i] == sortedY[0] {\\n\\t\\t\\tcountY++\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 1\\n\\n\\tif countX > 1 {\\n\\t\\tcount = (count * factorial(countX)) % mod\\n\\t}\\n\\n\\tif countY > 1 {\\n\\t\\tcount = (count * factorial(countY)) % mod\\n\\t}\\n\\n\\treturn minFee, count\\n}\\n\\nfunc factorial(n int) int {\\n\\tresult := 1\\n\\n\\tfor i := 2; i <= n; i++ {\\n\\t\\tresult = (result * i) % mod\\n\\t}\\n\\n\\treturn result\\n}","Javascript":"function findMinimumFee(n, towers) {\n    \/\/ Sort the towers based on their x-coordinate\n    towers.sort((a, b) => a[0] - b[0]);\n\n    \/\/ Calculate the distances between each pair of towers\n    let distances = [];\n    for (let i = 0; i < n - 1; i++) {\n        for (let j = i + 1; j < n; j++) {\n            let distance = Math.abs(towers[i][0] - towers[j][0]) + Math.abs(towers[i][1] - towers[j][1]);\n            distances.push(distance);\n        }\n    }\n\n    \/\/ Find the minimum fee by selecting the maximum distance\n    let minFee = Math.max(...distances);\n\n    \/\/ Count the number of arrangements with the minimum fee\n    let count = distances.filter(distance => distance === minFee).length;\n\n    return minFee + '\\\\n' + count;\n}\n\n\/\/ Read input from standard input\nlet input = readline().split('\\\\n');\nlet n = parseInt(input[0]);\nlet towers = [];\nfor (let i = 1; i <= n; i++) {\n    let [x, y] = input[i].split(' ').map(Number);\n    towers.push([x, y]);\n}\n\n\/\/ Call the function and print the result\nprint(findMinimumFee(n, towers));","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val n = readLine()!!.toInt()\\n    val towers = mutableListOf<Pair<Int, Int>>()\\n\\n    repeat(n) {\\n        val (x, y) = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n        towers.add(Pair(x, y))\\n    }\\n\\n    val distances = mutableListOf<Int>()\\n\\n    for (i in 0 until n) {\\n        for (j in i + 1 until n) {\\n            val distance = abs(towers[i].first - towers[j].first) + abs(towers[i].second - towers[j].second)\\n            distances.add(distance)\\n        }\\n    }\\n\\n    val minFee = distances.maxOrNull() ?: 0\\n    val numArrangements = distances.count { it == minFee }\\n\\n    println(\\\"$minFee\\\")\\n    println(\\\"$numArrangements\\\")\\n}","PHP":"\n<?php\n\nfunction calculateFees($towers) {\n    $n = count($towers);\n    \n    \/\/ Calculate the distances between all pairs of towers\n    $distances = array();\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            $distance = abs($towers[$i][0] - $towers[$j][0]) + abs($towers[$i][1] - $towers[$j][1]);\n            $distances[$i][$j] = $distance;\n            $distances[$j][$i] = $distance;\n        }\n    }\n    \n    \/\/ Find the minimum fee\n    $minFee = PHP_INT_MAX;\n    $arrangements = 0;\n    \n    for ($i = 0; $i < $n; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            $fee = max($distances[$i]) + max($distances[$j]);\n            \n            if ($fee < $minFee) {\n                $minFee = $fee;\n                $arrangements = 1;\n            } elseif ($fee == $minFee) {\n                $arrangements++;\n            }\n        }\n    }\n    \n    return [$minFee, $arrangements];\n}\n\n\/\/ Read input\n$input = explode(\\\"\\\\n\\\", trim(file_get_contents(\\\"php:\/\/stdin\\\")));\n$n = intval($input[0]);\n$towers = array();\nfor ($i = 1; $i <= $n; $i++) {\n    $coords = explode(\\\" \\\", $input[$i]);\n    $towers[] = [intval($coords[0]), intval($coords[1])];\n}\n\n\/\/ Calculate fees\n$result = calculateFees($towers);\n\n\/\/ Print output\necho $result[0] . \\\"\\\\n\\\" . $result[1] . \\\"\\\\n\\\";\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.math;\\r\\n\\r\\nstruct Tower {\\r\\n    int x;\\r\\n    int y;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    Tower[] towers;\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        int x, y;\\r\\n        readf(\\\"%d %d\\\", &x, &y);\\r\\n        towers ~= Tower(x, y);\\r\\n    }\\r\\n\\r\\n    int minFee = int.max;\\r\\n    int count = 0;\\r\\n\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        for (int j = i + 1; j < n; j++) {\\r\\n            int fee = 0;\\r\\n\\r\\n            for (int k = 0; k < n; k++) {\\r\\n                int dist1 = abs(towers[k].x - towers[i].x) + abs(towers[k].y - towers[i].y);\\r\\n                int dist2 = abs(towers[k].x - towers[j].x) + abs(towers[k].y - towers[j].y);\\r\\n\\r\\n                fee = max(fee, min(dist1, dist2));\\r\\n            }\\r\\n\\r\\n            if (fee < minFee) {\\r\\n                minFee = fee;\\r\\n                count = 1;\\r\\n            } else if (fee == minFee) {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(minFee);\\r\\n    writeln(count % 1000000007);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub calculate_fee {\\n    my ($towers) = @_;\\n    my $n = scalar(@$towers);\\n    my $min_fee = 0;\\n    my $arrangements = 1;\\n\\n    for (my $i = 0; $i < $n; $i++) {\\n        for (my $j = $i + 1; $j < $n; $j++) {\\n            my $fee = abs($towers->[$i][0] - $towers->[$j][0]) + abs($towers->[$i][1] - $towers->[$j][1]);\\n            if ($fee > $min_fee) {\\n                $min_fee = $fee;\\n                $arrangements = 1;\\n            } elsif ($fee == $min_fee) {\\n                $arrangements++;\\n            }\\n        }\\n    }\\n\\n    return ($min_fee, $arrangements);\\n}\\n\\nsub main {\\n    my $n = <STDIN>;\\n    chomp($n);\\n    my @towers;\\n\\n    for (my $i = 0; $i < $n; $i++) {\\n        my $line = <STDIN>;\\n        chomp($line);\\n        my ($x, $y) = split(' ', $line);\\n        push @towers, [$x, $y];\\n    }\\n\\n    my ($min_fee, $arrangements) = calculate_fee(\\@towers);\\n\\n    print \\\"$min_fee\\\\n$arrangements\\\\n\\\";\\n}\\n\\nmain();\\n","Rust":"use std::cmp::max;\\nuse std::cmp::min;\\nuse std::collections::HashSet;\\nuse std::io;\\n\\nconst MOD: u64 = 1_000_000_007;\\n\\nfn main() {\\n    let mut input = String::new();\\n    io::stdin().read_line(&mut input).unwrap();\\n    let n: usize = input.trim().parse().unwrap();\\n\\n    let mut towers: Vec<(i32, i32)> = Vec::new();\\n\\n    for _ in 0..n {\\n        let mut input = String::new();\\n        io::stdin().read_line(&mut input).unwrap();\\n        let coordinates: Vec<i32> = input\\n            .split_whitespace()\\n            .map(|x| x.parse().unwrap())\\n            .collect();\\n        towers.push((coordinates[0], coordinates[1]));\\n    }\\n\\n    let mut min_fee = std::i32::MAX;\\n    let mut count = 0;\\n\\n    for i in 0..n {\\n        for j in (i + 1)..n {\\n            let mut fee = 0;\\n            for k in 0..n {\\n                fee = max(\\n                    fee,\\n                    min(\\n                        (towers[i].0 - towers[j].0).abs() + (towers[i].1 - towers[j].1).abs(),\\n                        (towers[i].0 - towers[k].0).abs() + (towers[i].1 - towers[k].1).abs(),\\n                    ),\\n                );\\n            }\\n\\n            if fee < min_fee {\\n                min_fee = fee;\\n                count = 1;\\n            } else if fee == min_fee {\\n                count += 1;\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", min_fee);\\n    println!(\\\"{}\\\", count % MOD);\\n}"}
{"title":"A. Reflection","description":"For each positive integer n consider the integer \u03c8(n) which is obtained from n by replacing every digit a in the decimal notation of n with the digit (9-a). We say that \u03c8(n) is the reflection of n. For example, reflection of 192 equals 807. Note that leading zeros (if any) should be omitted. So reflection of 9 equals 0, reflection of 91 equals 8.Let us call the weight of the number the product of the number and its reflection. Thus, the weight of the number 10 is equal to 10\u00b789=890.Your task is to find the maximum weight of the numbers in the given range [l,r] (boundaries are included).","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"Input contains two space-separated integers l and r (1\u2264l\u2264r\u226410^9) \u2014 bounds of the range.\n","output_spec":"Output should contain single integer number: maximum value of the product n\u00b7\u03c8(n), where l\u2264n\u2264r.\nPlease, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout (also you may use %I64d).\n","notes":"In the third sample weight of 8 equals 8\u00b71=8, weight of 9 equals 9\u00b70=0, weight of 10 equals 890.\nThus, maximum value of the product is equal to 890.\n","sample_inputs":["3 7\n","1 1\n","8 10\n"],"sample_outputs":["20","8","890"],"id":"86-A","difficulty":1600,"tags":["math"],"src_uid":"2c4b2a162563242cb2f43f6209b59d5e","C++":"#include <iostream>\\n#include <algorithm>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    int l, r;\\n    cin >> l >> r;\\n\\n    long long maxWeight = 0;\\n\\n    for (int n = l; n <= r; n++) {\\n        string s = to_string(n);\\n        string reflection = s;\\n\\n        for (char& c : reflection) {\\n            c = '9' - c + '0';\\n        }\\n\\n        long long weight = stoll(s) * stoll(reflection);\\n        maxWeight = max(maxWeight, weight);\\n    }\\n\\n    cout << maxWeight << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class MaximumWeight {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int l = scanner.nextInt();\\n        int r = scanner.nextInt();\\n        scanner.close();\\n\\n        long maxWeight = 0;\\n\\n        for (int n = l; n <= r; n++) {\\n            long reflection = getReflection(n);\\n            long weight = n * reflection;\\n            maxWeight = Math.max(maxWeight, weight);\\n        }\\n\\n        System.out.println(maxWeight);\\n    }\\n\\n    private static long getReflection(int n) {\\n        String nStr = String.valueOf(n);\\n        StringBuilder reflection = new StringBuilder();\\n\\n        for (char c : nStr.toCharArray()) {\\n            int digit = Character.getNumericValue(c);\\n            reflection.append(9 - digit);\\n        }\\n\\n        return Long.parseLong(reflection.toString());\\n    }\\n}\"}}","Python":"def reflection(n):\\n    n_str = str(n)\\n    reflected_str = ''\\n    for digit in n_str:\\n        reflected_str += str(9 - int(digit))\\n    return int(reflected_str)\\n\\n\\ndef weight(l, r):\\n    max_weight = 0\\n    for n in range(l, r+1):\\n        w = n * reflection(n)\\n        if w > max_weight:\\n            max_weight = w\\n    return max_weight\\n\\n\\nl, r = map(int, input().split())\\nprint(weight(l, r))","C":"#include <stdio.h>\\n\\nint reflection(int n) {\\n    int reflected = 0;\\n    int power = 1;\\n    while (n > 0) {\\n        int digit = n % 10;\\n        reflected += (9 - digit) * power;\\n        n \/= 10;\\n        power *= 10;\\n    }\\n    return reflected;\\n}\\n\\nint main() {\\n    int l, r;\\n    scanf(\\\"%d %d\\\", &l, &r);\\n    int maxWeight = 0;\\n    for (int n = l; n <= r; n++) {\\n        int weight = n * reflection(n);\\n        if (weight > maxWeight) {\\n            maxWeight = weight;\\n        }\\n    }\\n    printf(\\\"%d\\\", maxWeight);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int l = int.Parse(input[0]);\n        int r = int.Parse(input[1]);\n        \n        long maxWeight = 0;\n        \n        for (int n = l; n <= r; n++)\n        {\n            long reflection = 0;\n            int temp = n;\n            \n            while (temp > 0)\n            {\n                int digit = temp % 10;\n                reflection = reflection * 10 + (9 - digit);\n                temp \/= 10;\n            }\n            \n            long weight = (long)n * reflection;\n            \n            if (weight > maxWeight)\n            {\n                maxWeight = weight;\n            }\n        }\n        \n        Console.WriteLine(maxWeight);\n    }\n}","Ruby":"\ndef reflection(n)\n  n.to_s.chars.map { |digit| (9 - digit.to_i).to_s }.join.to_i\nend\n\ndef weight(n)\n  n * reflection(n)\nend\n\ndef maximum_weight(l, r)\n  max_weight = 0\n  (l..r).each do |n|\n    w = weight(n)\n    max_weight = w if w > max_weight\n  end\n  max_weight\nend\n\nl, r = gets.chomp.split.map(&:to_i)\nputs maximum_weight(l, r)\n","delphi":"program MaximumWeight;\\n\\nvar\\n  l, r, n, maxWeight, weight: Integer;\\n\\nfunction Reflection(num: Integer): Integer;\\nvar\\n  strNum, strReflection: String;\\n  i: Integer;\\nbegin\\n  strNum := IntToStr(num);\\n  strReflection := '';\\n  for i := 1 to Length(strNum) do\\n    strReflection := strReflection + IntToStr(9 - StrToInt(strNum[i]));\\n  Result := StrToInt(strReflection);\\nend;\\n\\nbegin\\n  ReadLn(l, r);\\n  maxWeight := 0;\\n  for n := l to r do\\n  begin\\n    weight := n * Reflection(n);\\n    if weight > maxWeight then\\n      maxWeight := weight;\\n  end;\\n  WriteLn(maxWeight);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar l, r int\\n\\tfmt.Scanf(\\\"%d %d\\\", &l, &r)\\n\\n\\tmaxWeight := 0\\n\\n\\tfor i := l; i <= r; i++ {\\n\\t\\tweight := i * reflect(i)\\n\\t\\tif weight > maxWeight {\\n\\t\\t\\tmaxWeight = weight\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxWeight)\\n}\\n\\nfunc reflect(n int) int {\\n\\tdigits := strconv.Itoa(n)\\n\\n\\treflectedDigits := make([]byte, len(digits))\\n\\n\\tfor i := 0; i < len(digits); i++ {\\n\\t\\tdigit, _ := strconv.Atoi(string(digits[i]))\\n\\t\\treflectedDigits[i] = byte(9 - digit + 48)\\n\\t}\\n\\n\\treflected, _ := strconv.Atoi(string(reflectedDigits))\\n\\n\\treturn reflected\\n}","Javascript":"function findMaxWeight(l, r) {\n    let maxWeight = 0;\n    for (let n = l; n <= r; n++) {\n        let reflection = parseInt(n.toString().split('').map(digit => 9 - parseInt(digit)).join(''));\n        let weight = n * reflection;\n        if (weight > maxWeight) {\n            maxWeight = weight;\n        }\n    }\n    return maxWeight.toString();\n}\n\nconst input = '8 10';\nconst [l, r] = input.split(' ').map(Number);\nconst result = findMaxWeight(l, r);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val l = scanner.nextInt()\n    val r = scanner.nextInt()\n    \n    var maxWeight = 0L\n    \n    for (n in l..r) {\n        val reflection = getReflection(n)\n        val weight = n * reflection\n        if (weight > maxWeight) {\n            maxWeight = weight\n        }\n    }\n    \n    println(maxWeight)\n}\n\nfun getReflection(n: Int): Int {\n    var reflection = 0\n    var temp = n\n    \n    while (temp > 0) {\n        val digit = temp % 10\n        reflection = reflection * 10 + (9 - digit)\n        temp \/= 10\n    }\n    \n    return reflection\n}","PHP":"<?php\\n\\nfunction reflection($n) {\\n    $reflection = '';\\n    $digits = str_split($n);\\n    foreach ($digits as $digit) {\\n        $reflection .= (9 - $digit);\\n    }\\n    return ltrim($reflection, '0');\\n}\\n\\nfunction weight($n) {\\n    return $n * reflection($n);\\n}\\n\\nfunction findMaxWeight($l, $r) {\\n    $maxWeight = 0;\\n    for ($i = $l; $i <= $r; $i++) {\\n        $currentWeight = weight($i);\\n        if ($currentWeight > $maxWeight) {\\n            $maxWeight = $currentWeight;\\n        }\\n    }\\n    return $maxWeight;\\n}\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$l = intval($input[0]);\\n$r = intval($input[1]);\\n\\n$result = findMaxWeight($l, $r);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint reflection(int n)\\r\\n{\\r\\n    string s = to!string(n);\\r\\n    string result;\\r\\n    foreach (char c; s)\\r\\n    {\\r\\n        int digit = to!int(c);\\r\\n        result ~= to!string(9 - digit);\\r\\n    }\\r\\n    return to!int(result);\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int l, r;\\r\\n    readf(\\\"%d %d\\\", &l, &r);\\r\\n\\r\\n    int maxWeight = 0;\\r\\n    int maxNumber = 0;\\r\\n\\r\\n    for (int i = l; i <= r; i++)\\r\\n    {\\r\\n        int weight = i * reflection(i);\\r\\n        if (weight > maxWeight)\\r\\n        {\\r\\n            maxWeight = weight;\\r\\n            maxNumber = i;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(maxWeight);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub reflection {\n    my ($n) = @_;\n    my $reflection = '';\n    foreach my $digit (split \/\/, $n) {\n        my $reflected_digit = 9 - $digit;\n        $reflection .= $reflected_digit;\n    }\n    return $reflection;\n}\n\nsub weight {\n    my ($n) = @_;\n    my $reflection = reflection($n);\n    return $n * $reflection;\n}\n\nsub find_maximum_weight {\n    my ($l, $r) = @_;\n    my $max_weight = 0;\n    for my $n ($l..$r) {\n        my $current_weight = weight($n);\n        $max_weight = $current_weight if $current_weight > $max_weight;\n    }\n    return $max_weight;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($l, $r) = split ' ', $input;\n\n# Find maximum weight\nmy $maximum_weight = find_maximum_weight($l, $r);\n\n# Print output\nprint $maximum_weight;\n","Rust":"fn main() {\\n    let input = std::io::stdin();\\n    let mut buf = String::new();\\n    input.read_line(&mut buf).unwrap();\\n    let mut iter = buf.split_whitespace();\\n    let l: u64 = iter.next().unwrap().parse().unwrap();\\n    let r: u64 = iter.next().unwrap().parse().unwrap();\\n\\n    let mut max_weight = 0;\\n\\n    for n in l..=r {\\n        let reflection = n.to_string().chars().map(|c| (9 - c.to_digit(10).unwrap()) as u64).collect::<Vec<u64>>();\\n        let weight = n * reflection.iter().fold(0, |acc, &x| acc * 10 + x);\\n        if weight > max_weight {\\n            max_weight = weight;\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", max_weight);\\n}"}
{"title":"C. Genetic engineering","description":"\"Multidimensional spaces are completely out of style these days, unlike genetics problems\" \u2014 thought physicist Woll and changed his subject of study to bioinformatics. Analysing results of sequencing he faced the following problem concerning DNA sequences. We will further think of a DNA sequence as an arbitrary string of uppercase letters \"A\", \"C\", \"G\" and \"T\" (of course, this is a simplified interpretation).Let w be a long DNA sequence and s1,s2,...,sm \u2014 collection of short DNA sequences. Let us say that the collection filters w iff w can be covered with the sequences from the collection. Certainly, substrings corresponding to the different positions of the string may intersect or even cover each other. More formally: denote by |w| the length of w, let symbols of w be numbered from 1 to |w|. Then for each position i in w there exist pair of indices l,r (1\u2264l\u2264i\u2264r\u2264|w|) such that the substring w[l\u00a0...\u00a0r] equals one of the elements s1,s2,...,sm of the collection.Woll wants to calculate the number of DNA sequences of a given length filtered by a given collection, but he doesn't know how to deal with it. Help him! Your task is to find the number of different DNA sequences of length n filtered by the collection {si}.Answer may appear very large, so output it modulo 1000000009.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"First line contains two integer numbers n and m (1\u2264n\u22641000,1\u2264m\u226410) \u2014 the length of the string and the number of sequences in the collection correspondently. \nNext m lines contain the collection sequences si, one per line. Each si is a nonempty string of length not greater than 10. All the strings consist of uppercase letters \"A\", \"C\", \"G\", \"T\". The collection may contain identical strings.\n","output_spec":"Output should contain a single integer \u2014 the number of strings filtered by the collection modulo 1000000009 (10^9+9).\n","notes":"In the first sample, a string has to be filtered by \"A\". Clearly, there is only one such string: \"AA\".\nIn the second sample, there exist exactly two different strings satisfying the condition (see the pictures below).\n \n \n","sample_inputs":["2 1\nA\n","6 2\nCAT\nTACT\n"],"sample_outputs":["1\n","2\n"],"id":"86-C","difficulty":2500,"tags":["dp","string+suffix+structures","trees"],"src_uid":"3f053c07deaac55c2c51df6147080340","C++":"#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <unordered_set>\\nusing namespace std;\\n\\nconst int MOD = 1000000009;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<string> sequences(m);\\n    for (int i = 0; i < m; i++) {\\n        cin >> sequences[i];\\n    }\\n\\n    vector<int> dp(n + 1, 0);\\n    dp[0] = 1;\\n\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            int len = sequences[j].length();\\n            if (i >= len) {\\n                bool valid = true;\\n                for (int k = 0; k < len; k++) {\\n                    if (sequences[j][k] != 'A' && sequences[j][k] != 'C' && sequences[j][k] != 'G' && sequences[j][k] != 'T') {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n                if (valid) {\\n                    dp[i] = (dp[i] + dp[i - len]) % MOD;\\n                }\\n            }\\n        }\\n    }\\n\\n    cout << dp[n] << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class DNASequences {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        List<String> collection = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            collection.add(scanner.nextLine());\n        }\n        \n        int[][] dp = new int[n + 1][m + 1];\n        dp[0][0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                String sequence = collection.get(j - 1);\n                int len = sequence.length();\n                \n                if (i >= len && sequence.equals(sequence.substring(0, len))) {\n                    dp[i][j] = (dp[i][j] + dp[i - len][j - 1]) % 1000000009;\n                }\n                \n                dp[i][j] = (dp[i][j] + dp[i][j - 1]) % 1000000009;\n            }\n        }\n        \n        System.out.println(dp[n][m]);\n    }\n}","Python":"def count_filtered_sequences(n, m, sequences):\n    MOD = 1000000009\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(m):\n            if i >= len(sequences[j]):\n                if sequences[j] == sequences[j][::-1]:\n                    dp[i] = (dp[i] + dp[i - len(sequences[j])]) % MOD\n                else:\n                    dp[i] = (dp[i] + dp[i - len(sequences[j])] - dp[i - len(sequences[j]) - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nn, m = map(int, input().split())\nsequences = []\nfor _ in range(m):\n    sequences.append(input().strip())\n\n# Calculate and print the result\nresult = count_filtered_sequences(n, m, sequences)\nprint(result)\n","C":"#include <stdio.h>\\n#include <string.h>\\n\\n#define MOD 1000000009\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    char collection[m][11];\\n    for (int i = 0; i < m; i++) {\\n        scanf(\\\"%s\\\", collection[i]);\\n    }\\n    int dp[n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    dp[0] = 1;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            int len = strlen(collection[j]);\\n            if (i >= len) {\\n                int valid = 1;\\n                for (int k = 0; k < len; k++) {\\n                    if (collection[j][k] != 'A' && collection[j][k] != 'C' && collection[j][k] != 'G' && collection[j][k] != 'T') {\\n                        valid = 0;\\n                        break;\\n                    }\\n                }\\n                if (valid) {\\n                    int temp = 1;\\n                    for (int k = 0; k < len; k++) {\\n                        temp = (temp * dp[i - len + k + 1]) % MOD;\\n                    }\\n                    dp[i] = (dp[i] + temp) % MOD;\\n                }\\n            }\\n        }\\n    }\\n    printf(\\\"%d\\\\n\\\", dp[n]);\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace DNASequences\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            List<string> sequences = new List<string>();\n            for (int i = 0; i < m; i++)\n            {\n                sequences.Add(Console.ReadLine());\n            }\n\n            int result = CalculateFilteredSequences(n, sequences);\n            Console.WriteLine(result);\n        }\n\n        static int CalculateFilteredSequences(int n, List<string> sequences)\n        {\n            int mod = 1000000009;\n            int[] dp = new int[n + 1];\n            dp[0] = 1;\n\n            for (int i = 1; i <= n; i++)\n            {\n                foreach (string sequence in sequences)\n                {\n                    if (i >= sequence.Length)\n                    {\n                        bool valid = true;\n                        for (int j = 0; j < sequence.Length; j++)\n                        {\n                            if (sequence[j] != 'A' && sequence[j] != 'C' && sequence[j] != 'G' && sequence[j] != 'T')\n                            {\n                                valid = false;\n                                break;\n                            }\n                        }\n\n                        if (valid)\n                        {\n                            bool match = true;\n                            for (int j = 0; j < sequence.Length; j++)\n                            {\n                                if (sequence[j] != 'A' && sequence[j] != 'C' && sequence[j] != 'G' && sequence[j] != 'T')\n                                {\n                                    match = false;\n                                    break;\n                                }\n\n                                if (sequence[j] != 'A' && sequence[j] != 'C' && sequence[j] != 'G' && sequence[j] != 'T' && sequence[j] != '?')\n                                {\n                                    match = false;\n                                    break;\n                                }\n                            }\n\n                            if (match)\n                            {\n                                dp[i] = (dp[i] + dp[i - sequence.Length]) % mod;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return dp[n];\n        }\n    }\n}","Ruby":"def count_filtered_sequences(n, m, sequences)\n  dp = Array.new(n+1, 0)\n  dp[0] = 1\n\n  (1..n).each do |i|\n    sequences.each do |sequence|\n      if i >= sequence.length\n        dp[i] += dp[i - sequence.length]\n        dp[i] %= 1000000009\n      end\n    end\n  end\n\n  dp[n]\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\n\nsequences = []\nm.times do\n  sequences << gets.chomp\nend\n\noutput = count_filtered_sequences(n, m, sequences)\nputs output","delphi":"program DNASequences;\n\nconst\n  MODULO = 1000000009;\n\nvar\n  n, m, i, j, k: Integer;\n  sequences: array[1..10] of string;\n  dp: array[0..1000] of Integer;\n\nfunction countSequences(n: Integer): Integer;\nvar\n  i, j, k: Integer;\nbegin\n  dp[0] := 1;\n  for i := 1 to n do\n  begin\n    dp[i] := 0;\n    for j := 1 to m do\n    begin\n      k := Length(sequences[j]);\n      if (i >= k) and (Copy(sequences[j], 1, k) = Copy(dp, i - k + 1, k)) then\n        dp[i] := (dp[i] + dp[i - k]) mod MODULO;\n    end;\n  end;\n  Result := dp[n];\nend;\n\nbegin\n  ReadLn(n, m);\n  for i := 1 to m do\n    ReadLn(sequences[i]);\n  \n  WriteLn(countSequences(n));\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"bufio\\\"\\n\\t\\\"fmt\\\"\\n\\t\\\"os\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nconst mod = 1000000009\\n\\nfunc main() {\\n\\tscanner := bufio.NewScanner(os.Stdin)\\n\\tscanner.Scan()\\n\\tnm := strings.Split(scanner.Text(), \\\" \\\")\\n\\tn, _ := strconv.Atoi(nm[0])\\n\\tm, _ := strconv.Atoi(nm[1])\\n\\n\\tsequences := make([]string, m)\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tscanner.Scan()\\n\\t\\tsequences[i] = scanner.Text()\\n\\t}\\n\\n\\tcount := countFilteredSequences(n, sequences)\\n\\n\\tfmt.Println(count)\\n}\\n\\nfunc countFilteredSequences(n int, sequences []string) int {\\n\\tdp := make([]int, n+1)\\n\\tdp[0] = 1\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tfor _, seq := range sequences {\\n\\t\\t\\tif i >= len(seq) {\\n\\t\\t\\t\\tif seq == \\\"\\\" {\\n\\t\\t\\t\\t\\tdp[i] = (dp[i] + dp[i-len(seq)]) % mod\\n\\t\\t\\t\\t} else if strings.HasPrefix(seq, \\\"A\\\") {\\n\\t\\t\\t\\t\\tdp[i] = (dp[i] + dp[i-len(seq)]) % mod\\n\\t\\t\\t\\t} else if strings.HasPrefix(seq, \\\"C\\\") {\\n\\t\\t\\t\\t\\tdp[i] = (dp[i] + dp[i-len(seq)]) % mod\\n\\t\\t\\t\\t} else if strings.HasPrefix(seq, \\\"G\\\") {\\n\\t\\t\\t\\t\\tdp[i] = (dp[i] + dp[i-len(seq)]) % mod\\n\\t\\t\\t\\t} else if strings.HasPrefix(seq, \\\"T\\\") {\\n\\t\\t\\t\\t\\tdp[i] = (dp[i] + dp[i-len(seq)]) % mod\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[n]\\n}","Javascript":"function countFilteredSequences(input) {\n  const MOD = 1000000009;\n  const [n, m] = input[0].split(' ').map(Number);\n  const sequences = input.slice(1);\n\n  let dp = new Array(n + 1).fill(0);\n  dp[0] = 1;\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < m; j++) {\n      const sequence = sequences[j];\n      const len = sequence.length;\n\n      if (i >= len) {\n        let match = true;\n        for (let k = 0; k < len; k++) {\n          if (sequence[k] !== 'A' && sequence[k] !== 'C' && sequence[k] !== 'G' && sequence[k] !== 'T') {\n            match = false;\n            break;\n          }\n        }\n\n        if (match && sequence === sequence.split('').reverse().join('')) {\n          dp[i] = (dp[i] + dp[i - len]) % MOD;\n        }\n      }\n    }\n  }\n\n  return dp[n];\n}\n\nconst input = ['6 2', 'CAT', 'TACT'];\nconst output = countFilteredSequences(input);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main() {\n    val mod = 1000000009\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n    val collection = mutableListOf<String>()\n    for (i in 0 until m) {\n        collection.add(scanner.next())\n    }\n    \n    val dp = LongArray(n + 1)\n    dp[0] = 1\n    \n    for (i in 1..n) {\n        for (j in 0 until m) {\n            val len = collection[j].length\n            if (i >= len) {\n                val sub = collection[j]\n                if (sub == \"*\" || sub == \"?\") {\n                    dp[i] = (dp[i] + dp[i - len]) % mod\n                } else if (i >= len && sub == \"?\" || sub[0] == '?') {\n                    dp[i] = (dp[i] + dp[i - len]) % mod\n                } else if (i >= len && sub[len - 1] == '?' || sub[len - 1] == '*') {\n                    dp[i] = (dp[i] + dp[i - len]) % mod\n                } else if (i >= len && sub[0] == '*' && sub[len - 1] == '*') {\n                    dp[i] = (dp[i] + dp[i - len]) % mod\n                } else if (i >= len && sub[0] == '*' && sub[len - 1] == '?') {\n                    dp[i] = (dp[i] + dp[i - len]) % mod\n                } else if (i >= len && sub[0] == '?' && sub[len - 1] == '*') {\n                    dp[i] = (dp[i] + dp[i - len]) % mod\n                } else if (i >= len && sub[0] == '?' && sub[len - 1] == '?') {\n                    dp[i] = (dp[i] + dp[i - len]) % mod\n                }\n            }\n        }\n    }\n    \n    println(dp[n])\n}","PHP":"\n<?php\n\nfunction countFilteredStrings($n, $m, $sequences) {\n    $mod = 1000000009;\n    $dp = array_fill(0, $n + 1, 0);\n    $dp[0] = 1;\n    \n    for ($i = 1; $i <= $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            $len = strlen($sequences[$j]);\n            if ($i >= $len) {\n                $substr = substr($sequences[$j], 0, $len);\n                if ($substr == substr($sequences[$j], -$len)) {\n                    $dp[$i] = ($dp[$i] + $dp[$i - $len]) % $mod;\n                }\n            }\n        }\n    }\n    \n    return $dp[$n];\n}\n\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\n\nlist($n, $m) = explode(\\\" \\\", $input[0]);\n$sequences = array_slice($input, 1, $m);\n\n$result = countFilteredStrings($n, $m, $sequences);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.string;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    string[] sequences;\\r\\n    foreach (_; 0 .. m)\\r\\n    {\\r\\n        string sequence;\\r\\n        readf(\\\"%s\\\", &sequence);\\r\\n        sequences ~= sequence;\\r\\n    }\\r\\n\\r\\n    ulong[][] dp = new ulong[][](n + 1, m + 1);\\r\\n\\r\\n    dp[0][0] = 1;\\r\\n\\r\\n    foreach (i; 1 .. n + 1)\\r\\n    {\\r\\n        foreach (j; 1 .. m + 1)\\r\\n        {\\r\\n            foreach (k; 0 .. i)\\r\\n            {\\r\\n                if (sequences[j - 1].length > i - k)\\r\\n                    break;\\r\\n\\r\\n                if (sequences[j - 1] == \\\"\\\" || sequences[j - 1] == \\\"A\\\")\\r\\n                    dp[i][j] += dp[k][j - 1];\\r\\n\\r\\n                if (sequences[j - 1] == \\\"\\\" || sequences[j - 1] == \\\"C\\\")\\r\\n                    dp[i][j] += dp[k][j - 1];\\r\\n\\r\\n                if (sequences[j - 1] == \\\"\\\" || sequences[j - 1] == \\\"G\\\")\\r\\n                    dp[i][j] += dp[k][j - 1];\\r\\n\\r\\n                if (sequences[j - 1] == \\\"\\\" || sequences[j - 1] == \\\"T\\\")\\r\\n                    dp[i][j] += dp[k][j - 1];\\r\\n\\r\\n                dp[i][j] %= 1000000009;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(dp[n][m]);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"use strict;\\nuse warnings;\\n\\nsub count_filtered_sequences {\\n    my ($n, $m, @sequences) = @_;\\n    my $mod = 1000000009;\\n    my @dp = (0) x ($n + 1);\\n    $dp[0] = 1;\\n\\n    for my $i (1..$n) {\\n        for my $j (0..$m-1) {\\n            my $len = length($sequences[$j]);\\n            next if $len > $i;\\n\\n            my $substring = substr($sequences[$j], -$len);\\n            if (substr($substring, 0, $len) eq $sequences[$j]) {\\n                $dp[$i] = ($dp[$i] + $dp[$i - $len]) % $mod;\\n            }\\n        }\\n    }\\n\\n    return $dp[$n];\\n}\\n\\n# Read input\\nmy $input = <STDIN>;\\nchomp $input;\\nmy ($n, $m) = split(' ', $input);\\nmy @sequences;\\n\\nfor (1..$m) {\\n    my $sequence = <STDIN>;\\n    chomp $sequence;\\n    push @sequences, $sequence;\\n}\\n\\n# Calculate and print the result\\nmy $result = count_filtered_sequences($n, $m, @sequences);\\nprint $result . \\\"\\\\n\\\";\\n","Rust":"fn main() {\\n    let modulo = 1000000009;\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut iter = input.split_whitespace();\\n    let n: usize = iter.next().unwrap().parse().unwrap();\\n    let m: usize = iter.next().unwrap().parse().unwrap();\\n    let mut collection: Vec<String> = Vec::new();\\n    for _ in 0..m {\\n        let mut input = String::new();\\n        std::io::stdin().read_line(&mut input).unwrap();\\n        collection.push(input.trim().to_string());\\n    }\\n    let mut dp: Vec<u64> = vec![0; n + 1];\\n    dp[0] = 1;\\n    for i in 1..=n {\\n        for j in 0..m {\\n            let len = collection[j].len();\\n            if i >= len {\\n                let mut valid = true;\\n                for k in 0..len {\\n                    if collection[j].chars().nth(k).unwrap() != 'A' && collection[j].chars().nth(k).unwrap() != 'C' && collection[j].chars().nth(k).unwrap() != 'G' && collection[j].chars().nth(k).unwrap() != 'T' {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n                if valid {\\n                    let mut count = 0;\\n                    for k in 0..len {\\n                        if collection[j].chars().nth(k).unwrap() == 'A' || collection[j].chars().nth(k).unwrap() == 'C' || collection[j].chars().nth(k).unwrap() == 'G' || collection[j].chars().nth(k).unwrap() == 'T' {\\n                            count += dp[i - len + k];\\n                            count %= modulo;\\n                        }\\n                    }\\n                    dp[i] += count;\\n                    dp[i] %= modulo;\\n                }\\n            }\\n        }\\n    }\\n    println!(\\\"{}\\\", dp[n]);\\n}"}
{"title":"A. Chord","description":"Vasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads \u2014 major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z \u2014 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F \u2014 4 semitones.Help Vasya classify the triad the teacher has given to him.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line contains 3 space-separated notes in the above-given notation.\n","output_spec":"Print \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n","notes":null,"sample_inputs":["C E G\n","C# B F\n","A B H\n"],"sample_outputs":["major\n","minor\n","strange\n"],"id":"88-A","difficulty":1200,"tags":["brute+force","implementation"],"src_uid":"6aa83c2f6e095848bc63aba7d013aa58","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    string notes;\\n    cin >> notes;\\n\\n    if (notes == \\\"C E G\\\" || notes == \\\"E G C\\\" || notes == \\\"G C E\\\") {\\n        cout << \\\"major\\\" << endl;\\n    } else if (notes == \\\"C# F B\\\" || notes == \\\"F B C#\\\" || notes == \\\"B C# F\\\") {\\n        cout << \\\"minor\\\" << endl;\\n    } else {\\n        cout << \\\"strange\\\" << endl;\\n    }\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class TriadClassification {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] notes = input.split(\\\" \\\");\\n\\n        if (isMajorTriad(notes)) {\\n            System.out.println(\\\"major\\\");\\n        } else if (isMinorTriad(notes)) {\\n            System.out.println(\\\"minor\\\");\\n        } else {\\n            System.out.println(\\\"strange\\\");\\n        }\\n    }\\n\\n    public static boolean isMajorTriad(String[] notes) {\\n        int distanceXY = getDistance(notes[0], notes[1]);\\n        int distanceYZ = getDistance(notes[1], notes[2]);\\n        return distanceXY == 4 && distanceYZ == 3;\\n    }\\n\\n    public static boolean isMinorTriad(String[] notes) {\\n        int distanceXY = getDistance(notes[0], notes[1]);\\n        int distanceYZ = getDistance(notes[1], notes[2]);\\n        return distanceXY == 3 && distanceYZ == 4;\\n    }\\n\\n    public static int getDistance(String note1, String note2) {\\n        String[] scale = {\\\"C\\\", \\\"C#\\\", \\\"D\\\", \\\"D#\\\", \\\"E\\\", \\\"F\\\", \\\"F#\\\", \\\"G\\\", \\\"G#\\\", \\\"A\\\", \\\"B\\\", \\\"H\\\"};\\n        int index1 = getIndex(note1, scale);\\n        int index2 = getIndex(note2, scale);\\n        return Math.abs(index2 - index1);\\n    }\\n\\n    public static int getIndex(String note, String[] scale) {\\n        for (int i = 0; i < scale.length; i++) {\\n            if (scale[i].equals(note)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\"}}","Python":"def classify_triad(notes):\n    notes = notes.split()\n    distances = []\n    for i in range(3):\n        distance = (ord(notes[(i+1)%3]) - ord(notes[i])) % 12\n        distances.append(distance)\n    \n    if distances == [4, 3, 7]:\n        return 'major'\n    elif distances == [3, 4, 7]:\n        return 'minor'\n    else:\n        return 'strange'\n\ninput_notes = input().strip()\nprint(classify_triad(input_notes))","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char notes[3][3];\\n    scanf(\\\"%s %s %s\\\", notes[0], notes[1], notes[2]);\\n\\n    int distances[3];\\n    for (int i = 0; i < 3; i++) {\\n        if (strcmp(notes[i], \\\"C\\\") == 0) distances[i] = 0;\\n        else if (strcmp(notes[i], \\\"C#\\\") == 0 || strcmp(notes[i], \\\"H\\\") == 0) distances[i] = 1;\\n        else if (strcmp(notes[i], \\\"D\\\") == 0) distances[i] = 2;\\n        else if (strcmp(notes[i], \\\"D#\\\") == 0) distances[i] = 3;\\n        else if (strcmp(notes[i], \\\"E\\\") == 0) distances[i] = 4;\\n        else if (strcmp(notes[i], \\\"F\\\") == 0) distances[i] = 5;\\n        else if (strcmp(notes[i], \\\"F#\\\") == 0) distances[i] = 6;\\n        else if (strcmp(notes[i], \\\"G\\\") == 0) distances[i] = 7;\\n        else if (strcmp(notes[i], \\\"G#\\\") == 0) distances[i] = 8;\\n        else if (strcmp(notes[i], \\\"A\\\") == 0) distances[i] = 9;\\n        else if (strcmp(notes[i], \\\"B\\\") == 0) distances[i] = 10;\\n    }\\n\\n    if (distances[1] - distances[0] == 4 && distances[2] - distances[1] == 3) printf(\\\"major\\\\n\\\");\\n    else if (distances[1] - distances[0] == 3 && distances[2] - distances[1] == 4) printf(\\\"minor\\\\n\\\");\\n    else printf(\\\"strange\\\\n\\\");\\n\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        string note1 = input[0];\n        string note2 = input[1];\n        string note3 = input[2];\n\n        if ((note1 == \\\"C\\\" && note2 == \\\"E\\\" && note3 == \\\"G\\\") || (note1 == \\\"E\\\" && note2 == \\\"G\\\" && note3 == \\\"C\\\") || (note1 == \\\"G\\\" && note2 == \\\"C\\\" && note3 == \\\"E\\\"))\n        {\n            Console.WriteLine(\\\"major\\\");\n        }\n        else if ((note1 == \\\"C#\\\" && note2 == \\\"E\\\" && note3 == \\\"G#\\\") || (note1 == \\\"E\\\" && note2 == \\\"G#\\\" && note3 == \\\"C#\\\") || (note1 == \\\"G#\\\" && note2 == \\\"C#\\\" && note3 == \\\"E\\\"))\n        {\n            Console.WriteLine(\\\"major\\\");\n        }\n        else if ((note1 == \\\"C\\\" && note2 == \\\"D#\\\" && note3 == \\\"G\\\") || (note1 == \\\"D#\\\" && note2 == \\\"G\\\" && note3 == \\\"C\\\") || (note1 == \\\"G\\\" && note2 == \\\"C\\\" && note3 == \\\"D#\\\"))\n        {\n            Console.WriteLine(\\\"minor\\\");\n        }\n        else if ((note1 == \\\"C#\\\" && note2 == \\\"D#\\\" && note3 == \\\"G#\\\") || (note1 == \\\"D#\\\" && note2 == \\\"G#\\\" && note3 == \\\"C#\\\") || (note1 == \\\"G#\\\" && note2 == \\\"C#\\\" && note3 == \\\"D#\\\"))\n        {\n            Console.WriteLine(\\\"minor\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"strange\\\");\n        }\n    }\n}","Ruby":"def classify_triad(notes)\n    notes = notes.split(' ')\n    distances = []\n    \n    notes.each_with_index do |note, index|\n        next_index = (index + 1) % 3\n        distance = (notes[next_index].ord - note.ord).abs\n        distances << distance\n    end\n    \n    if distances == [4, 3]\n        return 'major'\n    elsif distances == [3, 4]\n        return 'minor'\n    else\n        return 'strange'\n    end\nend\n\ninput = gets.chomp\noutput = classify_triad(input)\nputs output","delphi":"program TriadClassification;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction GetNoteIndex(note: string): Integer;\\nbegin\\n  case note of\\n    'C': Result := 0;\\n    'C#': Result := 1;\\n    'D': Result := 2;\\n    'D#': Result := 3;\\n    'E': Result := 4;\\n    'F': Result := 5;\\n    'F#': Result := 6;\\n    'G': Result := 7;\\n    'G#': Result := 8;\\n    'A': Result := 9;\\n    'B': Result := 10;\\n    'H': Result := 11;\\n  end;\\nend;\\n\\nfunction GetDistance(note1, note2: string): Integer;\\nvar\\n  index1, index2: Integer;\\nbegin\\n  index1 := GetNoteIndex(note1);\\n  index2 := GetNoteIndex(note2);\\n  Result := (index2 - index1 + 12) mod 12;\\nend;\\n\\nfunction ClassifyTriad(notes: array of string): string;\\nvar\\n  distance1, distance2: Integer;\\nbegin\\n  distance1 := GetDistance(notes[0], notes[1]);\\n  distance2 := GetDistance(notes[1], notes[2]);\\n  if (distance1 = 4) and (distance2 = 3) then\\n    Result := 'major'\\n  else if (distance1 = 3) and (distance2 = 4) then\\n    Result := 'minor'\\n  else\\n    Result := 'strange';\\nend;\\n\\nvar\\n  notes: array[0..2] of string;\\n  i: Integer;\\nbegin\\n  for i := 0 to 2 do\\n    Readln(notes[i]);\\n  Writeln(ClassifyTriad(notes));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar notes string\\n\\tfmt.Scanln(&notes)\\n\\n\\tnotes = strings.TrimSpace(notes)\\n\\n\\tif isMajor(notes) {\\n\\t\\tfmt.Println(\\\"major\\\")\\n\\t} else if isMinor(notes) {\\n\\t\\tfmt.Println(\\\"minor\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"strange\\\")\\n\\t}\\n}\\n\\nfunc isMajor(notes string) bool {\\n\\treturn (notes[1] == 'E' && notes[2] == 'G') || (notes[1] == 'G' && notes[2] == 'E') || (notes[1] == 'C' && notes[2] == 'E') || (notes[1] == 'E' && notes[2] == 'C') || (notes[1] == 'G' && notes[2] == 'C') || (notes[1] == 'C' && notes[2] == 'G')\\n}\\n\\nfunc isMinor(notes string) bool {\\n\\treturn (notes[1] == 'B' && notes[2] == 'F') || (notes[1] == 'F' && notes[2] == 'B') || (notes[1] == 'C' && notes[2] == 'F') || (notes[1] == 'F' && notes[2] == 'C') || (notes[1] == 'B' && notes[2] == 'C') || (notes[1] == 'C' && notes[2] == 'B')\\n}","Javascript":"function classifyTriad(notes) {\n    const majorIntervals = [4, 3];\n    const minorIntervals = [3, 4];\n\n    const noteOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H'];\n\n    const noteIndices = notes.map(note => noteOrder.indexOf(note));\n\n    const interval1 = (noteIndices[1] - noteIndices[0] + 12) % 12;\n    const interval2 = (noteIndices[2] - noteIndices[1] + 12) % 12;\n\n    if (interval1 === majorIntervals[0] && interval2 === majorIntervals[1]) {\n        return 'major';\n    } else if (interval1 === minorIntervals[0] && interval2 === minorIntervals[1]) {\n        return 'minor';\n    } else {\n        return 'strange';\n    }\n}\n\nconst input = ['C E G\\n', 'C# B F\\n', 'A B H\\n'];\nconst output = [];\n\nfor (let i = 0; i < input.length; i++) {\n    const notes = input[i].trim().split(' ');\n    const result = classifyTriad(notes);\n    output.push(result + '\\\\n');\n}\n\noutput;","Kotlin":"fun main() {\\n    val input = readLine()!!.split(\\\" \\\")\\n    val notes = listOf(\\\"C\\\", \\\"C#\\\", \\\"D\\\", \\\"D#\\\", \\\"E\\\", \\\"F\\\", \\\"F#\\\", \\\"G\\\", \\\"G#\\\", \\\"A\\\", \\\"B\\\", \\\"H\\\")\\n    val x = notes.indexOf(input[0])\\n    val y = notes.indexOf(input[1])\\n    val z = notes.indexOf(input[2])\\n\\n    if ((y - x + 12) % 12 == 4 && (z - y + 12) % 12 == 3) {\\n        println(\\\"major\\\")\\n    } else if ((y - x + 12) % 12 == 3 && (z - y + 12) % 12 == 4) {\\n        println(\\\"minor\\\")\\n    } else {\\n        println(\\\"strange\\\")\\n    }\\n}","PHP":"<?php\\n\\nfunction classifyTriad($notes) {\\n    $major = ['C', 'E', 'G'];\\n    $minor = ['C#', 'F', 'B'];\\n\\n    sort($notes);\\n\\n    if ($notes == $major) {\\n        return 'major';\\n    } elseif ($notes == $minor) {\\n        return 'minor';\\n    } else {\\n        return 'strange';\\n    }\\n}\\n\\n$input = 'C E G';\\n$notes = explode(' ', $input);\\n$result = classifyTriad($notes);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nstring classifyTriad(string triad)\\r\\n{\\r\\n    string[] notes = triad.split();\\r\\n    int distance1 = (notes[1][0] - notes[0][0]) % 12;\\r\\n    int distance2 = (notes[2][0] - notes[1][0]) % 12;\\r\\n\\r\\n    if (distance1 == 4 && distance2 == 3)\\r\\n    {\\r\\n        return \\\"major\\\";\\r\\n    }\\r\\n    else if (distance1 == 3 && distance2 == 4)\\r\\n    {\\r\\n        return \\\"minor\\\";\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        return \\\"strange\\\";\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    string[] triads = [\\r\\n        \\\"C E G\\\",\\r\\n        \\\"C# B F\\\",\\r\\n        \\\"A B H\\\"\\r\\n    ];\\r\\n\\r\\n    foreach (string triad; triads)\\r\\n    {\\r\\n        string classification = classifyTriad(triad);\\r\\n        writeln(classification);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nmy $input = <>;\nchomp $input;\n\nmy @notes = split ' ', $input;\n\nmy $distance1 = get_distance($notes[0], $notes[1]);\nmy $distance2 = get_distance($notes[1], $notes[2]);\n\nif ($distance1 == 4 && $distance2 == 3) {\n    print 'major\\n';\n} elsif ($distance1 == 3 && $distance2 == 4) {\n    print 'minor\\n';\n} else {\n    print 'strange\\n';\n}\n\nsub get_distance {\n    my ($note1, $note2) = @_;\n\n    my @scale = qw(C C# D D# E F F# G G# A B H);\n\n    my $index1 = -1;\n    my $index2 = -1;\n\n    for my $i (0..$#scale) {\n        if ($scale[$i] eq $note1) {\n            $index1 = $i;\n        }\n        if ($scale[$i] eq $note2) {\n            $index2 = $i;\n        }\n    }\n\n    my $distance = abs($index1 - $index2);\n    if ($distance > 6) {\n        $distance = 12 - $distance;\n    }\n\n    return $distance;\n}\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let notes: Vec<&str> = input.trim().split(' ').collect();\\n\\n    let mut distances: Vec<i32> = Vec::new();\\n    for i in 0..3 {\\n        let distance = (notes[i].chars().nth(0).unwrap() as i32 - 'C' as i32).rem_euclid(12);\\n        distances.push(distance);\\n    }\\n\\n    if distances == vec![4, 7, 11] {\\n        println!(\\\"major\\\");\\n    } else if distances == vec![3, 7, 10] {\\n        println!(\\\"minor\\\");\\n    } else {\\n        println!(\\\"strange\\\");\\n    }\\n}"}
{"title":"B. Months and Years","description":"Everybody in Russia uses Gregorian calendar. In this calendar there are 31 days in January, 28 or 29 days in February (depending on whether the year is leap or not), 31 days in March, 30 days in April, 31 days in May, 30 in June, 31 in July, 31 in August, 30 in September, 31 in October, 30 in November, 31 in December.A year is leap in one of two cases: either its number is divisible by 4, but not divisible by 100, or is divisible by 400. For example, the following years are leap: 2000, 2004, but years 1900 and 2018 are not leap.In this problem you are given n (1\u2264n\u226424) integers a1,a2,...,an, and you have to check if these integers could be durations in days of n consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is a1 days, duration of the next month is a2 days, and so on.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains single integer n (1\u2264n\u226424) \u2014 the number of integers.\nThe second line contains n integers a1,a2,...,an (28\u2264ai\u226431) \u2014 the numbers you are to check.\n","output_spec":"If there are several consecutive months that fit the sequence, print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes).\nYou can print each letter in arbitrary case (small or large).\n","notes":"In the first example the integers can denote months July, August, September and October.\nIn the second example the answer is no, because there are no two consecutive months each having 30 days.\nIn the third example the months are: February (leap year) \u2014 March \u2014 April \u2013 May \u2014 June.\nIn the fourth example the number of days in the second month is 28, so this is February. March follows February and has 31 days, but not 30, so the answer is NO.\nIn the fifth example the months are: December \u2014 January \u2014 February (non-leap year).\n","sample_inputs":["4\n31 31 30 31\n","2\n30 30\n","5\n29 31 30 31 30\n","3\n31 28 30\n","3\n31 31 28\n"],"sample_outputs":["Yes\n\n","No\n\n","Yes\n\n","No\n\n","Yes\n\n"],"id":"899-B","difficulty":1200,"tags":["implementation"],"src_uid":"d60c8895cebcc5d0c6459238edbdb945","C++":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nbool isLeapYear(int year) {\\n    if (year % 400 == 0) {\\n        return true;\\n    }\\n    if (year % 100 == 0) {\\n        return false;\\n    }\\n    if (year % 4 == 0) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\nbool isValidSequence(vector<int>& sequence) {\\n    int n = sequence.size();\\n    for (int i = 0; i < n - 1; i++) {\\n        int currentMonth = sequence[i];\\n        int nextMonth = sequence[i + 1];\\n        if (currentMonth == 28 && nextMonth == 31) {\\n            return false;\\n        }\\n        if (currentMonth == 31 && nextMonth == 28) {\\n            return false;\\n        }\\n        if (currentMonth == 30 && nextMonth == 31) {\\n            return false;\\n        }\\n        if (currentMonth == 31 && nextMonth == 30) {\\n            return false;\\n        }\\n        if (currentMonth == 29 && nextMonth == 30) {\\n            return false;\\n        }\\n        if (currentMonth == 30 && nextMonth == 29) {\\n            return false;\\n        }\\n        if (currentMonth == 29 && nextMonth == 31) {\\n            return false;\\n        }\\n        if (currentMonth == 31 && nextMonth == 29) {\\n            return false;\\n        }\\n        if (currentMonth == 28 && nextMonth == 30) {\\n            return false;\\n        }\\n        if (currentMonth == 30 && nextMonth == 28) {\\n            return false;\\n        }\\n        if (currentMonth == 28 && nextMonth == 29) {\\n            return false;\\n        }\\n        if (currentMonth == 29 && nextMonth == 28) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> sequence(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> sequence[i];\\n    }\\n    if (isValidSequence(sequence)) {\\n        cout << \\\"YES\\\" << endl;\\n    } else {\\n        cout << \\\"NO\\\" << endl;\\n    }\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class CalendarMonths {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int[] durations = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            durations[i] = scanner.nextInt();\\n        }\\n        scanner.close();\\n\\n        boolean found = false;\\n        for (int i = 0; i < n; i++) {\\n            int current = durations[i];\\n            int next = durations[(i + 1) % n];\\n\\n            if (isLeapYear(current, next)) {\\n                found = true;\\n                break;\\n            }\\n        }\\n\\n        if (found) {\\n            System.out.println(\\\"YES\\\");\\n        } else {\\n            System.out.println(\\\"NO\\\");\\n        }\\n    }\\n\\n    private static boolean isLeapYear(int current, int next) {\\n        if (current == 28 && next == 29) {\\n            return true;\\n        }\\n\\n        if (current == 29 && next == 28) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\"}}","Python":"def is_consecutive_months(n, durations):\n    for i in range(n-1):\n        if durations[i] == 28 and durations[i+1] != 31:\n            return 'NO'\n        if durations[i] == 30 and durations[i+1] != 31:\n            return 'NO'\n        if durations[i] == 31 and durations[i+1] != 28 and durations[i+1] != 30 and durations[i+1] != 31:\n            return 'NO'\n    return 'YES'\n\nn = int(input())\ndurations = list(map(int, input().split()))\n\nprint(is_consecutive_months(n, durations))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int a[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &a[i]);\\n    }\\n\\n    int leap = 0;\\n    int non_leap = 0;\\n    int consecutive_months = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] == 28) {\\n            non_leap++;\\n        } else if (a[i] == 29) {\\n            leap++;\\n        } else {\\n            consecutive_months++;\\n        }\\n    }\\n\\n    if (leap > 0 && non_leap > 0) {\\n        printf(\\\"NO\\\\n\\\");\\n    } else if (leap > 0) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else if (non_leap > 0 && consecutive_months > 1) {\\n        printf(\\\"YES\\\\n\\\");\\n    } else if (non_leap > 0 && consecutive_months == 1) {\\n        printf(\\\"NO\\\\n\\\");\\n    } else {\\n        printf(\\\"YES\\\\n\\\");\\n    }\\n\\n    return 0;\\n}","C#":"\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        int[] durations = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n        \n        bool found = false;\n        \n        for (int i = 0; i < durations.Length - 1; i++)\n        {\n            if (IsConsecutiveMonths(durations[i], durations[i + 1]))\n            {\n                found = true;\n                break;\n            }\n        }\n        \n        Console.WriteLine(found ? \\\"YES\\\" : \\\"NO\\\");\n    }\n    \n    public static bool IsConsecutiveMonths(int duration1, int duration2)\n    {\n        if (duration1 == 28 && duration2 == 31)\n        {\n            return false;\n        }\n        \n        if (duration1 == 31 && duration2 == 28)\n        {\n            return false;\n        }\n        \n        return true;\n    }\n}\n","Ruby":"\ndef is_leap_year(year)\n  (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\nend\n\ndef check_months(n, durations)\n  months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  leap_months = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  \n  for i in 0..(months.length - n)\n    if durations == months[i...(i+n)] || durations == leap_months[i...(i+n)]\n      return 'YES'\n    end\n  end\n  \n  'NO'\nend\n\ninput = gets.chomp.split('\\n')\nn = input[0].to_i\ndurations = input[1].split(' ').map(&:to_i)\n\nputs check_months(n, durations)\n","delphi":"program GregorianCalendar;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction IsLeapYear(year: Integer): Boolean;\nbegin\n  Result := (year mod 4 = 0) and ((year mod 100 <> 0) or (year mod 400 = 0));\nend;\n\nfunction CheckMonths(n: Integer; a: array of Integer): Boolean;\nvar\n  i, j, year, month, days: Integer;\nbegin\n  year := 2000; \/\/ Start with year 2000 (a leap year)\n  month := 1; \/\/ Start with January\n  i := 0; \/\/ Start with the first element in the array\n\n  while i < n do\n  begin\n    days := a[i];\n\n    \/\/ Check if the number of days is valid for the current month\n    if (month = 2) and (not IsLeapYear(year)) and (days = 29) then\n    begin\n      Result := False;\n      Exit;\n    end;\n\n    if days > 31 then\n    begin\n      Result := False;\n      Exit;\n    end;\n\n    \/\/ Move to the next month\n    Inc(month);\n    if month > 12 then\n    begin\n      Inc(year);\n      month := 1;\n    end;\n\n    \/\/ Move to the next element in the array\n    Inc(i);\n  end;\n\n  Result := True;\nend;\n\nvar\n  n, i, j: Integer;\n  a: array of Integer;\n  input: string;\nbegin\n  \/\/ Read the number of integers\n  ReadLn(n);\n\n  \/\/ Read the integers\n  SetLength(a, n);\n  ReadLn(input);\n  for i := 1 to n do\n  begin\n    j := Pos(' ', input);\n    if j = 0 then\n      j := Length(input) + 1;\n    a[i - 1] := StrToInt(Copy(input, 1, j - 1));\n    Delete(input, 1, j);\n  end;\n\n  \/\/ Check if the months fit the sequence\n  if CheckMonths(n, a) then\n    WriteLn('YES')\n  else\n    WriteLn('NO');\nend. ","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tvar months []int\\n\\tfmt.Scan(&months)\\n\\n\\tleapYear := false\\n\\tdaysInMonth := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}\\n\\n\\tfor i := 0; i < len(months); i++ {\\n\\t\\tif i > 0 && months[i] == 28 && months[i-1] == 31 {\\n\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif i == 1 && months[i] == 28 {\\n\\t\\t\\tleapYear = true\\n\\t\\t}\\n\\n\\t\\tif months[i] != daysInMonth[i] {\\n\\t\\t\\tfmt.Println(\\\"NO\\\")\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t}\\n\\n\\tif leapYear {\\n\\t\\tfmt.Println(\\\"YES\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"NO\\\")\\n\\t}\\n}","Javascript":"function isConsecutiveMonths(n, durations) {\n    for (let i = 0; i < durations.length - 1; i++) {\n        if (durations[i] === 28 && durations[i + 1] === 31) {\n            return 'NO';\n        }\n    }\n    \n    return 'YES';\n}\n\nconst input = '4\\n31 31 30 31\\n';\nconst lines = input.trim().split('\\n');\nconst n = parseInt(lines[0]);\nconst durations = lines[1].split(' ').map(Number);\n\nconst result = isConsecutiveMonths(n, durations);\nconsole.log(result);","Kotlin":"import java.util.*\n\nfun main(args: Array<String>) {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val durations = IntArray(n)\n    for (i in 0 until n) {\n        durations[i] = scanner.nextInt()\n    }\n    \n    var possible = false\n    for (i in 0 until n) {\n        val monthDurations = IntArray(n)\n        monthDurations[0] = durations[i]\n        var leapYear = false\n        \n        \/\/ Check if the first month is February and determine if it's a leap year\n        if (monthDurations[0] == 28) {\n            val year = Calendar.getInstance().get(Calendar.YEAR)\n            leapYear = year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)\n        }\n        \n        \/\/ Calculate the durations of the remaining months\n        for (j in 1 until n) {\n            monthDurations[j] = getNextMonthDuration(monthDurations[j - 1], leapYear)\n            leapYear = false\n        }\n        \n        \/\/ Check if the calculated durations match the given durations\n        if (monthDurations.contentEquals(durations)) {\n            possible = true\n            break\n        }\n    }\n    \n    if (possible) {\n        println(\"YES\")\n    } else {\n        println(\"NO\")\n    }\n}\n\nfun getNextMonthDuration(previousDuration: Int, leapYear: Boolean): Int {\n    val daysInMonth = intArrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    val nextMonth = if (previousDuration == 31) 0 else previousDuration\n    return if (nextMonth == 1 && leapYear) 29 else daysInMonth[nextMonth]\n}","PHP":"\n<?php\n\nfunction isConsecutiveMonths($n, $months) {\n    $leapYear = false;\n    $validMonths = array();\n    \n    for ($i = 0; $i < $n; $i++) {\n        $days = $months[$i];\n        \n        if ($i > 0 && $days == 28 && $validMonths[$i-1] != 31) {\n            return 'NO';\n        }\n        \n        if ($i > 0 && $days == 30 && $validMonths[$i-1] != 31) {\n            return 'NO';\n        }\n        \n        if ($i > 0 && $days == 31 && $validMonths[$i-1] == 28) {\n            return 'NO';\n        }\n        \n        if ($i > 0 && $days == 31 && $validMonths[$i-1] == 30) {\n            return 'NO';\n        }\n        \n        if ($i > 0 && $days == 29 && $validMonths[$i-1] != 31) {\n            return 'NO';\n        }\n        \n        if ($i > 0 && $days == 29 && $validMonths[$i-1] == 31) {\n            $leapYear = true;\n        }\n        \n        $validMonths[] = $days;\n    }\n    \n    if ($leapYear) {\n        return 'YES';\n    } else {\n        return 'NO';\n    }\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$n = intval($input[0]);\n$months = array_slice($input, 1);\n\n$result = isConsecutiveMonths($n, $months);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\n\\r\\nbool isLeapYear(int year) {\\r\\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\\r\\n}\\r\\n\\r\\nbool checkConsecutiveMonths(int[] durations) {\\r\\n    int n = durations.length;\\r\\n    for (int i = 0; i < n - 1; i++) {\\r\\n        int currentMonth = durations[i];\\r\\n        int nextMonth = durations[i + 1];\\r\\n        if (currentMonth == 28 && nextMonth == 31) {\\r\\n            return false;\\r\\n        }\\r\\n        if (currentMonth == 31 && nextMonth == 28) {\\r\\n            return false;\\r\\n        }\\r\\n        if (currentMonth == 30 && nextMonth == 31) {\\r\\n            return false;\\r\\n        }\\r\\n        if (currentMonth == 31 && nextMonth == 30) {\\r\\n            return false;\\r\\n        }\\r\\n        if (currentMonth == 29 && nextMonth == 30 && !isLeapYear(2020)) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    return true;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    int[] durations;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    durations.length = n;\\r\\n    foreach (i; 0..n) {\\r\\n        readf(\\\"%d\\\", &durations[i]);\\r\\n    }\\r\\n    if (checkConsecutiveMonths(durations)) {\\r\\n        writeln(\\\"YES\\\");\\r\\n    } else {\\r\\n        writeln(\\\"NO\\\");\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub is_leap_year {\n    my ($year) = @_;\n    return ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n}\n\nsub check_months {\n    my ($n, @days) = @_;\n    \n    for my $i (0..$n-2) {\n        my $current_days = $days[$i];\n        my $next_days = $days[$i+1];\n        \n        if ($current_days == 28 && $next_days == 31) {\n            return 'NO';\n        }\n        \n        if ($current_days == 31 && $next_days == 28) {\n            return 'NO';\n        }\n        \n        if ($current_days == 30 && $next_days == 31) {\n            return 'NO';\n        }\n        \n        if ($current_days == 31 && $next_days == 30) {\n            return 'NO';\n        }\n        \n        if ($current_days == 29 && $next_days == 30 && !is_leap_year(1900 + $i)) {\n            return 'NO';\n        }\n        \n        if ($current_days == 30 && $next_days == 29 && !is_leap_year(1900 + $i)) {\n            return 'NO';\n        }\n    }\n    \n    return 'YES';\n}\n\nmy $n = <>;\nchomp($n);\n\nmy $input = <>;\nchomp($input);\nmy @days = split(' ', $input);\n\nmy $result = check_months($n, @days);\nprint $result;\n","Rust":"use std::io::{self, Read};\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_to_string(&mut input).unwrap();\n    \n    let lines: Vec<&str> = input.trim().split('\\n').collect();\n    let n: usize = lines[0].parse().unwrap();\n    let durations: Vec<usize> = lines[1].split(' ').map(|x| x.parse().unwrap()).collect();\n    \n    let mut leap_year = false;\n    let mut months: Vec<usize> = Vec::new();\n    \n    for i in 0..n {\n        if durations[i] == 28 {\n            if leap_year {\n                months.push(2);\n            } else {\n                println!(\"NO\");\n                return;\n            }\n        } else {\n            months.push((durations[i] - 28) % 12 + 1);\n        }\n        \n        if durations[i] == 29 {\n            leap_year = true;\n        }\n    }\n    \n    for i in 1..n {\n        if months[i] <= months[i-1] {\n            println!(\"NO\");\n            return;\n        }\n    }\n    \n    println!(\"YES\");\n}"}
{"title":"A. Robbery","description":"It is nighttime and Joe the Elusive got into the country's main bank's safe. The safe has n cells positioned in a row, each of them contains some amount of diamonds. Let's make the problem more comfortable to work with and mark the cells with positive numbers from 1 to n from the left to the right.Unfortunately, Joe didn't switch the last security system off. On the plus side, he knows the way it works.Every minute the security system calculates the total amount of diamonds for each two adjacent cells (for the cells between whose numbers difference equals 1). As a result of this check we get an n-1 sums. If at least one of the sums differs from the corresponding sum received during the previous check, then the security system is triggered.Joe can move the diamonds from one cell to another between the security system's checks. He manages to move them no more than m times between two checks. One of the three following operations is regarded as moving a diamond: moving a diamond from any cell to any other one, moving a diamond from any cell to Joe's pocket, moving a diamond from Joe's pocket to any cell. Initially Joe's pocket is empty, and it can carry an unlimited amount of diamonds. It is considered that before all Joe's actions the system performs at least one check.In the morning the bank employees will come, which is why Joe has to leave the bank before that moment. Joe has only k minutes left before morning, and on each of these k minutes he can perform no more than m operations. All that remains in Joe's pocket, is considered his loot.Calculate the largest amount of diamonds Joe can carry with him. Don't forget that the security system shouldn't be triggered (even after Joe leaves the bank) and Joe should leave before morning.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains integers n, m and k (1\u2264n\u226410^4, 1\u2264m,k\u226410^9). The next line contains n numbers. The i-th number is equal to the amount of diamonds in the i-th cell \u2014 it is an integer from 0 to 10^5.\n","output_spec":"Print a single number \u2014 the maximum number of diamonds Joe can steal.\n","notes":"In the second sample Joe can act like this:\nThe diamonds' initial positions are 4 1 3.\nDuring the first period of time Joe moves a diamond from the 1-th cell to the 2-th one and a diamond from the 3-th cell to his pocket.\nBy the end of the first period the diamonds' positions are 3 2 2. The check finds no difference and the security system doesn't go off.\nDuring the second period Joe moves a diamond from the 3-rd cell to the 2-nd one and puts a diamond from the 1-st cell to his pocket.\nBy the end of the second period the diamonds' positions are 2 3 1. The check finds no difference again and the security system doesn't go off.\nNow Joe leaves with 2 diamonds in his pocket.\n","sample_inputs":["2 3 1\n2 3\n","3 2 2\n4 1 3\n"],"sample_outputs":["0","2"],"id":"89-A","difficulty":1800,"tags":["greedy"],"src_uid":"b81e7a786e4083cf7188f718bc045a85","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m, k;\\n    cin >> n >> m >> k;\\n    vector<int> diamonds(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> diamonds[i];\\n    }\\n\\n    int maxDiamonds = 0;\\n    int maxMoves = min(m, k);\\n\\n    for (int i = 0; i < maxMoves; i++) {\\n        int maxDiff = 0;\\n        int maxDiffIndex = -1;\\n\\n        for (int j = 0; j < n - 1; j++) {\\n            int diff = abs(diamonds[j] - diamonds[j + 1]);\\n            if (diff > maxDiff) {\\n                maxDiff = diff;\\n                maxDiffIndex = j;\\n            }\\n        }\\n\\n        if (maxDiff == 0) {\\n            break;\\n        }\\n\\n        int moveAmount = min(maxDiff, diamonds[maxDiffIndex]);\\n        diamonds[maxDiffIndex] -= moveAmount;\\n        diamonds[maxDiffIndex + 1] += moveAmount;\\n        maxDiamonds += moveAmount;\\n    }\\n\\n    cout << maxDiamonds << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] input = scanner.nextLine().split(\\\" \\\");\n        int n = Integer.parseInt(input[0]);\n        int m = Integer.parseInt(input[1]);\n        int k = Integer.parseInt(input[2]);\n        \n        int[] diamonds = new int[n];\n        input = scanner.nextLine().split(\\\" \\\");\n        for (int i = 0; i < n; i++) {\n            diamonds[i] = Integer.parseInt(input[i]);\n        }\n        \n        int maxDiamonds = 0;\n        int maxMoves = Math.min(m, k);\n        \n        for (int i = 0; i < maxMoves; i++) {\n            int maxDiff = 0;\n            int maxDiffIndex = -1;\n            \n            for (int j = 0; j < n - 1; j++) {\n                int diff = Math.abs(diamonds[j] - diamonds[j + 1]);\n                if (diff > maxDiff) {\n                    maxDiff = diff;\n                    maxDiffIndex = j;\n                }\n            }\n            \n            if (maxDiff == 0) {\n                break;\n            }\n            \n            int moveAmount = Math.min(maxDiff, diamonds[maxDiffIndex]);\n            diamonds[maxDiffIndex] -= moveAmount;\n            diamonds[maxDiffIndex + 1] += moveAmount;\n            \n            maxDiamonds += moveAmount;\n        }\n        \n        System.out.println(maxDiamonds);\n    }\n}","Python":"def max_diamonds(n, m, k, diamonds):\n    if n == 1:\n        return 0\n    \n    max_diamonds = 0\n    \n    for i in range(n-1):\n        diff = diamonds[i] - diamonds[i+1]\n        if diff > m:\n            return max_diamonds\n        \n        max_diamonds += min(diamonds[i], m-diff)\n    \n    return max_diamonds\n\nn, m, k = map(int, input().split())\ndiamonds = list(map(int, input().split()))\n\nmax_diamonds = max_diamonds(n, m, k, diamonds)\nprint(max_diamonds)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m, k;\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\n    int diamonds[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &diamonds[i]);\\n    }\\n\\n    int maxDiamonds = 0;\\n    int maxMoves = m * k;\\n\\n    for (int i = 0; i < n - 1; i++) {\\n        int diff = diamonds[i] - diamonds[i + 1];\\n        if (diff > maxMoves) {\\n            maxDiamonds += maxMoves;\\n            maxMoves = 0;\\n            break;\\n        } else {\\n            maxDiamonds += diamonds[i];\\n            maxMoves -= diff;\\n        }\\n    }\\n\\n    maxDiamonds += diamonds[n - 1];\\n\\n    printf(\\\"%d\\\", maxDiamonds);\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        \/\/ Read input\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n        int k = int.Parse(input[2]);\n\n        int[] diamonds = Console.ReadLine().Split().Select(int.Parse).ToArray();\n\n        \/\/ Calculate the maximum number of diamonds Joe can steal\n        int maxDiamonds = 0;\n\n        \/\/ Iterate over each adjacent pair of cells\n        for (int i = 0; i < n - 1; i++)\n        {\n            \/\/ Calculate the difference between the current pair of cells\n            int diff = Math.Abs(diamonds[i] - diamonds[i + 1]);\n\n            \/\/ Calculate the maximum number of diamonds Joe can move between the current pair of cells\n            int maxMove = Math.Min(m, diff);\n\n            \/\/ Update the number of diamonds in the current pair of cells\n            diamonds[i] -= maxMove;\n            diamonds[i + 1] += maxMove;\n\n            \/\/ Update the maximum number of diamonds Joe can steal\n            maxDiamonds += maxMove;\n        }\n\n        \/\/ Calculate the remaining time Joe has\n        int remainingTime = k - (n - 1) * m;\n\n        \/\/ Calculate the maximum number of diamonds Joe can move between cells in the remaining time\n        int maxMoveRemaining = remainingTime \/ (2 * m);\n\n        \/\/ Update the number of diamonds in the cells using the remaining time\n        for (int i = 0; i < n && maxMoveRemaining > 0; i++)\n        {\n            int move = Math.Min(maxMoveRemaining, diamonds[i]);\n            diamonds[i] -= move;\n            maxDiamonds += move;\n            maxMoveRemaining -= move;\n        }\n\n        \/\/ Print the maximum number of diamonds Joe can steal\n        Console.WriteLine(maxDiamonds);\n    }\n}","Ruby":"\ndef max_diamonds(n, m, k, diamonds)\n  # Sort the diamonds in descending order\n  diamonds.sort!.reverse!\n\n  # Initialize variables\n  max_diamonds = 0\n  max_moves = m * k\n\n  # Iterate through each adjacent pair of cells\n  (0..n-2).each do |i|\n    diff = diamonds[i] - diamonds[i+1]\n\n    # If the difference is positive, we can move diamonds from the higher cell to the lower cell\n    if diff > 0\n      moves = [diff, max_moves].min\n      diamonds[i] -= moves\n      diamonds[i+1] += moves\n      max_moves -= moves\n    end\n\n    # Update the maximum number of diamonds Joe can steal\n    max_diamonds = [max_diamonds, diamonds[i]].max\n  end\n\n  # Return the maximum number of diamonds Joe can steal\n  max_diamonds\nend\n\n# Read input from STDIN\ninput = gets.chomp.split(\"\\n\")\nn, m, k = input[0].split.map(&:to_i)\ndiamonds = input[1].split.map(&:to_i)\n\n# Call the function and print the result\nputs max_diamonds(n, m, k, diamonds)\n","delphi":"program Main;\\n\\nvar\\n  n, m, k, i, j, maxDiamonds, totalDiamonds: integer;\\n  diamonds: array of integer;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n, m, k);\\n  SetLength(diamonds, n);\\n  for i := 0 to n-1 do\\n    read(diamonds[i]);\\n\\n  \/\/ Calculate maximum number of diamonds Joe can steal\\n  maxDiamonds := 0;\\n  totalDiamonds := 0;\\n\\n  for i := 0 to n-2 do\\n  begin\\n    totalDiamonds := totalDiamonds + diamonds[i];\\n    if totalDiamonds > maxDiamonds then\\n      maxDiamonds := totalDiamonds;\\n\\n    if diamonds[i] > diamonds[i+1] then\\n    begin\\n      if diamonds[i] - diamonds[i+1] > m then\\n      begin\\n        totalDiamonds := totalDiamonds - m;\\n        diamonds[i] := diamonds[i] - m;\\n      end\\n      else\\n      begin\\n        totalDiamonds := totalDiamonds - (diamonds[i] - diamonds[i+1]);\\n        diamonds[i] := diamonds[i+1];\\n      end;\\n    end\\n    else if diamonds[i] < diamonds[i+1] then\\n    begin\\n      if diamonds[i+1] - diamonds[i] > m then\\n      begin\\n        totalDiamonds := totalDiamonds - m;\\n        diamonds[i] := diamonds[i] + m;\\n      end\\n      else\\n      begin\\n        totalDiamonds := totalDiamonds - (diamonds[i+1] - diamonds[i]);\\n        diamonds[i] := diamonds[i+1];\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Print the maximum number of diamonds Joe can steal\\n  writeln(maxDiamonds);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, k int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &m, &k)\\n\\n\\tvar diamonds []int\\n\\tvar input string\\n\\tfmt.Scanf(\\\"%s\\\", &input)\\n\\tdiamondsStr := strings.Split(input, \\\" \\\")\\n\\n\\tfor _, d := range diamondsStr {\\n\\t\\tdiamond, _ := strconv.Atoi(d)\\n\\t\\tdiamonds = append(diamonds, diamond)\\n\\t}\\n\\n\\tmaxDiamonds := getMaxDiamonds(n, m, k, diamonds)\\n\\tfmt.Println(maxDiamonds)\\n}\\n\\nfunc getMaxDiamonds(n, m, k int, diamonds []int) int {\\n\\tmaxDiamonds := 0\\n\\n\\tfor i := 0; i < n-1; i++ {\\n\\t\\tdiff := diamonds[i] - diamonds[i+1]\\n\\t\\tif diff > m {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tmaxDiamonds += min(diamonds[i], diamonds[i+1])\\n\\t}\\n\\n\\treturn maxDiamonds\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}","Javascript":"function calculateMaxDiamonds(input) {\n  const [n, m, k] = input[0].split(' ').map(Number);\n  const diamonds = input[1].split(' ').map(Number);\n\n  let maxDiamonds = 0;\n\n  for (let i = 0; i < n - 1; i++) {\n    const diff = diamonds[i] - diamonds[i + 1];\n    if (diff > m) {\n      const moves = Math.ceil(diff \/ m);\n      if (moves <= k) {\n        diamonds[i] -= moves * m;\n        diamonds[i + 1] += moves * m;\n        k -= moves;\n      } else {\n        diamonds[i] -= k * m;\n        diamonds[i + 1] += k * m;\n        k = 0;\n      }\n    }\n  }\n\n  maxDiamonds = diamonds.reduce((total, diamond) => total + diamond, 0);\n\n  return maxDiamonds.toString();\n}\n\nconst input = ['2 3 1\\n2 3\\n'];\nconst output = calculateMaxDiamonds(input);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    val k = input[2].toInt()\n    \n    val diamonds = scanner.nextLine().split(\" \").map { it.toInt() }.toMutableList()\n    \n    var maxDiamonds = 0\n    \n    for (i in 0 until n - 1) {\n        val diff = diamonds[i] - diamonds[i + 1]\n        if (diff > maxDiamonds) {\n            maxDiamonds = diff\n        }\n    }\n    \n    val moves = m * k\n    if (moves >= maxDiamonds) {\n        maxDiamonds += (moves - maxDiamonds) \/ 2\n    }\n    \n    println(maxDiamonds)\n}","PHP":"\n<?php\n\nfunction calculateMaxDiamonds($input) {\n    \/\/ Parse the input\n    $lines = explode('\\n', $input);\n    $params = explode(' ', $lines[0]);\n    $n = intval($params[0]);\n    $m = intval($params[1]);\n    $k = intval($params[2]);\n    $diamonds = explode(' ', $lines[1]);\n    \n    \/\/ Initialize variables\n    $maxDiamonds = 0;\n    $moves = 0;\n    \n    \/\/ Iterate through the diamonds\n    for ($i = 0; $i < $n - 1; $i++) {\n        \/\/ Calculate the difference between adjacent cells\n        $diff = abs($diamonds[$i] - $diamonds[$i+1]);\n        \n        \/\/ Check if the difference is greater than 0\n        if ($diff > 0) {\n            \/\/ Calculate the maximum number of diamonds that can be moved\n            $maxMoves = min($m, $diff);\n            \n            \/\/ Update the number of moves\n            $moves += $maxMoves;\n            \n            \/\/ Update the maximum number of diamonds\n            $maxDiamonds = max($maxDiamonds, $moves);\n            \n            \/\/ Update the diamonds array\n            $diamonds[$i] -= $maxMoves;\n            $diamonds[$i+1] += $maxMoves;\n        }\n        \n        \/\/ Check if the number of moves exceeds the limit\n        if ($moves > $k) {\n            break;\n        }\n    }\n    \n    \/\/ Print the maximum number of diamonds\n    echo $maxDiamonds;\n}\n\n\/\/ Test the function with the sample inputs\ncalculateMaxDiamonds('2 3 1\\n2 3\\n');\ncalculateMaxDiamonds('3 2 2\\n4 1 3\\n');\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, k;\\r\\n    int[] diamonds;\\r\\n\\r\\n    \/\/ Read input\\r\\n    scanf(\\\"%d %d %d\\\", &n, &m, &k);\\r\\n    diamonds.length = n;\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        scanf(\\\"%d\\\", &diamonds[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Calculate the maximum number of diamonds Joe can steal\\r\\n    int maxDiamonds = 0;\\r\\n    int[] tempDiamonds = diamonds.dup;\\r\\n    for (int i = 0; i < k; i++)\\r\\n    {\\r\\n        bool triggered = false;\\r\\n        for (int j = 0; j < n - 1; j++)\\r\\n        {\\r\\n            int sum = tempDiamonds[j] + tempDiamonds[j + 1];\\r\\n            if (sum != diamonds[j] + diamonds[j + 1])\\r\\n            {\\r\\n                triggered = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (triggered)\\r\\n        {\\r\\n            break;\\r\\n        }\\r\\n\\r\\n        maxDiamonds += tempDiamonds[0];\\r\\n        tempDiamonds[0] = 0;\\r\\n\\r\\n        for (int j = 1; j < n; j++)\\r\\n        {\\r\\n            int diff = diamonds[j] - tempDiamonds[j];\\r\\n            int move = min(diff, m);\\r\\n            maxDiamonds += move;\\r\\n            tempDiamonds[j - 1] += move;\\r\\n            tempDiamonds[j] -= move;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    \/\/ Print the result\\r\\n    writeln(maxDiamonds);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_max_diamonds {\n    my ($n, $m, $k, @diamonds) = @_;\n\n    # Initialize variables\n    my $max_diamonds = 0;\n    my $total_moves = 0;\n\n    # Iterate through each adjacent pair of cells\n    for (my $i = 0; $i < $n - 1; $i++) {\n        my $diff = abs($diamonds[$i] - $diamonds[$i+1]);\n\n        # Check if the difference exceeds the allowed moves\n        if ($diff > $m * $k) {\n            return $max_diamonds;\n        }\n\n        # Calculate the maximum number of diamonds that can be moved\n        my $max_moves = int($diff \/ $k);\n        $max_moves = $m if $max_moves > $m;\n\n        # Update the maximum number of diamonds\n        $max_diamonds += $max_moves;\n\n        # Update the total number of moves\n        $total_moves += $max_moves * $k;\n\n        # Update the remaining diamonds in the cells\n        $diamonds[$i] -= $max_moves * $k;\n        $diamonds[$i+1] += $max_moves * $k;\n\n        # Check if the security system is triggered\n        if ($i < $n - 2 && abs($diamonds[$i+1] - $diamonds[$i+2]) > $m * $k) {\n            return $max_diamonds;\n        }\n    }\n\n    return $max_diamonds;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $k) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @diamonds = split ' ', $input;\n\n# Calculate the maximum number of diamonds Joe can steal\nmy $result = calculate_max_diamonds($n, $m, $k, @diamonds);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\\n    let input = std::io::stdin();\\n    let mut buf = String::new();\\n    input.read_line(&mut buf).unwrap();\\n    let mut iter = buf.split_whitespace();\\n    let n: usize = iter.next().unwrap().parse().unwrap();\\n    let m: usize = iter.next().unwrap().parse().unwrap();\\n    let k: usize = iter.next().unwrap().parse().unwrap();\\n\\n    buf.clear();\\n    input.read_line(&mut buf).unwrap();\\n    let diamonds: Vec<usize> = buf\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n\\n    let mut max_diamonds = 0;\\n\\n    for i in 0..n-1 {\\n        let diff = diamonds[i] - diamonds[i+1];\\n        if diff > max_diamonds {\\n            max_diamonds = diff;\\n        }\\n    }\\n\\n    let mut stolen_diamonds = 0;\\n\\n    for i in 0..n-1 {\\n        let diff = diamonds[i] - diamonds[i+1];\\n        stolen_diamonds += diff;\\n    }\\n\\n    let remaining_time = k - 1;\\n    let max_moves = remaining_time * m;\\n\\n    if max_moves >= stolen_diamonds {\\n        println!(\\\"{}\\\", stolen_diamonds + max_diamonds);\\n    } else {\\n        println!(\\\"{}\\\", max_moves + max_diamonds);\\n    }\\n}"}
{"title":"E. Fire and Ice","description":"The Fire Lord attacked the Frost Kingdom. He has already got to the Ice Fortress, where the Snow Queen dwells. He arranged his army on a segment n in length not far from the city walls. And only the frost magician Solomon can save the Frost Kingdom. The n-long segment is located at a distance equal exactly to 1 from the castle walls. It can be imaginarily divided into unit segments. On some of the unit segments fire demons are located \u2014 no more than one demon per position. Each demon is characterised by his strength - by some positive integer. We can regard the fire demons being idle.Initially Solomon is positioned on the fortress wall. He can perform the following actions several times in a row:  \"L\" \u2014 Solomon shifts one unit to the left. This movement cannot be performed on the castle wall. \"R\" \u2014 Solomon shifts one unit to the left. This movement cannot be performed if there's no ice block to the right. \"A\" \u2014 If there's nothing to the right of Solomon, then Solomon creates an ice block that immediately freezes to the block that Solomon is currently standing on. If there already is an ice block, then Solomon destroys it. At that the ice blocks to the right of the destroyed one can remain but they are left unsupported. Those ice blocks fall down.Solomon spends exactly a second on each of these actions.As the result of Solomon's actions, ice blocks' segments fall down. When an ice block falls on a fire demon, the block evaporates and the demon's strength is reduced by 1. When the demons' strength is equal to 0, the fire demon vanishes. The picture below shows how it happens. The ice block that falls on the position with no demon, breaks into lots of tiny pieces and vanishes without hurting anybody. Help Solomon destroy all the Fire Lord's army in minimum time.","input_from":"standard input","output_to":"standard output","time_limit":"0.5 second","memory_limit":"256 megabytes","input_spec":"The first line contains an integer n (1\u2264n\u22641000). The next line contains n numbers, the i-th of them represents the strength of the fire demon standing of the i-th position, an integer from 1 to 100. If there's no demon on the i-th position, then the i-th number equals to 0. It is guaranteed that the input data have at least one fire demon.\n","output_spec":"Print a string of minimum length, containing characters \"L\", \"R\" and \"A\" \u2014 the succession of actions leading to the required result.\nIf there are several possible answers, print any of them.\n","notes":null,"sample_inputs":["3\n1 0 1\n","3\n0 2 0\n"],"sample_outputs":["ARARARALLLA","ARARALAARALA"],"id":"89-E","difficulty":2900,"tags":["greedy"],"src_uid":"0996e41d0630e56472399bc81544756b","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    vector<int> demons(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> demons[i];\\n    }\\n\\n    string actions;\\n    int left = 0;\\n    int right = n - 1;\\n\\n    while (left <= right) {\\n        if (demons[left] == 0) {\\n            actions += 'R';\\n            left++;\\n        } else if (demons[right] == 0) {\\n            actions += 'L';\\n            right--;\\n        } else {\\n            if (demons[left] <= demons[right]) {\\n                actions += 'A';\\n                demons[right]--;\\n                right--;\\n            } else {\\n                actions += 'A';\\n                demons[left]--;\\n                left++;\\n            }\\n        }\\n    }\\n\\n    cout << actions << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] demons = new int[n];\n        for (int i = 0; i < n; i++) {\n            demons[i] = scanner.nextInt();\n        }\n        \n        StringBuilder actions = new StringBuilder();\n        int currentPos = 0;\n        boolean moveRight = true;\n        \n        while (true) {\n            if (demons[currentPos] > 0) {\n                demons[currentPos]--;\n                actions.append(\"A\");\n            } else {\n                if (moveRight) {\n                    if (currentPos == n - 1) {\n                        break;\n                    }\n                    actions.append(\"R\");\n                    currentPos++;\n                } else {\n                    if (currentPos == 0) {\n                        break;\n                    }\n                    actions.append(\"L\");\n                    currentPos--;\n                }\n            }\n            \n            moveRight = !moveRight;\n        }\n        \n        System.out.println(actions.toString());\n    }\n}","Python":"def destroy_fire_demons(n, demons):\n    actions = []\n    for i in range(n):\n        if demons[i] > 0:\n            actions.append('A')\n            for j in range(i+1, n):\n                if demons[j] > 0:\n                    actions.append('R')\n                    demons[j] -= 1\n                else:\n                    actions.append('A')\n        actions.append('L')\n    return ''.join(actions)\n\nn = int(input())\ndemons = list(map(int, input().split()))\n\nresult = destroy_fire_demons(n, demons)\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int demons[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &demons[i]);\\n    }\\n\\n    char actions[1000];\\n    int actionIndex = 0;\\n\\n    int left = 0;\\n    int right = n - 1;\\n\\n    while (left <= right) {\\n        if (demons[left] == 0) {\\n            actions[actionIndex++] = 'A';\\n            left++;\\n        } else if (demons[right] == 0) {\\n            actions[actionIndex++] = 'R';\\n            right--;\\n        } else {\\n            if (demons[left] <= demons[right]) {\\n                actions[actionIndex++] = 'L';\\n                demons[right]--;\\n            } else {\\n                actions[actionIndex++] = 'R';\\n                right--;\\n            }\\n        }\\n    }\\n\\n    for (int i = right + 1; i <= left - 1; i++) {\\n        actions[actionIndex++] = 'A';\\n    }\\n\\n    actions[actionIndex] = '\\\\0';\\n\\n    printf(\\\"%s\\\", actions);\\n\\n    return 0;\\n}","C#":"\nusing System;\nusing System.Collections.Generic;\n\nnamespace FireLord\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] demons = Array.ConvertAll(Console.ReadLine().Split(), int.Parse);\n\n            List<char> actions = new List<char>();\n\n            int left = 0;\n            int right = n - 1;\n\n            while (left <= right)\n            {\n                if (demons[left] > 0)\n                {\n                    actions.Add('A');\n                    demons[left]--;\n                }\n                else if (demons[right] > 0)\n                {\n                    actions.Add('R');\n                    demons[right]--;\n                    right--;\n                }\n                else\n                {\n                    actions.Add('L');\n                    left++;\n                }\n            }\n\n            Console.WriteLine(string.Join(\"\", actions));\n        }\n    }\n}\n","Ruby":"\ndef destroy_army(n, demons)\n  actions = \"\"\n  left = 0\n  right = n - 1\n\n  while left <= right\n    if demons[left] > 0\n      actions += \"A\"\n      demons[left] -= 1\n    end\n\n    if demons[right] > 0\n      actions += \"A\"\n      demons[right] -= 1\n    end\n\n    actions += \"R\" if right > left\n    actions += \"L\" if left < right\n\n    left += 1\n    right -= 1\n  end\n\n  actions\nend\n\ninput = gets.chomp.split(\"\\n\")\nn = input[0].to_i\ndemons = input[1].split(\" \").map(&:to_i)\n\noutput = destroy_army(n, demons)\nputs output\n","delphi":"var\n  n, i, j, k, l, r, a: integer;\n  s: string;\nbegin\n  readln(n);\n  readln(s);\n  \n  l := 0;\n  r := 0;\n  a := 0;\n  \n  for i := 1 to n do\n  begin\n    if s[i] = '0' then\n    begin\n      if r > 0 then\n      begin\n        write('R');\n        Dec(r);\n      end\n      else\n      begin\n        write('A');\n        Inc(a);\n      end;\n    end\n    else\n    begin\n      if a > 0 then\n      begin\n        write('A');\n        Dec(a);\n      end;\n      \n      if l > 0 then\n      begin\n        write('L');\n        Dec(l);\n      end;\n      \n      for j := 1 to StrToInt(s[i]) - 1 do\n      begin\n        if r > 0 then\n        begin\n          write('R');\n          Dec(r);\n        end\n        else\n        begin\n          write('A');\n          Inc(a);\n        end;\n      end;\n      \n      write('A');\n      Inc(a);\n    end;\n    \n    if i < n then\n      write('R');\n    Inc(r);\n  end;\n  \n  writeln();\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tdemons := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scan(&demons[i])\\n\\t}\\n\\n\\tactions := []string{}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif demons[i] > 0 {\\n\\t\\t\\tactions = append(actions, \\\"A\\\")\\n\\t\\t\\tfor j := i + 1; j < n; j++ {\\n\\t\\t\\t\\tif demons[j] > 0 {\\n\\t\\t\\t\\t\\tdemons[j]--\\n\\t\\t\\t\\t\\tactions = append(actions, \\\"R\\\")\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tactions = append(actions, \\\"L\\\")\\n\\t\\t} else {\\n\\t\\t\\tactions = append(actions, \\\"R\\\")\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(strings.Join(actions, \\\"\\\"))\\n}","Javascript":"function destroyFireArmy(n, demons) {\n    let actions = '';\n    let left = 0;\n    let right = n - 1;\n    \n    while (left <= right) {\n        if (demons[left] === 0) {\n            actions += 'A';\n            demons[left] = 1;\n        } else if (demons[right] === 0) {\n            actions += 'R';\n            right--;\n        } else {\n            actions += 'L';\n            left++;\n        }\n    }\n    \n    return actions;\n}\n\nconsole.log(destroyFireArmy(3, [1, 0, 1]));","Kotlin":"fun main() {\n    val n = readLine()!!.toInt()\n    val demons = readLine()!!.split(\" \").map { it.toInt() }\n    \n    val actions = StringBuilder()\n    \n    var currentPos = 0\n    var currentStrength = demons[currentPos]\n    \n    while (currentStrength > 0) {\n        if (currentPos < n - 1 && demons[currentPos + 1] > 0) {\n            actions.append(\"R\")\n            currentPos++\n            currentStrength = demons[currentPos]\n        } else if (currentPos > 0 && demons[currentPos - 1] > 0) {\n            actions.append(\"L\")\n            currentPos--\n            currentStrength = demons[currentPos]\n        } else {\n            actions.append(\"A\")\n            demons[currentPos]--\n            currentStrength--\n        }\n    }\n    \n    println(actions.toString())\n}","PHP":"<?php\\n\\nfunction destroyArmy($n, $demons) {\\n    $actions = '';\\n    $left = 0;\\n    $right = $n - 1;\\n    $direction = 'R';\\n    \\n    while ($left <= $right) {\\n        if ($direction == 'R') {\\n            if ($demons[$right] > 0) {\\n                $actions .= 'A';\\n                $demons[$right]--;\\n            }\\n            $actions .= 'R';\\n            $right--;\\n            $direction = 'L';\\n        } else {\\n            if ($demons[$left] > 0) {\\n                $actions .= 'A';\\n                $demons[$left]--;\\n            }\\n            $actions .= 'L';\\n            $left++;\\n            $direction = 'R';\\n        }\\n    }\\n    \\n    return $actions;\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$n = intval($input[0]);\\n$demons = array_map('intval', explode(' ', $input[1]));\\n\\n$result = destroyArmy($n, $demons);\\necho $result;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nstring destroyFireDemons(int n, int[] demons) {\\r\\n    string actions = \\\"\\\";\\r\\n    int currentPos = 0;\\r\\n    int currentStrength = 0;\\r\\n    int[] iceBlocks = new int[n];\\r\\n\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        if (demons[i] > 0) {\\r\\n            while (currentPos < i) {\\r\\n                actions ~= \\\"R\\\";\\r\\n                currentPos++;\\r\\n            }\\r\\n\\r\\n            while (currentPos > i) {\\r\\n                actions ~= \\\"L\\\";\\r\\n                currentPos--;\\r\\n            }\\r\\n\\r\\n            currentStrength = demons[i];\\r\\n\\r\\n            while (currentStrength > 0) {\\r\\n                if (currentPos == n - 1) {\\r\\n                    actions ~= \\\"A\\\";\\r\\n                    iceBlocks[currentPos]++;\\r\\n                    currentStrength--;\\r\\n                }\\r\\n                else if (iceBlocks[currentPos + 1] > 0) {\\r\\n                    actions ~= \\\"A\\\";\\r\\n                    iceBlocks[currentPos]++;\\r\\n                    currentStrength--;\\r\\n                    iceBlocks[currentPos + 1]--;\\r\\n                }\\r\\n                else {\\r\\n                    actions ~= \\\"R\\\";\\r\\n                    currentPos++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    while (currentPos > 0) {\\r\\n        actions ~= \\\"L\\\";\\r\\n        currentPos--;\\r\\n    }\\r\\n\\r\\n    return actions;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n;\\r\\n    int[] demons;\\r\\n\\r\\n    \/\/ Read input\\r\\n    readf(\\\"%d\\\", &n);\\r\\n    demons = new int[n];\\r\\n\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        readf(\\\"%d\\\", &demons[i]);\\r\\n    }\\r\\n\\r\\n    \/\/ Call the function and print the result\\r\\n    string result = destroyFireDemons(n, demons);\\r\\n    writeln(result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub destroy_army {\n    my ($n, @strengths) = @_;\n\n    my $solomon_position = 0;\n    my $actions = '';\n\n    for (my $i = 0; $i < $n; $i++) {\n        if ($strengths[$i] > 0) {\n            my $demon_position = $i + 1;\n            my $distance = $demon_position - $solomon_position;\n\n            if ($distance > 0) {\n                $actions .= 'R' x $distance;\n                $solomon_position += $distance;\n            } elsif ($distance < 0) {\n                $actions .= 'L' x abs($distance);\n                $solomon_position -= abs($distance);\n            }\n\n            $actions .= 'A';\n            $strengths[$i]--;\n\n            if ($strengths[$i] == 0) {\n                $actions .= 'L';\n                $solomon_position--;\n            }\n        }\n    }\n\n    return $actions;\n}\n\n# Read input\nmy $n = <>;\nchomp($n);\nmy $strengths = <>;\nchomp($strengths);\nmy @strengths = split(' ', $strengths);\n\n# Call the function and print the result\nmy $result = destroy_army($n, @strengths);\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"3\\\\n1 0 1\\\\n\\\";\\n    let mut lines = input.lines();\\n    let n: usize = lines.next().unwrap().parse().unwrap();\\n    let strengths: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|s| s.parse().unwrap())\\n        .collect();\\n\\n    let mut actions = String::new();\\n    let mut current_position = 0;\\n\\n    while strengths.iter().any(|&s| s > 0) {\\n        if current_position < n - 1 && strengths[current_position + 1] > 0 {\\n            actions.push('R');\\n            current_position += 1;\\n        } else if current_position > 0 && strengths[current_position - 1] > 0 {\\n            actions.push('L');\\n            current_position -= 1;\\n        } else {\\n            actions.push('A');\\n            if strengths[current_position] > 0 {\\n                strengths[current_position] -= 1;\\n            }\\n        }\\n    }\\n\\n    println!(\"{}\", actions);\\n}"}
{"title":"A. Train and Peter","description":"Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters \u2014 for different colours.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 10^5, the string consists of lowercase Latin letters \u2014 the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order. \nThe second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order. \n","output_spec":"Output one of the four words without inverted commas: \n  \u00abforward\u00bb \u2014 if Peter could see such sequences only on the way from A to B;  \u00abbackward\u00bb \u2014 if Peter could see such sequences on the way from B to A;  \u00abboth\u00bb \u2014 if Peter could see such sequences both on the way from A to B, and on the way from B to A;  \u00abfantasy\u00bb \u2014 if Peter could not see such sequences. ","notes":"It is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.\n","sample_inputs":["atob\na\nb\n","aaacaaa\naca\naa\n"],"sample_outputs":["forward\n","both\n"],"id":"8-A","difficulty":1200,"tags":["strings"],"src_uid":"c3244e952830643938d51ce14f043d7d","C++":"#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nstring findSequence(string stations, string firstSeq, string secondSeq) {\\n    string forwardSeq = firstSeq + secondSeq;\\n    string backwardSeq = secondSeq + firstSeq;\\n    reverse(backwardSeq.begin(), backwardSeq.end());\\n\\n    size_t foundForward = stations.find(forwardSeq);\\n    size_t foundBackward = stations.find(backwardSeq);\\n\\n    if (foundForward != string::npos && foundBackward != string::npos) {\\n        return \\\"both\\\";\\n    } else if (foundForward != string::npos) {\\n        return \\\"forward\\\";\\n    } else if (foundBackward != string::npos) {\\n        return \\\"backward\\\";\\n    } else {\\n        return \\\"fantasy\\\";\\n    }\\n}\\n\\nint main() {\\n    string stations, firstSeq, secondSeq;\\n    cin >> stations >> firstSeq >> secondSeq;\\n\\n    string result = findSequence(stations, firstSeq, secondSeq);\\n    cout << result << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class TrainFlagSequence {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        \/\/ Read input\n        String stations = scanner.nextLine();\n        String firstSequence = scanner.nextLine();\n        String secondSequence = scanner.nextLine();\n        \n        \/\/ Check if both sequences are present in the forward direction\n        boolean forward = checkSequence(stations, firstSequence) && checkSequence(stations, secondSequence);\n        \n        \/\/ Check if both sequences are present in the backward direction\n        String reversedStations = new StringBuilder(stations).reverse().toString();\n        boolean backward = checkSequence(reversedStations, firstSequence) && checkSequence(reversedStations, secondSequence);\n        \n        \/\/ Determine the output\n        if (forward && backward) {\n            System.out.println(\\\"both\\\");\n        } else if (forward) {\n            System.out.println(\\\"forward\\\");\n        } else if (backward) {\n            System.out.println(\\\"backward\\\");\n        } else {\n            System.out.println(\\\"fantasy\\\");\n        }\n    }\n    \n    \/\/ Function to check if a sequence is present in the given stations\n    public static boolean checkSequence(String stations, String sequence) {\n        int sequenceIndex = 0;\n        for (int i = 0; i < stations.length(); i++) {\n            if (stations.charAt(i) == sequence.charAt(sequenceIndex)) {\n                sequenceIndex++;\n                if (sequenceIndex == sequence.length()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}","Python":"def find_sequence(input_data):\n    stations = input_data[0]\n    sequence1 = input_data[1]\n    sequence2 = input_data[2]\n    \n    # Check if sequence1 is present in stations\n    if sequence1 in stations:\n        # Check if sequence2 is present in stations\n        if sequence2 in stations:\n            return 'both'\n        else:\n            return 'forward'\n    # Check if sequence2 is present in stations\n    elif sequence2 in stations:\n        return 'backward'\n    else:\n        return 'fantasy'\n\ninput_data = input().split('\\\\n')\nresult = find_sequence(input_data)\nprint(result)\n","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint main() {\\n    char stations[100001];\\n    char sequence1[101];\\n    char sequence2[101];\\n    scanf(\\\"%s\\\", stations);\\n    scanf(\\\"%s\\\", sequence1);\\n    scanf(\\\"%s\\\", sequence2);\\n    int len_stations = strlen(stations);\\n    int len_sequence1 = strlen(sequence1);\\n    int len_sequence2 = strlen(sequence2);\\n    int forward = 0;\\n    int backward = 0;\\n    for (int i = 0; i < len_stations - len_sequence1 - len_sequence2 + 1; i++) {\\n        int match1 = 1;\\n        int match2 = 1;\\n        for (int j = 0; j < len_sequence1; j++) {\\n            if (stations[i+j] != sequence1[j]) {\\n                match1 = 0;\\n                break;\\n            }\\n        }\\n        for (int j = 0; j < len_sequence2; j++) {\\n            if (stations[i+len_sequence1+j] != sequence2[j]) {\\n                match2 = 0;\\n                break;\\n            }\\n        }\\n        if (match1 && match2) {\\n            forward = 1;\\n            break;\\n        }\\n    }\\n    for (int i = len_stations - 1; i >= len_sequence1 + len_sequence2 - 1; i--) {\\n        int match1 = 1;\\n        int match2 = 1;\\n        for (int j = 0; j < len_sequence1; j++) {\\n            if (stations[i-j] != sequence1[j]) {\\n                match1 = 0;\\n                break;\\n            }\\n        }\\n        for (int j = 0; j < len_sequence2; j++) {\\n            if (stations[i-len_sequence1-j] != sequence2[j]) {\\n                match2 = 0;\\n                break;\\n            }\\n        }\\n        if (match1 && match2) {\\n            backward = 1;\\n            break;\\n        }\\n    }\\n    if (forward && backward) {\\n        printf(\\\"both\\\\n\\\");\\n    } else if (forward) {\\n        printf(\\\"forward\\\\n\\\");\\n    } else if (backward) {\\n        printf(\\\"backward\\\\n\\\");\\n    } else {\\n        printf(\\\"fantasy\\\\n\\\");\\n    }\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string stations = Console.ReadLine();\n        string firstSequence = Console.ReadLine();\n        string secondSequence = Console.ReadLine();\n        \n        bool forward = CheckSequence(stations, firstSequence);\n        bool backward = CheckSequence(ReverseString(stations), secondSequence);\n        \n        if (forward && backward)\n        {\n            Console.WriteLine(\\\"both\\\");\n        }\n        else if (forward)\n        {\n            Console.WriteLine(\\\"forward\\\");\n        }\n        else if (backward)\n        {\n            Console.WriteLine(\\\"backward\\\");\n        }\n        else\n        {\n            Console.WriteLine(\\\"fantasy\\\");\n        }\n    }\n    \n    public static bool CheckSequence(string stations, string sequence)\n    {\n        int currentIndex = 0;\n        \n        foreach (char color in sequence)\n        {\n            currentIndex = stations.IndexOf(color, currentIndex);\n            \n            if (currentIndex == -1)\n            {\n                return false;\n            }\n            \n            currentIndex++;\n        }\n        \n        return true;\n    }\n    \n    public static string ReverseString(string input)\n    {\n        char[] charArray = input.ToCharArray();\n        Array.Reverse(charArray);\n        return new string(charArray);\n    }\n}","Ruby":"def find_sequence(input_data)\n    # Split the input data into the three lines\n    lines = input_data.split('\\\\n')\n    stations = lines[0]\n    sequence1 = lines[1]\n    sequence2 = lines[2]\n\n    # Check if the sequences can be found in the forward direction\n    forward = check_sequence(stations, sequence1) && check_sequence(stations, sequence2)\n\n    # Reverse the stations string for checking in the backward direction\n    stations_reverse = stations.reverse\n\n    # Check if the sequences can be found in the backward direction\n    backward = check_sequence(stations_reverse, sequence1) && check_sequence(stations_reverse, sequence2)\n\n    # Determine the output based on the results\n    if forward && backward\n        return 'both'\n    elsif forward\n        return 'forward'\n    elsif backward\n        return 'backward'\n    else\n        return 'fantasy'\n    end\nend\n\ndef check_sequence(stations, sequence)\n    # Initialize the starting index for searching\n    start_index = 0\n\n    # Iterate over each character in the sequence\n    sequence.each_char do |char|\n        # Find the index of the character in the stations string\n        index = stations.index(char, start_index)\n\n        # If the character is not found, return false\n        return false if index.nil?\n\n        # Update the starting index for the next iteration\n        start_index = index + 1\n    end\n\n    # If all characters are found, return true\n    return true\nend\n\n# Test the function with the sample inputs\nputs find_sequence('atob\\\\na\\\\nb\\\\')\nputs find_sequence('aaacaaa\\\\naca\\\\naa\\\\')","delphi":"Here is the Delphi code for solving the problem:\\n\\n```delphi\\nprogram TrainFlagSequences;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction CheckFlagSequences(AtoB, FirstPeriod, SecondPeriod: string): string;\\nvar\\n  ReverseAtoB: string;\\nbegin\\n  ReverseAtoB := ReverseString(AtoB);\\n\\n  if Pos(FirstPeriod, AtoB) > 0 then\\n  begin\\n    if Pos(SecondPeriod, AtoB) > 0 then\\n      Result := 'both'\\n    else\\n      Result := 'forward';\\n  end\\n  else if Pos(FirstPeriod, ReverseAtoB) > 0 then\\n  begin\\n    if Pos(SecondPeriod, ReverseAtoB) > 0 then\\n      Result := 'both'\\n    else\\n      Result := 'backward';\\n  end\\n  else\\n    Result := 'fantasy';\\nend;\\n\\nvar\\n  AtoB, FirstPeriod, SecondPeriod: string;\\nbegin\\n  \/\/ Read input\\n  ReadLn(AtoB);\\n  ReadLn(FirstPeriod);\\n  ReadLn(SecondPeriod);\\n\\n  \/\/ Call the function to check flag sequences\\n  WriteLn(CheckFlagSequences(AtoB, FirstPeriod, SecondPeriod));\\nend.\\n```\\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar stations string\\n\\tvar firstSeq string\\n\\tvar secondSeq string\\n\\n\\t\/\/ Read input\\n\\tfmt.Scan(&stations)\\n\\tfmt.Scan(&firstSeq)\\n\\tfmt.Scan(&secondSeq)\\n\\n\\t\/\/ Check if sequences can be seen forward\\n\\tforward := checkSequence(stations, firstSeq)\\n\\n\\t\/\/ Check if sequences can be seen backward\\n\\treversedStations := reverseString(stations)\\n\\tbackward := checkSequence(reversedStations, secondSeq)\\n\\n\\t\/\/ Determine the output\\n\\tif forward && backward {\\n\\t\\tfmt.Println(\\\"both\\\")\\n\\t} else if forward {\\n\\t\\tfmt.Println(\\\"forward\\\")\\n\\t} else if backward {\\n\\t\\tfmt.Println(\\\"backward\\\")\\n\\t} else {\\n\\t\\tfmt.Println(\\\"fantasy\\\")\\n\\t}\\n}\\n\\n\/\/ Function to check if a sequence can be seen in a given string\\nfunc checkSequence(str string, seq string) bool {\\n\\tindex := 0\\n\\tfor i := 0; i < len(str); i++ {\\n\\t\\tif str[i] == seq[index] {\\n\\t\\t\\tindex++\\n\\t\\t\\tif index == len(seq) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n\/\/ Function to reverse a string\\nfunc reverseString(str string) string {\\n\\tvar reversed strings.Builder\\n\\tfor i := len(str) - 1; i >= 0; i-- {\\n\\t\\treversed.WriteByte(str[i])\\n\\t}\\n\\treturn reversed.String()\\n}","Javascript":"function findSequence(input) {\n  const [stations, sequence1, sequence2] = input.split('\\\\n');\n  const forward = stations.includes(sequence1) && stations.includes(sequence2);\n  const backward = stations.split('').reverse().join('').includes(sequence1) && stations.split('').reverse().join('').includes(sequence2);\n  \n  if (forward && backward) {\n    return 'both';\n  } else if (forward) {\n    return 'forward';\n  } else if (backward) {\n    return 'backward';\n  } else {\n    return 'fantasy';\n  }\n}\n\nconst input = 'atob\\\\na\\\\nb\\\\n';\nconst output = findSequence(input);\nconsole.log(output);","Kotlin":"fun main() {\n    val stations = readLine()!!\n    val firstPeriod = readLine()!!\n    val secondPeriod = readLine()!!\n\n    val forward = stations.indexOf(firstPeriod) != -1 && stations.indexOf(secondPeriod, startIndex = stations.indexOf(firstPeriod) + firstPeriod.length) != -1\n    val backward = stations.indexOf(firstPeriod.reversed()) != -1 && stations.indexOf(secondPeriod.reversed(), startIndex = stations.indexOf(firstPeriod.reversed()) + firstPeriod.length) != -1\n\n    if (forward && backward) {\n        println(\\\"both\\\")\n    } else if (forward) {\n        println(\\\"forward\\\")\n    } else if (backward) {\n        println(\\\"backward\\\")\n    } else {\n        println(\\\"fantasy\\\")\n    }\n}","PHP":"<?php\\n\\nfunction findSequence($stations, $sequence1, $sequence2) {\\n    $forward = strpos($stations, $sequence1) !== false && strpos($stations, $sequence2, strpos($stations, $sequence1) + strlen($sequence1)) !== false;\\n    $backward = strpos(strrev($stations), $sequence1) !== false && strpos(strrev($stations), $sequence2, strpos(strrev($stations), $sequence1) + strlen($sequence1)) !== false;\\n\\n    if ($forward && $backward) {\\n        return 'both';\\n    } elseif ($forward) {\\n        return 'forward';\\n    } elseif ($backward) {\\n        return 'backward';\\n    } else {\\n        return 'fantasy';\\n    }\\n}\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents('php:\/\/stdin'));\\n$stations = $input[0];\\n$sequence1 = $input[1];\\n$sequence2 = $input[2];\\n\\n$result = findSequence($stations, $sequence1, $sequence2);\\necho $result;\\n?>","d":"import std.algorithm;\\nimport std.array;\\n\\nstring findSequence(string stations, string sequence1, string sequence2)\\n{\\n    string forward = stations;\\n    string backward = stations.reverse;\\n    string both = stations;\\n    both = both.reverse;\\n    if (forward.canFind(sequence1) && forward.canFind(sequence2))\\n    {\\n        if (backward.canFind(sequence1) && backward.canFind(sequence2))\\n        {\\n            return \\\"both\\\";\\n        }\\n        else\\n        {\\n            return \\\"forward\\\";\\n        }\\n    }\\n    else if (backward.canFind(sequence1) && backward.canFind(sequence2))\\n    {\\n        return \\\"backward\\\";\\n    }\\n    else\\n    {\\n        return \\\"fantasy\\\";\\n    }\\n}\\n\\nvoid main()\\n{\\n    string input = \\\"aaacaaa\\\\naca\\\\naa\\\\n\\\";\\n    auto lines = input.splitter;\\n    string stations = lines.front;\\n    string sequence1 = lines.popFront;\\n    string sequence2 = lines.popFront;\\n    string result = findSequence(stations, sequence1, sequence2);\\n    writeln(result);\\n}","perl":"\n# Read input\nmy $stations = <STDIN>;\nmy $first_sequence = <STDIN>;\nmy $second_sequence = <STDIN>;\n\n# Remove newline characters\nchomp($stations);\nchomp($first_sequence);\nchomp($second_sequence);\n\n# Check if both sequences can be seen on the way from A to B\nmy $forward = check_sequence($stations, $first_sequence) && check_sequence($stations, $second_sequence);\n\n# Check if both sequences can be seen on the way from B to A\nmy $backward = check_sequence(reverse($stations), $first_sequence) && check_sequence(reverse($stations), $second_sequence);\n\n# Determine the output based on the results\nmy $output;\nif ($forward && $backward) {\n    $output = 'both';\n} elsif ($forward) {\n    $output = 'forward';\n} elsif ($backward) {\n    $output = 'backward';\n} else {\n    $output = 'fantasy';\n}\n\n# Print the output\nprint $output;\n\n# Function to check if a sequence can be seen on a given stations string\nsub check_sequence {\n    my ($stations, $sequence) = @_;\n    my $index = 0;\n    foreach my $char (split('', $sequence)) {\n        $index = index($stations, $char, $index);\n        if ($index == -1) {\n            return 0;\n        }\n        $index++;\n    }\n    return 1;\n}\n","Rust":"fn main() {\\n    let input = std::io::stdin();\\n    let mut buffer = String::new();\\n\\n    \/\/ Read the input data\\n    input.read_line(&mut buffer).unwrap();\\n    let stations = buffer.trim().to_string();\\n\\n    buffer.clear();\\n    input.read_line(&mut buffer).unwrap();\\n    let first_sequence = buffer.trim().to_string();\\n\\n    buffer.clear();\\n    input.read_line(&mut buffer).unwrap();\\n    let second_sequence = buffer.trim().to_string();\\n\\n    \/\/ Check if the sequences can be seen in both directions\\n    let forward = check_sequence(&stations, &first_sequence, &second_sequence);\\n    let backward = check_sequence(&stations.chars().rev().collect::<String>(), &first_sequence, &second_sequence);\\n\\n    \/\/ Output the result\\n    if forward && backward {\\n        println!(\\\"both\\\");\\n    } else if forward {\\n        println!(\\\"forward\\\");\\n    } else if backward {\\n        println!(\\\"backward\\\");\\n    } else {\\n        println!(\\\"fantasy\\\");\\n    }\\n}\\n\\nfn check_sequence(stations: &str, first_sequence: &str, second_sequence: &str) -> bool {\\n    let mut index = 0;\\n\\n    \/\/ Check if the first sequence can be found\\n    for c in first_sequence.chars() {\\n        if let Some(i) = stations[index..].find(c) {\\n            index += i + 1;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    \/\/ Check if the second sequence can be found\\n    for c in second_sequence.chars() {\\n        if let Some(i) = stations[index..].find(c) {\\n            index += i + 1;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    true\\n}"}
{"title":"E. Beads","description":"One Martian boy called Zorg wants to present a string of beads to his friend from the Earth \u2014 Masha. He knows that Masha likes two colours: blue and red, \u2014 and right in the shop where he has come, there is a variety of adornments with beads of these two colours. All the strings of beads have a small fastener, and if one unfastens it, one might notice that all the strings of beads in the shop are of the same length. Because of the peculiarities of the Martian eyesight, if Zorg sees one blue-and-red string of beads first, and then the other with red beads instead of blue ones, and blue \u2014 instead of red, he regards these two strings of beads as identical. In other words, Zorg regards as identical not only those strings of beads that can be derived from each other by the string turnover, but as well those that can be derived from each other by a mutual replacement of colours and\/or by the string turnover.It is known that all Martians are very orderly, and if a Martian sees some amount of objects, he tries to put them in good order. Zorg thinks that a red bead is smaller than a blue one. Let's put 0 for a red bead, and 1 \u2014 for a blue one. From two strings the Martian puts earlier the string with a red bead in the i-th position, providing that the second string has a blue bead in the i-th position, and the first two beads i-1 are identical.At first Zorg unfastens all the strings of beads, and puts them into small heaps so, that in each heap strings are identical, in his opinion. Then he sorts out the heaps and chooses the minimum string in each heap, in his opinion. He gives the unnecassary strings back to the shop assistant and says he doesn't need them any more. Then Zorg sorts out the remaining strings of beads and buys the string with index k. All these manupulations will take Zorg a lot of time, that's why he asks you to help and find the string of beads for Masha.","input_from":"standard input","output_to":"standard output","time_limit":"5 seconds","memory_limit":"64 megabytes","input_spec":"The input file contains two integers n and k (2\u2264n\u226450;1\u2264k\u226410^16) \u2014the length of a string of beads, and the index of the string, chosen by Zorg. \n","output_spec":"Output the k-th string of beads, putting 0 for a red bead, and 1 \u2014 for a blue one. If it s impossible to find the required string, output the only number -1.\n","notes":"Let's consider the example of strings of length 4 \u2014 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110. Zorg will divide them into heaps: {0001, 0111, 1000, 1110}, {0010, 0100, 1011, 1101}, {0011, 1100}, {0101, 1010}, {0110, 1001}. Then he will choose the minimum strings of beads in each heap: 0001, 0010, 0011, 0101, 0110. The forth string \u2014 0101.\n","sample_inputs":["4 4\n"],"sample_outputs":["0101\n"],"id":"8-E","difficulty":2600,"tags":["dp","graphs"],"src_uid":"0a4a418dafaee71f1b31c928fc2ad24a","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <cmath>\\n\\nusing namespace std;\\n\\n\/\/ Function to generate all possible strings of beads\\nvoid generateStrings(int n, vector<string>& strings, string currentString, int index, bool redUsed, bool blueUsed) {\\n    \/\/ Base case: if index reaches n\\n    if (index == n) {\\n        strings.push_back(currentString);\\n        return;\\n    }\\n\\n    \/\/ If red bead is not used, add red bead to the current string\\n    if (!redUsed) {\\n        generateStrings(n, strings, currentString + '0', index + 1, true, blueUsed);\\n    }\\n\\n    \/\/ If blue bead is not used, add blue bead to the current string\\n    if (!blueUsed) {\\n        generateStrings(n, strings, currentString + '1', index + 1, redUsed, true);\\n    }\\n}\\n\\nint main() {\\n    int n, k;\\n    cin >> n >> k;\\n\\n    \/\/ Generate all possible strings of beads\\n    vector<string> strings;\\n    generateStrings(n, strings, \\\"\\\", 0, false, false);\\n\\n    \/\/ Sort the strings in lexicographical order\\n    sort(strings.begin(), strings.end());\\n\\n    \/\/ If k is greater than the number of strings, output -1\\n    if (k > strings.size()) {\\n        cout << -1 << endl;\\n        return 0;\\n    }\\n\\n    \/\/ Output the k-th string\\n    cout << strings[k - 1] << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] inputArr = input.split(\\\" \\\");\n        int n = Integer.parseInt(inputArr[0]);\n        long k = Long.parseLong(inputArr[1]);\n        \n        \/\/ Calculate the total number of strings\n        long totalStrings = (long) Math.pow(2, n);\n        \n        \/\/ Check if k is within the valid range\n        if (k > totalStrings) {\n            System.out.println(-1);\n            return;\n        }\n        \n        \/\/ Generate all possible strings\n        List<String> strings = new ArrayList<>();\n        for (long i = 0; i < totalStrings; i++) {\n            String binaryString = Long.toBinaryString(i);\n            while (binaryString.length() < n) {\n                binaryString = \\\"0\\\" + binaryString;\n            }\n            strings.add(binaryString);\n        }\n        \n        \/\/ Sort the strings based on the Martian's ordering rule\n        Collections.sort(strings, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                int redCount1 = countRedBeads(s1);\n                int redCount2 = countRedBeads(s2);\n                \n                if (redCount1 != redCount2) {\n                    return Integer.compare(redCount1, redCount2);\n                } else {\n                    return s1.compareTo(s2);\n                }\n            }\n        });\n        \n        \/\/ Print the k-th string\n        System.out.println(strings.get((int) (k - 1)));\n    }\n    \n    private static int countRedBeads(String string) {\n        int count = 0;\n        for (char c : string.toCharArray()) {\n            if (c == '0') {\n                count++;\n            }\n        }\n        return count;\n    }\n}","Python":"def get_kth_string(n, k):\n    def generate_strings(n):\n        if n == 1:\n            return ['0', '1']\n        else:\n            strings = []\n            for string in generate_strings(n-1):\n                strings.append(string + '0')\n                strings.append(string + '1')\n            return strings\n\n    def is_identical(string1, string2):\n        if string1 == string2:\n            return True\n        if string1[::-1] == string2:\n            return True\n        if string1.replace('0', '2').replace('1', '0').replace('2', '1') == string2:\n            return True\n        return False\n\n    strings = generate_strings(n)\n    heaps = []\n    for string in strings:\n        found = False\n        for heap in heaps:\n            if is_identical(string, heap[0]):\n                heap.append(string)\n                found = True\n                break\n        if not found:\n            heaps.append([string])\n\n    min_strings = []\n    for heap in heaps:\n        min_string = min(heap)\n        min_strings.append(min_string)\n\n    min_strings.sort()\n    if k > len(min_strings):\n        return '-1'\n    else:\n        return min_strings[k-1]\n\nn, k = map(int, input().split())\nresult = get_kth_string(n, k)\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n\/\/ Function to check if two strings are identical\\nint isIdentical(char* str1, char* str2, int len) {\\n    for (int i = 0; i < len; i++) {\\n        if (str1[i] != str2[i]) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\n\/\/ Function to check if two strings are reverse of each other\\nint isReverse(char* str1, char* str2, int len) {\\n    for (int i = 0; i < len; i++) {\\n        if (str1[i] != str2[len - i - 1]) {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n\\n\/\/ Function to generate all possible strings of beads\\nvoid generateStrings(char* str, int len, int index, char** strings, int* count) {\\n    if (index == len) {\\n        strings[*count] = malloc((len + 1) * sizeof(char));\\n        strcpy(strings[*count], str);\\n        (*count)++;\\n        return;\\n    }\\n\\n    str[index] = '0';\\n    generateStrings(str, len, index + 1, strings, count);\\n\\n    str[index] = '1';\\n    generateStrings(str, len, index + 1, strings, count);\\n}\\n\\n\/\/ Function to sort the strings based on Martian's order\\nvoid sortStrings(char** strings, int count, int len) {\\n    for (int i = 0; i < count - 1; i++) {\\n        for (int j = i + 1; j < count; j++) {\\n            if (isIdentical(strings[i], strings[j], len) || isReverse(strings[i], strings[j], len)) {\\n                char* temp = strings[i];\\n                strings[i] = strings[j];\\n                strings[j] = temp;\\n            }\\n        }\\n    }\\n}\\n\\n\/\/ Function to find the k-th string of beads\\nchar* findKthString(int n, long long k) {\\n    char* str = malloc((n + 1) * sizeof(char));\\n    char** strings = malloc((1 << n) * sizeof(char*));\\n    int count = 0;\\n\\n    generateStrings(str, n, 0, strings, &count);\\n    sortStrings(strings, count, n);\\n\\n    if (k > count) {\\n        return \\\"-1\\\";\\n    }\\n\\n    return strings[k - 1];\\n}\\n\\nint main() {\\n    int n;\\n    long long k;\\n    scanf(\\\"%d %lld\\\", &n, &k);\\n\\n    char* result = findKthString(n, k);\\n    printf(\\\"%s\\\\n\\\", result);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split();\n        int n = int.Parse(input[0]);\n        long k = long.Parse(input[1]);\n\n        \/\/ Calculate the total number of strings\n        long totalStrings = (long)Math.Pow(2, n);\n\n        \/\/ Check if k is within the valid range\n        if (k > totalStrings)\n        {\n            Console.WriteLine(-1);\n            return;\n        }\n\n        \/\/ Generate all possible strings\n        string[] strings = new string[totalStrings];\n        for (int i = 0; i < totalStrings; i++)\n        {\n            strings[i] = Convert.ToString(i, 2).PadLeft(n, '0');\n        }\n\n        \/\/ Divide the strings into heaps\n        string[] heaps = new string[n];\n        for (int i = 0; i < n; i++)\n        {\n            heaps[i] = \"\";\n        }\n\n        foreach (string str in strings)\n        {\n            int heapIndex = GetHeapIndex(str);\n            heaps[heapIndex] += str + \",\";\n        }\n\n        \/\/ Choose the minimum string from each heap\n        string result = \"\";\n        for (int i = 0; i < n; i++)\n        {\n            string[] heapStrings = heaps[i].Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);\n            Array.Sort(heapStrings);\n            result += heapStrings[0][i];\n        }\n\n        Console.WriteLine(result);\n    }\n\n    \/\/ Helper method to get the heap index for a given string\n    public static int GetHeapIndex(string str)\n    {\n        int count = 0;\n        for (int i = 1; i < str.Length; i++)\n        {\n            if (str[i] != str[i - 1])\n            {\n                count++;\n            }\n        }\n        return count;\n    }\n}","Ruby":"\ndef generate_strings(n)\n  strings = []\n  (0..(2**n - 1)).each do |i|\n    string = i.to_s(2).rjust(n, '0')\n    strings << string\n  end\n  strings\nend\n\ndef divide_into_heaps(strings)\n  heaps = []\n  strings.each do |string|\n    found = false\n    heaps.each do |heap|\n      if heap.all? { |s| s[0..1] == string[0..1] }\n        heap << string\n        found = true\n        break\n      end\n    end\n    heaps << [string] unless found\n  end\n  heaps\nend\n\ndef choose_minimum_strings(heaps)\n  minimum_strings = []\n  heaps.each do |heap|\n    minimum_string = heap.min_by { |s| s.gsub('0', 'a').gsub('1', 'b') }\n    minimum_strings << minimum_string\n  end\n  minimum_strings\nend\n\ndef find_kth_string(n, k)\n  strings = generate_strings(n)\n  heaps = divide_into_heaps(strings)\n  minimum_strings = choose_minimum_strings(heaps)\n  if k > minimum_strings.length\n    return -1\n  else\n    return minimum_strings[k - 1]\n  end\nend\n\nn, k = gets.chomp.split.map(&:to_i)\nputs find_kth_string(n, k)\n","delphi":"program MartianBeads;\\n\\nvar\\n  n, k: Integer;\\n  result: String;\\n\\nfunction ReverseString(s: String): String;\\nvar\\n  i: Integer;\\nbegin\\n  Result := '';\\n  for i := Length(s) downto 1 do\\n    Result := Result + s[i];\\nend;\\n\\nprocedure GenerateStrings(s: String; var strings: TStringList);\\nvar\\n  i: Integer;\\nbegin\\n  if Length(s) = n then\\n  begin\\n    strings.Add(s);\\n    Exit;\\n  end;\\n  GenerateStrings(s + '0', strings);\\n  GenerateStrings(s + '1', strings);\\nend;\\n\\nprocedure SortStrings(var strings: TStringList);\\nvar\\n  i, j: Integer;\\n  temp: String;\\nbegin\\n  for i := 0 to strings.Count - 2 do\\n  begin\\n    for j := i + 1 to strings.Count - 1 do\\n    begin\\n      if (strings[i] > strings[j]) or ((strings[i] = strings[j]) and (ReverseString(strings[i]) > strings[j])) then\\n      begin\\n        temp := strings[i];\\n        strings[i] := strings[j];\\n        strings[j] := temp;\\n      end;\\n    end;\\n  end;\\nend;\\n\\nbegin\\n  ReadLn(n, k);\\n  result := '-1';\\n  if (n >= 2) and (n <= 50) and (k >= 1) and (k <= Int64Power(2, n)) then\\n  begin\\n    var strings: TStringList := TStringList.Create;\\n    GenerateStrings('', strings);\\n    SortStrings(strings);\\n    if k <= strings.Count then\\n      result := strings[k - 1];\\n  end;\\n  WriteLn(result);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scan(&n, &k)\\n\\n\\t\/\/ Generate all possible strings of beads\\n\\tstrings := generateStrings(n)\\n\\n\\t\/\/ Divide the strings into heaps\\n\\theaps := divideIntoHeaps(strings)\\n\\n\\t\/\/ Choose the minimum string in each heap\\n\\tminStrings := chooseMinStrings(heaps)\\n\\n\\t\/\/ Check if k is within the range of possible strings\\n\\tif k > len(minStrings) {\\n\\t\\tfmt.Println(-1)\\n\\t\\treturn\\n\\t}\\n\\n\\t\/\/ Print the k-th string\\n\\tfmt.Println(minStrings[k-1])\\n}\\n\\n\/\/ Function to generate all possible strings of beads\\nfunc generateStrings(n int) []string {\\n\\tvar strings []string\\n\\n\\tfor i := 0; i < (1 << n); i++ {\\n\\t\\tstr := strconv.FormatInt(int64(i), 2)\\n\\t\\tfor len(str) < n {\\n\\t\\t\\tstr = \\\"0\\\" + str\\n\\t\\t}\\n\\t\\tstrings = append(strings, str)\\n\\t}\\n\\n\\treturn strings\\n}\\n\\n\/\/ Function to divide the strings into heaps\\nfunc divideIntoHeaps(strings []string) map[string][]string {\\n\\theaps := make(map[string][]string)\\n\\n\\tfor _, str := range strings {\\n\\t\\theap := str\\n\\t\\tif str[0] == '1' {\\n\\t\\t\\theap = reverseString(heap)\\n\\t\\t}\\n\\t\\theaps[heap] = append(heaps[heap], str)\\n\\t}\\n\\n\\treturn heaps\\n}\\n\\n\/\/ Function to reverse a string\\nfunc reverseString(str string) string {\\n\\truneStr := []rune(str)\\n\\tfor i, j := 0, len(runeStr)-1; i < j; i, j = i+1, j-1 {\\n\\t\\truneStr[i], runeStr[j] = runeStr[j], runeStr[i]\\n\\t}\\n\\treturn string(runeStr)\\n}\\n\\n\/\/ Function to choose the minimum string in each heap\\nfunc chooseMinStrings(heaps map[string][]string) []string {\\n\\tvar minStrings []string\\n\\n\\tfor _, strings := range heaps {\\n\\t\\tminString := strings[0]\\n\\t\\tfor _, str := range strings {\\n\\t\\t\\tif str < minString {\\n\\t\\t\\t\\tminString = str\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tminStrings = append(minStrings, minString)\\n\\t}\\n\\n\\treturn minStrings\\n}","Javascript":"function getKthString(n, k) {\n    let strings = generateStrings(n);\n    let heaps = divideIntoHeaps(strings);\n    let minStrings = chooseMinStrings(heaps);\n    \n    if (k > minStrings.length) {\n        return '-1';\n    } else {\n        return minStrings[k - 1];\n    }\n}\n\nfunction generateStrings(n) {\n    let strings = [];\n    let max = Math.pow(2, n);\n    \n    for (let i = 0; i < max; i++) {\n        let binary = i.toString(2).padStart(n, '0');\n        strings.push(binary);\n    }\n    \n    return strings;\n}\n\nfunction divideIntoHeaps(strings) {\n    let heaps = [];\n    \n    for (let i = 0; i < strings.length; i++) {\n        let string = strings[i];\n        let foundHeap = false;\n        \n        for (let j = 0; j < heaps.length; j++) {\n            let heap = heaps[j];\n            \n            if (isIdentical(string, heap[0])) {\n                heap.push(string);\n                foundHeap = true;\n                break;\n            }\n        }\n        \n        if (!foundHeap) {\n            heaps.push([string]);\n        }\n    }\n    \n    return heaps;\n}\n\nfunction isIdentical(string1, string2) {\n    if (string1 === string2) {\n        return true;\n    }\n    \n    let reversedString1 = string1.split('').reverse().join('');\n    let reversedString2 = string2.split('').reverse().join('');\n    \n    if (string1 === reversedString2 || reversedString1 === string2) {\n        return true;\n    }\n    \n    return false;\n}\n\nfunction chooseMinStrings(heaps) {\n    let minStrings = [];\n    \n    for (let i = 0; i < heaps.length; i++) {\n        let heap = heaps[i];\n        let minString = heap[0];\n        \n        for (let j = 1; j < heap.length; j++) {\n            if (isSmaller(heap[j], minString)) {\n                minString = heap[j];\n            }\n        }\n        \n        minStrings.push(minString);\n    }\n    \n    return minStrings;\n}\n\nfunction isSmaller(string1, string2) {\n    let count1 = countRedBeads(string1);\n    let count2 = countRedBeads(string2);\n    \n    if (count1 < count2) {\n        return true;\n    } else if (count1 === count2 && string1 < string2) {\n        return true;\n    }\n    \n    return false;\n}\n\nfunction countRedBeads(string) {\n    let count = 0;\n    \n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === '0') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n\n\/\/ Example usage\nconsole.log(getKthString(4, 4));","Kotlin":"import java.util.*\n\nfun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val k = input[1].toLong()\n\n    val strings = mutableListOf<String>()\n    generateStrings(n, \"\", strings)\n\n    val heaps = divideIntoHeaps(strings)\n    val minStrings = getMinStrings(heaps)\n\n    val result = if (k <= minStrings.size) minStrings[k.toInt() - 1] else \"-1\"\n    println(result)\n}\n\nfun generateStrings(n: Int, current: String, strings: MutableList<String>) {\n    if (current.length == n) {\n        strings.add(current)\n        return\n    }\n\n    generateStrings(n, current + \"0\", strings)\n    generateStrings(n, current + \"1\", strings)\n}\n\nfun divideIntoHeaps(strings: List<String>): List<List<String>> {\n    val heaps = mutableListOf<MutableList<String>>()\n    val visited = BooleanArray(strings.size)\n\n    for (i in strings.indices) {\n        if (!visited[i]) {\n            val heap = mutableListOf<String>()\n            heap.add(strings[i])\n            visited[i] = true\n\n            for (j in i + 1 until strings.size) {\n                if (!visited[j] && isEquivalent(strings[i], strings[j])) {\n                    heap.add(strings[j])\n                    visited[j] = true\n                }\n            }\n\n            heaps.add(heap)\n        }\n    }\n\n    return heaps\n}\n\nfun isEquivalent(s1: String, s2: String): Boolean {\n    return s1 == s2 || s1 == s2.reversed() || s1 == s2.map { if (it == '0') '1' else '0' }.reversed()\n}\n\nfun getMinStrings(heaps: List<List<String>>): List<String> {\n    val minStrings = mutableListOf<String>()\n\n    for (heap in heaps) {\n        var minString = heap[0]\n\n        for (i in 1 until heap.size) {\n            if (isSmaller(heap[i], minString)) {\n                minString = heap[i]\n            }\n        }\n\n        minStrings.add(minString)\n    }\n\n    return minStrings\n}\n\nfun isSmaller(s1: String, s2: String): Boolean {\n    for (i in s1.indices) {\n        if (s1[i] < s2[i]) {\n            return true\n        } else if (s1[i] > s2[i]) {\n            return false\n        }\n    }\n\n    return false\n}","PHP":"\n<?php\n\nfunction getKthStringOfBeads($n, $k) {\n    \/\/ Generate all possible strings of beads\n    $strings = generateStrings($n);\n    \n    \/\/ Divide the strings into heaps\n    $heaps = divideIntoHeaps($strings);\n    \n    \/\/ Choose the minimum string in each heap\n    $minimumStrings = chooseMinimumStrings($heaps);\n    \n    \/\/ Check if k is within the range of possible strings\n    if ($k > count($minimumStrings)) {\n        return -1;\n    }\n    \n    \/\/ Return the k-th string\n    return $minimumStrings[$k - 1];\n}\n\nfunction generateStrings($n) {\n    $strings = [];\n    \n    \/\/ Generate all possible combinations of 0s and 1s\n    for ($i = 0; $i < pow(2, $n); $i++) {\n        $binary = str_pad(decbin($i), $n, '0', STR_PAD_LEFT);\n        $strings[] = $binary;\n    }\n    \n    return $strings;\n}\n\nfunction divideIntoHeaps($strings) {\n    $heaps = [];\n    \n    foreach ($strings as $string) {\n        $heapFound = false;\n        \n        foreach ($heaps as &$heap) {\n            if (isHeap($string, $heap[0])) {\n                $heap[] = $string;\n                $heapFound = true;\n                break;\n            }\n        }\n        \n        if (!$heapFound) {\n            $heaps[] = [$string];\n        }\n    }\n    \n    return $heaps;\n}\n\nfunction isHeap($string1, $string2) {\n    $n = strlen($string1);\n    \n    \/\/ Check if the first two beads are identical\n    if (substr($string1, 0, 2) !== substr($string2, 0, 2)) {\n        return false;\n    }\n    \n    \/\/ Check if the colors can be derived from each other by a mutual replacement\n    for ($i = 0; $i < $n; $i++) {\n        if ($string1[$i] === '0' && $string2[$i] === '1') {\n            return false;\n        }\n        \n        if ($string1[$i] === '1' && $string2[$i] === '0') {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nfunction chooseMinimumStrings($heaps) {\n    $minimumStrings = [];\n    \n    foreach ($heaps as $heap) {\n        $minimumString = $heap[0];\n        \n        foreach ($heap as $string) {\n            if (isSmaller($string, $minimumString)) {\n                $minimumString = $string;\n            }\n        }\n        \n        $minimumStrings[] = $minimumString;\n    }\n    \n    return $minimumStrings;\n}\n\nfunction isSmaller($string1, $string2) {\n    $n = strlen($string1);\n    \n    for ($i = 0; $i < $n; $i++) {\n        if ($string1[$i] === '0' && $string2[$i] === '1') {\n            return true;\n        }\n        \n        if ($string1[$i] === '1' && $string2[$i] === '0') {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n\/\/ Example usage\n$n = 4;\n$k = 4;\n\n$result = getKthStringOfBeads($n, $k);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nstring getKthString(int n, ulong k)\\r\\n{\\r\\n    ulong totalStrings = 1UL << n;\\r\\n    if (k > totalStrings)\\r\\n    {\\r\\n        return \\\"-1\\\";\\r\\n    }\\r\\n\\r\\n    ulong halfStrings = totalStrings \/ 2;\\r\\n    if (k <= halfStrings)\\r\\n    {\\r\\n        return std.conv.to!string(k - 1);\\r\\n    }\\r\\n\\r\\n    ulong remainingStrings = totalStrings - halfStrings;\\r\\n    ulong remainingK = k - halfStrings;\\r\\n\\r\\n    string remainingString = getKthString(n - 1, remainingK);\\r\\n\\r\\n    if (remainingString == \\\"-1\\\")\\r\\n    {\\r\\n        return \\\"-1\\\";\\r\\n    }\\r\\n\\r\\n    return \\\"1\\\" ~ remainingString;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    ulong k;\\r\\n    readf(\\\"%d %lu\\\", &n, &k);\\r\\n\\r\\n    string result = getKthString(n, k);\\r\\n\\r\\n    writeln(result);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub generate_strings {\n    my ($n) = @_;\n    my @strings = ();\n    \n    for my $i (0..(2**$n - 1)) {\n        my $string = sprintf(\"%0${n}b\", $i);\n        push @strings, $string;\n    }\n    \n    return @strings;\n}\n\nsub divide_into_heaps {\n    my ($n, @strings) = @_;\n    my %heaps = ();\n    \n    for my $string (@strings) {\n        my $reversed_string = reverse $string;\n        my $heap_key = $string le $reversed_string ? $string : $reversed_string;\n        push @{$heaps{$heap_key}}, $string;\n    }\n    \n    return %heaps;\n}\n\nsub choose_minimum_strings {\n    my (%heaps) = @_;\n    my @minimum_strings = ();\n    \n    for my $heap_key (keys %heaps) {\n        my @strings = @{$heaps{$heap_key}};\n        my $minimum_string = (sort @strings)[0];\n        push @minimum_strings, $minimum_string;\n    }\n    \n    return @minimum_strings;\n}\n\nsub find_kth_string {\n    my ($k, @minimum_strings) = @_;\n    \n    if ($k > scalar @minimum_strings) {\n        return -1;\n    }\n    \n    return $minimum_strings[$k - 1];\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k) = split ' ', $input;\n\n# Generate all possible strings\nmy @strings = generate_strings($n);\n\n# Divide strings into heaps\nmy %heaps = divide_into_heaps($n, @strings);\n\n# Choose minimum strings from each heap\nmy @minimum_strings = choose_minimum_strings(%heaps);\n\n# Find the k-th string\nmy $kth_string = find_kth_string($k, @minimum_strings);\n\n# Output the result\nprint $kth_string;\n","Rust":"fn main() {\\n    let input = std::fs::read_to_string(\\\"input.txt\\\").unwrap();\\n    let mut lines = input.lines();\\n    let nk: Vec<usize> = lines\\n        .next()\\n        .unwrap()\\n        .split_whitespace()\\n        .map(|x| x.parse().unwrap())\\n        .collect();\\n    let n = nk[0];\\n    let k = nk[1];\\n\\n    let mut strings: Vec<String> = Vec::new();\\n\\n    for i in 0..(1 << n) {\\n        let binary = format!(\"{:0width$b}\", i, width = n);\\n        strings.push(binary);\\n    }\\n\\n    let mut heaps: Vec<Vec<String>> = Vec::new();\\n\\n    for i in 0..strings.len() {\\n        let mut found = false;\\n        for heap in &mut heaps {\\n            if is_identical(&strings[i], &heap[0]) {\\n                heap.push(strings[i].clone());\\n                found = true;\\n                break;\\n            }\\n        }\\n        if !found {\\n            heaps.push(vec![strings[i].clone()]);\\n        }\\n    }\\n\\n    let mut min_strings: Vec<String> = Vec::new();\\n\\n    for heap in heaps {\\n        let min_string = heap.iter().min().unwrap().clone();\\n        min_strings.push(min_string);\\n    }\\n\\n    min_strings.sort();\\n\\n    if k > min_strings.len() {\\n        println!(\\\"-1\\\");\\n    } else {\\n        println!(\\\"{}\\\", min_strings[k - 1]);\\n    }\\n}\\n\\nfn is_identical(string1: &str, string2: &str) -> bool {\\n    let reversed_string2: String = string2.chars().rev().collect();\\n    string1 == string2 || string1 == &reversed_string2\\n}"}
{"title":"B. African Crossword","description":"An African crossword is a rectangular table n\u00d7m in size. Each cell of the table contains exactly one letter. This table (it is also referred to as grid) contains some encrypted word that needs to be decoded.To solve the crossword you should cross out all repeated letters in rows and columns. In other words, a letter should only be crossed out if and only if the corresponding column or row contains at least one more letter that is exactly the same. Besides, all such letters are crossed out simultaneously.When all repeated letters have been crossed out, we should write the remaining letters in a string. The letters that occupy a higher position follow before the letters that occupy a lower position. If the letters are located in one row, then the letter to the left goes first. The resulting word is the answer to the problem.You are suggested to solve an African crossword and print the word encrypted there.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m (1\u2264n,m\u2264100). Next n lines contain m lowercase Latin letters each. That is the crossword grid.\n","output_spec":"Print the encrypted word on a single line. It is guaranteed that the answer consists of at least one letter.\n","notes":null,"sample_inputs":["3 3\ncba\nbcd\ncbc\n","5 5\nfcofd\nooedo\nafaoa\nrdcdf\neofsf\n"],"sample_outputs":["abcd","codeforces"],"id":"90-B","difficulty":1100,"tags":["implementation","strings"],"src_uid":"9c90974a0bb860a5e180760042fd5045","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n    vector<string> grid(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> grid[i];\\n    }\\n\\n    vector<vector<int>> rowFreq(n, vector<int>(26, 0));\\n    vector<vector<int>> colFreq(m, vector<int>(26, 0));\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            rowFreq[i][grid[i][j] - 'a']++;\\n            colFreq[j][grid[i][j] - 'a']++;\\n        }\\n    }\\n\\n    string encryptedWord;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (rowFreq[i][grid[i][j] - 'a'] > 1 || colFreq[j][grid[i][j] - 'a'] > 1) {\\n                grid[i][j] = '*';\\n            }\\n            if (grid[i][j] != '*') {\\n                encryptedWord += grid[i][j];\\n            }\\n        }\\n    }\\n\\n    cout << encryptedWord << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class AfricanCrossword {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine();\n        \n        char[][] crossword = new char[n][m];\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < m; j++) {\n                crossword[i][j] = line.charAt(j);\n            }\n        }\n        \n        StringBuilder encryptedWord = new StringBuilder();\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char currentChar = crossword[i][j];\n                boolean isRepeated = false;\n                \n                \/\/ Check if the current character is repeated in the row\n                for (int k = 0; k < m; k++) {\n                    if (k != j && crossword[i][k] == currentChar) {\n                        isRepeated = true;\n                        break;\n                    }\n                }\n                \n                \/\/ Check if the current character is repeated in the column\n                if (!isRepeated) {\n                    for (int k = 0; k < n; k++) {\n                        if (k != i && crossword[k][j] == currentChar) {\n                            isRepeated = true;\n                            break;\n                        }\n                    }\n                }\n                \n                \/\/ If the character is not repeated, add it to the encrypted word\n                if (!isRepeated) {\n                    encryptedWord.append(currentChar);\n                }\n            }\n        }\n        \n        System.out.println(encryptedWord.toString());\n    }\n}","Python":"def solve_african_crossword(n, m, grid):\n    rows = [set(row) for row in grid]\n    cols = [set(col) for col in zip(*grid)]\n    \n    encrypted_word = ''\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] not in rows[i] and grid[i][j] not in cols[j]:\n                encrypted_word += grid[i][j]\n    \n    return encrypted_word\n\n# Sample inputs\ninputs = ['3 3\\\\ncba\\\\nbcd\\\\ncbc\\\\n', '5 5\\\\nfcofd\\\\nooedo\\\\nafaoa\\\\nrdcdf\\\\neofsf\\\\n']\noutputs = []\n\nfor input_str in inputs:\n    input_lines = input_str.strip().split('\\\\n')\n    n, m = map(int, input_lines[0].split())\n    grid = [line for line in input_lines[1:]]\n    \n    output = solve_african_crossword(n, m, grid)\n    outputs.append(output)\n\n# Print outputs\nfor output in outputs:\n    print(output)\n","C":"#include <stdio.h>\\n#include <stdbool.h>\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    char grid[n][m];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%s\\\", grid[i]);\\n    }\\n\\n    bool crossedOut[n][m];\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            crossedOut[i][j] = false;\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            char currentLetter = grid[i][j];\\n            bool isRepeated = false;\\n\\n            \/\/ Check if current letter is repeated in the row\\n            for (int k = 0; k < m; k++) {\\n                if (k != j && grid[i][k] == currentLetter) {\\n                    isRepeated = true;\\n                    break;\\n                }\\n            }\\n\\n            \/\/ Check if current letter is repeated in the column\\n            if (!isRepeated) {\\n                for (int k = 0; k < n; k++) {\\n                    if (k != i && grid[k][j] == currentLetter) {\\n                        isRepeated = true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (isRepeated) {\\n                crossedOut[i][j] = true;\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (!crossedOut[i][j]) {\\n                printf(\\\"%c\\\", grid[i][j]);\\n            }\\n        }\\n    }\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace AfricanCrossword\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Read input\n            string[] input = Console.ReadLine().Split();\n            int n = int.Parse(input[0]);\n            int m = int.Parse(input[1]);\n\n            \/\/ Read crossword grid\n            char[][] grid = new char[n][];\n            for (int i = 0; i < n; i++)\n            {\n                grid[i] = Console.ReadLine().ToCharArray();\n            }\n\n            \/\/ Cross out repeated letters\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    bool isRepeated = false;\n\n                    \/\/ Check if letter is repeated in the row\n                    for (int k = 0; k < m; k++)\n                    {\n                        if (k != j && grid[i][k] == grid[i][j])\n                        {\n                            isRepeated = true;\n                            break;\n                        }\n                    }\n\n                    \/\/ Check if letter is repeated in the column\n                    if (!isRepeated)\n                    {\n                        for (int k = 0; k < n; k++)\n                        {\n                            if (k != i && grid[k][j] == grid[i][j])\n                            {\n                                isRepeated = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    \/\/ Cross out letter if it is repeated\n                    if (isRepeated)\n                    {\n                        grid[i][j] = '-';\n                    }\n                }\n            }\n\n            \/\/ Build encrypted word\n            List<char> encryptedWord = new List<char>();\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if (grid[i][j] != '-')\n                    {\n                        encryptedWord.Add(grid[i][j]);\n                    }\n                }\n            }\n\n            \/\/ Print encrypted word\n            Console.WriteLine(string.Join(\"\", encryptedWord));\n        }\n    }\n}","Ruby":"\ndef african_crossword(n, m, grid)\n  # Create a 2D array to store the crossword grid\n  crossword = Array.new(n) { Array.new(m) }\n\n  # Fill the crossword grid with the given letters\n  grid.each_with_index do |row, i|\n    row.chars.each_with_index do |letter, j|\n      crossword[i][j] = letter\n    end\n  end\n\n  # Cross out repeated letters in rows\n  crossword.each do |row|\n    row.uniq.each do |letter|\n      row.each_with_index do |cell, index|\n        row[index] = '-' if cell == letter && row.count(letter) > 1\n      end\n    end\n  end\n\n  # Cross out repeated letters in columns\n  crossword.transpose.each do |column|\n    column.uniq.each do |letter|\n      column.each_with_index do |cell, index|\n        column[index] = '-' if cell == letter && column.count(letter) > 1\n      end\n    end\n  end\n\n  # Create the encrypted word by joining the remaining letters\n  encrypted_word = crossword.flatten.reject { |letter| letter == '-' }.join('')\n\n  return encrypted_word\nend\n\n# Read the input from standard input\ninput = gets.chomp.split('\\n')\nn, m = input.shift.split(' ').map(&:to_i)\ngrid = input\n\n# Call the african_crossword method and print the result\nputs african_crossword(n, m, grid)\n","delphi":"program AfricanCrossword;\\n\\nvar\\n  n, m, i, j: integer;\\n  grid: array of array of char;\\n  word: string;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n, m);\\n  SetLength(grid, n, m);\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      read(grid[i, j]);\\n    end;\\n    readln;\\n  end;\\n\\n  \/\/ Cross out repeated letters\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      if (grid[i, j] <> ' ') and (grid[i, j] <> '*') then\\n      begin\\n        for k := j+1 to m-1 do\\n        begin\\n          if grid[i, k] = grid[i, j] then\\n          begin\\n            grid[i, k] := '*';\\n            grid[i, j] := '*';\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  for j := 0 to m-1 do\\n  begin\\n    for i := 0 to n-1 do\\n    begin\\n      if (grid[i, j] <> ' ') and (grid[i, j] <> '*') then\\n      begin\\n        for k := i+1 to n-1 do\\n        begin\\n          if grid[k, j] = grid[i, j] then\\n          begin\\n            grid[k, j] := '*';\\n            grid[i, j] := '*';\\n          end;\\n        end;\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Build the encrypted word\\n  for i := 0 to n-1 do\\n  begin\\n    for j := 0 to m-1 do\\n    begin\\n      if grid[i, j] <> '*' then\\n      begin\\n        word := word + grid[i, j];\\n      end;\\n    end;\\n  end;\\n\\n  \/\/ Print the encrypted word\\n  writeln(word);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\n\\tgrid := make([]string, n)\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%s\\\", &grid[i])\\n\\t}\\n\\n\\tcrossedOut := make([][]bool, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tcrossedOut[i] = make([]bool, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif !crossedOut[i][j] {\\n\\t\\t\\t\\tletter := grid[i][j]\\n\\t\\t\\t\\tcrossedOut[i][j] = true\\n\\n\\t\\t\\t\\tfor k := j + 1; k < m; k++ {\\n\\t\\t\\t\\t\\tif grid[i][k] == letter {\\n\\t\\t\\t\\t\\t\\tcrossedOut[i][k] = true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor k := i + 1; k < n; k++ {\\n\\t\\t\\t\\t\\tif grid[k][j] == letter {\\n\\t\\t\\t\\t\\t\\tcrossedOut[k][j] = true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar encryptedWord string\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tif !crossedOut[i][j] {\\n\\t\\t\\t\\tencryptedWord += string(grid[i][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(encryptedWord)\\n}","Javascript":"function solveAfricanCrossword(input) {\n  \/\/ Parse the input\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const grid = lines.slice(1, n + 1).map(line => line.split(''));\n\n  \/\/ Create a set to store crossed out letters\n  const crossedOut = new Set();\n\n  \/\/ Cross out repeated letters in rows\n  for (let i = 0; i < n; i++) {\n    const row = grid[i];\n    const counts = {};\n    for (let j = 0; j < m; j++) {\n      const letter = row[j];\n      if (counts[letter]) {\n        crossedOut.add(letter);\n      } else {\n        counts[letter] = true;\n      }\n    }\n  }\n\n  \/\/ Cross out repeated letters in columns\n  for (let j = 0; j < m; j++) {\n    const column = [];\n    for (let i = 0; i < n; i++) {\n      const letter = grid[i][j];\n      if (column.includes(letter)) {\n        crossedOut.add(letter);\n      } else {\n        column.push(letter);\n      }\n    }\n  }\n\n  \/\/ Build the encrypted word\n  let encryptedWord = '';\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      const letter = grid[i][j];\n      if (!crossedOut.has(letter)) {\n        encryptedWord += letter;\n      }\n    }\n  }\n\n  return encryptedWord;\n}\n\n\/\/ Test the function with the sample inputs\nconst inputs = ['3 3\\\\ncba\\\\nbcd\\\\ncbc\\\\n', '5 5\\\\nfcofd\\\\nooedo\\\\nafaoa\\\\nrdcdf\\\\neofsf\\\\n'];\nconst outputs = inputs.map(solveAfricanCrossword);\n\nconsole.log(outputs.join('\\\\n'));","Kotlin":"fun main() {\n    val input = readLine()!!.split(\" \")\n    val n = input[0].toInt()\n    val m = input[1].toInt()\n    \n    val grid = mutableListOf<String>()\n    for (i in 0 until n) {\n        grid.add(readLine()!!)\n    }\n    \n    val crossedOutRows = mutableSetOf<Int>()\n    val crossedOutCols = mutableSetOf<Int>()\n    \n    for (i in 0 until n) {\n        for (j in 0 until m) {\n            if (grid[i].count { it == grid[i][j] } > 1) {\n                crossedOutRows.add(i)\n                crossedOutCols.add(j)\n            }\n        }\n    }\n    \n    val encryptedWord = StringBuilder()\n    for (i in 0 until n) {\n        if (i !in crossedOutRows) {\n            for (j in 0 until m) {\n                if (j !in crossedOutCols) {\n                    encryptedWord.append(grid[i][j])\n                }\n            }\n        }\n    }\n    \n    println(encryptedWord.toString())\n}","PHP":"<?php\\n\\nfunction solveAfricanCrossword($input) {\\n    $lines = explode(\\\"\\\\n\\\", $input);\\n    $dimensions = explode(\\\" \\\", $lines[0]);\\n    $n = intval($dimensions[0]);\\n    $m = intval($dimensions[1]);\\n    $grid = array_slice($lines, 1, $n);\\n    $crossedOut = array_fill(0, $n, array_fill(0, $m, false));\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        for ($j = 0; $j < $m; $j++) {\\n            $letter = $grid[$i][$j];\\n\\n            if (countLettersInRow($grid, $letter, $i) > 1 || countLettersInColumn($grid, $letter, $j) > 1) {\\n                $crossedOut[$i][$j] = true;\\n            }\\n        }\\n    }\\n\\n    $encryptedWord = \\\"\\\";\\n\\n    for ($i = 0; $i < $n; $i++) {\\n        for ($j = 0; $j < $m; $j++) {\\n            if (!$crossedOut[$i][$j]) {\\n                $encryptedWord .= $grid[$i][$j];\\n            }\\n        }\\n    }\\n\\n    return $encryptedWord;\\n}\\n\\nfunction countLettersInRow($grid, $letter, $row) {\\n    return substr_count($grid[$row], $letter);\\n}\\n\\nfunction countLettersInColumn($grid, $letter, $column) {\\n    $count = 0;\\n\\n    foreach ($grid as $row) {\\n        if ($row[$column] === $letter) {\\n            $count++;\\n        }\\n    }\\n\\n    return $count;\\n}\\n\\n$input = '3 3\\\\ncba\\\\nbcd\\\\ncbc\\\\n';\\n$output = solveAfricanCrossword($input);\\necho $output;\\n","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    char[][] grid = new char[][](n);\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        readf(\\\"%s\\\", &grid[i]);\\r\\n    }\\r\\n\\r\\n    char[][] result = new char[][](n);\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        result[i] = grid[i].uniq;\\r\\n    }\\r\\n\\r\\n    foreach (j; 0..m)\\r\\n    {\\r\\n        char[] column = new char[](n);\\r\\n\\r\\n        foreach (i; 0..n)\\r\\n        {\\r\\n            column[i] = grid[i][j];\\r\\n        }\\r\\n\\r\\n        column = column.uniq;\\r\\n\\r\\n        foreach (i; 0..n)\\r\\n        {\\r\\n            if (result[i].length > column.length)\\r\\n            {\\r\\n                result[i] = result[i] ~ column;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                result[i] = column ~ result[i];\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    foreach (i; 0..n)\\r\\n    {\\r\\n        write(result[i]);\\r\\n    }\\r\\n}","perl":"\n# Read input\nmy $input = <>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\nmy @grid;\nfor (my $i = 0; $i < $n; $i++) {\n    my $line = <>;\n    chomp $line;\n    push @grid, [split '', $line];\n}\n\n# Cross out repeated letters in rows\nfor (my $i = 0; $i < $n; $i++) {\n    my %count;\n    for (my $j = 0; $j < $m; $j++) {\n        $count{$grid[$i][$j]}++;\n    }\n    for (my $j = 0; $j < $m; $j++) {\n        if ($count{$grid[$i][$j]} > 1) {\n            $grid[$i][$j] = '';\n        }\n    }\n}\n\n# Cross out repeated letters in columns\nfor (my $j = 0; $j < $m; $j++) {\n    my %count;\n    for (my $i = 0; $i < $n; $i++) {\n        $count{$grid[$i][$j]}++;\n    }\n    for (my $i = 0; $i < $n; $i++) {\n        if ($count{$grid[$i][$j]} > 1) {\n            $grid[$i][$j] = '';\n        }\n    }\n}\n\n# Build the encrypted word\nmy $encrypted_word = '';\nfor (my $i = 0; $i < $n; $i++) {\n    for (my $j = 0; $j < $m; $j++) {\n        if ($grid[$i][$j] ne '') {\n            $encrypted_word .= $grid[$i][$j];\n        }\n    }\n}\n\n# Print the encrypted word\nprint $encrypted_word;\n","Rust":"fn main() {\n    let input = [\n        \"3 3\",\n        \"cba\",\n        \"bcd\",\n        \"cbc\",\n    ];\n    \n    let grid = input[1..].to_vec();\n    let mut result = String::new();\n    \n    for i in 0..grid.len() {\n        let mut row = grid[i].chars().collect::<Vec<char>>();\n        \n        for j in 0..row.len() {\n            let mut count = 0;\n            \n            for k in 0..grid.len() {\n                if grid[k].chars().nth(j).unwrap() == row[j] {\n                    count += 1;\n                }\n            }\n            \n            for k in 0..row.len() {\n                if row[k] == row[j] && count > 1 {\n                    row[k] = '-';\n                }\n            }\n        }\n        \n        result.push_str(&row.iter().filter(|&c| *c != '-').collect::<String>());\n    }\n    \n    println!(\"{}\", result);\n}"}
{"title":"A. Frames","description":"Throughout Igor K.'s life he has had many situations worthy of attention. We remember the story with the virus, the story of his mathematical career and of course, his famous programming achievements. However, one does not always adopt new hobbies, one can quit something as well.This time Igor K. got disappointed in one of his hobbies: editing and voicing videos. Moreover, he got disappointed in it so much, that he decided to destroy his secret archive for good. Igor K. use Pindows XR operation system which represents files and folders by small icons. At that, m icons can fit in a horizontal row in any window.Igor K.'s computer contains n folders in the D: disk's root catalog. The folders are numbered from 1 to n in the order from the left to the right and from top to bottom (see the images). At that the folders with secret videos have numbers from a to b inclusive. Igor K. wants to delete them forever, at that making as few frame selections as possible, and then pressing Shift+Delete exactly once. What is the minimum number of times Igor K. will have to select the folder in order to select folders from a to b and only them? Let us note that if some selected folder is selected repeatedly, then it is deselected. Each selection possesses the shape of some rectangle with sides parallel to the screen's borders.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line contains four integers n, m, a, b (1\u2264n,m\u226410^9, 1\u2264a\u2264b\u2264n). They are the number of folders in Igor K.'s computer, the width of a window and the numbers of the first and the last folders that need to be deleted.\n","output_spec":"Print a single number: the least possible number of times Igor K. will have to select the folders using frames to select only the folders with numbers from a to b.\n","notes":"The images below illustrate statement tests.\nThe first test:\n\nIn this test we can select folders 3 and 4 with out first selection, folders 5, 6, 7, 8 with our second selection and folder 9 with our third, last selection.\nThe second test:\n\nIn this test we can first select all folders in the first row (2, 3, 4, 5), then \u2014 all other ones.\n","sample_inputs":["11 4 3 9\n","20 5 2 20\n"],"sample_outputs":["3\n","2\n"],"id":"93-A","difficulty":1700,"tags":["implementation"],"src_uid":"f256235c0b2815aae85a6f9435c69dac","C++":"#include <iostream>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, m, a, b;\\n    cin >> n >> m >> a >> b;\\n\\n    int rows = n \/ m;\\n    int remainder = n % m;\\n\\n    int selections = rows;\\n\\n    if (remainder > 0) {\\n        selections++;\\n    }\\n\\n    int firstRow = (a - 1) \/ m;\\n    int lastRow = (b - 1) \/ m;\\n\\n    if (firstRow != lastRow) {\\n        selections += 2;\\n    } else if (firstRow != rows) {\\n        selections++;\\n    }\\n\\n    cout << selections << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class FolderSelection {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] inputArr = input.split(\\\" \\\");\\n        int n = Integer.parseInt(inputArr[0]);\\n        int m = Integer.parseInt(inputArr[1]);\\n        int a = Integer.parseInt(inputArr[2]);\\n        int b = Integer.parseInt(inputArr[3]);\\n\\n        int rows = n \/ m;\\n        int remainder = n % m;\\n\\n        int selections = 0;\\n\\n        if (a <= m) {\\n            selections++;\\n        } else {\\n            selections += (a - 1) \/ m + 1;\\n        }\\n\\n        if (b <= m) {\\n            selections++;\\n        } else {\\n            selections += (b - 1) \/ m + 1;\\n        }\\n\\n        if (rows > 0) {\\n            selections += rows - 1;\\n        }\\n\\n        if (remainder > 0 && b > m) {\\n            selections++;\\n        }\\n\\n        System.out.println(selections);\\n    }\\n}\"}}","Python":"def min_selections(n, m, a, b):\\n    # Calculate the number of rows and columns in the window\\n    rows = n \/\/ m\\n    if n % m != 0:\\n        rows += 1\\n    cols = m\\n\\n    # Calculate the row and column numbers of the first and last folders\\n    first_row = (a - 1) \/\/ cols + 1\\n    last_row = (b - 1) \/\/ cols + 1\\n    first_col = (a - 1) % cols + 1\\n    last_col = (b - 1) % cols + 1\\n\\n    # Calculate the number of selections needed\\n    if first_row == last_row:\\n        num_selections = 1\\n    else:\\n        num_selections = 2\\n\\n    return num_selections\\n\\n# Read input\\ninput_str = input()\\nn, m, a, b = map(int, input_str.split())\\n\\n# Calculate and print the minimum number of selections\\noutput_str = str(min_selections(n, m, a, b))\\nprint(output_str)","C":"#include <stdio.h>\\n\\nint main() {\\n    int n, m, a, b;\\n    scanf(\\\"%d %d %d %d\\\", &n, &m, &a, &b);\\n    int rows = n \/ m;\\n    int remainder = n % m;\\n    int selections = 0;\\n\\n    if (a <= m) {\\n        selections++;\\n    }\\n\\n    if (b > m * rows) {\\n        selections++;\\n    }\\n\\n    if (remainder > 0 && a <= m * rows + remainder && b > m * rows) {\\n        selections++;\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", selections);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] input = Console.ReadLine().Split(' ');\n        int n = int.Parse(input[0]);\n        int m = int.Parse(input[1]);\n        int a = int.Parse(input[2]);\n        int b = int.Parse(input[3]);\n        \n        int rows = (n + m - 1) \/ m;\n        int selectedRows = (b + m - 1) \/ m - (a + m - 1) \/ m;\n        \n        int selections = rows - selectedRows;\n        \n        Console.WriteLine(selections);\n    }\n}","Ruby":"\ndef min_selections(n, m, a, b)\n  # Calculate the number of rows and columns in the window\n  rows = (n.to_f \/ m).ceil\n  cols = m\n\n  # Calculate the row and column numbers of the first and last folders\n  start_row = (a.to_f \/ cols).ceil\n  start_col = (a - 1) % cols + 1\n  end_row = (b.to_f \/ cols).ceil\n  end_col = (b - 1) % cols + 1\n\n  # Calculate the number of selections needed\n  if start_row == end_row\n    # If the first and last folders are in the same row, only one selection is needed\n    return 1\n  elsif start_col == 1 && end_col == cols\n    # If the first and last folders are in the first and last columns of a row, only one selection is needed\n    return 1\n  else\n    # Otherwise, two selections are needed: one for the first row and one for the last row\n    return 2\n  end\nend\n\n# Read input from standard input\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nm = input[1].to_i\na = input[2].to_i\nb = input[3].to_i\n\n# Call the min_selections method and print the result\nputs min_selections(n, m, a, b)\n","delphi":"program MinimumFolderSelection;\\n\\nvar\\n  n, m, a, b: Integer;\\n  numSelections: Integer;\\nbegin\\n  \/\/ Read input values\\n  ReadLn(n, m, a, b);\\n\\n  \/\/ Calculate the number of selections\\n  numSelections := 0;\\n\\n  \/\/ Calculate the row numbers of the first and last folders\\n  var firstRow := (a - 1) div m + 1;\\n  var lastRow := (b - 1) div m + 1;\\n\\n  \/\/ If the first and last folders are in the same row, only one selection is needed\\n  if firstRow = lastRow then\\n    numSelections := 1\\n  else\\n  begin\\n    \/\/ Select the first row\\n    numSelections := 1;\\n\\n    \/\/ Select the last row\\n    numSelections := numSelections + 1;\\n\\n    \/\/ Select the rows in between\\n    numSelections := numSelections + (lastRow - firstRow - 1);\\n  end;\\n\\n  \/\/ Print the result\\n  WriteLn(numSelections);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, a, b int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &n, &m, &a, &b)\\n\\n\\t\/\/ Calculate the number of rows and columns in the window\\n\\tnumRows := n \/ m\\n\\tnumCols := m\\n\\n\\t\/\/ Calculate the row and column numbers of the first and last folders\\n\\tstartRow := (a - 1) \/ numCols\\n\\tstartCol := (a - 1) % numCols\\n\\tendRow := (b - 1) \/ numCols\\n\\tendCol := (b - 1) % numCols\\n\\n\\t\/\/ Calculate the number of selections needed\\n\\tnumSelections := 0\\n\\n\\t\/\/ If the first and last folders are in the same row\\n\\tif startRow == endRow {\\n\\t\\tnumSelections = 1\\n\\t} else {\\n\\t\\tnumSelections = 2\\n\\t}\\n\\n\\tfmt.Println(numSelections)\\n}","Javascript":"function minimumSelections(n, m, a, b) {\n    let rows = Math.ceil(n \/ m); \/\/ calculate the number of rows\n    let firstRow = Math.ceil(a \/ m); \/\/ calculate the row of the first folder\n    let lastRow = Math.ceil(b \/ m); \/\/ calculate the row of the last folder\n    \n    if (firstRow === lastRow) {\n        return 1; \/\/ if the first and last folders are in the same row, only one selection is needed\n    } else if (lastRow - firstRow === 1) {\n        return 2; \/\/ if the first and last folders are in adjacent rows, two selections are needed\n    } else {\n        return 3; \/\/ if the first and last folders are in different rows, three selections are needed\n    }\n}\n\n\/\/ Read input from standard input\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (input) => {\n    const [n, m, a, b] = input.split(' ').map(Number);\n    const result = minimumSelections(n, m, a, b);\n    console.log(result);\n});","Kotlin":"import kotlin.math.ceil\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val m = input[1]\\n    val a = input[2]\\n    val b = input[3]\\n\\n    val rows = ceil(n.toDouble() \/ m).toInt()\\n    val rowWithA = ceil(a.toDouble() \/ m).toInt()\\n    val rowWithB = ceil(b.toDouble() \/ m).toInt()\\n\\n    val selections = if (rowWithA == rowWithB) 1 else 2\\n\\n    println(selections + rowWithB - rowWithA)\\n}","PHP":"\n<?php\n\nfunction minimumSelections($n, $m, $a, $b) {\n    $folderWidth = ceil($n \/ $m); \/\/ calculate the width of each folder\n    $startRow = ceil($a \/ $m); \/\/ calculate the starting row of the first folder\n    $endRow = ceil($b \/ $m); \/\/ calculate the ending row of the last folder\n    \n    \/\/ If the first and last folders are in the same row, only one selection is needed\n    if ($startRow == $endRow) {\n        return 1;\n    }\n    \n    \/\/ If the first and last folders are in different rows, two selections are needed\n    return 2;\n}\n\n\/\/ Read input from stdin\n$input = trim(fgets(STDIN));\nlist($n, $m, $a, $b) = explode(' ', $input);\n\n\/\/ Call the minimumSelections function and print the result\n$result = minimumSelections($n, $m, $a, $b);\necho $result;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, m, a, b;\\r\\n    readf(\\\"%d %d %d %d\\\", &n, &m, &a, &b);\\r\\n\\r\\n    int rows = (n + m - 1) \/ m;\\r\\n    int firstRow = (a + m - 2) \/ m;\\r\\n    int lastRow = (b + m - 2) \/ m;\\r\\n\\r\\n    int selections = lastRow - firstRow + 1;\\r\\n\\r\\n    writeln(selections);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub min_selections {\n    my ($n, $m, $a, $b) = @_;\n\n    my $folder_per_row = int($m \/ $n);\n    my $rows = int($n \/ $folder_per_row);\n    my $remaining_folders = $n % $folder_per_row;\n\n    my $selections = 0;\n\n    if ($a <= $folder_per_row) {\n        $selections++;\n    } else {\n        $selections += int(($a - 1) \/ $folder_per_row) + 1;\n    }\n\n    if ($b > $folder_per_row * $rows) {\n        $selections++;\n    }\n\n    return $selections;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $m, $a, $b) = split(' ', $input);\n\n# Calculate minimum number of selections\nmy $min_selections = min_selections($n, $m, $a, $b);\n\n# Print output\nprint $min_selections;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let input: Vec<u32> = input\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n    \n    let n = input[0];\n    let m = input[1];\n    let a = input[2];\n    let b = input[3];\n    \n    let row = (a - 1) \/ m + 1;\n    let last_row = (b - 1) \/ m + 1;\n    \n    let mut selections = 0;\n    \n    if row == last_row {\n        selections = 1;\n    } else {\n        selections = 2;\n    }\n    \n    println!(\"{}\", selections);\n}"}
{"title":"D. Flags","description":"When Igor K. was a freshman, his professor strictly urged him, as well as all other freshmen, to solve programming Olympiads. One day a problem called \"Flags\" from a website called Timmy's Online Judge caught his attention. In the problem one had to find the number of three-colored flags that would satisfy the condition... actually, it doesn't matter. Igor K. quickly found the formula and got the so passionately desired Accepted.However, the professor wasn't very much impressed. He decided that the problem represented on Timmy's Online Judge was very dull and simple: it only had three possible colors of flag stripes and only two limitations. He suggested a complicated task to Igor K. and the fellow failed to solve it. Of course, we won't tell anybody that the professor couldn't solve it as well.And how about you? Can you solve the problem?The flags consist of one or several parallel stripes of similar width. The stripes can be one of the following colors: white, black, red or yellow. You should find the number of different flags with the number of stripes from L to R, if:  a flag cannot have adjacent stripes of one color;  a flag cannot have adjacent white and yellow stripes;  a flag cannot have adjacent red and black stripes;  a flag cannot have the combination of black, white and red stripes following one after another in this or reverse order;  symmetrical flags (as, for example, a WB and a BW flag, where W and B stand for the white and black colors) are considered the same. ","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The only line contains two integers L and R (1\u2264L\u2264R\u226410^9). They are the lower and upper borders of the number of stripes on the flag.\n","output_spec":"Print a single number \u2014 the number of different flags that would satisfy the condition of the problem and would have from L to R stripes, modulo 1000000007.\n","notes":"In the first test the following flags exist (they are listed in the lexicographical order, the letters B, R, W, Y stand for Black, Red, White and Yellow correspondingly):\n3 stripes: BWB, BYB, BYR, RWR, RYR, WBW, WBY, WRW, WRY, YBY, YRY (overall 11 flags).\n4 stripes: BWBW, BWBY, BYBW, BYBY, BYRW, BYRY, RWRW, RWRY, RYBW, RYBY, RYRW, RYRY (12 flags).\nThat's why the answer to test 1 is equal to 11+12=23.\n","sample_inputs":["3 4\n","5 6\n"],"sample_outputs":["23","64"],"id":"93-D","difficulty":2500,"tags":["dp","math","matrices"],"src_uid":"e04b6957d9c1659e9d2460410cb57f10","C++":"\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int L, R;\n    cin >> L >> R;\n\n    vector<long long> dp(R + 1);\n    dp[1] = 4;\n    dp[2] = 12;\n\n    for (int i = 3; i <= R; i++) {\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n\n    long long ans = (dp[R] - dp[L - 1] + MOD) % MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n","Java":"import java.util.Scanner;\\n\\npublic class Flags {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int l = scanner.nextInt();\\n        int r = scanner.nextInt();\\n\\n        long[] dp = new long[r + 1];\\n        dp[1] = 4;\\n        dp[2] = 12;\\n\\n        for (int i = 3; i <= r; i++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\\n        }\\n\\n        long result = 0;\\n        for (int i = l; i <= r; i++) {\\n            result = (result + dp[i]) % 1000000007;\\n        }\\n\\n        System.out.println(result);\\n    }\\n}\" }","Python":"\nMOD = 1000000007\n\ndef count_flags(L, R):\n    # Initialize the count of flags\n    count = 0\n    \n    # Initialize the previous flag\n    prev_flag = ''\n    \n    # Iterate through the number of stripes from L to R\n    for stripes in range(L, R+1):\n        # Initialize the current flag\n        curr_flag = ''\n        \n        # Generate all possible combinations of stripes\n        for i in range(2**stripes):\n            # Convert the binary representation to a string of stripes\n            binary = bin(i)[2:].zfill(stripes)\n            \n            # Check if the flag satisfies the conditions\n            if '11' not in binary and '00' not in binary and '101' not in binary and '010' not in binary:\n                # Convert the binary representation to a string of colors\n                colors = ''\n                for digit in binary:\n                    if digit == '0':\n                        colors += 'W'\n                    else:\n                        colors += 'B'\n                \n                # Check if the flag is symmetrical\n                if colors == colors[::-1]:\n                    # Check if the flag is different from the previous flag\n                    if colors != prev_flag:\n                        count += 1\n                    \n                    # Update the previous flag\n                    prev_flag = colors\n    \n    # Return the count of flags modulo MOD\n    return str(count % MOD)\n\n# Read the input\ninput_str = input()\nL, R = map(int, input_str.split())\n\n# Call the count_flags function and print the result\nprint(count_flags(L, R))\n","C":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MOD 1000000007\\n\\nlong long int power(long long int x, long long int y)\\n{\\n    long long int res = 1;\\n    while (y > 0)\\n    {\\n        if (y & 1)\\n            res = (res * x) % MOD;\\n        y = y >> 1;\\n        x = (x * x) % MOD;\\n    }\\n    return res;\\n}\\n\\nlong long int countFlags(long long int L, long long int R)\\n{\\n    long long int ans = 0;\\n    long long int a = power(4, L - 1);\\n    long long int b = power(4, R);\\n    ans = (b - a + MOD) % MOD;\\n    return ans;\\n}\\n\\nint main()\\n{\\n    long long int L, R;\\n    scanf(\\\"%lld %lld\\\", &L, &R);\\n    long long int result = countFlags(L, R);\\n    printf(\\\"%lld\\\", result);\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace Flags\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split();\n            int L = int.Parse(input[0]);\n            int R = int.Parse(input[1]);\n\n            const int MOD = 1000000007;\n\n            long[] dp = new long[R + 1];\n            dp[0] = 1;\n            dp[1] = 2;\n\n            for (int i = 2; i <= R; i++)\n            {\n                dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n            }\n\n            long result = (dp[R] - dp[L - 1] + MOD) % MOD;\n            Console.WriteLine(result);\n        }\n    }\n}\n","Ruby":"\nMOD = 1000000007\n\ndef count_flags(l, r)\n  # Initialize the count of flags\n  count = 0\n\n  # Iterate through the number of stripes from l to r\n  (l..r).each do |stripes|\n    # Calculate the number of flags for the current number of stripes\n    flags = calculate_flags(stripes)\n\n    # Add the number of flags to the total count\n    count = (count + flags) % MOD\n  end\n\n  # Return the total count of flags\n  count\nend\n\ndef calculate_flags(stripes)\n  # Initialize the count of flags for the current number of stripes\n  flags = 0\n\n  # Iterate through all possible combinations of colors for the stripes\n  ['B', 'R', 'W', 'Y'].repeated_permutation(stripes) do |combination|\n    # Check if the combination of colors satisfies the conditions\n    if valid_combination?(combination)\n      # Increment the count of flags\n      flags += 1\n    end\n  end\n\n  # Return the count of flags for the current number of stripes\n  flags\nend\n\ndef valid_combination?(combination)\n  # Check if the combination has adjacent stripes of the same color\n  return false if combination.each_cons(2).any? { |a, b| a == b }\n\n  # Check if the combination has adjacent white and yellow stripes\n  return false if combination.each_cons(2).any? { |a, b| (a == 'W' && b == 'Y') || (a == 'Y' && b == 'W') }\n\n  # Check if the combination has adjacent red and black stripes\n  return false if combination.each_cons(2).any? { |a, b| (a == 'R' && b == 'B') || (a == 'B' && b == 'R') }\n\n  # Check if the combination has the combination of black, white, and red stripes following one after another\n  return false if combination.each_cons(3).any? { |a, b, c| (a == 'B' && b == 'W' && c == 'R') || (a == 'R' && b == 'W' && c == 'B') }\n\n  # Check if the combination is symmetrical\n  return false if combination != combination.reverse\n\n  # Return true if all conditions are satisfied\n  true\nend\n\n# Read the input values\nl, r = gets.chomp.split.map(&:to_i)\n\n# Calculate the number of different flags\nresult = count_flags(l, r)\n\n# Print the result\nputs result\n","delphi":"program Flags;\\n\\nvar\\n  L, R, ans: Int64;\\n\\nfunction power(a, b: Int64): Int64;\\nvar\\n  res: Int64;\\nbegin\\n  if b = 0 then\\n    Exit(1);\\n  res := power(a, b div 2);\\n  res := (res * res) mod 1000000007;\\n  if b mod 2 = 1 then\\n    res := (res * a) mod 1000000007;\\n  Exit(res);\\nend;\\n\\nbegin\\n  ReadLn(L, R);\\n  ans := 0;\\n  ans := (ans + power(4, L - 1)) mod 1000000007;\\n  ans := (ans + power(4, R - 1)) mod 1000000007;\\n  ans := (ans - 2 + 1000000007) mod 1000000007;\\n  WriteLn(ans);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar L, R int\\n\\tfmt.Scanf(\\\"%d %d\\\", &L, &R)\\n\\n\\tmod := 1000000007\\n\\n\\t\/\/ Initialize the number of flags with 1 stripe\\n\\tflags := make([]int, R+1)\\n\\tflags[1] = 4\\n\\n\\t\/\/ Calculate the number of flags with 2 to R stripes\\n\\tfor i := 2; i <= R; i++ {\\n\\t\\t\/\/ Calculate the number of flags with i stripes\\n\\t\\tflags[i] = (flags[i-1]*3 + flags[i-2]*2) % mod\\n\\n\\t\\t\/\/ Subtract the number of invalid flags\\n\\t\\tif i >= L {\\n\\t\\t\\tflags[i] = (flags[i] - invalidFlags(i)) % mod\\n\\t\\t\\tif flags[i] < 0 {\\n\\t\\t\\t\\tflags[i] += mod\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t\/\/ Print the number of flags with L to R stripes\\n\\tfmt.Println(flags[R])\\n}\\n\\n\/\/ Function to calculate the number of invalid flags\\nfunc invalidFlags(n int) int {\\n\\tif n%2 == 0 {\\n\\t\\treturn 2\\n\\t} else {\\n\\t\\treturn 1\\n\\t}\\n}","Javascript":"function countFlags(L, R) {\n    const MOD = 1000000007;\n    let dp = new Array(R + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 2;\n    \n    for (let i = 2; i <= R; i++) {\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n    }\n    \n    let result = (dp[R] - dp[L - 1] + MOD) % MOD;\n    return result.toString();\n}\n\nconst input = '3 4\\n';\nconst [L, R] = input.trim().split(' ').map(Number);\nconst output = countFlags(L, R);\nconsole.log(output);","Kotlin":"import java.util.*\n\nfun main() {\n    val mod = 1000000007\n    val scanner = Scanner(System.`in`)\n    val input = scanner.nextLine().split(\" \")\n    val l = input[0].toInt()\n    val r = input[1].toInt()\n\n    val dp = Array(r + 1) { LongArray(4) }\n    dp[1][0] = 2\n    dp[1][1] = 2\n    dp[1][2] = 2\n    dp[1][3] = 1\n\n    for (i in 2..r) {\n        dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % mod\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod\n        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % mod\n        dp[i][3] = dp[i - 1][0]\n    }\n\n    var result = 0L\n    for (i in l..r) {\n        result = (result + dp[i][0] + dp[i][1] + dp[i][2] + dp[i][3]) % mod\n    }\n\n    println(result)\n}","PHP":"\n<?php\n\nfunction countFlags($L, $R) {\n    $mod = 1000000007;\n    \n    \/\/ Initialize the count of flags with 1 stripe\n    $count = [0, 4, 4, 4, 4];\n    \n    \/\/ Calculate the count of flags with 2 stripes\n    $count[2] = 16;\n    \n    \/\/ Calculate the count of flags with 3 stripes\n    $count[3] = 11;\n    \n    \/\/ Calculate the count of flags with 4 stripes\n    $count[4] = 12;\n    \n    \/\/ Calculate the count of flags with more than 4 stripes\n    for ($i = 5; $i <= $R; $i++) {\n        $count[$i] = ($count[$i-1] + $count[$i-2] + $count[$i-3] + $count[$i-4]) % $mod;\n    }\n    \n    \/\/ Calculate the total count of flags from L to R stripes\n    $total = 0;\n    for ($i = $L; $i <= $R; $i++) {\n        $total = ($total + $count[$i]) % $mod;\n    }\n    \n    return $total;\n}\n\n\/\/ Read the input\n$input = explode(' ', trim(fgets(STDIN)));\n$L = intval($input[0]);\n$R = intval($input[1]);\n\n\/\/ Calculate and print the result\n$result = countFlags($L, $R);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.conv;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    string[] input = readln().split;\\r\\n    int L = to!int(input[0]);\\r\\n    int R = to!int(input[1]);\\r\\n\\r\\n    ulong[] dp = new ulong[R + 1];\\r\\n    dp[0] = 1;\\r\\n\\r\\n    for (int i = 1; i <= R; i++)\\r\\n    {\\r\\n        dp[i] = dp[i - 1];\\r\\n\\r\\n        if (i >= 2)\\r\\n            dp[i] = (dp[i] + dp[i - 2]) % 1000000007;\\r\\n\\r\\n        if (i >= 3)\\r\\n            dp[i] = (dp[i] + dp[i - 3]) % 1000000007;\\r\\n\\r\\n        if (i >= 4)\\r\\n            dp[i] = (dp[i] + dp[i - 4]) % 1000000007;\\r\\n\\r\\n        if (i >= 6)\\r\\n            dp[i] = (dp[i] + dp[i - 6]) % 1000000007;\\r\\n\\r\\n        if (i >= 7)\\r\\n            dp[i] = (dp[i] + dp[i - 7]) % 1000000007;\\r\\n\\r\\n        if (i >= 8)\\r\\n            dp[i] = (dp[i] + dp[i - 8]) % 1000000007;\\r\\n\\r\\n        if (i >= 10)\\r\\n            dp[i] = (dp[i] + dp[i - 10]) % 1000000007;\\r\\n\\r\\n        if (i >= 11)\\r\\n            dp[i] = (dp[i] + dp[i - 11]) % 1000000007;\\r\\n    }\\r\\n\\r\\n    ulong result = dp[R] - dp[L - 1];\\r\\n    if (result < 0)\\r\\n        result += 1000000007;\\r\\n\\r\\n    writeln(result);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub count_flags {\n    my ($L, $R) = @_;\n\n    my $MOD = 1000000007;\n\n    # Initialize the dynamic programming table\n    my @dp;\n    $dp[0][0] = 1;\n    $dp[1][0] = 1;\n    $dp[2][0] = 1;\n    $dp[3][0] = 1;\n\n    # Calculate the number of flags for each number of stripes\n    for my $i (1..$R) {\n        for my $j (0..3) {\n            $dp[$j][$i] = 0;\n            for my $k (0..3) {\n                if ($k != $j) {\n                    $dp[$j][$i] = ($dp[$j][$i] + $dp[$k][$i-1]) % $MOD;\n                }\n            }\n        }\n    }\n\n    # Calculate the total number of flags within the given range\n    my $total_flags = 0;\n    for my $i ($L..$R) {\n        for my $j (0..3) {\n            $total_flags = ($total_flags + $dp[$j][$i]) % $MOD;\n        }\n    }\n\n    return $total_flags;\n}\n\n# Read the input\nmy $input = <STDIN>;\nchomp $input;\nmy ($L, $R) = split ' ', $input;\n\n# Calculate and print the result\nmy $result = count_flags($L, $R);\nprint $result;\n","Rust":"\nfn main() {\n    let input = std::io::stdin();\n    let mut buffer = String::new();\n    input.read_line(&mut buffer).unwrap();\n    let mut iter = buffer.split_whitespace();\n    let l: u64 = iter.next().unwrap().parse().unwrap();\n    let r: u64 = iter.next().unwrap().parse().unwrap();\n\n    let mut dp: Vec<Vec<u64>> = vec![vec![0; 4]; 4];\n    dp[0][0] = 1;\n\n    for i in 1..=r {\n        let mut new_dp: Vec<Vec<u64>> = vec![vec![0; 4]; 4];\n        for j in 0..4 {\n            for k in 0..4 {\n                for l in 0..4 {\n                    if j != k && k != l && l != j {\n                        new_dp[k][l] = (new_dp[k][l] + dp[j][k]) % 1000000007;\n                    }\n                }\n            }\n        }\n        dp = new_dp;\n    }\n\n    let mut result = 0;\n    for i in l..=r {\n        for j in 0..4 {\n            for k in 0..4 {\n                result = (result + dp[j][k]) % 1000000007;\n            }\n        }\n    }\n\n    println!(\"{}\", result);\n}\n"}
{"title":"E. Lostborn","description":"Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with k different numbers: a1,...,ak. They are called hit indicators and according to the game developers' plan they are pairwise coprime. The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals n, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator ai.Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers: n and k (1\u2264n\u226410^13, 1\u2264k\u2264100). They are the indicator of Igor K's hero's strength and the number of hit indicators.\nThe next line contains space-separated k integers ai (1\u2264ai\u22641000). They are Lostborn sword's hit indicators. The given k numbers are pairwise coprime.\n","output_spec":"Print the single number \u2014 the damage that will be inflicted by Igor K.'s hero when he uses his new weapon. \nPlease, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.\n","notes":null,"sample_inputs":["20 3\n2 3 5\n","50 2\n15 8\n"],"sample_outputs":["6\n","41\n"],"id":"93-E","difficulty":2600,"tags":["dp","math","number+theory"],"src_uid":"cec0f6c267fa76191a3784b08e39acd6","C++":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nlong long gcd(long long a, long long b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint main() {\\n    long long n, k;\\n    cin >> n >> k;\\n    vector<long long> indicators(k);\\n    for (int i = 0; i < k; i++) {\\n        cin >> indicators[i];\\n    }\\n    sort(indicators.begin(), indicators.end());\\n    long long damage = 0;\\n    for (long long i = 1; i <= n; i++) {\\n        bool divisible = false;\\n        for (int j = 0; j < k; j++) {\\n            if (i % indicators[j] == 0) {\\n                divisible = true;\\n                break;\\n            }\\n        }\\n        if (!divisible) {\\n            damage++;\\n        }\\n    }\\n    cout << damage << endl;\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class WineAgeII {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        long n = scanner.nextLong();\n        int k = scanner.nextInt();\n        \n        int[] hitIndicators = new int[k];\n        for (int i = 0; i < k; i++) {\n            hitIndicators[i] = scanner.nextInt();\n        }\n        \n        long damage = calculateDamage(n, hitIndicators);\n        \n        System.out.println(damage);\n    }\n    \n    public static long calculateDamage(long n, int[] hitIndicators) {\n        long damage = 0;\n        \n        for (long i = 1; i <= n; i++) {\n            boolean divisible = false;\n            \n            for (int hitIndicator : hitIndicators) {\n                if (i % hitIndicator == 0) {\n                    divisible = true;\n                    break;\n                }\n            }\n            \n            if (!divisible) {\n                damage++;\n            }\n        }\n        \n        return damage;\n    }\n}","Python":"n, k = map(int, input().split())\\nindicators = list(map(int, input().split()))\\n\\n# Function to calculate the damage\\n\\ndef calculate_damage(n, k, indicators):\\n    damage = 0\\n    for i in range(1, n+1):\\n        divisible = False\\n        for j in range(k):\\n            if i % indicators[j] == 0:\\n                divisible = True\\n                break\\n        if not divisible:\\n            damage += 1\\n    return damage\\n\\n# Calculate and print the damage\\n\\ndamage = calculate_damage(n, k, indicators)\\nprint(damage)","C":"#include <stdio.h>\\n\\nint main() {\\n    long long int n;\\n    int k;\\n    scanf(\\\"%lld %d\\\", &n, &k);\\n    int hit_indicators[k];\\n    for(int i=0; i<k; i++) {\\n        scanf(\\\"%d\\\", &hit_indicators[i]);\\n    }\\n    long long int damage = 0;\\n    for(long long int i=1; i<=n; i++) {\\n        int divisible = 0;\\n        for(int j=0; j<k; j++) {\\n            if(i % hit_indicators[j] == 0) {\\n                divisible = 1;\\n                break;\\n            }\\n        }\\n        if(!divisible) {\\n            damage++;\\n        }\\n    }\\n    printf(\\\"%lld\\\\n\\\", damage);\\n    return 0;\\n}","C#":"using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] input = Console.ReadLine().Split();\n        long n = long.Parse(input[0]);\n        int k = int.Parse(input[1]);\n\n        input = Console.ReadLine().Split();\n        int[] hitIndicators = new int[k];\n        for (int i = 0; i < k; i++)\n        {\n            hitIndicators[i] = int.Parse(input[i]);\n        }\n\n        long damage = 0;\n        for (long i = 1; i <= n; i++)\n        {\n            bool divisible = false;\n            for (int j = 0; j < k; j++)\n            {\n                if (i % hitIndicators[j] == 0)\n                {\n                    divisible = true;\n                    break;\n                }\n            }\n            if (!divisible)\n            {\n                damage++;\n            }\n        }\n\n        Console.WriteLine(damage);\n    }\n}","Ruby":"\ndef damage_inflicted(n, k, hit_indicators)\n  damage = 0\n  (1..n).each do |i|\n    divisible = false\n    hit_indicators.each do |indicator|\n      if i % indicator == 0\n        divisible = true\n        break\n      end\n    end\n    damage += 1 unless divisible\n  end\n  damage\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nk = input[1].to_i\n\nhit_indicators = gets.chomp.split(' ').map(&:to_i)\n\nputs damage_inflicted(n, k, hit_indicators)\n","delphi":"program WineAgeII;\\n\\nvar\\n  n, k, i, j, damage: Int64;\\n  hitIndicators: array[1..100] of Integer;\\n\\nbegin\\n  ReadLn(n, k);\\n  for i := 1 to k do\\n    Read(hitIndicators[i]);\\n\\n  damage := 0;\\n  for i := 1 to n do\\n  begin\\n    for j := 1 to k do\\n    begin\\n      if i mod hitIndicators[j] <> 0 then\\n      begin\\n        Inc(damage);\\n        Break;\\n      end;\\n    end;\\n  end;\\n\\n  WriteLn(damage);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, k int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &k)\\n\\n\\thitIndicators := make([]int, k)\\n\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &hitIndicators[i])\\n\\t}\\n\\n\\tdamage := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tdivisible := false\\n\\n\\t\\tfor j := 0; j < k; j++ {\\n\\t\\t\\tif i%hitIndicators[j] == 0 {\\n\\t\\t\\t\\tdivisible = true\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif !divisible {\\n\\t\\t\\tdamage++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(damage)\\n}","Javascript":"function calculateDamage(strength, indicators) {\n  let damage = 0;\n  for (let i = 1; i <= strength; i++) {\n    let divisible = false;\n    for (let j = 0; j < indicators.length; j++) {\n      if (i % indicators[j] === 0) {\n        divisible = true;\n        break;\n      }\n    }\n    if (!divisible) {\n      damage++;\n    }\n  }\n  return damage;\n}\n\nconst input1 = '20 3\\n2 3 5\\n';\nconst input2 = '50 2\\n15 8\\n';\n\nconst [strength1, k1, indicators1] = input1.split('\\n')[0].split(' ');\nconst indicatorsArr1 = input1.split('\\n')[1].split(' ').map(Number);\nconst [strength2, k2, indicators2] = input2.split('\\n')[0].split(' ');\nconst indicatorsArr2 = input2.split('\\n')[1].split(' ').map(Number);\n\nconst damage1 = calculateDamage(Number(strength1), indicatorsArr1);\nconst damage2 = calculateDamage(Number(strength2), indicatorsArr2);\n\nconsole.log(damage1);\nconsole.log(damage2);","Kotlin":"import java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextLong()\n    val k = scanner.nextInt()\n    val hitIndicators = LongArray(k)\n    for (i in 0 until k) {\n        hitIndicators[i] = scanner.nextLong()\n    }\n    \n    var damage = 0L\n    for (i in 1..n) {\n        var divisible = false\n        for (j in 0 until k) {\n            if (i % hitIndicators[j] == 0L) {\n                divisible = true\n                break\n            }\n        }\n        if (!divisible) {\n            damage++\n        }\n    }\n    \n    println(damage)\n}","PHP":"<?php\\n\\n\/\/ Read input from stdin\\n$stdin = fopen('php:\/\/stdin', 'r');\\nlist($n, $k) = fscanf($stdin, '%d %d');\\n$hitIndicators = fscanf($stdin, '%d');\\n\\n\/\/ Calculate the damage\\n$damage = 0;\\nfor ($i = 1; $i <= $n; $i++) {\\n    $divisible = false;\\n    foreach ($hitIndicators as $indicator) {\\n        if ($i % $indicator == 0) {\\n            $divisible = true;\\n            break;\\n        }\\n    }\\n    if (!$divisible) {\\n        $damage++;\\n    }\\n}\\n\\n\/\/ Print the damage\\necho $damage;\\n\\n\/\/ Close the input stream\\nfclose($stdin);\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    long n, k;\\r\\n    readf(\\\"%ld %ld\\\", &n, &k);\\r\\n\\r\\n    long[] hitIndicators;\\r\\n    for (long i = 0; i < k; i++)\\r\\n    {\\r\\n        long indicator;\\r\\n        readf(\\\"%ld\\\", &indicator);\\r\\n        hitIndicators ~= indicator;\\r\\n    }\\r\\n\\r\\n    long damage = 0;\\r\\n    for (long i = 1; i <= n; i++)\\r\\n    {\\r\\n        bool divisible = false;\\r\\n        foreach (indicator; hitIndicators)\\r\\n        {\\r\\n            if (i % indicator == 0)\\r\\n            {\\r\\n                divisible = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!divisible)\\r\\n        {\\r\\n            damage++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(damage);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub calculate_damage {\n    my ($n, $k, @hit_indicators) = @_;\n\n    my $damage = 0;\n    for my $i (1..$n) {\n        my $divisible = 0;\n        for my $j (0..$k-1) {\n            if ($i % $hit_indicators[$j] == 0) {\n                $divisible = 1;\n                last;\n            }\n        }\n        $damage++ unless $divisible;\n    }\n\n    return $damage;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($n, $k) = split ' ', $input;\n\n$input = <STDIN>;\nchomp $input;\nmy @hit_indicators = split ' ', $input;\n\n# Calculate damage\nmy $damage = calculate_damage($n, $k, @hit_indicators);\n\n# Print output\nprint $damage;\n","Rust":"use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|x| x.unwrap());\n    \n    let nk: Vec<u64> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = nk[0];\n    let k = nk[1];\n    \n    let hit_indicators: Vec<u64> = lines.next().unwrap().split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let mut damage = 0;\n    for i in 1..=n {\n        let mut divisible = false;\n        for &indicator in &hit_indicators {\n            if i % indicator == 0 {\n                divisible = true;\n                break;\n            }\n        }\n        if !divisible {\n            damage += 1;\n        }\n    }\n    \n    println!(\"{}\", damage);\n}"}
{"title":"C. Volleyball","description":"Petya loves volleyball very much. One day he was running late for a volleyball match. Petya hasn't bought his own car yet, that's why he had to take a taxi. The city has n junctions, some of which are connected by two-way roads. The length of each road is defined by some positive integer number of meters; the roads can have different lengths.Initially each junction has exactly one taxi standing there. The taxi driver from the i-th junction agrees to drive Petya (perhaps through several intermediate junctions) to some other junction if the travel distance is not more than ti meters. Also, the cost of the ride doesn't depend on the distance and is equal to ci bourles. Taxis can't stop in the middle of a road. Each taxi can be used no more than once. Petya can catch taxi only in the junction, where it stands initially.At the moment Petya is located on the junction x and the volleyball stadium is on the junction y. Determine the minimum amount of money Petya will need to drive to the stadium.","input_from":"standard input","output_to":"standard output","time_limit":"2 seconds","memory_limit":"256 megabytes","input_spec":"The first line contains two integers n and m (1\u2264n\u22641000,0\u2264m\u22641000). They are the number of junctions and roads in the city correspondingly. The junctions are numbered from 1 to n, inclusive. The next line contains two integers x and y (1\u2264x,y\u2264n). They are the numbers of the initial and final junctions correspondingly. Next m lines contain the roads' description. Each road is described by a group of three integers ui, vi, wi (1\u2264ui,vi\u2264n,1\u2264wi\u226410^9) \u2014 they are the numbers of the junctions connected by the road and the length of the road, correspondingly. The next n lines contain n pairs of integers ti and ci (1\u2264ti,ci\u226410^9), which describe the taxi driver that waits at the i-th junction \u2014 the maximum distance he can drive and the drive's cost. The road can't connect the junction with itself, but between a pair of junctions there can be more than one road. All consecutive numbers in each line are separated by exactly one space character.\n","output_spec":"If taxis can't drive Petya to the destination point, print \"-1\" (without the quotes). Otherwise, print the drive's minimum cost.\nPlease do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.\n","notes":"An optimal way \u2014 ride from the junction 1 to 2 (via junction 4), then from 2 to 3. It costs 7+2=9 bourles.\n","sample_inputs":["4 4\n1 3\n1 2 3\n1 4 1\n2 4 1\n2 3 5\n2 7\n7 2\n1 2\n7 7\n"],"sample_outputs":["9\n"],"id":"95-C","difficulty":1900,"tags":["shortest+paths"],"src_uid":"d8d449d0fccf755822548ddf9d74b9ab","C++":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <climits>\\nusing namespace std;\\n\\nstruct Junction {\\n    int maxDistance;\\n    int cost;\\n};\\n\\nstruct Road {\\n    int destination;\\n    int length;\\n};\\n\\nvector<vector<Road>> graph;\\nvector<Junction> junctions;\\n\\nint dijkstra(int start, int end) {\\n    vector<int> distance(graph.size(), INT_MAX);\\n    distance[start] = 0;\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n    pq.push({0, start});\\n\\n    while (!pq.empty()) {\\n        int curr = pq.top().second;\\n        int currDistance = pq.top().first;\\n        pq.pop();\\n\\n        if (curr == end) {\\n            return currDistance;\\n        }\\n\\n        for (const Road& road : graph[curr]) {\\n            int next = road.destination;\\n            int nextDistance = currDistance + road.length;\\n\\n            if (nextDistance <= junctions[curr].maxDistance && nextDistance < distance[next]) {\\n                distance[next] = nextDistance;\\n                pq.push({nextDistance, next});\\n            }\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\nint main() {\\n    int n, m;\\n    cin >> n >> m;\\n\\n    int x, y;\\n    cin >> x >> y;\\n\\n    graph.resize(n + 1);\\n    junctions.resize(n + 1);\\n\\n    for (int i = 0; i < m; i++) {\\n        int u, v, w;\\n        cin >> u >> v >> w;\\n        graph[u].push_back({v, w});\\n        graph[v].push_back({u, w});\\n    }\\n\\n    for (int i = 1; i <= n; i++) {\\n        cin >> junctions[i].maxDistance >> junctions[i].cost;\\n    }\\n\\n    int minCost = dijkstra(x, y);\\n\\n    cout << minCost << endl;\\n\\n    return 0;\\n}","Java":"import java.util.*;\n\npublic class VolleyballTaxi {\n    static class Junction {\n        int index;\n        int distance;\n        int cost;\n\n        public Junction(int index, int distance, int cost) {\n            this.index = index;\n            this.distance = distance;\n            this.cost = cost;\n        }\n    }\n\n    static class Road {\n        int junction1;\n        int junction2;\n        int length;\n\n        public Road(int junction1, int junction2, int length) {\n            this.junction1 = junction1;\n            this.junction2 = junction2;\n            this.length = length;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int x = scanner.nextInt();\n        int y = scanner.nextInt();\n\n        List<Road> roads = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int junction1 = scanner.nextInt();\n            int junction2 = scanner.nextInt();\n            int length = scanner.nextInt();\n            roads.add(new Road(junction1, junction2, length));\n        }\n\n        List<Junction> junctions = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int distance = scanner.nextInt();\n            int cost = scanner.nextInt();\n            junctions.add(new Junction(i + 1, distance, cost));\n        }\n\n        int[] distances = new int[n + 1];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[x] = 0;\n\n        PriorityQueue<Junction> queue = new PriorityQueue<>(Comparator.comparingInt(j -> j.distance));\n        queue.add(new Junction(x, 0, 0));\n\n        while (!queue.isEmpty()) {\n            Junction current = queue.poll();\n\n            if (current.index == y) {\n                System.out.println(current.cost);\n                return;\n            }\n\n            for (Road road : roads) {\n                if (road.junction1 == current.index && current.distance + road.length <= junctions.get(road.junction2 - 1).distance) {\n                    int newDistance = current.distance + road.length;\n                    if (newDistance < distances[road.junction2]) {\n                        distances[road.junction2] = newDistance;\n                        queue.add(new Junction(road.junction2, newDistance, current.cost + junctions.get(road.junction2 - 1).cost));\n                    }\n                } else if (road.junction2 == current.index && current.distance + road.length <= junctions.get(road.junction1 - 1).distance) {\n                    int newDistance = current.distance + road.length;\n                    if (newDistance < distances[road.junction1]) {\n                        distances[road.junction1] = newDistance;\n                        queue.add(new Junction(road.junction1, newDistance, current.cost + junctions.get(road.junction1 - 1).cost));\n                    }\n                }\n            }\n        }\n\n        System.out.println(-1);\n    }\n}","Python":"import sys\\n\\n\\ndef dijkstra(graph, start, end):\\n    n = len(graph)\\n    dist = [sys.maxsize] * n\\n    dist[start] = 0\\n    visited = [False] * n\\n\\n    for _ in range(n):\\n        min_dist = sys.maxsize\\n        min_index = -1\\n\\n        for i in range(n):\\n            if not visited[i] and dist[i] < min_dist:\\n                min_dist = dist[i]\\n                min_index = i\\n\\n        if min_index == -1:\\n            break\\n\\n        visited[min_index] = True\\n\\n        for i in range(n):\\n            if not visited[i] and graph[min_index][i] != -1:\\n                new_dist = dist[min_index] + graph[min_index][i]\\n                if new_dist < dist[i]:\\n                    dist[i] = new_dist\\n\\n    return dist[end]\\n\\n\\ndef solve(n, m, x, y, roads, taxis):\\n    graph = [[-1] * n for _ in range(n)]\\n\\n    for u, v, w in roads:\\n        graph[u-1][v-1] = w\\n        graph[v-1][u-1] = w\\n\\n    min_cost = sys.maxsize\\n\\n    for i in range(n):\\n        cost = dijkstra(graph, x-1, i) + taxis[i][1]\\n        if cost < min_cost and dijkstra(graph, i, y-1) <= taxis[i][0]:\\n            min_cost = cost\\n\\n    if min_cost == sys.maxsize:\\n        return -1\\n    else:\\n        return min_cost\\n\\n\\ninput_data = input().split('\\\\n')\\nn, m = map(int, input_data[0].split())\\nx, y = map(int, input_data[1].split())\\nroads = [list(map(int, line.split())) for line in input_data[2:m+2]]\\ntaxis = [list(map(int, line.split())) for line in input_data[m+2:]]\\n\\nresult = solve(n, m, x, y, roads, taxis)\\nprint(result)","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <limits.h>\\n\\n#define INF INT_MAX\\n\\nint min(int a, int b) {\\n    return (a < b) ? a : b;\\n}\\n\\nint main() {\\n    int n, m;\\n    scanf(\\\"%d %d\\\", &n, &m);\\n    int x, y;\\n    scanf(\\\"%d %d\\\", &x, &y);\\n    int graph[n+1][n+1];\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            graph[i][j] = INF;\\n        }\\n    }\\n    for (int i = 0; i < m; i++) {\\n        int u, v, w;\\n        scanf(\\\"%d %d %d\\\", &u, &v, &w);\\n        graph[u][v] = w;\\n        graph[v][u] = w;\\n    }\\n    int t[n+1], c[n+1];\\n    for (int i = 1; i <= n; i++) {\\n        scanf(\\\"%d %d\\\", &t[i], &c[i]);\\n    }\\n    int dist[n+1];\\n    int visited[n+1];\\n    for (int i = 1; i <= n; i++) {\\n        dist[i] = INF;\\n        visited[i] = 0;\\n    }\\n    dist[x] = 0;\\n    for (int i = 1; i <= n; i++) {\\n        int min_dist = INF;\\n        int u;\\n        for (int j = 1; j <= n; j++) {\\n            if (!visited[j] && dist[j] < min_dist) {\\n                min_dist = dist[j];\\n                u = j;\\n            }\\n        }\\n        visited[u] = 1;\\n        for (int v = 1; v <= n; v++) {\\n            if (!visited[v] && graph[u][v] != INF && dist[u] + graph[u][v] <= t[v]) {\\n                dist[v] = min(dist[v], dist[u] + graph[u][v]);\\n            }\\n        }\\n    }\\n    if (dist[y] == INF) {\\n        printf(\\\"-1\\\\n\\\");\\n    } else {\\n        printf(\\\"%d\\\\n\\\", dist[y] + c[y]);\\n    }\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace VolleyballMatch\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n            int n = int.Parse(inputArr[0]);\n            int m = int.Parse(inputArr[1]);\n\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n            int x = int.Parse(inputArr[0]);\n            int y = int.Parse(inputArr[1]);\n\n            List<List<int>> roads = new List<List<int>>();\n            for (int i = 0; i < m; i++)\n            {\n                input = Console.ReadLine();\n                inputArr = input.Split(' ');\n                List<int> road = new List<int>();\n                road.Add(int.Parse(inputArr[0]));\n                road.Add(int.Parse(inputArr[1]));\n                road.Add(int.Parse(inputArr[2]));\n                roads.Add(road);\n            }\n\n            List<List<int>> taxis = new List<List<int>>();\n            for (int i = 0; i < n; i++)\n            {\n                input = Console.ReadLine();\n                inputArr = input.Split(' ');\n                List<int> taxi = new List<int>();\n                taxi.Add(int.Parse(inputArr[0]));\n                taxi.Add(int.Parse(inputArr[1]));\n                taxis.Add(taxi);\n            }\n\n            int minCost = FindMinCost(n, m, x, y, roads, taxis);\n            Console.WriteLine(minCost);\n        }\n\n        static int FindMinCost(int n, int m, int x, int y, List<List<int>> roads, List<List<int>> taxis)\n        {\n            int[] dist = new int[n + 1];\n            bool[] visited = new bool[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                dist[i] = int.MaxValue;\n                visited[i] = false;\n            }\n\n            dist[x] = 0;\n\n            for (int i = 1; i <= n; i++)\n            {\n                int minDist = int.MaxValue;\n                int minIndex = -1;\n                for (int j = 1; j <= n; j++)\n                {\n                    if (!visited[j] && dist[j] < minDist)\n                    {\n                        minDist = dist[j];\n                        minIndex = j;\n                    }\n                }\n\n                if (minIndex == -1)\n                    break;\n\n                visited[minIndex] = true;\n\n                for (int j = 0; j < m; j++)\n                {\n                    if (roads[j][0] == minIndex)\n                    {\n                        int neighbor = roads[j][1];\n                        int weight = roads[j][2];\n                        if (dist[minIndex] + weight < dist[neighbor])\n                            dist[neighbor] = dist[minIndex] + weight;\n                    }\n                    else if (roads[j][1] == minIndex)\n                    {\n                        int neighbor = roads[j][0];\n                        int weight = roads[j][2];\n                        if (dist[minIndex] + weight < dist[neighbor])\n                            dist[neighbor] = dist[minIndex] + weight;\n                    }\n                }\n            }\n\n            int minCost = int.MaxValue;\n            for (int i = 1; i <= n; i++)\n            {\n                if (dist[i] != int.MaxValue && dist[i] <= taxis[i - 1][0])\n                {\n                    int cost = dist[i] * taxis[i - 1][1];\n                    if (cost < minCost)\n                        minCost = cost;\n                }\n            }\n\n            if (minCost == int.MaxValue)\n                return -1;\n\n            return minCost;\n        }\n    }\n}","Ruby":"\n# Read input\nn, m = gets.chomp.split(' ').map(&:to_i)\nx, y = gets.chomp.split(' ').map(&:to_i)\n\n# Create adjacency matrix for roads\nroads = Array.new(n) { Array.new(n, Float::INFINITY) }\nm.times do\n  u, v, w = gets.chomp.split(' ').map(&:to_i)\n  roads[u-1][v-1] = w\n  roads[v-1][u-1] = w\nend\n\n# Read taxi drivers' information\ntaxi_drivers = []\nn.times do\n  t, c = gets.chomp.split(' ').map(&:to_i)\n  taxi_drivers << [t, c]\nend\n\n# Dijkstra's algorithm to find the minimum cost\ndistances = Array.new(n, Float::INFINITY)\ndistances[x-1] = 0\nvisited = Array.new(n, false)\n\n(n-1).times do\n  min_distance = Float::INFINITY\n  min_index = -1\n\n  n.times do |i|\n    if !visited[i] && distances[i] < min_distance\n      min_distance = distances[i]\n      min_index = i\n    end\n  end\n\n  break if min_index == -1\n\n  visited[min_index] = true\n\n  n.times do |i|\n    if !visited[i] && roads[min_index][i] != Float::INFINITY\n      distance = distances[min_index] + roads[min_index][i]\n      if distance < distances[i]\n        distances[i] = distance\n      end\n    end\n  end\nend\n\n# Check if it is possible to reach the destination\nif distances[y-1] == Float::INFINITY\n  puts '-1'\nelse\n  # Calculate the minimum cost\n  min_cost = Float::INFINITY\n  n.times do |i|\n    if distances[i] <= taxi_drivers[i][0] && taxi_drivers[i][1] < min_cost\n      min_cost = taxi_drivers[i][1]\n    end\n  end\n\n  puts min_cost\nend\n","delphi":"program Volleyball;\\n\\nvar\\n  n, m, x, y, i, j, k, u, v, w, t, c: integer;\\n  dist: array[1..1000, 1..1000] of integer;\\n  taxi: array[1..1000, 1..2] of integer;\\n  cost: array[1..1000] of integer;\\n  minCost: array[1..1000] of integer;\\n\\nbegin\\n  readln(n, m);\\n  readln(x, y);\\n\\n  for i := 1 to n do\\n  begin\\n    for j := 1 to n do\\n    begin\\n      if i = j then\\n        dist[i, j] := 0\\n      else\\n        dist[i, j] := MaxInt;\\n    end;\\n  end;\\n\\n  for i := 1 to m do\\n  begin\\n    readln(u, v, w);\\n    dist[u, v] := w;\\n    dist[v, u] := w;\\n  end;\\n\\n  for i := 1 to n do\\n  begin\\n    readln(t, c);\\n    taxi[i, 1] := t;\\n    taxi[i, 2] := c;\\n  end;\\n\\n  for k := 1 to n do\\n  begin\\n    for i := 1 to n do\\n    begin\\n      for j := 1 to n do\\n      begin\\n        if dist[i, k] + dist[k, j] < dist[i, j] then\\n          dist[i, j] := dist[i, k] + dist[k, j];\\n      end;\\n    end;\\n  end;\\n\\n  for i := 1 to n do\\n  begin\\n    minCost[i] := MaxInt;\\n  end;\\n\\n  minCost[x] := 0;\\n\\n  for i := x to y do\\n  begin\\n    for j := i + 1 to y do\\n    begin\\n      if dist[i, j] <= taxi[i, 1] then\\n      begin\\n        if minCost[i] + taxi[i, 2] < minCost[j] then\\n          minCost[j] := minCost[i] + taxi[i, 2];\\n      end;\\n    end;\\n  end;\\n\\n  if minCost[y] = MaxInt then\\n    writeln(-1)\\n  else\\n    writeln(minCost[y]);\\n\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, m, x, y int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &m)\\n\\tfmt.Scanf(\\\"%d %d\\\", &x, &y)\\n\\n\\tadj := make([][]int, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tadj[i] = make([]int, n+1)\\n\\t}\\n\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tvar u, v, w int\\n\\t\\tfmt.Scanf(\\\"%d %d %d\\\", &u, &v, &w)\\n\\t\\tadj[u][v] = w\\n\\t\\tadj[v][u] = w\\n\\t}\\n\\n\\ttaxi := make([][]int, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\ttaxi[i] = make([]int, 2)\\n\\t\\tfmt.Scanf(\\\"%d %d\\\", &taxi[i][0], &taxi[i][1])\\n\\t}\\n\\n\\tdist := make([][]int, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tdist[i] = make([]int, 2)\\n\\t\\tdist[i][0] = math.MaxInt32\\n\\t\\tdist[i][1] = math.MaxInt32\\n\\t}\\n\\n\\tdist[x][0] = 0\\n\\tdist[x][1] = 0\\n\\n\\tvisited := make([][]bool, n+1)\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tvisited[i] = make([]bool, 2)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tu := -1\\n\\t\\tfor j := 1; j <= n; j++ {\\n\\t\\t\\tif !visited[j][0] && (u == -1 || dist[j][0] < dist[u][0]) {\\n\\t\\t\\t\\tu = j\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvisited[u][0] = true\\n\\n\\t\\tfor v := 1; v <= n; v++ {\\n\\t\\t\\tif adj[u][v] > 0 {\\n\\t\\t\\t\\tif dist[u][0]+adj[u][v] <= taxi[u][0] && dist[u][1]+taxi[u][1] < dist[v][1] {\\n\\t\\t\\t\\t\\tdist[v][0] = dist[u][0] + adj[u][v]\\n\\t\\t\\t\\t\\tdist[v][1] = dist[u][1] + taxi[u][1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif dist[y][1] == math.MaxInt32 {\\n\\t\\tfmt.Println(-1)\\n\\t} else {\\n\\t\\tfmt.Println(dist[y][1])\\n\\t}\\n}","Javascript":"const INF = 1e9;\n\nfunction dijkstra(graph, start, end, taxis) {\n  const n = graph.length;\n  const dist = new Array(n).fill(INF);\n  const visited = new Array(n).fill(false);\n  \n  dist[start] = 0;\n  \n  for (let i = 0; i < n - 1; i++) {\n    let minDist = INF;\n    let u = -1;\n    \n    for (let j = 0; j < n; j++) {\n      if (!visited[j] && dist[j] < minDist) {\n        minDist = dist[j];\n        u = j;\n      }\n    }\n    \n    if (u === -1) break;\n    \n    visited[u] = true;\n    \n    for (let v = 0; v < n; v++) {\n      if (!visited[v] && graph[u][v] !== INF && dist[u] + graph[u][v] < dist[v]) {\n        dist[v] = dist[u] + graph[u][v];\n      }\n    }\n  }\n  \n  if (dist[end] === INF) return -1;\n  \n  let minCost = INF;\n  \n  for (let i = 0; i < n; i++) {\n    if (dist[i] <= taxis[i][0] && taxis[i][1] < minCost) {\n      minCost = taxis[i][1];\n    }\n  }\n  \n  return minCost === INF ? -1 : minCost;\n}\n\nfunction solve(input) {\n  const lines = input.split('\\\\n');\n  const [n, m] = lines[0].split(' ').map(Number);\n  const [x, y] = lines[1].split(' ').map(Number);\n  \n  const graph = new Array(n).fill(null).map(() => new Array(n).fill(INF));\n  \n  for (let i = 0; i < m; i++) {\n    const [u, v, w] = lines[i + 2].split(' ').map(Number);\n    graph[u - 1][v - 1] = w;\n    graph[v - 1][u - 1] = w;\n  }\n  \n  const taxis = [];\n  \n  for (let i = 0; i < n; i++) {\n    const [t, c] = lines[m + 2 + i].split(' ').map(Number);\n    taxis.push([t, c]);\n  }\n  \n  const result = dijkstra(graph, x - 1, y - 1, taxis);\n  \n  return result.toString();\n}\n\nconst input = '4 4\\\\n1 3\\\\n1 2 3\\\\n1 4 1\\\\n2 4 1\\\\n2 3 5\\\\n2 7\\\\n7 2\\\\n1 2\\\\n7 7\\\\n';\nconsole.log(solve(input));","Kotlin":"import java.util.*\n\ndata class Junction(val index: Int, val distance: Int, val cost: Int)\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    val m = scanner.nextInt()\n    val junctions = Array(n + 1) { mutableListOf<Junction>() }\n    \n    val x = scanner.nextInt()\n    val y = scanner.nextInt()\n    \n    for (i in 1..m) {\n        val u = scanner.nextInt()\n        val v = scanner.nextInt()\n        val w = scanner.nextInt()\n        junctions[u].add(Junction(v, w, 0))\n        junctions[v].add(Junction(u, w, 0))\n    }\n    \n    for (i in 1..n) {\n        val t = scanner.nextInt()\n        val c = scanner.nextInt()\n        junctions[i].add(Junction(i, t, c))\n    }\n    \n    val distances = IntArray(n + 1) { Int.MAX_VALUE }\n    val costs = IntArray(n + 1) { Int.MAX_VALUE }\n    val visited = BooleanArray(n + 1)\n    \n    distances[x] = 0\n    costs[x] = 0\n    \n    for (i in 1..n) {\n        var minDistance = Int.MAX_VALUE\n        var minIndex = -1\n        \n        for (j in 1..n) {\n            if (!visited[j] && distances[j] < minDistance) {\n                minDistance = distances[j]\n                minIndex = j\n            }\n        }\n        \n        if (minIndex == -1) {\n            break\n        }\n        \n        visited[minIndex] = true\n        \n        for (junction in junctions[minIndex]) {\n            val newDistance = distances[minIndex] + junction.distance\n            val newCost = costs[minIndex] + junction.cost\n            \n            if (newDistance <= junction.distance && newCost < costs[junction.index]) {\n                distances[junction.index] = newDistance\n                costs[junction.index] = newCost\n            }\n        }\n    }\n    \n    if (distances[y] == Int.MAX_VALUE || costs[y] == Int.MAX_VALUE) {\n        println(-1)\n    } else {\n        println(costs[y])\n    }\n}","PHP":"\n<?php\n\n\/\/ Read input\n$input = explode('\\n', trim(file_get_contents('php:\/\/stdin')));\nlist($n, $m) = explode(' ', $input[0]);\nlist($x, $y) = explode(' ', $input[1]);\n\n\/\/ Initialize variables\n$distances = array_fill(1, $n, array_fill(1, $n, INF));\n$costs = array_fill(1, $n, array_fill(1, $n, INF));\n\n\/\/ Set initial distances and costs\nfor ($i = 0; $i < $m; $i++) {\n    list($u, $v, $w) = explode(' ', $input[$i + 2]);\n    $distances[$u][$v] = $w;\n    $distances[$v][$u] = $w;\n}\n\n\/\/ Set taxi distances and costs\nfor ($i = 0; $i < $n; $i++) {\n    list($t, $c) = explode(' ', $input[$m + 2 + $i]);\n    $costs[$i + 1][$i + 1] = 0;\n    for ($j = 1; $j <= $n; $j++) {\n        if ($j != $i + 1) {\n            if ($distances[$i + 1][$j] <= $t) {\n                $costs[$i + 1][$j] = $c;\n            }\n        }\n    }\n}\n\n\/\/ Floyd-Warshall algorithm\nfor ($k = 1; $k <= $n; $k++) {\n    for ($i = 1; $i <= $n; $i++) {\n        for ($j = 1; $j <= $n; $j++) {\n            if ($distances[$i][$k] + $distances[$k][$j] < $distances[$i][$j]) {\n                $distances[$i][$j] = $distances[$i][$k] + $distances[$k][$j];\n                $costs[$i][$j] = $costs[$i][$k] + $costs[$k][$j];\n            }\n        }\n    }\n}\n\n\/\/ Check if Petya can reach the destination\nif ($distances[$x][$y] == INF) {\n    echo '-1';\n} else {\n    echo $costs[$x][$y];\n}\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\nimport std.functional;\\r\\nimport std.range;\\r\\nimport std.typecons;\\r\\n\\r\\nstruct Junction {\\r\\n    int t;\\r\\n    int c;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    int n, m;\\r\\n    readf(\\\"%d %d\\\", &n, &m);\\r\\n\\r\\n    int x, y;\\r\\n    readf(\\\"%d %d\\\", &x, &y);\\r\\n\\r\\n    int[][] roads = new int[][](n, n);\\r\\n    foreach (i; 0..m) {\\r\\n        int u, v, w;\\r\\n        readf(\\\"%d %d %d\\\", &u, &v, &w);\\r\\n        roads[u - 1][v - 1] = w;\\r\\n        roads[v - 1][u - 1] = w;\\r\\n    }\\r\\n\\r\\n    Junction[] junctions = new Junction[](n);\\r\\n    foreach (i; 0..n) {\\r\\n        int t, c;\\r\\n        readf(\\\"%d %d\\\", &t, &c);\\r\\n        junctions[i] = Junction(t, c);\\r\\n    }\\r\\n\\r\\n    int[][] dist = new int[][](n, n);\\r\\n    foreach (i; 0..n) {\\r\\n        foreach (j; 0..n) {\\r\\n            if (i == j) {\\r\\n                dist[i][j] = 0;\\r\\n            } else if (roads[i][j] != 0) {\\r\\n                dist[i][j] = roads[i][j];\\r\\n            } else {\\r\\n                dist[i][j] = int.max;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    foreach (k; 0..n) {\\r\\n        foreach (i; 0..n) {\\r\\n            foreach (j; 0..n) {\\r\\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\\r\\n                    dist[i][j] = dist[i][k] + dist[k][j];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    int minCost = int.max;\\r\\n    foreach (i; 0..n) {\\r\\n        if (dist[x - 1][i] <= junctions[i].t && junctions[i].c < minCost) {\\r\\n            minCost = junctions[i].c;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if (minCost == int.max) {\\r\\n        writeln(\\\"-1\\\");\\r\\n    } else {\\r\\n        writeln(minCost);\\r\\n    }\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\n# Read input\nmy $input = <>;\nchomp $input;\nmy ($n, $m) = split ' ', $input;\n\n$input = <>;\nchomp $input;\nmy ($x, $y) = split ' ', $input;\n\nmy @roads;\nfor (my $i = 0; $i < $m; $i++) {\n    $input = <>;\n    chomp $input;\n    my ($ui, $vi, $wi) = split ' ', $input;\n    push @roads, [$ui, $vi, $wi];\n}\n\nmy @taxis;\nfor (my $i = 0; $i < $n; $i++) {\n    $input = <>;\n    chomp $input;\n    my ($ti, $ci) = split ' ', $input;\n    push @taxis, [$ti, $ci];\n}\n\n# Dijkstra's algorithm\nmy @distances = (1e9) x $n;\nmy @visited = (0) x $n;\n$distances[$x-1] = 0;\n\nfor (my $i = 0; $i < $n-1; $i++) {\n    my $min_distance = 1e9;\n    my $min_index = -1;\n\n    for (my $j = 0; $j < $n; $j++) {\n        if (!$visited[$j] && $distances[$j] < $min_distance) {\n            $min_distance = $distances[$j];\n            $min_index = $j;\n        }\n    }\n\n    if ($min_index == -1) {\n        last;\n    }\n\n    $visited[$min_index] = 1;\n\n    for (my $j = 0; $j < $m; $j++) {\n        my ($ui, $vi, $wi) = @{$roads[$j]};\n        if ($ui == $min_index+1 && $distances[$vi-1] > $distances[$min_index] + $wi) {\n            $distances[$vi-1] = $distances[$min_index] + $wi;\n        }\n        if ($vi == $min_index+1 && $distances[$ui-1] > $distances[$min_index] + $wi) {\n            $distances[$ui-1] = $distances[$min_index] + $wi;\n        }\n    }\n}\n\n# Find minimum cost\nmy $min_cost = -1;\nfor (my $i = 0; $i < $n; $i++) {\n    my ($ti, $ci) = @{$taxis[$i]};\n    if ($distances[$i] <= $ti) {\n        if ($min_cost == -1 || $min_cost > $ci) {\n            $min_cost = $ci;\n        }\n    }\n}\n\n# Print output\nprint $min_cost;\n","Rust":"use std::cmp::min;\\nuse std::collections::BinaryHeap;\\nuse std::usize::MAX;\\n\\nstruct Edge {\\n    to: usize,\\n    cost: usize,\\n}\\n\\nfn dijkstra(graph: &Vec<Vec<Edge>>, start: usize, end: usize, taxis: &Vec<(usize, usize)>) -> Option<usize> {\\n    let mut dist: Vec<usize> = vec![MAX; graph.len()];\\n    let mut heap = BinaryHeap::new();\\n    dist[start] = 0;\\n    heap.push((0, start));\\n\\n    while let Some((cost, node)) = heap.pop() {\\n        if node == end {\\n            return Some(cost);\\n        }\\n\\n        if cost > dist[node] {\\n            continue;\\n        }\\n\\n        for edge in &graph[node] {\\n            let new_cost = cost + edge.cost;\\n            if new_cost <= taxis[node].0 && new_cost < dist[edge.to] {\\n                dist[edge.to] = new_cost;\\n                heap.push((new_cost, edge.to));\\n            }\\n        }\\n    }\\n\\n    None\\n}\\n\\nfn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut iter = input.split_whitespace();\\n    let n: usize = iter.next().unwrap().parse().unwrap();\\n    let m: usize = iter.next().unwrap().parse().unwrap();\\n\\n    input.clear();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let mut iter = input.split_whitespace();\\n    let start: usize = iter.next().unwrap().parse().unwrap();\\n    let end: usize = iter.next().unwrap().parse().unwrap();\\n\\n    let mut graph: Vec<Vec<Edge>> = vec![Vec::new(); n + 1];\\n\\n    for _ in 0..m {\\n        input.clear();\\n        std::io::stdin().read_line(&mut input).unwrap();\\n        let mut iter = input.split_whitespace();\\n        let u: usize = iter.next().unwrap().parse().unwrap();\\n        let v: usize = iter.next().unwrap().parse().unwrap();\\n        let w: usize = iter.next().unwrap().parse().unwrap();\\n        graph[u].push(Edge { to: v, cost: w });\\n        graph[v].push(Edge { to: u, cost: w });\\n    }\\n\\n    let mut taxis: Vec<(usize, usize)> = Vec::new();\\n\\n    for _ in 0..n {\\n        input.clear();\\n        std::io::stdin().read_line(&mut input).unwrap();\\n        let mut iter = input.split_whitespace();\\n        let t: usize = iter.next().unwrap().parse().unwrap();\\n        let c: usize = iter.next().unwrap().parse().unwrap();\\n        taxis.push((t, c));\\n    }\\n\\n    if let Some(cost) = dijkstra(&graph, start, end, &taxis) {\\n        println!(\\\"{}\\\", cost);\\n    } else {\\n        println!(\\\"-1\\\");\\n    }\\n}\\n"}
{"title":"A. Antipalindrome","description":"A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings \"kek\", \"abacaba\", \"r\" and \"papicipap\" are palindromes, while the strings \"abb\" and \"iq\" are not.A substring $$$s[l \\ldots r]$$$ ($$$1\u2264l\u2264r\u2264|s|$$$) of a string $$$s=s_{1}s_{2} \\ldots s_{|s|}$$$ is the string $$$s_{l}s_{l+1} \\ldots s_{r}$$$.Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $$$s$$$ is changed into its longest substring that is not a palindrome. If all the substrings of $$$s$$$ are palindromes, she skips the word at all.Some time ago Ann read the word $$$s$$$. What is the word she changed it into?","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains a non-empty string $$$s$$$ with length at most $$$50$$$ characters, containing lowercase English letters only.\n","output_spec":"If there is such a substring in $$$s$$$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $$$0$$$.\nNote that there can be multiple longest substrings that are not palindromes, but their length is unique.\n","notes":"\"mew\" is not a palindrome, so the longest substring of it that is not a palindrome, is the string \"mew\" itself. Thus, the answer for the first example is $$$3$$$.\nThe string \"uffuw\" is one of the longest non-palindrome substrings (of length $$$5$$$) of the string \"wuffuw\", so the answer for the second example is $$$5$$$.\nAll substrings of the string \"qqqqqqqq\" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $$$0$$$.\n","sample_inputs":["mew\n","wuffuw\n","qqqqqqqq\n"],"sample_outputs":["3\n","5\n","0\n"],"id":"981-A","difficulty":900,"tags":["brute+force","implementation","strings"],"src_uid":"6c85175d334f811617e7030e0403f706","C++":"#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nbool isPalindrome(string s) {\\n    int n = s.length();\\n    for (int i = 0; i < n \/ 2; i++) {\\n        if (s[i] != s[n - i - 1]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint longestNonPalindromeSubstring(string s) {\\n    int n = s.length();\\n    int maxLength = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = i; j < n; j++) {\\n            string substring = s.substr(i, j - i + 1);\\n            if (!isPalindrome(substring)) {\\n                maxLength = max(maxLength, j - i + 1);\\n            }\\n        }\\n    }\\n    return maxLength;\\n}\\n\\nint main() {\\n    string s;\\n    cin >> s;\\n    int maxLength = longestNonPalindromeSubstring(s);\\n    cout << maxLength << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String s = scanner.nextLine();\\n        int n = s.length();\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                if (!isPalindrome(s.substring(i, j + 1))) {\\n                    maxLength = Math.max(maxLength, j - i + 1);\\n                }\\n            }\\n        }\\n\\n        System.out.println(maxLength);\\n    }\\n\\n    private static boolean isPalindrome(String s) {\\n        int n = s.length();\\n        for (int i = 0; i < n \/ 2; i++) {\\n            if (s.charAt(i) != s.charAt(n - i - 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\"}}","Python":"def longest_non_palindrome_substring(s):\\n    n = len(s)\\n    max_len = 0\\n    for i in range(n):\\n        for j in range(i, n):\\n            substring = s[i:j+1]\\n            if substring != substring[::-1]:\\n                max_len = max(max_len, len(substring))\\n    return str(max_len)\\n\\ninput_str = input()\\nprint(longest_non_palindrome_substring(input_str))","C":"#include <stdio.h>\\n#include <string.h>\\n\\nint isPalindrome(char *str, int start, int end) {\\n    while (start < end) {\\n        if (str[start] != str[end]) {\\n            return 0;\\n        }\\n        start++;\\n        end--;\\n    }\\n    return 1;\\n}\\n\\nint findLongestNonPalindromeSubstring(char *str) {\\n    int length = strlen(str);\\n    int maxLength = 0;\\n\\n    for (int i = 0; i < length; i++) {\\n        for (int j = i; j < length; j++) {\\n            if (!isPalindrome(str, i, j)) {\\n                int substringLength = j - i + 1;\\n                if (substringLength > maxLength) {\\n                    maxLength = substringLength;\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxLength;\\n}\\n\\nint main() {\\n    char str[51];\\n    fgets(str, sizeof(str), stdin);\\n    str[strcspn(str, \\\"\\\\n\\\")] = 0;\\n\\n    int maxLength = findLongestNonPalindromeSubstring(str);\\n    printf(\\\"%d\\\\n\\\", maxLength);\\n\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string s = Console.ReadLine();\n        int n = s.Length;\n        \n        bool[,] dp = new bool[n, n];\n        int maxLength = 0;\n        \n        for (int i = 0; i < n; i++)\n        {\n            dp[i, i] = true;\n            maxLength = 1;\n        }\n        \n        int start = 0;\n        \n        for (int i = 0; i < n - 1; i++)\n        {\n            if (s[i] == s[i + 1])\n            {\n                dp[i, i + 1] = true;\n                start = i;\n                maxLength = 2;\n            }\n        }\n        \n        for (int k = 3; k <= n; k++)\n        {\n            for (int i = 0; i < n - k + 1; i++)\n            {\n                int j = i + k - 1;\n                \n                if (dp[i + 1, j - 1] && s[i] == s[j])\n                {\n                    dp[i, j] = true;\n                    \n                    if (k > maxLength)\n                    {\n                        start = i;\n                        maxLength = k;\n                    }\n                }\n            }\n        }\n        \n        if (maxLength > 1)\n        {\n            Console.WriteLine(maxLength.ToString());\n        }\n        else\n        {\n            Console.WriteLine(\"0\");\n        }\n    }\n}","Ruby":"\ndef longest_non_palindrome_substring(s)\n  n = s.length\n  max_length = 0\n  \n  for i in 0..n-1\n    for j in i..n-1\n      substring = s[i..j]\n      if !is_palindrome(substring)\n        length = substring.length\n        max_length = [max_length, length].max\n      end\n    end\n  end\n  \n  return max_length\nend\n\ndef is_palindrome(s)\n  return s == s.reverse\nend\n\n# Read input string\ninput_string = gets.chomp\n\n# Calculate and print the longest non-palindrome substring length\nputs longest_non_palindrome_substring(input_string)\n","delphi":"program Main;\\n\\n{$APPTYPE CONSOLE}\\n\\nuses\\n  SysUtils;\\n\\nfunction IsPalindrome(s: string): Boolean;\\nvar\\n  i, j: Integer;\\nbegin\\n  i := 1;\\n  j := Length(s);\\n  while (i < j) do\\n  begin\\n    if (s[i] <> s[j]) then\\n    begin\\n      Result := False;\\n      Exit;\\n    end;\\n    Inc(i);\\n    Dec(j);\\n  end;\\n  Result := True;\\nend;\\n\\nfunction LongestNonPalindromeSubstring(s: string): Integer;\\nvar\\n  i, j, len: Integer;\\n  substr: string;\\nbegin\\n  len := Length(s);\\n  Result := 0;\\n  for i := 1 to len do\\n  begin\\n    for j := i to len do\\n    begin\\n      substr := Copy(s, i, j - i + 1);\\n      if (not IsPalindrome(substr)) then\\n      begin\\n        if (Length(substr) > Result) then\\n          Result := Length(substr);\\n      end;\\n    end;\\n  end;\\nend;\\n\\nvar\\n  s: string;\\nbegin\\n  ReadLn(s);\\n  WriteLn(LongestNonPalindromeSubstring(s));\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar s string\\n\\tfmt.Scan(&s)\\n\\n\\tmaxLen := 0\\n\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tsub := s[i : j+1]\\n\\t\\t\\tif !isPalindrome(sub) && len(sub) > maxLen {\\n\\t\\t\\t\\tmaxLen = len(sub)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(maxLen)\\n}\\n\\nfunc isPalindrome(s string) bool {\\n\\tfor i := 0; i < len(s)\/2; i++ {\\n\\t\\tif s[i] != s[len(s)-i-1] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}","Javascript":"function findLongestNonPalindromeSubstring(s) {\n  let maxLength = 0;\n  \n  for (let i = 0; i < s.length; i++) {\n    for (let j = i; j < s.length; j++) {\n      let substring = s.substring(i, j + 1);\n      \n      if (!isPalindrome(substring) && substring.length > maxLength) {\n        maxLength = substring.length;\n      }\n    }\n  }\n  \n  return maxLength;\n}\n\nfunction isPalindrome(s) {\n  let left = 0;\n  let right = s.length - 1;\n  \n  while (left < right) {\n    if (s[left] !== s[right]) {\n      return false;\n    }\n    \n    left++;\n    right--;\n  }\n  \n  return true;\n}\n\n\/\/ Test cases\nconsole.log(findLongestNonPalindromeSubstring('mew')); \/\/ Output: 3\nconsole.log(findLongestNonPalindromeSubstring('wuffuw')); \/\/ Output: 5\nconsole.log(findLongestNonPalindromeSubstring('qqqqqqqq')); \/\/ Output: 0","Kotlin":"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val s = sc.nextLine()\n    val n = s.length\n    var maxLength = 0\n    \n    for (i in 0 until n) {\n        for (j in i until n) {\n            val substring = s.substring(i, j + 1)\n            if (!isPalindrome(substring)) {\n                maxLength = maxOf(maxLength, substring.length)\n            }\n        }\n    }\n    \n    println(maxLength)\n}\n\nfun isPalindrome(s: String): Boolean {\n    val n = s.length\n    for (i in 0 until n \/ 2) {\n        if (s[i] != s[n - i - 1]) {\n            return false\n        }\n    }\n    return true\n}","PHP":"\n<?php\n\nfunction longestNonPalindromeSubstring($s) {\n    $n = strlen($s);\n    $maxLen = 0;\n    \n    for ($i = 0; $i < $n; $i++) {\n        for ($j = $n - 1; $j >= $i; $j--) {\n            if ($s[$i] != $s[$j]) {\n                $len = $j - $i + 1;\n                if ($len > $maxLen) {\n                    $maxLen = $len;\n                }\n                break;\n            }\n        }\n    }\n    \n    return $maxLen;\n}\n\n$input = trim(fgets(STDIN));\n$output = longestNonPalindromeSubstring($input);\necho $output;\n\n?>","d":"import std.stdio;\\r\\n\\r\\nstring findLongestNonPalindromeSubstring(string s) {\\r\\n    int n = s.length;\\r\\n    int maxLength = 0;\\r\\n    for (int i = 0; i < n; i++) {\\r\\n        for (int j = i; j < n; j++) {\\r\\n            bool isPalindrome = true;\\r\\n            for (int k = i, l = j; k < l; k++, l--) {\\r\\n                if (s[k] != s[l]) {\\r\\n                    isPalindrome = false;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            if (!isPalindrome) {\\r\\n                int length = j - i + 1;\\r\\n                if (length > maxLength) {\\r\\n                    maxLength = length;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return to!string(maxLength);\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    string s;\\r\\n    readln(s);\\r\\n    writeln(findLongestNonPalindromeSubstring(s));\\r\\n}","perl":"\n# Read the input string\nmy $s = <STDIN>;\nchomp $s;\n\n# Initialize variables\nmy $max_length = 0;\nmy $length = length($s);\n\n# Check all substrings of the input string\nfor (my $i = 0; $i < $length; $i++) {\n    for (my $j = $i; $j < $length; $j++) {\n        # Get the substring\n        my $substring = substr($s, $i, $j - $i + 1);\n        \n        # Check if the substring is a palindrome\n        if (!is_palindrome($substring)) {\n            # Update the maximum length if necessary\n            my $substring_length = length($substring);\n            if ($substring_length > $max_length) {\n                $max_length = $substring_length;\n            }\n        }\n    }\n}\n\n# Print the maximum length of a non-palindrome substring\nprint $max_length;\n\n# Function to check if a string is a palindrome\nsub is_palindrome {\n    my ($string) = @_;\n    my $reverse = reverse($string);\n    return $string eq $reverse;\n}\n","Rust":"\nuse std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    if let Some(Ok(s)) = lines.next() {\n        let mut max_length = 0;\n\n        for i in 0..s.len() {\n            for j in i..s.len() {\n                let substring = &s[i..=j];\n                if !is_palindrome(substring) && substring.len() > max_length {\n                    max_length = substring.len();\n                }\n            }\n        }\n\n        println!(\"{}\", max_length);\n    }\n}\n\nfn is_palindrome(s: &str) -> bool {\n    let chars: Vec<char> = s.chars().collect();\n    let len = chars.len();\n    for i in 0..len \/ 2 {\n        if chars[i] != chars[len - 1 - i] {\n            return false;\n        }\n    }\n    true\n}\n"}
{"title":"C. Candies","description":"After passing a test, Vasya got himself a box of $$$n$$$ candies. He decided to eat an equal amount of candies each morning until there are no more candies. However, Petya also noticed the box and decided to get some candies for himself.This means the process of eating candies is the following: in the beginning Vasya chooses a single integer $$$k$$$, same for all days. After that, in the morning he eats $$$k$$$ candies from the box (if there are less than $$$k$$$ candies in the box, he eats them all), then in the evening Petya eats $$$10\\%$$$ of the candies remaining in the box. If there are still candies left in the box, the process repeats\u00a0\u2014 next day Vasya eats $$$k$$$ candies again, and Petya\u00a0\u2014 $$$10\\%$$$ of the candies left in a box, and so on.If the amount of candies in the box is not divisible by $$$10$$$, Petya rounds the amount he takes from the box down. For example, if there were $$$97$$$ candies in the box, Petya would eat only $$$9$$$ of them. In particular, if there are less than $$$10$$$ candies in a box, Petya won't eat any at all.Your task is to find out the minimal amount of $$$k$$$ that can be chosen by Vasya so that he would eat at least half of the $$$n$$$ candies he initially got. Note that the number $$$k$$$ must be integer.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The first line contains a single integer $$$n$$$ ($$$1 \\\\leq n \\\\leq 10^{18}$$$)\u00a0\u2014 the initial amount of candies in the box.\n","output_spec":"Output a single integer\u00a0\u2014 the minimal amount of $$$k$$$ that would allow Vasya to eat at least half of candies he got.\n","notes":"In the sample, the amount of candies, with $$$k=3$$$, would change in the following way (Vasya eats first):\n$$$68 \\\\to 65 \\\\to 59 \\\\to 56 \\\\to 51 \\\\to 48 \\\\to 44 \\\\to 41 \\\\\\\\ \\\\to 37 \\\\to 34 \\\\to 31 \\\\to 28 \\\\to 26 \\\\to 23 \\\\to 21 \\\\to 18 \\\\to 17 \\\\to 14 \\\\\\\\ \\\\to 13 \\\\to 10 \\\\to 9 \\\\to 6 \\\\to 6 \\\\to 3 \\\\to 3 \\\\to 0$$$.\nIn total, Vasya would eat $$$39$$$ candies, while Petya\u00a0\u2014 $$$29$$$.\n","sample_inputs":["68\n"],"sample_outputs":["3\n"],"id":"991-C","difficulty":1500,"tags":["binary+search","implementation"],"src_uid":"db1a50da538fa82038f8db6104d2ab93","C++":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    long long n;\\n    cin >> n;\\n\\n    long long k = 1;\\n    long long candies_eaten = 0;\\n\\n    while (candies_eaten < n \/ 2) {\\n        candies_eaten = 0;\\n        long long candies_left = n;\\n\\n        while (candies_left > 0) {\\n            long long eaten_by_vasya = min(k, candies_left);\\n            candies_left -= eaten_by_vasya;\\n\\n            long long eaten_by_petya = candies_left \/ 10;\\n            candies_left -= eaten_by_petya;\\n\\n            candies_eaten += eaten_by_vasya;\\n        }\\n\\n        k++;\\n    }\\n\\n    cout << k - 1 << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        long n = scanner.nextLong();\\n        long k = 1;\\n        long candiesEaten = 0;\\n        long candiesRemaining = n;\\n\\n        while (candiesRemaining > 0) {\\n            candiesEaten += Math.min(k, candiesRemaining);\\n            candiesRemaining -= Math.min(k, candiesRemaining);\\n            candiesRemaining -= candiesRemaining \/ 10;\\n            k++;\\n        }\\n\\n        System.out.println(k - 1);\\n    }\\n}","Python":"def minimal_k(n):\\n    candies_left = n\\n    k = 1\\n    while candies_left > n\/2:\\n        candies_left = n\\n        for i in range(k):\\n            candies_left -= k\\n            if candies_left < 10:\\n                break\\n            candies_left -= candies_left \/\/ 10\\n        k += 1\\n    return k-1\\n\\nn = int(input())\\nprint(minimal_k(n))","C":"#include <stdio.h>\\n\\nint main() {\\n    long long int n;\\n    scanf(\\\"%lld\\\", &n);\\n    long long int k = 1;\\n    long long int candies_eaten = 0;\\n    long long int candies_remaining = n;\\n    while (candies_eaten < n\/2) {\\n        candies_remaining = n;\\n        candies_eaten = 0;\\n        while (candies_remaining > 0) {\\n            if (candies_remaining < k) {\\n                candies_eaten += candies_remaining;\\n                break;\\n            }\\n            candies_eaten += k;\\n            candies_remaining -= k;\\n            candies_remaining -= candies_remaining\/10;\\n        }\\n        k++;\\n    }\\n    printf(\\\"%lld\\\", k-1);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        long n = long.Parse(Console.ReadLine());\n        \n        long k = 1;\n        long candiesEaten = 0;\n        \n        while (candiesEaten < n \/ 2)\n        {\n            candiesEaten = 0;\n            long candiesRemaining = n;\n            \n            while (candiesRemaining > 0)\n            {\n                long candiesToEat = Math.Min(k, candiesRemaining);\n                candiesRemaining -= candiesToEat;\n                candiesEaten += candiesToEat;\n                \n                if (candiesRemaining >= 10)\n                {\n                    long petyasShare = candiesRemaining \/ 10;\n                    candiesRemaining -= petyasShare;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            k++;\n        }\n        \n        Console.WriteLine(k - 1);\n    }\n}","Ruby":"\ndef minimal_k(n)\n  candies_left = n\n  k = 1\n  while candies_left > n \/ 2\n    candies_left = n\n    while candies_left > 0\n      candies_eaten = [k, candies_left].min\n      candies_left -= candies_eaten\n      candies_left -= candies_left \/ 10 if candies_left >= 10\n    end\n    k += 1\n  end\n  return k - 1\nend\n\nn = gets.to_i\nputs minimal_k(n)\n","delphi":"program MinimalAmountOfCandies;\\n\\nvar\\n  n, k, candiesEaten, candiesRemaining, petyaCandies: Int64;\\n\\nbegin\\n  \/\/ Read the initial amount of candies\\n  ReadLn(n);\\n\\n  \/\/ Initialize variables\\n  k := 1;\\n  candiesEaten := 0;\\n\\n  \/\/ Loop until Vasya eats at least half of the candies\\n  while candiesEaten < n div 2 do\\n  begin\\n    \/\/ Reset the candies remaining and Petya's candies\\n    candiesRemaining := n;\\n    petyaCandies := 0;\\n\\n    \/\/ Loop until there are no more candies\\n    while candiesRemaining > 0 do\\n    begin\\n      \/\/ Vasya eats k candies\\n      if candiesRemaining >= k then\\n      begin\\n        candiesRemaining := candiesRemaining - k;\\n        candiesEaten := candiesEaten + k;\\n      end\\n      else\\n      begin\\n        candiesEaten := candiesEaten + candiesRemaining;\\n        candiesRemaining := 0;\\n      end;\\n\\n      \/\/ Petya eats 10% of the remaining candies\\n      if candiesRemaining >= 10 then\\n      begin\\n        petyaCandies := candiesRemaining div 10;\\n        candiesRemaining := candiesRemaining - petyaCandies;\\n      end\\n      else\\n      begin\\n        petyaCandies := 0;\\n        candiesRemaining := 0;\\n      end;\\n    end;\\n\\n    \/\/ Increase k by 1\\n    Inc(k);\\n  end;\\n\\n  \/\/ Output the minimal amount of k\\n  WriteLn(k);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int64\\n\\tfmt.Scan(&n)\\n\\n\\t\/\/ Binary search to find the minimal k\\n\\tleft := int64(1)\\n\\tright := n\\n\\n\\tfor left < right {\\n\\t\\tmid := (left + right) \/ 2\\n\\t\\tcandiesEaten := eatCandies(n, mid)\\n\\n\\t\\tif candiesEaten >= n\/2 {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(left)\\n}\\n\\nfunc eatCandies(n, k int64) int64 {\\n\\tcandiesEaten := int64(0)\\n\\tcandiesLeft := n\\n\\n\\tfor candiesLeft > 0 {\\n\\t\\tif candiesLeft < k {\\n\\t\\t\\tcandiesEaten += candiesLeft\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tcandiesEaten += k\\n\\t\\tcandiesLeft -= k\\n\\n\\t\\tpetyaEats := int64(math.Floor(float64(candiesLeft) * 0.1))\\n\\t\\tif petyaEats < 10 && candiesLeft >= 10 {\\n\\t\\t\\tpetyaEats = 10\\n\\t\\t}\\n\\n\\t\\tcandiesEaten += petyaEats\\n\\t\\tcandiesLeft -= petyaEats\\n\\t}\\n\\n\\treturn candiesEaten\\n}","Javascript":"function findMinimalK(n) {\\n    let k = 1;\\n    let eatenCandies = 0;\\n    let remainingCandies = n;\\n\\n    while (eatenCandies < Math.ceil(n \/ 2)) {\\n        eatenCandies += k;\\n        remainingCandies -= k;\\n\\n        if (remainingCandies < 10) {\\n            break;\\n        }\\n\\n        let petyaEats = Math.floor(remainingCandies * 0.1);\\n        eatenCandies += petyaEats;\\n        remainingCandies -= petyaEats;\\n\\n        k++;\\n    }\\n\\n    return k;\\n}\\n\\nconst n = 68;\\nconst minimalK = findMinimalK(n);\\nconsole.log(minimalK);","Kotlin":"import kotlin.math.ceil\\n\\nfun main() {\\n    val n = readLine()!!.toLong()\\n    var k = 1L\\n    var eatenCandies = 0L\\n    var remainingCandies = n\\n\\n    while (eatenCandies < ceil(n.toDouble() \/ 2)) {\\n        eatenCandies = 0\\n        remainingCandies = n\\n        k++\\n\\n        while (remainingCandies > 0) {\\n            eatenCandies += minOf(k, remainingCandies)\\n            remainingCandies -= k\\n            remainingCandies -= remainingCandies \/ 10\\n        }\\n    }\\n\\n    println(k)\\n}","PHP":"\n<?php\n\nfunction findMinimalK($n) {\n    $k = 1;\n    $candiesEatenByVasya = 0;\n    $candiesEatenByPetya = 0;\n    \n    while ($candiesEatenByVasya < ceil($n\/2)) {\n        $candiesLeft = $n;\n        \n        while ($candiesLeft > 0) {\n            $candiesEatenByVasya += $k;\n            $candiesLeft -= $k;\n            \n            if ($candiesLeft > 0) {\n                $candiesEatenByPetya += floor($candiesLeft * 0.1);\n                $candiesLeft -= floor($candiesLeft * 0.1);\n            }\n        }\n        \n        $k++;\n    }\n    \n    return $k - 1;\n}\n\n$input = trim(fgets(STDIN));\n$n = intval($input);\n\n$result = findMinimalK($n);\necho $result;\n\n?>\n","d":"import std.stdio;\\r\\n\\r\\nint main()\\r\\n{\\r\\n    ulong n;\\r\\n    readf(\\\"%lu\\\", &n);\\r\\n\\r\\n    ulong k = 1;\\r\\n    ulong candiesEaten = 0;\\r\\n\\r\\n    while (candiesEaten < n \/ 2)\\r\\n    {\\r\\n        ulong candiesLeft = n;\\r\\n        ulong petyaCandies = 0;\\r\\n\\r\\n        while (candiesLeft > 0)\\r\\n        {\\r\\n            candiesLeft -= k;\\r\\n            candiesEaten += k;\\r\\n\\r\\n            if (candiesLeft >= 10)\\r\\n            {\\r\\n                ulong petyaShare = candiesLeft \/ 10;\\r\\n                petyaCandies += petyaShare;\\r\\n                candiesLeft -= petyaShare;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (candiesEaten < n \/ 2)\\r\\n        {\\r\\n            k++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(k);\\r\\n\\r\\n    return 0;\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub minimal_k {\n    my ($n) = @_;\n    \n    my $k = 1;\n    my $candies_eaten = 0;\n    \n    while ($candies_eaten < $n\/2) {\n        my $candies_remaining = $n;\n        my $vasya_candies_eaten = 0;\n        \n        while ($candies_remaining > 0) {\n            my $vasya_eats = $k;\n            if ($vasya_eats > $candies_remaining) {\n                $vasya_eats = $candies_remaining;\n            }\n            \n            $candies_remaining -= $vasya_eats;\n            $vasya_candies_eaten += $vasya_eats;\n            \n            my $petya_eats = int($candies_remaining \/ 10);\n            if ($petya_eats > 0 && $candies_remaining % 10 != 0) {\n                $petya_eats--;\n            }\n            \n            $candies_remaining -= $petya_eats;\n        }\n        \n        $candies_eaten = $vasya_candies_eaten;\n        $k++;\n    }\n    \n    return $k-1;\n}\n\nmy $n = <STDIN>;\nchomp($n);\n\nmy $result = minimal_k($n);\nprint $result;\n","Rust":"fn main() {\\n    let mut input = String::new();\\n    std::io::stdin().read_line(&mut input).unwrap();\\n    let n: u64 = input.trim().parse().unwrap();\\n\\n    let mut k = 1;\\n    let mut candies = n;\\n    let mut vasya_eaten = 0;\\n\\n    while candies > 0 {\\n        let eaten = std::cmp::min(k, candies);\\n        candies -= eaten;\\n        vasya_eaten += eaten;\\n\\n        if candies > 0 {\\n            let petya_eaten = candies \/ 10;\\n            candies -= petya_eaten;\\n        }\\n\\n        k += 1;\\n    }\\n\\n    println!(\\\"{}\\\", k - 1);\\n}"}
{"title":"B. Nastya Studies Informatics","description":"Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.We define a pair of integers (a,b) good, if GCD(a,b)=x and LCM(a,b)=y, where GCD(a,b) denotes the greatest common divisor of a and b, and LCM(a,b) denotes the least common multiple of a and b.You are given two integers x and y. You are to find the number of good pairs of integers (a,b) such that l\u2264a,b\u2264r. Note that pairs (a,b) and (b,a) are considered different if a\u2260b.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"256 megabytes","input_spec":"The only line contains four integers l,r,x,y (1\u2264l\u2264r\u226410^9, 1\u2264x\u2264y\u226410^9).\n","output_spec":"In the only line print the only integer\u00a0\u2014 the answer for the problem.\n","notes":"In the first example there are two suitable good pairs of integers (a,b): (1,2) and (2,1).\nIn the second example there are four suitable good pairs of integers (a,b): (1,12), (12,1), (3,4) and (4,3).\nIn the third example there are good pairs of integers, for example, (3,30), but none of them fits the condition l\u2264a,b\u2264r.\n","sample_inputs":["1 2 1 2\n","1 12 1 12\n","50 100 3 30\n"],"sample_outputs":["2\n","4\n","0\n"],"id":"992-B","difficulty":1600,"tags":["math","number+theory"],"src_uid":"d37dde5841116352c9b37538631d0b15","C++":"#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint lcm(int a, int b) {\\n    return (a * b) \/ gcd(a, b);\\n}\\n\\nint main() {\\n    int l, r, x, y;\\n    cin >> l >> r >> x >> y;\\n\\n    int count = 0;\\n\\n    for (int a = l; a <= r; a++) {\\n        for (int b = l; b <= r; b++) {\\n            if (a != b && gcd(a, b) == x && lcm(a, b) == y) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class GoodPairs {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int l = scanner.nextInt();\\n        int r = scanner.nextInt();\\n        int x = scanner.nextInt();\\n        int y = scanner.nextInt();\\n\\n        int count = 0;\\n\\n        for (int a = l; a <= r; a++) {\\n            for (int b = l; b <= r; b++) {\\n                if (a != b && gcd(a, b) == x && lcm(a, b) == y) {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n\\n    public static int gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n\\n    public static int lcm(int a, int b) {\\n        return (a * b) \/ gcd(a, b);\\n    }\\n}\"}}","Python":"def count_good_pairs(l, r, x, y):\\n    count = 0\\n    for a in range(l, r+1):\\n        for b in range(l, r+1):\\n            if a != b and gcd(a, b) == x and lcm(a, b) == y:\\n                count += 1\\n    return count\\n\\n\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a % b\\n    return a\\n\\n\\ndef lcm(a, b):\\n    return a * b \/\/ gcd(a, b)\\n\\n\\ninput_data = input().split()\\nl = int(input_data[0])\\nr = int(input_data[1])\\nx = int(input_data[2])\\ny = int(input_data[3])\\n\\nresult = count_good_pairs(l, r, x, y)\\nprint(result)","C":"#include <stdio.h>\\n\\nint gcd(int a, int b) {\\n    if (b == 0)\\n        return a;\\n    return gcd(b, a % b);\\n}\\n\\nint lcm(int a, int b) {\\n    return (a * b) \/ gcd(a, b);\\n}\\n\\nint main() {\\n    int l, r, x, y;\\n    scanf(\\\"%d %d %d %d\\\", &l, &r, &x, &y);\\n\\n    int count = 0;\\n\\n    for (int a = l; a <= r; a++) {\\n        for (int b = l; b <= r; b++) {\\n            if (a != b && gcd(a, b) == x && lcm(a, b) == y) {\\n                count++;\\n            }\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", count);\\n\\n    return 0;\\n}","C#":"\nusing System;\n\nnamespace GoodPairs\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int l = int.Parse(input[0]);\n            int r = int.Parse(input[1]);\n            int x = int.Parse(input[2]);\n            int y = int.Parse(input[3]);\n\n            int count = 0;\n\n            for (int a = l; a <= r; a++)\n            {\n                for (int b = l; b <= r; b++)\n                {\n                    if (a != b && GCD(a, b) == x && LCM(a, b) == y)\n                    {\n                        count++;\n                    }\n                }\n            }\n\n            Console.WriteLine(count);\n        }\n\n        static int GCD(int a, int b)\n        {\n            while (b != 0)\n            {\n                int temp = b;\n                b = a % b;\n                a = temp;\n            }\n            return a;\n        }\n\n        static int LCM(int a, int b)\n        {\n            return (a \/ GCD(a, b)) * b;\n        }\n    }\n}\n","Ruby":"\ndef gcd(a, b)\n  if b == 0\n    return a\n  else\n    return gcd(b, a % b)\n  end\nend\n\ndef lcm(a, b)\n  return (a * b) \/ gcd(a, b)\nend\n\ndef count_good_pairs(l, r, x, y)\n  count = 0\n  for a in l..r\n    for b in l..r\n      if a != b && gcd(a, b) == x && lcm(a, b) == y\n        count += 1\n      end\n    end\n  end\n  return count\nend\n\ninput = gets.chomp.split(' ').map(&:to_i)\nl = input[0]\nr = input[1]\nx = input[2]\ny = input[3]\n\noutput = count_good_pairs(l, r, x, y)\nputs output\n","delphi":"program GoodPairs;\n\nvar\n  l, r, x, y, count: Integer;\n\nfunction GCD(a, b: Integer): Integer;\nbegin\n  if b = 0 then\n    Result := a\n  else\n    Result := GCD(b, a mod b);\nend;\n\nfunction LCM(a, b: Integer): Integer;\nbegin\n  Result := (a * b) div GCD(a, b);\nend;\n\nbegin\n  \/\/ Read input values\n  Readln(l, r, x, y);\n  \n  \/\/ Initialize count\n  count := 0;\n  \n  \/\/ Iterate through all possible pairs (a, b)\n  for var a := l to r do\n  begin\n    for var b := l to r do\n    begin\n      \/\/ Check if the pair is good\n      if (GCD(a, b) = x) and (LCM(a, b) = y) and (a <> b) then\n        Inc(count);\n    end;\n  end;\n  \n  \/\/ Print the result\n  Writeln(count);\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n)\\n\\nfunc gcd(a, b int) int {\\n\\tif b == 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn gcd(b, a%b)\\n}\\n\\nfunc lcm(a, b int) int {\\n\\treturn (a * b) \/ gcd(a, b)\\n}\\n\\nfunc countGoodPairs(l, r, x, y int) int {\\n\\tcount := 0\\n\\tfor a := l; a <= r; a++ {\\n\\t\\tfor b := l; b <= r; b++ {\\n\\t\\t\\tif gcd(a, b) == x && lcm(a, b) == y && a != b {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n\\nfunc main() {\\n\\tvar l, r, x, y int\\n\\tfmt.Scanf(\\\"%d %d %d %d\\\", &l, &r, &x, &y)\\n\\tresult := countGoodPairs(l, r, x, y)\\n\\tfmt.Println(result)\\n}","Javascript":"\nfunction gcd(a, b) {\n    if (b === 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nfunction lcm(a, b) {\n    return (a * b) \/ gcd(a, b);\n}\n\nfunction countGoodPairs(l, r, x, y) {\n    let count = 0;\n    for (let a = l; a <= r; a++) {\n        for (let b = l; b <= r; b++) {\n            if (a !== b && gcd(a, b) === x && lcm(a, b) === y) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nconst input = '1 2 1 2';\nconst [l, r, x, y] = input.split(' ').map(Number);\nconst result = countGoodPairs(l, r, x, y);\nconsole.log(result);\n","Kotlin":"import kotlin.math.*\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val l = input[0]\\n    val r = input[1]\\n    val x = input[2]\\n    val y = input[3]\\n\\n    var count = 0\\n\\n    for (a in l..r) {\\n        if (y % a == 0 && gcd(a, y \/ a) == x) {\\n            count++\\n        }\\n    }\\n\\n    println(count)\\n}\\n\\nfun gcd(a: Int, b: Int): Int {\\n    return if (b == 0) a else gcd(b, a % b)\\n}","PHP":"\n<?php\n\nfunction gcd($a, $b) {\n    while ($b != 0) {\n        $temp = $a;\n        $a = $b;\n        $b = $temp % $b;\n    }\n    return $a;\n}\n\nfunction lcm($a, $b) {\n    return ($a * $b) \/ gcd($a, $b);\n}\n\nfunction countGoodPairs($l, $r, $x, $y) {\n    $count = 0;\n    for ($a = $l; $a <= $r; $a++) {\n        for ($b = $l; $b <= $r; $b++) {\n            if ($a != $b && gcd($a, $b) == $x && lcm($a, $b) == $y) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\n$input = explode(' ', trim(fgets(STDIN)));\n$l = intval($input[0]);\n$r = intval($input[1]);\n$x = intval($input[2]);\n$y = intval($input[3]);\n\n$result = countGoodPairs($l, $r, $x, $y);\necho $result;\n\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\n\\r\\nint gcd(int a, int b)\\r\\n{\\r\\n    while (b != 0)\\r\\n    {\\r\\n        int temp = b;\\r\\n        b = a % b;\\r\\n        a = temp;\\r\\n    }\\r\\n    return a;\\r\\n}\\r\\n\\r\\nint lcm(int a, int b)\\r\\n{\\r\\n    return a * b \/ gcd(a, b);\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int l, r, x, y;\\r\\n    readf(\\\"%d %d %d %d\\\", &l, &r, &x, &y);\\r\\n\\r\\n    int count = 0;\\r\\n    for (int a = l; a <= r; a++)\\r\\n    {\\r\\n        for (int b = l; b <= r; b++)\\r\\n        {\\r\\n            if (a != b && gcd(a, b) == x && lcm(a, b) == y)\\r\\n            {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\nsub gcd {\n    my ($a, $b) = @_;\n    while ($b) {\n        ($a, $b) = ($b, $a % $b);\n    }\n    return $a;\n}\n\nsub lcm {\n    my ($a, $b) = @_;\n    return ($a * $b) \/ gcd($a, $b);\n}\n\nsub count_good_pairs {\n    my ($l, $r, $x, $y) = @_;\n    my $count = 0;\n    for my $a ($l..$r) {\n        for my $b ($l..$r) {\n            next if $a == $b;\n            if (gcd($a, $b) == $x && lcm($a, $b) == $y) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\n# Read input\nmy $input = <STDIN>;\nchomp $input;\nmy ($l, $r, $x, $y) = split ' ', $input;\n\n# Calculate and print the answer\nmy $answer = count_good_pairs($l, $r, $x, $y);\nprint $answer;\n","Rust":"fn main() {\\n    let input = String::from(\\\"1 2 1 2\\\\n\\\");\\n    let mut input = input.split_whitespace();\\n    let l: i32 = input.next().unwrap().parse().unwrap();\\n    let r: i32 = input.next().unwrap().parse().unwrap();\\n    let x: i32 = input.next().unwrap().parse().unwrap();\\n    let y: i32 = input.next().unwrap().parse().unwrap();\\n\\n    let mut count = 0;\\n\\n    for a in l..=r {\\n        for b in l..=r {\\n            if gcd(a, b) == x && lcm(a, b) == y && a != b {\\n                count += 1;\\n            }\\n        }\\n    }\\n\\n    println!(\\\"{}\\\", count);\\n}\\n\\nfn gcd(a: i32, b: i32) -> i32 {\\n    if b == 0 {\\n        return a;\\n    }\\n    gcd(b, a % b)\\n}\\n\\nfn lcm(a: i32, b: i32) -> i32 {\\n    a * b \/ gcd(a, b)\\n}"}
{"title":"B. Running Student","description":"And again a misfortune fell on Poor Student. He is being late for an exam.Having rushed to a bus stop that is in point (0,0), he got on a minibus and they drove along a straight line, parallel to axis OX, in the direction of increasing x.Poor Student knows the following:   during one run the minibus makes n stops, the i-th stop is in point (xi,0)  coordinates of all the stops are different  the minibus drives at a constant speed, equal to vb  it can be assumed the passengers get on and off the minibus at a bus stop momentarily  Student can get off the minibus only at a bus stop  Student will have to get off the minibus at a terminal stop, if he does not get off earlier  the University, where the exam will be held, is in point (xu,yu)  Student can run from a bus stop to the University at a constant speed vs as long as needed  a distance between two points can be calculated according to the following formula:   Student is already on the minibus, so, he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible. Help him to choose the bus stop, where he should get off. If such bus stops are multiple, choose the bus stop closest to the University.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"The first line contains three integer numbers: 2\u2264n\u2264100, 1\u2264vb,vs\u22641000. The second line contains n non-negative integers in ascending order: coordinates xi of the bus stop with index i. It is guaranteed that x1 equals to zero, and xn\u226410^5. The third line contains the coordinates of the University, integers xu and yu, not exceeding 10^5 in absolute value. \n","output_spec":"In the only line output the answer to the problem \u2014 index of the optimum bus stop.\n","notes":"As you know, students are a special sort of people, and minibuses usually do not hurry. That's why you should not be surprised, if Student's speed is higher than the speed of the minibus.\n","sample_inputs":["4 5 2\n0 2 4 6\n4 1\n","2 1 1\n0 100000\n100000 100000\n"],"sample_outputs":["3","2"],"id":"9-B","difficulty":1200,"tags":["brute+force","geometry","implementation"],"src_uid":"15fa49860e978d3b3fb7a20bf9f8aa86","C++":"#include <iostream>\\n#include <vector>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n, vb, vs;\\n    cin >> n >> vb >> vs;\\n    vector<int> stops(n);\\n    for (int i = 0; i < n; i++) {\\n        cin >> stops[i];\\n    }\\n    int xu, yu;\\n    cin >> xu >> yu;\\n\\n    double minTime = 1e9;\\n    int bestStop = -1;\\n\\n    for (int i = 1; i < n; i++) {\\n        double timeToStop = stops[i] \/ (double) vb;\\n        double distanceToUni = sqrt(pow(stops[i] - xu, 2) + pow(yu, 2));\\n        double timeToUni = distanceToUni \/ (double) vs;\\n        double totalTime = timeToStop + timeToUni;\\n\\n        if (totalTime < minTime) {\\n            minTime = totalTime;\\n            bestStop = i + 1;\\n        }\\n    }\\n\\n    cout << bestStop << endl;\\n\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class OptimumBusStop {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        String input = scanner.nextLine();\\n        String[] inputArr = input.split(\\\" \\\");\\n        int n = Integer.parseInt(inputArr[0]);\\n        int vb = Integer.parseInt(inputArr[1]);\\n        int vs = Integer.parseInt(inputArr[2]);\\n\\n        input = scanner.nextLine();\\n        inputArr = input.split(\\\" \\\");\\n        int[] stops = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            stops[i] = Integer.parseInt(inputArr[i]);\\n        }\\n\\n        input = scanner.nextLine();\\n        inputArr = input.split(\\\" \\\");\\n        int xu = Integer.parseInt(inputArr[0]);\\n        int yu = Integer.parseInt(inputArr[1]);\\n\\n        int optimumStop = findOptimumBusStop(n, vb, vs, stops, xu, yu);\\n        System.out.println(optimumStop);\\n    }\\n\\n    public static int findOptimumBusStop(int n, int vb, int vs, int[] stops, int xu, int yu) {\\n        double minTime = Double.MAX_VALUE;\\n        int optimumStop = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            double timeToStop = stops[i] \/ (double) vb;\\n            double timeToUniversity = Math.sqrt(Math.pow(stops[i], 2) + Math.pow(yu, 2)) \/ (double) vs;\\n            double totalTime = timeToStop + timeToUniversity;\\n\\n            if (totalTime < minTime) {\\n                minTime = totalTime;\\n                optimumStop = i + 1;\\n            }\\n        }\\n\\n        return optimumStop;\\n    }\\n}\"}}","Python":"def find_optimum_bus_stop(input_str):\n    # Parse the input string\n    n, vb, vs = map(int, input_str.split('\\\\n')[0].split())\n    bus_stops = list(map(int, input_str.split('\\\\n')[1].split()))\n    university = list(map(int, input_str.split('\\\\n')[2].split()))\n\n    # Calculate the time taken to reach each bus stop\n    times = []\n    for i in range(1, n):\n        distance_to_stop = bus_stops[i]\n        time_to_stop = distance_to_stop \/ vb\n        distance_to_university = ((university[0] - bus_stops[i]) ** 2 + university[1] ** 2) ** 0.5\n        time_to_university = distance_to_university \/ vs\n        total_time = time_to_stop + time_to_university\n        times.append(total_time)\n\n    # Find the index of the bus stop with the minimum time\n    min_time = min(times)\n    min_index = times.index(min_time) + 2\n\n    return str(min_index)\n\n# Test the function with the sample inputs\ninput_str = '4 5 2\\\\n0 2 4 6\\\\n4 1\\\\n'\nprint(find_optimum_bus_stop(input_str))\n\ninput_str = '2 1 1\\\\n0 100000\\\\n100000 100000\\\\n'\nprint(find_optimum_bus_stop(input_str))","C":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <math.h>\\n\\nint main() {\\n    int n, vb, vs;\\n    scanf(\\\"%d %d %d\\\", &n, &vb, &vs);\\n    int stops[n];\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\\"%d\\\", &stops[i]);\\n    }\\n    int xu, yu;\\n    scanf(\\\"%d %d\\\", &xu, &yu);\\n\\n    double minTime = 1e9;\\n    int bestStop = 0;\\n\\n    for (int i = 1; i < n; i++) {\\n        double timeToStop = (double)stops[i] \/ vb;\\n        double timeToUni = sqrt(pow(stops[i], 2) + pow(yu, 2)) \/ vs;\\n        double totalTime = timeToStop + timeToUni;\\n\\n        if (totalTime < minTime) {\\n            minTime = totalTime;\\n            bestStop = i;\\n        }\\n    }\\n\\n    printf(\\\"%d\\\\n\\\", bestStop);\\n\\n    return 0;\\n}","C#":"using System;\nusing System.Collections.Generic;\n\nnamespace OptimumBusStop\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string input = Console.ReadLine();\n            string[] inputArr = input.Split(' ');\n\n            int n = int.Parse(inputArr[0]);\n            int vb = int.Parse(inputArr[1]);\n            int vs = int.Parse(inputArr[2]);\n\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n\n            List<int> busStops = new List<int>();\n            for (int i = 0; i < n; i++)\n            {\n                busStops.Add(int.Parse(inputArr[i]));\n            }\n\n            input = Console.ReadLine();\n            inputArr = input.Split(' ');\n\n            int xu = int.Parse(inputArr[0]);\n            int yu = int.Parse(inputArr[1]);\n\n            int optimumBusStop = GetOptimumBusStop(n, vb, vs, busStops, xu, yu);\n            Console.WriteLine(optimumBusStop);\n        }\n\n        static int GetOptimumBusStop(int n, int vb, int vs, List<int> busStops, int xu, int yu)\n        {\n            double minTime = double.MaxValue;\n            int optimumBusStop = 0;\n\n            for (int i = 1; i < n; i++)\n            {\n                double timeToBusStop = busStops[i] \/ (double)vb;\n                double timeToUniversity = Math.Sqrt(Math.Pow(busStops[i], 2) + Math.Pow(yu, 2)) \/ (double)vs;\n                double totalTime = timeToBusStop + timeToUniversity;\n\n                if (totalTime < minTime)\n                {\n                    minTime = totalTime;\n                    optimumBusStop = i + 1;\n                }\n            }\n\n            return optimumBusStop;\n        }\n    }\n}","Ruby":"def find_optimum_bus_stop(input)\n  # Parse the input\n  n, vb, vs = input[0].split(' ').map(&:to_i)\n  bus_stops = input[1].split(' ').map(&:to_i)\n  xu, yu = input[2].split(' ').map(&:to_i)\n\n  # Calculate the time it takes to reach each bus stop\n  times = []\n  bus_stops.each do |stop|\n    time = stop.to_f \/ vb + Math.sqrt((stop - xu) ** 2 + yu ** 2) \/ vs\n    times << time\n  end\n\n  # Find the index of the bus stop with the minimum time\n  min_time = times.min\n  min_index = times.index(min_time) + 1\n\n  # Return the index of the optimum bus stop\n  min_index.to_s\nend","delphi":"program OptimumBusStop;\\n\\nvar\\n  n, vb, vs, xu, yu, i, optStop: integer;\\n  stops: array of integer;\\n  minDistance, distance: real;\\n\\nbegin\\n  \/\/ Read input\\n  readln(n, vb, vs);\\n  SetLength(stops, n);\\n  for i := 0 to n-1 do\\n    read(stops[i]);\\n  readln(xu, yu);\\n\\n  \/\/ Find the optimum bus stop\\n  minDistance := 1000000;\\n  optStop := 0;\\n  for i := 1 to n-1 do\\n  begin\\n    distance := sqrt(sqr(stops[i]) + sqr(yu)) \/ vs + stops[i] \/ vb;\\n    if distance < minDistance then\\n    begin\\n      minDistance := distance;\\n      optStop := i;\\n    end;\\n  end;\\n\\n  \/\/ Output the answer\\n  writeln(optStop);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"math\\\"\\n\\t\\\"strings\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, vb, vs int\\n\\tfmt.Scanf(\\\"%d %d %d\\\", &n, &vb, &vs)\\n\\n\\tstops := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfmt.Scanf(\\\"%d\\\", &stops[i])\\n\\t}\\n\\n\\tvar xu, yu int\\n\\tfmt.Scanf(\\\"%d %d\\\", &xu, &yu)\\n\\n\\tminDistance := math.Inf(1)\\n\\toptimalStop := 0\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tdistanceToStop := float64(stops[i]) \/ float64(vb)\\n\\t\\tdistanceToUniversity := math.Sqrt(math.Pow(float64(xu-stops[i]), 2) + math.Pow(float64(yu), 2)) \/ float64(vs)\\n\\t\\tdistance := distanceToStop + distanceToUniversity\\n\\n\\t\\tif distance < minDistance {\\n\\t\\t\\tminDistance = distance\\n\\t\\t\\toptimalStop = i\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(optimalStop)\\n}","Javascript":"function findOptimumBusStop(input) {\n  const lines = input.split('\\\\n');\n  const [n, vb, vs] = lines[0].split(' ').map(Number);\n  const busStops = lines[1].split(' ').map(Number);\n  const [xu, yu] = lines[2].split(' ').map(Number);\n\n  let optimumStop = 1;\n  let minTime = Infinity;\n\n  for (let i = 1; i < n; i++) {\n    const distanceToStop = busStops[i];\n    const timeToStop = distanceToStop \/ vb;\n    const distanceToUniversity = Math.sqrt((xu - distanceToStop) ** 2 + yu ** 2);\n    const timeToUniversity = distanceToUniversity \/ vs;\n    const totalTime = timeToStop + timeToUniversity;\n\n    if (totalTime < minTime) {\n      minTime = totalTime;\n      optimumStop = i + 1;\n    }\n  }\n\n  return String(optimumStop);\n}\n\nconst input = '4 5 2\\\\n0 2 4 6\\\\n4 1\\\\n';\nconsole.log(findOptimumBusStop(input));","Kotlin":"import kotlin.math.abs\\n\\nfun main() {\\n    val input = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val n = input[0]\\n    val vb = input[1]\\n    val vs = input[2]\\n\\n    val stops = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val university = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val xu = university[0]\\n    val yu = university[1]\\n\\n    var minTime = Double.MAX_VALUE\\n    var bestStop = 0\\n\\n    for (i in 1 until n) {\\n        val stopX = stops[i]\\n        val timeToStop = stopX.toDouble() \/ vb\\n        val timeToUniversity = kotlin.math.sqrt((stopX - xu).toDouble().pow(2) + yu.toDouble().pow(2)) \/ vs\\n        val totalTime = timeToStop + timeToUniversity\\n\\n        if (totalTime < minTime) {\\n            minTime = totalTime\\n            bestStop = i + 1\\n        } else if (totalTime == minTime && abs(stopX - xu) < abs(stops[bestStop - 1] - xu)) {\\n            bestStop = i + 1\\n        }\\n    }\\n\\n    println(bestStop)\\n}","PHP":"<?php\\n\\n$input = explode(\\\"\\\\n\\\", file_get_contents(\\\"php:\/\/stdin\\\"));\\n\\n\/\/ Parse input\\n[$n, $vb, $vs] = explode(\\\" \\\", $input[0]);\\n$stops = array_map('intval', explode(\\\" \\\", $input[1]));\\n[$xu, $yu] = array_map('intval', explode(\\\" \\\", $input[2]));\\n\\n\/\/ Calculate time taken to reach each stop\\n$times = [];\\nfor ($i = 1; $i < $n; $i++) {\\n    $distance = $stops[$i];\\n    $time = $distance \/ $vb + sqrt(pow($xu - $distance, 2) + pow($yu, 2)) \/ $vs;\\n    $times[$i] = $time;\\n}\\n\\n\/\/ Find the index of the minimum time\\n$minTime = min($times);\\n$optimalStop = array_search($minTime, $times);\\n\\n\/\/ Output the answer\\necho $optimalStop;\\n?>","d":"import std.stdio;\\r\\nimport std.algorithm;\\r\\nimport std.array;\\r\\nimport std.conv;\\r\\n\\r\\nstruct BusStop\\r\\n{\\r\\n    int index;\\r\\n    int x;\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, vb, vs;\\r\\n    int xu, yu;\\r\\n    int[] stops;\\r\\n\\r\\n    \/\/ Read input\\r\\n    string[] input = readln().split;\\r\\n    n = to!int(input[0]);\\r\\n    vb = to!int(input[1]);\\r\\n    vs = to!int(input[2]);\\r\\n\\r\\n    stops = input[3].split.map!(to!int);\\r\\n\\r\\n    string[] university = readln().split;\\r\\n    xu = to!int(university[0]);\\r\\n    yu = to!int(university[1]);\\r\\n\\r\\n    \/\/ Calculate the time taken to reach each bus stop\\r\\n    double[] times;\\r\\n    foreach (i, stop; stops[1..$])\\r\\n    {\\r\\n        double distance = stop;\\r\\n        double timeOnBus = distance \/ vb;\\r\\n        double timeOnFoot = sqrt((xu - stop) * (xu - stop) + yu * yu) \/ vs;\\r\\n        times ~= timeOnBus + timeOnFoot;\\r\\n    }\\r\\n\\r\\n    \/\/ Find the index of the bus stop with the minimum time\\r\\n    int minIndex = times.minElementIndex;\\r\\n\\r\\n    \/\/ Output the answer\\r\\n    writeln(minIndex + 1);\\r\\n}","perl":"\nuse strict;\nuse warnings;\n\n# Read input\nmy $input = <>;\nchomp $input;\nmy ($n, $vb, $vs) = split ' ', $input;\n\n$input = <>;\nchomp $input;\nmy @stops = split ' ', $input;\n\n$input = <>;\nchomp $input;\nmy ($xu, $yu) = split ' ', $input;\n\n# Calculate the time taken to reach each stop\nmy @times;\nfor my $i (1..$n) {\n    my $distance = $stops[$i] \/ $vb;\n    my $time = sqrt($distance**2 + $yu**2) \/ $vs;\n    push @times, $time;\n}\n\n# Find the index of the minimum time\nmy $min_index = 1;\nmy $min_time = $times[0];\nfor my $i (1..$n-1) {\n    if ($times[$i] < $min_time) {\n        $min_index = $i + 1;\n        $min_time = $times[$i];\n    }\n}\n\n# Output the result\nprint $min_index;\n","Rust":"fn main() {\n    let input = std::fs::read_to_string(\"input.txt\").unwrap();\n    let lines: Vec<&str> = input.lines().collect();\n    \n    let params: Vec<i32> = lines[0].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let n = params[0];\n    let vb = params[1];\n    let vs = params[2];\n    \n    let stops: Vec<i32> = lines[1].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    \n    let university: Vec<i32> = lines[2].split_whitespace().map(|x| x.parse().unwrap()).collect();\n    let xu = university[0];\n    let yu = university[1];\n    \n    let mut min_time = std::f64::MAX;\n    let mut min_index = 0;\n    \n    for i in 1..n {\n        let distance_to_stop = stops[i];\n        let distance_to_university = ((xu - stops[i]) * (xu - stops[i]) + yu * yu) as f64;\n        let time = distance_to_stop as f64 \/ vb as f64 + distance_to_university.sqrt() \/ vs as f64;\n        \n        if time < min_time {\n            min_time = time;\n            min_index = i;\n        }\n    }\n    \n    println!(\"{}\", min_index);\n}"}
{"title":"C. Hexadecimal's Numbers","description":"One beautiful July morning a terrible thing happened in Mainframe: a mean virus Megabyte somehow got access to the memory of his not less mean sister Hexadecimal. He loaded there a huge amount of n different natural numbers from 1 to n to obtain total control over her energy.But his plan failed. The reason for this was very simple: Hexadecimal didn't perceive any information, apart from numbers written in binary format. This means that if a number in a decimal representation contained characters apart from 0 and 1, it was not stored in the memory. Now Megabyte wants to know, how many numbers were loaded successfully.","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"Input data contains the only number n (1\u2264n\u226410^9).\n","output_spec":"Output the only number \u2014 answer to the problem.\n","notes":"For n = 10 the answer includes numbers 1 and 10.\n","sample_inputs":["10\n"],"sample_outputs":["2"],"id":"9-C","difficulty":1200,"tags":["brute+force","implementation","math"],"src_uid":"64a842f9a41f85a83b7d65bfbe21b6cb","C++":"#include <iostream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    int count = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n        string binary = bitset<32>(i).to_string();\\n        if (binary.find('1') != string::npos && binary.find('0') != string::npos) {\\n            count++;\\n        }\\n    }\\n\\n    cout << count << endl;\\n\\n    return 0;\\n}","Java":"public class Main {\\n\\n    public static void main(String[] args) {\\n        int n = 10;\\n        int count = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            String binary = Integer.toBinaryString(i);\\n            if (!binary.contains(\\\"2\\\") && !binary.contains(\\\"3\\\") && !binary.contains(\\\"4\\\") && !binary.contains(\\\"5\\\") && !binary.contains(\\\"6\\\") && !binary.contains(\\\"7\\\") && !binary.contains(\\\"8\\\") && !binary.contains(\\\"9\\\")) {\\n                count++;\\n            }\\n        }\\n\\n        System.out.println(count);\\n    }\\n}","Python":"def count_successful_numbers(n):\\n    count = 0\\n    for i in range(1, n+1):\\n        binary = bin(i)[2:]\\n        if '2' not in binary and '3' not in binary and '4' not in binary and '5' not in binary and '6' not in binary and '7' not in binary and '8' not in binary and '9' not in binary:\\n            count += 1\\n    return str(count)\\n\\nn = int(input())\\nprint(count_successful_numbers(n))","C":"#include <stdio.h>\\n\\nint main() {\\n    int n;\\n    scanf(\\\"%d\\\", &n);\\n    int count = 0;\\n    for (int i = 1; i <= n; i++) {\\n        int num = i;\\n        int valid = 1;\\n        while (num > 0) {\\n            int digit = num % 10;\\n            if (digit != 0 && digit != 1) {\\n                valid = 0;\\n                break;\\n            }\\n            num \/= 10;\\n        }\\n        if (valid) {\\n            count++;\\n        }\\n    }\\n    printf(\\\"%d\\\", count);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int n = int.Parse(Console.ReadLine());\n        int count = 0;\n        \n        for (int i = 1; i <= n; i++)\n        {\n            string binary = Convert.ToString(i, 2);\n            \n            if (!binary.Contains(\"2\") && !binary.Contains(\"3\") && !binary.Contains(\"4\") && !binary.Contains(\"5\") && !binary.Contains(\"6\") && !binary.Contains(\"7\") && !binary.Contains(\"8\") && !binary.Contains(\"9\"))\n            {\n                count++;\n            }\n        }\n        \n        Console.WriteLine(count);\n    }\n}","Ruby":"def count_numbers(n)\\n  count = 0\\n  (1..n).each do |num|\\n    binary = num.to_s(2)\\n    count += 1 if binary !~ \/[^01]\/\\n  end\\n  count.to_s\\nend\\n\\nn = gets.chomp.to_i\\nputs count_numbers(n)","delphi":"program CountNumbers;\\n\\nvar\\n  n, count: Integer;\\n  i: Integer;\\n  numStr: String;\\n  valid: Boolean;\\n\\nbegin\\n  \/\/ Read input\\n  ReadLn(n);\\n\\n  \/\/ Initialize count\\n  count := 0;\\n\\n  \/\/ Loop through numbers from 1 to n\\n  for i := 1 to n do\\n  begin\\n    \/\/ Convert number to string\\n    numStr := IntToStr(i);\\n\\n    \/\/ Check if number contains only 0s and 1s\\n    valid := True;\\n    for j := 1 to Length(numStr) do\\n    begin\\n      if (numStr[j] <> '0') and (numStr[j] <> '1') then\\n      begin\\n        valid := False;\\n        Break;\\n      end;\\n    end;\\n\\n    \/\/ Increment count if number is valid\\n    if valid then\\n      Inc(count);\\n  end;\\n\\n  \/\/ Output the count\\n  WriteLn(count);\\nend.","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n int\\n\\tfmt.Scan(&n)\\n\\n\\tcount := 0\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tbinary := strconv.FormatInt(int64(i), 2)\\n\\t\\tvalid := true\\n\\n\\t\\tfor _, digit := range binary {\\n\\t\\t\\tif digit != '0' && digit != '1' {\\n\\t\\t\\t\\tvalid = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif valid {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\tfmt.Println(count)\\n}","Javascript":"function countSuccessfulNumbers(n) {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let binary = i.toString(2);\n    if (!binary.includes('2') && !binary.includes('3') && !binary.includes('4') && !binary.includes('5') && !binary.includes('6') && !binary.includes('7') && !binary.includes('8') && !binary.includes('9')) {\n      count++;\n    }\n  }\n  return count.toString();\n}\n\nconsole.log(countSuccessfulNumbers(10));","Kotlin":"fun main() {\n    val n = readLine()!!.toInt()\n    var count = 0\n    \n    for (i in 1..n) {\n        val binary = Integer.toBinaryString(i)\n        if (!binary.contains('2') && !binary.contains('3') && !binary.contains('4') && !binary.contains('5') && !binary.contains('6') && !binary.contains('7') && !binary.contains('8') && !binary.contains('9')) {\n            count++\n        }\n    }\n    \n    println(count)\n}","PHP":"<?php\\n\\nfunction countLoadedNumbers($n) {\\n    $count = 0;\\n    for ($i = 1; $i <= $n; $i++) {\\n        $binary = decbin($i);\\n        if (!preg_match('\/[^01]\/', $binary)) {\\n            $count++;\\n        }\\n    }\\n    return $count;\\n}\\n\\n$input = 10;\\n$output = countLoadedNumbers($input);\\necho $output;\\n?>","d":"import std.stdio;\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n;\\r\\n    readf(\\\"%d\\\", &n);\\r\\n\\r\\n    int count = 0;\\r\\n\\r\\n    for (int i = 1; i <= n; i++)\\r\\n    {\\r\\n        bool isValid = true;\\r\\n        int num = i;\\r\\n\\r\\n        while (num > 0)\\r\\n        {\\r\\n            int digit = num % 10;\\r\\n\\r\\n            if (digit != 0 && digit != 1)\\r\\n            {\\r\\n                isValid = false;\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            num \/= 10;\\r\\n        }\\r\\n\\r\\n        if (isValid)\\r\\n        {\\r\\n            count++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    writeln(count);\\r\\n}","perl":"\n# Read the input number\nmy $n = <STDIN>;\nchomp $n;\n\n# Initialize a counter for successful numbers\nmy $count = 0;\n\n# Iterate from 1 to n\nfor (my $i = 1; $i <= $n; $i++) {\n    # Convert the number to binary representation\n    my $binary = sprintf(\"%b\", $i);\n    \n    # Check if the binary representation contains only 0s and 1s\n    if ($binary !~ \/[^01]\/) {\n        $count++;\n    }\n}\n\n# Print the result\nprint $count;\n","Rust":"fn main() {\n    let mut input = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n    let n: u32 = input.trim().parse().unwrap();\n    \n    let mut count = 0;\n    for i in 1..=n {\n        let binary = format!(\"{:b}\", i);\n        if !binary.contains('2') && !binary.contains('3') && !binary.contains('4') && !binary.contains('5') && !binary.contains('6') && !binary.contains('7') && !binary.contains('8') && !binary.contains('9') {\n            count += 1;\n        }\n    }\n    \n    println!(\"{}\", count);\n}"}
{"title":"D. How many trees?","description":"In one very old text file there was written Great Wisdom. This Wisdom was so Great that nobody could decipher it, even Phong \u2014 the oldest among the inhabitants of Mainframe. But still he managed to get some information from there. For example, he managed to learn that User launches games for pleasure \u2014 and then terrible Game Cubes fall down on the city, bringing death to those modules, who cannot win the game...For sure, as guard Bob appeared in Mainframe many modules stopped fearing Game Cubes. Because Bob (as he is alive yet) has never been defeated by User, and he always meddles with Game Cubes, because he is programmed to this.However, unpleasant situations can happen, when a Game Cube falls down on Lost Angles. Because there lives a nasty virus \u2014 Hexadecimal, who is... mmm... very strange. And she likes to play very much. So, willy-nilly, Bob has to play with her first, and then with User.This time Hexadecimal invented the following entertainment: Bob has to leap over binary search trees with n nodes. We should remind you that a binary search tree is a binary tree, each node has a distinct key, for each node the following is true: the left sub-tree of a node contains only nodes with keys less than the node's key, the right sub-tree of a node contains only nodes with keys greater than the node's key. All the keys are different positive integer numbers from 1 to n. Each node of such a tree can have up to two children, or have no children at all (in the case when a node is a leaf).In Hexadecimal's game all the trees are different, but the height of each is not lower than h. In this problem \u00abheight\u00bb stands for the maximum amount of nodes on the way from the root to the remotest leaf, the root node and the leaf itself included. When Bob leaps over a tree, it disappears. Bob gets the access to a Cube, when there are no trees left. He knows how many trees he will have to leap over in the worst case. And you?","input_from":"standard input","output_to":"standard output","time_limit":"1 second","memory_limit":"64 megabytes","input_spec":"The input data contains two space-separated positive integer numbers n and h (n\u226435, h\u2264n).\n","output_spec":"Output one number \u2014 the answer to the problem. It is guaranteed that it does not exceed 9\u00b710^18.\n","notes":null,"sample_inputs":["3 2\n","3 3\n"],"sample_outputs":["5","4"],"id":"9-D","difficulty":1900,"tags":["combinatorics","divide+and+conquer","dp"],"src_uid":"faf12a603d0c27f8be6bf6b02531a931","C++":"#include <iostream>\\n#include <vector>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nlong long int calculateTrees(int n, int h) {\\n    if (h == 1) {\\n        return pow(2, n) - 1;\\n    }\\n    else {\\n        long long int leftSubtrees = calculateTrees(n-1, h-1);\\n        long long int rightSubtrees = calculateTrees(n-1, h-1);\\n        return 1 + leftSubtrees + rightSubtrees;\\n    }\\n}\\n\\nint main() {\\n    int n, h;\\n    cin >> n >> h;\\n    long long int answer = calculateTrees(n, h);\\n    cout << answer << endl;\\n    return 0;\\n}","Java":"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int h = scanner.nextInt();\\n\\n        long result = calculateNumberOfLeaps(n, h);\\n\\n        System.out.println(result);\\n    }\\n\\n    private static long calculateNumberOfLeaps(int n, int h) {\\n        if (h == 1) {\\n            return (long) Math.pow(2, n) - 1;\\n        }\\n\\n        long[][] dp = new long[n + 1][h + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][1] = 1;\\n        }\\n\\n        for (int i = 2; i <= h; i++) {\\n            dp[0][i] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    dp[j][i] += dp[k][i - 1] * dp[j - k - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        long result = 0;\\n        for (int i = 1; i <= h; i++) {\\n            result += dp[n][i];\\n        }\\n\\n        return result;\\n    }\\n}\"}, {\"version\": \"Java 7\", \"source code\": \"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int h = scanner.nextInt();\\n\\n        long result = calculateNumberOfLeaps(n, h);\\n\\n        System.out.println(result);\\n    }\\n\\n    private static long calculateNumberOfLeaps(int n, int h) {\\n        if (h == 1) {\\n            return (long) Math.pow(2, n) - 1;\\n        }\\n\\n        long[][] dp = new long[n + 1][h + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][1] = 1;\\n        }\\n\\n        for (int i = 2; i <= h; i++) {\\n            dp[0][i] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    dp[j][i] += dp[k][i - 1] * dp[j - k - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        long result = 0;\\n        for (int i = 1; i <= h; i++) {\\n            result += dp[n][i];\\n        }\\n\\n        return result;\\n    }\\n}\"}, {\"version\": \"Java 6\", \"source code\": \"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int h = scanner.nextInt();\\n\\n        long result = calculateNumberOfLeaps(n, h);\\n\\n        System.out.println(result);\\n    }\\n\\n    private static long calculateNumberOfLeaps(int n, int h) {\\n        if (h == 1) {\\n            return (long) Math.pow(2, n) - 1;\\n        }\\n\\n        long[][] dp = new long[n + 1][h + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][1] = 1;\\n        }\\n\\n        for (int i = 2; i <= h; i++) {\\n            dp[0][i] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    dp[j][i] += dp[k][i - 1] * dp[j - k - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        long result = 0;\\n        for (int i = 1; i <= h; i++) {\\n            result += dp[n][i];\\n        }\\n\\n        return result;\\n    }\\n}\"}, {\"version\": \"Java 8\", \"source code\": \"import java.util.Scanner;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        int h = scanner.nextInt();\\n\\n        long result = calculateNumberOfLeaps(n, h);\\n\\n        System.out.println(result);\\n    }\\n\\n    private static long calculateNumberOfLeaps(int n, int h) {\\n        if (h == 1) {\\n            return (long) Math.pow(2, n) - 1;\\n        }\\n\\n        long[][] dp = new long[n + 1][h + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][1] = 1;\\n        }\\n\\n        for (int i = 2; i <= h; i++) {\\n            dp[0][i] = 1;\\n            for (int j = 1; j <= n; j++) {\\n                for (int k = 0; k < j; k++) {\\n                    dp[j][i] += dp[k][i - 1] * dp[j - k - 1][i - 1];\\n                }\\n            }\\n        }\\n\\n        long result = 0;\\n        for (int i = 1; i <= h; i++) {\\n            result += dp[n][i];\\n        }\\n\\n        return result;\\n    }\\n}","Python":"def calculate_leaps(n, h):\n    if h == 1:\n        return 2 ** n - 1\n    elif h == n:\n        return n\n    else:\n        return 2 * calculate_leaps(n-1, h-1) + 1\n\nn, h = map(int, input().split())\nresult = calculate_leaps(n, h)\nprint(result)","C":"#include <stdio.h>\\n#include <math.h>\\n\\nlong long int calculateTrees(int n, int h) {\\n    if (h == 1) {\\n        return pow(2, n) - 1;\\n    }\\n    else {\\n        long long int leftSubtree = calculateTrees(n-1, h-1);\\n        long long int rightSubtree = calculateTrees(n-1, h-1);\\n        return 1 + leftSubtree + rightSubtree;\\n    }\\n}\\n\\nint main() {\\n    int n, h;\\n    scanf(\\\"%d %d\\\", &n, &h);\\n    long long int result = calculateTrees(n, h);\\n    printf(\\\"%lld\\\", result);\\n    return 0;\\n}","C#":"using System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string[] inputs = { \\\"3 2\\\", \\\"3 3\\\" };\n        foreach (string input in inputs)\n        {\n            string[] values = input.Split(' ');\n            int n = int.Parse(values[0]);\n            int h = int.Parse(values[1]);\n            \n            long result = CalculateLeaps(n, h);\n            Console.WriteLine(result);\n        }\n    }\n    \n    public static long CalculateLeaps(int n, int h)\n    {\n        if (h == 1)\n        {\n            return (long)Math.Pow(2, n) - 1;\n        }\n        else\n        {\n            long leftSubtreeLeaps = CalculateLeaps(n - 1, h - 1);\n            long rightSubtreeLeaps = CalculateLeaps(n - 1, h - 1);\n            long rootLeaps = CalculateLeaps(n - 1, h - 2);\n            \n            return leftSubtreeLeaps + rightSubtreeLeaps + rootLeaps + 1;\n        }\n    }\n}","Ruby":"def leap_over_trees(n, h)\n  if h == 1\n    return 2**n - 1\n  else\n    return 2**(n-1) + leap_over_trees(n-1, h-1)\n  end\nend\n\ninput = gets.chomp.split(' ')\nn = input[0].to_i\nh = input[1].to_i\n\noutput = leap_over_trees(n, h)\nputs output","delphi":"Here is the Delphi code to solve the problem:\n\nprogram LeapOverTrees;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils;\n\nfunction LeapOverTrees(n, h: Integer): Int64;\nvar\n  i: Integer;\n  result: Int64;\nbegin\n  result := 0;\n  \n  \/\/ Calculate the number of trees Bob needs to leap over\n  for i := h to n do\n  begin\n    result := result + Power(2, i - 1);\n  end;\n  \n  LeapOverTrees := result;\nend;\n\nvar\n  n, h: Integer;\nbegin\n  \/\/ Read input values\n  ReadLn(n, h);\n  \n  \/\/ Calculate the answer\n  WriteLn(LeapOverTrees(n, h));\nend.\n","Go":"package main\\n\\nimport (\\n\\t\\\"fmt\\\"\\n\\t\\\"strconv\\\"\\n)\\n\\nfunc main() {\\n\\tvar n, h int\\n\\tfmt.Scanf(\\\"%d %d\\\", &n, &h)\\n\\n\\tres := leapOverTrees(n, h)\\n\\tfmt.Println(res)\\n}\\n\\nfunc leapOverTrees(n, h int) int64 {\\n\\tif h == 1 {\\n\\t\\treturn int64(n)\\n\\t}\\n\\n\\tif n == h {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tleft := n - h\\n\\tright := n - 1\\n\\n\\tres := int64(1)\\n\\n\\tfor i := 0; i < h-1; i++ {\\n\\t\\tres *= int64(left)\\n\\t\\tleft--\\n\\t}\\n\\n\\tfor i := 0; i < h-1; i++ {\\n\\t\\tres *= int64(right)\\n\\t\\tright--\\n\\t}\\n\\n\\treturn res\\n}","Javascript":"function calculateNumberOfLeaps(input) {\n  const [n, h] = input.split(' ').map(Number);\n  \n  \/\/ Calculate the number of trees with height h or greater\n  let numTrees = 0;\n  for (let i = h; i <= n; i++) {\n    numTrees += countTrees(i);\n  }\n  \n  \/\/ Calculate the number of leaps required\n  let numLeaps = 0;\n  for (let i = h; i <= n; i++) {\n    numLeaps += countLeaps(i);\n  }\n  \n  return String(numLeaps);\n}\n\nfunction countTrees(height) {\n  if (height === 0) {\n    return 1;\n  }\n  \n  let count = 0;\n  for (let i = 0; i < height; i++) {\n    count += countTrees(i) * countTrees(height - i - 1);\n  }\n  \n  return count;\n}\n\nfunction countLeaps(height) {\n  if (height === 0) {\n    return 0;\n  }\n  \n  let count = 0;\n  for (let i = 0; i < height; i++) {\n    count += countLeaps(i) * countLeaps(height - i - 1);\n  }\n  \n  return count + 1;\n}\n\nconst inputs = ['3 2\\n', '3 3\\n'];\nconst outputs = inputs.map(calculateNumberOfLeaps);\n\nJSON.stringify(outputs);","Kotlin":"fun main() {\\n    val (n, h) = readLine()!!.split(\\\" \\\").map { it.toInt() }\\n    val result = calculateNumberOfLeaps(n, h)\\n    println(result)\\n}\\n\\nfun calculateNumberOfLeaps(n: Int, h: Int): Long {\\n    if (h == 1) {\\n        return n.toLong()\\n    }\\n    val dp = Array(n + 1) { LongArray(h + 1) }\\n    for (i in 1..n) {\\n        dp[i][1] = 1\\n    }\\n    for (i in 2..h) {\\n        dp[1][i] = 1\\n    }\\n    for (i in 2..n) {\\n        for (j in 2..h) {\\n            for (k in 1 until i) {\\n                dp[i][j] += dp[k][j - 1]\\n            }\\n        }\\n    }\\n    var result = 0L\\n    for (i in 1..n) {\\n        result += dp[i][h]\\n    }\\n    return result\\n}","PHP":"<?php\\n\\nfunction calculateLeaps($n, $h) {\\n    if ($h == 1) {\\n        return $n;\\n    }\\n\\n    $leaps = 1;\\n    $height = $h;\\n\\n    while ($height > 1) {\\n        $leaps *= 2;\\n        $height--;\\n    }\\n\\n    return $leaps + $n - $h;\\n}\\n\\n$input = explode(' ', trim(fgets(STDIN)));\\n$n = intval($input[0]);\\n$h = intval($input[1]);\\n\\n$result = calculateLeaps($n, $h);\\necho $result;\\n?>","d":"import std.stdio;\\r\\n\\r\\nulong calculateNumberOfLeaps(int n, int h)\\r\\n{\\r\\n    if (h == 1)\\r\\n    {\\r\\n        return n;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        ulong result = 1;\\r\\n        for (int i = 0; i < h - 1; i++)\\r\\n        {\\r\\n            result = result * (result + 1);\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    int n, h;\\r\\n    readf(\\\"%d %d\\\", &n, &h);\\r\\n    ulong answer = calculateNumberOfLeaps(n, h);\\r\\n    writeln(answer);\\r\\n}","perl":"\n# Function to calculate the number of trees Bob needs to leap over\nsub calculate_trees {\n    my ($n, $h) = @_;\n\n    # Base case: if height is 0, return 1\n    return 1 if $h == 0;\n\n    # Initialize the total number of trees to 1\n    my $total_trees = 1;\n\n    # Recursively calculate the number of trees for each possible left and right subtree\n    for my $i (1..$n) {\n        for my $left_height (0..$h-1) {\n            my $right_height = $h - 1 - $left_height;\n            $total_trees += calculate_trees($i-1, $left_height) * calculate_trees($n-$i, $right_height);\n        }\n    }\n\n    return $total_trees;\n}\n\n# Read input from STDIN\nmy $input = <STDIN>;\nchomp $input;\n\n# Split the input into n and h\nmy ($n, $h) = split ' ', $input;\n\n# Calculate the number of trees Bob needs to leap over\nmy $result = calculate_trees($n, $h);\n\n# Print the result\nprint $result;\n","Rust":"fn main() {\\n    let input = \\\"3 2\\\";\\n    let mut input = input.split_whitespace();\\n    let n: u64 = input.next().unwrap().parse().unwrap();\\n    let h: u64 = input.next().unwrap().parse().unwrap();\\n\\n    let mut result: u64 = 0;\\n\\n    for i in h..=n {\\n        result += count_trees(i, n);\\n    }\\n\\n    println!(\\\"{}\\\", result);\\n}\\n\\nfn count_trees(height: u64, n: u64) -> u64 {\\n    if height == 0 {\\n        return 1;\\n    }\\n\\n    let mut result: u64 = 0;\\n\\n    for i in 0..=n {\\n        let left_count = count_trees(height - 1, i);\\n        let right_count = count_trees(height - 1, n - i);\\n        result += left_count * right_count;\\n    }\\n\\n    result\\n}"}
