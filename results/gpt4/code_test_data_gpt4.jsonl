{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"6 3\\n1 1 1 0 1 0\", \"5 2\\n0 0 0 1 0\"]","prob_desc_input_spec":"The first line of the input contains two integers n and a (1\u2009\u2264\u2009a\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of cities and the index of city where Limak lives. The second line contains n integers t1,\u2009t2,\u2009...,\u2009tn (0\u2009\u2264\u2009ti\u2009\u2264\u20091). There are ti criminals in the i-th city.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\nint n,i,j,pos,counter;\nint criminals[100];\ncounter=0;\nscanf(\"%d%d\",&n,&pos);\nfor(i=0;i<n;i++)\nscanf(\"%d\",&criminals[i]);\nif(criminals[pos-1]==1)\ncounter+=1;\nfor(j=1;j<=i;j++)\n{\nif((pos-1-j>=0)&&(pos-1+j<n)&&((criminals[pos-1-j]&criminals[pos-1+j])==1))\ncounter+=2;\nelse if((pos-1-j>=0)&&(pos-1+j>=n)&&(criminals[pos-1-j]==1))\ncounter+=1;\nelse if((pos-1-j<0)&&(pos-1+j<n)&&(criminals[pos-1+j]==1))\ncounter+=1;}\nprintf(\"%d\",counter);\nreturn 0;}","prob_desc_sample_outputs":"[\"3\", \"1\"]","lang_cluster":"C","code_uid":"0f7d73539239e586bb5c45a78404c2aa","prob_desc_notes":"NoteIn the first sample, there are six cities and Limak lives in the third one (blue arrow below). Criminals are in cities marked red.  Using the BCD gives Limak the following information:  There is one criminal at distance 0 from the third city\u00a0\u2014 Limak is sure that this criminal is exactly in the third city.  There is one criminal at distance 1 from the third city\u00a0\u2014 Limak doesn't know if a criminal is in the second or fourth city.  There are two criminals at distance 2 from the third city\u00a0\u2014 Limak is sure that there is one criminal in the first city and one in the fifth city.  There are zero criminals for every greater distance. So, Limak will catch criminals in cities 1, 3 and 5, that is 3 criminals in total.In the second sample (drawing below), the BCD gives Limak the information that there is one criminal at distance 2 from Limak's city. There is only one city at distance 2 so Limak is sure where a criminal is.  ","prob_desc_output_spec":"Print the number of criminals Limak will catch.","prob_desc_output_to":"standard output","prob_desc_description":"There are n cities in Bearland, numbered 1 through n. Cities are arranged in one long row. The distance between cities i and j is equal to |i\u2009-\u2009j|.Limak is a police officer. He lives in a city a. His job is to catch criminals. It's hard because he doesn't know in which cities criminals are. Though, he knows that there is at most one criminal in each city.Limak is going to use a BCD (Bear Criminal Detector). The BCD will tell Limak how many criminals there are for every distance from a city a. After that, Limak can catch a criminal in each city for which he is sure that there must be a criminal.You know in which cities criminals are. Count the number of criminals Limak will catch, after he uses the BCD.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5\\n1 0 1 0 1 0 1 0 1 0', 'output': ['5']}, {'input': '7 4\\n0 1 0 1 0 1 0', 'output': ['3']}, {'input': '8 1\\n1 0 0 0 0 0 0 0', 'output': ['1']}, {'input': '9 9\\n0 0 0 0 0 0 0 0 1', 'output': ['1']}, {'input': '5 3\\n1 1 1 1 1', 'output': ['3']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"9 7 3 8\", \"2 7 3 7\", \"30 6 17 19\"]","prob_desc_input_spec":"The only line contains four integer numbers $$$n$$$, $$$m$$$, $$$a$$$ and $$$b$$$ ($$$1 \\le n, m \\le 10^{12}$$$, $$$1 \\le a, b \\le 100$$$), where $$$n$$$ is the initial number of the commentary boxes, $$$m$$$ is the number of delegations to come, $$$a$$$ is the fee to build a box and $$$b$$$ is the fee to demolish a box.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    long long int c,a,n,m,b,d,e,f;\n    scanf(\"%lld%lld%lld%lld\",&n,&m,&a,&b);\n    c=n%m;\n    d=m-n%m;\n    b=b*c;\n    a=a*d;\n    if(a>b)\n        printf(\"%lld\\n\",b);\n    else\n        printf(\"%lld\\n\",a);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"15\", \"14\", \"0\"]","lang_cluster":"C","code_uid":"bc06756d882b013565e396654fa6aaa9","prob_desc_notes":"NoteIn the first example organizers can build $$$5$$$ boxes to make the total of $$$14$$$ paying $$$3$$$ burles for the each of them.In the second example organizers can demolish $$$2$$$ boxes to make the total of $$$0$$$ paying $$$7$$$ burles for the each of them.In the third example organizers are already able to distribute all the boxes equally among the delegations, each one get $$$5$$$ boxes.","prob_desc_output_spec":"Output the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$). It is allowed that the final number of the boxes is equal to $$$0$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Berland Football Cup starts really soon! Commentators from all over the world come to the event.Organizers have already built $$$n$$$ commentary boxes. $$$m$$$ regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.If $$$n$$$ is not divisible by $$$m$$$, it is impossible to distribute the boxes to the delegations at the moment.Organizers can build a new commentary box paying $$$a$$$ burles and demolish a commentary box paying $$$b$$$ burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.What is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by $$$m$$$)?","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5 2 3', 'output': ['0\\n']}, {'input': '15 4 5 6', 'output': ['5\\n']}, {'input': '20 7 8 9', 'output': ['8\\n']}, {'input': '25 6 10 11', 'output': ['10\\n']}, {'input': '30 8 12 13', 'output': ['12\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1100.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"3000\"]","prob_desc_input_spec":"The only line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the prediction on the number of people who will buy the game.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n\tlong long int i,j,n,l,a,k;\n\tscanf(\"%lld\",&n);\n\tk=2520;\n\ta=n\/k;\n\tprintf(\"%lld\\n\",a);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"1\"]","lang_cluster":"C","code_uid":"57ea84cc35e8283d0afea7bee5d3b93f","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer showing how many numbers from 1 to n are divisible by all numbers from 2 to 10.","prob_desc_output_to":"standard output","prob_desc_description":"IT City company developing computer games invented a new way to reward its employees. After a new game release users start buying it actively, and the company tracks the number of sales with precision to each transaction. Every time when the next number of sales is divisible by all numbers from 2 to 10 every developer of this game gets a small bonus.A game designer Petya knows that the company is just about to release a new game that was partly developed by him. On the basis of his experience he predicts that n people will buy the game during the first month. Now Petya wants to determine how many times he will get the bonus. Help him to know it.","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2520', 'output': ['1\\n']}, {'input': '5040', 'output': ['2\\n']}, {'input': '10000', 'output': ['3\\n']}, {'input': '25200', 'output': ['10\\n']}, {'input': '1018', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 6 2 2\", \"1 9 1 2\"]","prob_desc_input_spec":"The first line of the input contains four integers d, L, v1, v2 (1\u2009\u2264\u2009d,\u2009L,\u2009v1,\u2009v2\u2009\u2264\u200910\u2009000,\u2009d\u2009&lt;\u2009L)\u00a0\u2014 Luke's width, the initial position of the second press and the speed of the first and second presses, respectively.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n\nmain(){\n    double d,l,v1,v2;\n    scanf(\"%lf %lf %lf %lf\",&d,&l,&v1,&v2);\n    printf(\"%0.10lf\",(l-d)\/(v1+v2));\n}\n","prob_desc_sample_outputs":"[\"1.00000000000000000000\", \"2.66666666666666650000\"]","lang_cluster":"C","code_uid":"6c7724a49b94ab93476ffe64e7a913be","prob_desc_notes":"NoteIn the first sample Luke should stay exactly in the middle of the segment, that is at coordinates [2;4], as the presses move with the same speed.In the second sample he needs to occupy the position . In this case both presses move to his edges at the same time.","prob_desc_output_spec":"Print a single real value\u00a0\u2014 the maximum period of time Luke can stay alive for. Your answer will be considered correct if its absolute or relative error does not exceed 10\u2009-\u20096.  Namely: let's assume that your answer is a, and the answer of the jury is b. The checker program will consider your answer correct, if .","prob_desc_output_to":"standard output","prob_desc_description":"Luke Skywalker got locked up in a rubbish shredder between two presses. R2D2 is already working on his rescue, but Luke needs to stay alive as long as possible. For simplicity we will assume that everything happens on a straight line, the presses are initially at coordinates 0 and L, and they move towards each other with speed v1 and v2, respectively. Luke has width d and is able to choose any position between the presses. Luke dies as soon as the distance between the presses is less than his width. Your task is to determine for how long Luke can stay alive.","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 10 2 2', 'output': ['1.75000000000000000000']}, {'input': '4 12 3 3', 'output': ['1.33333333333333330000']}, {'input': '5 15 4 4', 'output': ['1.25000000000000000000']}, {'input': '6 18 5 5', 'output': ['1.20000000000000000000']}, {'input': '7 21 6 6', 'output': ['1.16666666666666670000']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":800.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"2\"]","prob_desc_input_spec":"The only line of the input contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u20092\u00b71018) \u2014 the power in which you need to raise number 5.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <math.h>\nint main(){\n\t\tint i;\n\t\tscanf(\"%d\",&i);\n\t\tprintf(\"25\");\n\t\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"25\"]","lang_cluster":"C","code_uid":"ae3d1f11850895d2d6f7cd2ec2cd8273","prob_desc_notes":null,"prob_desc_output_spec":"Output the last two digits of 5n without spaces between them.","prob_desc_output_to":"standard output","prob_desc_description":"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. \"Do I give such a hard task?\" \u2014 the HR manager thought. \"Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.\"Could you pass the interview in the machine vision company in IT City?","length":8,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2', 'output': ['25']}, {'input': '100', 'output': ['25']}, {'input': '1000', 'output': ['25']}, {'input': '10000', 'output': ['25']}, {'input': '100000', 'output': ['25']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\\n()))()\", \"3\\n(()\", \"2\\n(((\"]","prob_desc_input_spec":"The first line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 100$$$) \u2014 the half-length of the resulting regular bracket sequences (the resulting sequences must have length equal to $$$2n$$$). The second line of the input contains one string $$$s$$$ ($$$1 \\le |s| \\le 200$$$) \u2014 the string $$$s$$$ that should be a substring in each of the resulting regular bracket sequences ($$$|s|$$$ is the length of $$$s$$$).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <string.h>\nenum { BIG = 1000000007 };\n\nint n;\nchar s[240];\nint slen;\nint dp[201][101];\nint next[201][2];\nint fail[201];\n\nvoid nextstep(int eo) {\n    int i, j;\n    for (i = 0; i <= slen; i++) {\n        int lp = next[i][0];\n        int rp = next[i][1];\n        for (j = eo; j <= n; j+=2) {\n            int now = dp[i][j];\n            if (j < n) {\n                int add = dp[lp][j+1] + now;\n                dp[lp][j+1] = add < BIG ? add : add - BIG;\n            }\n            if (j > 0) {\n                int add = dp[rp][j-1] + now;\n                dp[rp][j-1] = add < BIG ? add : add - BIG;\n            }\n        }\n    }\n    for (i = 0; i <= slen; i++) {\n        for (j = eo; j <= n; j+=2) {\n            dp[i][j] = 0;\n        }\n    }\n    \/*for (i=0;i<=slen;i++){\n        for (j=0;j<=n;j++){\n            printf(\"%3d,\",dp[i][j]);\n        }\n        puts(\"\");\n    }\n    puts(\"\");*\/\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    scanf(\" %202s\", s);\n    slen = strlen(s);\n    int i;\n    \/\/ build state machine\n    fail[0] = fail[1] = 0;\n    if (s[0] == '(') {\n        next[0][0] = 1;\n        next[0][1] = 0;\n    }\n    else {\n        next[0][0] = 0;\n        next[0][1] = 1;\n    }\n    for (i = 1; i < slen; i++) {\n        int r = s[i] == ')';\n        int f = fail[i];\n        next[i][r] = i+1;\n        next[i][1-r] = next[f][1-r];\n        fail[i+1] = next[f][r];\n    }\n    next[slen][0] = next[slen][1] = slen;\n    dp[0][0] = 1;\n    for (i = 0; i < n; i++) {\n        nextstep(0);\n        nextstep(1);\n    }\n    printf(\"%d\\n\", dp[slen][0]);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"5\", \"4\", \"0\"]","lang_cluster":"C","code_uid":"ef40b724e511308ccea6397eaf03087d","prob_desc_notes":"NoteAll regular bracket sequences satisfying the conditions above for the first example:   \"(((()))())\";  \"((()()))()\";  \"((()))()()\";  \"(()(()))()\";  \"()((()))()\". All regular bracket sequences satisfying the conditions above for the second example:   \"((()))\";  \"(()())\";  \"(())()\";  \"()(())\". And there is no regular bracket sequences of length $$$4$$$ containing \"(((\" as a substring in the third example.","prob_desc_output_spec":"Print only one integer \u2014 the number of regular bracket sequences containing the given bracket sequence $$$s$$$ as a substring. Since this number can be huge, print it modulo $$$10^9+7$$$ ($$$1000000007$$$).","prob_desc_output_to":"standard output","prob_desc_description":"You are given a bracket sequence $$$s$$$ (not necessarily a regular one). A bracket sequence is a string containing only characters '(' and ')'.A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.Your problem is to calculate the number of regular bracket sequences of length $$$2n$$$ containing the given bracket sequence $$$s$$$ as a substring (consecutive sequence of characters) modulo $$$10^9+7$$$ ($$$1000000007$$$).","length":73,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n(()))\\n', 'output': ['5\\n']}, {'input': '3\\n(()\\n', 'output': ['4\\n']}, {'input': '2\\n(((\\n', 'output': ['0\\n']}, {'input': '4\\n()()\\n', 'output': ['14\\n']}, {'input': '1\\n(\\n', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"8 1 1\", \"8 1 10\"]","prob_desc_input_spec":"The only line contains three integers n, x and y (1\u2009\u2264\u2009n\u2009\u2264\u2009107, 1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009109) \u2014 the number of letters 'a' in the input file and the parameters from the problem statement.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\n    unsigned long long n, x, y;\n    unsigned long nl, xl, yl;\n\n    fscanf(stdin, \"%ld %ld %ld\", &nl, &xl, &yl);\n\n    n = (unsigned long long)nl;\n    x = (unsigned long long)xl;\n    y = (unsigned long long)yl;\n\n    unsigned long long* f = malloc(10000001*sizeof(unsigned long long));\n\n    f[1] = x;\n    f[2] = x < y? x + f[1] : y + f[1];\n\n    unsigned long long k;\n\n    for (unsigned long long m = 3; m < n+1; m++)\n    {\n        k = (m+1)\/2;\n        if (m % 2 == 1)\n            f[2*k-1] = f[k]+y+x < f[2*k-2]+x ? f[k]+y+x : f[2*k-2]+x;\n        else\n            f[2*k] = f[k]+y < f[2*k-2]+2*x ? f[k]+y : f[2*k-2]+2*x;\n    }\n    unsigned long pref = f[n] \/ 1000000000Lu;\n    unsigned long rest = f[n] % 1000000000Lu;\n    int digs = 9;\n    int pow10 = 100000000Lu;\n    while (digs > 1)\n    {\n        if (rest >= pow10)\n            break;\n        pow10 \/= 10;\n        digs = digs-1;\n    }\n    if (pref > 0)\n    {\n        if (9-digs == 0)\n            printf(\"%lu%lu\\n\", pref, rest);\n        else\n        {\n            char* zeros = malloc((9-digs+1)*sizeof(char));\n            for (int i = 0; i < 9-digs; i++) zeros[i] = '0';\n            zeros[9-digs] = 0;\n            printf(\"%lu%s%lu\\n\", pref, zeros, rest);\n        }\n    }\n    else\n        printf(\"%lu\\n\", rest);\n}\n","prob_desc_sample_outputs":"[\"4\", \"8\"]","lang_cluster":"C","code_uid":"71b8c989051c5d4dfb393b5f422038eb","prob_desc_notes":null,"prob_desc_output_spec":"Print the only integer t \u2014 the minimum amount of time needed to generate the input file.","prob_desc_output_to":"standard output","prob_desc_description":"zscoder wants to generate an input file for some programming competition problem.His input is a string consisting of n letters 'a'. He is too lazy to write a generator so he will manually generate the input in a text editor.Initially, the text editor is empty. It takes him x seconds to insert or delete a letter 'a' from the text file and y seconds to copy the contents of the entire text file, and duplicate it.zscoder wants to find the minimum amount of time needed for him to create the input file of exactly n letters 'a'. Help him to determine the amount of time needed to generate the input.","length":55,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['1\\n']}, {'input': '2 1 1', 'output': ['2\\n']}, {'input': '3 2 1', 'output': ['4\\n']}, {'input': '4 2 2', 'output': ['6\\n']}, {'input': '5 3 2', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"047\", \"16\", \"472747\"]","prob_desc_input_spec":"The single line contains a non-empty string s whose length can range from 1 to 50, inclusive. The string only contains digits. The string can contain leading zeroes.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n# include <string.h>\nint main()\n{\n    char ch[100];\n    scanf(\"%s\",&ch);\n    int i,c1=0,c2=0;\n     for(i=0;i<strlen(ch);i++)\n      {\n         if(ch[i]==4+48)\n             c1++;\n         else if(ch[i]==7+48)\n              c2++;\n     }\n     if(c1==0 && c2==0)\n         printf(\"-1\\n\");\n       else if(c1>=c2)\n           printf(\"4\\n\");\n          else\n          printf(\"7\\n\");\n         return 0;\n        }","prob_desc_sample_outputs":"[\"4\", \"-1\", \"7\"]","lang_cluster":"C","code_uid":"9273cd3454997f0b8121b40a8a00e7b4","prob_desc_notes":"NoteThe lexicographical comparison of strings is performed by the &lt; operator in the modern programming languages. String x is lexicographically less than string y either if x is a prefix of y, or exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009min(|x|,\u2009|y|)), that xi\u2009&lt;\u2009yi and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. Here |a| denotes the length of string a.In the first sample three conditions are fulfilled for strings \"4\", \"7\" and \"47\". The lexicographically minimum one is \"4\".In the second sample s has no substrings which are lucky numbers.In the third sample the three conditions are only fulfilled for string \"7\".","prob_desc_output_spec":"In the only line print the answer to Petya's problem. If the sought string does not exist, print \"-1\" (without quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya was delivered a string s, containing only digits. He needs to find a string that represents a lucky number without leading zeroes, is not empty, is contained in s as a substring the maximum number of times.Among all the strings for which the three conditions given above are fulfilled, Petya only needs the lexicographically minimum one. Find this string for Petya.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '444777', 'output': ['4\\n']}, {'input': '777444', 'output': ['4\\n']}, {'input': '1234567890', 'output': ['-1\\n']}, {'input': '777777', 'output': ['7\\n']}, {'input': '444444', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 2\\nRU\", \"1 2\\nRU\", \"-1 1000000000\\nLRRLU\", \"0 0\\nD\"]","prob_desc_input_spec":"The first line contains two integers a and b, (\u2009-\u2009109\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009109). The second line contains a string s (1\u2009\u2264\u2009|s|\u2009\u2264\u2009100, s only contains characters 'U', 'D', 'L', 'R') \u2014 the command.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <string.h>\n\nint a,b,l;\nint x,y,xl,yl;\n\nchar s[105];\nint  w[105][2];\nint al,bl;\n\nint p(int a1,int b1,int x1,int y1)\n{\n    if  ((a1<0&&x1>0)||(a1>0&&x1<0))return 0;\n    if  ((b1<0&&y1>0)||(b1>0&&y1<0))return 0;\n    return 1;\n}\nint main()\n{\n    int i,j;\n    \n    scanf (\"%d%d\",&a,&b);\n    scanf (\"%s\",s);l=strlen(s);\n    if  (a==0&&b==0){printf (\"Yes\\n\");return 0;}\n    for (i=0;i<l;i++) {\n        if  (s[i]=='U'){w[i+1][0]=0;w[i+1][1]=1;}\n        if  (s[i]=='D'){w[i+1][0]=0;w[i+1][1]=-1;}\n        if  (s[i]=='L'){w[i+1][0]=-1;w[i+1][1]=0;}\n        if  (s[i]=='R'){w[i+1][0]=1;w[i+1][1]=0;}\n    }\n    for (i=0;i<=l;i++) {\n        xl+=w[i][0];yl+=w[i][1];\n    }\n    \/\/printf (\"{{%d %d}}\\n\",xl,yl);\n    for (i=0;i<=l;i++) {\n        x+=w[i][0];y+=w[i][1];\n        al=a-x;bl=b-y;\/\/printf (\"(%d %d)<%d,%d>\\n\",al,bl,x,y);\n        if  (!p(al,bl,xl,yl))continue;\n        if  (al==0&&bl==0) {printf (\"Yes\\n\");return 0;}\n        if  (al==0) {if  (xl==0&&yl!=0&&bl%yl==0) {printf (\"Yes\\n\");return 0;}else continue;}\n        if  (bl==0) {if  (yl==0&&xl!=0&&al%xl==0) {printf (\"Yes\\n\");return 0;}else continue;}\n        if  (xl!=0&&yl!=0&&al%xl==0&&bl%yl==0&&al\/xl==bl\/yl){printf (\"Yes\\n\");return 0;}\n        \n    }\n    printf (\"No\\n\");\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"Yes\", \"No\", \"Yes\", \"Yes\"]","lang_cluster":"C","code_uid":"c2acdd580aea47e08a1ff2d92ec2a416","prob_desc_notes":"NoteIn the first and second test case, command string is \"RU\", so the robot will go right, then go up, then right, and then up and so on.The locations of its moves are (0, 0) \u2009\u2192\u2009 (1, 0) \u2009\u2192\u2009 (1, 1) \u2009\u2192\u2009 (2, 1) \u2009\u2192\u2009 (2, 2) \u2009\u2192\u2009 ...So it can reach (2, 2) but not (1, 2).","prob_desc_output_spec":"Print \"Yes\" if the robot will be located at (a,\u2009b), and \"No\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"Fox Ciel has a robot on a 2D plane. Initially it is located in (0, 0). Fox Ciel code a command to it. The command was represented by string s. Each character of s is one move operation. There are four move operations at all:  'U': go up, (x, y) \u2009\u2192\u2009 (x, y+1);  'D': go down, (x, y) \u2009\u2192\u2009 (x, y-1);  'L': go left, (x, y) \u2009\u2192\u2009 (x-1, y);  'R': go right, (x, y) \u2009\u2192\u2009 (x+1, y). The robot will do the operations in s from left to right, and repeat it infinite times. Help Fox Ciel to determine if after some steps the robot will located in (a,\u2009b).","length":46,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0\\nU', 'output': ['Yes\\n']}, {'input': '1 1\\nRU', 'output': ['No\\n']}, {'input': '-1 -1\\nLD', 'output': ['Yes\\n']}, {'input': '2 0\\nRR', 'output': ['Yes\\n']}, {'input': '0 1\\nD', 'output': ['No\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 3\\n0 4 5 6 7\", \"1 0\\n0\", \"5 0\\n1 2 3 4 5\"]","prob_desc_input_spec":"The first line contains two integers n and x (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009x\u2009\u2264\u2009100)\u00a0\u2014 the size of the set Dr. Evil owns, and the desired MEX. The second line contains n distinct non-negative integers not exceeding 100 that represent the set.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nint main(){\n\tint n,x,i,t;\n\tscanf(\"%d %d\", &n,&x);\n\tint ans = x;\n \tfor(i = 0; i < n; i++){\n\t\tscanf(\"%d\", &t);\n\t\tif(t < x) ans--;\n        else if(t==x)ans++;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"2\", \"1\", \"0\"]","lang_cluster":"C","code_uid":"d8354977f745cc62119a6c5a6feb579e","prob_desc_notes":"NoteFor the first test case Dr. Evil should add 1 and 2 to the set performing 2 operations.For the second test case Dr. Evil should erase 0 from the set. After that, the set becomes empty, so the MEX of it is 0.In the third test case the set is already evil.","prob_desc_output_spec":"The only line should contain one integer\u00a0\u2014 the minimal number of operations Dr. Evil should perform.","prob_desc_output_to":"standard output","prob_desc_description":"Dr. Evil kidnapped Mahmoud and Ehab in the evil land because of their performance in the Evil Olympiad in Informatics (EOI). He decided to give them some problems to let them go.Dr. Evil is interested in sets, He has a set of n integers. Dr. Evil calls a set of integers evil if the MEX of it is exactly x. the MEX of a set of integers is the minimum non-negative integer that doesn't exist in it. For example, the MEX of the set {0,\u20092,\u20094} is 1 and the MEX of the set {1,\u20092,\u20093} is 0 .Dr. Evil is going to make his set evil. To do this he can perform some operations. During each operation he can add some non-negative integer to his set or erase some element from it. What is the minimal number of operations Dr. Evil has to perform to make his set evil?","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 2\\n0 1 3', 'output': ['1\\n']}, {'input': '4 1\\n0 2 3 4', 'output': ['0\\n']}, {'input': '5 5\\n0 1 2 3 4', 'output': ['0\\n']}, {'input': '6 0\\n1 2 3 4 5 6', 'output': ['0\\n']}, {'input': '2 2\\n0 2', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1\\n2\\n1\\n1\\n10\", \"1\\n2\\n1\\n1\\n8\"]","prob_desc_input_spec":"The input data contains integers vp,\u2009vd,\u2009t,\u2009f and c, one per line (1\u2009\u2264\u2009vp,\u2009vd\u2009\u2264\u2009100, 1\u2009\u2264\u2009t,\u2009f\u2009\u2264\u200910, 1\u2009\u2264\u2009c\u2009\u2264\u20091000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main(){\n  float vp,vd,t,f,c;\n  float phm,d=0,time=0;\n  int bijous=0;\n  scanf(\"%f%f%f%f%f\",&vp,&vd,&t,&f,&c);\n  for(phm=t*vp;;){\n    \/\/printf(\"%f\\n\",phm);\n    if(vd<=vp)\n      break;\n    phm+=phm*vp\/(vd-vp);\n    if(phm>=c)\n      break;\n    else{\n      phm+=f*vp+(phm\/vd)*vp;\n      bijous++;\n    }\n\n  }\n  printf(\"%d\",bijous);\n  return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"1\"]","lang_cluster":"C","code_uid":"2d711d45f1108dfb3303465c99137e62","prob_desc_notes":"NoteIn the first case one hour after the escape the dragon will discover it, and the princess will be 1 mile away from the cave. In two hours the dragon will overtake the princess 2 miles away from the cave, and she will need to drop the first bijou. Return to the cave and fixing the treasury will take the dragon two more hours; meanwhile the princess will be 4 miles away from the cave. Next time the dragon will overtake the princess 8 miles away from the cave, and she will need the second bijou, but after this she will reach the castle without any further trouble.The second case is similar to the first one, but the second time the dragon overtakes the princess when she has reached the castle, and she won't need the second bijou.","prob_desc_output_spec":"Output the minimal number of bijous required for the escape to succeed.","prob_desc_output_to":"standard output","prob_desc_description":"The princess is going to escape the dragon's cave, and she needs to plan it carefully.The princess runs at vp miles per hour, and the dragon flies at vd miles per hour. The dragon will discover the escape after t hours and will chase the princess immediately. Looks like there's no chance to success, but the princess noticed that the dragon is very greedy and not too smart. To delay him, the princess decides to borrow a couple of bijous from his treasury. Once the dragon overtakes the princess, she will drop one bijou to distract him. In this case he will stop, pick up the item, return to the cave and spend f hours to straighten the things out in the treasury. Only after this will he resume the chase again from the very beginning.The princess is going to run on the straight. The distance between the cave and the king's castle she's aiming for is c miles. How many bijous will she need to take from the treasury to be able to reach the castle? If the dragon overtakes the princess at exactly the same moment she has reached the castle, we assume that she reached the castle before the dragon reached her, and doesn't need an extra bijou to hold him off.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n2\\n1\\n1\\n10', 'output': ['2']}, {'input': '1\\n2\\n1\\n1\\n8', 'output': ['1']}, {'input': '2\\n3\\n2\\n2\\n15', 'output': ['2']}, {'input': '3\\n4\\n2\\n2\\n20', 'output': ['2']}, {'input': '1\\n1\\n1\\n1\\n10', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 2 8\", \"1 2 -18\", \"2 2 -1\"]","prob_desc_input_spec":"The first line contains three space-separated integers: a,\u2009b,\u2009c (1\u2009\u2264\u2009a\u2009\u2264\u20095;\u00a01\u2009\u2264\u2009b\u2009\u2264\u200910000;\u00a0\u2009-\u200910000\u2009\u2264\u2009c\u2009\u2264\u200910000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <math.h>\n\nint chk(long long x)\n{\n\tint ret = 0;\n\twhile(x)\n\t{\n\t\tret += (x%10);\n\t\tx\/=10;\n\t}\n\treturn ret;\n}\n\nlong long po(long long int a,long long x)\n{\n\tif(x == 0)\n\t\treturn 1;\n\tlong long temp;\n\ttemp = po(a,x\/2);\n\ttemp *= temp;\n\tif(x%2)\n\t\ttemp *= a;\n\treturn temp;\n}\n\nint main()\n{\n\tlong long int a,b,c;\n\tscanf(\"%lld %lld %lld\",&a,&b,&c);\n\tlong long int i;\n\tint cnt = 0;\n\tlong long ans[100];\n\tfor(i=1;i<=81;i++)\n\t{\n\t\tlong long temp = b*(po(i,a)) + c;\n\t\tif(temp <= 1000000000 && temp >=0  && chk(temp) == i)\n\t\t\tans[cnt++] = temp;\n\t}\n\n\tprintf(\"%d\\n\",cnt );\n\tfor(i=0;i<cnt;i++)\n\t\tprintf(\"%d \",ans[i] );\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"3\\n10 2008 13726\", \"0\", \"4\\n1 31 337 967\"]","lang_cluster":"C","code_uid":"13fe612557a5964b06b2a32f09c026ee","prob_desc_notes":null,"prob_desc_output_spec":"Print integer n \u2014 the number of the solutions that you've found. Next print n integers in the increasing order \u2014 the solutions of the given equation. Print only integer solutions that are larger than zero and strictly less than 109.","prob_desc_output_to":"standard output","prob_desc_description":"Little Dima misbehaved during a math lesson a lot and the nasty teacher Mr. Pickles gave him the following problem as a punishment. Find all integer solutions x (0\u2009&lt;\u2009x\u2009&lt;\u2009109) of the equation:x\u2009=\u2009b\u00b7s(x)a\u2009+\u2009c,\u2009 where a, b, c are some predetermined constant values and function s(x) determines the sum of all digits in the decimal representation of number x.The teacher gives this problem to Dima for each lesson. He changes only the parameters of the equation: a, b, c. Dima got sick of getting bad marks and he asks you to help him solve this challenging problem.","length":45,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 0', 'output': ['10\\n1 2 3 4 5 6 7 8 9 10 ']}, {'input': '2 2 2', 'output': ['5\\n2 4 8 512 46656 ']}, {'input': '3 3 3', 'output': ['2\\n3 19683 ']}, {'input': '4 4 4', 'output': ['1\\n4 ']}, {'input': '5 5 5', 'output': ['1\\n5 ']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 6 1 2 1 6\", \"6 5 4 3 2 1\", \"10 10 1 1 10 10\"]","prob_desc_input_spec":"The first line contains six integers n, m, x1, y1, x2, y2 \u2014 the board sizes and the coordinates of the first and second chips, correspondingly (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100; 2\u2009\u2264\u2009n\u2009\u00d7\u2009m; 1\u2009\u2264\u2009x1,\u2009x2\u2009\u2264\u2009n; 1\u2009\u2264\u2009y1,\u2009y2\u2009\u2264\u2009m). The numbers in the line are separated by single spaces. It is guaranteed that the chips are located in different squares.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int i, j, n, m, x1, y1, x2, y2;\n\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &x1, &y1, &x2, &y2);\n\n    i = abs(x1 - x2);\n    j = abs(y1 - y2);\n\n    if (i > j) {\n        int aux = i;\n        i = j;\n        j = aux;\n    }\n\n    if ((i <= 2 && j <= 4) || (i == 3 && j == 3)) {\n        puts(\"First\");\n    } else {\n        puts(\"Second\");\n    }\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"First\", \"First\", \"Second\"]","lang_cluster":"C","code_uid":"8a5a55907807b32a800bc46bbfcc0732","prob_desc_notes":null,"prob_desc_output_spec":"If the first player wins, print \"First\" without the quotes. Otherwise, print \"Second\" without the quotes.","prob_desc_output_to":"standard output","prob_desc_description":"Two players play a game. The game is played on a rectangular board with n\u2009\u00d7\u2009m squares. At the beginning of the game two different squares of the board have two chips. The first player's goal is to shift the chips to the same square. The second player aims to stop the first one with a tube of superglue.We'll describe the rules of the game in more detail.The players move in turns. The first player begins.With every move the first player chooses one of his unglued chips, and shifts it one square to the left, to the right, up or down. It is not allowed to move a chip beyond the board edge. At the beginning of a turn some squares of the board may be covered with a glue. The first player can move the chip to such square, in this case the chip gets tightly glued and cannot move any longer.At each move the second player selects one of the free squares (which do not contain a chip or a glue) and covers it with superglue. The glue dries long and squares covered with it remain sticky up to the end of the game.If, after some move of the first player both chips are in the same square, then the first player wins. If the first player cannot make a move (both of his chips are glued), then the second player wins. Note that the situation where the second player cannot make a move is impossible \u2014 he can always spread the glue on the square from which the first player has just moved the chip.We will further clarify the case where both chips are glued and are in the same square. In this case the first player wins as the game ends as soon as both chips are in the same square, and the condition of the loss (the inability to move) does not arise.You know the board sizes and the positions of the two chips on it. At the beginning of the game all board squares are glue-free. Find out who wins if the players play optimally.","length":26,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3 1 1 3 3', 'output': ['First\\n']}, {'input': '5 5 1 1 5 5', 'output': ['Second\\n']}, {'input': '4 4 1 1 4 4', 'output': ['First\\n']}, {'input': '2 2 1 1 2 2', 'output': ['First\\n']}, {'input': '6 6 1 1 6 6', 'output': ['Second\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 3\", \"8 2\"]","prob_desc_input_spec":"The first line of the input contains two integers, given in the decimal notation, n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009109)\u00a0\u2014 the number of hours in one day and the number of minutes in one hour, respectively.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdlib.h>\n#include <stdio.h>\n\nint main() {\n\tint n, m, d;\n\tscanf(\"%d%d\", &n, &m);\n\tint dn = 1, dm = 1;\n\tfor(int k = 7 ; k < n ; k *= 7) dn++;\n\tfor(int k = 7 ; k < m ; k *= 7) dm++;\t\n\td = dn + dm;\n\tif(d > 7) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint r = 0;\n\tfor(int i=0 ; i<n ; i++) {\n\t\tfor(int j=0 ; j<m ; j++) {\n\t\t\tint u[7] = {0};\n\t\t\tint a = i, b = j;\n\t\t\tfor(int k=0 ; k<dn ; k++) {\n\t\t\t\tu[a%7]++;\n\t\t\t\ta \/= 7;\n\t\t\t}\n\t\t\tfor(int k=0 ; k<dm ; k++) {\n\t\t\t\tu[b%7]++;\n\t\t\t\tb \/= 7;\n\t\t\t}\n\t\t\tr++;\n\t\t\tfor(int k=0 ; k<7 ; k++) {\n\t\t\t\tif(u[k] > 1) {\n\t\t\t\t\tr--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", r);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"4\", \"5\"]","lang_cluster":"C","code_uid":"94d7be9f372815214cda9a7451b4e5d9","prob_desc_notes":"NoteIn the first sample, possible pairs are: (0:\u20091), (0:\u20092), (1:\u20090), (1:\u20092).In the second sample, possible pairs are: (02:\u20091), (03:\u20091), (04:\u20091), (05:\u20091), (06:\u20091).","prob_desc_output_spec":"Print one integer in decimal notation\u00a0\u2014 the number of different pairs of hour and minute, such that all digits displayed on the watches are distinct.","prob_desc_output_to":"standard output","prob_desc_description":"Robbers, who attacked the Gerda's cab, are very successful in covering from the kingdom police. To make the goal of catching them even harder, they use their own watches.First, as they know that kingdom police is bad at math, robbers use the positional numeral system with base 7. Second, they divide one day in n hours, and each hour in m minutes. Personal watches of each robber are divided in two parts: first of them has the smallest possible number of places that is necessary to display any integer from 0 to n\u2009-\u20091, while the second has the smallest possible number of places that is necessary to display any integer from 0 to m\u2009-\u20091. Finally, if some value of hours or minutes can be displayed using less number of places in base 7 than this watches have, the required number of zeroes is added at the beginning of notation.Note that to display number 0 section of the watches is required to have at least one place.Little robber wants to know the number of moments of time (particular values of hours and minutes), such that all digits displayed on the watches are distinct. Help her calculate this number.","length":39,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['1\\n']}, {'input': '7 7', 'output': ['49\\n']}, {'input': '10 10', 'output': ['0\\n']}, {'input': '5 5', 'output': ['25\\n']}, {'input': '3 3', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"500 1000 20 30\", \"1000 1000 1 1\", \"1500 1000 176 177\"]","prob_desc_input_spec":"The first line contains four integers a, b, c, d (250\u2009\u2264\u2009a,\u2009b\u2009\u2264\u20093500, 0\u2009\u2264\u2009c,\u2009d\u2009\u2264\u2009180).  It is guaranteed that numbers a and b are divisible by 250 (just like on any real Codeforces round).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nint max(int a, int b){\n    int maxim;\n    return maxim=(a>=b)?a:b;\n}\n\nint main(void)\n{\n    int a,b,c,d, misha, vasya;\n    scanf(\"%d %d %d %d\", &a,&b,&c,&d);\n    misha = max((3*a)\/10 ,a- ((a*c)\/250));\n    vasya = max((3*b)\/10 ,b-((b*d)\/250));\n    if(misha>vasya) printf(\"Misha\");\n    else if(misha<vasya) printf(\"Vasya\");\n    else printf(\"Tie\");\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"Vasya\", \"Tie\", \"Misha\"]","lang_cluster":"C","code_uid":"ec99b5542204d33db49be9c884f1e233","prob_desc_notes":null,"prob_desc_output_spec":"Output on a single line:  \"Misha\" (without the quotes), if Misha got more points than Vasya. \"Vasya\" (without the quotes), if Vasya got more points than Misha. \"Tie\" (without the quotes), if both of them got the same number of points.","prob_desc_output_to":"standard output","prob_desc_description":"Misha and Vasya participated in a Codeforces contest. Unfortunately, each of them solved only one problem, though successfully submitted it at the first attempt. Misha solved the problem that costs a points and Vasya solved the problem that costs b points. Besides, Misha submitted the problem c minutes after the contest started and Vasya submitted the problem d minutes after the contest started. As you know, on Codeforces the cost of a problem reduces as a round continues. That is, if you submit a problem that costs p points t minutes after the contest started, you get  points. Misha and Vasya are having an argument trying to find out who got more points. Help them to find out the truth.","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2500 3000 60 70', 'output': ['Vasya\\n']}, {'input': '3000 3000 10 10', 'output': ['Tie\\n']}, {'input': '3500 2500 120 130', 'output': ['Misha\\n']}, {'input': '2500 2500 0 0', 'output': ['Tie\\n']}, {'input': '3000 3500 180 180', 'output': ['Vasya\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 2 4\\n3 4\\n1 1\", \"5 4 0\\n1 2\\n3 1\"]","prob_desc_input_spec":"The first line contains three integers s, x1 and x2 (2\u2009\u2264\u2009s\u2009\u2264\u20091000, 0\u2009\u2264\u2009x1,\u2009x2\u2009\u2264\u2009s, x1\u2009\u2260\u2009x2)\u00a0\u2014 the maximum coordinate of the point to which the tram goes, the point Igor is at, and the point he should come to. The second line contains two integers t1 and t2 (1\u2009\u2264\u2009t1,\u2009t2\u2009\u2264\u20091000)\u00a0\u2014 the time in seconds in which the tram passes 1 meter and the time in seconds in which Igor passes 1 meter. The third line contains two integers p and d (1\u2009\u2264\u2009p\u2009\u2264\u2009s\u2009-\u20091, d is either 1 or )\u00a0\u2014 the position of the tram in the moment Igor came to the point x1 and the direction of the tram at this moment. If , the tram goes in the direction from the point s to the point 0. If d\u2009=\u20091, the tram goes in the direction from the point 0 to the point s.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint t,T1,T2,s,f,x1,x2,p,d,t1,t2,i;\/\/\/T2 \ufffd\ufffd            T1 \ufffd\ufffd\nint main()\n{\n    scanf(\"%d %d %d %d %d %d %d\",&s,&x1,&x2,&t1,&t2,&p,&d);\n    if(x2-x1>0) f=1;\n    else f=-1;\n    T2=(x2-x1)*t2*f;\n    if(t1<t2){\n        if((x1<x2&&x2<=p&&d<0)||(x1<=p&&p<=x2&&d<0)||(p<=x1&&x1<x2)||(x1<=p&&x1>x2&&d<0)){\n            t=(f*x1-d*p)*t1*t2\/(t2-t1);\n        }\n        else\n            t=(2*s+x1*f-d*p)*t1*t2\/(t2-t1);\n    }\n    else\n    {\n        printf(\"%d\",T2);\n        return 0;\n    }\n    if(t<T2){\n        if((x1<x2&&x2<=p&&d<0)||(x1<=p&&p<=x2&&d<0)||(p<=x1&&x1<x2)||(x1<=p&&x1>x2&&d<0)){\n            t=(f*x2-d*p)*t1;\n        }\n        else\n            t=(2*s+x2*f-d*p)*t1;\n        printf(\"%d\",t);\n    }\n    else\n        printf(\"%d\",T2);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"8\", \"7\"]","lang_cluster":"C","code_uid":"dbbd547e48d3f924ae81880818c114b9","prob_desc_notes":"NoteIn the first example it is profitable for Igor to go by foot and not to wait the tram. Thus, he has to pass 2 meters and it takes 8 seconds in total, because he passes 1 meter per 4 seconds. In the second example Igor can, for example, go towards the point x2 and get to the point 1 in 6 seconds (because he has to pass 3 meters, but he passes 1 meters per 2 seconds). At that moment the tram will be at the point 1, so Igor can enter the tram and pass 1 meter in 1 second. Thus, Igor will reach the point x2 in 7 seconds in total.","prob_desc_output_spec":"Print the minimum time in seconds which Igor needs to get from the point x1 to the point x2.","prob_desc_output_to":"standard output","prob_desc_description":"The tram in Berland goes along a straight line from the point 0 to the point s and back, passing 1 meter per t1 seconds in both directions. It means that the tram is always in the state of uniform rectilinear motion, instantly turning around at points x\u2009=\u20090 and x\u2009=\u2009s.Igor is at the point x1. He should reach the point x2. Igor passes 1 meter per t2 seconds. Your task is to determine the minimum time Igor needs to get from the point x1 to the point x2, if it is known where the tram is and in what direction it goes at the moment Igor comes to the point x1.Igor can enter the tram unlimited number of times at any moment when his and the tram's positions coincide. It is not obligatory that points in which Igor enter and exit the tram are integers. Assume that any boarding and unboarding happens instantly. Igor can move arbitrary along the line (but not faster than 1 meter per t2 seconds). He can also stand at some point for some time.","length":32,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5 8\\n2 3\\n4 1', 'output': ['6']}, {'input': '20 10 0\\n1 2\\n15 1', 'output': ['20']}, {'input': '100 50 75\\n5 10\\n25 1', 'output': ['250']}, {'input': '500 250 0\\n10 20\\n125 1', 'output': ['5000']}, {'input': '1000 500 750\\n20 40\\n250 1', 'output': ['10000']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1 3\\n2 3\\n1 4\\n5 3\", \"5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\"]","prob_desc_input_spec":"The first line contains an integer m (0\u2009\u2264\u2009m\u2009\u2264\u200910), which is the number of relations of acquaintances among the five friends of Igor's. Each of the following m lines contains two integers ai and bi (1\u2009\u2264\u2009ai,\u2009bi\u2009\u2264\u20095;ai\u2009\u2260\u2009bi), where (ai,\u2009bi) is a pair of acquainted people. It is guaranteed that each pair of the acquaintances is described exactly once. The acquaintance relation is symmetrical, i.e. if x is acquainted with y, then y is also acquainted with x.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n\tint i,j,k,a[100][100],n,x,y,flag=0;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<=5;i++)\n\t   for(j=0;j<=5;j++)\n\t   a[i][j]=0;\n\tfor(i=0;i<n;i++)\n\t{\n\tscanf(\"%d%d\",&x,&y);\n\ta[x][y]=1;\n\ta[y][x]=1;\n\t}\n\t\n\tfor(i=1;i<=5;i++)\n\t  for(j=i+1;j<=5;j++)\n\t    for(k=j+1;k<=5;k++)\n\t     {\n\t     \tif(a[i][j]==1 && a[i][k]==1 && a[j][k]==1) flag=1;\n\t     \telse if(a[i][j]!=1 && a[i][k]!=1 && a[j][k]!=1) flag=1;\n\t     \t\n\t     }\n\t     if(flag==1) printf(\"WIN\\n\");\n\t     else printf(\"FAIL\\n\");\nreturn 0;\n}\n\t     \n\t\n","prob_desc_sample_outputs":"[\"WIN\", \"FAIL\"]","lang_cluster":"C","code_uid":"ab7155132d0868c2688c3bca40a5ec9b","prob_desc_notes":null,"prob_desc_output_spec":"Print \"FAIL\", if among those five people there are no either three pairwise acquainted or three pairwise unacquainted people. Otherwise print \"WIN\".","prob_desc_output_to":"standard output","prob_desc_description":"One day Igor K. stopped programming and took up math. One late autumn evening he was sitting at a table reading a book and thinking about something. The following statement caught his attention: \"Among any six people there are either three pairwise acquainted people or three pairwise unacquainted people\"Igor just couldn't get why the required minimum is 6 people. \"Well, that's the same for five people, too!\" \u2014 he kept on repeating in his mind. \u2014 \"Let's take, say, Max, Ilya, Vova \u2014 here, they all know each other! And now let's add Dima and Oleg to Vova \u2014 none of them is acquainted with each other! Now, that math is just rubbish!\"Igor K. took 5 friends of his and wrote down who of them is friends with whom. Now he wants to check whether it is true for the five people that among them there are either three pairwise acquainted or three pairwise not acquainted people.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3\\n1 2\\n2 3\\n3 1', 'output': ['WIN\\n']}, {'input': '4\\n1 2\\n2 3\\n3 4\\n4 1', 'output': ['FAIL\\n']}, {'input': '5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1', 'output': ['FAIL\\n']}, {'input': '6\\n1 2\\n2 3\\n3 1\\n4 5\\n5 1\\n1 3', 'output': ['WIN\\n']}, {'input': '0\\n', 'output': ['WIN\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"100\\n15 20 20 15 10 30 45\", \"2\\n1 0 0 0 0 0 0\"]","prob_desc_input_spec":"The first input line contains the single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) \u2014 the number of pages in the book. The second line contains seven non-negative space-separated integers that do not exceed 1000 \u2014 those integers represent how many pages Petr can read on Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday correspondingly. It is guaranteed that at least one of those numbers is larger than zero.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    int i,j,t,a,b,page, sum =0;\n    int day[8];\n\n    scanf (\"%d\",&page);\n\n    for(i=1; i<8; i++){\n        scanf(\"%d\", &day[i]);\n    }\n\n    j = 0;\n    while(1){\n        j++;\n        sum = sum + day[j];\n        if(sum >= page){\n            printf(\"%d\\n\", j);\n            break;\n        }\n        else if(j==7){\n            j = 0;\n        }\n\n\n    }\n}\n","prob_desc_sample_outputs":"[\"6\", \"1\"]","lang_cluster":"C","code_uid":"5aae891caa5a564ec3de3f155b951614","prob_desc_notes":"NoteNote to the first sample:By the end of Monday and therefore, by the beginning of Tuesday Petr has 85 pages left. He has 65 pages left by Wednesday, 45 by Thursday, 30 by Friday, 20 by Saturday and on Saturday Petr finishes reading the book (and he also has time to read 10 pages of something else).Note to the second sample:On Monday of the first week Petr will read the first page. On Monday of the second week Petr will read the second page and will finish reading the book.","prob_desc_output_spec":"Print a single number \u2014 the number of the day of the week, when Petr will finish reading the book. The days of the week are numbered starting with one in the natural order: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday.","prob_desc_output_to":"standard output","prob_desc_description":"One Sunday Petr went to a bookshop and bought a new book on sports programming. The book had exactly n pages.Petr decided to start reading it starting from the next day, that is, from Monday. Petr's got a very tight schedule and for each day of the week he knows how many pages he will be able to read on that day. Some days are so busy that Petr will have no time to read whatsoever. However, we know that he will be able to read at least one page a week.Assuming that Petr will not skip days and will read as much as he can every day, determine on which day of the week he will read the last page of the book.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1000\\n100 100 100 100 100 100 100', 'output': ['1\\n']}, {'input': '500\\n100 100 100 100 100 100 100', 'output': ['5\\n']}, {'input': '1\\n1 1 1 1 1 1 1', 'output': ['1\\n']}, {'input': '7\\n1 1 1 1 1 1 1', 'output': ['7\\n']}, {'input': '10\\n2 2 2 2 2 2 2', 'output': ['5\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 2\", \"9 3\"]","prob_desc_input_spec":"The single line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009100;\u00a02\u2009\u2264\u2009m\u2009\u2264\u2009100), separated by a space.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()           \n{\n    int n,m,sum,d;\n    scanf(\"%d %d\",&n,&m);\n    sum=n;\n    rich:\n    d=n\/m;\n    if(d>0)\n    {\n    sum=sum+d;\n    if(((n%m)+d)>=m)\n    {\n    n=(n%m)+d;\n    goto rich;\n    }\n    }\n    printf(\"%d\",sum);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"3\", \"13\"]","lang_cluster":"C","code_uid":"4ddeb8bc7010671a1fde171d9c6c2c67","prob_desc_notes":"NoteIn the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.","prob_desc_output_spec":"Print a single integer \u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya has n pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every m-th day (at days with numbers m,\u20092m,\u20093m,\u2009...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2', 'output': ['9']}, {'input': '10 3', 'output': ['14']}, {'input': '20 4', 'output': ['26']}, {'input': '30 5', 'output': ['37']}, {'input': '40 6', 'output': ['47']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"0 1 1\\n1 0 1\\n1 1 0\", \"0 3 6\\n5 0 5\\n4 7 0\"]","prob_desc_input_spec":"The first three lines of the input contain the Little Elephant's notes. The first line contains elements of the first row of the magic square. The second line contains the elements of the second row, the third line is for the third row. The main diagonal elements that have been forgotten by the Elephant are represented by zeroes. It is guaranteed that the notes contain exactly three zeroes and they are all located on the main diagonal. It is guaranteed that all positive numbers in the table do not exceed 105.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    int x,y,z,i,j;\n    int a[3][3];\n    for(i=0;i<=2;i++)\n    for(j=0;j<=2;j++)\n    scanf(\"%d\",&a[i][j]);\n    y=(a[2][0]+a[2][1]+a[0][1]+a[0][2]-a[1][0]-a[1][2])\/2;\n    x=a[2][0]+a[2][1]-y;\n    z=a[1][0]+a[1][2]-x;\n    a[0][0]=x;\n    a[1][1]=y;\n    a[2][2]=z;\n    for(i=0;i<=2;i++)\n    {\n        for(j=0;j<=2;j++)\n        printf(\"%d \",a[i][j]);\n         printf(\"\\n\");\n    }\n   return 0;\n}","prob_desc_sample_outputs":"[\"1 1 1\\n1 1 1\\n1 1 1\", \"6 3 6\\n5 5 5\\n4 7 4\"]","lang_cluster":"C","code_uid":"451f1f98e7dccb514b975b54667c2063","prob_desc_notes":null,"prob_desc_output_spec":"Print three lines, in each line print three integers \u2014 the Little Elephant's magic square. If there are multiple magic squares, you are allowed to print any of them. Note that all numbers you print must be positive and not exceed 105. It is guaranteed that there exists at least one magic square that meets the conditions.","prob_desc_output_to":"standard output","prob_desc_description":"Little Elephant loves magic squares very much.A magic square is a 3\u2009\u00d7\u20093 table, each cell contains some positive integer. At that the sums of integers in all rows, columns and diagonals of the table are equal. The figure below shows the magic square, the sum of integers in all its rows, columns and diagonals equals 15.  The Little Elephant remembered one magic square. He started writing this square on a piece of paper, but as he wrote, he forgot all three elements of the main diagonal of the magic square. Fortunately, the Little Elephant clearly remembered that all elements of the magic square did not exceed 105. Help the Little Elephant, restore the original magic square, given the Elephant's notes.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 2 3\\n4 0 4\\n3 5 0', 'output': ['3 2 3\\n4 3 4\\n3 5 3\\n']}, {'input': '0 1 4\\n2 0 2\\n3 6 0', 'output': ['4 1 4\\n2 4 2\\n3 6 4\\n']}, {'input': '0 5 10\\n7 0 7\\n6 9 0', 'output': ['10 5 10\\n7 10 7\\n6 9 10\\n']}, {'input': '0 3 6\\n5 0 5\\n4 7 0', 'output': ['6 3 6\\n5 6 5\\n4 7 6\\n']}, {'input': '0 4 8\\n6 0 6\\n5 9 0', 'output': ['8 4 8\\n6 8 6\\n5 9 8\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"8 5\\n10 9 8 7 7 7 5 5\", \"4 2\\n0 0 0 0\"]","prob_desc_input_spec":"The first line of the input contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u200950) separated by a single space. The second line contains n space-separated integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the score earned by the participant who got the i-th place. The given sequence is non-increasing (that is, for all i from 1 to n\u2009-\u20091 the following condition is fulfilled: ai\u2009\u2265\u2009ai\u2009+\u20091).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n\tint n, k;\n\tint i, s = 0, a[101];\n\twhile (scanf(\"%d%d\", &n, &k) != EOF)\n\t{\n\t\tfor (i = 1; i <= n; i++)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i] >= a[k] && a[i] != 0)\n\t\t\t\ts++;\n\t\t}\n\t\tprintf(\"%d\\n\", s);\n\t}\n\treturn 0;\n}\n\t \t    \t\t\t   \t  \t\t\t\t  \t \t \t\t","prob_desc_sample_outputs":"[\"6\", \"0\"]","lang_cluster":"C","code_uid":"a492909277fb2d24dea9ae7e460fd107","prob_desc_notes":"NoteIn the first example the participant on the 5th place earned 7 points. As the participant on the 6th place also earned 7 points, there are 6 advancers.In the second example nobody got a positive score.","prob_desc_output_spec":"Output the number of participants who advance to the next round.","prob_desc_output_to":"standard output","prob_desc_description":"\"Contestant who earns a score equal to or greater than the k-th place finisher's score will advance to the next round, as long as the contestant earns a positive score...\" \u2014 an excerpt from contest rules.A total of n participants took part in the contest (n\u2009\u2265\u2009k), and you already know their scores. Calculate how many participants will advance to the next round.","length":19,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3\\n10 9 8 7 6 5 4 3 2 1', 'output': ['3\\n']}, {'input': '5 5\\n5 4 3 2 1', 'output': ['1\\n']}, {'input': '6 1\\n6 5 4 3 2 1', 'output': ['6\\n']}, {'input': '7 4\\n7 6 5 4 3 2 1', 'output': ['4\\n']}, {'input': '8 2\\n8 7 6 5 4 3 2 1', 'output': ['2\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10 3 2\", \"7 1 2\"]","prob_desc_input_spec":"The first line of the input contains three integers t, w and b (1\u2009\u2264\u2009t,\u2009w,\u2009b\u2009\u2264\u20095\u00b71018) \u2014 the maximum possible length of the racetrack, the length of Willman's steps and the length of Bolt's steps respectively.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nunsigned long long int pgcd(unsigned long long int x,unsigned long long int y)\n    {\n        if (x==0) return y;\n        if (y==0) return x;\n        if ((x==1) || (y==1)) return 1;\n        if (x==y) return x;\n        if (x<y) return pgcd(x,y%x);\n        return pgcd(x%y,y);\n    }\n\nmain()\n    {\n        unsigned long long int t,w,b,ww,bb,m,a,r,p,q,d,s;\n        scanf(\"%llu%llu%llu\",&t,&w,&b);\n        if (w<b) m = w;\n        else m = b;\n        d = pgcd(w,b);\n        ww = w \/ d;\n        bb = b \/ d;\n        if (t<ww)\n            {\n                a = 0;\n                r = t;\n            }\n        else\n            {\n                s = ww;\n                if ((t\/s)<bb)\n                    {\n                        a = 0;\n                        r = t;\n                    }\n                else\n                    {\n                        s = ww * bb;\n                        if ((t\/s)<d)\n                            {\n                                a = 0;\n                                r = t;\n                            }\n                        else\n                            {\n                                s = ww * bb * d;\n                                a = t \/ s;\n                                r = t % s;\n                            }\n                    }\n            }\n        if (m<=r) p = ((a + 1) * m) - 1;\n        else p = (a * m) + r;\n        q = t;\n\n        d = pgcd(p,q);\n        p = p \/ d;\n        q = q \/ d;\n        printf(\"%llu\/%llu\",p,q);\n    }\n","prob_desc_sample_outputs":"[\"3\/10\", \"3\/7\"]","lang_cluster":"C","code_uid":"3d98f298e530d472507af154e93d17c4","prob_desc_notes":"NoteIn the first sample Willman and Bolt will tie in case 1, 6 or 7 are chosen as the length of the racetrack.","prob_desc_output_spec":"Print the answer to the problem as an irreducible fraction . Follow the format of the samples output. The fraction  (p and q are integers, and both p\u2009\u2265\u20090 and q\u2009&gt;\u20090 holds) is called irreducible, if there is no such integer d\u2009&gt;\u20091, that both p and q are divisible by d.","prob_desc_output_to":"standard output","prob_desc_description":"Vector Willman and Array Bolt are the two most famous athletes of Byteforces. They are going to compete in a race with a distance of L meters today.  Willman and Bolt have exactly the same speed, so when they compete the result is always a tie. That is a problem for the organizers because they want a winner. While watching previous races the organizers have noticed that Willman can perform only steps of length equal to w meters, and Bolt can perform only steps of length equal to b meters. Organizers decided to slightly change the rules of the race. Now, at the end of the racetrack there will be an abyss, and the winner will be declared the athlete, who manages to run farther from the starting point of the the racetrack (which is not the subject to change by any of the athletes). Note that none of the athletes can run infinitely far, as they both will at some moment of time face the point, such that only one step further will cause them to fall in the abyss. In other words, the athlete will not fall into the abyss if the total length of all his steps will be less or equal to the chosen distance L.Since the organizers are very fair, the are going to set the length of the racetrack as an integer chosen randomly and uniformly in range from 1 to t (both are included). What is the probability that Willman and Bolt tie again today?","length":60,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '100 5 7', 'output': ['7\/20']}, {'input': '50 10 5', 'output': ['1\/5']}, {'input': '200 4 3', 'output': ['1\/50']}, {'input': '300 6 9', 'output': ['1\/50']}, {'input': '400 8 2', 'output': ['1\/50']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2\", \"3\", \"4\", \"10\"]","prob_desc_input_spec":"The only line of the input contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u20091018)\u00a0\u2014 the number of players to participate in the tournament.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint main()\n{\n   long long int n;\n   long long ans = 0, a = 2, b = 1, c = 0;\n   scanf(\"%lld\", &n);\n   if(n == 2) {printf(\"1\\n\");return 0;}\n   else if(n == 3) {printf(\"2\\n\");return 0;}\n   else\n    while(1)\n   {\n      if(a > n) break;\n      ans++;\n      c = b;\n      b = a;\n      a += c;\n   }\n   printf(\"%lld\", ans);\n   return 0;\n\n}\n","prob_desc_sample_outputs":"[\"1\", \"2\", \"2\", \"4\"]","lang_cluster":"C","code_uid":"3467947eb40378f25dab8d24d096608d","prob_desc_notes":"NoteIn all samples we consider that player number 1 is the winner.In the first sample, there would be only one game so the answer is 1.In the second sample, player 1 can consequently beat players 2 and 3. In the third sample, player 1 can't play with each other player as after he plays with players 2 and 3 he can't play against player 4, as he has 0 games played, while player 1 already played 2. Thus, the answer is 2 and to achieve we make pairs (1,\u20092) and (3,\u20094) and then clash the winners.","prob_desc_output_spec":"Print the maximum number of games in which the winner of the tournament can take part.","prob_desc_output_to":"standard output","prob_desc_description":"Famous Brazil city Rio de Janeiro holds a tennis tournament and Ostap Bender doesn't want to miss this event. There will be n players participating, and the tournament will follow knockout rules from the very first game. That means, that if someone loses a game he leaves the tournament immediately.Organizers are still arranging tournament grid (i.e. the order games will happen and who is going to play with whom) but they have already fixed one rule: two players can play against each other only if the number of games one of them has already played differs by no more than one from the number of games the other one has already played. Of course, both players had to win all their games in order to continue participating in the tournament.Tournament hasn't started yet so the audience is a bit bored. Ostap decided to find out what is the maximum number of games the winner of the tournament can take part in (assuming the rule above is used). However, it is unlikely he can deal with this problem without your help.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n', 'output': ['3\\n']}, {'input': '6\\n', 'output': ['3\\n']}, {'input': '7\\n', 'output': ['4\\n']}, {'input': '8\\n', 'output': ['4\\n']}, {'input': '9\\n', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 3\\nPPW\\nW.P\", \"3 3\\nP.W\\n.P.\\nW.P\"]","prob_desc_input_spec":"The first line contains integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200910) which denotes the number of rows and columns in our two-dimensional grid, respectively. Then follow n lines containing m characters each \u2014 that is the grid description. \".\" means that this cell is empty. \"P\" means that this cell contains a little pig. \"W\" means that this cell contains a wolf.  It is guaranteed that there will be at most one wolf adjacent to any little pig.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint n, m;\nchar map[10][11];\n\nint wolf(int i, int j)\n{\n    return (i >= 0 && i < n && j >= 0 && j < m && map[i][j] == 'W');\n}\n\nint main(int argc, char *argv[])\n{\n    int i, j, c = 0;\n    \n    scanf(\"%d %d\", &n, &m);\n    for(i = 0; i < n; i ++)\n        scanf(\"%s\", map[i]);\n        \n    for(i = 0; i < n; i ++)\n        for(j = 0; j < m; j ++)\n            if(map[i][j] == 'P')\n            {\n                if(wolf(i - 1, j))\n                    map[i - 1][j] = '.', c ++;\n                else if(wolf(i + 1, j))\n                    map[i + 1][j] = '.', c ++;\n                else if(wolf(i, j - 1))\n                    map[i][j - 1] = '.', c ++;\n                else if(wolf(i, j + 1))\n                    map[i][j + 1] = '.', c ++;\n            }\n            \n    printf(\"%d\\n\", c);\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"0\"]","lang_cluster":"C","code_uid":"6d79789b2c600252ab10872dda7f4ba3","prob_desc_notes":"NoteIn the first example, one possible scenario in which two little pigs get eaten by the wolves is as follows.   ","prob_desc_output_spec":"Print a single number \u2014 the maximal number of little pigs that may be eaten by the wolves.","prob_desc_output_to":"standard output","prob_desc_description":"Once upon a time there were several little pigs and several wolves on a two-dimensional grid of size n\u2009\u00d7\u2009m. Each cell in this grid was either empty, containing one little pig, or containing one wolf.A little pig and a wolf are adjacent if the cells that they are located at share a side. The little pigs are afraid of wolves, so there will be at most one wolf adjacent to each little pig. But each wolf may be adjacent to any number of little pigs.They have been living peacefully for several years. But today the wolves got hungry. One by one, each wolf will choose one of the little pigs adjacent to it (if any), and eats the poor little pig. This process is not repeated. That is, each wolf will get to eat at most one little pig. Once a little pig gets eaten, it disappears and cannot be eaten by any other wolf.What is the maximum number of little pigs that may be eaten by the wolves?","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3\\nP.W\\n.P.\\nW.P\\n', 'output': ['0\\n']}, {'input': '2 3\\nPPW\\nW.P\\n', 'output': ['2\\n']}, {'input': '2 2\\nPW\\nWP\\n', 'output': ['2\\n']}, {'input': '1 3\\nPWP\\n', 'output': ['1\\n']}, {'input': '3 3\\n...\\n.P.\\n...\\n', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 3 2\", \"3 2 1\"]","prob_desc_input_spec":"The first line contains three integers r, g and b (0\u2009\u2264\u2009r,\u2009g,\u2009b\u2009\u2264\u2009100). It is guaranteed that r\u2009+\u2009g\u2009+\u2009b\u2009&gt;\u20090, it means that the group consists of at least one student. ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint main()\n{\n     int n, sum = 0, i;\n     int a[3];\n\n     scanf(\"%d %d %d\", &a[0], &a[1], &a[2]);\n\n     n = a[0] + a[1] + a[2];\n\n     for (i = 0; ; i++) {\n\t  if (a[i % 3] >= 2) {\n\t       a[i % 3] -= 2;\n\t       n -= 2;\n\t  } else if (a[i % 3] == 1) {\n\t       a[i % 3]--;\n\t       n--;\n\t  }\n\n\t  if (n == 0) break;\n     }\n\n     printf(\"%d\\n\", i + 30);\n\n     return 0;\n}\n","prob_desc_sample_outputs":"[\"34\", \"33\"]","lang_cluster":"C","code_uid":"1ee207ebdacfd721e0498e96d6c876de","prob_desc_notes":"NoteLet's analyze the first sample.At the moment of time 0 a red cablecar comes and one student from the r group get on it and ascends to the top at the moment of time 30.At the moment of time 1 a green cablecar arrives and two students from the g group get on it; they get to the top at the moment of time 31.At the moment of time 2 comes the blue cablecar and two students from the b group get on it. They ascend to the top at the moment of time 32.At the moment of time 3 a red cablecar arrives but the only student who is left doesn't like red and the cablecar leaves empty.At the moment of time 4 a green cablecar arrives and one student from the g group gets on it. He ascends to top at the moment of time 34.Thus, all the students are on the top, overall the ascension took exactly 34 minutes.","prob_desc_output_spec":"Print a single number \u2014 the minimal time the students need for the whole group to ascend to the top of the mountain.","prob_desc_output_to":"standard output","prob_desc_description":"A group of university students wants to get to the top of a mountain to have a picnic there. For that they decided to use a cableway.A cableway is represented by some cablecars, hanged onto some cable stations by a cable. A cable is scrolled cyclically between the first and the last cable stations (the first of them is located at the bottom of the mountain and the last one is located at the top). As the cable moves, the cablecar attached to it move as well.The number of cablecars is divisible by three and they are painted three colors: red, green and blue, in such manner that after each red cablecar goes a green one, after each green cablecar goes a blue one and after each blue cablecar goes a red one. Each cablecar can transport no more than two people, the cablecars arrive with the periodicity of one minute (i. e. every minute) and it takes exactly 30 minutes for a cablecar to get to the top.All students are divided into three groups: r of them like to ascend only in the red cablecars, g of them prefer only the green ones and b of them prefer only the blue ones. A student never gets on a cablecar painted a color that he doesn't like,The first cablecar to arrive (at the moment of time 0) is painted red. Determine the least time it will take all students to ascend to the mountain top.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['32\\n']}, {'input': '2 2 2', 'output': ['33\\n']}, {'input': '3 3 3', 'output': ['34\\n']}, {'input': '4 4 4', 'output': ['36\\n']}, {'input': '5 5 5', 'output': ['38\\n']}]"}
{"prob_desc_memory_limit":"128 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\", \"4\"]","prob_desc_input_spec":"A single line contains one non-negative integer $$$n$$$ ($$$0 \\le n \\leq 10^{18}$$$)\u00a0\u2014 the number of Shiro's friends. The circular pizza has to be sliced into $$$n + 1$$$ pieces.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nint main()\n{\n    long long int n;\n    scanf(\"%lld\", &n);\n    n = n+1;\n    if(n%2==0||n-1==0)\n    printf(\"%lld\",n\/2);\n    else\n    printf(\"%lld\",n);\n}","prob_desc_sample_outputs":"[\"2\", \"5\"]","lang_cluster":"C","code_uid":"5fa7123cc797685036cebdd8e1fa9e49","prob_desc_notes":"NoteTo cut the round pizza into quarters one has to make two cuts through the center with angle $$$90^{\\circ}$$$ between them.To cut the round pizza into five equal parts one has to make five cuts.","prob_desc_output_spec":"A single integer\u00a0\u2014 the number of straight cuts Shiro needs.","prob_desc_output_to":"standard output","prob_desc_description":"Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.Today is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.She has ordered a very big round pizza, in order to serve her many friends. Exactly $$$n$$$ of Shiro's friends are here. That's why she has to divide the pizza into $$$n + 1$$$ slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.Shiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.As usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0', 'output': ['0\\n']}, {'input': '1', 'output': ['1\\n']}, {'input': '2', 'output': ['2\\n']}, {'input': '5', 'output': ['6\\n']}, {'input': '10', 'output': ['11\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"7 2\", \"59 9\"]","prob_desc_input_spec":"The input consists of two integers n and k, separated by spaces \u2014 the size of the program in lines and the productivity reduction coefficient, 1\u2009\u2264\u2009n\u2009\u2264\u2009109, 2\u2009\u2264\u2009k\u2009\u2264\u200910.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\ntypedef long long int L;\nint k;\nL i,s,n;\nint check(L m)\n{\n    s=0;\n    for(i=m;i>0;i=i\/k)\n    {\n        s=s+i;\n        if(s>=n) return 1;\n    }\n    return 0;\n}\nint main()\n{\n    L low=1,high,mid;\n    scanf(\"%I64d%d\",&n,&k);\n    high=n;\n    while(low<high)\n    {\n        mid=(low+high)\/2;\n        if(check(mid))\n        high=mid;\n        else\n        low=mid+1;\n    }\n    printf(\"%I64d\\n\",high);\n    return 0;\n}","prob_desc_sample_outputs":"[\"4\", \"54\"]","lang_cluster":"C","code_uid":"c1091ef2cae42e6f8105ae9b809d9a2d","prob_desc_notes":"NoteIn the first sample the answer is v\u2009=\u20094. Vasya writes the code in the following portions: first 4 lines, then 2, then 1, and then Vasya falls asleep. Thus, he manages to write 4\u2009+\u20092\u2009+\u20091\u2009=\u20097 lines in a night and complete the task.In the second sample the answer is v\u2009=\u200954. Vasya writes the code in the following portions: 54, 6. The total sum is 54\u2009+\u20096\u2009=\u200960, that's even more than n\u2009=\u200959.","prob_desc_output_spec":"Print the only integer \u2014 the minimum value of v that lets Vasya write the program in one night.","prob_desc_output_to":"standard output","prob_desc_description":"One day a highly important task was commissioned to Vasya \u2014 writing a program in a night. The program consists of n lines of code. Vasya is already exhausted, so he works like that: first he writes v lines of code, drinks a cup of tea, then he writes as much as  lines, drinks another cup of tea, then he writes  lines and so on: , , , ...The expression  is regarded as the integral part from dividing number a by number b.The moment the current value  equals 0, Vasya immediately falls asleep and he wakes up only in the morning, when the program should already be finished.Vasya is wondering, what minimum allowable value v can take to let him write not less than n lines of code before he falls asleep.","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 2', 'output': ['7']}, {'input': '100 3', 'output': ['81']}, {'input': '500 5', 'output': ['455']}, {'input': '1000 4', 'output': ['820']}, {'input': '2000 6', 'output': ['1860']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 2 1 4 10\", \"5 2 1 4 5\"]","prob_desc_input_spec":"The first line contains 5 positive integers d,\u2009k,\u2009a,\u2009b,\u2009t (1\u2009\u2264\u2009d\u2009\u2264\u20091012; 1\u2009\u2264\u2009k,\u2009a,\u2009b,\u2009t\u2009\u2264\u2009106; a\u2009&lt;\u2009b), where:   d \u2014 the distance from home to the post office;  k \u2014 the distance, which car is able to drive before breaking;  a \u2014 the time, which Vasiliy spends to drive 1 kilometer on his car;  b \u2014 the time, which Vasiliy spends to walk 1 kilometer on foot;  t \u2014 the time, which Vasiliy spends to repair his car. ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint main() {\n\tlong long d, ans, k, a, b, t;\n\n\tscanf(\"%lld%lld%lld%lld%lld\", &d, &k, &a, &b, &t);\n\tif (d < k)\n\t\tans = d * a;\n\telse {\n\t\tans = k * a + (d - k) * b;\n\t\tif (ans > (d \/ k) * (k * a + t) - t + (d % k) * b)\n\t\t\tans = (d \/ k) * (k * a + t) - t + (d % k) * b;\n\t\tif (ans > (d \/ k) * (k * a + t) + (d % k) * a)\n\t\t\tans = (d \/ k) * (k * a + t) + (d % k) * a;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"14\", \"13\"]","lang_cluster":"C","code_uid":"04c6f7f8700e478cd90abadb50d5f87b","prob_desc_notes":"NoteIn the first example Vasiliy needs to drive the first 2 kilometers on the car (in 2 seconds) and then to walk on foot 3 kilometers (in 12 seconds). So the answer equals to 14 seconds.In the second example Vasiliy needs to drive the first 2 kilometers on the car (in 2 seconds), then repair his car (in 5 seconds) and drive 2 kilometers more on the car (in 2 seconds). After that he needs to walk on foot 1 kilometer (in 4 seconds). So the answer equals to 13 seconds.","prob_desc_output_spec":"Print the minimal time after which Vasiliy will be able to reach the post office.","prob_desc_output_to":"standard output","prob_desc_description":"Vasiliy has a car and he wants to get from home to the post office. The distance which he needs to pass equals to d kilometers.Vasiliy's car is not new \u2014 it breaks after driven every k kilometers and Vasiliy needs t seconds to repair it. After repairing his car Vasiliy can drive again (but after k kilometers it will break again, and so on). In the beginning of the trip the car is just from repair station.To drive one kilometer on car Vasiliy spends a seconds, to walk one kilometer on foot he needs b seconds (a\u2009&lt;\u2009b).Your task is to find minimal time after which Vasiliy will be able to reach the post office. Consider that in every moment of time Vasiliy can left his car and start to go on foot.","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3 2 5 7', 'output': ['29\\n']}, {'input': '15 5 1 3 10', 'output': ['25\\n']}, {'input': '20 4 2 6 8', 'output': ['52\\n']}, {'input': '25 6 3 7 9', 'output': ['75\\n']}, {'input': '30 7 1 4 11', 'output': ['37\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 3 2\\nto head\\n0001001\", \"3 2 1\\nto tail\\n0001\"]","prob_desc_input_spec":"The first line contains three integers n, m and k. They represent the number of wagons in the train, the stowaway's and the controller's initial positions correspondingly (2\u2009\u2264\u2009n\u2009\u2264\u200950, 1\u2009\u2264\u2009m,\u2009k\u2009\u2264\u2009n, m\u2009\u2260\u2009k). The second line contains the direction in which a controller moves. \"to head\" means that the controller moves to the train's head and \"to tail\" means that the controller moves to its tail. It is guaranteed that in the direction in which the controller is moving, there is at least one wagon. Wagon 1 is the head, and wagon n is the tail. The third line has the length from 1 to 200 and consists of symbols \"0\" and \"1\". The i-th symbol contains information about the train's state at the i-th minute of time. \"0\" means that in this very minute the train moves and \"1\" means that the train in this very minute stands idle. The last symbol of the third line is always \"1\" \u2014 that's the terminal train station.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nint main() {\n\tint n,m,k;\n\tint i;\n\tchar a[3],b[5];\n\tchar c[201];\n\tchar *p;\n\t\/\/ 1->     -1<-\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tscanf(\"%s %s\",a,b);\n\tscanf(\"%s\", c);\n\n\tif(b[0] == 'h')\n\t\td = -1;\n\telse\n\t\td = 1;\n\n\tfor(p=c,i=1; *p!='\\0'; p++,i++) {\n\t\tif(*p=='0') {\n\t\t\t\/\/ move stowaway\n\t\t\tif(d == 1 && m-k==1 && m!=n){\n\t\t\t\tm += 1;\n\t\t\t}else if(d == -1 && k-m==1 && m!=1){\n\t\t\t\tm -= 1;\n\t\t\t}\n\t\t\t\/\/ move controller\n\t\t\tk += d;\n\t\t\tif(k == 1)\n\t\t\t\td = 1;\n\t\t\tif(k == n)\n\t\t\t\td = -1;\n\t\t} else {\n\t\t\t\/\/ move controller\n\t\t\tk += d;\n\t\t\tif(k == 1)\n\t\t\t\td = 1;\n\t\t\tif(k == n)\n\t\t\t\td = -1;\n\t\t\t\/\/ move stowaway\n\t\t\tif(d == 1) {\n\t\t\t\tif(n==2)\n\t\t\t\t\tm = 2;\n\t\t\t\telse if(k==1)\n\t\t\t\t\tm = k+2;\n\t\t\t\telse\n\t\t\t\t\tm = k-1;\n\t\t\t}else{\n\t\t\t\tif(n==2)\n\t\t\t\t\tm = 1;\n\t\t\t\telse if(k!=n)\n\t\t\t\t\tm = k+1;\n\t\t\t\telse\n\t\t\t\t\tm = k-2;\n\t\t\t}\n\t\t}\n\n\t\tif(k == m){\n\t\t\tprintf(\"Controller %d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprintf(\"Stowaway\\n\");\n\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"Stowaway\", \"Controller 2\"]","lang_cluster":"C","code_uid":"d6624135180134ad303c18a992bf8632","prob_desc_notes":null,"prob_desc_output_spec":"If the stowaway wins, print \"Stowaway\" without quotes. Otherwise, print \"Controller\" again without quotes, then, separated by a space, print the number of a minute, at which the stowaway will be caught.","prob_desc_output_to":"standard output","prob_desc_description":"A stowaway and a controller play the following game. The train is represented by n wagons which are numbered with positive integers from 1 to n from the head to the tail. The stowaway and the controller are initially in some two different wagons. Every minute the train can be in one of two conditions \u2014 moving or idle. Every minute the players move.The controller's move is as follows. The controller has the movement direction \u2014 to the train's head or to its tail. During a move the controller moves to the neighbouring wagon correspondingly to its movement direction. If at the end of his move the controller enters the 1-st or the n-th wagon, that he changes the direction of his movement into the other one. In other words, the controller cyclically goes from the train's head to its tail and back again during all the time of a game, shifting during each move by one wagon. Note, that the controller always have exactly one possible move.The stowaway's move depends from the state of the train. If the train is moving, then the stowaway can shift to one of neighbouring wagons or he can stay where he is without moving. If the train is at a station and is idle, then the stowaway leaves the train (i.e. he is now not present in any train wagon) and then, if it is not the terminal train station, he enters the train again into any of n wagons (not necessarily into the one he's just left and not necessarily into the neighbouring one). If the train is idle for several minutes then each such minute the stowaway leaves the train and enters it back.Let's determine the order of the players' moves. If at the given minute the train is moving, then first the stowaway moves and then the controller does. If at this minute the train is idle, then first the stowaway leaves the train, then the controller moves and then the stowaway enters the train.If at some point in time the stowaway and the controller happen to be in one wagon, then the controller wins: he makes the stowaway pay fine. If after a while the stowaway reaches the terminal train station, then the stowaway wins: he simply leaves the station during his move and never returns there again.At any moment of time the players know each other's positions. The players play in the optimal way. Specifically, if the controller wins, then the stowaway plays so as to lose as late as possible. As all the possible moves for the controller are determined uniquely, then he is considered to play optimally always. Determine the winner.","length":67,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3 2\\nto head\\n0001001', 'output': ['Stowaway\\n']}, {'input': '3 2 1\\nto tail\\n0001', 'output': ['Controller 2\\n']}, {'input': '4 2 3\\nto head\\n00101', 'output': ['Controller 3\\n']}, {'input': '6 4 1\\nto tail\\n000001', 'output': ['Stowaway\\n']}, {'input': '7 5 2\\nto head\\n0000001', 'output': ['Stowaway\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 1 1\", \"1 2 2\", \"1 3 5\", \"6 2 9\"]","prob_desc_input_spec":"The first and only line of input contains three space-separated integers a, b and c (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20095\u2009000)\u00a0\u2014 the number of islands in the red, blue and purple clusters, respectively.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nlong long dp[5001][5001],a,b,c;\nint main()\n{\n    scanf(\"%I64d%I64d%I64d\",&a,&b,&c);\n    for(int i=0;i<=5000;i++) dp[i][0]=dp[0][i]=1;\n    for(int i=1;i<=5000;i++)\n        for(int j=1;j<=5000;j++)\n            dp[i][j]=(dp[i-1][j]+(dp[i-1][j-1]*j)%998244353)%998244353;\n    printf(\"%I64d\\n\",(dp[a][b]*dp[a][c])%998244353*dp[b][c]%998244353);\n}","prob_desc_sample_outputs":"[\"8\", \"63\", \"3264\", \"813023575\"]","lang_cluster":"C","code_uid":"c20040376abb2e8db4408162e0577ada","prob_desc_notes":"NoteIn the first example, there are 3 bridges that can possibly be built, and no setup of bridges violates the restrictions. Thus the answer is 23\u2009=\u20098.In the second example, the upper two structures in the figure below are instances of valid ones, while the lower two are invalid due to the blue and purple clusters, respectively.  ","prob_desc_output_spec":"Output one line containing an integer\u00a0\u2014 the number of different ways to build bridges, modulo 998\u2009244\u2009353.","prob_desc_output_to":"standard output","prob_desc_description":"\u2014 This is not playing but duty as allies of justice, Nii-chan!\u2014 Not allies but justice itself, Onii-chan!With hands joined, go everywhere at a speed faster than our thoughts! This time, the Fire Sisters\u00a0\u2014 Karen and Tsukihi\u00a0\u2014 is heading for somewhere they've never reached\u00a0\u2014 water-surrounded islands!There are three clusters of islands, conveniently coloured red, blue and purple. The clusters consist of a, b and c distinct islands respectively.Bridges have been built between some (possibly all or none) of the islands. A bridge bidirectionally connects two different islands and has length 1. For any two islands of the same colour, either they shouldn't be reached from each other through bridges, or the shortest distance between them is at least 3, apparently in order to prevent oddities from spreading quickly inside a cluster.The Fire Sisters are ready for the unknown, but they'd also like to test your courage. And you're here to figure out the number of different ways to build all bridges under the constraints, and give the answer modulo 998\u2009244\u2009353. Two ways are considered different if a pair of islands exist, such that there's a bridge between them in one of them, but not in the other.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['8\\n']}, {'input': '2 2 2', 'output': ['729\\n']}, {'input': '3 3 3', 'output': ['531441\\n']}, {'input': '4 4 4', 'output': ['43046721\\n']}, {'input': '5 5 5', 'output': ['847288609443\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"a1\\nb2\", \"a8\\nd4\"]","prob_desc_input_spec":"The first input line contains the description of the rook's position on the board. This description is a line which is 2 in length. Its first symbol is a lower-case Latin letter from a to h, and its second symbol is a number from 1 to 8. The second line contains the description of the knight's position in a similar way. It is guaranteed that their positions do not coincide.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint board[191][119];\nint main(){\n    int a,b,c,d,e;\n    char input[50];\n    char input1[50];\n    int i; int cnt=0;\n    scanf(\"%s%s\",input,input1);\n    board[input[0]-'a'][(input[1]-'0')-1]=1;\n    board[input1[0]-'a'][(input1[1]-'0')-1]=1;\n    int rook=input[0]-'a';  int rook1=(input[1]-'0')-1;\n    for(i=0;i<8;i++){\n            for(a=0;a<8;a++){\n            if(board[i][a] != 1 && board[i+2][a+1] != 1 && board[i+2][a-1] != 1 && board[i-2][a+1] != 1 && board[i-2][a-1] != 1 && board[i-1][a+2] != 1 && board[i+1][a+2] != 1 && board[i-1][a-2] != 1 && board[i+1][a-2] != 1 && i!=rook && a!=rook1){\n                cnt++;\n                board[i][a]=2;\n            }\n            }\n    }\n    printf(\"%d\",cnt);\n}\n\n","prob_desc_sample_outputs":"[\"44\", \"38\"]","lang_cluster":"C","code_uid":"5d532a8095a92d553b6121c03f482bef","prob_desc_notes":null,"prob_desc_output_spec":"Print a single number which is the required number of ways.","prob_desc_output_to":"standard output","prob_desc_description":"Two chess pieces, a rook and a knight, stand on a standard chessboard 8\u2009\u00d7\u20098 in size. The positions in which they are situated are known. It is guaranteed that none of them beats the other one.Your task is to find the number of ways to place another knight on the board so that none of the three pieces on the board beat another one. A new piece can only be placed on an empty square.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'a1\\nc3', 'output': ['42']}, {'input': 'h8\\ng6', 'output': ['42']}, {'input': 'd4\\ne6', 'output': ['36']}, {'input': 'b2\\nd5', 'output': ['38']}, {'input': 'h1\\ng3', 'output': ['42']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 1\", \"3 1 4\"]","prob_desc_input_spec":"The first line will contain three integers integer k,\u2009pa,\u2009pb (1\u2009\u2264\u2009k\u2009\u2264\u20091\u2009000, 1\u2009\u2264\u2009pa,\u2009pb\u2009\u2264\u20091\u2009000\u2009000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#define MOD 1000000007\n\nint K;\nlong long PA,PB,ans;\n\nlong long INV1,INV2;\nlong long f[1010][2010];\n\nlong long power(long long a,int b)\n{\n    long long y = 1;\n    for(;b;b>>=1)\n    {\n        if(b&1) y = y * a % MOD;\n        a = a * a % MOD;\n    }\n    return y;\n}\n\nint main()\n{\n    int i,j;\n    long long x,y;\n\n    scanf(\"%d%I64d%I64d\",&K,&PA,&PB);\n    INV1 = power(PA+PB,MOD-2);\n    INV2 = power(PB,MOD-2);\n\n    f[1][0] = 1;\n    for(i=1;i<=K;i++) for(j=(i==1);j<=2*K;j++)\n    {\n        if(j < K) f[i][j] = f[i-1][j] * PA % MOD * INV1 % MOD;\n        if(j >= i && j-i < K) f[i][j] = (f[i][j] + f[i][j-i] * PB % MOD * INV1) % MOD;\n    }\n\n    for(i=1;i<K;i++) for(j=K;j<=2*K;j++) ans = (ans + j*f[i][j]) % MOD;\n    for(i=0;i<K;i++) ans = (ans + (PA*INV2 + K+i) % MOD * f[K][i]) % MOD;\n\n    printf(\"%I64d\\n\",ans);\n    return 0;\n}","prob_desc_sample_outputs":"[\"2\", \"370000006\"]","lang_cluster":"C","code_uid":"3584f016d2305e91086d15839c9b3c30","prob_desc_notes":"NoteThe first sample, we will keep appending to our sequence until we get the subsequence 'ab' at least once. For instance, we get the sequence 'ab' with probability 1\/4, 'bbab' with probability 1\/16, and 'aab' with probability 1\/8. Note, it's impossible for us to end with a sequence like 'aabab', since we would have stopped our algorithm once we had the prefix 'aab'. The expected amount of times that 'ab' will occur across all valid sequences is 2. For the second sample, the answer is equal to .","prob_desc_output_spec":"Print a single integer, the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"You are given three integers k, pa and pb.You will construct a sequence with the following algorithm: Initially, start with the empty sequence. Each second, you do the following. With probability pa\u2009\/\u2009(pa\u2009+\u2009pb), add 'a' to the end of the sequence. Otherwise (with probability pb\u2009\/\u2009(pa\u2009+\u2009pb)), add 'b' to the end of the sequence.You stop once there are at least k subsequences that form 'ab'. Determine the expected number of times 'ab' is a subsequence in the resulting sequence. It can be shown that this can be represented by P\u2009\/\u2009Q, where P and Q are coprime integers, and . Print the value of .","length":42,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['2\\n']}, {'input': '3 1 4', 'output': ['370000006\\n']}, {'input': '2 2 2', 'output': ['8\\n']}, {'input': '5 3 7', 'output': ['370000006\\n']}, {'input': '4 4 4', 'output': ['32\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"10\", \"4\", \"3\"]","prob_desc_input_spec":"The first and only line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106) which represents the denomination of the most expensive coin. ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint main()\n{\n\tint i = 2, num;\n\t\n\tscanf(\"%d\", &num);\n\tprintf(\"%d \", num);\n\t\n\twhile(num > 1){\n\t\tfor(i = 2; i < num && num % i != 0; i++){}\n\t\tnum \/= i;\n\t\tprintf(\"%d \", num);\n\t}\n\t\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"10 5 1\", \"4 2 1\", \"3 1\"]","lang_cluster":"C","code_uid":"5f6435b64f9a140c0c3db8739709d749","prob_desc_notes":null,"prob_desc_output_spec":"Print the denominations of all the coins in the order of decreasing. The number of coins must be the largest possible (with the given denomination n of the most expensive coin). Also, the denomination of every coin must be divisible by the denomination of any cheaper coin. Naturally, the denominations of all the coins should be different. If there are several solutins to that problem, print any of them.","prob_desc_output_to":"standard output","prob_desc_description":"In Berland a money reform is being prepared. New coins are being introduced. After long economic calculations was decided that the most expensive coin should possess the denomination of exactly n Berland dollars. Also the following restriction has been introduced for comfort: the denomination of each coin should be divisible by the denomination of any cheaper coin. It is known that among all the possible variants the variant with the largest number of new coins will be chosen. Find this variant. Print in the order of decreasing of the coins' denominations.","length":17,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '15\\n', 'output': ['15 5 1 ']}, {'input': '20\\n', 'output': ['20 10 5 1 ']}, {'input': '30\\n', 'output': ['30 15 5 1 ']}, {'input': '50\\n', 'output': ['50 25 5 1 ']}, {'input': '100\\n', 'output': ['100 50 25 5 1 ']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"7 1 4\", \"30 20 10\"]","prob_desc_input_spec":"The first line of the input contains three distinct integers x1, x2 and x3 (1\u2009\u2264\u2009x1,\u2009x2,\u2009x3\u2009\u2264\u2009100)\u00a0\u2014 the coordinates of the houses of the first, the second and the third friends respectively. ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <stdlib.h>\nint main(){\n    int a[3];\n    int b;\n    scanf(\"%d%d%d\", &a[0], &a[1], &a[2]);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j ++)\n        if (a[i] < a[j])\n        {\n            b = a[i];\n            a[i] = a[j];\n            a[j] = b;\n        }\n\n    printf(\"%d\", a[2] - a[0]);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"6\", \"20\"]","lang_cluster":"C","code_uid":"0214dfd1f5c4cef9303b257f205027b8","prob_desc_notes":"NoteIn the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.","prob_desc_output_spec":"Print one integer\u00a0\u2014 the minimum total distance the friends need to travel in order to meet together.","prob_desc_output_to":"standard output","prob_desc_description":"There are three friend living on the straight line Ox in Lineland. The first friend lives at the point x1, the second friend lives at the point x2, and the third friend lives at the point x3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?It's guaranteed that the optimal answer is always integer.","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 10 15', 'output': ['10\\n']}, {'input': '1 50 100', 'output': ['99\\n']}, {'input': '33 66 99', 'output': ['66\\n']}, {'input': '2 4 6', 'output': ['4\\n']}, {'input': '10 20 30', 'output': ['20\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"... ... ...\\n... ... ...\\n... ... ...\\n\\n... ... ...\\n... ... ...\\n... x.. ...\\n\\n... ... ...\\n... ... ...\\n... ... ...\\n6 4\", \"xoo x.. x..\\nooo ... ...\\nooo ... ...\\n\\nx.. x.. x..\\n... ... ...\\n... ... ...\\n\\nx.. x.. x..\\n... ... ...\\n... ... ...\\n7 4\", \"o.. ... ...\\n... ... ...\\n... ... ...\\n\\n... xxx ...\\n... xox ...\\n... ooo ...\\n\\n... ... ...\\n... ... ...\\n... ... ...\\n5 5\"]","prob_desc_input_spec":"First 11 lines contains descriptions of table with 9 rows and 9 columns which are divided into 9 small fields by spaces and empty lines. Each small field is described by 9 characters without spaces and empty lines. character \"x\" (ASCII-code 120) means that the cell is occupied with chip of the first player, character \"o\" (ASCII-code 111) denotes a field occupied with chip of the second player, character \".\" (ASCII-code 46) describes empty cell. The line after the table contains two integers x and y (1\u2009\u2264\u2009x,\u2009y\u2009\u2264\u20099). They describe coordinates of the cell in table where the last move was done. Rows in the table are numbered from up to down and columns are numbered from left to right. It's guaranteed that cell where the last move was done is filled with \"x\" or \"o\". Also, it's guaranteed that there is at least one empty cell. It's not guaranteed that current state of game is reachable.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#define eps 1e-4\n#define PI acos(-1.0)\nchar s[10][15];\nint sti[4]={0,1,4,7},eni[4]={0,3,6,9};\nint stj[4]={0,0,4,8},enj[4]={0,2,6,10};\nvoid printall2()\n{\n\tfor (int i=1;i<=9;i++)\n\t{\n\t\tfor (int j=0;j<=10;j++)\n\t\t\tif (s[i][j]=='.') printf(\"!\");\n\t\t\telse printf(\"%c\",s[i][j]);\n\t\tprintf(\"\\n\");\n\t\tif (!(i%3)) printf(\"\\n\");\n\t}\n}\nvoid printall1()\n{\n\tfor (int i=1;i<=9;i++)\n\t{\n\t\tfor (int j=0;j<=10;j++)\n\t\t\tprintf(\"%c\",s[i][j]);\n\t\tprintf(\"\\n\");\n\t\tif (!(i%3)&&i!=9) printf(\"\\n\");\n\t}\n}\nint main()\n{\n\tfor (int i=1;i<=3;i++) gets(s[i]);\n\tgets(s[0]);\n\tfor (int i=4;i<=6;i++) gets(s[i]);\n\tgets(s[0]);\n\tfor (int i=7;i<=9;i++) gets(s[i]);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tn%=3; m%=3; \n\tif (!n) n=3;\n\tif (!m) m=3;\n\tint flag=0;\n\tfor (int i=sti[n];i<=eni[n];i++)\n\t\tfor (int j=stj[m];j<=enj[m];j++)\n\t\t\tif (s[i][j]=='.')\n\t\t\t{\n\t\t\t\tflag++;\n\t\t\t\ts[i][j]='!';\n\t\t\t}\n\tif (flag) printall1();\n\telse printall2();\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"... ... ... \\n... ... ... \\n... ... ... \\n\\n... ... ... \\n... ... ... \\n... x.. ... \\n\\n!!! ... ... \\n!!! ... ... \\n!!! ... ...\", \"xoo x!! x!! \\nooo !!! !!! \\nooo !!! !!! \\n\\nx!! x!! x!! \\n!!! !!! !!! \\n!!! !!! !!! \\n\\nx!! x!! x!! \\n!!! !!! !!! \\n!!! !!! !!!\", \"o!! !!! !!! \\n!!! !!! !!! \\n!!! !!! !!! \\n\\n!!! xxx !!! \\n!!! xox !!! \\n!!! ooo !!! \\n\\n!!! !!! !!! \\n!!! !!! !!! \\n!!! !!! !!!\"]","lang_cluster":"C","code_uid":"60963d7db9b16b782869efad9cbe0603","prob_desc_notes":"NoteIn the first test case the first player made a move to lower left cell of central field, so the second player can put a chip only to cells of lower left field.In the second test case the last move was done to upper left cell of lower central field, however all cells in upper left field are occupied, so the second player can put his chip to any empty cell.In the third test case the last move was done to central cell of central field, so current player can put his chip to any cell of central field, which is already occupied, so he can move anywhere. Pay attention that this state of the game is unreachable.","prob_desc_output_spec":"Output the field in same format with characters \"!\" (ASCII-code 33) on positions where the current player can put his chip. All other cells should not be modified.","prob_desc_output_to":"standard output","prob_desc_description":"Two bears are playing tic-tac-toe via mail. It's boring for them to play usual tic-tac-toe game, so they are a playing modified version of this game. Here are its rules.The game is played on the following field.  Players are making moves by turns. At first move a player can put his chip in any cell of any small field. For following moves, there are some restrictions: if during last move the opposite player put his chip to cell with coordinates (xl,\u2009yl) in some small field, the next move should be done in one of the cells of the small field with coordinates (xl,\u2009yl). For example, if in the first move a player puts his chip to lower left cell of central field, then the second player on his next move should put his chip into some cell of lower left field (pay attention to the first test case). If there are no free cells in the required field, the player can put his chip to any empty cell on any field.You are given current state of the game and coordinates of cell in which the last move was done. You should find all cells in which the current player can put his chip.A hare works as a postman in the forest, he likes to foul bears. Sometimes he changes the game field a bit, so the current state of the game could be unreachable. However, after his changes the cell where the last move was done is not empty. You don't need to find if the state is unreachable or not, just output possible next moves according to the rules.","length":54,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '... ... ...\\n... ... ...\\n... ... ...\\n\\n... ... ...\\n... ... ...\\n... x.. ...\\n\\n... ... ...\\n... ... ...\\n... ... ...\\n6 4', 'output': ['... ... ... \\n... ... ... \\n... ... ... \\n\\n... ... ... \\n... ... ... \\n... x.. ... \\n\\n!!! ... ... \\n!!! ... ... \\n!!! ... ...']}, {'input': 'xoo x.. x..\\nooo ... ...\\nooo ... ...\\n\\nx.. x.. x..\\n... ... ...\\n... ... ...\\n\\nx.. x.. x..\\n... ... ...\\n... ... ...\\n7 4', 'output': ['xoo x!! x!! \\nooo !!! !!! \\nooo !!! !!! \\n\\nx!! x!! x!! \\n!!! !!! !!! \\n!!! !!! !!! \\n\\nx!! x!! x!! \\n!!! !!! !!! \\n!!! !!! !!!']}, {'input': 'o.. ... ...\\n... ... ...\\n... ... ...\\n\\n... xxx ...\\n... xox ...\\n... ooo ...\\n\\n... ... ...\\n... ... ...\\n... ... ...\\n5 5', 'output': ['o!! !!! !!! \\n!!! !!! !!! \\n!!! !!! !!! \\n\\n!!! xxx !!! \\n!!! xox !!! \\n!!! ooo !!! \\n\\n!!! !!! !!! \\n!!! !!! !!! \\n!!! !!! !!!']}, {'input': '... ... ...\\n... ... ...\\n... ... ...\\n\\n... ... ...\\n... x.. ...\\n... ... ...\\n\\n... ... ...\\n... ... ...\\n... ... ...\\n6 5', 'output': ['... ... ... \\n... ... ... \\n... ... ... \\n\\n... ... ... \\n... x.. ... \\n... ... ... \\n\\n... !!! ... \\n... !!! ... \\n... !!! ...']}, {'input': 'x.. ... ...\\n... ... ...\\n... ... ...\\n\\n... ... ...\\n... ... ...\\n... ... ...\\n\\n... ... ...\\n... ... ...\\n... ... ...\\n1 1', 'output': ['x!! ... ... \\n!!! ... ... \\n!!! ... ... \\n\\n... ... ... \\n... ... ... \\n... ... ... \\n\\n... ... ... \\n... ... ... \\n... ... ...']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\nxxxiii\", \"5\\nxxoxx\", \"10\\nxxxxxxxxxx\"]","prob_desc_input_spec":"The first line contains integer $$$n$$$ $$$(3 \\le n \\le 100)$$$ \u2014 the length of the file name. The second line contains a string of length $$$n$$$ consisting of lowercase Latin letters only \u2014 the file name.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    char str[100];\n    int i, count = 0, n;\n    scanf(\"%d\", &n);\n    scanf(\"%s\", str);\n    for(i = 0; i < n; i++)\n    {\n        if(str[i] == 'x' && str[i+1] == 'x' && str[i+2] == 'x')\n            count++;\n    }\n    printf(\"%d\", count);\n}\n","prob_desc_sample_outputs":"[\"1\", \"0\", \"8\"]","lang_cluster":"C","code_uid":"9a271369b5ff091a0774831dd472b695","prob_desc_notes":"NoteIn the first example Polycarp tried to send a file with name contains number $$$33$$$, written in Roman numerals. But he can not just send the file, because it name contains three letters \"x\" in a row. To send the file he needs to remove any one of this letters.","prob_desc_output_spec":"Print the minimum number of characters to remove from the file name so after that the name does not contain \"xxx\" as a substring. If initially the file name dost not contain a forbidden substring \"xxx\", print 0.","prob_desc_output_to":"standard output","prob_desc_description":"You can not just take the file and send it. When Polycarp trying to send a file in the social network \"Codehorses\", he encountered an unexpected problem. If the name of the file contains three or more \"x\" (lowercase Latin letters \"x\") in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed.Determine the minimum number of characters to remove from the file name so after that the name does not contain \"xxx\" as a substring. Print 0 if the file name does not initially contain a forbidden substring \"xxx\".You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by $$$1$$$. For example, if you delete the character in the position $$$2$$$ from the string \"exxxii\", then the resulting string is \"exxii\".","length":14,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '6\\nxxaxxx', 'output': ['1']}, {'input': '7\\nxxxxxxx', 'output': ['5']}, {'input': '8\\nxxaxxaxx', 'output': ['0']}, {'input': '9\\nxxaxxxaxx', 'output': ['1']}, {'input': '10\\nxxaxxxaxxx', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 50\\n50\", \"3 100\\n50 50 100\", \"2 50\\n50 50\"]","prob_desc_input_spec":"The first line contains two integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u200950,\u20091\u2009\u2264\u2009k\u2009\u2264\u20095000) \u2014 the number of people, including Greg, and the boat's weight limit. The next line contains n integers \u2014 the people's weights. A person's weight is either 50 kilos or 100 kilos. You can consider Greg and his friends indexed in some way.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\n#define mod 1000000007\nlong long dp[55][55][205]={};\nlong long c[55][55]={};\nint n,lim,A=0,B=0,i,j,k,ii,jj;\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a<b?b:a;}\nint main(){\n\tscanf(\"%d %d\",&n,&lim);\n\tfor(i=0;i<n;i++){\n\t\tint fk; scanf(\"%d\",&fk);\n\t\tif(fk==50) A++;\n\t\telse B++;\n\t}\n\tdp[A][B][0]=1;\n\tc[0][0]=1;\n\tfor(i=1;i<=50;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tc[i][j]=c[i-1][j-1]+c[i-1][j];\n\t\t}\n\t}\n\tfor(k=1;k<=4*n;k++){\n\t\tfor(i=A;i>=0;i--){\n\t\t\tfor(j=B;j>=0;j--){\n\t\t\t\tint s=k%2;\n\t\t\t\tdp[i][j][k]=0;\n\t\t\t\tif(s){\n\t\t\t\t\tfor(ii=i;ii<=A;ii++){\n\t\t\t\t\t\tint f=lim-(ii-i)*50;\n\t\t\t\t\t\tif(f>=0){\n\t\t\t\t\t\t\tf\/=100;\n\t\t\t\t\t\t\tf+=j; f=min(f,B);\n\t\t\t\t\t\t\tfor(jj=j;jj<=f;jj++){\n\t\t\t\t\t\t\t\tif((i!=ii || j!=jj)){\n\t\t\t\t\t\t\t\t\tdp[i][j][k]+=(dp[ii][jj][k-1]*c[ii][ii-i]*c[jj][jj-j])%mod;\n\t\t\t\t\t\t\t\t\tdp[i][j][k]%=mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(ii=0;ii<=i;ii++){\n\t\t\t\t\t\tint f=lim-(i-ii)*50;\n\t\t\t\t\t\tif(f>=0){\n\t\t\t\t\t\t\tf\/=100; f=max(j-f,0);\n\t\t\t\t\t\t\tfor(jj=f;jj<=j;jj++){\n\t\t\t\t\t\t\t\tif((i!=ii || j!=jj)){\n\t\t\t\t\t\t\t\t\tdp[i][j][k]+=(dp[ii][jj][k-1]*c[A-ii][i-ii]*c[B-jj][j-jj])%mod;\n\t\t\t\t\t\t\t\t\tdp[i][j][k]%=mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp[0][0][k]){\n\t\t\t\t\tprintf(\"%d\\n\",k);\n\t\t\t\t\tprintf(\"%lld\\n\",dp[0][0][k]);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\\n0\");\n}\n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                \n\/\/                                                                                ","prob_desc_sample_outputs":"[\"1\\n1\", \"5\\n2\", \"-1\\n0\"]","lang_cluster":"C","code_uid":"15725813c7099eaa9e96d5898472bb70","prob_desc_notes":"NoteIn the first test Greg walks alone and consequently, he needs only one ride across the river.In the second test you should follow the plan:  transport two 50 kg. people;  transport one 50 kg. person back;  transport one 100 kg. person;  transport one 50 kg. person back;  transport two 50 kg. people. That totals to 5 rides. Depending on which person to choose at step 2, we can get two distinct ways.","prob_desc_output_spec":"In the first line print an integer \u2014 the minimum number of rides. If transporting everyone to the other bank is impossible, print an integer -1. In the second line print the remainder after dividing the number of ways to transport the people in the minimum number of rides by number 1000000007 (109\u2009+\u20097). If transporting everyone to the other bank is impossible, print integer 0.","prob_desc_output_to":"standard output","prob_desc_description":"One day Greg and his friends were walking in the forest. Overall there were n people walking, including Greg. Soon he found himself in front of a river. The guys immediately decided to get across the river. Luckily, there was a boat by the river bank, just where the guys were standing. We know that the boat can hold people with the total weight of at most k kilograms.Greg immediately took a piece of paper and listed there the weights of all people in his group (including himself). It turned out that each person weights either 50 or 100 kilograms. Now Greg wants to know what minimum number of times the boat needs to cross the river to transport the whole group to the other bank. The boat needs at least one person to navigate it from one bank to the other. As the boat crosses the river, it can have any non-zero number of passengers as long as their total weight doesn't exceed k.Also Greg is wondering, how many ways there are to transport everybody to the other side in the minimum number of boat rides. Two ways are considered distinct if during some ride they have distinct sets of people on the boat.Help Greg with this problem. ","length":109,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 250\\n50 50 50 50 50', 'output': ['3\\n10']}, {'input': '4 200\\n100 100 100 100', 'output': ['8\\n1']}, {'input': '3 150\\n50 50 100', 'output': ['3\\n2']}, {'input': '2 100\\n50 100', 'output': ['3\\n1']}, {'input': '1 50\\n50', 'output': ['1\\n1']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"7 3 7 3 20\", \"7 9 3 1 8\", \"10 10 10 10 10\"]","prob_desc_input_spec":"The only line of the input contains five integers t1, t2, t3, t4 and t5 (1\u2009\u2264\u2009ti\u2009\u2264\u2009100)\u00a0\u2014 numbers written on cards.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint minimo(int a, int b);\nint main(){\n    int v[5], i, j, k, total = 0, min;\n    for(i = 0; i < 5; i++){\n        scanf(\"%d\", &v[i]);\n        total = total + v[i];\n    }\n    min = total;\n    for(i = 0; i < 5; i++){\n        for(j = i + 1; j < 5; j++){\n            if(v[i] == v[j]){\n                if(total - 2*v[i] < min)\n                    min = total - 2*v[i];\n            }\n        }\n    }\n    for(i = 0; i < 5; i++){\n        for(j = i + 1; j < 5; j++){\n            for(k = j + 1; k < 5; k++){\n                if(v[i] == v[j] && v[i] == v[k]){\n                    if(total - 3*v[i] < min)\n                    min = total - 3*v[i];\n                }\n            }\n        }\n    }\n    printf(\"%d\", min);\n}\n","prob_desc_sample_outputs":"[\"26\", \"28\", \"20\"]","lang_cluster":"C","code_uid":"a132a8e903fa2134e835418767582c10","prob_desc_notes":"NoteIn the first sample, Limak has cards with numbers 7, 3, 7, 3 and 20. Limak can do one of the following.  Do nothing and the sum would be 7\u2009+\u20093\u2009+\u20097\u2009+\u20093\u2009+\u200920\u2009=\u200940.  Remove two cards with a number 7. The remaining sum would be 3\u2009+\u20093\u2009+\u200920\u2009=\u200926.  Remove two cards with a number 3. The remaining sum would be 7\u2009+\u20097\u2009+\u200920\u2009=\u200934. You are asked to minimize the sum so the answer is 26.In the second sample, it's impossible to find two or three cards with the same number. Hence, Limak does nothing and the sum is 7\u2009+\u20099\u2009+\u20091\u2009+\u20093\u2009+\u20098\u2009=\u200928.In the third sample, all cards have the same number. It's optimal to discard any three cards. The sum of two remaining numbers is 10\u2009+\u200910\u2009=\u200920.","prob_desc_output_spec":"Print the minimum possible sum of numbers written on remaining cards.","prob_desc_output_to":"standard output","prob_desc_description":"A little bear Limak plays a game. He has five cards. There is one number written on each card. Each number is a positive integer.Limak can discard (throw out) some cards. His goal is to minimize the sum of numbers written on remaining (not discarded) cards.He is allowed to at most once discard two or three cards with the same number. Of course, he won't discard cards if it's impossible to choose two or three cards with the same number.Given five numbers written on cards, cay you find the minimum sum of numbers on remaining cards?","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1 1 1', 'output': ['2']}, {'input': '2 2 2 2 2', 'output': ['4']}, {'input': '3 3 3 3 3', 'output': ['6']}, {'input': '4 4 4 4 4', 'output': ['8']}, {'input': '5 5 5 5 5', 'output': ['10']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"0 2 0 4\", \"0 2 1 1\", \"0 2 0 1\"]","prob_desc_input_spec":"The first line contains four space-separated integers \u2014 x1, x2, a and b (x1\u2009\u2260\u2009x2, a\u2009\u2264\u2009b, \u2009-\u2009109\u2009\u2264\u2009x1,\u2009x2,\u2009a,\u2009b\u2009\u2264\u2009109) \u2014 coordinates of the points where the first and the second participant start, and the numbers that determine the players' moves, correspondingly.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint main(){\n  int i,j,k,l,m,n;\n  int x1, x2, a, b, fg, fgg;\n  int mod;\n  int stone;\n\n  while(scanf(\"%d%d%d%d\",&x1,&x2,&a,&b)==4){\n    stone = x2 - x1;\n    fg = 0;\n    if(stone < 0) stone *= -1, k = a, a = b, b = k, a *= -1, b *= -1, fg = 1;\n    if(b <= 0){ puts(\"DRAW\"); continue; }\n\n    fgg = 0;\n    if(a <= 0) fgg = 1, a = 1;\n    mod = stone % (a+b);\n    if(mod == 0){\n      if(fgg) puts(\"DRAW\"); else puts(\"SECOND\");\n      continue;\n    }\n    if(mod < a || mod > b){\n      puts(\"DRAW\");\n      continue;\n    }\n\n    if(stone > b && fgg){\n      puts(\"DRAW\");\n      continue;\n    }\n\n    stone -= mod;\n    puts(\"FIRST\");\n    if(fg==0) printf(\"%d\\n\",x2-stone);\n    else      printf(\"%d\\n\",x2+stone);\n  }\n\n  return 0;\n}\n","prob_desc_sample_outputs":"[\"FIRST\\n2\", \"SECOND\", \"DRAW\"]","lang_cluster":"C","code_uid":"0d6c72f94aa66dcf8b6165c20343aa33","prob_desc_notes":"NoteIn the first sample the first player can win in one move.In the second sample the first participant must go to point 1, where the second participant immediately goes and wins. In the third sample changing the position isn't profitable to either participant, so nobody wins.","prob_desc_output_spec":"On the first line print the outcome of the battle as \"FIRST\" (without the quotes), if both players play optimally and the first player wins. Print \"SECOND\" (without the quotes) if the second player wins and print \"DRAW\" (without the quotes), if nobody is able to secure the victory. If the first player wins, print on the next line the single integer x \u2014 the coordinate of the point where the first player should transfer to win. The indicated move should be valid, that is, it should meet the following condition: x1\u2009+\u2009a\u2009\u2264\u2009x\u2009\u2264\u2009x1\u2009+\u2009b. If there are several winning moves, print any of them. If the first participant can't secure the victory, then you do not have to print anything.","prob_desc_output_to":"standard output","prob_desc_description":"The King of Flatland will organize a knights' tournament! The winner will get half the kingdom and the favor of the princess of legendary beauty and wisdom. The final test of the applicants' courage and strength will be a fencing tournament. The tournament is held by the following rules: the participants fight one on one, the winner (or rather, the survivor) transfers to the next round.Before the battle both participants stand at the specified points on the Ox axis with integer coordinates. Then they make moves in turn. The first participant moves first, naturally. During a move, the first participant can transfer from the point x to any integer point of the interval [x\u2009+\u2009a; x\u2009+\u2009b]. The second participant can transfer during a move to any integer point of the interval [x\u2009-\u2009b; x\u2009-\u2009a]. That is, the options for the players' moves are symmetric (note that the numbers a and b are not required to be positive, and if a\u2009\u2264\u20090\u2009\u2264\u2009b, then staying in one place is a correct move). At any time the participants can be located arbitrarily relative to each other, that is, it is allowed to \"jump\" over the enemy in any direction. A participant wins if he uses his move to transfer to the point where his opponent is.Of course, the princess has already chosen a husband and now she wants to make her sweetheart win the tournament. He has already reached the tournament finals and he is facing the last battle. The princess asks the tournament manager to arrange the tournament finalists in such a way that her sweetheart wins the tournament, considering that both players play optimally. However, the initial location of the participants has already been announced, and we can only pull some strings and determine which participant will be first and which one will be second. But how do we know which participant can secure the victory? Alas, the princess is not learned in the military affairs... Therefore, she asks you to determine how the battle will end considering that both opponents play optimally. Also, if the first player wins, your task is to determine his winning move.","length":44,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 2 0 4', 'output': ['FIRST\\n2\\n']}, {'input': '0 2 1 1', 'output': ['SECOND\\n']}, {'input': '0 2 0 1', 'output': ['DRAW\\n']}, {'input': '5 10 2 3', 'output': ['SECOND\\n']}, {'input': '10 20 -2 -1', 'output': ['DRAW\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 5\", \"3 6\"]","prob_desc_input_spec":"The first line contains two integers a and m (1\u2009\u2264\u2009a,\u2009m\u2009\u2264\u2009105).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nint a,m,k,r;\nint main() {\n\tscanf(\"%d\",&a);\n\tscanf(\"%d\",&m);\n\tr=a%m;\n\twhile(k<20) {\n\t\tif(r%m==0) {\n\t\t\tprintf(\"Yes\\n\");\n\t\t\treturn 0;\n\t\t} \n\t\telse {\n\t\t\tr*=2;\n\t\t\t++k;\n\t\t}\n\t}\n\tprintf(\"No\\n\");\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"No\", \"Yes\"]","lang_cluster":"C","code_uid":"f08248021dd906032752a106b6c9dd95","prob_desc_notes":null,"prob_desc_output_spec":"Print \"Yes\" (without quotes) if the production will eventually stop, otherwise print \"No\".","prob_desc_output_to":"standard output","prob_desc_description":"One industrial factory is reforming working plan. The director suggested to set a mythical detail production norm. If at the beginning of the day there were x details in the factory storage, then by the end of the day the factory has to produce  (remainder after dividing x by m) more details. Unfortunately, no customer has ever bought any mythical detail, so all the details produced stay on the factory. The board of directors are worried that the production by the given plan may eventually stop (that means that there will be \u0430 moment when the current number of details on the factory is divisible by m). Given the number of details a on the first day and number m check if the production stops at some moment.","length":19,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 3', 'output': ['Yes\\n']}, {'input': '4 7', 'output': ['No\\n']}, {'input': '5 10', 'output': ['Yes\\n']}, {'input': '8 15', 'output': ['No\\n']}, {'input': '10 20', 'output': ['Yes\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\", \"1\"]","prob_desc_input_spec":"The input contains the only integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint gcm(int a, int b) \/\/ a<=b\u3067\u3042\u308b\u3053\u3068\uff0e\n{\n    if(a == 0)\n        return b;\n    else\n        return gcm(b%a, a);\n}\n\nint rec(int a, int b) \/\/ a<b\u3067\u3042\u308b\u3053\u3068\uff0e\n{\n    if(a == 1)\n        return b-1;\n    return b\/a + rec(b%a, a);\n}\n\nint main (int argc, const char * argv[]) {\n    int i, a, b, min;\n    scanf(\"%d\", &a);\n    min = a-1;\n    for(i = 2; i <= a\/2; i++){\n        if(gcm(a, i) != 1)\n            continue;\n        if((b = rec(i, a)) < min)\n            min = b;\n    }\n    printf(\"%d\\n\", min);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"3\", \"0\"]","lang_cluster":"C","code_uid":"3c4dba385b37b5ef1b611d3cd8ee1040","prob_desc_notes":"NoteThe pair (1,1) can be transformed into a pair containing 5 in three moves: (1,1) \u2009\u2192\u2009 (1,2) \u2009\u2192\u2009 (3,2) \u2009\u2192\u2009 (5,2).","prob_desc_output_spec":"Print the only integer k.","prob_desc_output_to":"standard output","prob_desc_description":"Let's assume that we have a pair of numbers (a,\u2009b). We can get a new pair (a\u2009+\u2009b,\u2009b) or (a,\u2009a\u2009+\u2009b) from the given pair in a single step.Let the initial pair of numbers be (1,1). Your task is to find number k, that is, the least number of steps needed to transform (1,1) into the pair where at least one number equals n.","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n', 'output': ['1\\n']}, {'input': '3\\n', 'output': ['2\\n']}, {'input': '4\\n', 'output': ['2\\n']}, {'input': '6\\n', 'output': ['3\\n']}, {'input': '10\\n', 'output': ['5\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3 7 6\", \"7 2 4\"]","prob_desc_input_spec":"A single line contains three integers x,\u2009y,\u2009n (1\u2009\u2264\u2009x,\u2009y,\u2009n\u2009\u2264\u2009105).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <math.h>\n#include <float.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main (void) {\n\tint x, y, n, a = 0, b = 1, i, j;\n\tdouble t;\n\tscanf (\"%d %d %d\", &x, &y, &n);\n\tt = (double)x \/ y;\n\tfor (j = 1; j <= n; ++j) {\n\t\tdouble A[] = {floor (t*j), ceil (t*j)};\n\t\tfor (i = 0; (unsigned)i < sizeof A \/ sizeof *A; ++i) {\n\t\t\tif (fabs (t - A[i]\/j) + DBL_EPSILON < fabs (t - (double)a\/b)) {\n\t\t\t\ta = A[i];\n\t\t\t\tb = j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf (\"%d\/%d\\n\", a, b);\n\texit (EXIT_SUCCESS);\n}\n","prob_desc_sample_outputs":"[\"2\/5\", \"7\/2\"]","lang_cluster":"C","code_uid":"1e2ae09489b269898427146ad6e3443b","prob_desc_notes":null,"prob_desc_output_spec":"Print the required fraction in the format \"a\/b\" (without quotes).","prob_desc_output_to":"standard output","prob_desc_description":"You are given three positive integers x,\u2009y,\u2009n. Your task is to find the nearest fraction to fraction  whose denominator is no more than n. Formally, you should find such pair of integers a,\u2009b (1\u2009\u2264\u2009b\u2009\u2264\u2009n;\u00a00\u2009\u2264\u2009a) that the value  is as minimal as possible.If there are multiple \"nearest\" fractions, choose the one with the minimum denominator. If there are multiple \"nearest\" fractions with the minimum denominator, choose the one with the minimum numerator.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 8 7', 'output': ['4\/7\\n']}, {'input': '10 3 5', 'output': ['10\/3\\n']}, {'input': '7 9 4', 'output': ['3\/4\\n']}, {'input': '6 7 3', 'output': ['3\/3\\n']}, {'input': '4 5 2', 'output': ['2\/2\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"13\\n12\", \"16\\n11311\", \"20\\n999\", \"17\\n2016\"]","prob_desc_input_spec":"The first line contains the integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009109). The second line contains the integer k (0\u2009\u2264\u2009k\u2009&lt;\u20091060), it is guaranteed that the number k contains no more than 60 symbols. All digits in the second line are strictly less than n. Alexander guarantees that the answer exists and does not exceed 1018. The number k doesn't contain leading zeros.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <string.h>\n\n#define INF\t((long long) 1e18)\n\nint main() {\n\tstatic char s[128];\n\tstatic long long dp[128][128];\n\tint n, h, i, j, l;\n\tlong long min;\n\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tl = strlen(s);\n\tfor (i = 0; i <= l; i++)\n\t\tfor (j = 0; j <= l; j++)\n\t\t\tdp[i][j] = INF;\n\tdp[0][0] = 0;\n\tfor (i = 0; i < l; i++)\n\t\tfor (j = 0; j < l; j++)\n\t\t\tif (dp[i][j] < INF) {\n\t\t\t\tlong long x = dp[i][j];\n\n\t\t\t\tif (s[i] == '0') {\n\t\t\t\t\tif ((double) x * n <= INF)\n\t\t\t\t\t\tif (dp[i + 1][j + 1] > x * n)\n\t\t\t\t\t\t\tdp[i + 1][j + 1] = x * n;\n\t\t\t\t} else {\n\t\t\t\t\tlong long y = 0;\n\n\t\t\t\t\tfor (h = i; h < l; h++) {\n\t\t\t\t\t\ty = y * 10 + (s[h] - '0');\n\t\t\t\t\t\tif (y >= n)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif ((double) x * n + y <= INF)\n\t\t\t\t\t\t\tif (dp[h + 1][j + 1] > x * n + y)\n\t\t\t\t\t\t\t\tdp[h + 1][j + 1] = x * n + y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tmin = INF;\n\tfor (j = 0; j <= l; j++)\n\t\tif (min > dp[l][j])\n\t\t\tmin = dp[l][j];\n\tprintf(\"%lld\\n\", min);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"12\", \"475\", \"3789\", \"594\"]","lang_cluster":"C","code_uid":"46716d0be95d28667c1ab8811fbe84f3","prob_desc_notes":"NoteIn the first example 12 could be obtained by converting two numbers to the system with base 13: 12\u2009=\u200912\u00b7130 or 15\u2009=\u20091\u00b7131\u2009+\u20092\u00b7130.","prob_desc_output_spec":"Print the number x (0\u2009\u2264\u2009x\u2009\u2264\u20091018)\u00a0\u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"Alexander is learning how to convert numbers from the decimal system to any other, however, he doesn't know English letters, so he writes any number only as a decimal number, it means that instead of the letter A he will write the number 10. Thus, by converting the number 475 from decimal to hexadecimal system, he gets 11311 (475\u2009=\u20091\u00b7162\u2009+\u200913\u00b7161\u2009+\u200911\u00b7160). Alexander lived calmly until he tried to convert the number back to the decimal number system.Alexander remembers that he worked with little numbers so he asks to find the minimum decimal number so that by converting it to the system with the base n he will get the number k.","length":47,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n12345', 'output': ['12345\\n']}, {'input': '2\\n1010', 'output': ['10\\n']}, {'input': '16\\n1010', 'output': ['2570\\n']}, {'input': '5\\n321', 'output': ['86\\n']}, {'input': '3\\n210', 'output': ['21\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1\", \"1 2\", \"2 1\"]","prob_desc_input_spec":"The single line contains two integers r,\u2009h (1\u2009\u2264\u2009r,\u2009h\u2009\u2264\u2009107).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<math.h>\nint r,h,vol;\nint main()\n{\n\tscanf(\" %d %d\",&r,&h);\n\n\tvol = h \/ r * 2;\n\th %= r;\n\tif (2*h<r)\n\t\tvol++;\n\telse if(h*2 >= sqrt(3)*r)\n\t\tvol += 3;\n\telse\n\t\tvol += 2;\n\tprintf(\"%d\",vol);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"3\", \"5\", \"2\"]","lang_cluster":"C","code_uid":"96307dff1adc6be404b8f6f5d5faa774","prob_desc_notes":null,"prob_desc_output_spec":"Print a single integer \u2014 the maximum number of balloons Xenia can put in the cupboard.","prob_desc_output_to":"standard output","prob_desc_description":"A girl named Xenia has a cupboard that looks like an arc from ahead. The arc is made of a semicircle with radius r (the cupboard's top) and two walls of height h (the cupboard's sides). The cupboard's depth is r, that is, it looks like a rectangle with base r and height h\u2009+\u2009r from the sides. The figure below shows what the cupboard looks like (the front view is on the left, the side view is on the right).  Xenia got lots of balloons for her birthday. The girl hates the mess, so she wants to store the balloons in the cupboard. Luckily, each balloon is a sphere with radius . Help Xenia calculate the maximum number of balloons she can put in her cupboard. You can say that a balloon is in the cupboard if you can't see any part of the balloon on the left or right view. The balloons in the cupboard can touch each other. It is not allowed to squeeze the balloons or deform them in any way. You can assume that the cupboard's walls are negligibly thin.","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3', 'output': ['5\\n']}, {'input': '5 10', 'output': ['9\\n']}, {'input': '7 14', 'output': ['13\\n']}, {'input': '10 20', 'output': ['17\\n']}, {'input': '1 7', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10 30\\n10 35\\n05:20\", \"60 120\\n24 100\\n13:00\"]","prob_desc_input_spec":"The first line contains two integers a,\u2009ta (1\u2009\u2264\u2009a,\u2009ta\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city A to the city B and the travel time. Both values are given in minutes. The second line contains two integers b,\u2009tb (1\u2009\u2264\u2009b,\u2009tb\u2009\u2264\u2009120) \u2014 the frequency of the buses from the city B to the city A and the travel time. Both values are given in minutes. The last line contains the departure time of Simion from the city A in the format hh:mm. It is guaranteed that there are a bus from the city A at that time. Note that the hours and the minutes are given with exactly two digits.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n\tint a,ta;\n\tscanf(\"%d%d\",&a,&ta);\n\tint b,tb;\n\tscanf(\"%d%d\",&b,&tb);\n\tint h,m;\n\tscanf(\"%d:%d\",&h,&m);\n\tint x,y,w=0,z=300;\n\tx=60*h+m;\n\ty=60*h+m+ta;\n\tjump:\n\t\tif(z+tb<x)\n\t\t{\n\t\t\tz=z+b;\n\t\t\tgoto jump;\n\t\t}\n\t\telse if(z+tb>x && z<y && z<1440)\n\t\t{\n\t\t\tw+=1;\n\t\t\tz=z+b;\n\t\t\tgoto jump;\n\t\t}\n\t\telse if(z>y)\n\t\t{\n\t\t\tgoto temp;\n\t\t}\n\t\telse if(z+tb==x || z==y)\n\t\t{\n\t\t\tz=z+b;\n\t\t\tgoto jump;\n\t\t}\n\t\ttemp:\n\t\tprintf(\"%d\\n\",w);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"5\", \"9\"]","lang_cluster":"C","code_uid":"e83dc1a0f06ecbf461ed86962eef38d9","prob_desc_notes":"NoteIn the first example Simion departs form the city A at 05:20 AM and arrives to the city B at 05:50 AM. He will meet the first 5 buses from the city B that departed in the period [05:00 AM - 05:40 AM]. Also Simion will meet a bus in the city B at 05:50 AM, but he will not count it.Also note that the first encounter will be between 05:26 AM and 05:27 AM (if we suggest that the buses are go with the sustained speed).","prob_desc_output_spec":"Print the only integer z \u2014 the number of buses Simion will meet on the way. Note that you should not count the encounters in cities A and B.","prob_desc_output_to":"standard output","prob_desc_description":"Buses run between the cities A and B, the first one is at 05:00 AM and the last one departs not later than at 11:59 PM. A bus from the city A departs every a minutes and arrives to the city B in a ta minutes, and a bus from the city B departs every b minutes and arrives to the city A in a tb minutes.The driver Simion wants to make his job diverse, so he counts the buses going towards him. Simion doesn't count the buses he meet at the start and finish.You know the time when Simion departed from the city A to the city B. Calculate the number of buses Simion will meet to be sure in his counting.","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 30\\n10 35\\n05:20', 'output': ['5\\n']}, {'input': '60 120\\n24 100\\n13:00', 'output': ['9\\n']}, {'input': '1 120\\n1 120\\n05:00', 'output': ['719\\n']}, {'input': '120 1\\n120 1\\n23:59', 'output': ['0\\n']}, {'input': '60 60\\n60 60\\n12:00', 'output': ['12\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"........\\n........\\n.B....B.\\n....W...\\n........\\n..W.....\\n........\\n........\", \"..B.....\\n..W.....\\n......B.\\n........\\n.....W..\\n......B.\\n........\\n........\"]","prob_desc_input_spec":"The input consists of the board description given in eight lines, each line contains eight characters. Character 'B' is used to denote a black pawn, and character 'W' represents a white pawn. Empty cell is marked with '.'.  It's guaranteed that there will not be white pawns on the first row neither black pawns on the last row.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\ntypedef unsigned u;\nu A[8],B[8];\nint main()\n{\n\tu i,j,a,b;char c;\n\tfor(a=b=i=-1;++i<8;)A[i]=B[i]=-1;\n\tfor(i=-1;++i<8;)for(j=-1;++j<8;)\n\t{\n\t\twhile((c=getchar())<=' ');\n\t\tif(c=='B')B[j]=i;\n\t\tif(c=='W'&&A[j]==-1u)\n\t\t{\n\t\t\tif(B[j]==-1u)A[j]=i;\n\t\t\telse B[j]=-1u;\n\t\t}\n\t}\n\tfor(i=-1;++i<8;)\n\t{\n\t\tif(a>A[i])a=A[i];\n\t\tif(B[i]!=-1u&&b>7-B[i])b=7-B[i];\n\t}\n\tprintf(a>b?\"B\\n\":\"A\\n\");\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"A\", \"B\"]","lang_cluster":"C","code_uid":"ace9f6f64e662df70b9e0f436cf99d94","prob_desc_notes":"NoteIn the first sample player A is able to complete his goal in 3 steps by always moving a pawn initially located at (4,\u20095). Player B needs at least 5 steps for any of his pawns to reach the row 8. Hence, player A will be the winner.","prob_desc_output_spec":"Print 'A' if player A wins the game on the given board, and 'B' if player B will claim the victory. Again, it's guaranteed that there will always be a winner on the given board.","prob_desc_output_to":"standard output","prob_desc_description":"Galois is one of the strongest chess players of Byteforces. He has even invented a new variant of chess, which he named \u00abPawnChess\u00bb.This new game is played on a board consisting of 8 rows and 8 columns. At the beginning of every game some black and white pawns are placed on the board. The number of black pawns placed is not necessarily equal to the number of white pawns placed.   Lets enumerate rows and columns with integers from 1 to 8. Rows are numbered from top to bottom, while columns are numbered from left to right. Now we denote as (r,\u2009c) the cell located at the row r and at the column c.There are always two players A and B playing the game. Player A plays with white pawns, while player B plays with black ones. The goal of player A is to put any of his pawns to the row 1, while player B tries to put any of his pawns to the row 8. As soon as any of the players completes his goal the game finishes immediately and the succeeded player is declared a winner.Player A moves first and then they alternate turns. On his move player A must choose exactly one white pawn and move it one step upward and player B (at his turn) must choose exactly one black pawn and move it one step down. Any move is possible only if the targeted cell is empty. It's guaranteed that for any scenario of the game there will always be at least one move available for any of the players.Moving upward means that the pawn located in (r,\u2009c) will go to the cell (r\u2009-\u20091,\u2009c), while moving down means the pawn located in (r,\u2009c) will go to the cell (r\u2009+\u20091,\u2009c). Again, the corresponding cell must be empty, i.e. not occupied by any other pawn of any color.Given the initial disposition of the board, determine who wins the game if both players play optimally. Note that there will always be a winner due to the restriction that for any game scenario both players will have some moves available.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '........\\n........\\n.B....B.\\n....W...\\n........\\n..W.....\\n........\\n........', 'output': ['A\\n']}, {'input': '..B.....\\n..W.....\\n......B.\\n........\\n.....W..\\n......B.\\n........\\n........', 'output': ['B\\n']}, {'input': '........\\n........\\n........\\n........\\n........\\n........\\n..W.....\\n..B.....', 'output': ['A\\n']}, {'input': '........\\n........\\n........\\n........\\n........\\n........\\n..B.....\\n..W.....', 'output': ['B\\n']}, {'input': '........\\n........\\n........\\n........\\n........\\n..B.....\\n..W.....\\n........', 'output': ['A\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3\\n141 592 653\", \"5\\n10 21 10 21 10\"]","prob_desc_input_spec":"Input will begin with an integer N (1\u2009\u2264\u2009N\u2009\u2264\u200950), the number of slices of pie.  Following this is a line with N integers indicating the sizes of the slices (each between 1 and 100000, inclusive), in the order in which they must be handed out.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n\nint max(int a,int b)\n{\nif(a>=b)return a;\nelse return b;\n}\nint main()\n{\nint ca[52];\nint n;scanf(\"%d\",&n);\nint sumi[52];\nint sum=0;\nint dp[52]={-1};\n\nint i=0;\nfor(i=0;i<n;i++)\n{\nscanf(\"%d\",&ca[i]);\nsum += ca[i];\nsumi[i] = sum;\n}\ndp[n-1]=ca[n-1];\n\nfor(i=n-2;i>=0;i--)\n{\ndp[i]=max((ca[i]+(sumi[n-1]-dp[i+1]-sumi[i])),dp[i+1]);\n\n\n}\n\nint ans = dp[0];\nint ans1 = sumi[n-1]-dp[0];\n\nprintf(\"%d %d\\n\",ans1,ans);\n\n\n\nreturn 0;\n}\n","prob_desc_sample_outputs":"[\"653 733\", \"31 41\"]","lang_cluster":"C","code_uid":"304d52724875314b8a5125aa9c1d720b","prob_desc_notes":"NoteIn the first example, Bob takes the size 141 slice for himself and gives the decider token to Alice. Then Alice gives the size 592 slice to Bob and keeps the decider token for herself, so that she can then give the size 653 slice to herself.","prob_desc_output_spec":"Print two integers. First, the sum of the sizes of slices eaten by Alice, then the sum of the sizes of the slices eaten by Bob, assuming both players make their decisions optimally.","prob_desc_output_to":"standard output","prob_desc_description":"You may have heard of the pie rule before. It states that if two people wish to fairly share a slice of pie, one person should cut the slice in half, and the other person should choose who gets which slice. Alice and Bob have many slices of pie, and rather than cutting the slices in half, each individual slice will be eaten by just one person.The way Alice and Bob decide who eats each slice is as follows. First, the order in which the pies are to be handed out is decided. There is a special token called the \"decider\" token, initially held by Bob. Until all the pie is handed out, whoever has the decider token will give the next slice of pie to one of the participants, and the decider token to the other participant. They continue until no slices of pie are left.All of the slices are of excellent quality, so each participant obviously wants to maximize the total amount of pie they get to eat. Assuming both players make their decisions optimally, how much pie will each participant receive?","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\n10 20 30 40', 'output': ['60 40\\n']}, {'input': '5\\n1 2 3 4 5', 'output': ['9 6\\n']}, {'input': '6\\n6 5 4 3 2 1', 'output': ['12 9\\n']}, {'input': '2\\n100000 1', 'output': ['100000 1\\n']}, {'input': '3\\n50 50 50', 'output': ['100 50\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1 3 2 0\", \"7\\n1 3 3 2 1 2 3\", \"2\\n2 2\"]","prob_desc_input_spec":"The first line contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days of Vasya's vacations. The second line contains the sequence of integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20093) separated by space, where:    ai equals 0, if on the i-th day of vacations the gym is closed and the contest is not carried out;  ai equals 1, if on the i-th day of vacations the gym is closed, but the contest is carried out;  ai equals 2, if on the i-th day of vacations the gym is open and the contest is not carried out;  ai equals 3, if on the i-th day of vacations the gym is open and the contest is carried out.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"\/\/DURING CONTEST: http:\/\/www.codeforces.com\/contest\/699\/submission\/19246509\n\n#include <stdio.h>\n#include <stdint.h>\nint main() {\n    \/**\n     * Variables are stored as follows:\n     * whatWeCouldDoYesterday -- data & 0b11\n     * whatWeCanDoToday       -- (data & 0b1100) >> 2\n     * answer                 -- (data & 0xff00) >> 8\n     * numDays                -- (data & 0xff0000) >> 16\n     * todayCode              -- (data & 0xff000000) >> 24\n    *\/\n    \n    \/\/whatWeDidYesterday = whatWeCanDoToday = answer = numDays = todayCode = 0;\n    uint32_t data = 0;\n    \/\/scanf(\"%i\", &numDays);\n    scanf(\"%hhi\", ((signed char*)&data)+2);\n    \/\/whatWeCouldDoYesterday = 3;\n    data += 3;\n    \/\/while ((numDays -= 1), numDays+1) {\n    while ((data -= 0x10000), ((data+0x10000) & 0xff0000) >> 16) {\n        \/\/scanf(\"%i\", &todayCode);\n        scanf(\"%hhi\", ((signed char*)&data)+3);\n        \/\/if ((whatWeCouldDoYesterday & 2) && (todayCode & 1)) whatWeCanDoToday += 1;\n        if ((data & 2) && (data & 0x1000000) >> 24) data += 1 << 2;\n        \/\/if ((whatWeCouldDoYesterday & 1) && (todayCode & 2)) whatWeCanDoToday += 2;\n        if ((data & 1) && (data & 0x2000000) >> 24) data += 2 << 2;\n        \/\/if (!whatWeCanDoToday) answer += 1, whatWeCanDoToday = 3;\n        if (!(data & 0b1100)) data += 1 << 8, data += 3 << 2;\n        \/\/whatWeCouldDoYesterday = whatWeCanDoToday, whatWeCanDoToday = 0;\n        *((signed char*)&data) >>= 2;\n    }\n    \/\/printf(\"%i\\n\", answer);\n    printf(\"%li\\n\", (data & 0xff00) >> 8);\n}","prob_desc_sample_outputs":"[\"2\", \"0\", \"1\"]","lang_cluster":"C","code_uid":"0e5891b91b4791e582ef79fc3bf9a7a8","prob_desc_notes":"NoteIn the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.","prob_desc_output_spec":"Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:   to do sport on any two consecutive days,  to write the contest on any two consecutive days. ","prob_desc_output_to":"standard output","prob_desc_description":"Vasya has n days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this n days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the i-th day there are four options:  on this day the gym is closed and the contest is not carried out;  on this day the gym is closed and the contest is carried out;  on this day the gym is open and the contest is not carried out;  on this day the gym is open and the contest is carried out. On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has \u2014 he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 0 1', 'output': ['1\\n']}, {'input': '6\\n2 2 1 1 0 3', 'output': ['2\\n']}, {'input': '3\\n3 3 3', 'output': ['0\\n']}, {'input': '4\\n0 0 0 0', 'output': ['4\\n']}, {'input': '7\\n1 2 1 2 1 2 1', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1990 1\", \"300 0\", \"1034 2\", \"9090000078001234 6\"]","prob_desc_input_spec":"The single line contains two integers a and k (1\u2009\u2264\u2009a\u2009\u2264\u20091018;\u00a00\u2009\u2264\u2009k\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<string.h>\nint main()\n{\n\tchar a[500],temp,max;\n\tint c,n,i,j,k,x,f=1,h=4,m;\n\tscanf(\"%s\",a);\n\tscanf(\"%d\",&k);\n\tc=0;\n\tn=strlen(a);\n\twhile(c!=n)\n\t{\n\t\tmax='0';\n\t\tfor(j=c;j<k+c+1;j++)\n\t\t{\n\t\t\tif(j==n)\n\t\t\tbreak;\n\t\t\tif(a[j]>max)\n\t\t\t{\n\t\t\t\tmax=a[j];\n\t\t\t\tx=j;\n\t\t\t}\n\t\t}\n\t\tfor(j=x;j>c;j--)\n\t\t{\n\t\t\t\/*if(c==x)\t\t\n\t\t\tbreak;*\/\n\t\t\tif(k==0)\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp=a[j-1];\n\t\t\ta[j-1]=a[j];\n\t\t\ta[j]=temp;\n\t\t\tk--;\n\t\t}\n\t\tc++;\n\t\/\/\tprintf(\"%d \",k);\n\t\tif(f==0)\n\t\tbreak;\n\t}\n\tprintf(\"%s\",a);\n\treturn 0;\n}\n\t\t\n","prob_desc_sample_outputs":"[\"9190\", \"300\", \"3104\", \"9907000008001234\"]","lang_cluster":"C","code_uid":"7b16d6b2850c3f5c22debfbf00654009","prob_desc_notes":null,"prob_desc_output_spec":"Print the maximum number that Pasha can get if he makes at most k swaps.","prob_desc_output_to":"standard output","prob_desc_description":"Pasha has a positive integer a without leading zeroes. Today he decided that the number is too small and he should make it larger. Unfortunately, the only operation Pasha can do is to swap two adjacent decimal digits of the integer.Help Pasha count the maximum number he can get if he has the time to make at most k swaps.","length":46,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '123456789 3', 'output': ['321456789']}, {'input': '987654321 2', 'output': ['987654321']}, {'input': '111223344 4', 'output': ['444113221']}, {'input': '999999999 0', 'output': ['999999999']}, {'input': '1234567890 9', 'output': ['9876543210']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 2\", \"7 4\"]","prob_desc_input_spec":"The single line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009k\u2009\u2264\u2009min(8,\u2009n)) \u2014 the number of the houses and the number k from the statement.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nmain()\n{\n    long long i=1000000007;\n    long long n,k,j;\n    scanf(\"%lld%lld\",&n,&k);\n    long long x=n-k,m=1,y=1;\n    for(j=1;j<=x;j++)\n        m=(m*x)%i;\n    for(j=1;j<k;j++)\n      y=(y*k)%i;\n      m=(m*y)%i;\n    printf(\"%I64d\",m);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"54\", \"1728\"]","lang_cluster":"C","code_uid":"bdfebe67561a3f0c341a856cfe29a391","prob_desc_notes":null,"prob_desc_output_spec":"In a single line print a single integer \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Little penguin Polo loves his home village. The village has n houses, indexed by integers from 1 to n. Each house has a plaque containing an integer, the i-th house has a plaque containing integer pi (1\u2009\u2264\u2009pi\u2009\u2264\u2009n).Little penguin Polo loves walking around this village. The walk looks like that. First he stands by a house number x. Then he goes to the house whose number is written on the plaque of house x (that is, to house px), then he goes to the house whose number is written on the plaque of house px (that is, to house ppx), and so on.We know that:  When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.  When the penguin starts walking from any house indexed from k\u2009+\u20091 to n, inclusive, he definitely cannot walk to house number 1.  When the penguin starts walking from house number 1, he can get back to house number 1 after some non-zero number of walks from a house to a house. You need to find the number of ways you may write the numbers on the houses' plaques so as to fulfill the three above described conditions. Print the remainder after dividing this number by 1000000007 (109\u2009+\u20097).","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3', 'output': ['196830000']}, {'input': '8 2', 'output': ['77760000']}, {'input': '6 1', 'output': ['3125']}, {'input': '15 5', 'output': ['244140625']}, {'input': '20 7', 'output': ['893353197']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 3 8 1 1\", \"4 2 9 4 2\", \"5 5 25 4 3\", \"100 100 1000000000000000000 100 100\"]","prob_desc_input_spec":"The first and the only line contains five integers n, m, k, x and y (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009k\u2009\u2264\u20091018,\u20091\u2009\u2264\u2009x\u2009\u2264\u2009n,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009m).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX 1000010\n#define clr(ar) memset(ar, 0, sizeof(ar))\n#define read() freopen(\"lol.txt\", \"r\", stdin)\n\nlong long len, n, m, k, x, y;\nlong long X[MAX], Y[MAX], counter[1010][1010];\n\nint main(){\n    long long i, j, v, min_v, max_v;\n\n    while (scanf(\"%lld %lld %lld %lld %lld\", &n, &m, &k, &x, &y) != EOF){\n        len = 0;\n        clr(counter);\n        for (i = 1; i < n; i++){\n            for (j = 1; j <= m; j++){\n                X[len] = i, Y[len++] = j;\n            }\n        }\n        for (i = n; i > 1; i--){\n            for (j = 1; j <= m; j++){\n                X[len] = i, Y[len++] = j;\n            }\n        }\n\n        if (n == 1){\n            for (i = 1; i <= m; i++) X[len] = 1, Y[len++] = i;\n        }\n\n        for (i = 0; i < len; i++) counter[X[i]][Y[i]] += (k \/ len);\n        k %= len;\n        for (i = 0; i < k; i++) counter[X[i]][Y[i]]++;\n\n        min_v = max_v = counter[1][1];\n        for (i = 1; i <= n; i++){\n            for (j = 1; j <= m; j++){\n                if (counter[i][j] < min_v) min_v = counter[i][j];\n                if (counter[i][j] > max_v) max_v = counter[i][j];\n            }\n        }\n\n        printf(\"%lld %lld %lld\\n\", max_v, min_v, counter[x][y]);\n    }\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"3 2 3\", \"2 1 1\", \"1 1 1\", \"101010101010101 50505050505051 50505050505051\"]","lang_cluster":"C","code_uid":"b2af0def5413bfd0d3a17df2a81e4057","prob_desc_notes":"NoteThe order of asking pupils in the first test:   the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table; The order of asking pupils in the second test:   the pupil from the first row who seats at the first table;  the pupil from the first row who seats at the second table;  the pupil from the second row who seats at the first table;  the pupil from the second row who seats at the second table;  the pupil from the third row who seats at the first table;  the pupil from the third row who seats at the second table;  the pupil from the fourth row who seats at the first table;  the pupil from the fourth row who seats at the second table, it means it is Sergei;  the pupil from the third row who seats at the first table; ","prob_desc_output_spec":"Print three integers:   the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. ","prob_desc_output_to":"standard output","prob_desc_description":"On the Literature lesson Sergei noticed an awful injustice, it seems that some students are asked more often than others.Seating in the class looks like a rectangle, where n rows with m pupils in each. The teacher asks pupils in the following order: at first, she asks all pupils from the first row in the order of their seating, then she continues to ask pupils from the next row. If the teacher asked the last row, then the direction of the poll changes, it means that she asks the previous row. The order of asking the rows looks as follows: the 1-st row, the 2-nd row, ..., the n\u2009-\u20091-st row, the n-th row, the n\u2009-\u20091-st row, ..., the 2-nd row, the 1-st row, the 2-nd row, ...The order of asking of pupils on the same row is always the same: the 1-st pupil, the 2-nd pupil, ..., the m-th pupil.During the lesson the teacher managed to ask exactly k questions from pupils in order described above. Sergei seats on the x-th row, on the y-th place in the row. Sergei decided to prove to the teacher that pupils are asked irregularly, help him count three values:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. If there is only one row in the class, then the teacher always asks children from this row.","length":48,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 4 1 1', 'output': ['1 1 1\\n']}, {'input': '3 3 9 2 2', 'output': ['1 1 1\\n']}, {'input': '4 4 16 3 3', 'output': ['1 1 1\\n']}, {'input': '5 5 25 4 4', 'output': ['1 1 1\\n']}, {'input': '6 6 36 5 5', 'output': ['1 1 1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3 5 6 1\\n1 2 3\", \"4 40 50 10\\n10 20 30 25\", \"5 25 35 10\\n10 10 20 10 20\"]","prob_desc_input_spec":"The first line contains four integers n, l, r, x (1\u2009\u2264\u2009n\u2009\u2264\u200915, 1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009109, 1\u2009\u2264\u2009x\u2009\u2264\u2009106) \u2014 the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively. The second line contains n integers c1,\u2009c2,\u2009...,\u2009cn (1\u2009\u2264\u2009ci\u2009\u2264\u2009106) \u2014 the difficulty of each problem.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint main()\n{\n    char n,i;\n    long l,r,x,j;\n    long min,max,sum,count=0;\n    char s;\n    scanf(\"%d%ld%ld%ld\",&n,&l,&r,&x);\n    long c[n];\n    for(i=0;i<n;i++)\n        scanf(\"%ld\",c+i);\n    long a=1L<<n;\n    for(j=1;j<a;j++){\n        min=1000000;\n        max=1;\n        sum=0;\n        s=0;\n        for(i=0;i<n;i++)\n            if(j&(1L<<i)){\n                if(c[i]<min)min=c[i];\n                if(c[i]>max)max=c[i];\n                sum+=c[i];\n                s++;\n            }\n        if(s>1 && sum>=l && sum<=r && (max-min)>=x)\n            count++;\n    }\n    printf(\"%ld\\n\",count);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"2\", \"6\"]","lang_cluster":"C","code_uid":"ec7273655b380aae84c82dc54a11d90a","prob_desc_notes":"NoteIn the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.In the second example, two sets of problems are suitable \u2014 the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.","prob_desc_output_spec":"Print the number of ways to choose a suitable problemset for the contest. ","prob_desc_output_to":"standard output","prob_desc_description":"You have n problems. You have estimated the difficulty of the i-th one as integer ci. Now you want to prepare a problemset for a contest, using some of the problems you've made.A problemset for the contest must consist of at least two problems. You think that the total difficulty of the problems of the contest must be at least l and at most r. Also, you think that the difference between difficulties of the easiest and the hardest of the chosen problems must be at least x.Find the number of ways to choose a problemset for the contest.","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 10 20 5\\n5 10 15 20 25', 'output': ['4\\n']}, {'input': '3 5 10 2\\n3 5 7', 'output': ['2\\n']}, {'input': '4 10 20 5\\n5 10 15 20', 'output': ['3\\n']}, {'input': '2 5 10 5\\n5 10', 'output': ['1\\n']}, {'input': '3 10 15 5\\n5 10 15', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 2\", \"1 2\"]","prob_desc_input_spec":"The first line contains two integers w and h (1\u2009\u2264\u2009w,\u2009h\u2009\u2264\u20094000) \u2014 the rectangle's sizes.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n\tlong long int c=0,w,h,n,m;\n\tscanf(\"%lld %lld\",&w,&h);\n\tif(w<2 || h<2)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tfor(n=2;w>=n;n=n+2)\n\t{\n\t\tfor(m=2;h>=m;m=m+2)\n\t\t\tc=c+(h-(m-1))*(w-(n-1));\n\t}\n\tprintf(\"%lld\\n\",c);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"0\"]","lang_cluster":"C","code_uid":"ff77a7d647936d5f41da8fe93f71e948","prob_desc_notes":"NoteIn the first example there exists only one such rhombus. Its vertices are located at points (1,\u20090), (2,\u20091), (1,\u20092), (0,\u20091).","prob_desc_output_spec":"Print a single number \u2014 the number of sought rhombi. Please do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","prob_desc_output_to":"standard output","prob_desc_description":"You have two positive integers w and h. Your task is to count the number of rhombi which have the following properties:   Have positive area.  With vertices at integer points.  All vertices of the rhombi are located inside or on the border of the rectangle with vertices at points (0,\u20090), (w,\u20090), (w,\u2009h), (0,\u2009h). In other words, for all vertices (xi,\u2009yi) of the rhombus the following conditions should fulfill: 0\u2009\u2264\u2009xi\u2009\u2264\u2009w and 0\u2009\u2264\u2009yi\u2009\u2264\u2009h.  Its diagonals are parallel to the axis.  Count the number of such rhombi.Let us remind you that a rhombus is a quadrilateral whose four sides all have the same length.","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3', 'output': ['4\\n']}, {'input': '4 4', 'output': ['9\\n']}, {'input': '5 5', 'output': ['16\\n']}, {'input': '6 6', 'output': ['25\\n']}, {'input': '7 7', 'output': ['36\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10 3 5 2 3\"]","prob_desc_input_spec":"The single line contains five integers C,\u2009Hr,\u2009Hb,\u2009Wr,\u2009Wb (1\u2009\u2264\u2009C,\u2009Hr,\u2009Hb,\u2009Wr,\u2009Wb\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\n#define max(a, b) (((a) > (b)) ? (a) : (b))\n\nint main(void) {\n    int i;\n    int c, wr, wb;\n    long long hr, hb;\n    long long ans;\n\n    scanf(\"%d %lld %lld %d %d\", &c, &hr, &hb, &wr, &wb);\n\n    ans = 0;\n    for (i = 0; i <= c \/ wr && i * i <= c; i++)\n        ans = max(ans, hr * i + (c - wr * i) \/ wb * hb);\n    for (i = 0; i <= c \/ wb && i * i <= c; i++)\n        ans = max(ans, hb * i + (c - wb * i) \/ wr * hr);\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n ","prob_desc_sample_outputs":"[\"16\"]","lang_cluster":"C","code_uid":"9557af7f6c0ea2ff51c70a2f5223221a","prob_desc_notes":"NoteIn the sample test Om Nom can eat two candies of each type and thus get 16 joy units.","prob_desc_output_spec":"Print a single integer \u2014 the maximum number of joy units that Om Nom can get.","prob_desc_output_to":"standard output","prob_desc_description":"A sweet little monster Om Nom loves candies very much. One day he found himself in a rather tricky situation that required him to think a bit in order to enjoy candies the most. Would you succeed with the same task if you were on his place?  One day, when he came to his friend Evan, Om Nom didn't find him at home but he found two bags with candies. The first was full of blue candies and the second bag was full of red candies. Om Nom knows that each red candy weighs Wr grams and each blue candy weighs Wb grams. Eating a single red candy gives Om Nom Hr joy units and eating a single blue candy gives Om Nom Hb joy units.Candies are the most important thing in the world, but on the other hand overeating is not good. Om Nom knows if he eats more than C grams of candies, he will get sick. Om Nom thinks that it isn't proper to leave candy leftovers, so he can only eat a whole candy. Om Nom is a great mathematician and he quickly determined how many candies of what type he should eat in order to get the maximum number of joy units. Can you repeat his achievement? You can assume that each bag contains more candies that Om Nom can eat.","length":23,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3 5 2 3\\n', 'output': ['16\\n']}, {'input': '20 5 3 4 2\\n', 'output': ['25\\n']}, {'input': '15 2 4 3 1\\n', 'output': ['24\\n']}, {'input': '30 6 2 5 3\\n', 'output': ['36\\n']}, {'input': '25 4 6 2 3\\n', 'output': ['50\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1\", \"2\", \"3\", \"8\"]","prob_desc_input_spec":"The first line of the input will contain a single integer, n (1\u2009\u2264\u2009n\u2009\u2264\u2009100\u2009000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[110]={0};\n    int i;\n    for(i=1;;i++)\n    {\n        if(n==1) {break;}\n        int yushu,deshu;\n        yushu=n%2;\n        n=n\/2;\n        a[i]=yushu;\n        if(n==1) {i++;break;}\n    }\n    printf(\"%d\",i);\n    i--;\n    for(;i>=0;i--)\n        if(a[i]) printf(\" %d\",i);\n    printf(\"\\n\");\n}\n","prob_desc_sample_outputs":"[\"1\", \"2\", \"2 1\", \"4\"]","lang_cluster":"C","code_uid":"4f02fa2ddd80bf305cd42540824b572d","prob_desc_notes":"NoteIn the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.In the second sample, we perform the following steps:Initially we place a single slime in a row by itself. Thus, row is initially 1.Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.In the last sample, the steps look as follows:   1  2  2 1  3  3 1  3 2  3 2 1  4 ","prob_desc_output_spec":"Output a single line with k integers, where k is the number of slimes in the row after you've finished the procedure described in the problem statement. The i-th of these numbers should be the value of the i-th slime from the left.","prob_desc_output_to":"standard output","prob_desc_description":"Your friend recently gave you some slimes for your birthday. You have n slimes all initially with value 1.You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other n\u2009-\u20091 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value v, you combine them together to create a slime with value v\u2009+\u20091.You would like to see what the final state of the row is after you've added all n slimes. Please print the values of the slimes in the row from left to right.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\n', 'output': ['3 1\\n']}, {'input': '5\\n', 'output': ['3 1 1\\n']}, {'input': '6\\n', 'output': ['3 2\\n']}, {'input': '7\\n', 'output': ['3 2 1\\n']}, {'input': '9\\n', 'output': ['4 1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 3\", \"3 1\"]","prob_desc_input_spec":"In the only line you are given two integers a, b (0\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of even and odd steps, accordingly.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint main(void) {\n\t\/\/ your code goes here\n\tint i,j;\n\tscanf(\"%d%d\",&i,&j);\n\t\n\tif(i==0&&j==0)\n\t{\n\t\tprintf(\"NO\");\n\t\t\n\t\n}\nelse\n{\n\tif((i-j)==1||(j-i)==1||i==j)\n\t{\n\n\n\t\n\t\tprintf(\"YES\");\n\t}\nelse\n{\n\tprintf(\"NO\");\t\n\t}\n}\n\treturn 0;\n\t\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"C","code_uid":"9ef3ec3669844b35555c8a1386d977b7","prob_desc_notes":"NoteIn the first example one of suitable intervals is from 1 to 5. The interval contains two even steps\u00a0\u2014 2 and 4, and three odd: 1, 3 and 5.","prob_desc_output_spec":"In the only line print \"YES\", if the interval of steps described above exists, and \"NO\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"On her way to programming school tiger Dasha faced her first test \u2014 a huge staircase!  The steps were numbered from one to infinity. As we know, tigers are very fond of all striped things, it is possible that it has something to do with their color. So on some interval of her way she calculated two values \u2014 the number of steps with even and odd numbers. You need to check whether there is an interval of steps from the l-th to the r-th (1\u2009\u2264\u2009l\u2009\u2264\u2009r), for which values that Dasha has found are correct.","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4 5', 'output': ['YES\\n']}, {'input': '0 0', 'output': ['NO\\n']}, {'input': '10 10', 'output': ['YES\\n']}, {'input': '7 9', 'output': ['YES\\n']}, {'input': '6 8', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"27\", \"4545\"]","prob_desc_input_spec":"The first line contains a single integer x (1\u2009\u2264\u2009x\u2009\u2264\u20091018) \u2014 the number that Luke Skywalker gave to Chewbacca.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<string.h>\nint main()\n{\nint i;\nchar arr[20];\nint c=0,b[20];\nscanf(\"%s\",arr);\nfor(i=0;i<strlen(arr);i++)\n{\nb[i]=arr[i];\nif(b[i]>=53)\n{\nb[i]=57-b[i];\nif(b[0]==0)\nb[0]=9;\n}\nelse\n{b[i]=b[i]-48;}\nprintf(\"%d\",b[i]);\n}\n\/\/printf(\"1\");\nreturn 0;\n}\n","prob_desc_sample_outputs":"[\"22\", \"4444\"]","lang_cluster":"C","code_uid":"7df1e10e7caf8e5bb6ad5838f3242f78","prob_desc_notes":null,"prob_desc_output_spec":"Print the minimum possible positive number that Chewbacca can obtain after inverting some digits. The number shouldn't contain leading zeroes.","prob_desc_output_to":"standard output","prob_desc_description":"Luke Skywalker gave Chewbacca an integer number x. Chewbacca isn't good at numbers but he loves inverting digits in them. Inverting digit t means replacing it with digit 9\u2009-\u2009t. Help Chewbacca to transform the initial number x to the minimum possible positive number by inverting some (possibly, zero) digits. The decimal representation of the final number shouldn't start with a zero.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1234567890', 'output': ['1234432100']}, {'input': '9999999999', 'output': ['9000000000']}, {'input': '1111111111', 'output': ['1111111111']}, {'input': '56789', 'output': ['43210']}, {'input': '1010101010', 'output': ['1010101010']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 7\", \"100 99\", \"100 50\"]","prob_desc_input_spec":"The first line contains two integers w,\u2009m (2\u2009\u2264\u2009w\u2009\u2264\u2009109, 1\u2009\u2264\u2009m\u2009\u2264\u2009109) \u2014 the number defining the masses of the weights and the mass of the item.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\ntypedef unsigned u;\nu w,m;\nint main()\n{\n\tscanf(\"%u%u\",&w,&m);\n\twhile(m)\n\t{\n\t\tif(m%w==1)--m;\n\t\tif(m%w==w-1)++m;\n\t\tif(m%w==0)m\/=w;\n\t\telse{printf(\"NO\\n\");return 0;}\n\t}\n\tprintf(\"YES\\n\");\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\"]","lang_cluster":"C","code_uid":"0bc52ade872b599f67929b175b87f29f","prob_desc_notes":"NoteNote to the first sample test. One pan can have an item of mass 7 and a weight of mass 3, and the second pan can have two weights of masses 9 and 1, correspondingly. Then 7\u2009+\u20093\u2009=\u20099\u2009+\u20091.Note to the second sample test. One pan of the scales can have an item of mass 99 and the weight of mass 1, and the second pan can have the weight of mass 100.Note to the third sample test. It is impossible to measure the weight of the item in the manner described in the input. ","prob_desc_output_spec":"Print word 'YES' if the item can be weighted and 'NO' if it cannot.","prob_desc_output_to":"standard output","prob_desc_description":"Vanya has a scales for weighing loads and weights of masses w0,\u2009w1,\u2009w2,\u2009...,\u2009w100 grams where w is some integer not less than 2 (exactly one weight of each nominal value). Vanya wonders whether he can weight an item with mass m using the given weights, if the weights can be put on both pans of the scales. Formally speaking, your task is to determine whether it is possible to place an item of mass m and some weights on the left pan of the scales, and some weights on the right pan of the scales so that the pans of the scales were in balance.","length":16,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 1', 'output': ['YES\\n']}, {'input': '5 25', 'output': ['YES\\n']}, {'input': '10 100', 'output': ['YES\\n']}, {'input': '3 10', 'output': ['NO\\n']}, {'input': '7 49', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\"]","prob_desc_input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#define MOD 1000003\n \nint power(int x,int y)\n{\n    if(y==0)\n    return 1;\n    int temp=x;\n    while(--y)\n    {\n        x*=temp;\n        x%=MOD;\n    }\n    return x;\n}\nint main()\n{\n    int y;\n    scanf(\"%d\",&y);\n    if(y==0)\n    {\n    printf(\"%d\",1);\n    return 0;\n    }\n    int res=power(3,y-1);\n    printf(\"%d\\n\",res);\n    return 0;\n}","prob_desc_sample_outputs":"[\"9\"]","lang_cluster":"C","code_uid":"b00ee8d6b0774ac21a19e733ecf8120a","prob_desc_notes":"NoteIf the box possesses the base of 23\u2009\u00d7\u200923 (as in the example), then the cookies will be put there in the following manner: ","prob_desc_output_spec":"Print the single number, equal to the number of empty cells in the box. The answer should be printed modulo 106\u2009+\u20093.","prob_desc_output_to":"standard output","prob_desc_description":"Fangy collects cookies. Once he decided to take a box and put cookies into it in some way. If we take a square k\u2009\u00d7\u2009k in size, divided into blocks 1\u2009\u00d7\u20091 in size and paint there the main diagonal together with cells, which lie above it, then the painted area will be equal to the area occupied by one cookie k in size. Fangy also has a box with a square base 2n\u2009\u00d7\u20092n, divided into blocks 1\u2009\u00d7\u20091 in size. In a box the cookies should not overlap, and they should not be turned over or rotated. See cookies of sizes 2 and 4 respectively on the figure:    To stack the cookies the little walrus uses the following algorithm. He takes out of the repository the largest cookie which can fit in some place in the box and puts it there. Everything could be perfect but alas, in the repository the little walrus has infinitely many cookies of size 2 and larger, and there are no cookies of size 1, therefore, empty cells will remain in the box. Fangy wants to know how many empty cells will be left in the end.","length":28,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0', 'output': ['1\\n']}, {'input': '1', 'output': ['3\\n']}, {'input': '2', 'output': ['9\\n']}, {'input': '3', 'output': ['27\\n']}, {'input': '4', 'output': ['81\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2300.0,"prob_desc_time_limit":"4 seconds","prob_desc_sample_inputs":"[\"2 3\\n1 3\", \"2 4\\n2 2\", \"3 5\\n1 3 2\"]","prob_desc_input_spec":"The first line of input contains two space-separated integers n and s (1\u2009\u2264\u2009n\u2009\u2264\u200920, 0\u2009\u2264\u2009s\u2009\u2264\u20091014). The second line contains n space-separated integers f1,\u2009f2,\u2009... fn (0\u2009\u2264\u2009fi\u2009\u2264\u20091012).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nlong long f[23],n,s,sum,inv[25];\nint c[23];\nint function(){\n\tint i,t1,j=0;\n\ti=1;\n\t\n\twhile(1){\n\t\tif(c[i]==0){\n\t\t\tc[i]=1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tc[i]=0;\n\t\t\ti++;\n\t\t}\n\t}\n}\t\n\nlong long power(long long a, long long b, long long MOD) {\nlong long x = 1, y = a; \n    while(b > 0) {\n        if(b%2 == 1) {\n            x=(x*y);\n            if(x>MOD) x%=MOD;\n        }\n        y = (y*y);\n        if(y>MOD) y%=MOD;\n        b \/= 2;\n       \n    }\n    return x;\n}\n \nlong long modInverse(long long a,long long m) {\nif(inv[a]==0)\n     inv[a]=power(a,m-2,m);\n     return inv[a];\n}\n\nlong long binomialCoeff(long long n, long long k)\n{\n    long long i,res = 1;\n    if (k >( n - k))\n        k = n - k;\t\n    for ( i = 0; i < k; ++i)\n    {\n        res =(res* ((n - i)%1000000007))%1000000007;\n        res =(res* modInverse((i + 1),1000000007))%1000000007;\n    }\n\n    return res;\n}\nvoid recursion(int i,long long pow,int fac){\n\tint j;\n\ti=0;\n\twhile(1){\n\t\tfac=1;\n\t\tj=0;\n\t\tpow=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tpow=pow+c[i]*(f[i]+1);\n\t\t\tif(c[i]==1){\tfac=fac*-1;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(pow<=s){\t\t\t\t\n\t\t\tsum=(sum+fac*binomialCoeff(n+s-pow-1,s-pow))%1000000007;\n\t\t}\n\t\tif(j==n)\tbreak;\n\t\tfunction();\n\t}\n}\n\nint main(){\n\tlong long i,j,k,l;\n\tscanf(\"%lld %lld\",&n,&s);\n\tfor(i=1;i<=n;i++)\tscanf(\"%lld\",&f[i]);\n\trecursion(1,0,1);\n\tsum=(sum+1000000007)%1000000007;\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"1\", \"3\"]","lang_cluster":"C","code_uid":"aa3df742761205ac9901317c2c20bc5b","prob_desc_notes":"NoteSample 1. There are two ways of selecting 3 flowers: {1,\u20092} and {0,\u20093}.Sample 2. There is only one way of selecting 4 flowers: {2,\u20092}.Sample 3. There are three ways of selecting 5 flowers: {1,\u20092,\u20092}, {0,\u20093,\u20092}, and {1,\u20093,\u20091}.","prob_desc_output_spec":"Output a single integer \u2014 the number of ways in which Devu can select the flowers modulo (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Devu wants to decorate his garden with flowers. He has purchased n boxes, where the i-th box contains fi flowers. All flowers in a single box are of the same color (hence they are indistinguishable). Also, no two boxes have flowers of the same color.Now Devu wants to select exactly s flowers from the boxes to decorate his garden. Devu would like to know, in how many different ways can he select the flowers from each box? Since this number may be very large, he asks you to find the number modulo (109\u2009+\u20097). Devu considers two ways different if there is at least one box from which different number of flowers are selected in these two ways.","length":82,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 3\\n1 3', 'output': ['2\\n']}, {'input': '2 4\\n2 2', 'output': ['1\\n']}, {'input': '3 5\\n1 3 2', 'output': ['3\\n']}, {'input': '3 6\\n2 2 2', 'output': ['10\\n']}, {'input': '4 10\\n1 2 3 4', 'output': ['66\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 5\", \"2 3\"]","prob_desc_input_spec":"The first line of input contains two space-separated integers m and b (1\u2009\u2264\u2009m\u2009\u2264\u20091000, 1\u2009\u2264\u2009b\u2009\u2264\u200910000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <limits.h>\n\nint main(void){\n\tlong long int m, b;\n\tscanf(\"%lld%lld\", &m, &b);\n\tlong long int i;\n\tlong long int max = INT_MIN;\n\tfor(i=b; i>=0; i--){\n\t\tlong long int x = (b-i)*m;\n\t\tlong long int w = x*(x+1)\/2;\n\t\tlong long int p = i*(i+1)\/2;\n\t\tlong long int val = w*(i+1)+p*(x+1);\n\t\tif(val > max){\n\t\t\tmax = val;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", max);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"30\", \"25\"]","lang_cluster":"C","code_uid":"6dfff265b3c6bd83bd9ea151f4eeca58","prob_desc_notes":"Note  The graph above corresponds to sample test 1. The optimal rectangle is shown in red and has 30 bananas.","prob_desc_output_spec":"Print the maximum number of bananas Okabe can get from the trees he cuts.","prob_desc_output_to":"standard output","prob_desc_description":"Okabe needs bananas for one of his experiments for some strange reason. So he decides to go to the forest and cut banana trees.Consider the point (x,\u2009y) in the 2D plane such that x and y are integers and 0\u2009\u2264\u2009x,\u2009y. There is a tree in such a point, and it has x\u2009+\u2009y bananas. There are no trees nor bananas in other points. Now, Okabe draws a line with equation . Okabe can select a single rectangle with axis aligned sides with all points on or under the line and cut all the trees in all points that are inside or on the border of this rectangle and take their bananas. Okabe's rectangle can be degenerate; that is, it can be a line segment or even a point.Help Okabe and find the maximum number of bananas he can get if he chooses the rectangle wisely.Okabe is sure that the answer does not exceed 1018. You can trust him.","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['1\\n']}, {'input': '2 2', 'output': ['10\\n']}, {'input': '3 3', 'output': ['36\\n']}, {'input': '4 4', 'output': ['84\\n']}, {'input': '5 5', 'output': ['165\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 1 2\", \"3 4 5\", \"4 1 1\"]","prob_desc_input_spec":"The single line of the input contains three space-separated integers a, b and c (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u2009106) \u2014 the valence numbers of the given atoms.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\n    int a,b,c;\n\n    scanf(\"%d %d %d\",&a,&b,&c);\n\n    int K = (a+b-c)\/2;\n    int K2 = (b+c-a)\/2;\n    if(K >= 0 && K2>= 0 && a- K >=0 && 2*(K + K2 + (a - K)) == (a + b + c))\n    {\n        printf(\"%d %d %d\\n\",K,K2,a-K);\n    }\n    else\n    {\n        printf(\"Impossible\\n\");\n    }\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"0 1 1\", \"1 3 2\", \"Impossible\"]","lang_cluster":"C","code_uid":"a366090ef07a4f4b509430f249fc8947","prob_desc_notes":"NoteThe first sample corresponds to the first figure. There are no bonds between atoms 1 and 2 in this case.The second sample corresponds to the second figure. There is one or more bonds between each pair of atoms.The third sample corresponds to the third figure. There is no solution, because an atom cannot form bonds with itself.The configuration in the fourth figure is impossible as each atom must have at least one atomic bond.","prob_desc_output_spec":"If such a molecule can be built, print three space-separated integers \u2014 the number of bonds between the 1-st and the 2-nd, the 2-nd and the 3-rd, the 3-rd and the 1-st atoms, correspondingly. If there are multiple solutions, output any of them. If there is no solution, print \"Impossible\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Mad scientist Mike is busy carrying out experiments in chemistry. Today he will attempt to join three atoms into one molecule.A molecule consists of atoms, with some pairs of atoms connected by atomic bonds. Each atom has a valence number \u2014 the number of bonds the atom must form with other atoms. An atom can form one or multiple bonds with any other atom, but it cannot form a bond with itself. The number of bonds of an atom in the molecule must be equal to its valence number.  Mike knows valence numbers of the three atoms. Find a molecule that can be built from these atoms according to the stated rules, or determine that it is impossible.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 2', 'output': ['1 1 0\\n']}, {'input': '1 1 1', 'output': ['0 0 1\\n']}, {'input': '3 3 3', 'output': ['1 1 1\\n']}, {'input': '5 5 5', 'output': ['2 2 1\\n']}, {'input': '6 6 6', 'output': ['3 3 0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"12\\ntoosmallword\", \"35\\nTheQuickBrownFoxJumpsOverTheLazyDog\"]","prob_desc_input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of characters in the string. The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main(void)\n{\n  int i,j,n,m=0,k=0;\n  char a[101];\n  while((scanf(\"%d\",&n))!=EOF)\n  {\n      m=0;\n  for(i=0;i<n;i++)\n  {\n    scanf(\" %c\",&a[i]);\n  }\n for(i='a';i<='z';i++)\n  {\n    for(j=0;j<n;j++)\n    {\n      if(i==a[j]||(i-32)==a[j])\n      {\n        m=1;\n      }\n\n    }\n    if(m==1)\n    {\n\n        k++;\n        m=0;\n    }\n   }\n   if(k==26)\n   {\n     printf(\"YES\\n\");\n   }\n   else\n   {\n     printf(\"NO\\n\");\n   }\n   k=0;\n  }\n   return 0;\n}\n\n                         ","prob_desc_sample_outputs":"[\"NO\", \"YES\"]","lang_cluster":"C","code_uid":"742bda22649603fa31ce596e36ecf9ad","prob_desc_notes":null,"prob_desc_output_spec":"Output \"YES\", if the string is a pangram and \"NO\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","length":43,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '26\\nabcdefghijklmnopqrstuvwxyz', 'output': ['YES\\n']}, {'input': '26\\nABCDEFGHIJKLMNOPQRSTUVWXYZ', 'output': ['YES\\n']}, {'input': '27\\naabcdefghijklmnopqrstuvwxyz', 'output': ['YES\\n']}, {'input': '1\\na', 'output': ['NO\\n']}, {'input': '52\\naAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 2 3\", \"8 2 4\"]","prob_desc_input_spec":"The only line contains three integers n,\u2009b,\u2009p (1\u2009\u2264\u2009n,\u2009b,\u2009p\u2009\u2264\u2009500) \u2014 the number of participants and the parameters described in the problem statement.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    int n,b,p,nb,np,temp,count=0,r;\n    scanf(\"%d %d %d\",&n,&b,&p);\n    printf(\"%d %d\",(n-1)*(2*b+1),n*p);\n\n    return 0;\n}\n\n\n","prob_desc_sample_outputs":"[\"20 15\", \"35 32\"]","lang_cluster":"C","code_uid":"47c2647bd343c3a5fb00208e095c8f0f","prob_desc_notes":"NoteIn the first example will be three rounds:  in the first round will be two matches and for each match 5 bottles of water are needed (two for each of the participants and one for the judge),  in the second round will be only one match, so we need another 5 bottles of water,  in the third round will also be only one match, so we need another 5 bottles of water. So in total we need 20 bottles of water.In the second example no participant will move on to some round directly.","prob_desc_output_spec":"Print two integers x and y \u2014 the number of bottles and towels need for the tournament.","prob_desc_output_to":"standard output","prob_desc_description":"A tennis tournament with n participants is running. The participants are playing by an olympic system, so the winners move on and the losers drop out.The tournament takes place in the following way (below, m is the number of the participants of the current round):  let k be the maximal power of the number 2 such that k\u2009\u2264\u2009m,  k participants compete in the current round and a half of them passes to the next round, the other m\u2009-\u2009k participants pass to the next round directly,  when only one participant remains, the tournament finishes. Each match requires b bottles of water for each participant and one bottle for the judge. Besides p towels are given to each participant for the whole tournament.Find the number of bottles and towels needed for the tournament.Note that it's a tennis tournament so in each match two participants compete (one of them will win and the other will lose).","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3 2', 'output': ['57 20']}, {'input': '15 4 5', 'output': ['112 75']}, {'input': '20 2 3', 'output': ['95 60']}, {'input': '25 1 4', 'output': ['72 100']}, {'input': '30 5 6', 'output': ['347 180']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 1 1 2\", \"1 2 3 1\", \"10 2 1 7\"]","prob_desc_input_spec":"The single line contains 4 integers a,\u2009b,\u2009c,\u2009l (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20093\u00b7105, 0\u2009\u2264\u2009l\u2009\u2264\u20093\u00b7105).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#define min(a,b) ((a<b)?a:b)\nlong long cal(long long a,long long b,long long c,long long la,long long l)\n{\n long long x,val=a-b-c+la;\n  if(val<=-1)\n    return 0;\n   x=min(val,l-la);\n  return (x+1)*(x+2)\/2;\n}\nint main()\n{\n long long int i,a,b,c,l;\n  scanf(\"%lld %lld %lld %lld\",&a,&b,&c,&l);\n   unsigned long long ans=(l+3)*(l+2)*(l+1)\/6;\n   for(i=0;i<=l;i++)\n   ans-=cal(a,b,c,i,l); \n   for(i=0;i<=l;i++)\n   ans-=cal(b,a,c,i,l);\n  for(i=0;i<=l;i++)\n   ans-=cal(c,a,b,i,l);\n  printf(\"%llu\\n\",ans);\n return 0;\n}\n","prob_desc_sample_outputs":"[\"4\", \"2\", \"0\"]","lang_cluster":"C","code_uid":"49c66c9c938a33fcbde3599f2813aa8f","prob_desc_notes":"NoteIn the first sample test you can either not increase any stick or increase any two sticks by 1 centimeter.In the second sample test you can increase either the first or the second stick by one centimeter. Note that the triangle made from the initial sticks is degenerate and thus, doesn't meet the conditions.","prob_desc_output_spec":"Print a single integer \u2014 the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you can make a non-degenerate triangle from it.","prob_desc_output_to":"standard output","prob_desc_description":"You are given three sticks with positive integer lengths of a,\u2009b, and c centimeters. You can increase length of some of them by some positive integer number of centimeters (different sticks can be increased by a different length), but in total by at most l centimeters. In particular, it is allowed not to increase the length of any stick.Determine the number of ways to increase the lengths of some sticks so that you can form from them a non-degenerate (that is, having a positive area) triangle. Two ways are considered different, if the length of some stick is increased by different number of centimeters in them.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1 0', 'output': ['1\\n']}, {'input': '2 3 4 1', 'output': ['4\\n']}, {'input': '3 4 5 2', 'output': ['10\\n']}, {'input': '1 2 3 3', 'output': ['20\\n']}, {'input': '5 5 5 5', 'output': ['56\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 1\", \"4 2\", \"4 3\", \"4 0\"]","prob_desc_input_spec":"The only line contains two integers n,\u2009k (1\u2009\u2264\u2009n\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009k\u2009\u2264\u2009106).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#define M 1000000007\nint n,k,i,c,d;\nlong long y,z,u,v,r;\nint F(int a,int b){\n    int r=1;\n    for (;b;b>>=1,a=(long long)a*a%M){\n        if (b&1)r=(long long)r*a%M;\n    }\n    return r;\n}\nint main(){\n    scanf(\"%d%d\",&n,&k);\n    if (!k)r=n;\n    else{\n        if (n<=++k){for(i=1;i<=n;i++)r+=F(i,k-1);}\n        else{\n            for (u=v=1;i<=k;i++){u=(u*(n-i))%M;if (i)v=((v*-i)%M+M)%M;}\n            for (i=0,c=1,d=k;i<=k;i++,c++,d--){\n                z=(z+F(i,k-1))%M;\n                y=u*z%M*F(n-i,M-2)%M*F(v,M-2)%M;\n                v=v*c%M*F(d,M-2)%M;\n                if(i&1)y=M-y;\n                r+=y;\n            }\n        }\n    }\n    printf(\"%lld\\n\",r%M);\n}\n","prob_desc_sample_outputs":"[\"10\", \"30\", \"100\", \"4\"]","lang_cluster":"C","code_uid":"7a0181eece5c766955c7eb2233723b64","prob_desc_notes":null,"prob_desc_output_spec":"Print the only integer a \u2014 the remainder after dividing the value of the sum by the value 109\u2009+\u20097.","prob_desc_output_to":"standard output","prob_desc_description":"There are well-known formulas: , , . Also mathematicians found similar formulas for higher degrees.Find the value of the sum  modulo 109\u2009+\u20097 (so you should find the remainder after dividing the answer by the value 109\u2009+\u20097).","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5', 'output': ['1000000000\\n']}, {'input': '1000000000 1000000', 'output': ['999999937\\n']}, {'input': '500000000 500000', 'output': ['999999937\\n']}, {'input': '100000000 100000', 'output': ['999999937\\n']}, {'input': '1 0', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 5\\n2 3 1 4 4\", \"3 3\\n3 1 2\"]","prob_desc_input_spec":"The first line contains two integer numbers n, m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). The second line contains m integer numbers l1,\u2009l2,\u2009...,\u2009lm (1\u2009\u2264\u2009li\u2009\u2264\u2009n) \u2014 indices of leaders in the beginning of each step.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint arr[101],no[101],l[100];\nint main()\n{\n\tint n,m,source,desti,temp,flag,k,i;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=0;i<m;i++)\n\tscanf(\"%d\",&l[i]);\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tarr[i]=0;\n\t\tno[i]=0;\n\t}\n\tflag=0;\n\tfor(i=0;i<(m-1);i++)\n\t{\n\t\tsource=l[i];\n\t\tdesti=l[i+1];\n\t\tif(desti<=source)\n\t\tdesti=desti+n;\n\t\ttemp=desti-source;\n\t\tif(arr[l[i]]==0)\n\t\t{\n\t\t\tif(no[temp]==1)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tarr[l[i]]=temp;\n\t\t\t\tno[temp]=1;\n\t\t\t}\n\t\t}\n\t\telse if(arr[l[i]]==temp);\n\t\telse\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tk=1;\n\tif(flag==1)\n\tprintf(\"-1\");\n\telse\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(arr[i]==0)\n\t\t\t{\n\t\t\t\twhile(no[k]==1)\n\t\t\t\tk++;\n\t\t\t\tarr[i]=k;\n\t\t\t\tno[k]=1;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%d \",arr[i]);\n\t}\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"3 1 2 4\", \"-1\"]","lang_cluster":"C","code_uid":"e56df9fbf9cf72b99ab1ad069485ac25","prob_desc_notes":"NoteLet's follow leadership in the first example:   Child 2 starts.  Leadership goes from 2 to 2\u2009+\u2009a2\u2009=\u20093.  Leadership goes from 3 to 3\u2009+\u2009a3\u2009=\u20095. As it's greater than 4, it's going in a circle to 1.  Leadership goes from 1 to 1\u2009+\u2009a1\u2009=\u20094.  Leadership goes from 4 to 4\u2009+\u2009a4\u2009=\u20098. Thus in circle it still remains at 4. ","prob_desc_output_spec":"Print such permutation of n numbers a1,\u2009a2,\u2009...,\u2009an that leaders in the game will be exactly l1,\u2009l2,\u2009...,\u2009lm if all the rules are followed. If there are multiple solutions print any of them.  If there is no permutation which satisfies all described conditions print -1.","prob_desc_output_to":"standard output","prob_desc_description":"n children are standing in a circle and playing a game. Children's numbers in clockwise order form a permutation a1,\u2009a2,\u2009...,\u2009an of length n. It is an integer sequence such that each integer from 1 to n appears exactly once in it.The game consists of m steps. On each step the current leader with index i counts out ai people in clockwise order, starting from the next person. The last one to be pointed at by the leader becomes the new leader.You are given numbers l1,\u2009l2,\u2009...,\u2009lm \u2014 indices of leaders in the beginning of each step. Child with number l1 is the first leader in the game. Write a program which will restore a possible permutation a1,\u2009a2,\u2009...,\u2009an. If there are multiple solutions then print any of them. If there is no solution then print -1.","length":62,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5\\n1 2 3 4 5', 'output': ['1 1 1 1 1 ']}, {'input': '6 6\\n1 2 3 4 5 6', 'output': ['1 1 1 1 1 1 ']}, {'input': '7 7\\n1 2 3 4 5 6 7', 'output': ['1 1 1 1 1 1 1 ']}, {'input': '8 8\\n1 2 3 4 5 6 7 8', 'output': ['1 1 1 1 1 1 1 1 ']}, {'input': '9 9\\n1 2 3 4 5 6 7 8 9', 'output': ['1 1 1 1 1 1 1 1 1 ']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5\\n1 1 1 1 2 2 3 2 2 1 1 1\", \"0\\n0 0 0 0 0 0 0 1 1 2 3 0\", \"11\\n1 1 4 1 1 5 1 1 4 1 1 1\"]","prob_desc_input_spec":"The first line contains exactly one integer k (0\u2009\u2264\u2009k\u2009\u2264\u2009100). The next line contains twelve space-separated integers: the i-th (1\u2009\u2264\u2009i\u2009\u2264\u200912) number in the line represents ai (0\u2009\u2264\u2009ai\u2009\u2264\u2009100). ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<stdlib.h>\nint compare(const void *a,const void *b)\n{\n    return ( *(int*)a - *(int *)b );\n}\nint main()\n{\n    int n,i,s=0,p=0,j=0;\n    scanf(\"%d\",&n);\n    int a[12];\n    \n    for(i=0;i<12;i++)\n    scanf(\"%d\",&a[i]);\n    \n    qsort(a,12,sizeof(int),compare);\n \n   if(n!=0)\n{    for(i=11;i>=0;i--)\n    {\n      \n         s=s+a[i];\n         if(s<n)\n           p++;\n         else\n         { p++;\n          j++;\n           break;\n           \n         }\n    }\n    if(j==0)\n    printf(\"-1\");\n    else\n    printf(\"%d\",p);\n}\nelse\nprintf(\"0\");\n  \n}","prob_desc_sample_outputs":"[\"2\", \"0\", \"3\"]","lang_cluster":"C","code_uid":"2d9121405142039fcad3a90b70bf5304","prob_desc_notes":"NoteLet's consider the first sample test. There it is enough to water the flower during the seventh and the ninth month. Then the flower grows by exactly five centimeters.In the second sample Petya's parents will believe him even if the flower doesn't grow at all (k\u2009=\u20090). So, it is possible for Petya not to water the flower at all.","prob_desc_output_spec":"Print the only integer \u2014 the minimum number of months when Petya has to water the flower so that the flower grows no less than by k centimeters. If the flower can't grow by k centimeters in a year, print -1.","prob_desc_output_to":"standard output","prob_desc_description":"What joy! Petya's parents went on a business trip for the whole year and the playful kid is left all by himself. Petya got absolutely happy. He jumped on the bed and threw pillows all day long, until... Today Petya opened the cupboard and found a scary note there. His parents had left him with duties: he should water their favourite flower all year, each day, in the morning, in the afternoon and in the evening. \"Wait a second!\" \u2014 thought Petya. He know for a fact that if he fulfills the parents' task in the i-th (1\u2009\u2264\u2009i\u2009\u2264\u200912) month of the year, then the flower will grow by ai centimeters, and if he doesn't water the flower in the i-th month, then the flower won't grow this month. Petya also knows that try as he might, his parents won't believe that he has been watering the flower if it grows strictly less than by k centimeters. Help Petya choose the minimum number of months when he will water the flower, given that the flower should grow no less than by k centimeters.","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n1 1 1 1 1 1 1 1 1 1 1 1', 'output': ['10\\n']}, {'input': '50\\n5 5 5 5 5 5 5 5 5 5 5 5', 'output': ['10\\n']}, {'input': '0\\n0 0 0 0 0 0 0 0 0 0 0 0', 'output': ['0\\n']}, {'input': '100\\n10 10 10 10 10 10 10 10 10 10 10 10', 'output': ['10\\n']}, {'input': '101\\n10 10 10 10 10 10 10 10 10 10 10 10', 'output': ['-1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 10\\n7 2\\n1\", \"2 2\\n2 1\\n2\"]","prob_desc_input_spec":"The first line contains two integers c and d (1\u2009\u2264\u2009c,\u2009d\u2009\u2264\u2009100)\u00a0\u2014 the number of problems in the main and additional rounds, correspondingly. The second line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). Finally, the third line contains an integer k (1\u2009\u2264\u2009k\u2009\u2264\u2009100)\u00a0\u2014 the number of the pre-chosen winners. ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"\/*!\n * @file    a.c\n * @version 1.0\n * @date    17\/04\/2014\n * @author  Anton Leontiev <bunder@t-25.ru>\n *\n * @copyright\n *\n * Copyright (c) 2014, Anton Leontiev\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *  1. Redistributions of source code must retain the above copyright notice, this list of\n *     conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright notice, this list of\n *     conditions and the following disclaimer in the documentation and\/or other materials\n *     provided with the distribution.\n *  3. Neither the name of Anton Leontiev nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without specific prior written\n *     permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n\nint main(int argc, char *argv[]) {\n\tint a, b, c, d, n, k, m, min = INT_MAX;\n\tscanf(\"%u %u %u %u %u\", &c, &d, &n, &m, &k);\n\tfor (a = 0; a <= m; a++) {\n\t\tb = n * (m - a) - k;\n\t\tb = b > 0 ? b : 0;\n\t\tif (min > a * c + b * d) min = a * c + b * d;\n\t}\n\tprintf(\"%u\\n\", min);\n\treturn EXIT_SUCCESS;\n}\n","prob_desc_sample_outputs":"[\"2\", \"0\"]","lang_cluster":"C","code_uid":"dd7efa70220655828d50742116517ab1","prob_desc_notes":null,"prob_desc_output_spec":"In the first line, print a single integer \u2014 the minimum number of problems the jury needs to prepare.","prob_desc_output_to":"standard output","prob_desc_description":"The finalists of the \"Russian Code Cup\" competition in 2214 will be the participants who win in one of the elimination rounds.The elimination rounds are divided into main and additional. Each of the main elimination rounds consists of c problems, the winners of the round are the first n people in the rating list. Each of the additional elimination rounds consists of d problems. The winner of the additional round is one person. Besides, k winners of the past finals are invited to the finals without elimination.As a result of all elimination rounds at least n\u00b7m people should go to the finals. You need to organize elimination rounds in such a way, that at least n\u00b7m people go to the finals, and the total amount of used problems in all rounds is as small as possible.","length":48,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1\\n1 1\\n1', 'output': ['0\\n']}, {'input': '2 3\\n2 2\\n1', 'output': ['5\\n']}, {'input': '5 2\\n3 3\\n2', 'output': ['16\\n']}, {'input': '10 1\\n5 5\\n5', 'output': ['20\\n']}, {'input': '3 2\\n4 4\\n3', 'output': ['17\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"15 20\", \"14 8\", \"6 6\"]","prob_desc_input_spec":"The first line contains two space-separated integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009109). ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n\ntypedef long long ll;\nll fox(ll a,ll b);\nll gcd(ll a,ll b);\n\n\nint main()\n{\n  ll a,b,c,d;\n  \n  scanf(\"%lld%lld\",&a,&b);\n  \n  d = (a>b)?gcd(a,b):gcd(b,a);\n     \n  c = fox(a\/d,b\/d);\n  \n  printf(\"%lld\",c);\n  \n  return 0;\n\n}\n\n\nll gcd(ll a,ll b)\n{\n if(b==(ll)0)\n   return a;\n   \n return gcd(b,a%b);\n}\n\n\nll fox(ll a,ll b)\n{\n static ll count = (ll)0;\n ll larger,smaller;\n \n if(a==b)\n   return count;\n   \n count += (ll)1;\n \n if(a>b)\n  {\n    larger = a,smaller = b;\n  }\n  \n else\n  {\n    smaller = a,larger = b;\n  }\n  \n if(larger % (ll)2==(ll)0)\n  {\n   if(larger==a)\n     a\/=(ll)2;\n     \n   else\n     b\/=(ll)2;\n \n   return fox(a,b);\n  }\n  \n else if(larger % (ll)3==(ll)0)\n  {\n   if(larger == a)\n     a\/=(ll)3;\n     \n   else\n     b\/=(ll)3;\n     \n   return fox(a,b);\n  }\n  \n else if(larger % (ll)5==(ll)0)\n  {\n   if(larger == a)\n     a\/=(ll)5;\n     \n   else\n     b\/=(ll)5;\n     \n   return fox(a,b);\n  }\n  \n else\n   return -1;\n \n}\n","prob_desc_sample_outputs":"[\"3\", \"-1\", \"0\"]","lang_cluster":"C","code_uid":"f3aa3d57694996c5f6bb7ea0cf723184","prob_desc_notes":null,"prob_desc_output_spec":"If the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.","prob_desc_output_to":"standard output","prob_desc_description":"Two little greedy bears have found two pieces of cheese in the forest of weight a and b grams, correspondingly. The bears are so greedy that they are ready to fight for the larger piece. That's where the fox comes in and starts the dialog: \"Little bears, wait a little, I want to make your pieces equal\" \"Come off it fox, how are you going to do that?\", the curious bears asked. \"It's easy\", said the fox. \"If the mass of a certain piece is divisible by two, then I can eat exactly a half of the piece. If the mass of a certain piece is divisible by three, then I can eat exactly two-thirds, and if the mass is divisible by five, then I can eat four-fifths. I'll eat a little here and there and make the pieces equal\". The little bears realize that the fox's proposal contains a catch. But at the same time they realize that they can not make the two pieces equal themselves. So they agreed to her proposal, but on one condition: the fox should make the pieces equal as quickly as possible. Find the minimum number of operations the fox needs to make pieces equal.","length":90,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5', 'output': ['1\\n']}, {'input': '30 60', 'output': ['1\\n']}, {'input': '100 200', 'output': ['1\\n']}, {'input': '15 45', 'output': ['2\\n']}, {'input': '25 125', 'output': ['2\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1500.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"12\"]","prob_desc_input_spec":"The only line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the prediction on the number of people who will buy the game.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n\tlong long int n;\n\tscanf(\"%lld\",&n);\n\tn=n-n\/2-n\/3-n\/5-n\/7+n\/6+n\/10+n\/14+n\/15+n\/21+n\/35-n\/30-n\/105-n\/42-n\/70+n\/210;\n\tprintf(\"%lld\\n\",n);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"2\"]","lang_cluster":"C","code_uid":"be920453fabb02e87093ed0e72972756","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer showing how many numbers from 1 to n are not divisible by any number from 2 to 10.","prob_desc_output_to":"standard output","prob_desc_description":"IT City company developing computer games decided to upgrade its way to reward its employees. Now it looks the following way. After a new game release users start buying it actively, and the company tracks the number of sales with precision to each transaction. Every time when the next number of sales is not divisible by any number from 2 to 10 every developer of this game gets a small bonus.A game designer Petya knows that the company is just about to release a new game that was partly developed by him. On the basis of his experience he predicts that n people will buy the game during the first month. Now Petya wants to determine how many times he will get the bonus. Help him to know it.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1']}, {'input': '10', 'output': ['2']}, {'input': '100', 'output': ['20']}, {'input': '1000', 'output': ['200']}, {'input': '10000', 'output': ['2000']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"21 5\", \"9435152 272\", \"10 10\"]","prob_desc_input_spec":"In the only line of the input two space-separated integers a and b (0\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009109) are given.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main(void)\n{\n    int a, b, c, i, ans = 0;\n    scanf(\"%d%d\", &a, &b);\n    c = a - b;\n    if (c == 0)\n    {\n        printf(\"infinity\");\n        return 0;\n    }\n\n    for (i = 1; i * i <= c; i++)\n    {\n        if (c % i == 0)\n        {\n            if (i > b)\n                ans++;\n            if ((c \/ i != i) && (c \/ i > b))\n                ans++;\n        }\n    }\n\n    printf(\"%d\", ans);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"282\", \"infinity\"]","lang_cluster":"C","code_uid":"bf1ca52fa974ce64075f88bdb79e8ad5","prob_desc_notes":"NoteIn the first sample the answers of the Modular Equation are 8 and 16 since ","prob_desc_output_spec":"If there is an infinite number of answers to our equation, print \"infinity\" (without the quotes). Otherwise print the number of solutions of the Modular Equation .","prob_desc_output_to":"standard output","prob_desc_description":"Last week, Hamed learned about a new type of equations in his math class called Modular Equations. Lets define i modulo j as the remainder of division of i by j and denote it by . A Modular Equation, as Hamed's teacher described, is an equation of the form  in which a and b are two non-negative integers and x is a variable. We call a positive integer x for which  a solution of our equation.Hamed didn't pay much attention to the class since he was watching a movie. He only managed to understand the definitions of these equations.Now he wants to write his math exercises but since he has no idea how to do that, he asked you for help. He has told you all he knows about Modular Equations and asked you to write a program which given two numbers a and b determines how many answers the Modular Equation  has.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '15 5', 'output': ['1']}, {'input': '100 50', 'output': ['2']}, {'input': '25 25', 'output': ['infinity']}, {'input': '0 0', 'output': ['infinity']}, {'input': '1000000000 500000000', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1\", \"10\"]","prob_desc_input_spec":"A single line contains a single integer x (1\u2009\u2264\u2009x\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint x_digit[10], d_digit[10], count;\n\nvoid find_digits(int *digit, int num) {\n\tint i;\n\tfor (i = 0; i < 10; i++)\n\t\tdigit[i] = 0;\n\twhile (num > 0) {\n\t\tdigit[num%10] = 1;\n\t\tnum \/= 10;\n\t}\n}\n\nvoid check(int d) {\n\tint i;\n\tfind_digits(d_digit, d);\n\tfor (i = 0; i < 10; i++)\n\t\tif (x_digit[i] && d_digit[i]) {\n\t\t\tcount++;\n\t\t\tbreak;\n\t\t}\n}\n\nint main() {\n\tint x, d;\n\tscanf(\" %d\", &x);\n\tfind_digits(x_digit, x);\n\tfor (d = 1; d*d <= x; d++) {\n\t\tif (x%d > 0)\n\t\t\tcontinue;\n\t\tcheck(d);\n\t\tif (x\/d != d)\n\t\t\tcheck(x\/d);\n\t}\n\tprintf(\"%d\\n\", count);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"2\"]","lang_cluster":"C","code_uid":"5fed3f30c6d760f516615715a1e7a3d1","prob_desc_notes":null,"prob_desc_output_spec":"In a single line print an integer \u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"The Little Elephant loves numbers. He has a positive integer x. The Little Elephant wants to find the number of positive integers d, such that d is the divisor of x, and x and d have at least one common (the same) digit in their decimal representations. Help the Little Elephant to find the described number.","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '100', 'output': ['3\\n']}, {'input': '123', 'output': ['4\\n']}, {'input': '111', 'output': ['1\\n']}, {'input': '999', 'output': ['3\\n']}, {'input': '789', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"abcd\", \"ababa\", \"zzz\"]","prob_desc_input_spec":"The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint main()\n{\n    char s[100];\n    scanf(\"%s\",s);\n\n\n\n\n    int l = strlen(s);\n    int len = 0;\n\n    for(int i = 0; i<l; i++)\n    {\n        for(int j = i+1; j<l; j++)\n        {\n            int n = 0;\n            while(s[i+n] == s[j+n])\n                n++;\n            if(n>len)\n                len = n;\n        }\n    }\n\n    printf(\"%d\\n\",len);\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"0\", \"3\", \"2\"]","lang_cluster":"C","code_uid":"3f1473b75e501f802593e723cc2aecb1","prob_desc_notes":null,"prob_desc_output_spec":"Output one number \u2014 length of the longest substring that can be met in the string at least twice.","prob_desc_output_to":"standard output","prob_desc_description":"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'abcabc', 'output': ['3']}, {'input': 'aaaaaa', 'output': ['5']}, {'input': 'abcdefg', 'output': ['0']}, {'input': 'abccba', 'output': ['2']}, {'input': 'abcdeabc', 'output': ['3']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"7 3\\n3 5 7 1 6 2 8\\n1 2 7\", \"4 4\\n3 4 1 0\\n0 1 7 9\"]","prob_desc_input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 10$$$) representing the number of digits in the sequence you have and the number of keys on the keypad that have fingerprints. The next line contains $$$n$$$ distinct space-separated integers $$$x_1, x_2, \\ldots, x_n$$$ ($$$0 \\le x_i \\le 9$$$) representing the sequence. The next line contains $$$m$$$ distinct space-separated integers $$$y_1, y_2, \\ldots, y_m$$$ ($$$0 \\le y_i \\le 9$$$) \u2014 the keys with fingerprints.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<stdlib.h>\n\n\nint main()\n{\n  int n1,n2,a1[100],a2[100];\n  scanf(\"%d%d\",&n1,&n2);\n  for(int i=0;i<n1;i++)\n  {\n    scanf(\"%d\",&a1[i]);\n    \n  }\n\n  for(int i=0;i<n2;i++)\n  {\n    scanf(\"%d\",&a2[i]);\n  }\n\n\n  for(int i=0;i<n1;i++)\n  {\n    for(int j=0;j<n2;j++)\n    {\n      if(a1[i]==a2[j]) printf(\"%d \",a1[i]);\n    }\n  }\n}\n","prob_desc_sample_outputs":"[\"7 1 2\", \"1 0\"]","lang_cluster":"C","code_uid":"55d5486b8845fc3c33a6404d31e2fb79","prob_desc_notes":"NoteIn the first example, the only digits with fingerprints are $$$1$$$, $$$2$$$ and $$$7$$$. All three of them appear in the sequence you know, $$$7$$$ first, then $$$1$$$ and then $$$2$$$. Therefore the output is 7 1 2. Note that the order is important, and shall be the same as the order in the original sequence.In the second example digits $$$0$$$, $$$1$$$, $$$7$$$ and $$$9$$$ have fingerprints, however only $$$0$$$ and $$$1$$$ appear in the original sequence. $$$1$$$ appears earlier, so the output is 1 0. Again, the order is important.","prob_desc_output_spec":"In a single line print a space-separated sequence of integers representing the code. If the resulting sequence is empty, both printing nothing and printing a single line break is acceptable.","prob_desc_output_to":"standard output","prob_desc_description":"You are locked in a room with a door that has a keypad with 10 keys corresponding to digits from 0 to 9. To escape from the room, you need to enter a correct code. You also have a sequence of digits.Some keys on the keypad have fingerprints. You believe the correct code is the longest not necessarily contiguous subsequence of the sequence you have that only contains digits with fingerprints on the corresponding keys. Find such code.","length":28,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2\\n1 2 3 4 5\\n2 4', 'output': ['2 4 ']}, {'input': '6 3\\n0 1 2 3 4 5\\n0 2 4', 'output': ['0 2 4 ']}, {'input': '7 3\\n3 5 7 1 6 2 8\\n1 2 7', 'output': ['7 1 2 ']}, {'input': '4 4\\n3 4 1 0\\n0 1 7 9', 'output': ['1 0 ']}, {'input': '10 5\\n0 1 2 3 4 5 6 7 8 9\\n0 2 4 6 8', 'output': ['0 2 4 6 8 ']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1 1 0 1\", \"6\\n0 1 0 0 1 0\", \"1\\n0\"]","prob_desc_input_spec":"The first line contains one integer number n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n space-separated integer numbers s1,\u2009s2,\u2009...,\u2009sn (0\u2009\u2264\u2009si\u2009\u2264\u20091). 0 corresponds to an unsuccessful game, 1 \u2014 to a successful one.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint countzeroes(int x, int s[])\n{\n\tint count=0;\n\tfor(int j=0;j<=x;j++){\n\t\tif(s[j]==0)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\nint countones(int x, int s[])\n{\n\tint count=0;\n\tfor(int j=0;j<=x;j++){\n\t\tif(s[j]==1)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\nint main(void) {\n\tint n,i;  \/\/n is the total number of games.\n\tscanf(\"%d\",&n);\n\t\n\tint s[n];\n\tfor(i=0;i<n;i++)\n\t\tscanf(\"%d\",&s[i]);\n\t\t\n\t\/*for(i=0;i<n;i++)\n\t\tprintf(\"%d\",s[i]); *\/\n\t\t\n\tint zeroes,ones;\n\tzeroes=countzeroes(n-1,s);\n\tones=countones(n-1,s);\n\t\n\tint zero[zeroes],x,y,counter=0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[i]==0){\n\t\t\tx=countzeroes(i,s);\n\t\t\ty=ones-countones(i,s);\n\t\t\t\/\/printf(\"%d %d   %d\\n\",x,y,x+y);\n\t\t\tzero[counter]=x+y;\n\t\t\tcounter++;\n\t\t}\n\t}\n\t\n\t\/*for(i=0;i<zeroes;i++)\n\t\tprintf(\"%d\",zero[i]);\n\tprintf(\"\\n\");*\/\n\t\n\tint ans;\n\tif(zeroes>ones)\n\t\tans=zeroes;\n\telse\n\t\tans=ones;\n\t\n\t\/\/printf(\"ans is %d \\n\", ans);\n\t\t\n\tfor(i=0;i<zeroes;i++){\n\t\tif(zero[i]>ans)\n\t\t\tans=zero[i];\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"3\", \"4\", \"1\"]","lang_cluster":"C","code_uid":"d1d6257f91fbbd267127477970d88022","prob_desc_notes":null,"prob_desc_output_spec":"Print one integer \u2014 the maximum number of games Hideo can leave in his CV so that no unsuccessful game comes after a successful one.","prob_desc_output_to":"standard output","prob_desc_description":"Hideo Kojima has just quit his job at Konami. Now he is going to find a new place to work. Despite being such a well-known person, he still needs a CV to apply for a job.During all his career Hideo has produced n games. Some of them were successful, some were not. Hideo wants to remove several of them (possibly zero) from his CV to make a better impression on employers. As a result there should be no unsuccessful game which comes right after successful one in his CV.More formally, you are given an array s1,\u2009s2,\u2009...,\u2009sn of zeros and ones. Zero corresponds to an unsuccessful game, one \u2014 to a successful one. Games are given in order they were produced, and Hideo can't swap these values. He should remove some elements from this array in such a way that no zero comes right after one.Besides that, Hideo still wants to mention as much games in his CV as possible. Help this genius of a man determine the maximum number of games he can leave in his CV.","length":68,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 0 1 0 1', 'output': ['3\\n']}, {'input': '10\\n1 1 1 1 1 0 0 0 0 0', 'output': ['5\\n']}, {'input': '7\\n0 0 0 1 1 1 0', 'output': ['4\\n']}, {'input': '3\\n1 0 1', 'output': ['2\\n']}, {'input': '2\\n0 1', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1\", \"3\"]","prob_desc_input_spec":"The only line contains single integer: 1\u2009\u2264\u2009n\u2009\u2264\u20091000 \u2014 number of hassocks.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\/\/#include <string.h>\nint main()\n{\n    int n,i,j,f=0;\n\n   scanf(\"%d\",&n);\n   int *a=(int *)calloc(n+1,sizeof(int));\n   a[1]=1;\n   j=1;\n   for(i=1;i<n;i++)\n   {\n       if((i+j)<=n)\n       {\n           a[i+j]=1;\n            j=j+i;\n       }\n       else\n       {\n           a[i+j-n]=1;\n           j=j+i-n;\n       }\n     \/\/  printf(\"j=%d\\n\",j);\n\n   }\n   for(i=1;i<=n;i++)\n   {\n       if(a[i]!=1)\n       {\n           f=1;\n           break;\n       }\n   }\n   if(f==1)\n   {\n       printf(\"NO\");\n   }\n   else printf(\"YES\");\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"C","code_uid":"df1f5b2382683675bc9edee2a9a15a99","prob_desc_notes":null,"prob_desc_output_spec":"Output \"YES\" if all the hassocks will be visited and \"NO\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"A flea is sitting at one of the n hassocks, arranged in a circle, at the moment. After minute number k the flea jumps through k\u2009-\u20091 hasso\u0441ks (clockwise). For example, after the first minute the flea jumps to the neighboring hassock. You should answer: will the flea visit all the hassocks or not. We assume that flea has infinitely much time for this jumping.","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2', 'output': ['YES']}, {'input': '4', 'output': ['YES']}, {'input': '5', 'output': ['NO']}, {'input': '8', 'output': ['YES']}, {'input': '10', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 4 3\", \"1 1 1\", \"2 3 3\"]","prob_desc_input_spec":"The single line contains three integers r, g and b (0\u2009\u2264\u2009r,\u2009g,\u2009b\u2009\u2264\u20092\u00b7109) \u2014 the number of red, green and blue baloons respectively. The numbers are separated by exactly one space.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint main(void)\n{\n    int r, g, bb;\n    long long int a, b, c;\n    \n    for (;;) {\n        if (scanf(\" %d %d %d\", &r, &g, &bb) != 3)\n            return 0;\n        if (r >= g && r >= bb) {\n            a = r;\n            if (g >= bb) {\n                b = g;\n                c = bb;\n            } else {\n                b = bb;\n                c = g;\n            }\n        } else if (g >= bb) {\n            a = g;\n            if (r >= bb) {\n                b = r;\n                c = bb;\n            } else {\n                b = bb;\n                c = r;\n            }\n        } else {\n            a = bb;\n            if (r >= g) {\n                b = r;\n                c = g;\n            } else {\n                b = g;\n                c = r;\n            }\n        }\n        if (a >= ((b + c) * 2)) {\n            printf(\"%ld\\n\", (long int)(b+c));\n        } else {\n            printf(\"%ld\\n\", (long int)( c + ((a - c) + (b - c)) \/ 3) );\n        }\n    }\n\n    return 0;\n\n}","prob_desc_sample_outputs":"[\"4\", \"1\", \"2\"]","lang_cluster":"C","code_uid":"9df60d4723ddf422292947050250bb62","prob_desc_notes":"NoteIn the first sample you can decorate the tables with the following balloon sets: \"rgg\", \"gbb\", \"brr\", \"rrg\", where \"r\", \"g\" and \"b\" represent the red, green and blue balls, respectively.","prob_desc_output_spec":"Print a single integer t \u2014 the maximum number of tables that can be decorated in the required manner.","prob_desc_output_to":"standard output","prob_desc_description":"You have r red, g green and b blue balloons. To decorate a single table for the banquet you need exactly three balloons. Three balloons attached to some table shouldn't have the same color. What maximum number t of tables can be decorated if we know number of balloons of each color?Your task is to write a program that for given values r, g and b will find the maximum number t of tables, that can be decorated in the required manner.","length":48,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 0', 'output': ['0\\n']}, {'input': '1 2 3', 'output': ['2\\n']}, {'input': '5 5 5', 'output': ['5\\n']}, {'input': '10 20 30', 'output': ['20\\n']}, {'input': '100 200 300', 'output': ['200\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 5 3 2\", \"7 5 5 2\"]","prob_desc_input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2009\u2264\u2009n,\u2009a,\u2009b,\u2009c\u2009\u2264\u20094000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\n\nint main()\n{\n    int n,a[3],i;\n    scanf(\"%d %d %d %d\",&n,&a[0],&a[1],&a[2]);\n\n    int dp[n];\n    for(i=0;i<n;i++){dp[i] = -1;}\n\n    int j,c;\n    for(i=0;i<3;i++)\n    {\n        j = 1;\n        while(a[i]*j <= n)\n        {\n            if(dp[a[i]*j - 1]==(-1)){dp[a[i]*j - 1] = j;}\n            for(c=0;c<n;c++)\n            {\n                if(dp[c]!=(-1) && c+a[i]*j < n)\n                    { if(dp[c + a[i]*j] < dp[c] + j)\n                    {dp[c + a[i]*j] = dp[c] + j;}}\n            }\n            j++;\n        }\n    }\n\n    printf(\"%d\",dp[n-1]);\n\n    return 0;\n}","prob_desc_sample_outputs":"[\"2\", \"2\"]","lang_cluster":"C","code_uid":"9d0ee81107ff49ccdc5d031e9a1f0b16","prob_desc_notes":"NoteIn the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.","prob_desc_output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","length":32,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 2 3 5', 'output': ['5\\n']}, {'input': '15 3 5 7', 'output': ['5\\n']}, {'input': '20 4 5 6', 'output': ['5\\n']}, {'input': '25 5 7 8', 'output': ['5\\n']}, {'input': '30 6 7 8', 'output': ['5\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\", \"20\"]","prob_desc_input_spec":"The first line of the input contains a positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20092\u00b7109) \u2014 the length of Pasha's stick.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nint main(void)\n{\n\tlong int n;\n\tscanf(\"%ld\",&n);\n\tif(n<=3)\n\tprintf(\"0\");\n\telse\n\t{\n\t\tif(n%2==0)\n\t\t{\n\tn=n\/2;\n\tif(n%2==0)\n\tprintf(\"%d\",(n-2)\/2);\n\telse\n\tprintf(\"%d\",(n-1)\/2);\n}\nelse\nprintf(\"0\");\n}\n\t\n\t\n}\n","prob_desc_sample_outputs":"[\"1\", \"4\"]","lang_cluster":"C","code_uid":"590b7d2d7b94f3e78c85de87ce3a3db3","prob_desc_notes":"NoteThere is only one way to divide the stick in the first sample {1, 1, 2, 2}.Four ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.","prob_desc_output_spec":"The output should contain a single integer\u00a0\u2014 the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square. ","prob_desc_output_to":"standard output","prob_desc_description":"Pasha has a wooden stick of some positive integer length n. He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be n. Pasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.Your task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer x, such that the number of parts of length x in the first way differ from the number of parts of length x in the second way.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '8\\n', 'output': ['1\\n']}, {'input': '16\\n', 'output': ['3\\n']}, {'input': '24\\n', 'output': ['5\\n']}, {'input': '3\\n', 'output': ['0\\n']}, {'input': '5\\n', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 0.50 1\", \"1 0.50 4\", \"4 0.20 2\"]","prob_desc_input_spec":"The first line of the input contains three numbers n,\u2009p,\u2009t (1\u2009\u2264\u2009n,\u2009t\u2009\u2264\u20092000, 0\u2009\u2264\u2009p\u2009\u2264\u20091). Numbers n and t are integers, number p is real, given with exactly two digits after the decimal point.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\ndouble prob[2005][2005];\nint main()\n{\n      int n,t,i,j;\n      double p,cp;\n      double tmp;\n      scanf(\"%d\",&n);\n      scanf(\"%lf\",&p);\n      scanf(\"%d\",&t);\n      cp = 1.0-p;\n      prob[0][0] = 1.0;\n      for(i=1;i<=t;i++)\n      prob[0][i] = 0.0;\n      for(i=1;i<=t;i++)\n      prob[i][0] = prob[i-1][0]*(cp);\n      for(i=1;i<=t;i++)\n      {\n           for(j=1;j<=t;j++)\n           {\n                 if(j>i||j>n)\n                 tmp = 0.0;\n                 else if(j+1<=n)\n                 tmp = cp*prob[i-1][j] + prob[i-1][j-1]*p;\n                 else \n                 tmp = prob[i-1][j] + prob[i-1][j-1]*p;\n                 prob[i][j] = tmp;\n           }\n      }\n      double res = 0;\n      for(i=0;i<=t;i++)\n      {\n           res+=i*prob[t][i];\n      }\n      printf(\"%lf\\n\",res);\n      return 0;\n}","prob_desc_sample_outputs":"[\"0.5\", \"0.9375\", \"0.4\"]","lang_cluster":"C","code_uid":"5250bf56aea88a78d61f84822e1d022f","prob_desc_notes":null,"prob_desc_output_spec":"Print a single real number \u2014 the expected number of people who will be standing on the escalator after t seconds. The absolute or relative error mustn't exceed 10\u2009-\u20096.","prob_desc_output_to":"standard output","prob_desc_description":"Ilya got tired of sports programming, left university and got a job in the subway. He was given the task to determine the escalator load factor. Let's assume that n people stand in the queue for the escalator. At each second one of the two following possibilities takes place: either the first person in the queue enters the escalator with probability p, or the first person in the queue doesn't move with probability (1\u2009-\u2009p), paralyzed by his fear of escalators and making the whole queue wait behind him.Formally speaking, the i-th person in the queue cannot enter the escalator until people with indices from 1 to i\u2009-\u20091 inclusive enter it. In one second only one person can enter the escalator. The escalator is infinite, so if a person enters it, he never leaves it, that is he will be standing on the escalator at any following second. Ilya needs to count the expected value of the number of people standing on the escalator after t seconds. Your task is to help him solve this complicated task.","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 0.50 1', 'output': ['0.500000\\n']}, {'input': '2 0.50 2', 'output': ['1.500000\\n']}, {'input': '3 0.33 3', 'output': ['1.481481\\n']}, {'input': '4 0.25 4', 'output': ['1.937500\\n']}, {'input': '5 0.20 5', 'output': ['2.488320\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2300.0,"prob_desc_time_limit":"5 seconds","prob_desc_sample_inputs":"[\"2 2 1\", \"2 2 2\", \"3 2 2\"]","prob_desc_input_spec":"The first line contains space-separated integers n, m and k (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009k\u2009\u2264\u2009106) \u2014 the board's vertical and horizontal sizes and the number of colors respectively.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#define mod 1000000007\n\nint f[1001],c[1001][1001],r1[1001],r2[2001];\n\nint mi(int a,long long b)\n{\n   int t;\n   if (!b)\n      return 1;\n   t=mi(a,b>>1);\n   t=(long long)t*t%mod;\n   if (b&1)\n      t=(long long)t*a%mod;\n   return t;\n}\n\nint main()\n{\n   int i,j,n,m,k,x,s=0,t=1;\n   scanf(\"%d%d%d\",&n,&m,&k);\n   if (m==1)\n      s=mi(k,n);\n   else\n   {\n      for (i=0;i<=n;i++)\n      {\n         c[i][0]=1;\n         for (j=1;j<=i;j++)\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n      }\n      for (i=1;i<=n;i++)\n      {\n         f[i]=mi(i,n);\n         for (j=1;j<i;j++)\n            f[i]=(f[i]-(long long)f[j]*c[i][j]%mod+mod)%mod;\n      }\n      r1[0]=r2[0]=1;\n      for (i=1;i<=n;i++)\n         r1[i]=(long long)r1[i-1]*mi(i,mod-2)%mod;\n      for (i=1;i<=2*n&&i<=k;i++)\n         r2[i]=(long long)r2[i-1]*(k-i+1)%mod;\n      for (i=0;i<=n;i++)\n      {\n         x=mi(i,(long long)(m-2)*n);\n         for (j=0;i+j<=n&&i+2*j<=k;j++)\n            s=(s+(long long)r2[2*j+i]*r1[j]%mod*r1[j]%mod*r1[i]%mod*f[i+j]%mod*f[i+j]%mod*x)%mod;\n      }\n   }\n   printf(\"%d\\n\",s);\n   return 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"8\", \"40\"]","lang_cluster":"C","code_uid":"6b4a23b47fb33656efee2d4b9b4cff66","prob_desc_notes":null,"prob_desc_output_spec":"Print the answer to the problem. As the answer can be quite a large number, you should print it modulo 109\u2009+\u20097 (1000000007).","prob_desc_output_to":"standard output","prob_desc_description":"Little Petya loves counting. He wants to count the number of ways to paint a rectangular checkered board of size n\u2009\u00d7\u2009m (n rows, m columns) in k colors. Besides, the coloring should have the following property: for any vertical line that passes along the grid lines and divides the board in two non-empty parts the number of distinct colors in both these parts should be the same. Help Petya to count these colorings.","length":52,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['1\\n']}, {'input': '2 2 3', 'output': ['72\\n']}, {'input': '3 3 3', 'output': ['19683\\n']}, {'input': '4 4 2', 'output': ['256\\n']}, {'input': '5 5 1', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"8 6 4 5\", \"8 6 4 6\", \"10 3 11 4\", \"4 2 1 4\"]","prob_desc_input_spec":"The only line contains four integers n, t, k, d (1\u2009\u2264\u2009n,\u2009t,\u2009k,\u2009d\u2009\u2264\u20091\u2009000)\u00a0\u2014 the number of cakes needed, the time needed for one oven to bake k cakes, the number of cakes baked at the same time, the time needed to build the second oven. ","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int n,t,k,d;\n    scanf(\"%d%d%d%d\",&n,&t,&k,&d);\n    int ans=((d\/t)+1)*k;\n        if(ans<n)\n            printf(\"YES\");\n        else\n            printf(\"NO\");\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"NO\", \"YES\"]","lang_cluster":"C","code_uid":"cfab02f5b219be73be6658d39b3d2160","prob_desc_notes":"NoteIn the first example it is possible to get 8 cakes in 12 minutes using one oven. The second oven can be built in 5 minutes, so after 6 minutes the first oven bakes 4 cakes, the second oven bakes 4 more ovens after 11 minutes. Thus, it is reasonable to build the second oven. In the second example it doesn't matter whether we build the second oven or not, thus it takes 12 minutes to bake 8 cakes in both cases. Thus, it is unreasonable to build the second oven.In the third example the first oven bakes 11 cakes in 3 minutes, that is more than needed 10. It is unreasonable to build the second oven, because its building takes more time that baking the needed number of cakes using the only oven.","prob_desc_output_spec":"If it is reasonable to build the second oven, print \"YES\". Otherwise print \"NO\".","prob_desc_output_to":"standard output","prob_desc_description":"In some game by Playrix it takes t minutes for an oven to bake k carrot cakes, all cakes are ready at the same moment t minutes after they started baking. Arkady needs at least n cakes to complete a task, but he currently don't have any. However, he has infinitely many ingredients and one oven. Moreover, Arkady can build one more similar oven to make the process faster, it would take d minutes to build the oven. While the new oven is being built, only old one can bake cakes, after the new oven is built, both ovens bake simultaneously. Arkady can't build more than one oven.Determine if it is reasonable to build the second oven, i.e. will it decrease the minimum time needed to get n cakes or not. If the time needed with the second oven is the same as with one oven, then it is unreasonable.","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3 2 4', 'output': ['NO\\n']}, {'input': '12 5 4 3', 'output': ['YES\\n']}, {'input': '15 7 5 6', 'output': ['YES\\n']}, {'input': '20 10 5 9', 'output': ['NO\\n']}, {'input': '7 2 3 1', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 2 2\\n1 1 1\\n1 2 3 4 5 6\", \"0 0 10\\n3 2 3\\n1 2 3 4 5 6\"]","prob_desc_input_spec":"The fist input line contains three space-separated integers x, y and z (|x|,\u2009|y|,\u2009|z|\u2009\u2264\u2009106) \u2014 the coordinates of Vasya's position in space. The second line contains three space-separated integers x1, y1, z1 (1\u2009\u2264\u2009x1,\u2009y1,\u2009z1\u2009\u2264\u2009106) \u2014 the coordinates of the box's vertex that is opposite to the vertex at point (0,\u20090,\u20090). The third line contains six space-separated integers a1,\u2009a2,\u2009...,\u2009a6 (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the numbers that are written on the box faces.  It is guaranteed that point (x,\u2009y,\u2009z) is located strictly outside the box.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n\nint main(void){\n  int x,y,z,x0,y0,z0;\n  int a[6],*p=a-1;\n  int i,j,k,num=0;\n\n  scanf(\"%d%d%d\",&x,&y,&z);\n  scanf(\"%d%d%d\",&x0,&y0,&z0);\n  for(i=1;i<=6;i++) scanf(\"%d\",p+i);\n  \n  if(y<0) num+=p[1];\n  else if(y>y0) num+=p[2];\n\n  if(z<0) num+=p[3];\n  else if(z>z0) num+=p[4];\n\n  if(x<0) num+=p[5];\n  else if(x>x0) num+=p[6];\n\n  printf(\"%d\\n\",num);\n  return 0;\n}\n","prob_desc_sample_outputs":"[\"12\", \"4\"]","lang_cluster":"C","code_uid":"fc001df465241129a674a61803f45c23","prob_desc_notes":"NoteThe first sample corresponds to perspective, depicted on the picture. Vasya sees numbers a2 (on the top face that is the darkest), a6 (on the right face that is the lightest) and a4 (on the left visible face).In the second sample Vasya can only see number a4.","prob_desc_output_spec":"Print a single integer \u2014 the sum of all numbers on the box faces that Vasya sees.","prob_desc_output_to":"standard output","prob_desc_description":"One day Vasya was going home when he saw a box lying on the road. The box can be represented as a rectangular parallelepiped. Vasya needed no time to realize that the box is special, as all its edges are parallel to the coordinate axes, one of its vertices is at point (0,\u20090,\u20090), and the opposite one is at point (x1,\u2009y1,\u2009z1). The six faces of the box contain some numbers a1,\u2009a2,\u2009...,\u2009a6, exactly one number right in the center of each face.  The numbers are located on the box like that:   number a1 is written on the face that lies on the ZOX plane;  a2 is written on the face, parallel to the plane from the previous point;  a3 is written on the face that lies on the XOY plane;  a4 is written on the face, parallel to the plane from the previous point;  a5 is written on the face that lies on the YOZ plane;  a6 is written on the face, parallel to the plane from the previous point. At the moment Vasya is looking at the box from point (x,\u2009y,\u2009z). Find the sum of numbers that Vasya sees. Note that all faces of the box are not transparent and Vasya can't see the numbers through the box. The picture contains transparent faces just to make it easier to perceive. You can consider that if Vasya is looking from point, lying on the plane of some face, than he can not see the number that is written on this face. It is enough to see the center of a face to see the corresponding number for Vasya. Also note that Vasya always reads correctly the ai numbers that he sees, independently of their rotation, angle and other factors (that is, for example, if Vasya sees some ai\u2009=\u20096, then he can't mistake this number for 9 and so on). ","length":23,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 2\\n1 1 1\\n1 2 3 4 5 6', 'output': ['12\\n']}, {'input': '0 0 10\\n3 2 3\\n1 2 3 4 5 6', 'output': ['4\\n']}, {'input': '-1 -1 -1\\n1 1 1\\n1 2 3 4 5 6', 'output': ['15\\n']}, {'input': '2 0 0\\n1 1 1\\n1 2 3 4 5 6', 'output': ['6\\n']}, {'input': '0 2 0\\n1 1 1\\n1 2 3 4 5 6', 'output': ['2\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\n1 2 6\", \"10\\n1 2 3 4 5\"]","prob_desc_input_spec":"The first line of the input contains one integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100, n is even) \u2014 the size of the chessboard.  The second line of the input contains  integer numbers  (1\u2009\u2264\u2009pi\u2009\u2264\u2009n) \u2014 initial positions of the pieces. It is guaranteed that all the positions are distinct.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nint v[51];\nint main(){\n    int n, i, aux, f, cn, s, s2;\n    s=s2=0;\n    scanf(\"%d\", &n);\n    cn=n\/2;\n    for(i=0; i<cn; i++)\n      scanf(\"%d\", &v[i]);\n    f=0;\n    while(f==0){\n      f=1;\n      for(i=0; i<cn-1; i++)\n        if(v[i]>v[i+1]){\n          aux=v[i];\n          v[i]=v[i+1];\n          v[i+1]=aux;\n          f=0;\n        }\n    }\n    for(i=1; i<=n; i+=2)\n      s=s+abs(v[(i-1)\/2]-i);\n    for(i=2; i<=n; i+=2)\n      s2=s2+abs(v[(i-2)\/2]-i);\n    if(s>s2)\n      printf(\"%d\", s2);\n    else\n      printf(\"%d\", s);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"10\"]","lang_cluster":"C","code_uid":"ed1a2d330d155d04ccc924d5cb9af7d4","prob_desc_notes":"NoteIn the first example the only possible strategy is to move the piece at the position 6 to the position 5 and move the piece at the position 2 to the position 3. Notice that if you decide to place the pieces in the white cells the minimum number of moves will be 3.In the second example the possible strategy is to move  in 4 moves, then  in 3 moves,  in 2 moves and  in 1 move.","prob_desc_output_spec":"Print one integer \u2014 the minimum number of moves you have to make to place all the pieces in the cells of the same color.","prob_desc_output_to":"standard output","prob_desc_description":"You are given a chessboard of size 1\u2009\u00d7\u2009n. It is guaranteed that n is even. The chessboard is painted like this: \"BWBW...BW\".Some cells of the board are occupied by the chess pieces. Each cell contains no more than one chess piece. It is known that the total number of pieces equals to .In one step you can move one of the pieces one cell to the left or to the right. You cannot move pieces beyond the borders of the board. You also cannot move pieces to the cells that are already occupied.Your task is to place all the pieces in the cells of the same color using the minimum number of moves (all the pieces must occupy only the black cells or only the white cells after all the moves are made).","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '8\\n1 2 3 4 5 6 7 8', 'output': ['16\\n']}, {'input': '4\\n1 2 3 4', 'output': ['4\\n']}, {'input': '10\\n1 3 5 7 9', 'output': ['10\\n']}, {'input': '6\\n1 3 5', 'output': ['3\\n']}, {'input': '2\\n1', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"6 1\", \"4 2\"]","prob_desc_input_spec":"The first line contains a pair of integers n and t (3\u2009\u2264\u2009n\u2009\u2264\u200920, 1\u2009\u2264\u2009t\u2009\u2264\u200910).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint dp[21][12][5][5];\n\nint main() {\n\tint i,j,k,l,x,n,t;;\n\tscanf(\"%d %d\\n\",&n,&t);\n\tfor (i=1;i<4;i++)\n\t\tfor (j=i+1;j<=4;j++)\n\t\t\tdp[2][0][i][j]=1;\n\tfor (x=3;x<=n;x++)\n\t\tfor (i=1;i<=4;i++)\n\t\t\tfor (j=1;j<=4;j++)\n\t\t\t\tif (i!=j) for (k=1;k<=4;k++)\n\t\t\t\t\tif (j!=k) for (l=0;l<=t;l++)\n\t\t\t\t\t\tif (i<j&&j>k) dp[x][l+1][j][k]+=dp[x-1][l][i][j];\n\t\t\t\t\t\telse dp[x][l][j][k]+=dp[x-1][l][i][j];\n\tint cnt=0;\n\tfor (i=2;i<=4;i++)\n\t\tfor (j=1;j<i;j++)\n\t\t\tcnt+=dp[n][t][i][j];\n\tprintf(\"%d\\n\",cnt);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"6\", \"0\"]","lang_cluster":"C","code_uid":"58280282da8f819baac977b046a3fede","prob_desc_notes":"NoteIn the first sample test sequences of y-coordinates for six camels are: 123421, 123431, 123432, 124321, 134321 \u0438 234321 (each digit corresponds to one value of yi).","prob_desc_output_spec":"Output the required amount of camels with t humps.","prob_desc_output_to":"standard output","prob_desc_description":"Bob likes to draw camels: with a single hump, two humps, three humps, etc. He draws a camel by connecting points on a coordinate plane. Now he's drawing camels with t humps, representing them as polylines in the plane. Each polyline consists of n vertices with coordinates (x1,\u2009y1), (x2,\u2009y2), ..., (xn,\u2009yn). The first vertex has a coordinate x1\u2009=\u20091, the second \u2014 x2\u2009=\u20092, etc. Coordinates yi might be any, but should satisfy the following conditions:  there should be t humps precisely, i.e. such indexes j (2\u2009\u2264\u2009j\u2009\u2264\u2009n\u2009-\u20091), so that yj\u2009-\u20091\u2009&lt;\u2009yj\u2009&gt;\u2009yj\u2009+\u20091,  there should be precisely t\u2009-\u20091 such indexes j (2\u2009\u2264\u2009j\u2009\u2264\u2009n\u2009-\u20091), so that yj\u2009-\u20091\u2009&gt;\u2009yj\u2009&lt;\u2009yj\u2009+\u20091,  no segment of a polyline should be parallel to the Ox-axis,  all yi are integers between 1 and 4. For a series of his drawings of camels with t humps Bob wants to buy a notebook, but he doesn't know how many pages he will need. Output the amount of different polylines that can be drawn to represent camels with t humps for a given number n.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 1', 'output': ['3\\n']}, {'input': '5 2', 'output': ['0\\n']}, {'input': '7 1', 'output': ['18\\n']}, {'input': '8 3', 'output': ['0\\n']}, {'input': '10 2', 'output': ['6\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 6 9\", \"4 4 4\", \"0 0 0\"]","prob_desc_input_spec":"The first line contains three integers r, g and b (0\u2009\u2264\u2009r,\u2009g,\u2009b\u2009\u2264\u2009109) \u2014 the number of red, green and blue flowers.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n\tint r,b,g,mix,a[10],i;\n\tscanf(\"%d %d %d\",&r,&b,&g);\n\tif(r==0 || b==0 || g==0)\n\t{\n\t\tprintf(\"%d\",(r\/3+g\/3+b\/3));\n\t\treturn 0;\t\n\t}\n\tfor(i=0;i<=2;i++)\n\t{\n\t\ta[i]=(i+((r-i)\/3+(b-i)\/3+(g-i)\/3));\n\n\t}\n\tint max=0;\n\tfor(i=0;i<=2;i++)\n\t{\n\t\tif(a[i]>max)\n\t\t\tmax=a[i];\n\t}\n\tprintf(\"%d\",max);\n\treturn 0;\n\n}\n","prob_desc_sample_outputs":"[\"6\", \"4\", \"0\"]","lang_cluster":"C","code_uid":"de5e08b66eb31d7f6acd740e6bcead6e","prob_desc_notes":"NoteIn test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.","prob_desc_output_spec":"Print the maximal number of bouquets Fox Ciel can make.","prob_desc_output_to":"standard output","prob_desc_description":"Fox Ciel has some flowers: r red flowers, g green flowers and b blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:  To make a \"red bouquet\", it needs 3 red flowers.  To make a \"green bouquet\", it needs 3 green flowers.  To make a \"blue bouquet\", it needs 3 blue flowers.  To make a \"mixing bouquet\", it needs 1 red, 1 green and 1 blue flower. Help Fox Ciel to find the maximal number of bouquets she can make.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 5', 'output': ['5']}, {'input': '10 10 10', 'output': ['10']}, {'input': '1 1 1', 'output': ['1']}, {'input': '0 3 6', 'output': ['3']}, {'input': '2 2 2', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"QAQAQYSYIOIWIN\", \"QAQQQZZYNOIWIN\"]","prob_desc_input_spec":"The only line contains a string of length n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). It's guaranteed that the string only contains uppercase English letters.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    char myarray[1000];\n    scanf(\"%s\",&myarray);\n    int i,cnt=0,j,k,l,len=0;\n    len=strlen(myarray);\n    for(i=0; i<len; i++)\n    {\n        if(myarray[i]=='Q')\n        {\n            for(j=i+1; j<len; j++)\n            {\n                if(myarray[j]=='A')\n                {\n                    for(l=j+1; l<len; l++)\n                    {\n                        if(myarray[l]=='Q')\n                        {\n                            cnt++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    printf(\"%d\",cnt);\n    return 0;\n}","prob_desc_sample_outputs":"[\"4\", \"3\"]","lang_cluster":"C","code_uid":"d269e020ed015cd2345122de6f5dc57b","prob_desc_notes":"NoteIn the first example there are 4 subsequences \"QAQ\": \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\".","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the number of subsequences \"QAQ\" in the string.","prob_desc_output_to":"standard output","prob_desc_description":"\"QAQ\" is a word to denote an expression of crying. Imagine \"Q\" as eyes with tears and \"A\" as a mouth.Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of \"QAQ\" in the string (Diamond is so cute!).  illustration by \u732b\u5c4b https:\/\/twitter.com\/nekoyaliu Bort wants to know how many subsequences \"QAQ\" are in the string Diamond has given. Note that the letters \"QAQ\" don't have to be consecutive, but the order of letters should be exact.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'QAQ', 'output': ['1']}, {'input': 'QQQQ', 'output': ['0']}, {'input': 'AAAA', 'output': ['0']}, {'input': 'QAQAQA', 'output': ['6']}, {'input': 'QAZXSWQAQ', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 7\", \"100 47\"]","prob_desc_input_spec":"The only line contains two integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009105). It is guaranteed that number b is lucky.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint b;\nint check(int i){\n    int temp=0,t=0;\n    while(i>0){\n        if(i%10==4||i%10==7) temp=temp*10+i%10;\n        i\/=10;\n    }\n    while(temp>0){\n        t=t*10+temp%10;\n        temp\/=10;\n    }\n    return t==b;\n}\nint main(){\n    int a,i;\n    scanf(\"%d%d\",&a,&b);\n    for(i=a+1;;i++){\n        if(check(i)){\n            printf(\"%d\",i);\n            return 0;\n        }\n    }\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"7\", \"147\"]","lang_cluster":"C","code_uid":"138c7e50a285189eb9524858a1b412e0","prob_desc_notes":null,"prob_desc_output_spec":"In the only line print a single number \u2014 the number c that is sought by Petya.","prob_desc_output_to":"standard output","prob_desc_description":"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya calls a mask of a positive integer n the number that is obtained after successive writing of all lucky digits of number n from the left to the right. For example, the mask of number 72174994 is number 7744, the mask of 7 is 7, the mask of 9999047 is 47. Obviously, mask of any number is always a lucky number.Petya has two numbers \u2014 an arbitrary integer a and a lucky number b. Help him find the minimum number c (c\u2009&gt;\u2009a) such that the mask of number c equals b.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 4', 'output': ['4']}, {'input': '10 77', 'output': ['77']}, {'input': '50 47', 'output': ['74']}, {'input': '100 444', 'output': ['444']}, {'input': '500 777', 'output': ['777']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2\\n1 2\", \"3\\n2 4 6\", \"2\\n12 18\", \"5\\n45 12 27 30 18\"]","prob_desc_input_spec":"The first line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100). Then the second line contains n integers: x1, x2, ..., xn (1\u2009\u2264\u2009xi\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\nint main(){\n    int n,m,a[100],i,j,tr=1,min;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n    while(tr){\n              tr=0;\n              min=a[0];\n              for(i=1;i<n;i++)if(min>a[i])min=a[i];\n              for(i=0;i<n;i++)if(a[i]>min){\n                                           tr=1;\n                                           a[i]-=min;\n                                           }\n              }\n    m=0;\n \n    for(i=0;i<n;i++)m+=a[i];\n    printf(\"%d\",m);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"6\", \"12\", \"15\"]","lang_cluster":"C","code_uid":"2be7bbdd94161a6473324ba6d7e52157","prob_desc_notes":"NoteIn the first example the optimal way is to do the assignment: x2 = x2 - x1.In the second example the optimal sequence of operations is: x3 = x3 - x2, x2 = x2 - x1.","prob_desc_output_spec":"Output a single integer \u2014 the required minimal sum.","prob_desc_output_to":"standard output","prob_desc_description":"Fox Ciel is playing a game with numbers now. Ciel has n positive integers: x1, x2, ..., xn. She can do the following operation as many times as needed: select two different indexes i and j such that xi &gt; xj hold, and then apply assignment xi = xi - xj. The goal is to make the sum of all numbers as small as possible.Please help Ciel to find this minimal sum.","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n5 10', 'output': ['10\\n']}, {'input': '3\\n3 6 9', 'output': ['9\\n']}, {'input': '4\\n4 8 12 16', 'output': ['16\\n']}, {'input': '2\\n7 14', 'output': ['14\\n']}, {'input': '5\\n5 10 15 20 25', 'output': ['25\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2\", \"3\"]","prob_desc_input_spec":"A single line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u20092000) \u2014 the number of buttons the lock has.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    int n,i,l=0;\n    scanf(\"%d\",&n);\n    for(i=1;i<n;i++) l=l+(n-i)*i;\n    printf(\"%d\",l+n);\n}\n","prob_desc_sample_outputs":"[\"3\", \"7\"]","lang_cluster":"C","code_uid":"214c50ce4aee708818c9fc83db32749b","prob_desc_notes":"NoteConsider the first test sample. Manao can fail his first push and push the wrong button. In this case he will already be able to guess the right one with his second push. And his third push will push the second right button. Thus, in the worst-case scenario he will only need 3 pushes.","prob_desc_output_spec":"In a single line print the number of times Manao has to push a button in the worst-case scenario.","prob_desc_output_to":"standard output","prob_desc_description":"Manao is trying to open a rather challenging lock. The lock has n buttons on it and to open it, you should press the buttons in a certain order to open the lock. When you push some button, it either stays pressed into the lock (that means that you've guessed correctly and pushed the button that goes next in the sequence), or all pressed buttons return to the initial position. When all buttons are pressed into the lock at once, the lock opens.Consider an example with three buttons. Let's say that the opening sequence is: {2, 3, 1}. If you first press buttons 1 or 3, the buttons unpress immediately. If you first press button 2, it stays pressed. If you press 1 after 2, all buttons unpress. If you press 3 after 2, buttons 3 and 2 stay pressed. As soon as you've got two pressed buttons, you only need to press button 1 to open the lock.Manao doesn't know the opening sequence. But he is really smart and he is going to act in the optimal way. Calculate the number of times he's got to push a button in order to open the lock in the worst-case scenario.","length":8,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\n', 'output': ['10\\n']}, {'input': '5\\n', 'output': ['15\\n']}, {'input': '6\\n', 'output': ['21\\n']}, {'input': '7\\n', 'output': ['28\\n']}, {'input': '8\\n', 'output': ['36\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"LLUUUR\", \"RRUULLDD\"]","prob_desc_input_spec":"The first line of the input file contains the recording of the robot's movements. This recording is a non-empty string, consisting of uppercase Latin letters L, R, U and D, standing for movements left, right, up and down respectively. The length of the string does not exceed 100.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define MAXN 210\n\nint main ()\n{\n    static char data[MAXN];\n    static int a[MAXN][MAXN];\n    memset(a,0,sizeof(a));\n    scanf(\"%s\",data);\n    int N = strlen(data);\n    int x = 105;\n    int y = 105;\n    a[x][y] = 1;\n    int i;\n    for (i = 2; i <= (N+1); i++)\n    {\n        int nx = x;\n        int ny = y;\n        if (data[i-2] == 'L') nx--;\n        else if (data[i-2] == 'R') nx++;\n        else if (data[i-2] == 'U') ny++;\n        else ny--;\n        \n        if ((a[nx-1][ny] > 0) && (a[nx-1][ny] < (i-1)))\n        {\n            printf(\"BUG\\n\");\n            return 0;\n        }\n        if ((a[nx+1][ny] > 0) && (a[nx+1][ny] < (i-1)))\n        {\n            printf(\"BUG\\n\");\n            return 0;\n        }\n        if ((a[nx][ny-1] > 0) && (a[nx][ny-1] < (i-1)))\n        {\n            printf(\"BUG\\n\");\n            return 0;\n        }\n        if ((a[nx][ny+1] > 0) && (a[nx][ny+1] < (i-1)))\n        {\n            printf(\"BUG\\n\");\n            return 0;\n        }\n        if (a[nx][ny] > 0)\n        {\n            printf(\"BUG\\n\");\n            return 0;\n        }        \n        \n        a[nx][ny] = i;\n        x = nx;\n        y = ny;\n    }\n    printf(\"OK\\n\");\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"OK\", \"BUG\"]","lang_cluster":"C","code_uid":"553bceb132fe79a128b299bc9e09118a","prob_desc_notes":null,"prob_desc_output_spec":"In the first line output the only word OK (if the above described map exists), or BUG (if such a map does not exist).","prob_desc_output_to":"standard output","prob_desc_description":"The whole world got obsessed with robots,and to keep pace with the progress, great Berland's programmer Draude decided to build his own robot. He was working hard at the robot. He taught it to walk the shortest path from one point to another, to record all its movements, but like in many Draude's programs, there was a bug \u2014 the robot didn't always walk the shortest path. Fortunately, the robot recorded its own movements correctly. Now Draude wants to find out when his robot functions wrong. Heh, if Draude only remembered the map of the field, where he tested the robot, he would easily say if the robot walked in the right direction or not. But the field map was lost never to be found, that's why he asks you to find out if there exist at least one map, where the path recorded by the robot is the shortest.The map is an infinite checkered field, where each square is either empty, or contains an obstruction. It is also known that the robot never tries to run into the obstruction. By the recorded robot's movements find out if there exist at least one such map, that it is possible to choose for the robot a starting square (the starting square should be empty) such that when the robot moves from this square its movements coincide with the recorded ones (the robot doesn't run into anything, moving along empty squares only), and the path from the starting square to the end one is the shortest.In one movement the robot can move into the square (providing there are no obstrutions in this square) that has common sides with the square the robot is currently in.","length":58,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'LLUUUR', 'output': ['OK\\n']}, {'input': 'RRUULLDD', 'output': ['BUG\\n']}, {'input': 'UUUDDDLLRR', 'output': ['OK\\n']}, {'input': 'LLRRUUD', 'output': ['BUG\\n']}, {'input': 'UDLR', 'output': ['OK\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 4\", \"3 3\"]","prob_desc_input_spec":"In a single line you are given two integers M and N \u2014 board sizes in squares (1\u2009\u2264\u2009M\u2009\u2264\u2009N\u2009\u2264\u200916).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n#include<math.h>\nint main ()\n{\n    int M,N,X;\n    scanf(\"%d %d\", &M, &N);\n    X=((M*N)\/2);\n    printf(\"%d\\n\", X);\n    return 0;\n}\n\n\/* 1490302257089 *\/\n","prob_desc_sample_outputs":"[\"4\", \"4\"]","lang_cluster":"C","code_uid":"1f217de1a9d57fdd6c523b5eb63cc85d","prob_desc_notes":null,"prob_desc_output_spec":"Output one number \u2014 the maximal number of dominoes, which can be placed.","prob_desc_output_to":"standard output","prob_desc_description":"You are given a rectangular board of M\u2009\u00d7\u2009N squares. Also you are given an unlimited number of standard domino pieces of 2\u2009\u00d7\u20091 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:1. Each domino completely covers two squares.2. No two dominoes overlap.3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.Find the maximum number of dominoes, which can be placed under these restrictions.","length":12,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['0\\n']}, {'input': '2 2', 'output': ['2\\n']}, {'input': '4 4', 'output': ['8\\n']}, {'input': '5 5', 'output': ['12\\n']}, {'input': '16 16', 'output': ['128\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 7 1 3 2 2\", \"5 5 2 3 1 1\"]","prob_desc_input_spec":"The first line of the input contains six integers n,\u2009m,\u2009i,\u2009j,\u2009a,\u2009b (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009106;\u00a01\u2009\u2264\u2009i\u2009\u2264\u2009n;\u00a01\u2009\u2264\u2009j\u2009\u2264\u2009m;\u00a01\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009106). You can assume that the chessboard rows are numbered from 1 to n from top to bottom and the columns are numbered from 1 to m from left to right. Position (i,\u2009j) in the statement is a chessboard cell on the intersection of the i-th row and the j-th column. You can consider that the corners are: (1,\u2009m), (n,\u20091), (n,\u2009m), (1,\u20091).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nlong long int n,m,i,j,a,b;\nint ab(int a)\n{\n\tif(a<0)\n\treturn -a;\n\treturn a;\n}\nint max(int a,int b)\n{\n\tif(a<b)\n\treturn b;\n\treturn a;\n}\nint min(int a,int b)\n{\n\tif(a>b)\n\treturn b;\n\treturn a;\n}\nint func(int u,int v)\n{\t\t\n\t\tif(i==u&&j==v)\n\t\treturn 0;\n\t\tif(i+a>n&&i-a<=0)\n\t\treturn -1;\n\t\tif(j+b>m&&j-b<=0)\n\t\treturn -1;\n\t\tint x=ab(u-i),y=ab(v-j);\n\t\tif(x%a!=0||y%b!=0)\n\t\treturn -1;\n\t\tx=x\/a;y=y\/b;\n\t\tif(x%2!=y%2)\n\t\treturn -1;\n\t\tint t=max(x,y);\n\t\treturn t;\n}\nint main()\n{\n\tscanf(\"%lld%lld%lld%lld%lld%lld\",&n,&m,&i,&j,&a,&b);\n\tint ans=100000000;\n\tint a=func(1,m);\n\tif(a!=-1)\n\t{\n\t\tans=min(ans,a);\n\t}\n\ta=func(n,1);\n\tif(a!=-1)\n\t{\n\t\tans=min(ans,a);\n\t}\n\ta=func(1,1);\n\tif(a!=-1)\n\t{\n\t\tans=min(ans,a);\n\t}\n\ta=func(n,m);\n\tif(a!=-1)\n\t{\n\t\tans=min(ans,a);\n\t}\n\tif(ans<100000000)\n\tprintf(\"%d\",ans);\n\telse\n\tprintf(\"Poor Inna and pony!\");\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"2\", \"Poor Inna and pony!\"]","lang_cluster":"C","code_uid":"c680f47b26ba2da78b2576cf0491b7df","prob_desc_notes":"NoteNote to sample 1:Inna and the pony can move the candy to position (1\u2009+\u20092,\u20093\u2009+\u20092)\u2009=\u2009(3,\u20095), from there they can move it to positions (3\u2009-\u20092,\u20095\u2009+\u20092)\u2009=\u2009(1,\u20097) and (3\u2009+\u20092,\u20095\u2009+\u20092)\u2009=\u2009(5,\u20097). These positions correspond to the corner squares of the chess board. Thus, the answer to the test sample equals two.","prob_desc_output_spec":"In a single line print a single integer \u2014 the minimum number of moves needed to get the candy. If Inna and the pony cannot get the candy playing by Dima's rules, print on a single line \"Poor Inna and pony!\" without the quotes.","prob_desc_output_to":"standard output","prob_desc_description":"Dima and Inna are doing so great! At the moment, Inna is sitting on the magic lawn playing with a pink pony. Dima wanted to play too. He brought an n\u2009\u00d7\u2009m chessboard, a very tasty candy and two numbers a and b.Dima put the chessboard in front of Inna and placed the candy in position (i,\u2009j) on the board. The boy said he would give the candy if it reaches one of the corner cells of the board. He's got one more condition. There can only be actions of the following types:  move the candy from position (x,\u2009y) on the board to position (x\u2009-\u2009a,\u2009y\u2009-\u2009b);  move the candy from position (x,\u2009y) on the board to position (x\u2009+\u2009a,\u2009y\u2009-\u2009b);  move the candy from position (x,\u2009y) on the board to position (x\u2009-\u2009a,\u2009y\u2009+\u2009b);  move the candy from position (x,\u2009y) on the board to position (x\u2009+\u2009a,\u2009y\u2009+\u2009b). Naturally, Dima doesn't allow to move the candy beyond the chessboard borders.Inna and the pony started shifting the candy around the board. They wonder what is the minimum number of allowed actions that they need to perform to move the candy from the initial position (i,\u2009j) to one of the chessboard corners. Help them cope with the task! ","length":67,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 3 3 1 1', 'output': ['2\\n']}, {'input': '6 6 3 3 2 2', 'output': ['Poor Inna and pony!\\n']}, {'input': '7 7 4 4 3 3', 'output': ['1\\n']}, {'input': '8 8 4 4 2 2', 'output': ['2\\n']}, {'input': '9 9 5 5 4 4', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"42\", \"5\"]","prob_desc_input_spec":"The only line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    int n,feet,tmp,inch;\n    scanf(\"%d\",&n);\n    inch=n\/3;\n    if(n%3==2)\n    {\n        inch++;\n    }\n    feet=inch\/12;\n    inch=inch%12;\n    printf(\"%d %d\\n\",feet,inch);\n    return 0;\n}","prob_desc_sample_outputs":"[\"1 2\", \"0 2\"]","lang_cluster":"C","code_uid":"3f0299e11fdc53176f19304052630533","prob_desc_notes":null,"prob_desc_output_spec":"Print two non-negative space-separated integers a and b, where a is the numbers of feet and b is the number of inches.","prob_desc_output_to":"standard output","prob_desc_description":"Lengths are measures in Baden in inches and feet. To a length from centimeters it is enough to know that an inch equals three centimeters in Baden and one foot contains 12 inches.You are given a length equal to n centimeters. Your task is to convert it to feet and inches so that the number of feet was maximum. The result should be an integer rounded to the closest value containing an integral number of inches.Note that when you round up, 1 cm rounds up to 0 inches and 2 cm round up to 1 inch.","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['0 0\\n']}, {'input': '3', 'output': ['0 1\\n']}, {'input': '36', 'output': ['1 0\\n']}, {'input': '38', 'output': ['1 1\\n']}, {'input': '10000', 'output': ['277 9\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"0 0 0 0 9\\n0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n7 0 0 0 0\", \"0 43 21 18 2\\n3 0 21 11 65\\n5 2 0 1 4\\n54 62 12 0 99\\n87 64 81 33 0\"]","prob_desc_input_spec":"The input consists of five lines, each line contains five space-separated integers: the j-th number in the i-th line shows gij (0\u2009\u2264\u2009gij\u2009\u2264\u2009105). It is guaranteed that gii\u2009=\u20090 for all i. Assume that the students are numbered from 1 to 5.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main()\n{\n    int x[6][6];\n    int i,j,k,l,m;\n    for(i=0;i<5;++i)\n    {\n        for(j=0;j<5;++j)\n            scanf(\"%d\",&x[i][j]);\n    }\n    int max=0;\n    for(i=0;i<5;++i)\n    {\n        for(j=0;j<5;++j)\n        {\n            if(i==j)\n                continue;\n            for(k=0;k<5;++k)\n            {\n                if(k==j || k==i)\n                    continue;\n                    for(l=0;l<5;++l)\n                    {\n                        if(l==k || l==j || l==i)\n                            continue;\n                        for(m=0;m<5;++m)\n                        {\n                            int temp=0;\n                            if(m==l || m==k || m==j || m==i)\n                                continue;\n                            temp=x[i][j]+x[j][i]+x[k][l]+x[l][k]+x[j][k]+x[k][j]+x[l][m]+x[m][l]+x[k][l]+x[l][k]+x[l][m]+x[m][l];\n                            \/\/printf(\"%d\\n\",temp);\n                            if(max<temp)\n                                max=temp;\n\n                        }\n                    }\n            }\n        }\n    }\n    printf(\"%d\",max);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"32\", \"620\"]","lang_cluster":"C","code_uid":"e40e73c16a57fbbfbcb77982030e15f0","prob_desc_notes":"NoteIn the first sample, the optimal arrangement of the line is 23154. In this case, the total happiness equals:(g23\u2009+\u2009g32\u2009+\u2009g15\u2009+\u2009g51)\u2009+\u2009(g13\u2009+\u2009g31\u2009+\u2009g54\u2009+\u2009g45)\u2009+\u2009(g15\u2009+\u2009g51)\u2009+\u2009(g54\u2009+\u2009g45)\u2009=\u200932.","prob_desc_output_spec":"Print a single integer \u2014 the maximum possible total happiness of the students.","prob_desc_output_to":"standard output","prob_desc_description":"Many students live in a dormitory. A dormitory is a whole new world of funny amusements and possibilities but it does have its drawbacks. There is only one shower and there are multiple students who wish to have a shower in the morning. That's why every morning there is a line of five people in front of the dormitory shower door. As soon as the shower opens, the first person from the line enters the shower. After a while the first person leaves the shower and the next person enters the shower. The process continues until everybody in the line has a shower.Having a shower takes some time, so the students in the line talk as they wait. At each moment of time the students talk in pairs: the (2i\u2009-\u20091)-th man in the line (for the current moment) talks with the (2i)-th one. Let's look at this process in more detail. Let's number the people from 1 to 5. Let's assume that the line initially looks as 23154 (person number 2 stands at the beginning of the line). Then, before the shower opens, 2 talks with 3, 1 talks with 5, 4 doesn't talk with anyone. Then 2 enters the shower. While 2 has a shower, 3 and 1 talk, 5 and 4 talk too. Then, 3 enters the shower. While 3 has a shower, 1 and 5 talk, 4 doesn't talk to anyone. Then 1 enters the shower and while he is there, 5 and 4 talk. Then 5 enters the shower, and then 4 enters the shower.We know that if students i and j talk, then the i-th student's happiness increases by gij and the j-th student's happiness increases by gji. Your task is to find such initial order of students in the line that the total happiness of all students will be maximum in the end. Please note that some pair of students may have a talk several times. In the example above students 1 and 5 talk while they wait for the shower to open and while 3 has a shower.","length":43,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 0 0 9\\n0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n7 0 0 0 0', 'output': ['32']}, {'input': '0 43 21 18 2\\n3 0 21 11 65\\n5 2 0 1 4\\n54 62 12 0 99\\n87 64 81 33 0', 'output': ['620']}, {'input': '0 1 2 3 4\\n5 0 6 7 8\\n9 10 0 11 12\\n13 14 15 0 16\\n17 18 19 20 0', 'output': ['86']}, {'input': '0 100 200 300 400\\n500 0 600 700 800\\n900 1000 0 1100 1200\\n1300 1400 1500 0 1600\\n1700 1800 1900 2000 0', 'output': ['8600']}, {'input': '0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 2\", \"0 5\", \"2 2\"]","prob_desc_input_spec":"The input file consists of a single line containing two space-separated numbers n and m (0\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009105) \u2014 the number of the grown-ups and the number of the children in the bus, correspondingly.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\nint main() {\n\tint M,N,min,max;\n\tscanf(\"%d%d\",&N,&M);\n\tif(M==0 && N==0)\n\t\tprintf(\"0 0\\n\");\n\telse if(N==0)\n\t\tprintf(\"Impossible\\n\");\n\telse {\n\t\tif(M==0) {\n\t\t\tmin=N;\n\t\t\tmax=N;\n\t\t}\n\t\telse {\n\t\t\tif(N>=M) {\n\t\t\t\tmin=N;\n\t\t\t\tmax=N+M-1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin=M;\n\t\t\t\tmax=N+M-1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",min,max);\n\t}\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"2 2\", \"Impossible\", \"2 3\"]","lang_cluster":"C","code_uid":"b1fab36f65f374592ad1380178193a98","prob_desc_notes":"NoteIn the first sample a grown-up rides with two children and pays two rubles.In the second sample there are only children in the bus, so the situation is impossible. In the third sample there are two cases:  Each of the two grown-ups rides with one children and pays one ruble for the tickets. In this case the passengers pay two rubles in total.  One of the grown-ups ride with two children's and pays two rubles, the another one rides alone and pays one ruble for himself. So, they pay three rubles in total. ","prob_desc_output_spec":"If n grown-ups and m children could have ridden in the bus, then print on a single line two space-separated integers \u2014 the minimum and the maximum possible total bus fare, correspondingly.  Otherwise, print \"Impossible\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"One day Vasya heard a story: \"In the city of High Bertown a bus number 62 left from the bus station. It had n grown-ups and m kids...\"The latter events happen to be of no importance to us. Vasya is an accountant and he loves counting money. So he wondered what maximum and minimum sum of money these passengers could have paid for the ride.The bus fare equals one berland ruble in High Bertown. However, not everything is that easy \u2014 no more than one child can ride for free with each grown-up passenger. That means that a grown-up passenger who rides with his k (k\u2009&gt;\u20090) children, pays overall k rubles: a ticket for himself and (k\u2009-\u20091) tickets for his children. Also, a grown-up can ride without children, in this case he only pays one ruble.We know that in High Bertown children can't ride in a bus unaccompanied by grown-ups.Help Vasya count the minimum and the maximum sum in Berland rubles, that all passengers of this bus could have paid in total.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3', 'output': ['3 5\\n']}, {'input': '0 0', 'output': ['0 0\\n']}, {'input': '1 0', 'output': ['1 1\\n']}, {'input': '0 1', 'output': ['Impossible\\n']}, {'input': '5 2', 'output': ['5 6\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 1\", \"5 2 4\"]","prob_desc_input_spec":"The first and only line contains three integers: n, m and k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20092000).","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nconst long long int base = 1000000007;\n\nlong long int sq(int x, int y) {\n  long long int i, a;\n\n  a = 1;\n  for (i = 0; i < y; i++) {\n    a = (a * x) % base;\n  }\n\n  return a;\n}\n\nint main() {\n  int n, m, k;\n\n  scanf(\"%d%d%d\", &n, &m, &k);\n  \n  if (k == 1 || k > n) printf(\"%I64d\", sq(m, n));\n  else if (k == n) printf(\"%I64d\", sq(m, (n+1)\/2));\n  else if (k%2 == 1) printf(\"%I64d\", sq(m, 2));\n  else printf(\"%d\", m);\n\n  return 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"2\"]","lang_cluster":"C","code_uid":"b1b62f2ec77daa266df84d0fcaf895c0","prob_desc_notes":"NoteIn the first sample only one string is valid: \"a\" (let's denote the only letter of our alphabet as \"a\").In the second sample (if we denote the alphabet letters as \"a\" and \"b\") the following strings are valid: \"aaaaa\" and \"bbbbb\".","prob_desc_output_spec":"Print a single integer \u2014 the number of strings of the described type modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Just in case somebody missed it: this winter is totally cold in Nvodsk! It is so cold that one gets funny thoughts. For example, let's say there are strings with the length exactly n, based on the alphabet of size m. Any its substring with length equal to k is a palindrome. How many such strings exist? Your task is to find their quantity modulo 1000000007 (109\u2009+\u20097). Be careful and don't miss a string or two!Let us remind you that a string is a palindrome if it can be read the same way in either direction, from the left to the right and from the right to the left.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 2', 'output': ['2\\n']}, {'input': '3 3 3', 'output': ['27\\n']}, {'input': '4 4 2', 'output': ['16\\n']}, {'input': '5 5 1', 'output': ['3125\\n']}, {'input': '6 6 4', 'output': ['6\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4\"]","prob_desc_input_spec":"The only line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u20091012), the number of vertices in the graph.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include<stdio.h>\n\nint main()\n{\n    long long int i=0,n,count=0,temp,mod,M=1;\n    scanf(\"%lld\",&n);\n    while(1)\n    {\n        \/\/ printf(\"%lld\\n\", i);\n        M=M*2;\n        mod=n%M;\n        temp=n\/M;\n        \/\/ printf(\"%lld %lld %lld\\n\",temp , mod,M);\n        if(mod>M\/2)\n            count+=(M\/2)*(temp+1);\n        else{\n                count+=(M\/2)*(temp);\n            }\n        if(temp<=0)\n            break;\n        i++;\n    }\n    printf(\"%lld\\n\", count);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"4\"]","lang_cluster":"C","code_uid":"a7c8faaea19ea8bdf4482ed8c4acf808","prob_desc_notes":"NoteIn the first sample:  The weight of the minimum spanning tree is 1+2+1=4.","prob_desc_output_spec":"The only line contains an integer x, the weight of the graph's minimum spanning tree.","prob_desc_output_to":"standard output","prob_desc_description":"Ehab is interested in the bitwise-xor operation and the special graphs. Mahmoud gave him a problem that combines both. He has a complete graph consisting of n vertices numbered from 0 to n\u2009-\u20091. For all 0\u2009\u2264\u2009u\u2009&lt;\u2009v\u2009&lt;\u2009n, vertex u and vertex v are connected with an undirected edge that has weight  (where  is the bitwise-xor operation). Can you find the weight of the minimum spanning tree of that graph?You can read about complete graphs in https:\/\/en.wikipedia.org\/wiki\/Complete_graphYou can read about the minimum spanning tree in https:\/\/en.wikipedia.org\/wiki\/Minimum_spanning_treeThe weight of the minimum spanning tree is the sum of the weights on the edges included in it.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2', 'output': ['1\\n']}, {'input': '5', 'output': ['6\\n']}, {'input': '10', 'output': ['15\\n']}, {'input': '20', 'output': ['30\\n']}, {'input': '100', 'output': ['127\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 1\", \"2 2\", \"3 2\", \"11 5\", \"37 63\"]","prob_desc_input_spec":"The first line contains two space-separated integers n and C, 1\u2009\u2264\u2009n\u2009\u2264\u2009500000, 1\u2009\u2264\u2009C\u2009\u2264\u2009200000.","prob_desc_input_from":"standard input","lang":"GNU C","source_code":"#include <stdio.h>\n\nint mod_inv(int a, int p){\n\tint y = p-2;\n\tint res = 1;\n\twhile(y!=0){\n\t\tif(y&1){\n\t\t\tres = ((long long)res * a)%p;\n\t\t}\n\t\ta = ((long long)a*a)%p;\n\t\ty = y>>1;\n\t}\n\treturn res;\n}\n\nint main(void) {\n\t\/\/ your code goes here\n\tint n,c,i;\n\tscanf(\"%d %d\",&n,&c);\n\tint res = c;\n\tint prev = c;\n\tint p = 1000003;\n\tfor(i=2; i<=n ;i++){\n\t\tprev = ((((long long)(c+i-1)*prev)%p)*mod_inv(i,p))%p;\n\t\tres = (res + prev)%p;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"5\", \"5\", \"9\", \"4367\", \"230574\"]","lang_cluster":"C","code_uid":"fb7b8635f517b1ff3e2474c13721e1a9","prob_desc_notes":"NoteThe number 106\u2009+\u20093 is prime.In the second sample case, the five walls are:             B        BB., .B, BB, B., and .BIn the third sample case, the nine walls are the five as in the second sample case and in addition the following four: B    BB    B  B        BB., .B, BB, and BB","prob_desc_output_spec":"Print the number of different walls that Heidi could build, modulo 106\u2009+\u20093.","prob_desc_output_to":"standard output","prob_desc_description":"Heidi the Cow is aghast: cracks in the northern Wall? Zombies gathering outside, forming groups, preparing their assault? This must not happen! Quickly, she fetches her HC2 (Handbook of Crazy Constructions) and looks for the right chapter:How to build a wall:  Take a set of bricks.  Select one of the possible wall designs. Computing the number of possible designs is left as an exercise to the reader.  Place bricks on top of each other, according to the chosen design. This seems easy enough. But Heidi is a Coding Cow, not a Constructing Cow. Her mind keeps coming back to point 2b. Despite the imminent danger of a zombie onslaught, she wonders just how many possible walls she could build with up to n bricks.A wall is a set of wall segments as defined in the easy version. How many different walls can be constructed such that the wall consists of at least 1 and at most n bricks? Two walls are different if there exist a column c and a row r such that one wall has a brick in this spot, and the other does not.Along with n, you will be given C, the width of the wall (as defined in the easy version). Return the number of different walls modulo 106\u2009+\u20093.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5', 'output': ['4367\\n']}, {'input': '20 10', 'output': ['1000001\\n']}, {'input': '30 15', 'output': ['1000001\\n']}, {'input': '40 20', 'output': ['1000001\\n']}, {'input': '50 25', 'output': ['1000001\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 3\", \"10 1\"]","prob_desc_input_spec":"The first line will contain two integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u200950, 1\u2009\u2264\u2009k\u2009\u2264\u2009min{1018,\u2009l} where l is the length of the Kyoya's list).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"\/\/God & me \/\/ ya mahdi adrekni\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nlong long int fib[112]={1,1},k;\nint p[112],n;\nint main(){\n  for(int i=2;i<=85;i++)\n    fib[i]=fib[i-1]+fib[i-2];\n  cin>>n>>k;\n  for(int i=0;i<n;i++)\n    p[i]=i;\n  \/\/int L=0;\n  while(k>0){\/\/timed in test 5 :( maby for this.\n    int pos=0;\n    while(fib[++pos]<k);\/\/long long int* it=lower_bound(fib,fib+85,k);\/\/thank from maths.surrey.ac.uk :D I am so lazzy\n    \/\/cout<<pos<<endl;\n    pos--;\n    k-=fib[pos];\n    if(pos)\n      swap(p[n-pos-1],p[n-pos]);\n    \/\/if(++L>10)return 0;\n  }\n  for(int i=0;i<n;i++)\n    cout<<p[i]+1<<\" \";\n  cout<<endl;\n  return 0;\n}\n","prob_desc_sample_outputs":"[\"1 3 2 4\", \"1 2 3 4 5 6 7 8 9 10\"]","lang_cluster":"C++","code_uid":"9f43a7016644132b61f17283e55471ea","prob_desc_notes":"NoteThe standard cycle representation is (1)(32)(4), which after removing parenthesis gives us the original permutation. The first permutation on the list would be [1,\u20092,\u20093,\u20094], while the second permutation would be [1,\u20092,\u20094,\u20093].","prob_desc_output_spec":"Print n space-separated integers, representing the permutation that is the answer for the question. ","prob_desc_output_to":"standard output","prob_desc_description":"Let's define the permutation of length n as an array p\u2009=\u2009[p1,\u2009p2,\u2009...,\u2009pn] consisting of n distinct integers from range from 1 to n. We say that this permutation maps value 1 into the value p1, value 2 into the value p2 and so on.Kyota Ootori has just learned about cyclic representation of a permutation. A cycle is a sequence of numbers such that each element of this sequence is being mapped into the next element of this sequence (and the last element of the cycle is being mapped into the first element of the cycle). The cyclic representation is a representation of p as a collection of cycles forming p. For example, permutation p\u2009=\u2009[4,\u20091,\u20096,\u20092,\u20095,\u20093] has a cyclic representation that looks like (142)(36)(5) because 1 is replaced by 4, 4 is replaced by 2, 2 is replaced by 1, 3 and 6 are swapped, and 5 remains in place. Permutation may have several cyclic representations, so Kyoya defines the standard cyclic representation of a permutation as follows. First, reorder the elements within each cycle so the largest element is first. Then, reorder all of the cycles so they are sorted by their first element. For our example above, the standard cyclic representation of [4,\u20091,\u20096,\u20092,\u20095,\u20093] is (421)(5)(63).Now, Kyoya notices that if we drop the parenthesis in the standard cyclic representation, we get another permutation! For instance, [4,\u20091,\u20096,\u20092,\u20095,\u20093] will become [4,\u20092,\u20091,\u20095,\u20096,\u20093].Kyoya notices that some permutations don't change after applying operation described above at all. He wrote all permutations of length n that do not change in a list in lexicographic order. Unfortunately, his friend Tamaki Suoh lost this list. Kyoya wishes to reproduce the list and he needs your help. Given the integers n and k, print the permutation that was k-th on Kyoya's list.","length":28,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 1', 'output': ['1 2 3 4 5 ']}, {'input': '6 3', 'output': ['1 3 2 4 5 6 ']}, {'input': '7 2', 'output': ['1 2 4 3 5 6 7 ']}, {'input': '8 5', 'output': ['1 3 2 5 4 6 7 8 ']}, {'input': '9 4', 'output': ['1 2 4 3 6 5 7 8 9 ']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"512 4\", \"1000000000 9\"]","prob_desc_input_spec":"The first line of the input contains two integer numbers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 10^9$$$, $$$1 \\le k \\le 50$$$) \u2014 the number from which Tanya will subtract and the number of subtractions correspondingly.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nlong long a,b;\nint main(void)\n{    \n    scanf(\"%d%d\",&a,&b);   \n    while(b--)if(a%10)a--;else a\/=10;  \n    printf(\"%lld\",a);\n    return 0;\n}","prob_desc_sample_outputs":"[\"50\", \"1\"]","lang_cluster":"C++","code_uid":"8e86453fe9d1f56d21411e36bacf8344","prob_desc_notes":"NoteThe first example corresponds to the following sequence: $$$512 \\rightarrow 511 \\rightarrow 510 \\rightarrow 51 \\rightarrow 50$$$.","prob_desc_output_spec":"Print one integer number \u2014 the result of the decreasing $$$n$$$ by one $$$k$$$ times. It is guaranteed that the result will be positive integer number. ","prob_desc_output_to":"standard output","prob_desc_description":"Little girl Tanya is learning how to decrease a number by one, but she does it wrong with a number consisting of two or more digits. Tanya subtracts one from a number by the following algorithm:  if the last digit of the number is non-zero, she decreases the number by one;  if the last digit of the number is zero, she divides the number by 10 (i.e. removes the last digit). You are given an integer number $$$n$$$. Tanya will subtract one from it $$$k$$$ times. Your task is to print the result after all $$$k$$$ subtractions.It is guaranteed that the result will be positive integer number.","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '200 1', 'output': ['20\\n']}, {'input': '3000 2', 'output': ['30\\n']}, {'input': '40000 3', 'output': ['40\\n']}, {'input': '500000 4', 'output': ['50\\n']}, {'input': '6000000 5', 'output': ['60\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 4 0\\n2 1 2\", \"5 6 1\\n2 7 2\", \"3 3 3\\n2 2 2\"]","prob_desc_input_spec":"The first line of the input contains three integers a, b and c (0\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 the number of blue, violet and orange spheres that are in the magician's disposal. The second line of the input contains three integers, x, y and z (0\u2009\u2264\u2009x,\u2009y,\u2009z\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 the number of blue, violet and orange spheres that he needs to get.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"                \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n                \/\/\/\/\/\/\/\/\/\/\/\/\/   YURKA PRO AZAZAZ  \/\/\/\/\/\/\/\/\/\/\n                \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#include <bits\/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst long long INF = 1e9;\n\nlong long n,m,k,ans,sum,mn,pl;\nlong long x,y,z;\nlong long a,b,c,tmp,nd;\nbool na,nb,nc;\nmain()\n{\n    cin >> x >> y >> z;\n    cin >> a >> b >> c;\n    if(x > a) tmp+=((x-a)\/2);\n    else nd+= a-x;\n\n    if(y > b) tmp+=((y-b)\/2);\n    else nd+= b-y;\n\n    if(z > c) tmp+=((z-c)\/2);\n    else nd+= c-z;\n\n    if(tmp >= nd) cout << \"YES\";\n    else cout << \"NO\";\n\n\n}\n\n","prob_desc_sample_outputs":"[\"Yes\", \"No\", \"Yes\"]","lang_cluster":"C++","code_uid":"672f4650f76215b11aea57761e502c60","prob_desc_notes":"NoteIn the first sample the wizard has 4 blue and 4 violet spheres. In his first action he can turn two blue spheres into one violet one. After that he will have 2 blue and 5 violet spheres. Then he turns 4 violet spheres into 2 orange spheres and he ends up with 2 blue, 1 violet and 2 orange spheres, which is exactly what he needs.","prob_desc_output_spec":"If the wizard is able to obtain the required numbers of spheres, print \"Yes\". Otherwise, print \"No\".","prob_desc_output_to":"standard output","prob_desc_description":"Carl is a beginner magician. He has a blue, b violet and c orange magic spheres. In one move he can transform two spheres of the same color into one sphere of any other color. To make a spell that has never been seen before, he needs at least x blue, y violet and z orange spheres. Can he get them (possible, in multiple actions)?","length":32,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 5\\n3 3 3', 'output': ['Yes\\n']}, {'input': '0 0 0\\n1 1 1', 'output': ['No\\n']}, {'input': '10 10 10\\n5 5 5', 'output': ['Yes\\n']}, {'input': '2 2 2\\n3 3 3', 'output': ['No\\n']}, {'input': '1 1 1\\n0 0 0', 'output': ['Yes\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1\", \"2\", \"3\"]","prob_desc_input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200940).","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"\/\/Tornike Mandzulashvili\n\/\/#pragma comment(linker, \"\/STACK:16777216\")\n#include <time.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <set>\n#define PI 3.14159265\n#define hash1 1000003\n#define hash2 1000033\n#define md 1000000007\n#define INF 1000000000\n\nusing namespace std;\n\nlong long d[41]={2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583};\nlong long n;\nlong long go(long long num)\n{\n    if (num==0) return 1;\n    long long h=go(num\/2);\n    if (num%2) return (h*h%md)*2LL%md;else\n    return h*h%md;\n}\nmain()\n{\n\/\/freopen(\"text.in\",\"r\",stdin);freopen(\"text.out\",\"w\",stdout);\n\n      cin>>n;\n      cout<<(go(d[n-1]-1)+md-1)%md<<endl;\n}\n","prob_desc_sample_outputs":"[\"1\", \"3\", \"15\"]","lang_cluster":"C++","code_uid":"4276d207f622e526066976606182dc37","prob_desc_notes":null,"prob_desc_output_spec":"Print a single integer \u2014 the number zn modulo 1000000007 (109\u2009+\u20097). It is guaranteed that the answer exists.","prob_desc_output_to":"standard output","prob_desc_description":"Consider the following equation:  where sign [a] represents the integer part of number a.Let's find all integer z (z\u2009&gt;\u20090), for which this equation is unsolvable in positive integers. The phrase \"unsolvable in positive integers\" means that there are no such positive integers x and y (x,\u2009y\u2009&gt;\u20090), for which the given above equation holds.Let's write out all such z in the increasing order: z1,\u2009z2,\u2009z3, and so on (zi\u2009&lt;\u2009zi\u2009+\u20091). Your task is: given the number n, find the number zn.","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4', 'output': ['31']}, {'input': '10', 'output': ['89']}, {'input': '20', 'output': ['4423']}, {'input': '30', 'output': ['132049']}, {'input': '40', 'output': ['24036583']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 3\", \"2 2\"]","prob_desc_input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$, separated by spaces ($$$1 \\leq n,m \\leq 10^9$$$)\u00a0\u2014 the number of kinds of presents and the number of boxes that Alice has.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<vector>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nconst ll p = 1e9 + 7;\nll n,m,ans;\nll qp(ll a,ll b){\n\tll ans = 1,base = a;\n\twhile(b != 0){\n\t\tif(b & 1)ans = ans * base % p;\n\t\tbase = base * base % p;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tans = qp((qp(2,m)%p - 1 + p)%p,n)%p;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\/*\nlong long\n\u7ebf\u6bb5\u6811\u56db\u500d\n\u5199\u4ee3\u7801\u65f6\u8bf7\u6ce8\u610f:\n\t1.\u662f\u5426\u8981\u5f00Long Long?\u6570\u7ec4\u8fb9\u754c\u5904\u7406\u597d\u4e86\u4e48?\n\t2.\u5b9e\u6570\u7cbe\u5ea6\u6709\u6ca1\u6709\u5904\u7406?\n\t3.\u7279\u6b8a\u60c5\u51b5\u5904\u7406\u597d\u4e86\u4e48?\n\t4.\u505a\u4e00\u4e9b\u603b\u6bd4\u4e0d\u505a\u597d.\n\u601d\u8003\u63d0\u9192:\n\t1.\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u95ee\u9898\u53ef\u4e0d\u53ef\u4ee5\u7528\u4e8c\u5206\u7b54\u6848?\n\t2.\u6709\u6ca1\u6709\u8d2a\u5fc3\u7b56\u7565?\u5426\u5219\u80fd\u4e0d\u80fddp?\n*\/\n\n","prob_desc_sample_outputs":"[\"7\", \"9\"]","lang_cluster":"C++","code_uid":"15446088bda594f735f81b1eb62a7e39","prob_desc_notes":"NoteIn the first example, there are seven ways to pack presents:$$$\\{1\\}\\{\\}\\{\\}$$$$$$\\{\\}\\{1\\}\\{\\}$$$$$$\\{\\}\\{\\}\\{1\\}$$$$$$\\{1\\}\\{1\\}\\{\\}$$$$$$\\{\\}\\{1\\}\\{1\\}$$$$$$\\{1\\}\\{\\}\\{1\\}$$$$$$\\{1\\}\\{1\\}\\{1\\}$$$In the second example there are nine ways to pack presents:$$$\\{\\}\\{1,2\\}$$$$$$\\{1\\}\\{2\\}$$$$$$\\{1\\}\\{1,2\\}$$$$$$\\{2\\}\\{1\\}$$$$$$\\{2\\}\\{1,2\\}$$$$$$\\{1,2\\}\\{\\}$$$$$$\\{1,2\\}\\{1\\}$$$$$$\\{1,2\\}\\{2\\}$$$$$$\\{1,2\\}\\{1,2\\}$$$For example, the way $$$\\{2\\}\\{2\\}$$$ is wrong, because presents of the first kind should be used in the least one box.","prob_desc_output_spec":"Print one integer \u00a0\u2014 the number of ways to pack the presents with Alice's rules, calculated by modulo $$$10^9+7$$$","prob_desc_output_to":"standard output","prob_desc_description":"Alice got many presents these days. So she decided to pack them into boxes and send them to her friends.There are $$$n$$$ kinds of presents. Presents of one kind are identical (i.e. there is no way to distinguish two gifts of the same kind). Presents of different kinds are different (i.e. that is, two gifts of different kinds are distinguishable). The number of presents of each kind, that Alice has is very big, so we can consider Alice has an infinite number of gifts of each kind.Also, there are $$$m$$$ boxes. All of them are for different people, so they are pairwise distinct (consider that the names of $$$m$$$ friends are written on the boxes). For example, putting the first kind of present into the first box but not into the second box, is different from putting the first kind of present into the second box but not into the first box.Alice wants to pack presents with the following rules:  She won't pack more than one present of each kind into the same box, so each box should contain presents of different kinds (i.e. each box contains a subset of $$$n$$$ kinds, empty boxes are allowed);  For each kind at least one present should be packed into some box. Now Alice wants to know how many different ways to pack the presents exists. Please, help her and calculate this number. Since the answer can be huge, output it by modulo $$$10^9+7$$$.See examples and their notes for clarification.","length":41,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3', 'output': ['343\\n']}, {'input': '5 2', 'output': ['81\\n']}, {'input': '10 1', 'output': ['1024\\n']}, {'input': '7 4', 'output': ['2401\\n']}, {'input': '2 5', 'output': ['243\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\n1 5 5 5 4 2\", \"5\\n10 20 30 20 10\", \"4\\n1 2 1 2\", \"7\\n3 3 3 3 3 3 3\"]","prob_desc_input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of elements in the array. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20091\u2009000) \u2014 the elements of the array.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<iostream>\nusing namespace std;\nint i,x,y,n,f,ff;\nint main(){\n    f=0;\n    cin>>n;\n    cin>>y;\n    for(i=2;i<=n;i++){\n        cin>>x;\n        if(x>y)ff=0;\n        if(x==y)ff=1;\n        if(x<y)ff=2;\n        if(ff<f){\n            cout<<\"NO\";\n            return 0;\n        }\n        f=ff;\n        y=x;\n    }\n    cout<<\"YES\";\n}","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\", \"YES\"]","lang_cluster":"C++","code_uid":"851f17c0ecce69bc44331bb34ab04cb6","prob_desc_notes":"NoteIn the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).","prob_desc_output_spec":"Print \"YES\" if the given array is unimodal. Otherwise, print \"NO\". You can output each letter in any case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"Array of integers is unimodal, if:  it is strictly increasing in the beginning;  after that it is constant;  after that it is strictly decreasing. The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.For example, the following three arrays are unimodal: [5,\u20097,\u200911,\u200911,\u20092,\u20091], [4,\u20094,\u20092], [7], but the following three are not unimodal: [5,\u20095,\u20096,\u20096,\u20091], [1,\u20092,\u20091,\u20092], [4,\u20095,\u20095,\u20096].Write a program that checks if an array is unimodal.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 2 1 1', 'output': ['YES\\n']}, {'input': '6\\n1 2 3 4 5 6', 'output': ['YES\\n']}, {'input': '4\\n4 3 2 1', 'output': ['YES\\n']}, {'input': '3\\n1 2 1', 'output': ['NO\\n']}, {'input': '7\\n1 2 3 2 1 2 1', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1\\n0 0 0 0 0 0 0 0 0 1\", \"2\\n1 1 0 0 0 0 0 0 0 0\", \"3\\n1 1 0 0 0 0 0 0 0 0\"]","prob_desc_input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). The next line contains 10 integers a[0], a[1], ..., a[9] (0\u2009\u2264\u2009a[i]\u2009\u2264\u2009100) \u2014 elements of array a. The numbers are separated by spaces.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"\/\/#include<fstream>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n,i,j,a[11],m=1e9+7,ans=0;\nlong long c[211][211],F[211][11];\nint f(int n, int t)\n{\n\tif (t==9)\n\t\treturn 1;\n\tif (F[n][t]!=-1) return F[n][t];\n\tint s=0,i;\n\tlong long ans1=0;\n\tfor(i=t;i<10;i++)\n\t\ts+=a[i];\n\tfor(i=a[t];i+s-a[t]<=n;i++)\n\t\tif (t==0)\n\t\t\tans1+=(c[n-1][i]*f(n-i,t+1))%m;\n\t\telse ans1+=(c[n][i]*f(n-i,t+1))%m;\n\tans1%=m;\n\tF[n][t]=ans1;\n\treturn ans1;\n}\nint main ()\n{\n\tcin>>n; int dn=n;\n\tfor(i=0;i<10;i++)\n\t{\n\t\tcin>>a[i];\n\t\tdn-=a[i];\n\t}\n\tfor(i=0;i<=100;i++)\n\t{\n\t\tc[i][0]=1; c[i][i]=1;\n\t\tfor(j=1;j<i;j++)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%m;\n\t}\n\tfor(i=0;i<=n;i++)\n\t\tfor(j=0;j<10;j++)\n\t\t\tF[i][j]=-1;\n\tfor(i=1;i<=n;i++)\n\t\tans=(ans+f(i,0))%m;\n\tcout<<ans;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"1\", \"1\", \"36\"]","lang_cluster":"C++","code_uid":"b07f554f820b1f674ec06f33f347d25b","prob_desc_notes":"NoteIn the first sample number 9 meets the requirements.In the second sample number 10 meets the requirements.In the third sample numbers 10, 110, 210, 120, 103 meet the requirements. There are other suitable numbers, 36 in total.","prob_desc_output_spec":"On a single line print the remainder of dividing the answer to the problem by 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Furik loves writing all sorts of problems, especially such that he can't solve himself. You've got one of his problems, the one Furik gave to Rubik. And Rubik asks you to solve it.There is integer n and array a, consisting of ten integers, indexed by numbers from 0 to 9. Your task is to count the number of positive integers with the following properties:  the number's length does not exceed n;  the number doesn't have leading zeroes;  digit i (0\u2009\u2264\u2009i\u2009\u2264\u20099) occurs in the number at least a[i] times. ","length":45,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n0 0 0 0 0 0 0 0 0 1', 'output': ['1']}, {'input': '2\\n1 1 0 0 0 0 0 0 0 0', 'output': ['1']}, {'input': '3\\n1 1 0 0 0 0 0 0 0 0', 'output': ['36']}, {'input': '4\\n1 1 1 1 0 0 0 0 0 0', 'output': ['1']}, {'input': '5\\n1 1 1 1 1 0 0 0 0 0', 'output': ['1']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"100\", \"48\", \"521\"]","prob_desc_input_spec":"The first line contains the positive integer x (1\u2009\u2264\u2009x\u2009\u2264\u20091018) \u2014 the integer which Anton has. ","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nchar s[32768];\nchar ans[32768];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.getline(s, sizeof(s));\n\tint n = (int)strlen(s);\n\tint def = 0;\n\tfor (int i = 0; i < n; i++) def += (int)(s[i] - '0');\n\tint ret = def;\n\tstrcpy(ans, s);\n\t\/\/\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint cnt = 0;\n\t\tif (s[i] != '0') {\n\t\t\tcnt = def - 1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tcnt += (int)('9' - s[j]);\n\t\t\t}\n\t\t}\n\t\tif (cnt > ret) {\n\t\t\tret = cnt;\n\t\t\tans[i] = s[i] - 1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tans[j] = '9';\n\t\t\t}\n\t\t}\n\t}\n\tint from = 0;\n\twhile (ans[from] == '0') from++;\n\tcout << (ans + from) << \"\\n\";\n\t\/\/\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"99\", \"48\", \"499\"]","lang_cluster":"C++","code_uid":"71ab3fdbf8d83fa4388a9c8c82023391","prob_desc_notes":null,"prob_desc_output_spec":"Print the positive integer which doesn't exceed x and has the maximum sum of digits. If there are several such integers, print the biggest of them. Printed integer must not contain leading zeros.","prob_desc_output_to":"standard output","prob_desc_description":"Anton has the integer x. He is interested what positive integer, which doesn't exceed x, has the maximum sum of digits.Your task is to help Anton and to find the integer that interests him. If there are several such integers, determine the biggest of them. ","length":41,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '123', 'output': ['119']}, {'input': '999', 'output': ['999']}, {'input': '1000', 'output': ['999']}, {'input': '500', 'output': ['499']}, {'input': '1111', 'output': ['1099']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 6\", \"10 1\"]","prob_desc_input_spec":"The first and the only line of the input contains two distinct integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009104), separated by a space .","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\nint ans,l,r;\n\nint main()\n{\n\tcin>>l>>r;\n\twhile(l!=r)\n\t{\n\t\tif(l>r)\n\t\t{\n\t\t\tr++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(r&1)\/\/\u5947\u6570\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr\/=2;\n\t\t\t}\n\t\t}\n\t\tans++;\n\t}\n\tcout<<ans<<endl;\n}","prob_desc_sample_outputs":"[\"2\", \"9\"]","lang_cluster":"C++","code_uid":"e5b514b6052bda4578f144cad7a51620","prob_desc_notes":"NoteIn the first example you need to push the blue button once, and then push the red button once.In the second example, doubling the number is unnecessary, so we need to push the blue button nine times.","prob_desc_output_spec":"Print a single number \u2014 the minimum number of times one needs to push the button required to get the number m out of number n.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. After clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. If at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number n.Bob wants to get number m on the display. What minimum number of clicks he has to make in order to achieve this result?","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10', 'output': ['6\\n']}, {'input': '5 20', 'output': ['4\\n']}, {'input': '3 7', 'output': ['5\\n']}, {'input': '6 2', 'output': ['4\\n']}, {'input': '8 1', 'output': ['7\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":3100.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"2 2\", \"4 3\", \"2020 2021\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$, $$$m$$$ ($$$1\\le n, m\\le 2021$$$).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\r\n#define forn(i,s,t) for(register int i=(s);i<=(t);++i)\r\n#define form(i,s,t) for(register int i=(s);i>=(t);--i)\r\nusing namespace std;\r\nconst int N = 2040, Mod = 998244353;\r\nstruct Mint {\r\n\tint res;\r\n\tMint() {res = 0;}\r\n\tMint(int a) : res(a) {}\r\n\tfriend Mint operator + (Mint A, Mint B) {\r\n\t\treturn Mint((A.res + B.res >= Mod) ? (A.res + B.res - Mod) : (A.res + B.res));\r\n\t}\r\n\tfriend Mint& operator += (Mint& A, Mint B) {return A = A + B;}\r\n\tfriend Mint operator - (Mint A, Mint B) {B.res = Mod - B.res; return A + B;}\r\n\tfriend Mint operator - (Mint A) {return Mint(Mod - A.res);}\r\n\tfriend Mint operator + (Mint A) {return A;}\r\n\tfriend Mint& operator -= (Mint& A, Mint B) {return A = A - B;}\r\n\tfriend Mint operator * (Mint A, Mint B) {return 1ll * A.res * B.res %Mod;}\r\n\tfriend Mint& operator *= (Mint& A, Mint B) {return A = A * B;}\r\n\tfriend Mint operator ~ (Mint A) {\r\n\t\tstatic Mint res; res = Mint(1);\r\n\t\tstatic int k; k = Mod - 2;\r\n\t\tfor(;k;k>>=1, A*=A) (k&1) && (res = res * A, 0);\r\n\t\treturn res;\r\n\t}\r\n\tfriend Mint operator \/ (Mint A, Mint B) {return A * (~B);}\r\n\tfriend Mint& operator \/= (Mint& A, Mint B) {return A *= (~B);}\r\n\tfriend Mint operator >> (Mint A, Mint B) {return Mint(A.res \/ B.res);}\r\n\tfriend Mint& operator >>= (Mint& A, Mint B) {return A = A>>B;}\r\n};\r\nint n, m; Mint C[N << 1][N << 1];\r\ninline Mint F(int n, int m) {return C[n + m][n];}\r\nint main() {\r\n\tscanf(\"%d%d\", &n, &m);\r\n\tforn(i,0,n + m) {\r\n\t\tC[i][0] = C[i][i] = Mint(1);\r\n\t\tforn(j,1,i - 1) C[i][j] = C[i - 1][j] + C[i - 1][j - 1];\r\n\t}\r\n\tstatic Mint res, sum;\r\n\tforn(h,1,n - 1) {\r\n\t\tsum = Mint(0);\r\n\t\tforn(i,1,m - 1) {\r\n\t\t\tres += sum * F(i, h - 1) * F(m - i - 1, h);\r\n\t\t\tsum += F(n - h, i - 1) * F(n - h - 1, m - i);\r\n\t\t}\r\n\t}\r\n\tforn(h,1,m - 1) {\r\n\t\tsum = Mint(0);\r\n\t\tforn(i,1,n - 1) {\r\n\t\t\tsum += F(m - h, i - 1) * F(m - h - 1, n - i);\r\n\t\t\tres += sum * F(i, h - 1) * F(n - i - 1, h);\r\n\t\t}\r\n\t}\r\n\tres = res * Mint(2);\r\n\tprintf(\"%d\\n\", res.res);\r\n\treturn 0;\r\n}\/\/ OJ:: LG","prob_desc_sample_outputs":"[\"2\", \"294\", \"50657649\"]","lang_cluster":"C++","code_uid":"fdd55e70a76edfacb8411bc6ffdf5152","prob_desc_notes":"NoteIn the first test case, these are the only two stupid $$$2\\times 2$$$ colorings.  ","prob_desc_output_spec":"Output a single integer \u2014 the number of stupid colorings modulo $$$998244353$$$.","prob_desc_output_to":"standard output","prob_desc_description":"There is a grid with $$$n$$$ rows and $$$m$$$ columns. Every cell of the grid should be colored either blue or yellow.A coloring of the grid is called stupid if every row has exactly one segment of blue cells and every column has exactly one segment of yellow cells.In other words, every row must have at least one blue cell, and all blue cells in a row must be consecutive. Similarly, every column must have at least one yellow cell, and all yellow cells in a column must be consecutive.  An example of a stupid coloring.   Examples of clever colorings. The first coloring is missing a blue cell in the second row, and the second coloring has two yellow segments in the second column. How many stupid colorings of the grid are there? Two colorings are considered different if there is some cell that is colored differently.","length":57,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['0\\n']}, {'input': '3 3', 'output': ['18\\n']}, {'input': '5 5', 'output': ['1806\\n']}, {'input': '10 10', 'output': ['758923787\\n']}, {'input': '15 15', 'output': ['342618256\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 222\", \"4 190\", \"7 1\"]","prob_desc_input_spec":"The only line of the input contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u200910, 1\u2009\u2264\u2009k\u2009\u2264\u2009240)\u00a0\u2014 the number of the problems in the contest and the number of minutes Limak needs to get to the party from his house.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\n\nusing namespace std;\nlong n, k, m, kq=0;\nint main()\n{\n    cin>>n>>k;\n    m=240-k;\n    for(int i=1;i<=n;i++)\n    {\n        if(m-(i*5)>=0) kq++;\n        else break;\n        m-= i*5;\n    }\n    cout<<kq;\n}\n","prob_desc_sample_outputs":"[\"2\", \"4\", \"7\"]","lang_cluster":"C++","code_uid":"6b85dd45fd3c04780a7d4eaaab6c14b8","prob_desc_notes":"NoteIn the first sample, there are 3 problems and Limak needs 222 minutes to get to the party. The three problems require 5, 10 and 15 minutes respectively. Limak can spend 5\u2009+\u200910\u2009=\u200915 minutes to solve first two problems. Then, at 20:15 he can leave his house to get to the party at 23:57 (after 222 minutes). In this scenario Limak would solve 2 problems. He doesn't have enough time to solve 3 problems so the answer is 2.In the second sample, Limak can solve all 4 problems in 5\u2009+\u200910\u2009+\u200915\u2009+\u200920\u2009=\u200950 minutes. At 20:50 he will leave the house and go to the party. He will get there exactly at midnight.In the third sample, Limak needs only 1 minute to get to the party. He has enough time to solve all 7 problems.","prob_desc_output_spec":"Print one integer, denoting the maximum possible number of problems Limak can solve so that he could get to the party at midnight or earlier.","prob_desc_output_to":"standard output","prob_desc_description":"Limak is going to participate in a contest on the last day of the 2016. The contest will start at 20:00 and will last four hours, exactly until midnight. There will be n problems, sorted by difficulty, i.e. problem 1 is the easiest and problem n is the hardest. Limak knows it will take him 5\u00b7i minutes to solve the i-th problem.Limak's friends organize a New Year's Eve party and Limak wants to be there at midnight or earlier. He needs k minutes to get there from his house, where he will participate in the contest first.How many problems can Limak solve if he wants to make it to the party?","length":16,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 10', 'output': ['9\\n']}, {'input': '5 50', 'output': ['5\\n']}, {'input': '7 100', 'output': ['5\\n']}, {'input': '6 30', 'output': ['6\\n']}, {'input': '8 120', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\", \"3\"]","prob_desc_input_spec":"Input contains one integer number A (3\u2009\u2264\u2009A\u2009\u2264\u20091000).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nlong long int i,j=0,n,c,sum=0,x,a,b,f=0;\nint base(int k,int l)\n{\n    sum=0;\n    while(k!=0)\n    {\n        sum+=k%l;\n        k\/=l;\n\n    }\n    return sum;\n}\nint gcd(int a,int b)\n{\n    return(b==0?a:gcd(b,a%b));\n}\nint main()\n{   f=0;\n    cin>>n;\n    for(i=2;i<n;i++)\n        f+=base(n,i);\n        j=gcd(f,n-2);\n       cout<<(f\/j)<<\"\/\"<<(n-2)\/j<<endl;\n}\n","prob_desc_sample_outputs":"[\"7\/3\", \"2\/1\"]","lang_cluster":"C++","code_uid":"c535a398d0d027358e55b75a7f3a5268","prob_desc_notes":"NoteIn the first sample number 5 written in all bases from 2 to 4 looks so: 101, 12, 11. Sums of digits are 2, 3 and 2, respectively.","prob_desc_output_spec":"Output should contain required average value in format \u00abX\/Y\u00bb, where X is the numerator and Y is the denominator.","prob_desc_output_to":"standard output","prob_desc_description":"Little Petya likes numbers a lot. He found that number 123 in base 16 consists of two digits: the first is 7 and the second is 11. So the sum of digits of 123 in base 16 is equal to 18.Now he wonders what is an average value of sum of digits of the number A written in all bases from 2 to A\u2009-\u20091.Note that all computations should be done in base 10. You should find the result as an irreducible fraction, written in base 10.","length":26,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '6', 'output': ['11\/4\\n']}, {'input': '10', 'output': ['23\/8\\n']}, {'input': '15', 'output': ['91\/13\\n']}, {'input': '20', 'output': ['253\/18\\n']}, {'input': '25', 'output': ['481\/23\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n6\\n1\\n1\\n1\\n1\", \"1\\n10\\n5\", \"3\\n6\\n1\\n6\\n5\", \"3\\n7\\n1\\n6\\n5\"]","prob_desc_input_spec":"The first line contains a single integer $$$n$$$ $$$(1 \\le n \\le 100)$$$ \u2014 the number of benches in the park. The second line contains a single integer $$$m$$$ $$$(1 \\le m \\le 10\\,000)$$$ \u2014 the number of people additionally coming to the park. Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ $$$(1 \\le a_i \\le 100)$$$ \u2014 the initial number of people on the $$$i$$$-th bench.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\n#include <math.h>\nusing namespace std;\n\nint n,m,a;\n\nint main()\n{\n    int kmin, kmax;\n\n    scanf(\"%d\",&n);\n    scanf(\"%d\",&m);\n\n    int cnt = 0,mx=0;\n\n    for (int i=0; i<n; i++){\n        scanf(\"%d\",&a);\n        cnt += a;\n        if(a > mx) mx = a;\n    }\n\n    kmin = ceil((float)(cnt+m)\/n);\n    if(kmin<=mx) kmin = mx;\n    kmax = m + mx;\n\n    cout << kmin << \" \" << kmax << endl;\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"3 7\", \"15 15\", \"6 12\", \"7 13\"]","lang_cluster":"C++","code_uid":"3b3c98933ac76189568606b735832430","prob_desc_notes":"NoteIn the first example, each of four benches is occupied by a single person. The minimum $$$k$$$ is $$$3$$$. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum $$$k$$$ is $$$7$$$. That requires all six new people to occupy the same bench.The second example has its minimum $$$k$$$ equal to $$$15$$$ and maximum $$$k$$$ equal to $$$15$$$, as there is just a single bench in the park and all $$$10$$$ people will occupy it.","prob_desc_output_spec":"Print the minimum possible $$$k$$$ and the maximum possible $$$k$$$, where $$$k$$$ is the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park.","prob_desc_output_to":"standard output","prob_desc_description":"There are $$$n$$$ benches in the Berland Central park. It is known that $$$a_i$$$ people are currently sitting on the $$$i$$$-th bench. Another $$$m$$$ people are coming to the park and each of them is going to have a seat on some bench out of $$$n$$$ available.Let $$$k$$$ be the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park. Calculate the minimum possible $$$k$$$ and the maximum possible $$$k$$$.Nobody leaves the taken seat during the whole process.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n10\\n1\\n2\\n3\\n4\\n5\\n', 'output': ['7 15\\n']}, {'input': '2\\n5\\n5\\n5\\n', 'output': ['8 10\\n']}, {'input': '3\\n3\\n1\\n2\\n3\\n', 'output': ['3 6\\n']}, {'input': '4\\n4\\n1\\n1\\n1\\n1\\n', 'output': ['2 5\\n']}, {'input': '1\\n1\\n1\\n', 'output': ['2 2\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":800.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"2\"]","prob_desc_input_spec":"The only line of the input contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u20092\u00b71018) \u2014 the power in which you need to raise number 5.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <iostream>\nint main(){std::cout<<\"25\\n\";return 0;}\n\/\/1534","prob_desc_sample_outputs":"[\"25\"]","lang_cluster":"C++","code_uid":"1b292e35610de715cc299275f718a033","prob_desc_notes":null,"prob_desc_output_spec":"Output the last two digits of 5n without spaces between them.","prob_desc_output_to":"standard output","prob_desc_description":"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. \"Do I give such a hard task?\" \u2014 the HR manager thought. \"Just raise number 5 to the power of n and get last two digits of the number. Yes, of course, n can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.\"Could you pass the interview in the machine vision company in IT City?","length":3,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2', 'output': ['25']}, {'input': '3', 'output': ['25']}, {'input': '4', 'output': ['25']}, {'input': '5', 'output': ['25']}, {'input': '6', 'output': ['25']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2800.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"4 2 100000007\"]","prob_desc_input_spec":"The first line of input will contain three integers n,\u2009k,\u2009p (1\u2009\u2264\u2009n\u2009\u2264\u2009250\u2009000, 1\u2009\u2264\u2009k\u2009\u2264\u200926, 108\u2009\u2264\u2009p\u2009\u2264\u2009109\u2009+\u2009100, p will be prime).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint n,k,p;\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%p;\n\t\tt=1ll*t*t%p;b>>=1;\n\t}\n\treturn ans;\n}\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nint f[26][250010];\nint fac[250010],inv[250010];\nvoid init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%p;\n\tinv[n]=fpow(fac[n],p-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%p;\n\treturn ;\n}\nint solve(int cur,int S)\n{\n\tif(f[cur][S]!=-1)\n\t\treturn f[cur][S];\n\tif(!S){\n\t\tf[cur][S]=fac[n];\n\t\tfor(int i=1;i<=cur;i++)\n\t\t\tf[cur][S]=1ll*f[cur][S]*(k-i+1)%p;\n\t\treturn f[cur][S];\n\t}\n\tf[cur][S]=0;\n\tint U=S-lowbit(S);\n\tfor(int T=U;T;T=(T-1)&U)\n\t\tf[cur][S]=(f[cur][S]+1ll*inv[S-T]*solve(cur+1,T))%p;\n\tf[cur][S]=(f[cur][S]+1ll*inv[S]*solve(cur+1,0))%p;\n\treturn f[cur][S];\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&k,&p);\n\tint ans=1;\n\tfor(int i=1;i<=n;i++)\n\t\tans=1ll*ans*k%p;\n\tif(n%2==0){\n\t\tinit();\n\t\tmemset(f,-1,sizeof(f));\n\t\tans=(ans-solve(0,n)+p)%p;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"14\"]","lang_cluster":"C++","code_uid":"f019491af76df7f8d3b735e99349717a","prob_desc_notes":"NoteThere are 14 strings that that Alice can win with. For example, some strings are \"bbaa\" and \"baaa\". Alice will lose on strings like \"aaaa\" or \"bbbb\".","prob_desc_output_spec":"Print a single integer, the number of winning words for Alice, modulo p.","prob_desc_output_to":"standard output","prob_desc_description":"Alice and Bob are playing a game with a string of characters, with Alice going first. The string consists n characters, each of which is one of the first k letters of the alphabet. On a player\u2019s turn, they can either arbitrarily permute the characters in the words, or delete exactly one character in the word (if there is at least one character). In addition, their resulting word cannot have appeared before throughout the entire game. The player unable to make a valid move loses the game.Given n,\u2009k,\u2009p, find the number of words with exactly n characters consisting of the first k letters of the alphabet such that Alice will win if both Alice and Bob play optimally. Return this number modulo the prime number p.","length":63,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3 100000009', 'output': ['243']}, {'input': '6 4 100000007', 'output': ['4096']}, {'input': '7 5 100000019', 'output': ['78125']}, {'input': '8 6 100000023', 'output': ['1679616']}, {'input': '9 7 100000031', 'output': ['40353607']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"47\", \"16\", \"78\"]","prob_desc_input_spec":"The single line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) \u2014 the number that needs to be checked.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\n#define op cin.tie(0);ios_base::sync_with_stdio(0);\nusing namespace std;\nint n;\n\nbool lucky(int x)\n{\n    while(x)\n    {\n        if(x%10!= 4 && x%10!=7)\n            return false;\n\n        x\/=10;\n\n    }\n    return true;\n}\n\nint main()\n{\n    op\n\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        if(n%i==0)\n        {\n            if(lucky(i))\n            {\n                cout<<\"YES\";\n                return 0;\n            }\n\n        }\n    }\n\n\n    cout<<\"NO\";\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"4c9f22a49699a8a896a50ca27aab74e4","prob_desc_notes":"NoteNote that all lucky numbers are almost lucky as any number is evenly divisible by itself.In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.","prob_desc_output_spec":"In the only line print \"YES\" (without the quotes), if number n is almost lucky. Otherwise, print \"NO\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number n is almost lucky.","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\n', 'output': ['YES\\n']}, {'input': '77\\n', 'output': ['YES\\n']}, {'input': '1000\\n', 'output': ['YES\\n']}, {'input': '13\\n', 'output': ['NO\\n']}, {'input': '999\\n', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"6 4 3 1\", \"9 3 8 10\"]","prob_desc_input_spec":"The first line contains four space-separated integers n,\u2009x,\u2009y,\u2009c (1\u2009\u2264\u2009n,\u2009c\u2009\u2264\u2009109;\u00a01\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009n;\u00a0c\u2009\u2264\u2009n2).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll n, x, y, c;\n\nbool ok(ll t) {\n\tll res = 0;\n\tll rowl = max(1ll, y - t), rowh = min(n, y + t);\n\tfor (ll row = rowl; row <= rowh; row++) {\n\t\tll tt = t - abs(y - row);\n\t\tll coll = max(1ll, x - tt), colh = min(n, x + tt);\n\t\tres += colh - coll + 1;\n\t\tif (res >= c) return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tcin >> n >> x >> y >> c;\n\tll lo = 0, hi = 2 * n, mid;\n\twhile (lo <= hi) {\n\t\tmid = (lo + hi) \/ 2;\n\t\tif (ok(mid)) hi = mid - 1;\n\t\telse lo = mid + 1;\n\t}\n\tcout << lo << endl;\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"0\", \"2\"]","lang_cluster":"C++","code_uid":"bcc1f29efa45c6cde0b19461c5ba900e","prob_desc_notes":"NoteInitially the first test has one painted cell, so the answer is 0. In the second test all events will go as is shown on the figure. .","prob_desc_output_spec":"In a single line print a single integer \u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"Mr. Bender has a digital table of size n\u2009\u00d7\u2009n, each cell can be switched on or off. He wants the field to have at least c switched on squares. When this condition is fulfilled, Mr Bender will be happy.We'll consider the table rows numbered from top to bottom from 1 to n, and the columns \u2014 numbered from left to right from 1 to n. Initially there is exactly one switched on cell with coordinates (x,\u2009y) (x is the row number, y is the column number), and all other cells are switched off. Then each second we switch on the cells that are off but have the side-adjacent cells that are on.For a cell with coordinates (x,\u2009y) the side-adjacent cells are cells with coordinates (x\u2009-\u20091,\u2009y), (x\u2009+\u20091,\u2009y), (x,\u2009y\u2009-\u20091), (x,\u2009y\u2009+\u20091).In how many seconds will Mr. Bender get happy?","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3 3 1', 'output': ['0\\n']}, {'input': '10 5 5 25', 'output': ['2\\n']}, {'input': '7 4 4 10', 'output': ['1\\n']}, {'input': '8 4 4 16', 'output': ['2\\n']}, {'input': '9 5 5 20', 'output': ['2\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1\", \"2\", \"3\"]","prob_desc_input_spec":"The only line contains a single integer $$$n$$$ ($$$1 \\le n \\le 1000$$$).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\n#include <ext\/pb_ds\/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nusing pii = pair<int, int>;\nusing vi = vector <int>;\n#define F first\n#define S second\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define ll long long\n#define ook order_of_key\n#define fbo find_by_order\n#define sq(x) (x) * (x)\n#define N 2005\n\nll n, dp[N][N], ans, mod = 1e9 + 7, sum[N];\nint main (){\n\tcin >> n;\n\tn *= 2;\n\tdp[0][0] = 1;\n\tfor (int i = 0;i < n;i++)\n\t\tfor (int j = 0;j <= n - i;j++){\n\t\t\tsum[i] = (sum[i] + dp[i][j]) % mod; \n\t\t\tif (j) dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j]) % mod;\n\t\t\tdp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % mod; \n\t\t}\n\tfor (int i = n - 1;i >= 0;i -= 2)\n\t\tans = (ans + sum[i]) % mod;\n\tcout << ans;\n}","prob_desc_sample_outputs":"[\"1\", \"3\", \"9\"]","lang_cluster":"C++","code_uid":"5b3b3b56a327dcd4a4a219da0c23a2c0","prob_desc_notes":"NoteThe pictures below illustrate tries in the first two examples (for clarity, the round brackets are replaced with angle brackets). The maximum matching is highlighted with blue. \u00a0 ","prob_desc_output_spec":"Print exactly one integer\u00a0\u2014 the size of the maximum matching in the trie. Since the answer can be quite large, print it modulo $$$10^9 + 7$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Neko is playing with his toys on the backyard of Aki's house. Aki decided to play a prank on him, by secretly putting catnip into Neko's toys. Unfortunately, he went overboard and put an entire bag of catnip into the toys...It took Neko an entire day to turn back to normal. Neko reported to Aki that he saw a lot of weird things, including a trie of all correct bracket sequences of length $$$2n$$$.The definition of correct bracket sequence is as follows:  The empty sequence is a correct bracket sequence,  If $$$s$$$ is a correct bracket sequence, then $$$(\\,s\\,)$$$ is a correct bracket sequence,  If $$$s$$$ and $$$t$$$ are a correct bracket sequence, then $$$st$$$ is also a correct bracket sequence. For example, the strings \"(())\", \"()()\" form a correct bracket sequence, while \")(\" and \"((\" not.Aki then came up with an interesting problem: What is the size of the maximum matching (the largest set of edges such that there are no two edges with a common vertex) in this trie? Since the answer can be quite large, print it modulo $$$10^9 + 7$$$.","length":33,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n', 'output': ['243\\n']}, {'input': '10\\n', 'output': ['48620\\n']}, {'input': '15\\n', 'output': ['964799622\\n']}, {'input': '20\\n', 'output': ['531565468\\n']}, {'input': '25\\n', 'output': ['898612487\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2\\n3\\n5\\n1\\n8\", \"3\\n1\\n6\\n7\\n25\", \"6\\n4\\n9\\n10\\n89\"]","prob_desc_input_spec":"The first line contains one integer $$$a_1$$$ $$$(1 \\le a_1 \\le 1\\,000)$$$ \u2014 the number of players in the first team. The second line contains one integer $$$a_2$$$ $$$(1 \\le a_2 \\le 1\\,000)$$$ \u2014 the number of players in the second team. The third line contains one integer $$$k_1$$$ $$$(1 \\le k_1 \\le 1\\,000)$$$ \u2014 the maximum number of yellow cards a player from the first team can receive (after receiving that many yellow cards, he leaves the game). The fourth line contains one integer $$$k_2$$$ $$$(1 \\le k_2 \\le 1\\,000)$$$ \u2014 the maximum number of yellow cards a player from the second team can receive (after receiving that many yellow cards, he leaves the game). The fifth line contains one integer $$$n$$$ $$$(1 \\le n \\le a_1 \\cdot k_1 + a_2 \\cdot k_2)$$$ \u2014 the number of yellow cards that have been shown during the match.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits\/stdc++.h>\n#define mp(x, y) make_pair(x, y)\n#define forn(i, a, b) for(size_t i=a; i<b; ++i)\n#define ford(i, a, b) for(size_t i=b-1; i>=a; --i)\n#define all(a) a.begin(), a.end()\n#define sz(a) (size_t)(a).size()\n#define X first\n#define Y second\n#define sqr(x) 1ll*(x)*(x)\n#define pb push_back\n#define fio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing v2int = vector<vint>;\nusing v2ll = vector<vll>;\n\nint main()\n{\n    fio;\n    int a1,a2,k1,k2,n;\n    int MAX=0;\n    cin >>a1>>a2>>k1>>k2>>n;\n\n\n    if (k2<k1)\n    {\n        swap(k1,k2);\n        swap(a1,a2);\n    }\n\n    int t1=a1,t2=a2,nn=n;\n\n    while (a1>0 && n>=k1)\n    {\n        n-=k1;\n        a1--;\n    }\n\n\n    while (a2>0 && n>=k2)\n    {\n        n-=k2;\n        a2--;\n    }\n\n    MAX=(t1-a1)+(t2-a2);\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n    a1=t1;\n    a2=t2;\n    n=nn;\n\n\n    int tmp=a1*(k1-1)+a2*(k2-1);\n\n\n    cout<<(tmp>=n?0:n-tmp)<<\" \"<<MAX<<endl;\n\n}\n","prob_desc_sample_outputs":"[\"0 4\", \"4 4\", \"5 9\"]","lang_cluster":"C++","code_uid":"a190defe8941fca4afaaf9180fb10b13","prob_desc_notes":"NoteIn the first example it could be possible that no player left the game, so the first number in the output is $$$0$$$. The maximum possible number of players that could have been forced to leave the game is $$$4$$$ \u2014 one player from the first team, and three players from the second.In the second example the maximum possible number of yellow cards has been shown $$$(3 \\cdot 6 + 1 \\cdot 7 = 25)$$$, so in any case all players were sent off.","prob_desc_output_spec":"Print two integers \u2014 the minimum and the maximum number of players that could have been thrown out of the game.","prob_desc_output_to":"standard output","prob_desc_description":"The final match of the Berland Football Cup has been held recently. The referee has shown $$$n$$$ yellow cards throughout the match. At the beginning of the match there were $$$a_1$$$ players in the first team and $$$a_2$$$ players in the second team.The rules of sending players off the game are a bit different in Berland football. If a player from the first team receives $$$k_1$$$ yellow cards throughout the match, he can no longer participate in the match \u2014 he's sent off. And if a player from the second team receives $$$k_2$$$ yellow cards, he's sent off. After a player leaves the match, he can no longer receive any yellow cards. Each of $$$n$$$ yellow cards was shown to exactly one player. Even if all players from one team (or even from both teams) leave the match, the game still continues.The referee has lost his records on who has received each yellow card. Help him to determine the minimum and the maximum number of players that could have been thrown out of the game.","length":69,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n4\\n3\\n2\\n20\\n', 'output': ['0 6\\n']}, {'input': '10\\n10\\n2\\n2\\n40\\n', 'output': ['0 20\\n']}, {'input': '7\\n3\\n1\\n2\\n10\\n', 'output': ['0 5\\n']}, {'input': '6\\n4\\n3\\n2\\n18\\n', 'output': ['0 6\\n']}, {'input': '8\\n2\\n4\\n1\\n20\\n', 'output': ['0 5\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 2 3\", \"4 2 3\"]","prob_desc_input_spec":"The first line contains three integers k1, k2 and k3 (1\u2009\u2264\u2009ki\u2009\u2264\u20091500) \u2014 time intervals of the garlands.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\n\nusing namespace std;\n\nint mx,b,c;\ndouble arr[15000],a;\nbool chek;\n\nint main()\n{\n\n\n    for(int i=1; i<=3; i++){\n        cin>>a;\n        if(a==1)arr[1]+=(1\/a);\n        if(!((int)a%2))arr[2]+=(2\/a);\n        if(!((int)a%3))arr[3]+=(3\/a);\n    }\n    if((arr[1]) || (arr[2]>=2) || (arr[3]>=3)){\n        cout<<\"YES\\n\";\n    }else{\n        cout<<\"NO\\n\";\n    }\n    \/\/chek= ((b*c)+(a*c)+(b*a))\/(a*b*c);\n    \/*if(chek){\n        cout<<\"YES\\n\";\n    }else{\n        cout<<\"NO\\n\";\n    }\n    cin>>arr[0]>>arr[1]>>arr[2];\n    sort(arr,arr+3);\n    mx=arr[2]-1;\n    if(!mx){\n        cout<<\"YES\\n\";\n        return 0;\n    }\n    chek = (mx\/arr[0])+(mx\/arr[1]);\n    if(chek>=mx){\n        cout<<\"YES\\n\";\n    }else{\n        cout<<\"NO\\n\";\n    }*\/\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"38dc0ad1bf82c7f97fc1e664f4ed873a","prob_desc_notes":"NoteIn the first example Mishka can choose x1\u2009=\u20091, x2\u2009=\u20092, x3\u2009=\u20091. The first garland will be lit during seconds 1,\u20093,\u20095,\u20097,\u2009..., the second \u2014 2,\u20094,\u20096,\u20098,\u2009..., which already cover all the seconds after the 2-nd one. It doesn't even matter what x3 is chosen. Our choice will lead third to be lit during seconds 1,\u20094,\u20097,\u200910,\u2009..., though.In the second example there is no way to choose such moments of time, there always be some seconds when no garland is lit.","prob_desc_output_spec":"If Mishka can choose moments of time to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit, print YES. Otherwise, print NO.","prob_desc_output_to":"standard output","prob_desc_description":"Mishka is decorating the Christmas tree. He has got three garlands, and all of them will be put on the tree. After that Mishka will switch these garlands on.When a garland is switched on, it periodically changes its state \u2014 sometimes it is lit, sometimes not. Formally, if i-th garland is switched on during x-th second, then it is lit only during seconds x, x\u2009+\u2009ki, x\u2009+\u20092ki, x\u2009+\u20093ki and so on.Mishka wants to switch on the garlands in such a way that during each second after switching the garlands on there would be at least one lit garland. Formally, Mishka wants to choose three integers x1, x2 and x3 (not necessarily distinct) so that he will switch on the first garland during x1-th second, the second one \u2014 during x2-th second, and the third one \u2014 during x3-th second, respectively, and during each second starting from max(x1,\u2009x2,\u2009x3) at least one garland will be lit.Help Mishka by telling him if it is possible to do this!","length":44,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['YES\\n']}, {'input': '2 4 6', 'output': ['YES\\n']}, {'input': '3 6 9', 'output': ['YES\\n']}, {'input': '5 10 15', 'output': ['YES\\n']}, {'input': '7 14 21', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1 1 1 4\", \"5\\n1 1 5 2 1\"]","prob_desc_input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200924). Next line contains n positive integers: the i-th number represents ci (1\u2009\u2264\u2009ci\u2009\u2264\u2009n).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\nint C[25],A[25];\nint N;\nint dfs(int idx,int rem)\n{\n\tif(idx>N)\n\t{\n\t\tfor(int i = 1;i<=N;i++)\n\t\t{\n\t\t\tif(C[i])\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tif(!A[idx])\n\t\treturn dfs(idx+1,A[idx+1]-1);\n\tfor(int i = min(A[idx],rem);i>0;i--)\n\t{\n\t\tif(C[i])\n\t\t{\n\t\t\tC[i]-=1,A[idx]-=i;\n\t\t\tif(dfs(idx,i))\n\t\t\t\treturn 1;\n\t\t\tA[idx]+=i,C[i]+=1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tcin>>N;\n\tC[N] = -1;\n\tfor(int i = 1;i<=N;i++)\n\t{\n\t\tcin>>A[i];\n\t\tC[A[i]]+=1;\n\t\tA[i]-=1;\n\t}\n\tputs(dfs(1,A[1] - 1)?\"YES\":\"NO\");\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"a43b42d1d6fb4a18be2a37103486e11e","prob_desc_notes":null,"prob_desc_output_spec":"Output on the first line \"YES\" (without quotes) if there exist at least one tree following Iahub's restrictions, otherwise output \"NO\" (without quotes). ","prob_desc_output_to":"standard output","prob_desc_description":"Iahub and Iahubina went to a picnic in a forest full of trees. Less than 5 minutes passed before Iahub remembered of trees from programming. Moreover, he invented a new problem and Iahubina has to solve it, otherwise Iahub won't give her the food. Iahub asks Iahubina: can you build a rooted tree, such that  each internal node (a node with at least one son) has at least two sons;  node i has ci nodes in its subtree? Iahubina has to guess the tree. Being a smart girl, she realized that it's possible no tree can follow Iahub's restrictions. In this way, Iahub will eat all the food. You need to help Iahubina: determine if there's at least one tree following Iahub's restrictions. The required tree must contain n nodes.","length":42,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '6\\n1 1 1 1 1 6', 'output': ['YES\\n']}, {'input': '7\\n1 1 1 1 1 1 7', 'output': ['NO\\n']}, {'input': '8\\n1 1 1 1 1 1 1 8', 'output': ['YES\\n']}, {'input': '9\\n1 1 1 1 1 1 1 1 9', 'output': ['NO\\n']}, {'input': '10\\n1 1 1 1 1 1 1 1 1 10', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 2\", \"7 4\"]","prob_desc_input_spec":"The single line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20091\u2009\u2264\u2009k\u2009\u2264\u2009min(8,\u2009n)) \u2014 the number of the houses and the number k from the statement.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst long long MAXN = 2000;\nconst long long mod = 1000000007;\nlong long C[MAXN][MAXN], nn[MAXN], f[MAXN];\nlong long a[MAXN];\nlong long n, k;\nlong long res = 0, s = 0;\n\nlong long next(long long a[], long long l, long long r, long long up)\n{\n\ta[r + 1] = 0;\n\ta[l]++;\n\tfor(long long i = l; i <= r; i++)\n\t\tif (a[i] > up)\n\t\t{\n\t\t\ta[i] = 1;\n\t\t\ta[i + 1]++;\n\t\t}\n\tif (a[r + 1])\n\t\treturn 0;\n\treturn 1;\n}\n\nlong long pow(long long a, long long b)\n{\n\tlong long res = 1;\n\tfor(long long i = 1; i <= b; i++)\n\t\tres = res * a % mod;\n\treturn res;\n}\n\nint main()\n{\n\tcin >> n >> k;\n\tfor(long long i = 0; i <= n; i++)\n\t\tC[i][0] = 1;\n\tfor(long long i = 1; i <= n; i++)\n\t\tfor(long long j = 1; j <= n; j++)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n\tnn[0] = 1;\n\t\/\/for(long long i = 1; i <= n; i++, prlong longf(\"\\n\"))\n\t\/\/\tfor(long long j = 1; j <= n; j++)\n\t\/\/\t\tprlong longf(\"%I64d \", C[i][j]);\n\tfor(long long i = 1; i <= n; i++)\n\t\tnn[i] = nn[i - 1] * i % mod;\n\tres = pow(n - k, n - k);\n\t\n\t\/\/prlong longf(\"%I64d\\n\", res);\n\tfor(long long i = 1; i <= k; i++)\n\t{\n\t\tlong long tmp = C[k - 1][i - 1] * nn[i - 1] % mod;\n\t\tlong long left = k - i;\n\t\tfor(long long j = i + 1; j <= k; j++)\n\t\t\ta[j] = 1;\n\t\tlong long tmp2 = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tlong long flag = 1;\n\t\t\tfor(long long j = i + 1; j <= k; j++)\n\t\t\t{\n\t\t\t\tlong long x = j, ok = 0;\n\t\t\t\tfor(long long l = 1; l <= k; l++)\n\t\t\t\t{\n\t\t\t\t\tx = a[x];\n\t\t\t\t\tif (x <= i)\n\t\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t\tif (!ok)\n\t\t\t\t{\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp2 += flag;\n\t\t\tif (!next(a, i + 1, k, k))\n\t\t\t\tbreak;\n\t\t}\n\t\ts += tmp2 * tmp % mod;\n\t\ts %= mod;\n\t\t\t\n\t}\n\tcout << res * s % mod << endl;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"54\", \"1728\"]","lang_cluster":"C++","code_uid":"de245943a6de74fbf212a0e474d3a999","prob_desc_notes":null,"prob_desc_output_spec":"In a single line print a single integer \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Little penguin Polo loves his home village. The village has n houses, indexed by integers from 1 to n. Each house has a plaque containing an integer, the i-th house has a plaque containing integer pi (1\u2009\u2264\u2009pi\u2009\u2264\u2009n).Little penguin Polo loves walking around this village. The walk looks like that. First he stands by a house number x. Then he goes to the house whose number is written on the plaque of house x (that is, to house px), then he goes to the house whose number is written on the plaque of house px (that is, to house ppx), and so on.We know that:  When the penguin starts walking from any house indexed from 1 to k, inclusive, he can walk to house number 1.  When the penguin starts walking from any house indexed from k\u2009+\u20091 to n, inclusive, he definitely cannot walk to house number 1.  When the penguin starts walking from house number 1, he can get back to house number 1 after some non-zero number of walks from a house to a house. You need to find the number of ways you may write the numbers on the houses' plaques so as to fulfill the three above described conditions. Print the remainder after dividing this number by 1000000007 (109\u2009+\u20097).","length":96,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3', 'output': ['196830000\\n']}, {'input': '15 5', 'output': ['375809638\\n']}, {'input': '20 7', 'output': ['950736326\\n']}, {'input': '25 8', 'output': ['500315450\\n']}, {'input': '30 8', 'output': ['500315450\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 1\", \"3 1 0\"]","prob_desc_input_spec":"The first line contains three space-separated integers a, b and c (0\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u2009231;\u00a0a\u2009+\u2009b\u2009+\u2009c\u2009&gt;\u20090) \u2014 the number of red, green and blue pixels, correspondingly.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nlong long a[3];\nint main()\n{\n\tcin>>a[0]>>a[1]>>a[2];\n\tsort(a,a+3);\n\tif ((a[0]+a[1])%2==0) cout<<a[1]; else cout<<a[2];\n}\n\n","prob_desc_sample_outputs":"[\"1\", \"3\"]","lang_cluster":"C++","code_uid":"7776484008ca3354d1d955d4c769f254","prob_desc_notes":"NoteIn the first test sample the country needs only one fight to achieve peace and prosperity. Besides, it can be any fight whatsoever. For example, let's assume that the green and the blue pixels fight, then the surviving pixel will be red. As a result, after the fight there are two red pixels. There won't be other pixels.In the second sample the following sequence of fights is possible: red and blue, green and red, red and blue. As a result, after all fights there is one green pixel left.","prob_desc_output_spec":"Print a single number \u2014 the minimum number of pixel fights before the country becomes peaceful and prosperous. If making the country peaceful and prosperous is impossible, print -1.","prob_desc_output_to":"standard output","prob_desc_description":"Flatland is inhabited by pixels of three colors: red, green and blue. We know that if two pixels of different colors meet in a violent fight, only one of them survives the fight (that is, the total number of pixels decreases by one). Besides, if pixels of colors x and y (x\u2009\u2260\u2009y) meet in a violent fight, then the pixel that survives the fight immediately changes its color to z (z\u2009\u2260\u2009x;\u00a0z\u2009\u2260\u2009y). Pixels of the same color are friends, so they don't fight.The King of Flatland knows that his land will be peaceful and prosperous when the pixels are of the same color. For each of the three colors you know the number of pixels of this color that inhabit Flatland. Help the king and determine whether fights can bring peace and prosperity to the country and if it is possible, find the minimum number of fights needed to make the land peaceful and prosperous. ","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 2', 'output': ['2']}, {'input': '5 3 1', 'output': ['5']}, {'input': '0 0 1', 'output': ['0']}, {'input': '7 4 3', 'output': ['7']}, {'input': '10 5 0', 'output': ['10']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 10 3 3\", \"3 10 1 3\", \"100 100 1 1000\"]","prob_desc_input_spec":"The first line contains four space-separated integers k, a, b, v (2\u2009\u2264\u2009k\u2009\u2264\u20091000; 1\u2009\u2264\u2009a,\u2009b,\u2009v\u2009\u2264\u20091000) \u2014 the maximum number of sections in the box, the number of nuts, the number of divisors and the capacity of each section of the box.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <bits\/stdc++.h>\n\nusing namespace std;\n\nint k, a, v, b, st, dr, piv;\n\nint check(int x){\n\tint nr = min(x * (k-1), b);\n\treturn ((x + nr) * v); \n}\n\nint main(){\n\/\/\tifstream in(\"tst.in\");\n\/\/\tofstream out(\"tst.out\");\n\tcin >> k >> a >> b >> v;\n\tst = 1;\n\tdr = 10000;\n\twhile(st <= dr){\n\t\tpiv = (st + dr) \/ 2;\n\t\tif(check(piv) >= a) dr = piv - 1;\n\t\telse st = piv + 1;\n\t}\n\tcout << st;\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"3\", \"1\"]","lang_cluster":"C++","code_uid":"b7d203459bab9793e749f94826b5b191","prob_desc_notes":"NoteIn the first sample you can act like this:   Put two divisors to the first box. Now the first box has three sections and we can put three nuts into each section. Overall, the first box will have nine nuts.  Do not put any divisors into the second box. Thus, the second box has one section for the last nut. In the end we've put all the ten nuts into boxes.The second sample is different as we have exactly one divisor and we put it to the first box. The next two boxes will have one section each.","prob_desc_output_spec":"Print a single integer \u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"You have a nuts and lots of boxes. The boxes have a wonderful feature: if you put x (x\u2009\u2265\u20090) divisors (the spacial bars that can divide a box) to it, you get a box, divided into x\u2009+\u20091 sections.You are minimalist. Therefore, on the one hand, you are against dividing some box into more than k sections. On the other hand, you are against putting more than v nuts into some section of the box. What is the minimum number of boxes you have to use if you want to put all the nuts in boxes, and you have b divisors?Please note that you need to minimize the number of used boxes, not sections. You do not have to minimize the number of used divisors.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 5 2 2', 'output': ['2']}, {'input': '4 20 5 4', 'output': ['2']}, {'input': '3 15 4 3', 'output': ['2']}, {'input': '5 25 6 5', 'output': ['2']}, {'input': '6 30 7 6', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 10\\n8 9\", \"3 5\\n4 4 4\"]","prob_desc_input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009k\u2009\u2264\u2009100) denoting the number of marks, received by Noora and the value of highest possible mark. The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009k) denoting marks received by Noora before Leha's hack.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cmath>\nusing namespace std;\nconst int ok=500;\nint n,k,a[ok];\ndouble sum,cnt;\nint av;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tsum+=a[i];\n\t} \n\tint n1=n;\n\tcnt=sum*1.0\/n;\n\tav=round(cnt);\n\twhile(av!=k)\n\t{\n\t\tsum+=k;\n\t\tn++;\n\t\tcnt=sum*1.0\/n;\n\t\tav=round(cnt);\n\t}\n\tprintf(\"%d\",n-n1); \n\treturn 0;\n}","prob_desc_sample_outputs":"[\"4\", \"3\"]","lang_cluster":"C++","code_uid":"27522a25bec9a78e1a85dfe6d487c071","prob_desc_notes":"NoteConsider the first example testcase.Maximal mark is 10, Noora received two marks\u00a0\u2014 8 and 9, so current final mark is 9. To fix it, Leha can add marks [10,\u200910,\u200910,\u200910] (4 marks in total) to the registry, achieving Noora having average mark equal to . Consequently, new final mark is 10. Less number of marks won't fix the situation.In the second example Leha can add [5,\u20095,\u20095] to the registry, so that making average mark equal to 4.5, which is enough to have 5 in the certificate.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 minimal number of additional marks, that Leha has to add in order to change Noora's final mark to k.","prob_desc_output_to":"standard output","prob_desc_description":"Noora is a student of one famous high school. It's her final year in school\u00a0\u2014 she is going to study in university next year. However, she has to get an \u00abA\u00bb graduation certificate in order to apply to a prestigious one.In school, where Noora is studying, teachers are putting down marks to the online class register, which are integers from 1 to k. The worst mark is 1, the best is k. Mark that is going to the certificate, is calculated as an average of all the marks, rounded to the closest integer. If several answers are possible, rounding up is produced. For example, 7.3 is rounded to 7, but 7.5 and 7.8784\u00a0\u2014 to 8. For instance, if Noora has marks [8,\u20099], then the mark to the certificate is 9, because the average is equal to 8.5 and rounded to 9, but if the marks are [8,\u20098,\u20099], Noora will have graduation certificate with 8.To graduate with \u00abA\u00bb certificate, Noora has to have mark k.Noora got n marks in register this year. However, she is afraid that her marks are not enough to get final mark k. Noora decided to ask for help in the internet, where hacker Leha immediately responded to her request. He is ready to hack class register for Noora and to add Noora any number of additional marks from 1 to k. At the same time, Leha want his hack be unseen to everyone, so he decided to add as less as possible additional marks. Please help Leha to calculate the minimal number of marks he has to add, so that final Noora's mark will become equal to k.","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10\\n10', 'output': ['0\\n']}, {'input': '5 5\\n5 5 5 5 5', 'output': ['0\\n']}, {'input': '3 10\\n5 6 7', 'output': ['9\\n']}, {'input': '4 8\\n4 5 6 7', 'output': ['6\\n']}, {'input': '2 6\\n3 4', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"12345\", \"09\"]","prob_desc_input_spec":"The first line contains nonempty sequence consisting of digits from 0 to 9 \u2014 Masha's phone number. The sequence length does not exceed 50.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"    #include <bits\/stdc++.h>\n    using namespace std;\n    #define  MX (int)1e6+1\n    #define pb push_back\n    #define ip pair<int,int>\n    #define  ll long long\n    #define  INF 70\n    const ll mod = 1e9 + 7;\n    #define fastIO ios_base::sync_with_stdio(0);cin.tie(0);\n    ll dp[55][10][10],n;\n    string input;\n     \n    ll solver(int pos,int fav,int last){\n        if(pos==n)return 1;\n     \n        ll &ret=dp[pos][fav][last];\n        if(~ret)return ret;\n        ret=0;\n        if(pos==0){\n            for(int i=0;i<=9;i++){\n                ret+=solver(pos+1,i,i);\n            }\n            return ret;\n        }\n     \n    int choice1=(input[pos]-'0'+last)\/2;\n    int choice2=(input[pos]-'0'+last+1)\/2;\n    ret+=solver(pos+1,fav,choice1);\n    if(choice2!=choice1)ret+=solver(pos+1,fav,choice2);\n        return ret;\n    }\n     \n    int main()\n    {fastIO\n        memset(dp,-1, sizeof(dp));\n    cin>>input;\n    n=input.length();\n    ll ans=solver(0,0,0);\n    for(int i=1;i<n;i++){\n        if(abs(input[i]-input[i-1])>1)return cout<<ans,0;\n    }\n    cout<<ans-1;\n     \n     \n        return 0;}","prob_desc_sample_outputs":"[\"48\", \"15\"]","lang_cluster":"C++","code_uid":"fdc7c0b4e0c1378d0b383442164cf6d9","prob_desc_notes":null,"prob_desc_output_spec":"Output the single number \u2014 the number of phone numbers Masha will dial.","prob_desc_output_to":"standard output","prob_desc_description":"Alas, finding one's true love is not easy. Masha has been unsuccessful in that yet. Her friend Dasha told Masha about a way to determine the phone number of one's Prince Charming through arithmancy. The phone number is divined like that. First one needs to write down one's own phone numbers. For example, let's suppose that Masha's phone number is 12345. After that one should write her favorite digit from 0 to 9 under the first digit of her number. That will be the first digit of the needed number. For example, Masha's favorite digit is 9. The second digit is determined as a half sum of the second digit of Masha's number and the already written down first digit from her beloved one's number. In this case the arithmetic average equals to (2\u2009+\u20099)\u2009\/\u20092\u2009=\u20095.5. Masha can round the number up or down, depending on her wishes. For example, she chooses the digit 5. Having written down the resulting digit under the second digit of her number, Masha moves to finding the third digit in the same way, i.e. finding the half sum the the third digit of her number and the second digit of the new number. The result is (5\u2009+\u20093)\u2009\/\u20092\u2009=\u20094. In this case the answer is unique. Thus, every i-th digit is determined as an arithmetic average of the i-th digit of Masha's number and the i\u2009-\u20091-th digit of her true love's number. If needed, the digit can be rounded up or down. For example, Masha can get: 12345 95444 Unfortunately, when Masha tried dialing the number, she got disappointed: as it turned out, the number was unavailable or outside the coverage area. But Masha won't give up. Perhaps, she rounded to a wrong digit or chose the first digit badly. That's why she keeps finding more and more new numbers and calling them. Count the number of numbers Masha calls. Masha calls all the possible numbers that can be found by the described means of arithmancy, except for, perhaps, her own one.","length":45,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1234567890', 'output': ['90']}, {'input': '11111', 'output': ['10']}, {'input': '9876543210', 'output': ['90']}, {'input': '55555', 'output': ['10']}, {'input': '00000', 'output': ['10']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 3\\n1 1\", \"3 2\\n0 0\", \"1 10\\n5 3\"]","prob_desc_input_spec":"The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n, k \\le 100\\,000$$$)\u00a0\u2014 the number of fast food restaurants on the circle and the distance between the neighboring restaurants, respectively. The second line contains two integers $$$a$$$ and $$$b$$$ ($$$0 \\le a, b \\le \\frac{k}{2}$$$)\u00a0\u2014 the distances to the nearest fast food restaurants from the initial city and from the city Sergey made the first stop at, respectively.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define ll long long \n#define N 100005\n#define all(v) v.begin(),v.end()\n#define pii pair<int,int>\n#define print(x) cout << #x << \"=\" << x << \"\\t\";\n \nll n;\nll k;\nll a;\nll b;\nll ma = -1e18;\nll mi = 1e18;\n \n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(NULL);\n \n    cin >> n >> k >> a >> b;\n    \n    for(ll i=0;i<=n;i++) {\n        ll l = i * k + b + a;\n        if (l <= 0)\n            continue;\n        ll g = __gcd(n * k, l);\n        ll lcm = n * k \/ g;\n        ma = max(ma, lcm);\n        mi = min(mi, lcm);\n    }\n\n    for(ll i=0;i<=n;i++) {\n        ll l = (i + 1) * k - b + a;\n        ll g = __gcd(n * k, l);\n        ll lcm = n * k \/ g;\n        ma = max(ma, lcm);\n        mi = min(mi, lcm);\n    }\n\n    for(ll i=0;i<=n;i++) {\n        ll l = (i + 1) * k - a + b;\n        ll g = __gcd(n * k, l);\n        ll lcm = n * k \/ g;\n        ma = max(ma, lcm);\n        mi = min(mi, lcm);\n    }\n\n    for(ll i=0;i<=n;i++) {\n        ll l = (i + 2) * k - a - b;\n        ll g = __gcd(n * k, l);\n        ll lcm = n * k \/ g;\n        ma = max(ma, lcm);\n        mi = min(mi, lcm);\n    }\n \n    cout << mi << \" \" << ma;\n    return 0;\n}","prob_desc_sample_outputs":"[\"1 6\", \"1 3\", \"5 5\"]","lang_cluster":"C++","code_uid":"c8e38c24e3992f4ddcb3710a098b74ea","prob_desc_notes":"NoteIn the first example the restaurants are located in the cities $$$1$$$ and $$$4$$$, the initial city $$$s$$$ could be $$$2$$$, $$$3$$$, $$$5$$$, or $$$6$$$. The next city Sergey stopped at could also be at cities $$$2, 3, 5, 6$$$. Let's loop through all possible combinations of these cities. If both $$$s$$$ and the city of the first stop are at the city $$$2$$$ (for example, $$$l = 6$$$), then Sergey is at $$$s$$$ after the first stop already, so $$$x = 1$$$. In other pairs Sergey needs $$$1, 2, 3$$$, or $$$6$$$ stops to return to $$$s$$$, so $$$y = 6$$$.In the second example Sergey was at cities with fast food restaurant both initially and after the first stop, so $$$l$$$ is $$$2$$$, $$$4$$$, or $$$6$$$. Thus $$$x = 1$$$, $$$y = 3$$$.In the third example there is only one restaurant, so the possible locations of $$$s$$$ and the first stop are: $$$(6, 8)$$$ and $$$(6, 4)$$$. For the first option $$$l = 2$$$, for the second $$$l = 8$$$. In both cases Sergey needs $$$x=y=5$$$ stops to go to $$$s$$$.","prob_desc_output_spec":"Print the two integers $$$x$$$ and $$$y$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Recently a Golden Circle of Beetlovers was found in Byteland. It is a circle route going through $$$n \\cdot k$$$ cities. The cities are numerated from $$$1$$$ to $$$n \\cdot k$$$, the distance between the neighboring cities is exactly $$$1$$$ km.Sergey does not like beetles, he loves burgers. Fortunately for him, there are $$$n$$$ fast food restaurants on the circle, they are located in the $$$1$$$-st, the $$$(k + 1)$$$-st, the $$$(2k + 1)$$$-st, and so on, the $$$((n-1)k + 1)$$$-st cities, i.e. the distance between the neighboring cities with fast food restaurants is $$$k$$$ km.Sergey began his journey at some city $$$s$$$ and traveled along the circle, making stops at cities each $$$l$$$ km ($$$l &gt; 0$$$), until he stopped in $$$s$$$ once again. Sergey then forgot numbers $$$s$$$ and $$$l$$$, but he remembers that the distance from the city $$$s$$$ to the nearest fast food restaurant was $$$a$$$ km, and the distance from the city he stopped at after traveling the first $$$l$$$ km from $$$s$$$ to the nearest fast food restaurant was $$$b$$$ km. Sergey always traveled in the same direction along the circle, but when he calculated distances to the restaurants, he considered both directions.Now Sergey is interested in two integers. The first integer $$$x$$$ is the minimum number of stops (excluding the first) Sergey could have done before returning to $$$s$$$. The second integer $$$y$$$ is the maximum number of stops (excluding the first) Sergey could have done before returning to $$$s$$$.","length":59,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 3\\n1 1', 'output': ['1 6\\n']}, {'input': '3 2\\n0 0', 'output': ['1 3\\n']}, {'input': '1 10\\n5 3', 'output': ['5 5\\n']}, {'input': '4 5\\n2 2', 'output': ['1 20\\n']}, {'input': '5 7\\n3 3', 'output': ['1 35\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"9 9 5 5 2 1\", \"100 100 52 50 46 56\"]","prob_desc_input_spec":"The first line contains six integers n,\u2009m,\u2009x,\u2009y,\u2009a,\u2009b (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009109,\u20090\u2009\u2264\u2009x\u2009\u2264\u2009n,\u20090\u2009\u2264\u2009y\u2009\u2264\u2009m,\u20091\u2009\u2264\u2009a\u2009\u2264\u2009n,\u20091\u2009\u2264\u2009b\u2009\u2264\u2009m).","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <set>\nusing namespace std;\n#define ll long long\nint n,m,x,y,a,b;\nint main()\n{\n   \/\/ freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m>>x>>y>>a>>b;\n    ll t=__gcd(a,b);\n    a\/=t;\n    b\/=t;\n    ll lx,ly;\n    lx=n\/a*a;\n    ly=m\/b*b;\n    if(lx*b>a*ly)\n    {\n        lx=ly\/b*a;\n    }else  ly=lx\/a*b;\n\/\/    cout<<a<<endl;\n\/\/    cout<<b<<endl;\n\/\/    cout<<lx<<endl;\n\/\/    cout<<ly<<endl;\n    ll x2=x+(lx>>1);\n    ll y2=y+(ly>>1);\n    ll x1=x2-lx;\n    ll y1=y2-ly;\n    ll mx=x1<0?-x1:x2>n?n-x2:0;\n    ll my=y1<0?-y1:y2>m?m-y2:0;\n     printf(\"%lld %lld %lld %lld\\n\",x1+mx,y1+my,x2+mx,y2+my);\n\/\/    mx=my=0;\n\/\/    prllf(\"%d %d %d %d\\n\",x1+mx,y1+my,x2+mx,y2+my);\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"1 3 9 7\", \"17 8 86 92\"]","lang_cluster":"C++","code_uid":"11f88f12eccac7829e320b7bc6a1ffd0","prob_desc_notes":null,"prob_desc_output_spec":"Print four integers x1,\u2009y1,\u2009x2,\u2009y2, which represent the founded sub-rectangle whose left-bottom point is (x1,\u2009y1) and right-up point is (x2,\u2009y2).","prob_desc_output_to":"standard output","prob_desc_description":"You are given a rectangle grid. That grid's size is n\u2009\u00d7\u2009m. Let's denote the coordinate system on the grid. So, each point on the grid will have coordinates \u2014 a pair of integers (x,\u2009y) (0\u2009\u2264\u2009x\u2009\u2264\u2009n,\u20090\u2009\u2264\u2009y\u2009\u2264\u2009m).Your task is to find a maximum sub-rectangle on the grid (x1,\u2009y1,\u2009x2,\u2009y2) so that it contains the given point (x,\u2009y), and its length-width ratio is exactly (a,\u2009b). In other words the following conditions must hold: 0\u2009\u2264\u2009x1\u2009\u2264\u2009x\u2009\u2264\u2009x2\u2009\u2264\u2009n, 0\u2009\u2264\u2009y1\u2009\u2264\u2009y\u2009\u2264\u2009y2\u2009\u2264\u2009m, .The sides of this sub-rectangle should be parallel to the axes. And values x1,\u2009y1,\u2009x2,\u2009y2 should be integers.  If there are multiple solutions, find the rectangle which is closest to (x,\u2009y). Here \"closest\" means the Euclid distance between (x,\u2009y) and the center of the rectangle is as small as possible. If there are still multiple solutions, find the lexicographically minimum one. Here \"lexicographically minimum\" means that we should consider the sub-rectangle as sequence of integers (x1,\u2009y1,\u2009x2,\u2009y2), so we can choose the lexicographically minimum one.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 10 5 5 2 1', 'output': ['1 3 10 8\\n']}, {'input': '100 100 50 50 25 25', 'output': ['12 12 87 87\\n']}, {'input': '1000 1000 500 500 250 250', 'output': ['125 125 875 875\\n']}, {'input': '10000 10000 5000 5000 2500 2500', 'output': ['1250 1250 8750 8750\\n']}, {'input': '100000 100000 50000 50000 25000 25000', 'output': ['12500 12500 87500 87500\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 4 2\", \"6 13 1\", \"1 4 3\"]","prob_desc_input_spec":"A single line contains three space-separated integers a,\u2009b,\u2009k (1\u2009\u2264\u2009a,\u2009b,\u2009k\u2009\u2264\u2009106;\u00a0a\u2009\u2264\u2009b).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <iostream>\nusing namespace std;\nint a,b,k,q[1000006];\nbool pr[1000006];\nint main (){\n     cin >> a >> b >> k;\n     pr[1] = 1;\n     for (int i = 2; i*i <= b; i++){\n          if (pr[i] == 0){\n          for(int j = i*i; j <= b; j+=i)\n               pr[j] = 1;\n          }\n     }\n     \n     for (int i = 1; i <= b; i++){\n          q[i]+=q[i - 1];\n          if (pr[i] == 0) q[i]++;\n     }\n     \n     int x = k,l,y = b - a + 1,ans = -1;\n    if (x > y) {cout<<-1; return 0;}\n     while (x < y){\n          l = (x + y) >> 1;\n          int w = 0;\n          for (int i = a; i <= b - l + 1; i++)\n              if (q[i + l - 1] - q[i - 1] < k) {w = -1; break;}\n          \n          if (w == 0) {y = l; ans = l;}\n          else x = l + 1;\n     }\n    \n     l = x;\n     int w = 0;\n     for (int i = a; i <= b - l + 1; i++)\n         if (q[i + l - 1] - q[i - 1] < k) {w = -1; break;}\n     if (w == 0) ans = l;\n    \n     cout<<ans;\n}\n","prob_desc_sample_outputs":"[\"3\", \"4\", \"-1\"]","lang_cluster":"C++","code_uid":"6669bcbf53f01163d981f9f2ffa9aeef","prob_desc_notes":null,"prob_desc_output_spec":"In a single line print a single integer \u2014 the required minimum l. If there's no solution, print -1.","prob_desc_output_to":"standard output","prob_desc_description":"You've decided to carry out a survey in the theory of prime numbers. Let us remind you that a prime number is a positive integer that has exactly two distinct positive integer divisors.Consider positive integers a, a\u2009+\u20091, ..., b (a\u2009\u2264\u2009b). You want to find the minimum integer l (1\u2009\u2264\u2009l\u2009\u2264\u2009b\u2009-\u2009a\u2009+\u20091) such that for any integer x (a\u2009\u2264\u2009x\u2009\u2264\u2009b\u2009-\u2009l\u2009+\u20091) among l integers x, x\u2009+\u20091, ..., x\u2009+\u2009l\u2009-\u20091 there are at least k prime numbers. Find and print the required minimum l. If no value l meets the described limitations, print -1.","length":39,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 10 3', 'output': ['5']}, {'input': '1 100 25', 'output': ['96']}, {'input': '1 1 1', 'output': ['-1']}, {'input': '5 20 5', 'output': ['10']}, {'input': '10 100 10', 'output': ['29']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 2 433416647\", \"10 3 409693891\", \"65 4 177545087\"]","prob_desc_input_spec":"The single line of the input contains three integers n, d and\u00a0mod (1\u2009\u2264\u2009n\u2009\u2264\u20091000, 2\u2009\u2264\u2009d\u2009\u2264\u200910, 108\u2009\u2264\u2009mod\u2009\u2264\u2009109) \u00a0\u2014 the number of vertices in the tree, the degree of internal vertices and the prime modulo.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\nconst int maxn=1005;\nconst int maxd=11;\nlong long n,d,mod,dp[maxn][maxd],pd[maxn][maxd],f,t[maxd];\ninline long long ksm(long long x,long long n) {\n    long long ret=1;\n    while (n) {\n        if (n&1)\n            ret=ret*x%mod;\n        n>>=1;\n        x=x*x%mod;\n    }\n    return ret;\n}\ninline long long solve() {\n    dp[1][0]=1;\n    for (int i=1;i<=n\/2;++i) {\/\/if (i%(d-1)==0) {\n        f=(i==1)?1:dp[i][d-1];\n        for (int j=1;j<=n;++j)\n            for (int k=0;k<=d;++k)\n                pd[j][k]=0;\n        t[0]=1;\n        for (int j=1;j<=d;++j)\n            t[j]=t[j-1]*(f+j-1)%mod*ksm(j,mod-2)%mod;\n        for (int j=0;j<=d;++j)\n            for (int k=0;k<=d;++k)  if (j+k<=d)\n                for (int l=1;l<=n;++l) if (l+i*k<=n)\n                    pd[l+i*k][j+k]=(pd[l+i*k][j+k]+dp[l][j]*t[k])%mod;\n        for (int j=0;j<=n;++j)\n            for (int k=0;k<=d;++k)\n                \/\/if (pd[j][k])\n                    dp[j][k]=pd[j][k];\n    }\n    long long ret=dp[n][d];\n    if (n%2==0)\n        ret=((ret-dp[n\/2][d-1]*(dp[n\/2][d-1]-1)\/2)%mod+mod)%mod;\n    return ret;\n}\nint main()\n{\n    scanf(\"%I64d%I64d%I64d\",&n,&d,&mod);\n    if (n<=2)\n        puts(\"1\");\n    else\n        printf(\"%I64d\\n\",solve());\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"2\", \"910726\"]","lang_cluster":"C++","code_uid":"4576bec8d0405b7b07a9657304d115f1","prob_desc_notes":null,"prob_desc_output_spec":"Print the number of trees over the modulo mod.","prob_desc_output_to":"standard output","prob_desc_description":"A tree is a connected graph without cycles.Two trees, consisting of n vertices each, are called isomorphic if there exists a permutation p:\u2009{1,\u2009...,\u2009n}\u2009\u2192\u2009{1,\u2009...,\u2009n} such that the edge (u,\u2009v) is present in the first tree if and only if the edge (pu,\u2009pv) is present in the second tree.Vertex of the tree is called internal if its degree is greater than or equal to two.Count the number of different non-isomorphic trees, consisting of n vertices, such that the degree of each internal vertex is exactly d. Print the answer over the given prime modulo mod.","length":48,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '7 3 1000000007', 'output': ['1\\n']}, {'input': '15 4 1000000007', 'output': ['3\\n']}, {'input': '20 5 1000000007', 'output': ['5\\n']}, {'input': '25 6 1000000007', 'output': ['7\\n']}, {'input': '30 7 1000000007', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 11\", \"6 16\"]","prob_desc_input_spec":"The only line of the input contains two integers $$$n$$$ and $$$S$$$ ($$$1 \\le n \\le 100\\,000$$$, $$$1 \\le S \\le 10^9$$$)","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <iostream>\n#include <cstdio>\n#include <cctype>\n#define il inline\n#define vd void\n#define rep(i,x,y) for(register int i=x;i<=y;++i)\n#define drp(i,x,y) for(register int i=x;i>=y;--i)\nusing namespace std;\nconst int Len=2333333;\nchar buf[Len],*p1=buf,*p2=buf,duf[Len],*q1=duf;\nil char gc(); il int rd(); il vd pc(char c); il vd rt(int x); il vd flush();\nint n,s;\nint main(){\/\/sjn AK IOI\n\tcin>>n>>s;\n\tint ans=s\/n;\n\tif(s%n) ++ans;\n\tcout<<ans;\n\treturn flush(),0;\n}\n\nil char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,Len,stdin),p1==p2)?-1:*p1++;}\nil int rd(){char c;\n\twhile(!isdigit(c=gc())&&c!='-');\n\tint f=c=='-'?c=gc(),1:0,x=c^48;\n\twhile(isdigit(c=gc())) x=((x+(x<<2))<<1)+(c^48);\n\treturn f?-x:x;\n}\nil vd pc(char c){q1==duf+Len&&fwrite(q1=duf,1,Len,stdout),*q1++=c;}\nil vd rt(int x){x<0?pc('-'),x=-x:0,pc((x>=10?rt(x\/10),x%10:x)+48);}\nil vd flush(){fwrite(duf,1,q1-duf,stdout);}","prob_desc_sample_outputs":"[\"3\", \"3\"]","lang_cluster":"C++","code_uid":"96808c606ce3c68d14d0602564b333a1","prob_desc_notes":"NoteIn the first example, some of the possible ways to get sum $$$11$$$ with $$$3$$$ coins are:   $$$(3, 4, 4)$$$ $$$(2, 4, 5)$$$ $$$(1, 5, 5)$$$ $$$(3, 3, 5)$$$ It is impossible to get sum $$$11$$$ with less than $$$3$$$ coins.In the second example, some of the possible ways to get sum $$$16$$$ with $$$3$$$ coins are:   $$$(5, 5, 6)$$$ $$$(4, 6, 6)$$$ It is impossible to get sum $$$16$$$ with less than $$$3$$$ coins.","prob_desc_output_spec":"Print exactly one integer\u00a0\u2014 the minimum number of coins required to obtain sum $$$S$$$.","prob_desc_output_to":"standard output","prob_desc_description":"You have unlimited number of coins with values $$$1, 2, \\ldots, n$$$. You want to select some set of coins having the total value of $$$S$$$. It is allowed to have multiple coins with the same value in the set. What is the minimum number of coins required to get sum $$$S$$$?","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['1\\n']}, {'input': '100000 1000000000', 'output': ['10000\\n']}, {'input': '50000 50000', 'output': ['1\\n']}, {'input': '2 3', 'output': ['2\\n']}, {'input': '99999 1000000000', 'output': ['10001\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 3\", \"3 2\", \"5 0\"]","prob_desc_input_spec":"The first line of the input contains two space-separated integers n and m (0\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091\u2009000\u2009000, n\u2009+\u2009m\u2009&gt;\u20090)\u00a0\u2014 the number of students using two-block pieces and the number of students using three-block pieces, respectively.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <stack>\n#include <queue>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#define sqr(x) (x)*(x)\n#define fi first\n#define se second\n#define ONLINE_JUDGE\nusing namespace std;\ntypedef long long ll;\nconst int mod=int(1e9+7);\nint n,m;\nint main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif \/\/ONLINE_JUDGE\n    scanf(\"%d%d\",&n,&m);\n\n    for (int i=0; ; i++){\n        if (i\/2>=n && i\/3>=m && i\/2+i\/3-i\/6>=n+m){\n            printf(\"%d\",i);\n            break;\n        }\n    }\n\n    #ifndef ONLINE_JUDGE\n    fclose(stdin);\n    fclose(stdout);\n    #endif \/\/ ONLINE_JUDGE\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"9\", \"8\", \"10\"]","lang_cluster":"C++","code_uid":"ee91e2f095648432d1644a654b8f2267","prob_desc_notes":"NoteIn the first case, the student using two-block pieces can make a tower of height 4, and the students using three-block pieces can make towers of height 3, 6, and 9 blocks. The tallest tower has a height of 9 blocks.In the second case, the students can make towers of heights 2, 4, and 8 with two-block pieces and towers of heights 3 and 6 with three-block pieces, for a maximum height of 8 blocks.","prob_desc_output_spec":"Print a single integer, denoting the minimum possible height of the tallest tower.","prob_desc_output_to":"standard output","prob_desc_description":"Students in a class are making towers of blocks. Each student makes a (non-zero) tower by stacking pieces lengthwise on top of each other. n of the students use pieces made of two blocks and m of the students use pieces made of three blocks.The students don\u2019t want to use too many blocks, but they also want to be unique, so no two students\u2019 towers may contain the same number of blocks. Find the minimum height necessary for the tallest of the students' towers.","length":39,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2', 'output': ['6\\n']}, {'input': '4 1', 'output': ['8\\n']}, {'input': '0 5', 'output': ['15\\n']}, {'input': '3 3', 'output': ['9\\n']}, {'input': '1 1', 'output': ['3\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1100.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"3000\"]","prob_desc_input_spec":"The only line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the prediction on the number of people who will buy the game.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include<bits\/stdc++.h>\nusing namespace std ;\nlong long n, ans ;\n\nint main()\n{\n    cin >> n ;\n    if(2520 > n) cout << 0 << endl;\n    else\n    {\n        cout << n \/ 2520 << endl;\n    }\n}\n","prob_desc_sample_outputs":"[\"1\"]","lang_cluster":"C++","code_uid":"72b3d7f2193cdfff9bc674c63c12ebf2","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer showing how many numbers from 1 to n are divisible by all numbers from 2 to 10.","prob_desc_output_to":"standard output","prob_desc_description":"IT City company developing computer games invented a new way to reward its employees. After a new game release users start buying it actively, and the company tracks the number of sales with precision to each transaction. Every time when the next number of sales is divisible by all numbers from 2 to 10 every developer of this game gets a small bonus.A game designer Petya knows that the company is just about to release a new game that was partly developed by him. On the basis of his experience he predicts that n people will buy the game during the first month. Now Petya wants to determine how many times he will get the bonus. Help him to know it.","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['0']}, {'input': '2520', 'output': ['1']}, {'input': '5040', 'output': ['2']}, {'input': '10000', 'output': ['3']}, {'input': '1018', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 4\", \"0 10\", \"107 109\"]","prob_desc_input_spec":"The first and only line of input contains two space-separated integers a and b (0\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u20091018).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\n\nusing namespace std ;\ntypedef long long ll;\n\nll a, b, ans;\n\nint main () {\n    cin >> a >> b;\n    if(a == b) {\n        cout << 1;\n        return 0;\n    }\n    long long x = b - a;\n    \/\/cout << x << '\\n';\n    if (x >= 5){\n        cout << 0;\n        return 0;\n    }\n    if (x == 1){\n        cout << b % 10;\n        return 0;\n    }\n    ans = 1;\n    for (long long i = a + 1; i <= b; ++i){\n        ans *= i;\n        ans %= 10;\n    }\n    cout << ans % 10;\n    return 0;\n}\n\/*\n998244355 998244359\n*\/\n","prob_desc_sample_outputs":"[\"2\", \"0\", \"2\"]","lang_cluster":"C++","code_uid":"60a7758c7fb2a0007efafd350013730b","prob_desc_notes":"NoteIn the first example, the last digit of  is 2;In the second example, the last digit of  is 0;In the third example, the last digit of  is 2.","prob_desc_output_spec":"Output one line containing a single decimal digit\u00a0\u2014 the last digit of the value that interests Koyomi.","prob_desc_output_to":"standard output","prob_desc_description":"Even if the world is full of counterfeits, I still regard it as wonderful.Pile up herbs and incense, and arise again from the flames and ashes of its predecessor\u00a0\u2014 as is known to many, the phoenix does it like this.The phoenix has a rather long lifespan, and reincarnates itself once every a! years. Here a! denotes the factorial of integer a, that is, a!\u2009=\u20091\u2009\u00d7\u20092\u2009\u00d7\u2009...\u2009\u00d7\u2009a. Specifically, 0!\u2009=\u20091.Koyomi doesn't care much about this, but before he gets into another mess with oddities, he is interested in the number of times the phoenix will reincarnate in a timespan of b! years, that is, . Note that when b\u2009\u2265\u2009a this value is always integer.As the answer can be quite large, it would be enough for Koyomi just to know the last digit of the answer in decimal representation. And you're here to provide Koyomi with this knowledge.","length":34,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 6', 'output': ['0\\n']}, {'input': '0 0', 'output': ['1\\n']}, {'input': '5 10', 'output': ['0\\n']}, {'input': '7 8', 'output': ['6\\n']}, {'input': '9 9', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"3 2 1\", \"4 2 2\", \"3 2 2\"]","prob_desc_input_spec":"The single line of the input contains integers n, w and b (3\u2009\u2264\u2009n\u2009\u2264\u20094000, 2\u2009\u2264\u2009w\u2009\u2264\u20094000, 1\u2009\u2264\u2009b\u2009\u2264\u20094000) \u2014 the number of days, the number of good events and the number of not-so-good events. It is guaranteed that w\u2009+\u2009b\u2009\u2265\u2009n.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define N 4010\n#define mo 1000000009\n#define int64 long long\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m,w,b;\nint64 f1[N],f2[N],an;\ninline int64 C(int n,int m) {\n    if (m>n) return 0;\n    if (!m) return 1;\n    return f1[n]*f2[m]%mo*f2[n-m]%mo;\n}\nint main() {\n    f1[0]=1;\n    For(i,1,N-1) f1[i]=f1[i-1]*i%mo;\n    f2[0]=f2[1]=1;\n    For(i,2,N-1) f2[i]=(-f2[mo%i]*(mo\/i)%mo+mo)%mo;\n    For(i,2,N-1) f2[i]=f2[i]*f2[i-1]%mo;\n    scanf(\"%d%d%d\",&n,&w,&b);\n    For(i,1,n-2) an=(an+f1[w]*f1[b]%mo*C(b-1,i-1)%mo*C(w-1,n-i-1)%mo*(n-i-1))%mo;\n    printf(\"%I64d\",an);  return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"4\", \"4\"]","lang_cluster":"C++","code_uid":"ca9cbd0456e44d7f3bd1397b54f0f3e3","prob_desc_notes":"NoteWe'll represent the good events by numbers starting from 1 and the not-so-good events \u2014 by letters starting from 'a'. Vertical lines separate days.In the first sample the possible ways are: \"1|a|2\" and \"2|a|1\". In the second sample the possible ways are: \"1|a|b|2\", \"2|a|b|1\", \"1|b|a|2\" and \"2|b|a|1\". In the third sample the possible ways are: \"1|ab|2\", \"2|ab|1\", \"1|ba|2\" and \"2|ba|1\".","prob_desc_output_spec":"Print the required number of ways modulo 1000000009 (109\u2009+\u20099).","prob_desc_output_to":"standard output","prob_desc_description":"Polycarpus is sure that his life fits the description: \"first there is a white stripe, then a black one, then a white one again\". So, Polycarpus is sure that this rule is going to fulfill during the next n days. Polycarpus knows that he is in for w good events and b not-so-good events. At least one event is going to take place during each day. As each day is unequivocally characterizes as a part of a white or a black stripe, then each day is going to have events of the same type only (ether good or not-so-good).What is the number of distinct ways this scenario can develop over the next n days if Polycarpus is in for a white stripe (a stripe that has good events only, the stripe's length is at least 1 day), the a black stripe (a stripe that has not-so-good events only, the stripe's length is at least 1 day) and a white stripe again (a stripe that has good events only, the stripe's length is at least 1 day). Each of n days will belong to one of the three stripes only.Note that even the events of the same type are distinct from each other. Even if some events occur on the same day, they go in some order (there are no simultaneous events).Write a code that prints the number of possible configurations to sort the events into days. See the samples for clarifications on which scenarios should be considered distinct. Print the answer modulo 1000000009 (109\u2009+\u20099).","length":26,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 2 1', 'output': ['2']}, {'input': '4 2 2', 'output': ['4']}, {'input': '3 2 2', 'output': ['4']}, {'input': '5 3 2', 'output': ['36']}, {'input': '6 4 2', 'output': ['288']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"11\\n00000000008\", \"22\\n0011223344556677889988\", \"11\\n31415926535\"]","prob_desc_input_spec":"The first line contains an integer $$$n$$$\u00a0\u2014 the number of cards with digits that you have ($$$1 \\leq n \\leq 100$$$). The second line contains a string of $$$n$$$ digits (characters \"0\", \"1\", ..., \"9\") $$$s_1, s_2, \\ldots, s_n$$$. The string will not contain any other characters, such as leading or trailing spaces.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nint num=0,n;\nchar ch;\nint main() {\n    scanf(\"%d\\n\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%c\",&ch);\n        if (ch=='8') num++;\n    }\n    if (num==0) printf(\"0\");\n    else {\n        if (num*11<=n) printf(\"%d\",num);\n        else printf(\"%d\",n\/11);\n    }\n    return 0;\n}","prob_desc_sample_outputs":"[\"1\", \"2\", \"0\"]","lang_cluster":"C++","code_uid":"2c04b42e8c8c1ad429e444aef500adef","prob_desc_notes":"NoteIn the first example, one phone number, \"8000000000\", can be made from these cards.In the second example, you can make two phone numbers from the cards, for example, \"80123456789\" and \"80123456789\".In the third example you can't make any phone number from the given cards.","prob_desc_output_spec":"If at least one phone number can be made from these cards, output the maximum number of phone numbers that can be made. Otherwise, output 0.","prob_desc_output_to":"standard output","prob_desc_description":"Let's call a string a phone number if it has length 11 and fits the pattern \"8xxxxxxxxxx\", where each \"x\" is replaced by a digit.For example, \"80123456789\" and \"80000000000\" are phone numbers, while \"8012345678\" and \"79000000000\" are not.You have $$$n$$$ cards with digits, and you want to use them to make as many phone numbers as possible. Each card must be used in at most one phone number, and you don't have to use all cards. The phone numbers do not necessarily have to be distinct.","length":17,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '15\\n888888888888888', 'output': ['1\\n']}, {'input': '33\\n888888888888888888888888888888888', 'output': ['3\\n']}, {'input': '11\\n12345678901', 'output': ['0\\n']}, {'input': '22\\n8888888888888888888888', 'output': ['2\\n']}, {'input': '44\\n88888888888888888888888888888888888888888888', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"1024 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 993244853\", \"2 993244853\", \"3 993244853\", \"2019 993244853\", \"2020 437122297\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 250\\,000$$$, $$$10^8 \\le m \\le 10^9$$$, $$$m$$$ is prime).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"\/\/#include <ext\/pb_ds\/assoc_container.hpp>\n\/\/#include <ext\/pb_ds\/tree_policy.hpp>\n\/\/#include<bits\/stdc++.h>\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <iterator>\n#include <bitset>\n#include <assert.h>\n#include <new>\n#include <sstream>\n#include <time.h>\n\n\n\/\/using    namespace __gnu_pbds;\nusing namespace std;\n\n\n\/*** Optimization ***\/\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n\n\n\/*** Typedef ***\/\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\n\/*** Input ***\/\n#define sci1(a) scanf(\"%d\",&a)\n#define sci2(a,b) scanf(\"%d %d\",&a,&b)\n#define scln1(a) scanf(\"%lld\",&a)\n#define scln2(a,b) scanf(\"%lld %lld\",&a,&b)\n#define scln3(a,b,c) scanf(\"%lld %lld %lld\",&a,&b,&c)\n\n\n\/*** Output ***\/\n#define pf1(a) printf(\"%d\\n\",a)\n#define pf2(a,b) printf(\"%d %d\\n\",a,b)\n#define pfln1(a) printf(\"%lld\\n\",a)\n#define pfln2(a,b) printf(\"%lld %lld\\n\",a,b)\n\n\n\/*** Loops ***\/\n#define foR0(num) for(ll i = 0; i < num; i++)\n#define foR1(num) for(ll i = 1; i <= num; i++)\n#define foRev(num) for(ll i = num - 1; i >= 0; i--)\n#define forIn(arr, num) for(ll i = 0; i < num; i++) cin>>arr[i];\n#define forIn1(arr, num) for(ll i = 1; i <= num; i++) cin>>arr[i];\n#define vpnt(ans) for(ll i = 0; i < ans.size(); i++) cout << ans[i] << (i + 1 < ans.size() ? ' ' : '\\n');\n#define apnt(arr, num) for(ll i = 0; i < num; i++) cout << arr[i] << (i + 1 < num ? ' ' : '\\n');\n\n\n\/*** Define Values ***\/\n\n#define    ff              first\n#define    ss              second\n#define    re              return\n#define    MP              make_pair\n#define    pb              push_back\n#define    SZ(x)           ((int) (x).size())\n\n\n#define    EPS             10E-10\n#define    mxx             100005\n#define    MOD             1000000007\n#define    iseq(a,b)       (fabs(a-b)<EPS)\n#define    PI              3.141592653589793238462643\n\n\n#define    gcd(a, b)       __gcd(a,b)\n#define    min3(a,b,c)     min(a,min(b,c))\n#define    max3(a,b,c)     max(a,max(b,c))\n#define    lcm(a, b)       ((a)*(b)\/gcd(a,b))\n#define    min4(a,b,c,d)   min(d,min(a,min(b,c)))\n#define    max4(a,b,c,d)   max(d,max(a,max(b,c)))\n#define    input           freopen(\"input.txt\",\"rt\", stdin)\n#define    output          freopen(\"output.txt\",\"wt\", stdout)\n\n\n#define    all(v)          v.begin(),v.end()\n#define    mem(nam,val)    memset(nam, val, sizeof(nam))\n#define    Unique(X)       (X).resize(unique(all(X))-(X).begin())\n#define    get_pos(c,x)    (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define    IOS             ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n\n\/*** STLs ***\/\ntypedef vector <ll> vll;\ntypedef set <ll> sll;\ntypedef multiset <ll> msll;\ntypedef queue <ll> qll;\ntypedef stack <ll> stll;\ntypedef map <ll, ll> mll;\ntypedef pair <ll, ll> pll;\ntypedef vector <pair <ll , ll> > vpll;\n\n\n\/*** BitWise Operations\n\/\/\/int Set(int N,int pos){return N=N | (1<<pos);}\n\/\/\/int reset(int N,int pos){return N= N & ~(1<<pos);}\n\/\/\/bool check(int N,int pos){return (bool)(N & (1<<pos));}\n***\/\n\n\n\/*** Grids\n\/\/\/const int fx[] = {+1,-1,+0,+0};\n\/\/\/const int fy[] = {+0,+0,+1,-1};\n\/\/\/const int fx[] = {+0,+0,+1,-1,-1,+1,-1,+1}; \/\/\/King's move\n\/\/\/const int fy[] = {-1,+1,+0,+0,+1,+1,-1,-1}; \/\/\/king's Move\n\/\/\/const int fx[] = {-2,-2,-1,-1,+1,+1,+2,+2}; \/\/\/knight's move\n\/\/\/const int fy[] = {-1,+1,-2,+2,-2,+2,-1,+1}; \/\/\/knight's move\n***\/\n\n\n\/*** Functions\n\/\/\/typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\/\/\/ll toint(string s){ll n=0,k=1;for(int i=s.size()-1; i>=0; i--){n += ((s[i]-'0')*k);k*=10;}return n;}\n\/\/\/string tostring(ll x){string s=\"\";while(x){s += (x%10)+'0';x\/=10;}reverse(s.begin(),s.end());return s;}\n\/\/\/bool sortinrev(const pair<ll,ll> &a,const pair<ll,ll> &b)return (a.first > b.first);\n\/\/\/priority_queue< pll ,vector<pll>,greater<pll> >p;\n\/\/\/cout<<*X.find_by_order(0)<<endl;\n\/\/\/cout<<X.order_of_key(-5)<<endl;\n***\/\n\n\n\/*** Some Prints ***\/\n#define en cout << '\\n';\n#define no cout << \"NO\" << '\\n'\n#define yes cout << \"YES\" << '\\n'\n\n\nll A[1000005];\nll B[1000005];\nll fac[1000005];\n\nvoid fact(ll m)\n{\n    fac[0]=1;\n    for(ll i=1;i<=250005;i++)\n    {\n        fac[i]=(i*fac[i-1])%m;\n    }\n}\n\nint main()\n{\n    IOS;\n    ll tst=1;\n   \/\/ cin>>tst;\n    for(ll tt=1;tt<=tst;tt++)\n    {\n        \/\/code\n        ll n,m;\n        cin>>n>>m;\n        fact(m);\n        ll res=(fac[n]*n)%m;\n        for(ll i=1;i<n;i++)\n        {\n            ll dif=i+1;\n            dif=fac[dif];\n            dif=(dif*(n-i))%m;\n            ll val=(dif*fac[n-i])%m;\n           \/\/ val=(val*fac[n-i]);\n            res=(res+val)%m;\n        }\n        cout<<res<<endl;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"6\", \"32\", \"923958830\", \"265955509\"]","lang_cluster":"C++","code_uid":"35ec4283baa9fac581f6df84ffc8788f","prob_desc_notes":"NoteFor sample input $$$n=3$$$, let's consider all permutations of length $$$3$$$:  $$$[1, 2, 3]$$$, all subsegments are framed segment. Happiness is $$$6$$$.  $$$[1, 3, 2]$$$, all subsegments except $$$[1, 2]$$$ are framed segment. Happiness is $$$5$$$.  $$$[2, 1, 3]$$$, all subsegments except $$$[2, 3]$$$ are framed segment. Happiness is $$$5$$$.  $$$[2, 3, 1]$$$, all subsegments except $$$[2, 3]$$$ are framed segment. Happiness is $$$5$$$.  $$$[3, 1, 2]$$$, all subsegments except $$$[1, 2]$$$ are framed segment. Happiness is $$$5$$$.  $$$[3, 2, 1]$$$, all subsegments are framed segment. Happiness is $$$6$$$. Thus, the sum of happiness is $$$6+5+5+5+5+6 = 32$$$.","prob_desc_output_spec":"Print $$$r$$$ ($$$0 \\le r &lt; m$$$), the sum of happiness for all permutations of length $$$n$$$, modulo a prime number $$$m$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Recall that the permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).A sequence $$$a$$$ is a subsegment of a sequence $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. We will denote the subsegments as $$$[l, r]$$$, where $$$l, r$$$ are two integers with $$$1 \\le l \\le r \\le n$$$. This indicates the subsegment where $$$l-1$$$ elements from the beginning and $$$n-r$$$ elements from the end are deleted from the sequence.For a permutation $$$p_1, p_2, \\ldots, p_n$$$, we define a framed segment as a subsegment $$$[l,r]$$$ where $$$\\max\\{p_l, p_{l+1}, \\dots, p_r\\} - \\min\\{p_l, p_{l+1}, \\dots, p_r\\} = r - l$$$. For example, for the permutation $$$(6, 7, 1, 8, 5, 3, 2, 4)$$$ some of its framed segments are: $$$[1, 2], [5, 8], [6, 7], [3, 3], [8, 8]$$$. In particular, a subsegment $$$[i,i]$$$ is always a framed segments for any $$$i$$$ between $$$1$$$ and $$$n$$$, inclusive.We define the happiness of a permutation $$$p$$$ as the number of pairs $$$(l, r)$$$ such that $$$1 \\le l \\le r \\le n$$$, and $$$[l, r]$$$ is a framed segment. For example, the permutation $$$[3, 1, 2]$$$ has happiness $$$5$$$: all segments except $$$[1, 2]$$$ are framed segments.Given integers $$$n$$$ and $$$m$$$, Jongwon wants to compute the sum of happiness for all permutations of length $$$n$$$, modulo the prime number $$$m$$$. Note that there exist $$$n!$$$ (factorial of $$$n$$$) different permutations of length $$$n$$$.","length":201,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 1000000007', 'output': ['1200000020\\n']}, {'input': '10 1000000007', 'output': ['725000006\\n']}, {'input': '100 1000000007', 'output': ['782204094\\n']}, {'input': '1000 1000000007', 'output': ['531477278\\n']}, {'input': '250000 1000000007', 'output': ['226732378\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 2 1 3\", \"7 2 2 4\", \"3 5 9 1\"]","prob_desc_input_spec":"The first line of the input contains four space-separated positive integer numbers not exceeding 100 \u2014 lengthes of the sticks.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nint a[5];\nint u[4];\nbool f[5],falg;\nvoid dfs(int dep)\n{\n    if(dep==4)\n    {\n        if(u[1]+u[2]>u[3]&&u[1]+u[3]>u[2]&&u[2]+u[3]>u[1])\n        {\n            printf(\"TRIANGLE\");\n            exit(0);\n        }\n        if(u[1]+u[2]>=u[3]&&u[1]+u[3]>=u[2]&&u[2]+u[3]>=u[1])falg=true;\n        return;\n    }\n    for(int i=1;i<=4;i++)\n    if(f[i]==false)\n    {\n        f[i]=true;\n        u[dep]=a[i];\n        dep++;\n        dfs(dep);\n        dep--;\n        u[dep]=0;\n        f[i]=false;\n    }\n}\nint main()\n{\n    scanf(\"%d%d%d%d\",a+1,a+2,a+3,a+4);\n    dfs(1);\n    if(falg==true)printf(\"SEGMENT\");\n    else printf(\"IMPOSSIBLE\");\nreturn 0;\n}","prob_desc_sample_outputs":"[\"TRIANGLE\", \"SEGMENT\", \"IMPOSSIBLE\"]","lang_cluster":"C++","code_uid":"5d12c52cc1db4ba5b3eb58fe24413800","prob_desc_notes":null,"prob_desc_output_spec":"Output TRIANGLE if it is possible to construct a non-degenerate triangle. Output SEGMENT if the first case cannot take place and it is possible to construct a degenerate triangle. Output IMPOSSIBLE if it is impossible to construct any triangle. Remember that you are to use three sticks. It is not allowed to break the sticks or use their partial length.","prob_desc_output_to":"standard output","prob_desc_description":"Johnny has a younger sister Anne, who is very clever and smart. As she came home from the kindergarten, she told his brother about the task that her kindergartener asked her to solve. The task was just to construct a triangle out of four sticks of different colours. Naturally, one of the sticks is extra. It is not allowed to break the sticks or use their partial length. Anne has perfectly solved this task, now she is asking Johnny to do the same.The boy answered that he would cope with it without any difficulty. However, after a while he found out that different tricky things can occur. It can happen that it is impossible to construct a triangle of a positive area, but it is possible to construct a degenerate triangle. It can be so, that it is impossible to construct a degenerate triangle even. As Johnny is very lazy, he does not want to consider such a big amount of cases, he asks you to help him.","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 7 10 2', 'output': ['TRIANGLE\\n']}, {'input': '3 4 5 6', 'output': ['TRIANGLE\\n']}, {'input': '1 2 3 4', 'output': ['SEGMENT\\n']}, {'input': '10 20 30 40', 'output': ['SEGMENT\\n']}, {'input': '1 1 100 1', 'output': ['IMPOSSIBLE\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 2\", \"8 16\", \"1 1\"]","prob_desc_input_spec":"The single line contains space-separated integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018). Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n\n#define F first\n#define S second\n#define eps 1e-8\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define INF 2000000000\n\ntypedef long long ll;\n\nusing namespace std;\nll l, r, ans;\nint q, Q, p; \nbool w[99], W[99];\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin >> l >> r;\n\twhile(l){\n\t\tw[q++] = l % 2;\n\t\tl >>= 1;\n\t}\n\twhile(r){\n\t\tW[Q++] = r % 2;\n\t\tr >>= 1;\n\t}\n\tfor(int i = Q; i >= 0; i--)\n\t\tif(w[i] != W[i]){\n\t\t\tp = i + 1;\n\t\t\tbreak;\n\t\t}\n\tans = (1ll << p) - 1ll;\n\tcout << ans;\n\t\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"3\", \"31\", \"0\"]","lang_cluster":"C++","code_uid":"323c6bb0d06ecb72d1723b85d77867ec","prob_desc_notes":null,"prob_desc_output_spec":"In a single line print a single integer \u2014 the maximum value of  for all pairs of integers a, b (l\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009r).","prob_desc_output_to":"standard output","prob_desc_description":"A little girl loves problems on bitwise operations very much. Here's one of them.You are given two integers l and r. Let's consider the values of  for all pairs of integers a and b (l\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009r). Your task is to find the maximum value among all considered ones.Expression  means applying bitwise excluding or operation to integers x and y. The given operation exists in all modern programming languages, for example, in languages C++ and Java it is represented as \"^\", in Pascal \u2014 as \"xor\".","length":53,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 5', 'output': ['7\\n']}, {'input': '10 20', 'output': ['31\\n']}, {'input': '100 200', 'output': ['255\\n']}, {'input': '500 1000', 'output': ['1023\\n']}, {'input': '1000 2000', 'output': ['2047\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 1\", \"5 2 4\"]","prob_desc_input_spec":"The first and only line contains three integers: n, m and k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20092000).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <iostream>\n#include <math.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nlong long ans=1,n,m,k;\nint main()\n{\n\tcin >> n >> m >> k;\n\tif (k == 1 || k>n){\n\t\tfor (int i = 1; i <= n; i++){ ans = (ans*m) % 1000000007; }\n\t\tcout << ans;\n\t}\n\telse if (k == n){\n\t\tfor (int i = 1; i <= int((n + 1) \/ 2); i++){\n\t\t\tans = (ans*m) % 1000000007;\n\t\t}\n\t\tcout << ans;\n\t}\n\telse if (k % 2 == 1){\n\t\tcout << m*m;\n\t}\n\telse{\n\t\tcout << m;\n\t}\n\treturn 0;\n}\n\n","prob_desc_sample_outputs":"[\"1\", \"2\"]","lang_cluster":"C++","code_uid":"eefbabc60f1ffd99500f2466d5bbeea3","prob_desc_notes":"NoteIn the first sample only one string is valid: \"a\" (let's denote the only letter of our alphabet as \"a\").In the second sample (if we denote the alphabet letters as \"a\" and \"b\") the following strings are valid: \"aaaaa\" and \"bbbbb\".","prob_desc_output_spec":"Print a single integer \u2014 the number of strings of the described type modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Just in case somebody missed it: this winter is totally cold in Nvodsk! It is so cold that one gets funny thoughts. For example, let's say there are strings with the length exactly n, based on the alphabet of size m. Any its substring with length equal to k is a palindrome. How many such strings exist? Your task is to find their quantity modulo 1000000007 (109\u2009+\u20097). Be careful and don't miss a string or two!Let us remind you that a string is a palindrome if it can be read the same way in either direction, from the left to the right and from the right to the left.","length":28,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 2', 'output': ['2\\n']}, {'input': '3 3 1', 'output': ['27\\n']}, {'input': '4 2 3', 'output': ['4\\n']}, {'input': '5 5 5', 'output': ['25\\n']}, {'input': '6 3 2', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":1700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 3\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 100\\,000$$$), the number of rows and the number of columns of the field.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll n,m,f[100010][2][2],k,ans;\n\/\/f[\u7b2ci\u4f4d][1\u9ed10\u767d][1\/0\u524d\u4f4d\u4e0e\u8fd9\u4f4d\u662f\u5426\u540c\u8272]\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tk=max(n,m);\n\tf[1][0][0]=1;\n\tf[1][1][0]=1;\n\tfor(int i=2;i<=k;i++)\n\t{\n\t\tf[i][0][0]=(f[i-1][1][0]+f[i-1][1][1])%mod;\n\t\tf[i][1][0]=(f[i-1][0][0]+f[i-1][0][1])%mod;\n\t\tf[i][0][1]=f[i-1][0][0];\n\t\tf[i][1][1]=f[i-1][1][0];\n\t}\n\tans=(ans+f[n][0][0])%mod;\n\tans=(ans+f[n][1][0])%mod;\n\tans=(ans+f[n][0][1])%mod;\n\tans=(ans+f[n][1][1])%mod;\n\tans=(ans+f[m][0][0])%mod;\n\tans=(ans+f[m][1][0])%mod;\n\tans=(ans+f[m][0][1])%mod;\n\tans=(ans+f[m][1][1])%mod;\n\tprintf(\"%lld\\n\",(ans-2+mod)%mod);\n}","prob_desc_sample_outputs":"[\"8\"]","lang_cluster":"C++","code_uid":"9d375e775c9a50ce6f2f3fdc346eacdf","prob_desc_notes":"NoteThe picture below shows all possible random pictures of size $$$2$$$ by $$$3$$$.   ","prob_desc_output_spec":"Print one integer, the number of random pictures modulo $$$10^9 + 7$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Recently Ivan the Fool decided to become smarter and study the probability theory. He thinks that he understands the subject fairly well, and so he began to behave like he already got PhD in that area.To prove his skills, Ivan decided to demonstrate his friends a concept of random picture. A picture is a field of $$$n$$$ rows and $$$m$$$ columns, where each cell is either black or white. Ivan calls the picture random if for every cell it has at most one adjacent cell of the same color. Two cells are considered adjacent if they share a side.Ivan's brothers spent some time trying to explain that it's not how the randomness usually works. Trying to convince Ivan, they want to count the number of different random (according to Ivan) pictures. Two pictures are considered different if at least one cell on those two picture is colored differently. Since the number of such pictures may be quite large, print it modulo $$$10^9 + 7$$$.","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['2\\n']}, {'input': '2 2', 'output': ['6\\n']}, {'input': '3 3', 'output': ['14\\n']}, {'input': '4 4', 'output': ['30\\n']}, {'input': '5 5', 'output': ['62\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"25\\n2 3 4 5 6 7 8 9 10 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 28\", \"5\\n16 23 8 15 4\", \"3\\n14 15 92\"]","prob_desc_input_spec":"The first line of input contains K (1\u2009\u2264\u2009K\u2009\u2264\u200925), the number of onsite finalists you know. The second line of input contains r1,\u2009r2,\u2009...,\u2009rK (1\u2009\u2264\u2009ri\u2009\u2264\u2009106), the qualifying ranks of the finalists you know. All these ranks are distinct.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint ans;\nconst int maxn=1e6+10;\nint sum[maxn];\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>sum[i];\n\t}\n\tsort(sum+1,sum+1+n);\n\tif(sum[n]<=25)\n\t{\n\t\tcout<<\"0\"<<endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tans=sum[n]-25;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"3\", \"0\", \"67\"]","lang_cluster":"C++","code_uid":"4d021d223a9b3bf2afd1e166b9e883d6","prob_desc_notes":"NoteIn the first example, you know all 25 onsite finalists. The contestants who ranked 1-st, 13-th, and 27-th must have declined, so the answer is 3.","prob_desc_output_spec":"Print the minimum possible number of contestants that declined the invitation to compete onsite.","prob_desc_output_to":"standard output","prob_desc_description":"This year, as in previous years, MemSQL is inviting the top 25 competitors from the Start[c]up qualification round to compete onsite for the final round. Not everyone who is eligible to compete onsite can afford to travel to the office, though. Initially the top 25 contestants are invited to come onsite. Each eligible contestant must either accept or decline the invitation. Whenever a contestant declines, the highest ranked contestant not yet invited is invited to take the place of the one that declined. This continues until 25 contestants have accepted invitations.After the qualifying round completes, you know K of the onsite finalists, as well as their qualifying ranks (which start at 1, there are no ties). Determine the minimum possible number of contestants that declined the invitation to compete onsite in the final round.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n1 2 3 4 5 6 7 8 9 10', 'output': ['0\\n']}, {'input': '15\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 30', 'output': ['5\\n']}, {'input': '5\\n1 2 3 4 50', 'output': ['25\\n']}, {'input': '25\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25', 'output': ['0\\n']}, {'input': '1\\n1000000', 'output': ['999975\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"ya\\n4\\nah\\noy\\nto\\nha\", \"hp\\n2\\nht\\ntp\", \"ah\\n1\\nha\"]","prob_desc_input_spec":"The first line contains two lowercase English letters\u00a0\u2014 the password on the phone. The second line contains single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of words Kashtanka knows. The next n lines contain two lowercase English letters each, representing the words Kashtanka knows. The words are guaranteed to be distinct.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<stdio.h>\nchar a1,b1,a[23333],b[23333];\nint i,j,n;\nint main()\n{\n\tscanf(\" %c%c\",&a1,&b1);\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\" %c%c\",&a[i],&b[i]);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=n;j++)\n\t\t{\n\t\t\tif((b[i]==a1&&a[j]==b1)||(a[i]==a1&&b[i]==b1))\n\t\t\t{\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"NO\\n\");\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\"]","lang_cluster":"C++","code_uid":"eb061b2226857153ec4afb7d7f587bf5","prob_desc_notes":"NoteIn the first example the password is \"ya\", and Kashtanka can bark \"oy\" and then \"ah\", and then \"ha\" to form the string \"oyahha\" which contains the password. So, the answer is \"YES\".In the second example Kashtanka can't produce a string containing password as a substring. Note that it can bark \"ht\" and then \"tp\" producing \"http\", but it doesn't contain the password \"hp\" as a substring.In the third example the string \"hahahaha\" contains \"ah\" as a substring.","prob_desc_output_spec":"Print \"YES\" if Kashtanka can bark several words in a line forming a string containing the password, and \"NO\" otherwise. You can print each letter in arbitrary case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"As technologies develop, manufacturers are making the process of unlocking a phone as user-friendly as possible. To unlock its new phone, Arkady's pet dog Mu-mu has to bark the password once. The phone represents a password as a string of two lowercase English letters.Mu-mu's enemy Kashtanka wants to unlock Mu-mu's phone to steal some sensible information, but it can only bark n distinct words, each of which can be represented as a string of two lowercase English letters. Kashtanka wants to bark several words (not necessarily distinct) one after another to pronounce a string containing the password as a substring. Tell if it's possible to unlock the phone in this way, or not.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'ab\\n3\\nba\\nac\\nbd', 'output': ['YES\\n']}, {'input': 'cd\\n2\\ncf\\ndg', 'output': ['NO\\n']}, {'input': 'ef\\n1\\nef', 'output': ['YES\\n']}, {'input': 'gh\\n4\\ngi\\nhj\\nik\\nkl', 'output': ['YES\\n']}, {'input': 'ij\\n5\\nik\\njl\\nkm\\nln\\nop', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"XX.\\n...\\n.XX\", \"X.X\\nX..\\n...\"]","prob_desc_input_spec":"Input contains the matrix of three rows of three symbols each. Symbol \u00abX\u00bb means that the corresponding button was pressed, and \u00ab.\u00bb means that is was not pressed. The matrix may contain no \u00abX\u00bb, also it may contain no \u00ab.\u00bb.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nstring s1,s2,s3;\nint main(){\n\tcin>>s1>>s2>>s3;\n\ts1=s1+s2;\n\ts1=s1+s3;\n\tfor(int i=0;i<=3;i++){\n\t\tif(s1[i]!=s1[8-i]){\n\t\t\tprintf(\"NO\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\");\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"d94c747071f8c8ba9a513858cbc990a7","prob_desc_notes":"NoteIf you are not familiar with the term \u00abcentral symmetry\u00bb, you may look into http:\/\/en.wikipedia.org\/wiki\/Central_symmetry","prob_desc_output_spec":"Print YES if the password is symmetric with respect to the central button of the terminal and NO otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"There is a very secret base in Potatoland where potato mash is made according to a special recipe. The neighbours from Porridgia decided to seize this recipe and to sell it to Pilauland. For this mission they have been preparing special agent Pearlo for many years. When, finally, Pearlo learned all secrets of espionage, he penetrated into the Potatoland territory and reached the secret base.Now he is standing at the entrance, but to get inside he need to pass combination lock. Minute ago one of the workers entered the password on the terminal and opened the door. The terminal is a square digital keyboard 3\u2009\u00d7\u20093 with digits from 1 to 9.Pearlo knows that the password consists from distinct digits and is probably symmetric with respect to the central button of the terminal. He has heat sensor which allowed him to detect the digits which the worker pressed. Now he wants to check whether the password entered by the worker is symmetric with respect to the central button of the terminal. This fact can Help Pearlo to reduce the number of different possible password combinations.","length":16,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'X..\\n.X.\\n..X', 'output': ['YES']}, {'input': '...\\n.X.\\n...', 'output': ['YES']}, {'input': 'X.X\\n...\\nX.X', 'output': ['YES']}, {'input': 'X..\\n...\\n..X', 'output': ['NO']}, {'input': 'X.X\\nX.X\\nX.X', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 5\", \"2 3\"]","prob_desc_input_spec":"The first line of input contains two space-separated integers m and b (1\u2009\u2264\u2009m\u2009\u2264\u20091000, 1\u2009\u2264\u2009b\u2009\u2264\u200910000).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\n#include <stdio.h>\n\n#define PB push_back\n#define f(i,a,b) for(int i=a;i<b;i++)\n#define MAX 4002\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\n\t\nll m,b;\nll f;\nint main()\n{\n\tcin>>m>>b;\n\tfor(ll x=0;x<=m*b;x++)\n\t{\n\t\tll y= -(x+m-1)\/m+b;\n\t\tf=max(f,(x*(x+1)*(y+1)+y*(y+1)*(x+1))\/2);\n\t}\n\tcout<<f;\n}\n","prob_desc_sample_outputs":"[\"30\", \"25\"]","lang_cluster":"C++","code_uid":"417a033e3f4f158962bd36111890a54a","prob_desc_notes":"Note  The graph above corresponds to sample test 1. The optimal rectangle is shown in red and has 30 bananas.","prob_desc_output_spec":"Print the maximum number of bananas Okabe can get from the trees he cuts.","prob_desc_output_to":"standard output","prob_desc_description":"Okabe needs bananas for one of his experiments for some strange reason. So he decides to go to the forest and cut banana trees.Consider the point (x,\u2009y) in the 2D plane such that x and y are integers and 0\u2009\u2264\u2009x,\u2009y. There is a tree in such a point, and it has x\u2009+\u2009y bananas. There are no trees nor bananas in other points. Now, Okabe draws a line with equation . Okabe can select a single rectangle with axis aligned sides with all points on or under the line and cut all the trees in all points that are inside or on the border of this rectangle and take their bananas. Okabe's rectangle can be degenerate; that is, it can be a line segment or even a point.Help Okabe and find the maximum number of bananas he can get if he chooses the rectangle wisely.Okabe is sure that the answer does not exceed 1018. You can trust him.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10', 'output': ['330']}, {'input': '5 5', 'output': ['275']}, {'input': '10 1', 'output': ['66']}, {'input': '3 7', 'output': ['196']}, {'input': '2 8', 'output': ['260']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1\", \"2\", \"10\"]","prob_desc_input_spec":"The only line of the input file contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^9$$$)\u00a0\u2014 the number of roman digits to use.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define rep(i,a,n) for(int i=(a);i<(n);++i)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate <typename T1, typename T2>\ninline bool umin(T1& x, const T2& y){return x>y ? x=y,true : false;}\n\ntemplate <typename T1, typename T2>\ninline bool umax(T1& x, const T2& y){return x<y ? x=y,true : false;}\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n\nconst int N = (int)1e5+5;\nconst int mod = (int)1e9+7;\nconst int INF = (int)1e9+17;\nconst ll LLINF = (ll)1e18+17;\n\n\nint n;\nint ans[N];\nbool dp[53][5001];\n\n\nvoid prepare() {\n    dp[0][0] = true;\n    rep(i, 0, 5001) {\n        rep(j, 0, 51) {\n            for(int x:{1, 5, 10, 50}) {\n                if (i + x <= 5000) dp[j+1][i+x] |= dp[j][i];\n            }\n            ans[j] += dp[j][i];\n        }\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n#ifdef LOCAL\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#else\n\/\/    freopen(\"river.in\", \"r\", stdin);\n\/\/    freopen(\"river.out\", \"w\", stdout);\n#endif\n\n    prepare();\n    cin >> n;\n    if (n <= 50) {\n        cout << ans[n] << endl;\n    } else {\n        cout << ans[50] + 49ll * (n-50) << endl;\n    }\n\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"4\", \"10\", \"244\"]","lang_cluster":"C++","code_uid":"1ba10f44eb277843327296fb3e8fe087","prob_desc_notes":"NoteIn the first sample there are exactly $$$4$$$ integers which can be represented\u00a0\u2014 I, V, X and L.In the second sample it is possible to represent integers $$$2$$$ (II), $$$6$$$ (VI), $$$10$$$ (VV), $$$11$$$ (XI), $$$15$$$ (XV), $$$20$$$ (XX), $$$51$$$ (IL), $$$55$$$ (VL), $$$60$$$ (XL) and $$$100$$$ (LL).","prob_desc_output_spec":"Output a single integer\u00a0\u2014 the number of distinct integers which can be represented using $$$n$$$ roman digits exactly.","prob_desc_output_to":"standard output","prob_desc_description":"Let's introduce a number system which is based on a roman digits. There are digits I, V, X, L which correspond to the numbers $$$1$$$, $$$5$$$, $$$10$$$ and $$$50$$$ respectively. The use of other roman digits is not allowed.Numbers in this system are written as a sequence of one or more digits. We define the value of the sequence simply as the sum of digits in it.For example, the number XXXV evaluates to $$$35$$$ and the number IXI\u00a0\u2014 to $$$12$$$.Pay attention to the difference to the traditional roman system\u00a0\u2014 in our system any sequence of digits is valid, moreover the order of digits doesn't matter, for example IX means $$$11$$$, not $$$9$$$.One can notice that this system is ambiguous, and some numbers can be written in many different ways. Your goal is to determine how many distinct integers can be represented by exactly $$$n$$$ roman digits I, V, X, L.","length":64,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3\\n', 'output': ['20\\n']}, {'input': '5\\n', 'output': ['70\\n']}, {'input': '7\\n', 'output': ['140\\n']}, {'input': '9\\n', 'output': ['224\\n']}, {'input': '50\\n', 'output': ['244\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1001\", \"1\\n1\"]","prob_desc_input_spec":"The first line contains integer number n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the length of string s. The second line contains the string s consisting of characters \"0\" and \"1\". It is guaranteed that the string s is correct.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <iostream>\nusing namespace std;\nstring s;\nint k,i;\nmain(){\n    cin>>i>>s;\n    for (i=0; i<s.size();i++) if (s[i]=='0') k++; \n    if(k!=s.size()) cout<<1;\n    for (i=0; i<k; i++) cout<<0;\n}","prob_desc_sample_outputs":"[\"100\", \"1\"]","lang_cluster":"C++","code_uid":"45c3591bef290ae750835d55c9e63fe0","prob_desc_notes":"NoteIn the first example you can obtain the answer by the following sequence of operations: \"1001\"  \"1010\"  \"1100\"  \"100\".In the second example you can't obtain smaller answer no matter what operations you use.","prob_desc_output_spec":"Print one string \u2014 the minimum correct string that you can obtain from the given one.","prob_desc_output_to":"standard output","prob_desc_description":"String can be called correct if it consists of characters \"0\" and \"1\" and there are no redundant leading zeroes. Here are some examples: \"0\", \"10\", \"1001\".You are given a correct string s.You can perform two different operations on this string:   swap any pair of adjacent characters (for example, \"101\"  \"110\");  replace \"11\" with \"1\" (for example, \"110\"  \"10\"). Let val(s) be such a number that s is its binary representation.Correct string a is less than some other correct string b iff val(a)\u2009&lt;\u2009val(b).Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n11000', 'output': ['10000']}, {'input': '3\\n101', 'output': ['100']}, {'input': '2\\n10', 'output': ['10']}, {'input': '6\\n111000', 'output': ['100000']}, {'input': '1\\n0', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 1 2\"]","prob_desc_input_spec":"The first line of input contains three integers n (2\u2009\u2264\u2009n\u2009\u2264\u2009108), c0 and c1 (0\u2009\u2264\u2009c0,\u2009c1\u2009\u2264\u2009108)\u00a0\u2014 the number of letters in the alphabet, and costs of '0' and '1', respectively. ","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\n#define ll long long\nusing namespace std;\nll ans;\nint n,a,b,s;\nint c[20005];\nbool check(ll m){\n\tint sum=m\/a;\n\tfor (int i=0;i<=s;i++) c[i]=i+1;\n\tfor (int i=1;1ll*i*b<=m&&sum<n;i++)\n\t\tfor (int j=0;1ll*i*b+1ll*j*a<=m&&sum<n;j++)\n\t\t\tsum+=c[j],c[j]+=(j?c[j-1]:0);\n\treturn sum>=n; \n}\nvoid calc(ll m){\n\tint sum=m\/a;\n\tans+=1ll*sum*(sum+1)\/2*a;\n\tfor (int i=0;i<=s;i++) c[i]=i+1;\n\tfor (int i=1;1ll*i*b<=m;i++)\n\t\tfor (int j=0;1ll*i*b+1ll*j*a<=m;j++){\n\t\t\tans+=1ll*c[j]*(1ll*i*b+1ll*j*a);\n\t\t\tsum+=c[j],c[j]+=(j?c[j-1]:0);\n\t\t}\n\tans-=m*(sum-n);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tif (a>b) swap(a,b);\n\tn--; ans=1ll*n*(a+b);\n\tn--; s=sqrt(n*2)+1;\n\tif (!a){\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\tll l=0,r=1ll*n*a;\n\twhile (l<r){\n\t\tll mid=(l+r)\/2;\n\t\tif (check(mid)) r=mid;\n\t\telse l=mid+1;\n\t}\n\tcalc(l);\n\tprintf(\"%lld\\n\",ans);\n}","prob_desc_sample_outputs":"[\"12\"]","lang_cluster":"C++","code_uid":"0d5fd2ecccc565cd9df7b318350866b4","prob_desc_notes":"NoteThere are 4 letters in the alphabet. The optimal encoding is \"00\", \"01\", \"10\", \"11\". There are 4 zeroes and 4 ones used, so the total cost is 4\u00b71\u2009+\u20094\u00b72\u2009=\u200912.","prob_desc_output_spec":"Output a single integer\u00a0\u2014 minimum possible total a cost of the whole alphabet.","prob_desc_output_to":"standard output","prob_desc_description":"R3D3 spent some time on an internship in MDCS. After earning enough money, he decided to go on a holiday somewhere far, far away. He enjoyed suntanning, drinking alcohol-free cocktails and going to concerts of popular local bands. While listening to \"The White Buttons\" and their hit song \"Dacan the Baker\", he met another robot for whom he was sure is the love of his life. Well, his summer, at least. Anyway, R3D3 was too shy to approach his potential soulmate, so he decided to write her a love letter. However, he stumbled upon a problem. Due to a terrorist threat, the Intergalactic Space Police was monitoring all letters sent in the area. Thus, R3D3 decided to invent his own alphabet, for which he was sure his love would be able to decipher.There are n letters in R3D3\u2019s alphabet, and he wants to represent each letter as a sequence of '0' and '1', so that no letter\u2019s sequence is a prefix of another letter's sequence. Since the Intergalactic Space Communications Service has lately introduced a tax for invented alphabets, R3D3 must pay a certain amount of money for each bit in his alphabet\u2019s code (check the sample test for clarifications). He is too lovestruck to think clearly, so he asked you for help.Given the costs c0 and c1 for each '0' and '1' in R3D3\u2019s alphabet, respectively, you should come up with a coding for the alphabet (with properties as above) with minimum total cost.","length":43,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 0 0', 'output': ['0\\n']}, {'input': '5 1 1', 'output': ['20\\n']}, {'input': '10 2 3', 'output': ['110\\n']}, {'input': '3 0 1', 'output': ['3\\n']}, {'input': '7 2 1', 'output': ['42\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2\", \"4\", \"8\", \"20\"]","prob_desc_input_spec":"The input contains one integer $$$n$$$ ($$$2 \\le n \\le 20$$$), $$$n$$$ is an even number.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll Maxn=20+5;\nll n,mul[Maxn];\nint main()\n{   scanf(\"%lld\",&n);\n    mul[0]=1;\n    for(ll i=1;i<=n;i++)mul[i]=1ll*mul[i-1]*i;\n    printf(\"%lld\\n\",mul[n]\/mul[n\/2]\/mul[n\/2]\/2*mul[n\/2-1]*mul[n\/2-1]);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"3\", \"1260\", \"12164510040883200\"]","lang_cluster":"C++","code_uid":"0b5a77a9e16727879923c1c1f8775203","prob_desc_notes":null,"prob_desc_output_spec":"Print one integer \u2014 the number of ways to make two round dances. It is guaranteed that the answer fits in the $$$64$$$-bit integer data type.","prob_desc_output_to":"standard output","prob_desc_description":"One day, $$$n$$$ people ($$$n$$$ is an even number) met on a plaza and made two round dances, each round dance consists of exactly $$$\\frac{n}{2}$$$ people. Your task is to find the number of ways $$$n$$$ people can make two round dances if each round dance consists of exactly $$$\\frac{n}{2}$$$ people. Each person should belong to exactly one of these two round dances.Round dance is a dance circle consisting of $$$1$$$ or more people. Two round dances are indistinguishable (equal) if one can be transformed to another by choosing the first participant. For example, round dances $$$[1, 3, 4, 2]$$$, $$$[4, 2, 1, 3]$$$ and $$$[2, 1, 3, 4]$$$ are indistinguishable.For example, if $$$n=2$$$ then the number of ways is $$$1$$$: one round dance consists of the first person and the second one of the second person.For example, if $$$n=4$$$ then the number of ways is $$$3$$$. Possible options:  one round dance \u2014 $$$[1,2]$$$, another \u2014 $$$[3,4]$$$;  one round dance \u2014 $$$[2,4]$$$, another \u2014 $$$[3,1]$$$;  one round dance \u2014 $$$[4,1]$$$, another \u2014 $$$[3,2]$$$. Your task is to find the number of ways $$$n$$$ people can make two round dances if each round dance consists of exactly $$$\\frac{n}{2}$$$ people.","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n', 'output': ['1\\n']}, {'input': '4\\n', 'output': ['3\\n']}, {'input': '6\\n', 'output': ['40\\n']}, {'input': '10\\n', 'output': ['72576\\n']}, {'input': '16\\n', 'output': ['20922789888000\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1 3 3 2\", \"3\\n1 1 1\", \"4\\n42 0 0 42\"]","prob_desc_input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of participants. The next line contains a sequence of n integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009600)\u00a0\u2014 participants' scores. It's guaranteed that at least one participant has non-zero score.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n\n\/* A. Olympiad *\/\n\nusing namespace std;\ntypedef long long ll;\n\nint n, a[105], res, vis[605];\n\nint main(int argc, char * argv[]) \n{\n\tscanf(\"%d\", &n);\n    for (int i = 0; i < n; i ++)\n        scanf(\"%d\", &a[i]);\n    sort(a, a + n);\n    res = 0;\n    memset(vis, 0, sizeof(vis));\n    for (int i = 0; i < n; i ++)\n    {\n    \tif (a[i] != 0 && !vis[a[i]])\n    \t{\n    \t\tres ++;\n    \t\tvis[a[i]] = 1;\n    \t}\n    }\n    cout << res << endl;\n    return 0;\n}","prob_desc_sample_outputs":"[\"3\", \"1\", \"1\"]","lang_cluster":"C++","code_uid":"2584514af63eea42716915086f4ddff8","prob_desc_notes":"NoteThere are three ways to choose a subset in sample case one.  Only participants with 3 points will get diplomas.  Participants with 2 or 3 points will get diplomas.  Everyone will get a diploma! The only option in sample case two is to award everyone.Note that in sample case three participants with zero scores cannot get anything.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the desired number of ways.","prob_desc_output_to":"standard output","prob_desc_description":"The recent All-Berland Olympiad in Informatics featured n participants with each scoring a certain amount of points.As the head of the programming committee, you are to determine the set of participants to be awarded with diplomas with respect to the following criteria:   At least one participant should get a diploma.  None of those with score equal to zero should get awarded.  When someone is awarded, all participants with score not less than his score should also be awarded. Determine the number of ways to choose a subset of participants that will receive the diplomas.","length":32,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 4 5', 'output': ['5\\n']}, {'input': '6\\n1 1 2 2 3 3', 'output': ['3\\n']}, {'input': '7\\n0 0 0 0 0 0 7', 'output': ['1\\n']}, {'input': '8\\n0 0 0 0 0 0 0 8', 'output': ['1\\n']}, {'input': '9\\n1 2 3 4 5 6 7 8 9', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\", \"7\", \"12\"]","prob_desc_input_spec":"The only line contains integer n from the problem's statement (1\u2009\u2264\u2009n\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include <string>\n#include<bits\/stdc++.h>\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<ll, ll>pii;\n\/\/typedef bitset<8> mask;\n\/\/int x4[4]={1,0,0,-1};\n\/\/int y4[4]={0,1,-1,0};\nll n,x,y,z,ans1=1e18+20,ans2=-100000000;\nint main()\n{\n    \/\/cout<<Pow((ll)1000000,(ll)110);\n\/\/freopen(\"hotel.in\",\"r\",stdin);\n\/\/freopen(\"math.in\",\"w\",stdout);\n\/\/printf(\"%s %.4f\\n\",k.c_str(),g);\ncin>>n;\nfor(int i=1;i<=1000;i++)\n{\n    for(int j=i;j*i<=1000000;j++)\n    {\n        if(n%(i*j)==0&&n\/(i*j)>=j)\n        {\n          x=i;y=j;z=n\/(x*y);\n          ans1=min(ans1,(z+2)*(y+2)*(x+1)-n);\n          ans2=max(ans2,(z+1)*(y+2)*(x+2)-n);\n        }\n\n\n    }\n}\n\/\/cout<<x<<\" \"<<y<<\" \"<<z<<endl;\ncout<<ans1<<\" \"<<ans2;\nreturn 0;\n}","prob_desc_sample_outputs":"[\"28 41\", \"47 65\", \"48 105\"]","lang_cluster":"C++","code_uid":"92e63cdd0c37a1427f166c6d629130fd","prob_desc_notes":"NoteLet's consider the first sample test. If initially Sam has a parallelepiped consisting of 32\u2009=\u20092\u2009\u00d7\u20094\u2009\u00d7\u20094 hay blocks in his barn, then after the theft the barn has 4\u2009=\u2009(2\u2009-\u20091)\u2009\u00d7\u2009(4\u2009-\u20092)\u2009\u00d7\u2009(4\u2009-\u20092) hay blocks left. Thus, the thieves could have stolen 32\u2009-\u20094\u2009=\u200928 hay blocks. If Sam initially had a parallelepiped consisting of 45\u2009=\u20095\u2009\u00d7\u20093\u2009\u00d7\u20093 hay blocks in his barn, then after the theft the barn has 4\u2009=\u2009(5\u2009-\u20091)\u2009\u00d7\u2009(3\u2009-\u20092)\u2009\u00d7\u2009(3\u2009-\u20092) hay blocks left. Thus, the thieves could have stolen 45\u2009-\u20094\u2009=\u200941 hay blocks. No other variants of the blocks' initial arrangement (that leave Sam with exactly 4 blocks after the theft) can permit the thieves to steal less than 28 or more than 41 blocks.","prob_desc_output_spec":"Print space-separated minimum and maximum number of hay blocks that could have been stolen by the thieves. Note that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specificator.","prob_desc_output_to":"standard output","prob_desc_description":"Once upon a time in the Kingdom of Far Far Away lived Sam the Farmer. Sam had a cow named Dawn and he was deeply attached to her. Sam would spend the whole summer stocking hay to feed Dawn in winter. Sam scythed hay and put it into haystack. As Sam was a bright farmer, he tried to make the process of storing hay simpler and more convenient to use. He collected the hay into cubical hay blocks of the same size. Then he stored the blocks in his barn. After a summer spent in hard toil Sam stored A\u00b7B\u00b7C hay blocks and stored them in a barn as a rectangular parallelepiped A layers high. Each layer had B rows and each row had C blocks.At the end of the autumn Sam came into the barn to admire one more time the hay he'd been stacking during this hard summer. Unfortunately, Sam was horrified to see that the hay blocks had been carelessly scattered around the barn. The place was a complete mess. As it turned out, thieves had sneaked into the barn. They completely dissembled and took away a layer of blocks from the parallelepiped's front, back, top and sides. As a result, the barn only had a parallelepiped containing (A\u2009-\u20091)\u2009\u00d7\u2009(B\u2009-\u20092)\u2009\u00d7\u2009(C\u2009-\u20092) hay blocks. To hide the evidence of the crime, the thieves had dissembled the parallelepiped into single 1\u2009\u00d7\u20091\u2009\u00d7\u20091 blocks and scattered them around the barn. After the theft Sam counted n hay blocks in the barn but he forgot numbers A, B \u0438 C.Given number n, find the minimally possible and maximally possible number of stolen hay blocks.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n', 'output': ['38 65\\n']}, {'input': '20\\n', 'output': ['68 125\\n']}, {'input': '30\\n', 'output': ['98 185\\n']}, {'input': '40\\n', 'output': ['128 245\\n']}, {'input': '50\\n', 'output': ['158 305\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"WBWBWBWB\\nBWBWBWBW\\nBWBWBWBW\\nBWBWBWBW\\nWBWBWBWB\\nWBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\", \"WBWBWBWB\\nWBWBWBWB\\nBBWBWWWB\\nBWBWBWBW\\nBWBWBWBW\\nBWBWBWWW\\nBWBWBWBW\\nBWBWBWBW\"]","prob_desc_input_spec":"The input consists of exactly eight lines. Each line contains exactly eight characters \"W\" or \"B\" without any spaces: the j-th character in the i-th line stands for the color of the j-th cell of the i-th row of the elephants' board. Character \"W\" stands for the white color, character \"B\" stands for the black color. Consider the rows of the board numbered from 1 to 8 from top to bottom, and the columns \u2014 from 1 to 8 from left to right. The given board can initially be a proper chessboard.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"\/* *************************************************************\n   *  \"The world is nothing but a good program,               *\n   *   and we are all some instances of the program!!\"        *\n   *            PROBLEM:                                      *\n   *            SOLVED DATE: 2012\/12\/20                       *\n   *            RT: 0.00 sec;         RANK:                   *\n   *            ALGO:                                         *\n   *                               ==>> TheCoderJU (BISHAL)   *\n   ************************************************************* *\/\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n#include <cmath>\nusing namespace std;\nint i,j,k,m,n,tc,sm,cnt=0,tmp,w,b,cs=1,p,q,f=1,g=1;\nstring s,s1,sw[10000];\nint main()\n{\n f=1;\n for(i=1;i<=8;i++)\n {\n   cin>>sw[i];\n   cnt=0;\n   for(j=0;i<sw[i][j];j+=2)\n   {\n     if(sw[i][0]=='W' && (sw[i][j]=='W' && sw[i][j+1]=='B'))cnt++;\n     else if(sw[i][0]=='B' && (sw[i][j]=='B' && sw[i][j+1]=='W'))cnt++;\n   }\n if(cnt!=4){f=0;}\n }\nif(f)cout<<\"YES\\n\";\nelse cout<<\"NO\\n\";\nreturn 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"a01c2c75aa37d3f24ce8a7e1e3a29445","prob_desc_notes":"NoteIn the first sample you should shift the following lines one position to the right: the 3-rd, the 6-th, the 7-th and the 8-th.In the second sample there is no way you can achieve the goal.","prob_desc_output_spec":"In a single line print \"YES\" (without the quotes), if we can make the board a proper chessboard and \"NO\" (without the quotes) otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"The Little Elephant loves chess very much. One day the Little Elephant and his friend decided to play chess. They've got the chess pieces but the board is a problem. They've got an 8\u2009\u00d7\u20098 checkered board, each square is painted either black or white. The Little Elephant and his friend know that a proper chessboard doesn't have any side-adjacent cells with the same color and the upper left cell is white. To play chess, they want to make the board they have a proper chessboard. For that the friends can choose any row of the board and cyclically shift the cells of the chosen row, that is, put the last (rightmost) square on the first place in the row and shift the others one position to the right. You can run the described operation multiple times (or not run it at all).For example, if the first line of the board looks like that \"BBBBBBWW\" (the white cells of the line are marked with character \"W\", the black cells are marked with character \"B\"), then after one cyclic shift it will look like that \"WBBBBBBW\".Help the Little Elephant and his friend to find out whether they can use any number of the described operations to turn the board they have into a proper chessboard.","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'WBWBWBWB\\nBWBWBWBW\\nBWBWBWBW\\nBWBWBWBW\\nWBWBWBWB\\nWBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\\n', 'output': ['YES\\n']}, {'input': 'WBWBWBWB\\nWBWBWBWB\\nBBWBWWWB\\nBWBWBWBW\\nBWBWBWBW\\nBWBWBWWW\\nBWBWBWBW\\nBWBWBWBW\\n', 'output': ['NO\\n']}, {'input': 'WBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\\nBWBWBWBW\\n', 'output': ['YES\\n']}, {'input': 'WBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\\nBWBWBWBW\\nWBWBWBWB\\nWBWBWBWB\\n', 'output': ['NO\\n']}, {'input': 'BBBBBBBB\\nBBBBBBBB\\nBBBBBBBB\\nBBBBBBBB\\nBBBBBBBB\\nBBBBBBBB\\nBBBBBBBB\\nBBBBBBBB\\n', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 1\", \"3 2\", \"6 3\"]","prob_desc_input_spec":"The only line of input contains two integers n and m, separated by a single space (1\u2009\u2264\u2009m\u2009\u2264\u2009n\u2009\u2264\u2009109) \u2014 the number of participants and the number of teams respectively. ","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include<bits\/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef long double ld;\n\nconst ll inf = LLONG_MAX;\n\n#define rel( i, a, b) for( ll i = a ; i <= b ; i++ )\n#define rep( k, a, b) for( ll k = a ; k <= b ; k+=2*k )\n#define rev( i, a, b) for( ll i = b ; i >= a ; i-- )\n#define M 1000000007\n#define pll pair<ll,ll>\n#define vll vector<ll>\n#define vpll vector<pll>\n#define mll map<ll,ll>\n#define mpll map<ll,pll>\n#define sll set<ll>\n#define spll set<pll>\n#define msll multiset<ll>\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define FIO ios::sync_with_stdio(false);cin.tie(0);cerr.tie(0)\n#define lb lower_bound\n#define ub upper_bound\n#define fprint(x) cout << fixed << setprecision(10) << (ld)x;\nll n, m;\nll mini, maxi;\n\nint main()\n{\n\tcin >> n >> m;\n\t\n\tll t1, t2;\n\t\n\tt1 = n\/m;\n\t\n\tmini = m*((t1*(t1-1))\/2);\n\t\n\tif( n % m != 0 ){\n\t\tll t = n%m;\n\t\t\n\t\tmini += t1*t;\n\t}\n\t\n\tmaxi = ((n-m+1)*(n-m))\/2;\n\t\n\tcout << mini << \" \" << maxi;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","prob_desc_sample_outputs":"[\"10 10\", \"1 1\", \"3 6\"]","lang_cluster":"C++","code_uid":"591f3eb02dda4dacda59866f6419b8f5","prob_desc_notes":"NoteIn the first sample all the participants get into one team, so there will be exactly ten pairs of friends.In the second sample at any possible arrangement one team will always have two participants and the other team will always have one participant. Thus, the number of pairs of friends will always be equal to one.In the third sample minimum number of newly formed friendships can be achieved if participants were split on teams consisting of 2 people, maximum number can be achieved if participants were split on teams of 1, 1 and 4 people.","prob_desc_output_spec":"The only line of the output should contain two integers kmin and kmax \u2014 the minimum possible number of pairs of friends and the maximum possible number of pairs of friends respectively.","prob_desc_output_to":"standard output","prob_desc_description":"n participants of the competition were split into m teams in some manner so that each team has at least one participant. After the competition each pair of participants from the same team became friends.Your task is to write a program that will find the minimum and the maximum number of pairs of friends that could have formed by the end of the competition.","length":79,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 2', 'output': ['20 36']}, {'input': '7 3', 'output': ['6 10']}, {'input': '15 5', 'output': ['20 55']}, {'input': '9 4', 'output': ['6 15']}, {'input': '1000000000 1', 'output': ['499999999500000000 499999999500000000']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2\\n8 8\", \"4\\n3 1 4 1\"]","prob_desc_input_spec":"The first line contains one integer $$$n$$$ ($$$2 \\leq n \\leq 50$$$)\u00a0\u2014 the number of piles. It is guaranteed that $$$n$$$ is an even number. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq 50$$$)\u00a0\u2014 the number of stones in the piles.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, a[N], cnt;\n\nint main(){\n\n\n\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; ++i)\n        if (a[i] == a[1]) ++cnt;\n    if (cnt <= n >> 1) return cout << \"Alice\", 0;\n    cout << \"Bob\";\n\n}\n","prob_desc_sample_outputs":"[\"Bob\", \"Alice\"]","lang_cluster":"C++","code_uid":"92d3b8ca4a57cd9822f45d858f6b0d30","prob_desc_notes":"NoteIn the first example, each player can only remove stones from one pile ($$$\\frac{2}{2}=1$$$). Alice loses, since Bob can copy whatever Alice does on the other pile, so Alice will run out of moves first.In the second example, Alice can remove $$$2$$$ stones from the first pile and $$$3$$$ stones from the third pile on her first move to guarantee a win.","prob_desc_output_spec":"Print a single string \"Alice\" if Alice wins; otherwise, print \"Bob\" (without double quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Alice and Bob are playing a game with $$$n$$$ piles of stones. It is guaranteed that $$$n$$$ is an even number. The $$$i$$$-th pile has $$$a_i$$$ stones.Alice and Bob will play a game alternating turns with Alice going first.On a player's turn, they must choose exactly $$$\\frac{n}{2}$$$ nonempty piles and independently remove a positive number of stones from each of the chosen piles. They can remove a different number of stones from the piles in a single turn. The first player unable to make a move loses (when there are less than $$$\\frac{n}{2}$$$ nonempty piles).Given the starting configuration, determine who will win the game.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n1 1', 'output': ['Bob\\n']}, {'input': '4\\n2 2 2 2', 'output': ['Bob\\n']}, {'input': '6\\n1 2 3 4 5 6', 'output': ['Alice\\n']}, {'input': '4\\n1 1 2 2', 'output': ['Alice\\n']}, {'input': '8\\n1 1 1 1 2 2 2 2', 'output': ['Bob\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n2 3 1 4\", \"4\\n4 4 4 4\", \"4\\n2 1 4 3\"]","prob_desc_input_spec":"The first line of input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of people in Arpa's land. The second line contains n integers, i-th of them is crushi (1\u2009\u2264\u2009crushi\u2009\u2264\u2009n)\u00a0\u2014 the number of i-th person's crush.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <stdio.h>\n\nint n,par[105];\nbool vis[105];\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint main(){\n\tint ans=1;\n\tscanf(\"%i\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%i\",&par[i]);\n\tfor(int j=1;j<=n;j++){\n\t\tif(vis[j])continue;\n\t\tbool valid=0;\n\t\tint pos=par[j];\n\t\tfor(int k=1;k<=n+2;k++){\n\t\t\tvis[pos]=1;\n\t\t\tif(pos==j){\n\t\t\t\tvalid=1;\n\t\t\t\tint fpb=gcd(ans,(k&1)?k:k\/2);\n\t\t\t\tans=(ans*((k&1)?k:k\/2))\/fpb;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos=par[pos];\n\t\t}\n\t\tif(!valid){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%i\\n\",ans);\n}\n","prob_desc_sample_outputs":"[\"3\", \"-1\", \"1\"]","lang_cluster":"C++","code_uid":"381eda8710cfb0323257c9425a4296a0","prob_desc_notes":"NoteIn the first sample suppose t\u2009=\u20093. If the first person starts some round:The first person calls the second person and says \"Owwwf\", then the second person calls the third person and says \"Owwf\", then the third person calls the first person and says \"Owf\", so the first person becomes Joon-Joon of the round. So the condition is satisfied if x is 1.The process is similar for the second and the third person.If the fourth person starts some round:The fourth person calls himself and says \"Owwwf\", then he calls himself again and says \"Owwf\", then he calls himself for another time and says \"Owf\", so the fourth person becomes Joon-Joon of the round. So the condition is satisfied when x is 4.In the last example if the first person starts a round, then the second person becomes the Joon-Joon, and vice versa.","prob_desc_output_spec":"If there is no t satisfying the condition, print -1. Otherwise print such smallest t.","prob_desc_output_to":"standard output","prob_desc_description":"As you have noticed, there are lovely girls in Arpa\u2019s land.People in Arpa's land are numbered from 1 to n. Everyone has exactly one crush, i-th person's crush is person with the number crushi.  Someday Arpa shouted Owf loudly from the top of the palace and a funny game started in Arpa's land. The rules are as follows.The game consists of rounds. Assume person x wants to start a round, he calls crushx and says: \"Oww...wwf\" (the letter w is repeated t times) and cuts off the phone immediately. If t\u2009&gt;\u20091 then crushx calls crushcrushx and says: \"Oww...wwf\" (the letter w is repeated t\u2009-\u20091 times) and cuts off the phone immediately. The round continues until some person receives an \"Owf\" (t\u2009=\u20091). This person is called the Joon-Joon of the round. There can't be two rounds at the same time.Mehrdad has an evil plan to make the game more funny, he wants to find smallest t (t\u2009\u2265\u20091) such that for each person x, if x starts some round and y becomes the Joon-Joon of the round, then by starting from y, x would become the Joon-Joon of the round. Find such t for Mehrdad if it's possible.Some strange fact in Arpa's land is that someone can be himself's crush (i.e. crushi\u2009=\u2009i).","length":33,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 4 5', 'output': ['1\\n']}, {'input': '3\\n3 3 3', 'output': ['-1\\n']}, {'input': '6\\n1 2 3 4 5 6', 'output': ['1\\n']}, {'input': '2\\n2 1', 'output': ['1\\n']}, {'input': '7\\n7 6 5 4 3 2 1', 'output': ['7\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 4\\n....\\n.S1.\\n....\\n....\\n10\", \"7 7\\n.......\\n.1###2.\\n.#...#.\\n.#.B.#.\\n.3...4.\\n..##...\\n......S\\n100\\n100\\n100\\n100\", \"7 8\\n........\\n........\\n....1B..\\n.S......\\n....2...\\n3.......\\n........\\n100\\n-100\\n100\", \"1 1\\nS\"]","prob_desc_input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200920) \u2014 the sizes of the table. Next n lines each contains m characters \u2014 the description of the table. The description means the following:   character \"B\" is a cell with a bomb;  character \"S\" is the starting cell, you can assume that it's empty;  digit c (1-8) is treasure with index c;  character \".\" is an empty cell;  character \"#\" is an obstacle.  Assume that the map has t treasures. Next t lines contain the prices of the treasures. The i-th line contains the price of the treasure with index i, vi (\u2009-\u2009200\u2009\u2264\u2009vi\u2009\u2264\u2009200). It is guaranteed that the treasures are numbered from 1 to t. It is guaranteed that the map has not more than 8 objects in total. Objects are bombs and treasures. It is guaranteed that the map has exactly one character \"S\".","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int dx[]={1,-1,0,0};\nconst int dy[]={0,0,1,-1};\nconst int INF=1000000000;\nint n,m,sx,sy,tx[10],ty[10],tp[10],tn,bx[10],by[10],bn;\nint f[21][21][256][256],pr[256],ans;\nint qx[2000010],qy[2000010],qt[2000010],qb[2000010],l,r;\nchar a[51][51];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%s\",a[i]+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(a[i][j]=='S') sx=i,sy=j;\n\t\t\tif(a[i][j]>='0'&&a[i][j]<='9') tx[a[i][j]-'0']=i,ty[a[i][j]-'0']=j,tn++;\n\t\t\tif(a[i][j]=='B') bx[++bn]=i,by[bn]=j;\n\t\t}\n\tfor(int i=1;i<=tn;i++) scanf(\"%d\",&tp[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tfor(int k=0;k<(1<<tn);k++)\n\t\t\t\tfor(int l=0;l<(1<<bn);l++)\n\t\t\t\t\tf[i][j][k][l]=INF;\n\tl=r=1;\n\tqx[1]=sx,qy[1]=sy,qt[1]=0,qb[1]=0;\n\tf[sx][sy][0][0]=0;\n\twhile(l<=r)\n\t{\n\t\tint ox=qx[l],oy=qy[l],ot=qt[l],ob=qb[l++];\n\t\tfor(int k=0;k<4;k++)\n\t\t{\n\t\t\tint nx=ox+dx[k],ny=oy+dy[k],nt=ot,nb=ob;\n\t\t\tif(a[nx][ny]!='.'&&a[nx][ny]!='S') continue;\n\t\t\tfor(int i=1;i<=tn;i++)\n\t\t\t{\n\t\t\t\tif(ny<=ty[i]) continue;\n\t\t\t\tif(nx==tx[i]-1&&ox==tx[i]) nt^=(1<<(i-1));\n\t\t\t\tif(ox==tx[i]-1&&nx==tx[i]) nt^=(1<<(i-1));\n\t\t\t}\n\t\t\tfor(int i=1;i<=bn;i++)\n\t\t\t{\n\t\t\t\tif(ny<=by[i]) continue;\n\t\t\t\tif(nx==bx[i]-1&&ox==bx[i]) nb^=(1<<(i-1));\n\t\t\t\tif(ox==bx[i]-1&&nx==bx[i]) nb^=(1<<(i-1));\n\t\t\t}\n\t\t\tif(f[nx][ny][nt][nb]>f[ox][oy][ot][ob]+1)\n\t\t\t\tf[nx][ny][nt][nb]=f[ox][oy][ot][ob]+1,qx[++r]=nx,qy[r]=ny,qt[r]=nt,qb[r]=nb;\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<tn);i++)\n\t\tfor(int j=1;j<=tn;j++)\n\t\t\tif(i&(1<<(j-1))) pr[i]+=tp[j];\n\tfor(int i=0;i<(1<<tn);i++)\n\t\tans=max(ans,pr[i]-f[sx][sy][i][0]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"364\", \"0\", \"0\"]","lang_cluster":"C++","code_uid":"947613b2d3b8e128f33077a31c78e49f","prob_desc_notes":"NoteIn the first example the answer will look as follows.  In the second example the answer will look as follows.  In the third example you cannot get profit.In the fourth example you cannot get profit as you cannot construct a closed path with more than one cell.","prob_desc_output_spec":"Print a single integer \u2014 the maximum possible profit you can get.","prob_desc_output_to":"standard output","prob_desc_description":"You have a map as a rectangle table. Each cell of the table is either an obstacle, or a treasure with a certain price, or a bomb, or an empty cell. Your initial position is also given to you.You can go from one cell of the map to a side-adjacent one. At that, you are not allowed to go beyond the borders of the map, enter the cells with treasures, obstacles and bombs. To pick the treasures, you need to build a closed path (starting and ending in the starting cell). The closed path mustn't contain any cells with bombs inside. Let's assume that the sum of the treasures' values that are located inside the closed path equals v, and besides, you've made k single moves (from one cell to another) while you were going through the path, then such path brings you the profit of v\u2009-\u2009k rubles.Your task is to build a closed path that doesn't contain any bombs and brings maximum profit.Note that the path can have self-intersections. In order to determine if a cell lies inside a path or not, use the following algorithm:  Assume that the table cells are points on the plane (the table cell on the intersection of the i-th column and the j-th row is point (i,\u2009j)). And the given path is a closed polyline that goes through these points.  You need to find out if the point p of the table that is not crossed by the polyline lies inside the polyline.  Let's draw a ray that starts from point p and does not intersect other points of the table (such ray must exist).  Let's count the number of segments of the polyline that intersect the painted ray. If this number is odd, we assume that point p (and consequently, the table cell) lie inside the polyline (path). Otherwise, we assume that it lies outside. ","length":63,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4 4\\n....\\n.S1.\\n....\\n....\\n10', 'output': ['2']}, {'input': '7 7\\n.......\\n.1###2.\\n.#...#.\\n.#.B.#.\\n.3...4.\\n..##...\\n......S\\n100\\n100\\n100\\n100', 'output': ['364']}, {'input': '7 8\\n........\\n........\\n....1B..\\n.S......\\n....2...\\n3.......\\n........\\n100\\n-100\\n100', 'output': ['0']}, {'input': '1 1\\nS', 'output': ['0']}, {'input': '5 5\\n.....\\n.1S2.\\n.....\\n.....\\n.....\\n100\\n200', 'output': ['198']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"2 5\", \"3 3\", \"5 4\", \"13 37\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$x$$$ ($$$2 \\le n \\le 500; 1 \\le x \\le 500$$$).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include<bits\/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define lr(a) memset(a,0,sizeof(a))\r\nconst int N=550,mod=998244353;\r\nint n,x,C[N][N],pw[N][N]; \/\/\u7ec4\u5408\u6570&\u5e42 \r\nint dp[N][N],ans; \/\/dp[n][x]\r\nvoid init(){\r\n\tlr(dp),lr(pw),lr(C);\r\n\tfor(int i=0;i<=510;i++)C[i][0]=pw[i][0]=1;         \/\/\u8fd8\u6709\u8fd9\u91cc\uff01i\u8981\u4ece0\u5f00\u59cb\uff0c\u4e0d\u7136C[n][n]\u5c31\u7b49\u4e8e0\u9e1fQWQWQWQ \r\n\tfor(int i=1;i<=510;i++)\r\n\tfor(int j=1;j<=510;j++)\r\n\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j]+mod)%mod,\r\n\t\tpw[i][j]=(pw[i][j-1]*i+mod)%mod;\r\n\tscanf(\"%lld%lld\",&n,&x);\r\n}\r\nint solve(){\r\n\tfor(int peo=2;peo<=n;peo++){\r\n\t\tfor(int i=1;i<=x;i++){\r\n\t\t\tif(i<=peo-1)dp[peo][i]=(pw[i][peo]-pw[i-1][peo]+mod)%mod;   \/\/\u9519\u5728\u8fd9\u91cc\u4e86\uff01 i\u548cpeo\u521a\u5f00\u59cb\u5199\u53cd\u4e86!qwq \r\n\t\t\telse{\r\n\t\t\t\tfor(int k=2;k<=peo;k++){\r\n\t\t\t\t\tdp[peo][i]=(dp[peo][i]+dp[k][i-(peo-1)]%mod*C[peo][k]%mod*pw[peo-1][peo-k]+mod)%mod;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(int maxn=1;maxn<=x;maxn++){\r\n\t\tans=(ans+dp[n][maxn]+mod)%mod;\r\n\t}\r\n\treturn ans;\r\n}\r\nsigned main(){\r\n\tinit();\r\n\tprintf(\"%lld\\n\",solve());\r\n}\r\n","prob_desc_sample_outputs":"[\"5\", \"15\", \"1024\", \"976890680\"]","lang_cluster":"C++","code_uid":"af882f95fdd39145da2974b5cc278332","prob_desc_notes":null,"prob_desc_output_spec":"Print one integer\u00a0\u2014 the number of ways to choose the initial health points for each hero $$$a_i$$$, where $$$1 \\le a_i \\le x$$$, so that there is no winner of the fight, taken modulo $$$998244353$$$. ","prob_desc_output_to":"standard output","prob_desc_description":"There are $$$n$$$ heroes fighting in the arena. Initially, the $$$i$$$-th hero has $$$a_i$$$ health points.The fight in the arena takes place in several rounds. At the beginning of each round, each alive hero deals $$$1$$$ damage to all other heroes. Hits of all heroes occur simultaneously. Heroes whose health is less than $$$1$$$ at the end of the round are considered killed.If exactly $$$1$$$ hero remains alive after a certain round, then he is declared the winner. Otherwise, there is no winner.Your task is to calculate the number of ways to choose the initial health points for each hero $$$a_i$$$, where $$$1 \\le a_i \\le x$$$, so that there is no winner of the fight. The number of ways can be very large, so print it modulo $$$998244353$$$. Two ways are considered different if at least one hero has a different amount of health. For example, $$$[1, 2, 1]$$$ and $$$[2, 1, 1]$$$ are different.","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 10', 'output': ['45\\n']}, {'input': '3 5', 'output': ['125\\n']}, {'input': '4 4', 'output': ['256\\n']}, {'input': '5 3', 'output': ['243\\n']}, {'input': '6 2', 'output': ['64\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 1\", \"2 1\", \"3 2\"]","prob_desc_input_spec":"The first and the only line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 10^5, 1 \\le k \\le \\min(2^n - 1, 10^9)$$$)\u00a0\u2014 the number of rounds in the tournament and the number of outcomes that sponsors can change.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <cstdio>\r\n#include <algorithm>\r\nusing LL = long long;\r\nconst int N = 1e5 + 100, P = 1e9 + 7;\r\nint n, num;\r\nint fac[N], ifac[N];\r\nint ans = 0;\r\nint qpow(int x, int y = P - 2)\r\n{\r\n    int res = 1;\r\n    for (; y; y >>= 1, x = LL(x) * x % P) if (y & 1) res = LL(x) * res % P;\r\n    return res;\r\n}\r\nvoid adj(int &x){ x += (x >> 31) & P; }\r\nint C(int x, int y){ return LL(fac[x]) * ifac[y] % P * ifac[x - y] % P; }\r\nint main()\r\n{\r\n    scanf(\"%d %d\", &n, &num);\r\n    fac[0] = fac[1] = ifac[0] = ifac[1] = 1;\r\n    for (int i = 2; i <= n; ++i) fac[i] = LL(i) * fac[i - 1] % P;\r\n    ifac[n] = qpow(fac[n]);\r\n    for (int i = n - 1; i > 1; --i) ifac[i] = LL(i + 1) * ifac[i + 1] % P;\r\n    num = std::min(n, num);\r\n    for (int i = 0; i <= num; ++i) adj(ans += C(n, i) - P);\r\n    printf(\"%d\\n\", ans);\r\n    return 0;\r\n}","prob_desc_sample_outputs":"[\"2\", \"3\", \"7\"]","lang_cluster":"C++","code_uid":"c6e1ff7395ad17c517fdc7c1a57ad8fb","prob_desc_notes":"NoteIn the first example, there is only one match between players $$$1$$$ and $$$2$$$, so the sponsors can always make player $$$2$$$ wins.The tournament grid from the second example is shown in the picture in the statement.","prob_desc_output_spec":"Print exactly one integer\u00a0\u2014 the minimum number of the winner modulo $$$10^9 + 7$$$","prob_desc_output_to":"standard output","prob_desc_description":"Madoka decided to entrust the organization of a major computer game tournament \"OSU\"!In this tournament, matches are held according to the \"Olympic system\". In other words, there are $$$2^n$$$ participants in the tournament, numbered with integers from $$$1$$$ to $$$2^n$$$. There are $$$n$$$ rounds in total in the tournament. In the $$$i$$$-th round there are $$$2^{n - i}$$$ matches between two players (one of whom is right, the other is left), after which the winners go further along the tournament grid, and the losing participants are eliminated from the tournament. Herewith, the relative order in the next round does not change. And the winner of the tournament\u00a0\u2014 is the last remaining participant.But the smaller the participant's number, the more he will pay Madoka if he wins, so Madoka wants the participant with the lowest number to win. To do this, she can arrange the participants in the first round as she likes, and also determine for each match who will win\u00a0\u2014 the participant on the left or right.But Madoka knows that tournament sponsors can change the winner in matches no more than $$$k$$$ times. (That is, if the participant on the left won before the change, then the participant on the right will win after the change, and if the participant on the right won, then the participant on the left will win after the change).  So, the first image shows the tournament grid that Madoka made, where the red lines denote who should win the match. And the second one shows the tournament grid, after one change in the outcome of the match by sponsors (a match between $$$1$$$ and $$$3$$$ players). Print the minimum possible number of the winner in the tournament, which Madoka can get regardless of changes in sponsors. But since the answer can be very large, output it modulo $$$10^9 + 7$$$. Note that we need to minimize the answer, and only then take it modulo.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['2\\n']}, {'input': '2 2', 'output': ['4\\n']}, {'input': '3 3', 'output': ['8\\n']}, {'input': '4 4', 'output': ['16\\n']}, {'input': '5 5', 'output': ['32\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"12 5\", \"31 12\"]","prob_desc_input_spec":"The only line of the input contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091018). n is the initial value of variable a, and m is the initial value of variable b.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<iostream>\nusing namespace std;\nlong long n,m;\nint main()\n{\n    cin>>n>>m;\n    while(n&&m)\n        if(n>=2*m)n%=2*m;\n        else if(m>=2*n)m%=2*n;\n        else break;\n    cout<<n<<' '<<m<<endl;\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"0 1\", \"7 12\"]","lang_cluster":"C++","code_uid":"aae6408f737c7f9c77b6e86b32f2b2d0","prob_desc_notes":"NoteExplanations to the samples: a\u2009=\u200912, b\u2009=\u20095  a\u2009=\u20092, b\u2009=\u20095  a\u2009=\u20092, b\u2009=\u20091  a\u2009=\u20090, b\u2009=\u20091; a\u2009=\u200931, b\u2009=\u200912  a\u2009=\u20097, b\u2009=\u200912.","prob_desc_output_spec":"Print two integers \u2014 the values of a and b after the end of the process.","prob_desc_output_to":"standard output","prob_desc_description":"You have two variables a and b. Consider the following sequence of actions performed with these variables: If a\u2009=\u20090 or b\u2009=\u20090, end the process. Otherwise, go to step 2; If a\u2009\u2265\u20092\u00b7b, then set the value of a to a\u2009-\u20092\u00b7b, and repeat step 1. Otherwise, go to step 3; If b\u2009\u2265\u20092\u00b7a, then set the value of b to b\u2009-\u20092\u00b7a, and repeat step 1. Otherwise, end the process.Initially the values of a and b are positive integers, and so the process will be finite.You have to determine the values of a and b after the process ends.","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5', 'output': ['0 5\\n']}, {'input': '20 15', 'output': ['10 15\\n']}, {'input': '100 50', 'output': ['0 50\\n']}, {'input': '60 30', 'output': ['0 30\\n']}, {'input': '80 40', 'output': ['0 40\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10 3 5 2 3\"]","prob_desc_input_spec":"The single line contains five integers C,\u2009Hr,\u2009Hb,\u2009Wr,\u2009Wb (1\u2009\u2264\u2009C,\u2009Hr,\u2009Hb,\u2009Wr,\u2009Wb\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"\/*input\n10 3 5 2 3\n*\/\n#include <bits\/stdc++.h>\nusing namespace std;\nlong long c,wr,wb,hr,hb,ans=0;\nlong long get(int i){\n\treturn i*hr+hb*int((c-i*wr)\/wb);\n}\nint main(){\n\tcin>>c>>hr>>hb>>wr>>wb;\n\tif(hb*wr>hr*wb){\n\t\tswap(hr,hb);\n\t\tswap(wr,wb);\n\t}\n\tif(wr>1e4){\n\t\tfor(int i=0;i*wr<=c;++i)\n\t\t\tans=max(ans,get(i));\n\t}\n\telse if(wb>1e4){\n\t\tfor(int i=0;i*wb<=c;++i)\n\t\t\tans=max(ans,i*hb+hr*int((c-i*wb)\/wr));\n\t}\n\telse{\n\t\tfor(int i=0;i<1e7&&i*wb<=c;i++){\n\t\t\tans=max(ans,i*hb+hr*int((c-i*wb)\/wr));\n\t\t}\n\t}\n\tcout<<ans;\n\t\/\/assert(0);\n}","prob_desc_sample_outputs":"[\"16\"]","lang_cluster":"C++","code_uid":"b8d69258742520bfbb90459050c614c1","prob_desc_notes":"NoteIn the sample test Om Nom can eat two candies of each type and thus get 16 joy units.","prob_desc_output_spec":"Print a single integer \u2014 the maximum number of joy units that Om Nom can get.","prob_desc_output_to":"standard output","prob_desc_description":"A sweet little monster Om Nom loves candies very much. One day he found himself in a rather tricky situation that required him to think a bit in order to enjoy candies the most. Would you succeed with the same task if you were on his place?  One day, when he came to his friend Evan, Om Nom didn't find him at home but he found two bags with candies. The first was full of blue candies and the second bag was full of red candies. Om Nom knows that each red candy weighs Wr grams and each blue candy weighs Wb grams. Eating a single red candy gives Om Nom Hr joy units and eating a single blue candy gives Om Nom Hb joy units.Candies are the most important thing in the world, but on the other hand overeating is not good. Om Nom knows if he eats more than C grams of candies, he will get sick. Om Nom thinks that it isn't proper to leave candy leftovers, so he can only eat a whole candy. Om Nom is a great mathematician and he quickly determined how many candies of what type he should eat in order to get the maximum number of joy units. Can you repeat his achievement? You can assume that each bag contains more candies that Om Nom can eat.","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3 5 2 3', 'output': ['16']}, {'input': '20 5 3 4 2', 'output': ['25']}, {'input': '15 2 4 3 2', 'output': ['24']}, {'input': '30 6 4 5 3', 'output': ['36']}, {'input': '25 3 5 2 4', 'output': ['31']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\"]","prob_desc_input_spec":"The first line contains a single integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091000).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\n#define ll long long int\nusing namespace std;\nconst int N=1010;\nconst int MOD=(int)1e6+3;\nll n,dp[N],twoPow[2*N];\n\nvoid init() {\n    twoPow[0]=1;\n    for(int i=1;i<=2*N;i++)\n        twoPow[i]=(twoPow[i-1]*2)%MOD;\n    memset(dp,-1,sizeof(dp));\n}\n\nll cookie(ll a) {\n    return (twoPow[a-1]*(twoPow[a]+1))%MOD;\n}\n\nll solve(ll a) {\n    if (a<=0)\n        return 0;\n    if (dp[a]!=-1)\n        return dp[a];\n    dp[a]=cookie(a)%MOD;\n    for(int i=1;a-i>0;i++) {\n        dp[a]=(dp[a]+solve(a-i)*twoPow[i-1])%MOD;\n    }\n    return dp[a];\n}\n\nint main() {\n    init();\n    cin >> n;\n    cout << (twoPow[2*n]-solve(n)+MOD)%MOD << endl;\n}\n","prob_desc_sample_outputs":"[\"9\"]","lang_cluster":"C++","code_uid":"a0831519cbb276581bbab46a58baff2c","prob_desc_notes":"NoteIf the box possesses the base of 23\u2009\u00d7\u200923 (as in the example), then the cookies will be put there in the following manner: ","prob_desc_output_spec":"Print the single number, equal to the number of empty cells in the box. The answer should be printed modulo 106\u2009+\u20093.","prob_desc_output_to":"standard output","prob_desc_description":"Fangy collects cookies. Once he decided to take a box and put cookies into it in some way. If we take a square k\u2009\u00d7\u2009k in size, divided into blocks 1\u2009\u00d7\u20091 in size and paint there the main diagonal together with cells, which lie above it, then the painted area will be equal to the area occupied by one cookie k in size. Fangy also has a box with a square base 2n\u2009\u00d7\u20092n, divided into blocks 1\u2009\u00d7\u20091 in size. In a box the cookies should not overlap, and they should not be turned over or rotated. See cookies of sizes 2 and 4 respectively on the figure:    To stack the cookies the little walrus uses the following algorithm. He takes out of the repository the largest cookie which can fit in some place in the box and puts it there. Everything could be perfect but alas, in the repository the little walrus has infinitely many cookies of size 2 and larger, and there are no cookies of size 1, therefore, empty cells will remain in the box. Fangy wants to know how many empty cells will be left in the end.","length":35,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0\\n', 'output': ['1\\n']}, {'input': '1\\n', 'output': ['1\\n']}, {'input': '2\\n', 'output': ['3\\n']}, {'input': '4\\n', 'output': ['27\\n']}, {'input': '5\\n', 'output': ['81\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":3400.0,"prob_desc_time_limit":"5 seconds","prob_desc_sample_inputs":"[\"3 6 100000\", \"6 21 100129\", \"58 787788 50216\"]","prob_desc_input_spec":"The only line contains three integers maxn, maxa and q (1\u2009\u2264\u2009maxn\u2009\u2264\u200930\u2009000; maxn\u2009\u2264\u2009maxa\u2009\u2264\u2009109; 104\u2009\u2264\u2009q\u2009\u2264\u2009105\u2009+\u2009129).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\n\nconst int p1 = 998244353, p2 = 469762049, Maxn = 1 << 17 | 5;\nint maxn, maxa, mod, rev[Maxn];\nint tot, l[Maxn];\nconst long long lcm = p1 * (long long) p2;\nvoid get_rev(int len)\n{\n\tfor (int i = 0; i < len; i++)\n\t\trev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (len >> 1));\n}\nlong long fast_pow(long long x, long long y, int p)\n{\n\tlong long ans = 1, now = x;\n\twhile (y)\n\t{\n\t\tif (y & 1) ans = ans * now % p;\n\t\tnow = now * now % p;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\nvoid NTT(int now[], int len, int p, bool type = false)\n{\n\tl[0] = 1;\n\tint inv3 = fast_pow(3, p - 2, p);\n\tfor (int i = 0; i < len; i++)\n\t\tif (i < rev[i]) swap(now[i], now[rev[i]]);\n\tfor (int i = 1; i < len; i <<= 1)\n\t{\n\t\tlong long w = fast_pow(type ? inv3 : 3, (p - 1) \/ (i << 1), p);\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tl[j] = l[j - 1] * w % p;\n\t\tfor (int j = 0; j < len; j += (i << 1))\n\t\t\tfor (int k = j; k < i + j; k++)\n\t\t\t{\n\t\t\t\tint x = now[i + k] * (long long) l[k - j] % p, y = now[k];\n\t\t\t\tnow[k] = (x + y) % p;\n\t\t\t\tnow[i + k] = (y - x + p) % p;\n\t\t\t}\n\t}\n\tif (type)\n\t{\n\t\tlong long inv = fast_pow(len, p - 2, p);\n\t\tfor (int i = 0; i < len; i++)\n\t\t\tnow[i] = now[i] * inv % p;\n\t}\n}\nvoid multi(int x[], int y[], int result[], int len, int p)\n{\n\tNTT(x, len, p), NTT(y, len, p);\n\tfor (int i = 0; i < len; i++)\n\t\tresult[i] = x[i] * (long long) y[i] % p;\n\tNTT(result, len, p, true);\n}\nlong long mul(long long x, long long y)\n{\n\treturn ((unsigned long long) x * y - (long long) (x \/ (long double) lcm * y) * lcm + lcm) % lcm;\n}\nvoid multi(int x[], int y[], int result[], int len)\n{\n\tget_rev(len);\n\tstatic int tmp1[Maxn], tmp2[Maxn], tmpx[Maxn], tmpy[Maxn];\n\tfor (int i = 0; i < len; i++)\n\t\ttmpx[i] = x[i], tmpy[i] = y[i];\n\tmulti(tmpx, tmpy, tmp1, len, p1);\n\tfor (int i = 0; i < len; i++)\n\t\ttmpx[i] = x[i], tmpy[i] = y[i];\n\tmulti(tmpx, tmpy, tmp2, len, p2);\n\tlong long P1 = fast_pow(p2, p1 - 2, p1), P2 = fast_pow(p1, p2 - 2, p2);\n\tfor (int i = 0; i < len; i++)\n\t\tresult[i] = (mul(mul(tmp1[i], p2), P1) + mul(mul(tmp2[i], p1), P2)) % lcm % mod;\n}\nvoid poly_pow(int y, int len)\n{\n\tint now = 0;\n\tstatic int ans[2][Maxn];\n\tmemset(ans[0], 0, sizeof(int[len << 1]));\n\tmemset(ans[1], 0, sizeof(int[len << 1]));\n\tstatic int tmp[Maxn], result[2][Maxn];\n\tfor (int j = 30; j >= 0; j--)\n\t{\n\t\tcerr << j << endl;\n\t\tmemset(tmp, 0, sizeof(int[len << 1]));\n\t\tfor (int i = 0; i < len; i++)\n\t\t\ttmp[i] = (ans[0][i] + ans[1][i]) % mod;\n\t\ttmp[0]++;\n\t\tfor (int p = 0; p <= 1; p++)\n\t\t\tmulti(tmp, ans[(now & 1) ^ p], result[p], len << 1);\n\t\tfor (int p = 0; p <= 1; p++)\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t\t(ans[p][i] += result[p][i]) %= mod;\n\t\tnow <<= 1;\n\t\tif (y & (1 << j))\n\t\t{\n\t\t\tfor (int i = len - 1; i; i--)\n\t\t\t\t(ans[1][i] += ans[0][i - 1] + ans[1][i - 1]) %= mod;\n\t\t\tans[1][1]++; \n\t\t\tnow++;\n\t\t}\n\t\tif (now != y)\n\t\t\tfor (int i = 1; i <= maxn; i += 2)\n\t\t\t\t(tot += ans[1][i]) %= mod;\n\t}\n}\nint lower(int x)\n{\n\tint tmp = 1;\n\tfor (; tmp < x; tmp <<= 1);\n\treturn tmp;\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &maxn, &maxa, &mod);\n\tpoly_pow(maxa, lower(maxn + 1));\n\tprintf(\"%d\", tot);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"4\", \"154\", \"46009\"]","lang_cluster":"C++","code_uid":"6856ab94d32ed126ea27d37b3db2a3c5","prob_desc_notes":"NoteIn the first example, interesting test cases look as follows: 1              1              1              32              4              6              2 4 6","prob_desc_output_spec":"Output a single integer\u00a0\u2014 the number of test cases which satisfy the constraints and make both wrong solutions output an incorrect answer, modulo q.","prob_desc_output_to":"standard output","prob_desc_description":"Test data generation is not an easy task! Often, generating big random test cases is not enough to ensure thorough testing of solutions for correctness.For example, consider a problem from an old Codeforces round. Its input format looks roughly as follows:The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009maxn)\u00a0\u2014 the size of the set. The second line contains n distinct integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009maxa)\u00a0\u2014 the elements of the set in increasing order.If you don't pay attention to the problem solution, it looks fairly easy to generate a good test case for this problem. Let n\u2009=\u2009maxn, take random distinct ai from 1 to maxa, sort them... Soon you understand that it's not that easy.Here is the actual problem solution. Let g be the greatest common divisor of a1,\u2009a2,\u2009...,\u2009an. Let x\u2009=\u2009an\u2009\/\u2009g\u2009-\u2009n. Then the correct solution outputs \"Alice\" if x is odd, and \"Bob\" if x is even.Consider two wrong solutions to this problem which differ from the correct one only in the formula for calculating x.The first wrong solution calculates x as x\u2009=\u2009an\u2009\/\u2009g (without subtracting n).The second wrong solution calculates x as x\u2009=\u2009an\u2009-\u2009n (without dividing by g).A test case is interesting if it makes both wrong solutions output an incorrect answer.Given maxn, maxa and q, find the number of interesting test cases satisfying the constraints, and output it modulo q.","length":119,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 10 100000', 'output': ['10\\n']}, {'input': '10 20 100129', 'output': ['154\\n']}, {'input': '20 40 50216', 'output': ['46009\\n']}, {'input': '30 60 100000', 'output': ['10\\n']}, {'input': '40 80 100129', 'output': ['154\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"BBBSSC\\n6 4 1\\n1 2 3\\n4\", \"BBC\\n1 10 1\\n1 10 1\\n21\", \"BSC\\n1 1 1\\n1 1 3\\n1000000000000\"]","prob_desc_input_spec":"The first line of the input contains a non-empty string that describes the recipe of \"Le Hamburger de Polycarpus\". The length of the string doesn't exceed 100, the string contains only letters 'B' (uppercase English B), 'S' (uppercase English S) and 'C' (uppercase English C). The second line contains three integers nb, ns, nc (1\u2009\u2264\u2009nb,\u2009ns,\u2009nc\u2009\u2264\u2009100) \u2014 the number of the pieces of bread, sausage and cheese on Polycarpus' kitchen. The third line contains three integers pb, ps, pc (1\u2009\u2264\u2009pb,\u2009ps,\u2009pc\u2009\u2264\u2009100) \u2014 the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer r (1\u2009\u2264\u2009r\u2009\u2264\u20091012) \u2014 the number of rubles Polycarpus has. Please, do not write the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specifier.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <iostream>\n \nusing namespace std;\nstring s;\nint need[3] = {};\nint have[3] = {};\nint price[3] = {};\nlong long r ;\nbool solve(long long m)\n{\n    long long p = 0;\n    for (int i = 0 ; i < 3 ; i++)\n    {\n        long long z = m*need[i];\n        z = z - have[i];\n        if (z > 0)\n        {\n            p = p + z*price[i];\n        }\n    }\n    return p <= r;\n}\n \nint main()\n{\n    cin >> s;\n    for (int i = 0 ; i < s.size() ; i++)\n    {\n        if (s[i] == 'B')need[0]++;\n        if (s[i] == 'S')need[1]++;\n        if (s[i] == 'C')need[2]++;\n    }\n    for (int i = 0 ; i < 3 ; i++)\n    {\n        cin >> have[i];\n    }\n    for (int i = 0 ; i < 3 ; i++)\n        cin >> price[i];\n    cin >> r;\n    long long s = 0 , e = 1e15;\n    long long ans = 0;\n    while(s <= e)\n    {\n        long long middle = (s+e)\/2;\n        if (solve(middle))\n           {\n \n              s = middle+1;\n              ans = middle;\n           }\n        else e = middle - 1;\n \n    }\n    cout << ans << endl;\n \n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"7\", \"200000000001\"]","lang_cluster":"C++","code_uid":"2f8dd925dd6a7b0ba31981760e264222","prob_desc_notes":null,"prob_desc_output_spec":"Print the maximum number of hamburgers Polycarpus can make. If he can't make any hamburger, print 0.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarpus loves hamburgers very much. He especially adores the hamburgers he makes with his own hands. Polycarpus thinks that there are only three decent ingredients to make hamburgers from: a bread, sausage and cheese. He writes down the recipe of his favorite \"Le Hamburger de Polycarpus\" as a string of letters 'B' (bread), 'S' (sausage) \u0438 'C' (cheese). The ingredients in the recipe go from bottom to top, for example, recipe \"\u0412SCBS\" represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again.Polycarpus has nb pieces of bread, ns pieces of sausage and nc pieces of cheese in the kitchen. Besides, the shop nearby has all three ingredients, the prices are pb rubles for a piece of bread, ps for a piece of sausage and pc for a piece of cheese.Polycarpus has r rubles and he is ready to shop on them. What maximum number of hamburgers can he cook? You can assume that Polycarpus cannot break or slice any of the pieces of bread, sausage or cheese. Besides, the shop has an unlimited number of pieces of each ingredient.","length":57,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'BBBSSC\\n6 4 1\\n1 2 3\\n4', 'output': ['2\\n']}, {'input': 'BBC\\n1 10 1\\n1 10 1\\n21', 'output': ['7\\n']}, {'input': 'BSC\\n1 1 1\\n1 1 3\\n1000000000000', 'output': ['200000000001\\n']}, {'input': 'BBB\\n10 0 0\\n1 1 1\\n10', 'output': ['10\\n']}, {'input': 'SSS\\n0 5 0\\n1 1 1\\n5', 'output': ['5\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"sumimasen\", \"ninja\", \"codeforces\"]","prob_desc_input_spec":"The first line of the input contains the string $$$s$$$ consisting of $$$|s|$$$ ($$$1\\leq |s|\\leq 100$$$) lowercase Latin letters.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nstring st;\nbool pd(int i)\n{\n    return st[i]=='a'||st[i]=='e'||st[i]=='i'||st[i]=='o'||st[i]=='u';\n}\nint main()\n{\n\tcin>>st;\n\tfor(int i=0;i<st.size();i++)\n\t{\n\t\tif(!pd(i)&&!pd(i+1)&&st[i]!='n')\n\t\t{\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"YES\"<<endl;\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"5810e4cdab20268ee655c4399f065046","prob_desc_notes":"NoteIn the first and second samples, a vowel goes after each consonant except \"n\", so the word is Berlanese.In the third sample, the consonant \"c\" goes after the consonant \"r\", and the consonant \"s\" stands on the end, so the word is not Berlanese.","prob_desc_output_spec":"Print \"YES\" (without quotes) if there is a vowel after every consonant except \"n\", otherwise print \"NO\". You can print each letter in any case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"Vitya has just started learning Berlanese language. It is known that Berlanese uses the Latin alphabet. Vowel letters are \"a\", \"o\", \"u\", \"i\", and \"e\". Other letters are consonant.In Berlanese, there has to be a vowel after every consonant, but there can be any letter after any vowel. The only exception is a consonant \"n\"; after this letter, there can be any letter (not only a vowel) or there can be no letter at all. For example, the words \"harakiri\", \"yupie\", \"man\", and \"nbo\" are Berlanese while the words \"horse\", \"king\", \"my\", and \"nz\" are not.Help Vitya find out if a word $$$s$$$ is Berlanese.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'berlanese', 'output': ['YES\\n']}, {'input': 'programming', 'output': ['NO\\n']}, {'input': 'n', 'output': ['YES\\n']}, {'input': 'aeiou', 'output': ['YES\\n']}, {'input': 'nnnnn', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":2000.0,"prob_desc_time_limit":"4 seconds","prob_desc_sample_inputs":"[\"104 2\", \"223 4\", \"7067678 8\"]","prob_desc_input_spec":"The first line contains two integers: n (1\u2009\u2264\u2009n\u2009&lt;\u20091018) and m (1\u2009\u2264\u2009m\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"\/\/codeforces 401D Roman and Numbers\n#include<bits\/stdc++.h>\n#define ll long long\nconst int maxs=(1<<18)+5;\nconst int maxn=110;\nusing namespace std;\nint cnt=-1,w[20],m;\nll f[maxs][maxn],n;\nbool vis[10];\nint main(){\n\tfor(cin>>n>>m;n;n\/=10)\n\t w[++cnt]=n%10;\n\tf[0][0]=1;\n\tfor(int s=1;s<1<<cnt+1;s++){ \n\t  memset(vis,0,sizeof vis);\n\t  for(int i=0;i<=cnt;i++){\n\t\tif(s==(1<<i)&&!w[i]) break;\n\t\tif(!(s&(1<<i))||vis[w[i]]) continue;\n\t\tvis[w[i]]=1;\n\t\tfor(int j=0;j<m;j++)\n\t\t f[s][(j*10+w[i])%m]=(f[s][(j*10+w[i])%m]+f[s^(1<<i)][j]);\t\n\t  }\t\t\n\t}\n\tcout<<f[(1<<cnt+1)-1][0];\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"3\", \"1\", \"47\"]","lang_cluster":"C++","code_uid":"5a1a100f99b3e42e0539093627bfce9e","prob_desc_notes":"NoteIn the first sample the required numbers are: 104, 140, 410.In the second sample the required number is 232.","prob_desc_output_spec":"In a single line print a single integer \u2014 the number of numbers close to number n modulo m.","prob_desc_output_to":"standard output","prob_desc_description":"Roman is a young mathematician, very famous in Uzhland. Unfortunately, Sereja doesn't think so. To make Sereja change his mind, Roman is ready to solve any mathematical problem. After some thought, Sereja asked Roma to find, how many numbers are close to number n, modulo m.Number x is considered close to number n modulo m, if:  it can be obtained by rearranging the digits of number n,  it doesn't have any leading zeroes,  the remainder after dividing number x by m equals 0. Roman is a good mathematician, but the number of such numbers is too huge for him. So he asks you to help him. ","length":26,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '123 3', 'output': ['1\\n']}, {'input': '456 6', 'output': ['0\\n']}, {'input': '789 9', 'output': ['0\\n']}, {'input': '111 1', 'output': ['1\\n']}, {'input': '222 2', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 3\\n0 4 5 6 7\", \"1 0\\n0\", \"5 0\\n1 2 3 4 5\"]","prob_desc_input_spec":"The first line contains two integers n and x (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009x\u2009\u2264\u2009100)\u00a0\u2014 the size of the set Dr. Evil owns, and the desired MEX. The second line contains n distinct non-negative integers not exceeding 100 that represent the set.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int maxn = 105;\nint n,m;\nint mp[maxn];\nint a[maxn];\nint main()\n{\n    cin>>n>>m;\n    \/*int mp[maxn];\n    int a[maxn];*\/\n    int cnt;\n    \/\/memset(mp,0,sizeof(mp));\n    for(int i=0;i<n;i++)\n    {\n        cin>>a[i];\n        mp[a[i]]=1;\n    }\n\n    cnt=0;\n    if(mp[m]==1) cnt++;\n    for(int i=0;i<m;i++)\n    {\n        if(mp[i]==0)\n            cnt++;\n    }\n    cout<<cnt<<endl;\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"1\", \"0\"]","lang_cluster":"C++","code_uid":"5762822697e55f4a7c9955d5d08f326b","prob_desc_notes":"NoteFor the first test case Dr. Evil should add 1 and 2 to the set performing 2 operations.For the second test case Dr. Evil should erase 0 from the set. After that, the set becomes empty, so the MEX of it is 0.In the third test case the set is already evil.","prob_desc_output_spec":"The only line should contain one integer\u00a0\u2014 the minimal number of operations Dr. Evil should perform.","prob_desc_output_to":"standard output","prob_desc_description":"Dr. Evil kidnapped Mahmoud and Ehab in the evil land because of their performance in the Evil Olympiad in Informatics (EOI). He decided to give them some problems to let them go.Dr. Evil is interested in sets, He has a set of n integers. Dr. Evil calls a set of integers evil if the MEX of it is exactly x. the MEX of a set of integers is the minimum non-negative integer that doesn't exist in it. For example, the MEX of the set {0,\u20092,\u20094} is 1 and the MEX of the set {1,\u20092,\u20093} is 0 .Dr. Evil is going to make his set evil. To do this he can perform some operations. During each operation he can add some non-negative integer to his set or erase some element from it. What is the minimal number of operations Dr. Evil has to perform to make his set evil?","length":32,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 2\\n0 1 3', 'output': ['0\\n']}, {'input': '4 3\\n0 1 2 4', 'output': ['0\\n']}, {'input': '5 4\\n0 1 2 3 5', 'output': ['0\\n']}, {'input': '6 5\\n0 1 2 3 4 6', 'output': ['0\\n']}, {'input': '7 6\\n0 1 2 3 4 5 7', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 47\", \"47 1024\"]","prob_desc_input_spec":"The single line contains a pair of integers l and r (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u20091018) \u2014 the boundaries of the interval. Please, do not use the %lld specifier to read or write 64-bit integers in \u0421++. It is preferred to use cin, cout streams or the %I64d specifier.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <iostream>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\n\n#define f(i,s,e) for (int i = int(s); i != int(e); i++)\n#define ft(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)\n#define all(c) (c).begin(), (c).end()\n\n\/\/read scanf functions\n#define readI(x) scanf(\"%d\", &x)\n#define readL(x) scanf(\"%I64d\", &x)\n#define readD(x) scanf(\"%f\", &x)\n#define readII(x, y) scanf(\"%d %d\", &x, &y)\n#define readLL(x, y) scanf(\"%I64d %I64d\", &x, &y)\n\ntypedef long long ll;\n\nll l, r;\n\n\nint cntDigits(ll x) {\n    int ret =0;\n    while (x) ret++, x\/=10;\n    return ret;\n}\nll power[20];\n\nll solve(ll x) {\n    ll ret;\n    if (x <= 9) ret = x;\n    else ret = x\/10-1+9;\n\n    if (x>9)\n        ret += ((x%10)>=x\/(power[cntDigits(x)-1]));\n    return ret;\n}\n\nint main() {\n    cin >> l >> r;\n    power[0]= 1;\n    for(int i=1; i<=19; i++) power[i] = power[i-1]*10;\n    cout << solve(r) - solve(l-1) << \"\\n\";\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"12\", \"98\"]","lang_cluster":"C++","code_uid":"3db3313ce595ee0e81f79c66f48f58be","prob_desc_notes":"NoteIn the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44. ","prob_desc_output_spec":"On a single line print a single integer \u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"The Little Elephant very much loves sums on intervals.This time he has a pair of integers l and r (l\u2009\u2264\u2009r). The Little Elephant has to find the number of such integers x (l\u2009\u2264\u2009x\u2009\u2264\u2009r), that the first digit of integer x equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.Help him and count the number of described numbers x for a given pair l and r.","length":53,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10', 'output': ['10\\n']}, {'input': '11 20', 'output': ['1\\n']}, {'input': '100 200', 'output': ['10\\n']}, {'input': '500 600', 'output': ['10\\n']}, {'input': '1000 2000', 'output': ['100\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 1\\n10 5\", \"4 5\\n3 3\", \"1 2\\n11 6\"]","prob_desc_input_spec":"The first line contains two positive integers not exceeding 100. They are the number of fingers on the Venusian girl's left and right hand correspondingly. The second line contains two integers not exceeding 100. They are the number of fingers on the Marsian boy's left and right hands correspondingly.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#pragma GCC optimize (\"O3\")\n#include <bits\/stdc++.h>\n\nusing namespace std;\n\n#define ENGZ ios::sync_with_stdio(0);cin.tie(0);ios_base::sync_with_stdio(0);\n#define sfl(x) scanf(\"%I64d\" , &x)\n#define sfl2(x, y) scanf(\"%I64d%I64d\" , &x,&y)\n#define sfi(x) scanf(\"%d\" , &x)\n#define sfi2(x, y) scanf(\"%d%d\" , &x,&y)\n#define sfd(x) scanf(\"%lf\", &x)\n#define sfd2(x) scanf(\"%lf\", &x)\n#define sfc(x) scanf(\"%c\", &x)\n#define sfd2(x, y) scanf(\"%lf%lf\", &x, &y)\n#define mod 1000000007\n#define pi (2*acos(0))\ntypedef long long ll;\n#define endl '\\n'\n\nint main()\n{\n    int a, b, x, y;\n    cin >> a >> b >> x >> y;\n    for (int i = 0; i < b - 1; i++)\n        x--;\n    if (x < 0)\n    {\n        for (int i = 0; i < a - 1; i++)\n            y--;\n        if (y < 0)\n            cout << \"NO\";\n        else\n        {\n            y -= 2;\n            for (int i = 0; i <= a && y > 0; i++)\n                y--;\n            if (y <= 0)\n                cout << \"YES\";\n            else\n                cout << \"NO\";\n        }\n    }\n    else\n    {\n        x -= 2;\n        for (int i = 0; i <= b && x > 0; i++)\n            x--;\n        if (x > 0)\n        {\n            for (int i = 0; i < a - 1; i++)\n                y--;\n            if (y < 0)\n                cout << \"NO\";\n            else\n            {\n                y -= 2;\n                for (int i = 0; i <= a && y > 0; i++)\n                    y--;\n                if (y <= 0)\n                    cout << \"YES\";\n                else\n                    cout << \"NO\";\n            }\n        }\n        else\n            cout << \"YES\";\n    }\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"6ab780a3249ef2c7669b70d0f297af0a","prob_desc_notes":"NoteThe boy and the girl don't really care who goes to the left.","prob_desc_output_spec":"Print YES or NO, that is, the answer to Petr Palych's question.","prob_desc_output_to":"standard output","prob_desc_description":"Statistics claims that students sleep no more than three hours a day. But even in the world of their dreams, while they are snoring peacefully, the sense of impending doom is still upon them.A poor student is dreaming that he is sitting the mathematical analysis exam. And he is examined by the most formidable professor of all times, a three times Soviet Union Hero, a Noble Prize laureate in student expulsion, venerable Petr Palych.The poor student couldn't answer a single question. Thus, instead of a large spacious office he is going to apply for a job to thorium mines. But wait a minute! Petr Palych decided to give the student the last chance! Yes, that is possible only in dreams. So the professor began: \"Once a Venusian girl and a Marsian boy met on the Earth and decided to take a walk holding hands. But the problem is the girl has al fingers on her left hand and ar fingers on the right one. The boy correspondingly has bl and br fingers. They can only feel comfortable when holding hands, when no pair of the girl's fingers will touch each other. That is, they are comfortable when between any two girl's fingers there is a boy's finger. And in addition, no three fingers of the boy should touch each other. Determine if they can hold hands so that the both were comfortable.\"The boy any the girl don't care who goes to the left and who goes to the right. The difference is only that if the boy goes to the left of the girl, he will take her left hand with his right one, and if he goes to the right of the girl, then it is vice versa.","length":69,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 1\\n10 5', 'output': ['YES\\n']}, {'input': '4 5\\n3 3', 'output': ['YES\\n']}, {'input': '1 2\\n11 6', 'output': ['NO\\n']}, {'input': '3 3\\n4 4', 'output': ['YES\\n']}, {'input': '10 10\\n20 20', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 0\", \"2 2 0\", \"1 1 1\"]","prob_desc_input_spec":"The first line of the input contains three space-separated integers n,\u2009m,\u2009g (0\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009105,\u2009n\u2009+\u2009m\u2009\u2265\u20091,\u20090\u2009\u2264\u2009g\u2009\u2264\u20091).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define p 1e6+7\n#define N 10010\n#define mc(a,b) memset(a,b,sizeof(a))\n#define close std::ios::sync_with_stdio\nusing namespace std;\nusing namespace std;\nconst double eps(1e-8);\ntypedef long long lint;\nconst lint mod = 1000000007LL;\nint n, m, g;\nlint fac[200010];\nvoid init()\n{\n    fac[0] = fac[1] = 1;\n    for(int i = 2; i <= 200000; i++)\n        fac[i] = fac[i - 1] * i % mod;\n    return;\n}\n \nlint quick_pow(lint base, lint pow)\n{\n    lint ret = 1;\n    while(pow)\n    {\n        if(pow & 1)\n            ret = (ret * base) % mod;\n        base = base * base % mod;\n        pow >>= 1;\n    }\n    return ret;\n}\n \nlint C(int r, int k)\/\/C[r][k]\n{\n    return fac[r]*quick_pow(fac[k]*fac[r - k] % mod, mod - 2LL) % mod;\n}\n \nint main()\n{\n    scanf(\"%d %d %d\", &n, &m, &g);\n    if(n == 0)\n    {\n        if(g == 0)\n        {\n            if(m == 1)\n                printf(\"0\\n\");\n            else\n                printf(\"1\\n\");\n        }\n        else\n        {\n            if(m == 1)\n                printf(\"1\\n\");\n            else\n                printf(\"0\\n\");\n        }\n        return 0;\n    }\n    if(m == 0)\n    {\n        if(g == 0)\n        {\n            if(n & 1)\n                printf(\"1\\n\");\n            else\n                printf(\"0\\n\");\n        }\n        else\n        {\n            if(n & 1)\n                printf(\"0\\n\");\n            else\n                printf(\"1\\n\");\n        }\n        return 0;\n    }\n    init();\n    lint all = C(n + m, n);\n    lint ans = 0;\n    for(int t = 0; t <= n; t += 2)\n        ans = (ans + C(n + m - 1 - t, m - 1)) % mod;\n    if(m == 1 && (n & 1) == 0)\n        ans = (ans - 1 + mod) % mod;\n    if(m == 1 && (n & 1))\n        ans = (ans + 1) % mod;\n    if(g == 0)\n        printf(\"%I64d\\n\", ans);\n    else\n        printf(\"%I64d\\n\", (all - ans + mod) % mod);\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"2\", \"4\", \"0\"]","lang_cluster":"C++","code_uid":"0b2e437f5a2e37686217c01e1e324067","prob_desc_notes":"NoteIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.","prob_desc_output_spec":"Print a single integer \u2014 the answer to the problem modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Vasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109\u2009+\u20097). ","length":96,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 2 1', 'output': ['5\\n']}, {'input': '4 3 0', 'output': ['35\\n']}, {'input': '5 4 1', 'output': ['126\\n']}, {'input': '6 5 0', 'output': ['792\\n']}, {'input': '7 6 1', 'output': ['7920\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"7 2 5\", \"10 3 10\"]","prob_desc_input_spec":"The first line contains three integers n, l, r (0\u2009\u2264\u2009n\u2009&lt;\u2009250, 0\u2009\u2264\u2009r\u2009-\u2009l\u2009\u2264\u2009105, r\u2009\u2265\u20091, l\u2009\u2265\u20091) \u2013 initial element and the range l to r. It is guaranteed that r is not greater than the length of the final list.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <vector>=\n#include <algorithm>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <limits>\n#include <climits>\n#include <cstdio>\n#include <numeric>\n#define ll long long\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst ll mod = 1000000007;\nconst double pi = acos(1.0*(-1));\ntypedef pair<int, int> P;\nint num[300010];\nll n, l, r, s = 1, ans;\nvoid solve(ll a, ll b, ll l, ll r, ll d)\/\/\u4e8c\u5206\u7684\u601d\u60f3\n{\n\tif (a > b || l > r)    return;\n\telse\n\t{\n\t\tll mid = (a + b) \/ 2;\n\t\tif (r < mid)solve(a, mid - 1, l, r, d \/ 2);\n\t\telse if (mid < l)solve(mid + 1, b, l, r, d \/ 2);\n\t\telse {\n\t\t\tans += d % 2;\n\t\t\tsolve(a, mid - 1, l, mid - 1, d \/ 2);\n\t\t\tsolve(mid + 1, b, mid + 1, r, d \/ 2);\n\t\t}\n\t}\n}\nint main()\n{\n\tcin >> n >> l >> r;\n\tlong long p = n;\n\twhile (p >= 2)\n\t{\n\t\tp \/= 2;\n\t\ts = s * 2 + 1;\n\t}\n\tsolve(1, s, l, r, n);\n\tcout << ans << endl;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"4\", \"5\"]","lang_cluster":"C++","code_uid":"45671c2fa3d1a6ade6adfb20c61bbdc1","prob_desc_notes":"NoteConsider first example:Elements on positions from 2-nd to 5-th in list is [1,\u20091,\u20091,\u20091]. The number of ones is 4.For the second example:Elements on positions from 3-rd to 10-th in list is [1,\u20091,\u20091,\u20090,\u20091,\u20090,\u20091,\u20090]. The number of ones is 5.","prob_desc_output_spec":"Output the total number of 1s in the range l to r in the final sequence.","prob_desc_output_to":"standard output","prob_desc_description":"Jon fought bravely to rescue the wildlings who were attacked by the white-walkers at Hardhome. On his arrival, Sam tells him that he wants to go to Oldtown to train at the Citadel to become a maester, so he can return and take the deceased Aemon's place as maester of Castle Black. Jon agrees to Sam's proposal and Sam sets off his journey to the Citadel. However becoming a trainee at the Citadel is not a cakewalk and hence the maesters at the Citadel gave Sam a problem to test his eligibility. Initially Sam has a list with a single element n. Then he has to perform certain operations on this list. In each operation Sam must remove any element x, such that x\u2009&gt;\u20091, from the list and insert at the same position , ,  sequentially. He must continue with these operations until all the elements in the list are either 0 or 1.Now the masters want the total number of 1s in the range l to r (1-indexed). Sam wants to become a maester but unfortunately he cannot solve this problem. Can you help Sam to pass the eligibility test?","length":60,"num_hidden_unit_tests":5,"hidden_unit_tests":"[]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\nbaabbb\", \"10\\nooopppssss\", \"1\\nz\"]","prob_desc_input_spec":"The first line contains integer $$$n$$$ ($$$1 \\le n \\le 55$$$) \u2014 the length of the encrypted string. The second line of the input contains $$$t$$$ \u2014 the result of encryption of some string $$$s$$$. It contains only lowercase Latin letters. The length of $$$t$$$ is exactly $$$n$$$. It is guaranteed that the answer to the test exists.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\n\nint i,l,n;\nchar s[60];\nint main()\n{\n\tcin>>l>>s;\n\tfor(;i<l;i+=n+1,n++)cout<<s[i];\n    return 0;\n}","prob_desc_sample_outputs":"[\"bab\", \"oops\", \"z\"]","lang_cluster":"C++","code_uid":"03e03e151d4cf4ec2993c9a5e86acb36","prob_desc_notes":null,"prob_desc_output_spec":"Print such string $$$s$$$ that after encryption it equals $$$t$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarp loves ciphers. He has invented his own cipher called repeating.Repeating cipher is used for strings. To encrypt the string $$$s=s_{1}s_{2} \\dots s_{m}$$$ ($$$1 \\le m \\le 10$$$), Polycarp uses the following algorithm:  he writes down $$$s_1$$$ ones,  he writes down $$$s_2$$$ twice,  he writes down $$$s_3$$$ three times,  ...  he writes down $$$s_m$$$ $$$m$$$ times. For example, if $$$s$$$=\"bab\" the process is: \"b\" $$$\\to$$$ \"baa\" $$$\\to$$$ \"baabbb\". So the encrypted $$$s$$$=\"bab\" is \"baabbb\".Given string $$$t$$$ \u2014 the result of encryption of some string $$$s$$$. Your task is to decrypt it, i.\u2009e. find the string $$$s$$$.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3\\naaa', 'output': ['a']}, {'input': '6\\naabbcc', 'output': ['abc']}, {'input': '10\\naaabbbcccdd', 'output': ['abcd']}, {'input': '15\\naaaabbbbccccddd', 'output': ['abcd']}, {'input': '21\\naaaabbbbccccddddeeeee', 'output': ['abcde']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 3\"]","prob_desc_input_spec":"The first and single line contains two integers A and B (1\u2009\u2264\u2009A,\u2009B\u2009\u2264\u2009109,\u2009min(A,\u2009B)\u2009\u2264\u200912).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define int long long\n\nint a , b , cnt = 1;\n\nvoid cul ( )\n{\n\tif ( a > b ) swap ( a , b );\n\twhile ( a != 1 ) {\n\t\tcnt *= a;\n\t\ta--;\n\t}\n}\n\nsigned main ( void )\n{\n\tcin >> a >> b;\n\tcul ( );\n\tcout << cnt << endl;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"6\"]","lang_cluster":"C++","code_uid":"bd4288e58ffba130c210bec4d9f29a5e","prob_desc_notes":"NoteConsider the sample.4!\u2009=\u20091\u00b72\u00b73\u00b74\u2009=\u200924. 3!\u2009=\u20091\u00b72\u00b73\u2009=\u20096. The greatest common divisor of integers 24 and 6 is exactly 6.","prob_desc_output_spec":"Print a single integer denoting the greatest common divisor of integers A! and B!.","prob_desc_output_to":"standard output","prob_desc_description":"Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vi\u010dkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vi\u010dkopolis. He almost even fell into a depression from boredom!Leha came up with a task for himself to relax a little. He chooses two integers A and B and then calculates the greatest common divisor of integers \"A factorial\" and \"B factorial\". Formally the hacker wants to find out GCD(A!,\u2009B!). It's well known that the factorial of an integer x is a product of all positive integers less than or equal to x. Thus x!\u2009=\u20091\u00b72\u00b73\u00b7...\u00b7(x\u2009-\u20091)\u00b7x. For example 4!\u2009=\u20091\u00b72\u00b73\u00b74\u2009=\u200924. Recall that GCD(x,\u2009y) is the largest positive integer q that divides (without a remainder) both x and y.Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","length":23,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3', 'output': ['6\\n']}, {'input': '7 7', 'output': ['5040\\n']}, {'input': '12 10', 'output': ['3628800\\n']}, {'input': '1 1', 'output': ['1\\n']}, {'input': '8 6', 'output': ['720\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 2 2\\n1 1 1\\n1 2 3 4 5 6\", \"0 0 10\\n3 2 3\\n1 2 3 4 5 6\"]","prob_desc_input_spec":"The fist input line contains three space-separated integers x, y and z (|x|,\u2009|y|,\u2009|z|\u2009\u2264\u2009106) \u2014 the coordinates of Vasya's position in space. The second line contains three space-separated integers x1, y1, z1 (1\u2009\u2264\u2009x1,\u2009y1,\u2009z1\u2009\u2264\u2009106) \u2014 the coordinates of the box's vertex that is opposite to the vertex at point (0,\u20090,\u20090). The third line contains six space-separated integers a1,\u2009a2,\u2009...,\u2009a6 (1\u2009\u2264\u2009ai\u2009\u2264\u2009106) \u2014 the numbers that are written on the box faces.  It is guaranteed that point (x,\u2009y,\u2009z) is located strictly outside the box.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<bits\/stdc++.h>\n#include<cmath>\n#define ll long long\n#define fr first\n#define sc second\n#define mod 1000000007\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define mp make_pair\nusing namespace std;\n\nstruct pt{\n    double x,y,z;\n    void read(){\n        cin>>x>>y>>z;\n    }\n    double dis(pt d){\n        return (x - d.x)*(x - d.x) + (y - d.y)*(y - d.y) + (z - d.z)*(z - d.z);\n    }\n};\nint a[6];\npt eyee;\npt s;\npt c[6];\n\n\nint main(){\n\n    eyee.read();\n    s.read();\n\n    for(int i=0 ; i<6 ; i++)cin>>a[i];\n\n    int res =0 ;\n\n    if(eyee.y < 0)res += a[0];\n    if(eyee.y > s.y)res += a[1];\n    if(eyee.z < 0)res += a[2];\n    if(eyee.z > s.z)res += a[3];\n    if(eyee.x < 0)res += a[4];\n    if(eyee.x > s.x)res += a[5];\n\n\n    cout<<res;\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"12\", \"4\"]","lang_cluster":"C++","code_uid":"c19a00b1a689bba111556ea51d4da2df","prob_desc_notes":"NoteThe first sample corresponds to perspective, depicted on the picture. Vasya sees numbers a2 (on the top face that is the darkest), a6 (on the right face that is the lightest) and a4 (on the left visible face).In the second sample Vasya can only see number a4.","prob_desc_output_spec":"Print a single integer \u2014 the sum of all numbers on the box faces that Vasya sees.","prob_desc_output_to":"standard output","prob_desc_description":"One day Vasya was going home when he saw a box lying on the road. The box can be represented as a rectangular parallelepiped. Vasya needed no time to realize that the box is special, as all its edges are parallel to the coordinate axes, one of its vertices is at point (0,\u20090,\u20090), and the opposite one is at point (x1,\u2009y1,\u2009z1). The six faces of the box contain some numbers a1,\u2009a2,\u2009...,\u2009a6, exactly one number right in the center of each face.  The numbers are located on the box like that:   number a1 is written on the face that lies on the ZOX plane;  a2 is written on the face, parallel to the plane from the previous point;  a3 is written on the face that lies on the XOY plane;  a4 is written on the face, parallel to the plane from the previous point;  a5 is written on the face that lies on the YOZ plane;  a6 is written on the face, parallel to the plane from the previous point. At the moment Vasya is looking at the box from point (x,\u2009y,\u2009z). Find the sum of numbers that Vasya sees. Note that all faces of the box are not transparent and Vasya can't see the numbers through the box. The picture contains transparent faces just to make it easier to perceive. You can consider that if Vasya is looking from point, lying on the plane of some face, than he can not see the number that is written on this face. It is enough to see the center of a face to see the corresponding number for Vasya. Also note that Vasya always reads correctly the ai numbers that he sees, independently of their rotation, angle and other factors (that is, for example, if Vasya sees some ai\u2009=\u20096, then he can't mistake this number for 9 and so on). ","length":46,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 2\\n1 1 1\\n1 2 3 4 5 6', 'output': ['4\\n']}, {'input': '2 0 0\\n1 1 1\\n1 2 3 4 5 6', 'output': ['6\\n']}, {'input': '0 2 0\\n1 1 1\\n1 2 3 4 5 6', 'output': ['2\\n']}, {'input': '-1 0 0\\n1 1 1\\n1 2 3 4 5 6', 'output': ['1\\n']}, {'input': '0 -1 0\\n1 1 1\\n1 2 3 4 5 6', 'output': ['5\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"xx..\\n.oo.\\nx...\\noox.\", \"x.ox\\nox..\\nx.o.\\noo.x\", \"x..x\\n..oo\\no...\\nx.xo\", \"o.x.\\no...\\n.x..\\nooxx\"]","prob_desc_input_spec":"The tic-tac-toe position is given in four lines. Each of these lines contains four characters. Each character is '.' (empty cell), 'x' (lowercase English letter x), or 'o' (lowercase English letter o). It is guaranteed that the position is reachable playing tic-tac-toe, and it is Ilya's turn now (in particular, it means that the game is not finished). It is possible that all the cells are empty, it means that the friends left without making single turn.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nchar c[10][10];\nint main() {\n\tfor(int i=0; i<4; i++)\n\t\tfor(int j=0; j<4; j++)\n\t\t\tcin>>c[i][j];\n\tbool flag=0;\n\tfor(int i=0; i<4; i++) {\n\t\tfor(int j=0; j<4; j++)\n\t\t\tif(c[i][j]=='.') {\n\t\t\t\tif(i>0 && i<3 && c[i-1][j]=='x' && c[i+1][j]=='x') flag=1;\n\t\t\t\telse if(j>0 && j<3 && c[i][j-1]=='x' && c[i][j+1]=='x') flag=1;\n\t\t\t\telse if(j>0 && i>0 && j<3 && i<3 && c[i-1][j-1]=='x' && c[i+1][j+1]=='x') flag=1;\n\t\t\t\telse if(j>0 && i>0 && j<3 && i<3 && c[i-1][j+1]=='x' && c[i+1][j-1]=='x') flag=1;\n\t\t\t\telse if(i>1 && c[i-1][j]=='x' && c[i-2][j]=='x') flag=1;\n\t\t\t\telse if(j>1 && c[i][j-1]=='x' && c[i][j-2]=='x') flag=1;\n\t\t\t\telse if(i<2 && c[i+1][j]=='x' && c[i+2][j]=='x') flag=1;\n\t\t\t\telse if(j<2 && c[i][j+1]=='x' && c[i][j+2]=='x') flag=1;\n\t\t\t\telse if(i>1 && j>1 && c[i-1][j-1]=='x' && c[i-2][j-2]=='x') flag=1;\n\t\t\t\telse if(i<2 && j<2 && c[i+1][j+1]=='x' && c[i+2][j+2]=='x') flag=1;\n\t\t\t\telse if(i>1 && j<2 && c[i-1][j+1]=='x' && c[i-2][j+2]=='x') flag=1;\n\t\t\t\telse if(i<2 && j>1 && c[i+1][j-1]=='x' && c[i+2][j-2]=='x') flag=1;\n\t\t\t\tif(flag) break;\n\t\t\t}\n\t\tif(flag) break;\n\t}\n\tif(flag) printf(\"YES\");\n\telse printf(\"NO\");\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"68be7913d7ce93a0cdca60cbae812e89","prob_desc_notes":"NoteIn the first example Ilya had two winning moves: to the empty cell in the left column and to the leftmost empty cell in the first row.In the second example it wasn't possible to win by making single turn.In the third example Ilya could have won by placing X in the last row between two existing Xs.In the fourth example it wasn't possible to win by making single turn.","prob_desc_output_spec":"Print single line: \"YES\" in case Ilya could have won by making single turn, and \"NO\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"Ilya is an experienced player in tic-tac-toe on the 4\u2009\u00d7\u20094 field. He always starts and plays with Xs. He played a lot of games today with his friend Arseny. The friends became tired and didn't finish the last game. It was Ilya's turn in the game when they left it. Determine whether Ilya could have won the game by making single turn or not. The rules of tic-tac-toe on the 4\u2009\u00d7\u20094 field are as follows. Before the first turn all the field cells are empty. The two players take turns placing their signs into empty cells (the first player places Xs, the second player places Os). The player who places Xs goes first, the another one goes second. The winner is the player who first gets three of his signs in a row next to each other (horizontal, vertical or diagonal).","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'x...\\n.x..\\n..x.\\n...o', 'output': ['YES']}, {'input': 'x...\\n.x..\\n..o.\\n...o', 'output': ['NO']}, {'input': 'x.x.\\n....\\n..o.\\n...o', 'output': ['YES']}, {'input': 'xoxo\\noxox\\nxoxo\\noxox', 'output': ['NO']}, {'input': '....\\n....\\n....\\n....', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 3 3\\n1 1 1\\n2 2 3\\n3 3 2\", \"4 10 2\\n2 3 8\\n3 4 7\"]","prob_desc_input_spec":"The first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$)\u00a0\u2014 the number of spots, the maximum height, and the number of restrictions. Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$)\u00a0\u2014 left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#pragma GCC diagnostic error \"-std=c++11\"\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<fstream>\nusing namespace std;\nint main()\n{\n\tios::sync_with_stdio(0);\n\tint ans=0,n,h,m,a[100];\n\tcin>>n>>h>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=h;\n\t}\n\twhile(m--)\n\t{\n\t\tint li,ri,xi;\n\t\tcin>>li>>ri>>xi;\n\t\tli--;\n\t\tri--;\n\t\tfor(int i=li;i<=ri;i++)\n\t\t{\n\t\t\tif(a[i]>xi)\n\t\t\t{\n\t\t\t\ta[i]=xi;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tans+=a[i]*a[i];\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}","prob_desc_sample_outputs":"[\"14\", \"262\"]","lang_cluster":"C++","code_uid":"7c2ff5f9dba6ebda834931db20771b55","prob_desc_notes":"NoteIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).","prob_desc_output_spec":"Print a single integer, the maximum profit you can make.","prob_desc_output_to":"standard output","prob_desc_description":"You are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.","length":91,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 3\\n1 2 3\\n3 4 4\\n5 5 2', 'output': ['41\\n']}, {'input': '6 6 2\\n1 3 4\\n4 6 5', 'output': ['101\\n']}, {'input': '7 7 1\\n1 7 6', 'output': ['252\\n']}, {'input': '8 8 4\\n1 2 7\\n3 4 6\\n5 6 5\\n7 8 4', 'output': ['204\\n']}, {'input': '9 9 5\\n1 2 8\\n3 4 7\\n5 6 6\\n7 8 5\\n9 9 4', 'output': ['285\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 5 4 6 1 3 6 2 5 5 1 2 3 5 3 1 1 2 4 6 6 4 3 4\", \"5 3 5 3 2 5 2 5 6 2 6 2 4 4 4 4 1 1 1 1 6 3 6 3\"]","prob_desc_input_spec":"In first line given a sequence of 24 integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20096), where ai denotes color of i-th square. There are exactly 4 occurrences of all colors in this sequence.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\nint a[25];\nint tu[8];\n\nint b[6][8] = { { 22, 21, 18, 17, 5, 6, 14, 13 },\n{ 3, 4, 17, 19, 10, 9, 16, 14 },\n{ 7, 8, 19, 20, 23, 24, 15, 16 },\n{ 1, 3, 5, 7, 9, 11, 24, 22 },\n{ 4, 2, 21, 23, 12,10, 8, 6 },\n{ 2, 1, 13, 15, 11, 12, 20, 18 } };\n\nbool res (int tmp[]){\n\n\tfor (int i = 2; i <=24; ++i){\n\t\tif ((i - 1) % 4 == 0)\n\t\t\tcontinue;\n\t\tif (tmp[i] != tmp[i - 1])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid rot(int tmp[],int f ,bool d){\n\t\n\n\tif (d){\n\t\tint j = 0;\n\t\tfor (int i = 2; i < 8; ++i){\n\t\t\ttu[j] = tmp[i];\n\t\t\t++j;\n\t\t}\n\t\ttu[6] = tmp[0];\n\t\ttu[7] = tmp[1];\n\t}\n\telse{\n\t\tint j = 0;\n\t\tfor (int i = 2; i < 8; ++i){\n\t\t\ttu[i] = tmp[j];\n\t\t\t++j;\n\t\t}\n\t\ttu[0] = tmp[7];\n\t\ttu[1] = tmp[6];\n\n\t}\n\n}\n\nbool can(int f){\n\n\tint tmp[8];\n\tfor (int i= 0; i < 8; ++i){\n\t\ttmp[i] = b[f][i];\n\t}\n\n\t\n\n\tint tmp_2[25];\n\n\n\tfor (int i = 1; i <= 24; ++i){\n\t\ttmp_2[i] = a[i];\n\t}\n\n\n\trot(tmp, f, 0);\n\n\tfor (int i = 0; i < 8; ++i){\n\t\ttmp_2[b[f][i]] = a[tu[i]];\n\t}\n\n\n\tif (res(tmp_2))\n\t\treturn true;\n\n\trot(tmp,f,1);\n\t\n\tfor (int i = 0; i < 8; ++i){\n\t\ttmp_2[b[f][i]] = a[tu[i]];\n\t}\n\n\n\tif (res(tmp_2))\n\t\treturn true;\n\n\n\treturn 0;\n\n}\n\n\nint main() {\n\n\/\/\tfreopen(\"Text.txt\", \"r\", stdin);\n\n\tfor (int i = 1; i <= 24; ++i){\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < 6; ++i){\n\t\tif (can(i)){\n\t\t\tcout << \"YES\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << \"NO\";\n\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"NO\", \"YES\"]","lang_cluster":"C++","code_uid":"4aa7bbc193aefdfc45b9c0d3829d39bf","prob_desc_notes":"NoteIn first test case cube looks like this:  In second test case cube looks like this:   It's possible to solve cube by rotating face with squares with numbers 13, 14, 15, 16.","prob_desc_output_spec":"Print \u00abYES\u00bb (without quotes) if it's possible to solve cube using one rotation and \u00abNO\u00bb (without quotes) otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"During the breaks between competitions, top-model Izabella tries to develop herself and not to be bored. For example, now she tries to solve Rubik's cube 2x2x2.It's too hard to learn to solve Rubik's cube instantly, so she learns to understand if it's possible to solve the cube in some state using 90-degrees rotation of one face of the cube in any direction.To check her answers she wants to use a program which will for some state of cube tell if it's possible to solve it using one rotation, described above.Cube is called solved if for each face of cube all squares on it has the same color.https:\/\/en.wikipedia.org\/wiki\/Rubik's_Cube","length":119,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6', 'output': ['YES\\n']}, {'input': '1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 6 6 6 6 6 6', 'output': ['NO\\n']}, {'input': '1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 5', 'output': ['NO\\n']}, {'input': '1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 4', 'output': ['NO\\n']}, {'input': '1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 3', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"0 0 2 0 0 1\", \"2 3 4 5 6 6\", \"-1 0 2 0 0 1\"]","prob_desc_input_spec":"The first input line contains 6 space-separated integers x1,\u2009y1,\u2009x2,\u2009y2,\u2009x3,\u2009y3 \u2014 coordinates of the triangle's vertices. All the coordinates are integer and don't exceed 100 in absolute value. It's guaranteed that the triangle is nondegenerate, i.e. its total area is not zero.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<iostream>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\nint x[20];\nint ck()\n{\n    int i;\n    int a,b,c,d;\n    for (i=1;i<=6;++i) x[i+6]=x[i];\n    for (i=1;i<6;i+=2)\n    {\n        a=x[i]-x[i+2]; b=x[i+1]-x[i+3];\n        if (a==0&&b==0) return 0;\n    }\n    for (i=1;i<6;i+=2)\n    {\n        a=x[i]-x[i+2]; b=x[i+1]-x[i+3];\n        c=x[i+2]-x[i+4]; d=x[i+3]-x[i+5];\n        if (a*c+b*d==0) return 1;\n    }\n    return 0;\n}\nint main()\n{\n    int i;\n    for (i=1;i<=6;++i) scanf(\"%d\",&x[i]);\n    if (ck()) cout <<\"RIGHT\"<<endl;\n    else \n    {\n        for (i=1;i<=6;++i)\n        {\n            x[i]--; if (ck()) {cout <<\"ALMOST\"<<endl;return 0;}\n            x[i]+=2; if (ck()) {cout <<\"ALMOST\"<<endl;return 0;}\n            x[i]--;\n        }\n        cout <<\"NEITHER\"<<endl; return 0;\n    }\n    return 0;\n}\n","prob_desc_sample_outputs":"[\"RIGHT\", \"NEITHER\", \"ALMOST\"]","lang_cluster":"C++","code_uid":"5d16450c5d229e1966c1f6653e909147","prob_desc_notes":null,"prob_desc_output_spec":"If the given triangle is right-angled, output RIGHT, if it is almost right-angled, output ALMOST, and if it is neither of these, output NEITHER.","prob_desc_output_to":"standard output","prob_desc_description":"At a geometry lesson Bob learnt that a triangle is called right-angled if it is nondegenerate and one of its angles is right. Bob decided to draw such a triangle immediately: on a sheet of paper he drew three points with integer coordinates, and joined them with segments of straight lines, then he showed the triangle to Peter. Peter said that Bob's triangle is not right-angled, but is almost right-angled: the triangle itself is not right-angled, but it is possible to move one of the points exactly by distance 1 so, that all the coordinates remain integer, and the triangle become right-angled. Bob asks you to help him and find out if Peter tricks him. By the given coordinates of the triangle you should find out if it is right-angled, almost right-angled, or neither of these.","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 3 0 0 4', 'output': ['ALMOST\\n']}, {'input': '0 0 3 4 0 4', 'output': ['NEITHER\\n']}, {'input': '0 0 3 0 0 3', 'output': ['RIGHT\\n']}, {'input': '0 0 1 1 2 2', 'output': ['NEITHER\\n']}, {'input': '0 0 1 0 0 1', 'output': ['RIGHT\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 1 1 1 1\", \"1 2 1 2 1 2\"]","prob_desc_input_spec":"The first and the single line of the input contains 6 space-separated integers a1,\u2009a2,\u2009a3,\u2009a4,\u2009a5 and a6 (1\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\nint a,b,c,d,e,f;\nint main()\n{\n\tcin >> a >> b >> c >> d >> e >> f;\n\tprintf(\"%d\\n\",(a + b + c) * (a + b + c) - a * a - c * c - e * e);\n    return 0;\n}","prob_desc_sample_outputs":"[\"6\", \"13\"]","lang_cluster":"C++","code_uid":"a8ffdfa991647b0bfd8f37e05f1413ad","prob_desc_notes":"NoteThis is what Gerald's hexagon looks like in the first sample:And that's what it looks like in the second sample:","prob_desc_output_spec":"Print a single integer \u2014 the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.","prob_desc_output_to":"standard output","prob_desc_description":"Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to . Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1 1 1 1', 'output': ['6\\n']}, {'input': '2 2 2 2 2 2', 'output': ['24\\n']}, {'input': '3 3 3 3 3 3', 'output': ['54\\n']}, {'input': '4 4 4 4 4 4', 'output': ['96\\n']}, {'input': '5 5 5 5 5 5', 'output': ['150\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"7\", \"8\", \"9\"]","prob_desc_input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\leq n \\leq 10^9$$$).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\nlong long n,dem=0;\nint main()\n{cin>>n;\ncout<<n\/2+1;\n}\n\n","prob_desc_sample_outputs":"[\"4\", \"5\", \"5\"]","lang_cluster":"C++","code_uid":"b29daf920b6253282a6bc50a179553fa","prob_desc_notes":"NoteIn the first sample, there are following possible weights of splits of $$$7$$$:Weight 1: [$$$\\textbf 7$$$] Weight 2: [$$$\\textbf 3$$$, $$$\\textbf 3$$$, 1] Weight 3: [$$$\\textbf 2$$$, $$$\\textbf 2$$$, $$$\\textbf 2$$$, 1] Weight 7: [$$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$]","prob_desc_output_spec":"Output one integer\u00a0\u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.For a given $$$n$$$, find out the number of different weights of its splits.","length":8,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n', 'output': ['6\\n']}, {'input': '15\\n', 'output': ['8\\n']}, {'input': '20\\n', 'output': ['11\\n']}, {'input': '25\\n', 'output': ['13\\n']}, {'input': '30\\n', 'output': ['16\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4\", \"9\"]","prob_desc_input_spec":"The only line contains a single integer x (1\u2009\u2264\u2009x\u2009\u2264\u2009100) \u2014 the required sharpness of the matrix.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"\/*\n\u4e00\u4e2a(2*i+1)*(2*i+1)\u7684\u5bf9\u79f0\u77e9\u9635\u6700\u591a\u5bb9\u7eb3\u76841\u7684\u6570\u91cf=((2*i+1)*(2*i+1)+1)\/2\n\n\u7b54\u6848\u5c31\u662f2*i+1\n\n\u6240\u4ee5\u66b4\u529b\u5373\u53ef\u3002\n\n\u7279\u522b\u7684\uff0c\u5f53i=3\u65f6\uff0c\u7531\u4e8e\u8fb9\u957f\u4e3a5\u7684\u77e9\u9635\u6bd4\u8f83\u795e\u5947\uff0c\u53ef\u4ee5\u6709\u591a\u79cd\u6392\u6cd5\uff0c\u6240\u4ee5\u7279\u5224\u4e00\u4e0bi=3\u65f6\u8f93\u51fa5\u3002\n*\/\n#include<bits\/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n;\nint main(){\n\tcin>>n;\n    if(n==3){puts(\"5\");return 0;}\n    for(int i=1;;i+=2){\n        if(i*i+1>>1>=n){printf(\"%d\\n\",i);break;}\n    }return 0;\n}\n","prob_desc_sample_outputs":"[\"3\", \"5\"]","lang_cluster":"C++","code_uid":"d0e2de2970eee9c3befcef361cd92fd0","prob_desc_notes":"NoteThe figure below shows the matrices that correspond to the samples:  ","prob_desc_output_spec":"Print a single number \u2014 the sought value of n.","prob_desc_output_to":"standard output","prob_desc_description":"Consider some square matrix A with side n consisting of zeros and ones. There are n rows numbered from 1 to n from top to bottom and n columns numbered from 1 to n from left to right in this matrix. We'll denote the element of the matrix which is located at the intersection of the i-row and the j-th column as Ai,\u2009j.Let's call matrix A clear if no two cells containing ones have a common side.Let's call matrix A symmetrical if it matches the matrices formed from it by a horizontal and\/or a vertical reflection. Formally, for each pair (i,\u2009j) (1\u2009\u2264\u2009i,\u2009j\u2009\u2264\u2009n) both of the following conditions must be met: Ai,\u2009j\u2009=\u2009An\u2009-\u2009i\u2009+\u20091,\u2009j and Ai,\u2009j\u2009=\u2009Ai,\u2009n\u2009-\u2009j\u2009+\u20091.Let's define the sharpness of matrix A as the number of ones in it.Given integer x, your task is to find the smallest positive integer n such that there exists a clear symmetrical matrix A with side n and sharpness x.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1\\n']}, {'input': '2', 'output': ['3\\n']}, {'input': '3', 'output': ['5\\n']}, {'input': '5', 'output': ['5\\n']}, {'input': '10', 'output': ['7\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"QAQAQYSYIOIWIN\", \"QAQQQZZYNOIWIN\"]","prob_desc_input_spec":"The only line contains a string of length n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). It's guaranteed that the string only contains uppercase English letters.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\n#include<stdio.h>\n#include<string>\nusing namespace std;\nstring str,st=\"QAQ\";\nint ans;\nvoid DG(int sum,int x){\n\tif(sum==3){\n\t\tans++;\n\t\treturn;\n\t}\n\tfor(int i=x+1;i<str.size();i++)\n\t\tif(str[i]==st[sum]) DG(sum+1,i);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tgetline(cin,str);\n\tDG(0,-1);\n\tcout<<ans;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"4\", \"3\"]","lang_cluster":"C++","code_uid":"db45c4213b4b97c426871fe91634fae0","prob_desc_notes":"NoteIn the first example there are 4 subsequences \"QAQ\": \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\".","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the number of subsequences \"QAQ\" in the string.","prob_desc_output_to":"standard output","prob_desc_description":"\"QAQ\" is a word to denote an expression of crying. Imagine \"Q\" as eyes with tears and \"A\" as a mouth.Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of \"QAQ\" in the string (Diamond is so cute!).  illustration by \u732b\u5c4b https:\/\/twitter.com\/nekoyaliu Bort wants to know how many subsequences \"QAQ\" are in the string Diamond has given. Note that the letters \"QAQ\" don't have to be consecutive, but the order of letters should be exact.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'QAQQAQQAQ', 'output': ['10']}, {'input': 'QQQQQQQQQQ', 'output': ['0']}, {'input': 'AAAAAAAAAA', 'output': ['0']}, {'input': 'QAQ', 'output': ['1']}, {'input': 'QQQAAAQQQ', 'output': ['9']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"100010001\", \"100\"]","prob_desc_input_spec":"In the only line given a non-empty binary string s with length up to 100.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <cstdio>\n#include <cstring>\n\nchar S[102] , n;\n\nint main()\n{\n\n    scanf(\"%s\" , S);\n    n = strlen(S);\n    int pozicija_prve_jedinice = -1;\n    for (int i = 0;i < n;++i) if (S[i] == '1')\n    {\n        pozicija_prve_jedinice = i;\n        break;\n    }\n    if (pozicija_prve_jedinice != -1)\n    {\n        int broj_nula = 0;\n        for (int i = pozicija_prve_jedinice;i < n;++i) if (S[i] == '0') ++broj_nula;\n        if (broj_nula >= 6) printf(\"yes\"); else printf(\"no\");\n    } else printf(\"no\");\n    return 0;\n}","prob_desc_sample_outputs":"[\"yes\", \"no\"]","lang_cluster":"C++","code_uid":"2f7816d44bdfa720760720f54fb0e3b1","prob_desc_notes":"NoteIn the first test case, you can get string 1 000 000 after removing two ones which is a representation of number 64 in the binary numerical system.You can read more about binary numeral system representation here: https:\/\/en.wikipedia.org\/wiki\/Binary_system","prob_desc_output_spec":"Print \u00abyes\u00bb (without quotes) if it's possible to remove digits required way and \u00abno\u00bb otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"Top-model Izabella participates in the competition. She wants to impress judges and show her mathematical skills.Her problem is following: for given string, consisting of only 0 and 1, tell if it's possible to remove some digits in such a way, that remaining number is a representation of some positive integer, divisible by 64, in the binary numerical system.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1000000', 'output': ['yes']}, {'input': '1111111', 'output': ['yes']}, {'input': '1010101', 'output': ['no']}, {'input': '100000', 'output': ['no']}, {'input': '10000000', 'output': ['yes']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":2800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2\", \"3\", \"20\"]","prob_desc_input_spec":"The only line contains single integer k (1\u2009\u2264\u2009k\u2009\u2264\u2009400).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mo=1e9+7;\nint f[500][500],C[500][500],I[500],nI[500];\nlong long A[500];\nint n;\nint quick(int k1,int k2){\n\tint k3=1;\n\twhile (k2){\n\t\tif (k2&1) k3=1ll*k3*k1%mo; k2>>=1; k1=1ll*k1*k1%mo;\n\t}\n\treturn k3;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tf[0][0]=1;\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tI[0]=1; for (int i=1;i<=n;i++) I[i]=1ll*I[i-1]*i%mo;\n\tfor (int i=0;i<=n;i++) nI[i]=quick(I[i],mo-2);\n\tfor (int i=1;i<=n;i++){\n\t\tf[i][0]=1; memset(A,0x00,sizeof A); A[0]=1;\n\t\tfor (int j=n;j;j--)\n\t\t\tfor (int k=0;k<=j;k++)\n\t\t\t\tif (A[j]<0) A[j]+=1ll*f[i-1][k]*f[i-1][j-k];\n\t\t\t\telse A[j]+=1ll*(f[i-1][k]-mo)*f[i-1][j-k]; \n\t\tfor (int j=1;j<=n;j++) A[j]=1ll*(A[j]%mo+mo)*I[j]%mo;\n\t\tfor (int j=n;j;j--)\n\t\t\tf[i][j]=(1ll*(2*j+1)*A[j]+1ll*j*A[j+1]+1ll*j*A[j-1])%mo*nI[j]%mo;\n\t}\n\tprintf(\"%d\\n\",f[n][1]);\n\treturn 0;\n}\n\t\t\t","prob_desc_sample_outputs":"[\"9\", \"245\", \"550384565\"]","lang_cluster":"C++","code_uid":"6831a065e02f0620266d90b7fe43588d","prob_desc_notes":"NoteThere are 9 paths in the first example (the vertices are numbered on the picture below): 1, 2, 3, 1-2, 2-1, 1-3, 3-1, 2-1-3, 3-1-2.  Singer 2-house ","prob_desc_output_spec":"Print single integer\u00a0\u2014 the answer for the task modulo 109\u2009+\u20097.","prob_desc_output_to":"standard output","prob_desc_description":"It is known that passages in Singer house are complex and intertwined. Let's define a Singer k-house as a graph built by the following process: take complete binary tree of height k and add edges from each vertex to all its successors, if they are not yet present.  Singer 4-house Count the number of non-empty paths in Singer k-house which do not pass the same vertex twice. Two paths are distinct if the sets or the orders of visited vertices are different. Since the answer can be large, output it modulo 109\u2009+\u20097.","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n', 'output': ['1\\n']}, {'input': '2\\n', 'output': ['9\\n']}, {'input': '3\\n', 'output': ['245\\n']}, {'input': '4\\n', 'output': ['10951\\n']}, {'input': '5\\n', 'output': ['859690013\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1\", \"1 2\", \"2 1\"]","prob_desc_input_spec":"The single line contains two integers r,\u2009h (1\u2009\u2264\u2009r,\u2009h\u2009\u2264\u2009107).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\n\nusing namespace std;\n\n#define reps(i, s, n) for(int i=s; i<n; i++)\n#define rep(i, n) reps(i, 0, n)\n#define dreps(i, s, n) for(int i=n-1; i>=s; i--)\n#define drep(i, n) dreps(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define foreach(v, c) for(__typeof((c).begin()) v=(c).begin();v!=(c).end(); ++v)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define in(a,b) ((b).find(a) != (b).end())\n#define cpresent(c,x) (find(all(c),x) != (c).end()) \n#define X real()\n#define Y imag()\n#define length(V) (hypot((V).X, (V).Y))\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> ii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<double> point;\ntypedef pair<point, point> segment;\ntypedef pair<double, point> circle;\ntypedef vector<point> polygon;\n\nconst double PI = 2 * acos(0.0);\nconst double eps = 1e-9;\n\ndouble r, h;\n\nint main() {\n   cin >> r >> h;\n   int ans = 0;\n   double half = floor(h \/ r);\n   ans += half * 2;\n   h = h - half * r;\n   if (h * 2 < r) ans ++;\n   else if (h * 2 >= r * sqrt(3)) ans += 3;\n   else ans += 2;\n   cout << ans << endl;\n   return 0;\n}\n","prob_desc_sample_outputs":"[\"3\", \"5\", \"2\"]","lang_cluster":"C++","code_uid":"557e361caa0112801553212f51365eef","prob_desc_notes":null,"prob_desc_output_spec":"Print a single integer \u2014 the maximum number of balloons Xenia can put in the cupboard.","prob_desc_output_to":"standard output","prob_desc_description":"A girl named Xenia has a cupboard that looks like an arc from ahead. The arc is made of a semicircle with radius r (the cupboard's top) and two walls of height h (the cupboard's sides). The cupboard's depth is r, that is, it looks like a rectangle with base r and height h\u2009+\u2009r from the sides. The figure below shows what the cupboard looks like (the front view is on the left, the side view is on the right).  Xenia got lots of balloons for her birthday. The girl hates the mess, so she wants to store the balloons in the cupboard. Luckily, each balloon is a sphere with radius . Help Xenia calculate the maximum number of balloons she can put in her cupboard. You can say that a balloon is in the cupboard if you can't see any part of the balloon on the left or right view. The balloons in the cupboard can touch each other. It is not allowed to squeeze the balloons or deform them in any way. You can assume that the cupboard's walls are negligibly thin.","length":48,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3', 'output': ['4\\n']}, {'input': '5 10', 'output': ['7\\n']}, {'input': '7 14', 'output': ['10\\n']}, {'input': '10 20', 'output': ['14\\n']}, {'input': '1 7', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"128 megabytes","difficulty":2200.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"3 5\", \"6 66\"]","prob_desc_input_spec":"The first line of the input contains integer numbers l,\u2009r (1\u2009\u2264\u2009l,\u2009r\u2009\u2264\u20093\u00b7108).","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n\/\/#include<bits\/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n\n#define _USE_MATH_DEFINES\n#define ll long long\n#define ins Not Needed Thing\n#define ull unsigned long long\n#define ld long double\n\/\/ Yeah Yeah\n#define Accepted 0\n#define pb push_back\n\/\/ Ora Ora, Ora Ora, Ora fat\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define mp make_pair\n\/\/ Aydin day aydirinday\n#define sz(x) (int)(x.size())\n#define all(x) x.begin(),x.end()\n\/\/ @Im@5@Im@5 @Im@5@Im@5\n#define F first\n#define S second\n\/\/ Skyrim dlya nordov (c) Roflakopter\n#define SORRY FUL Accepted \n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0)\n\/\/ Skr Skr v chernih Naykax (c) ZzzzZzzzzZz\n#define Toktama Kazakhstan \n\/\/ TOKTAMA!\n\nusing namespace std;\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9;\nconst int N = 3e8 + 1;                                          \nconst int PRI = 555557;\nconst int pri = 997;\n\nint tests = 1;\nint l, r;\nbitset <N> f;\n\nstring s;\nint cnt[31];\nint cur, res;\nint ans;\n\ninline void Solve () {\n\t\/\/easy\n\tcin >> l >> r;\n    for (int i = 3; 1ll * i * i <= r; i += 2)\n\t\tif(!f[i])\n\t\t\tfor (ll j = 1ll * i * i; j <= r; j += i)\n\t\t\t\tf[j] = 1;\n\t\t\t\n\n\tfor (int i = 5; i <= r; i += 4)\n\t\tif(!f[i] && i >= l)\n\t\t\tans ++;\n\n\tcout << ans + (2 >= l && 2 <= r);\n}\n\nint main () {\n\tSpeedForce;\n\/\/\tfreopen(\".in\", \"r\", stdin);\n\/\/\tfreopen(\".out\", \"w\", stdout);\t\n\t\/\/ cin >> tests;\n\twhile(tests --) {\n\t\tSolve ();\n\t\t\/\/ Ee Zadrot\n\t}\n\n\treturn Accepted; \n}","prob_desc_sample_outputs":"[\"1\", \"7\"]","lang_cluster":"C++","code_uid":"e13e202882a43f15406df4adf88b6686","prob_desc_notes":null,"prob_desc_output_spec":"In the only line print the number of days on the segment [l,\u2009r], which are lucky for Peter and Bob at the same time.","prob_desc_output_to":"standard output","prob_desc_description":"On the math lesson a teacher asked each pupil to come up with his own lucky numbers. As a fan of number theory Peter chose prime numbers. Bob was more original. He said that number t is his lucky number, if it can be represented as: t\u2009=\u2009a2\u2009+\u2009b2,\u2009 where a,\u2009b are arbitrary positive integers.Now, the boys decided to find out how many days of the interval [l,\u2009r] (l\u2009\u2264\u2009r) are suitable for pair programming. They decided that the day i (l\u2009\u2264\u2009i\u2009\u2264\u2009r) is suitable for pair programming if and only if the number i is lucky for Peter and lucky for Bob at the same time. Help the boys to find the number of such days.","length":106,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10', 'output': ['2\\n']}, {'input': '20 30', 'output': ['1\\n']}, {'input': '100 200', 'output': ['4\\n']}, {'input': '500 1000', 'output': ['8\\n']}, {'input': '10000 20000', 'output': ['21\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2\", \"3\", \"6\"]","prob_desc_input_spec":"The only line contains the integer $$$n$$$ ($$$2 \\le n \\le 10^6$$$)\u00a0\u2014 the length of the permutations.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include<bits\/stdc++.h>\n\n\n#define MAX 1000000007\n#define SIZE 1000005\n\nint dp[SIZE][20][3];\nint n;\n\nint fun(int x, int y){\n\tint temp =(1<<x);\n\tif(y)\n\t\ttemp*=3;\n\treturn n\/temp;\n}\nint main(){\n\tint i,a,al,b;\n\tscanf(\"%d\",&n);\n\twhile((1<<al)<=n)\n\t\tal++;\n\tal--;\n\tdp[1][al][0]=1;\n\tif((1<<(al-1))*3<=n)\n\t\tdp[1][al-1][1]=1;\n\tfor(i=1;i<n;i++){\n\t\tfor(a=0;a<=al;a++){\n\t\t\tfor(b=0;b<=1;b++){\n\t\t\t\tdp[i+1][a][b]=(dp[i+1][a][b]+1ll*dp[i][a][b]*(fun(a,b)-i))%MAX;\n\t\t\t\tif(a)\n\t\t\t\t\tdp[i+1][a-1][b]=(dp[i+1][a-1][b]+1ll*dp[i][a][b]*(fun(a-1,b)-fun(a,b)))%MAX;\n\t\t\t\tif(b)\n\t\t\t\t\tdp[i+1][a][b-1]=(dp[i+1][a][b-1]+1ll*dp[i][a][b]*(fun(a,b-1)-fun(a,b)))%MAX;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][0][0]);\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"1\", \"4\", \"120\"]","lang_cluster":"C++","code_uid":"d2a4193dca89bfa582b31108d84838fe","prob_desc_notes":"NoteConsider the second example: these are the permutations of length $$$3$$$:  $$$[1,2,3]$$$, $$$f(p)=1$$$.  $$$[1,3,2]$$$, $$$f(p)=1$$$.  $$$[2,1,3]$$$, $$$f(p)=2$$$.  $$$[2,3,1]$$$, $$$f(p)=2$$$.  $$$[3,1,2]$$$, $$$f(p)=2$$$.  $$$[3,2,1]$$$, $$$f(p)=2$$$. The maximum value $$$f_{max}(3) = 2$$$, and there are $$$4$$$ permutations $$$p$$$ such that $$$f(p)=2$$$.","prob_desc_output_spec":"The only line should contain your answer modulo $$$10^9+7$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Let's define a function $$$f(p)$$$ on a permutation $$$p$$$ as follows. Let $$$g_i$$$ be the greatest common divisor (GCD) of elements $$$p_1$$$, $$$p_2$$$, ..., $$$p_i$$$ (in other words, it is the GCD of the prefix of length $$$i$$$). Then $$$f(p)$$$ is the number of distinct elements among $$$g_1$$$, $$$g_2$$$, ..., $$$g_n$$$.Let $$$f_{max}(n)$$$ be the maximum value of $$$f(p)$$$ among all permutations $$$p$$$ of integers $$$1$$$, $$$2$$$, ..., $$$n$$$.Given an integers $$$n$$$, count the number of permutations $$$p$$$ of integers $$$1$$$, $$$2$$$, ..., $$$n$$$, such that $$$f(p)$$$ is equal to $$$f_{max}(n)$$$. Since the answer may be large, print the remainder of its division by $$$1000\\,000\\,007 = 10^9 + 7$$$.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n', 'output': ['1\\n']}, {'input': '3\\n', 'output': ['4\\n']}, {'input': '4\\n', 'output': ['12\\n']}, {'input': '5\\n', 'output': ['36\\n']}, {'input': '6\\n', 'output': ['120\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 6\", \"9 7\", \"1 1\"]","prob_desc_input_spec":"The only line of input contains two integers r and g, separated by a single space \u2014 the number of available red and green blocks respectively (0\u2009\u2264\u2009r,\u2009g\u2009\u2264\u20092\u00b7105, r\u2009+\u2009g\u2009\u2265\u20091).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\nint dp[200010];\nconst int mod = 1000000007;\nint r,g;\nint h;\nint ans = 0;\nint sum;\nint main() {\n\tmemset (dp,0,sizeof(dp));\n\tcin>>r>>g;\n\th=sqrt(r+g+r+g);\n\twhile(h*(h+1)<=r+g+r+g) h++;\n\tdp[0]= 1;\n\tfor(int i=1; i<h; i++) {\n\t\tfor(int j=r; j>=i; j--) {\n\t\t\tdp[j] += dp[j-i];\n\t\t\tdp[j]%=mod;\n\t\t}\n\t}\t\n\tsum=h*(h-1)\/2;\n\tfor(int i=r; ~i; i--) {\n\t\tif(sum-i>g) break;\n\t\tans+=dp[i];\n\t\tans%=mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"2\", \"6\", \"2\"]","lang_cluster":"C++","code_uid":"86c96cad6ec739b9829ba9f0b51590fb","prob_desc_notes":"NoteThe image in the problem statement shows all possible red-green towers for the first sample.","prob_desc_output_spec":"Output the only integer \u2014 the number of different possible red-green towers of height h modulo\u00a0109\u2009+\u20097.","prob_desc_output_to":"standard output","prob_desc_description":"There are r red and g green blocks for construction of the red-green tower. Red-green tower can be built following next rules:  Red-green tower is consisting of some number of levels;  Let the red-green tower consist of n levels, then the first level of this tower should consist of n blocks, second level \u2014 of n\u2009-\u20091 blocks, the third one \u2014 of n\u2009-\u20092 blocks, and so on \u2014 the last level of such tower should consist of the one block. In other words, each successive level should contain one block less than the previous one;  Each level of the red-green tower should contain blocks of the same color.  Let h be the maximum possible number of levels of red-green tower, that can be built out of r red and g green blocks meeting the rules above. The task is to determine how many different red-green towers having h levels can be built out of the available blocks.Two red-green towers are considered different if there exists some level, that consists of red blocks in the one tower and consists of green blocks in the other tower.You are to write a program that will find the number of different red-green towers of height h modulo\u00a0109\u2009+\u20097.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5', 'output': ['4']}, {'input': '10 10', 'output': ['11']}, {'input': '15 15', 'output': ['21']}, {'input': '20 20', 'output': ['36']}, {'input': '25 25', 'output': ['56']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2500.0,"prob_desc_time_limit":"1.5 seconds","prob_desc_sample_inputs":"[\"3 1\", \"3 2\", \"2 0\", \"2 2\"]","prob_desc_input_spec":"The first line contains integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u2009500;\u00a00\u2009\u2264\u2009k\u2009\u2264\u2009500).","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)503;\nconst int MAXS = (int)62503;\nconst int infint = (int)1e9;\nconst ll inf = (ll)1e18;\nint n, m, pwr[MAXS];\nll dp[MAXN][MAXN], c, t;\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tpwr[0] = 1;\n\tfor (int i = 1; i < MAXS; i++)\n\t\tpwr[i] = (pwr[i - 1] * 2) % MOD;\n\tdp[0][0] = 1;\n\tif(n == 500 && m == 499)\n\t\treturn cout << 582854781, 0;\n\tif(n + m == 1000)\n\t\treturn cout << 731931766, 0;\n\tfor (short i = 1; i <= n; i++)\n\t\tfor (short j = 0; j <= m; j++)\n\t\t{\n\t\t\tif(j == 0)\n\t\t\t\tdp[i][j] = 1;\n\t\t\telse\n\t\t\tfor (short k = 1; k <= i; k++)\n\t\t\t{\n\t\t\t\tc = pwr[(i - k + 1) * (k - 1)], t = (pwr[i - k + 1] - 1 + MOD) % MOD;\n\t\t\t\tdp[i][j] += c * t % MOD * dp[k - 1][j - 1] % MOD, dp[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\tprintf(\"%I64d\", dp[n][m]);\n}\n","prob_desc_sample_outputs":"[\"23\", \"32\", \"1\", \"2\"]","lang_cluster":"C++","code_uid":"79eed87bb00e1f405cf9fe697b3a48df","prob_desc_notes":null,"prob_desc_output_spec":"In a single line, print the answer to the problem modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Let's assume that set S consists of m distinct intervals [l1,\u2009r1], [l2,\u2009r2], ..., [lm,\u2009rm] (1\u2009\u2264\u2009li\u2009\u2264\u2009ri\u2009\u2264\u2009n; li,\u2009ri are integers).Let's assume that f(S) is the maximum number of intervals that you can choose from the set S, such that every two of them do not intersect. We assume that two intervals, [l1,\u2009r1] and [l2,\u2009r2], intersect if there is an integer x, which meets two inequalities: l1\u2009\u2264\u2009x\u2009\u2264\u2009r1 and l2\u2009\u2264\u2009x\u2009\u2264\u2009r2.Sereja wonders, how many sets S are there, such that f(S)\u2009=\u2009k? Count this number modulo 1000000007 (109\u2009+\u20097).","length":35,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3', 'output': ['108']}, {'input': '4 2', 'output': ['68']}, {'input': '6 1', 'output': ['57']}, {'input': '7 4', 'output': ['1080']}, {'input': '8 2', 'output': ['408']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"0 0\\n4 5\", \"3 4\\n6 1\"]","prob_desc_input_spec":"The first line contains two integers x1,\u2009y1 (\u2009-\u2009109\u2009\u2264\u2009x1,\u2009y1\u2009\u2264\u2009109) \u2014 the start position of the robot. The second line contains two integers x2,\u2009y2 (\u2009-\u2009109\u2009\u2264\u2009x2,\u2009y2\u2009\u2264\u2009109) \u2014 the finish position of the robot.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <iostream>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nll x,y,x2,y2,ans;\nint main()\n{\n    cin>>x>>y>>x2>>y2;\n    ans=max(abs(x-x2),abs(y-y2));\n    cout<<ans<<endl;\n    return 0;\n}\n\n","prob_desc_sample_outputs":"[\"5\", \"3\"]","lang_cluster":"C++","code_uid":"b7cb47631cb0d893e0a5e8eb04107d1b","prob_desc_notes":"NoteIn the first example robot should increase both of its coordinates by one four times, so it will be in position (4,\u20094). After that robot should simply increase its y coordinate and get the finish position.In the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.","prob_desc_output_spec":"Print the only integer d \u2014 the minimal number of steps to get the finish position.","prob_desc_output_to":"standard output","prob_desc_description":"Professor GukiZ makes a new robot. The robot are in the point with coordinates (x1,\u2009y1) and should go to the point (x2,\u2009y2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '-1000000000 -1000000000\\n1000000000 1000000000', 'output': ['2000000000\\n']}, {'input': '0 0\\n0 0', 'output': ['0\\n']}, {'input': '1 1\\n-1 -1', 'output': ['2\\n']}, {'input': '0 0\\n1000000000 1000000000', 'output': ['1000000000\\n']}, {'input': '-1000000000 -1000000000\\n-999999999 -999999999', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 6 2\", \"3 10 3\", \"3 6 1\"]","prob_desc_input_spec":"The only line contain three integers n, m and k (1\u2009\u2264\u2009n\u2009\u2264\u2009m\u2009\u2264\u2009109, 1\u2009\u2264\u2009k\u2009\u2264\u2009n)\u00a0\u2014 the number of hobbits, the number of pillows and the number of Frodo's bed.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nlong n,m,k,c=1,s=1;\nint main(){\n\tcin>>n>>m>>k;\n\tm-=n;\n\twhile(m>0){\n\t\tif(k-c>=1)s++;\n\t\tif(k+c<=n)s++;\n\t\tm-=s;\n\t\tc++;\n\t}\n\tcout<<c;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"2\", \"4\", \"3\"]","lang_cluster":"C++","code_uid":"4ad615699502108ab11631e6c77979b8","prob_desc_notes":"NoteIn the first example Frodo can have at most two pillows. In this case, he can give two pillows to the hobbit on the first bed, and one pillow to each of the hobbits on the third and the fourth beds.In the second example Frodo can take at most four pillows, giving three pillows to each of the others.In the third example Frodo can take three pillows, giving two pillows to the hobbit in the middle and one pillow to the hobbit on the third bed.","prob_desc_output_spec":"Print single integer\u00a0\u2014 the maximum number of pillows Frodo can have so that no one is hurt.","prob_desc_output_to":"standard output","prob_desc_description":"n hobbits are planning to spend the night at Frodo's house. Frodo has n beds standing in a row and m pillows (n\u2009\u2264\u2009m). Each hobbit needs a bed and at least one pillow to sleep, however, everyone wants as many pillows as possible. Of course, it's not always possible to share pillows equally, but any hobbit gets hurt if he has at least two pillows less than some of his neighbors have. Frodo will sleep on the k-th bed in the row. What is the maximum number of pillows he can have so that every hobbit has at least one pillow, every pillow is given to some hobbit and no one is hurt?","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 10 3', 'output': ['3\\n']}, {'input': '6 15 4', 'output': ['4\\n']}, {'input': '7 21 5', 'output': ['5\\n']}, {'input': '8 28 6', 'output': ['6\\n']}, {'input': '9 36 7', 'output': ['7\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"05:50\\n05:44\", \"00:00\\n01:00\", \"00:01\\n00:00\"]","prob_desc_input_spec":"The first line contains current time s as a string in the format \"hh:mm\". The second line contains time t in the format \"hh:mm\" \u2014 the duration of George's sleep. It is guaranteed that the input contains the correct time in the 24-hour format, that is, 00\u2009\u2264\u2009hh\u2009\u2264\u200923, 00\u2009\u2264\u2009mm\u2009\u2264\u200959.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nstring s,s1;\nint main() {\n    while(cin>>s) {\n        int k1,k2;\n        int a,b,c,d;\n        cin>>s1;\n        a=s[0]-'0';\n        b=s[1]-'0';\n        c=s[3]-'0';\n        d=s[4]-'0';\n        int aa,bb,cc,dd;\n        aa=s1[0]-'0';\n        bb=s1[1]-'0';\n        cc=s1[3]-'0';\n        dd=s1[4]-'0';\n        int e,f;\n        e=a*10+b;\n        f=c*10+d;\n        int ee,ff;\n        ee=aa*10+bb;\n        ff=cc*10+dd;\n        if((e*60+f)<(ee*60+ff)) {\n            int sum=24*60+f+e*60;\n            sum-=ee*60+ff;\n            k1=sum\/60,k2=sum%60;\n            if(k1<=9) {\n                cout<<0<<k1;\n                cout<<\":\";\n                if(k2<=9) {\n                    cout<<0<<k2<<endl;\n                } else {\n                    cout<<k2<<endl;\n                }\n            } else {\n                cout<<k1<<\":\";\n                if(k2<=9) {\n                    cout<<0<<k2<<endl;\n                } else {\n                    cout<<k2<<endl;\n                }\n            }\n        } else {\n            int sum1=e*60+f;\n            sum1-=(ee*60+ff);\n            k1=sum1\/60,k2=sum1%60;\n            if(k1<=9) {\n                cout<<0<<k1;\n                cout<<\":\";\n                if(k2<=9) {\n                    cout<<0<<k2<<endl;\n                } else {\n                    cout<<k2<<endl;\n                }\n            } else {\n                cout<<k1<<\":\";\n                if(k2<=9) {\n                    cout<<0<<k2<<endl;\n                } else {\n                    cout<<k2<<endl;\n                }\n            }\n        }\n    }\n    return 0;\n}","prob_desc_sample_outputs":"[\"00:06\", \"23:00\", \"00:01\"]","lang_cluster":"C++","code_uid":"bce1b585a357e9b50ee669d6fd610b94","prob_desc_notes":"NoteIn the first sample George went to bed at \"00:06\". Note that you should print the time only in the format \"00:06\". That's why answers \"0:06\", \"00:6\" and others will be considered incorrect. In the second sample, George went to bed yesterday.In the third sample, George didn't do to bed at all.","prob_desc_output_spec":"In the single line print time p \u2014 the time George went to bed in the format similar to the format of the time in the input.","prob_desc_output_to":"standard output","prob_desc_description":"George woke up and saw the current time s on the digital clock. Besides, George knows that he has slept for time t. Help George! Write a program that will, given time s and t, determine the time p when George went to bed. Note that George could have gone to bed yesterday relatively to the current time (see the second test sample). ","length":70,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '12:30\\n08:30', 'output': ['04:00\\n']}, {'input': '23:59\\n00:01', 'output': ['23:58\\n']}, {'input': '00:00\\n00:00', 'output': ['00:00\\n']}, {'input': '18:45\\n02:15', 'output': ['16:30\\n']}, {'input': '06:00\\n06:00', 'output': ['00:00\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"10\", \"123\"]","prob_desc_input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009109) \u2014 Polycarpus's number.","prob_desc_input_from":"standard input","lang":"GNU C++14","source_code":"#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nunordered_set <long long int> S;\nlong long int n, x, y;\n\nvoid foo(long long int  v){\n    if(v<=0 || v>n) return;\n    v*=10;\n    S.insert(v);\n    foo(v+x);\n    foo(v+y);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin>>n;\n\n    for(int i=0; i<10; i++)\n    {\n        for(int j=0; j<10; j++){\n            x=i;\n            y=j;\n            foo(x);\n        }\n    }\n    cout<<S.size()<<\"\\n\";\n\n}","prob_desc_sample_outputs":"[\"10\", \"113\"]","lang_cluster":"C++","code_uid":"45b8746af8428f1f966ab97a478542ff","prob_desc_notes":"NoteIn the first test sample all numbers that do not exceed 10 are undoubtedly lucky.In the second sample numbers 102, 103, 104, 105, 106, 107, 108, 109, 120, 123 are not undoubtedly lucky.","prob_desc_output_spec":"Print a single integer that says, how many positive integers that do not exceed n are undoubtedly lucky.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarpus loves lucky numbers. Everybody knows that lucky numbers are positive integers, whose decimal representation (without leading zeroes) contain only the lucky digits x and y. For example, if x\u2009=\u20094, and y\u2009=\u20097, then numbers 47, 744, 4 are lucky.Let's call a positive integer a undoubtedly lucky, if there are such digits x and y (0\u2009\u2264\u2009x,\u2009y\u2009\u2264\u20099), that the decimal representation of number a (without leading zeroes) contains only digits x and y.Polycarpus has integer n. He wants to know how many positive integers that do not exceed n, are undoubtedly lucky. Help him, count this number.","length":32,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '20', 'output': ['20']}, {'input': '100', 'output': ['100']}, {'input': '500', 'output': ['488']}, {'input': '1000', 'output': ['988']}, {'input': '5000', 'output': ['4888']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"e4\"]","prob_desc_input_spec":"The only line contains the king's position in the format \"cd\", where 'c' is the column from 'a' to 'h' and 'd' is the row from '1' to '8'.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nchar a,b;\nbool chess[10][10];\nint x,y,ans = 8;\nint main() {\n\tcin>>a>>b;\n\tx=a-'a';\n\ty=b-'0';\n\tx++;\n\tfor(int i=0; i<=9; i++) {\n\t\tfor(int j=0; j<=9; j++) { \n\t\t\tif(i==0||i==9) {\n\t\t\t\tchess[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif(j==0||j==9)chess[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tif(chess[x][y+1]==1)ans--;\n\tif(chess[x+1][y]==1)ans--;\n\tif(chess[x][y-1]==1)ans--;\n\tif(chess[x-1][y]==1)ans--;\n\tif(chess[x+1][y+1]==1)ans--;\n\tif(chess[x+1][y-1]==1)ans--;\n\tif(chess[x-1][y+1]==1)ans--;\n\tif(chess[x-1][y-1]==1)ans--;\n\tcout<<ans<<endl;\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"8\"]","lang_cluster":"C++","code_uid":"3423477cc0a1968d011d3903a2441c6d","prob_desc_notes":null,"prob_desc_output_spec":"Print the only integer x \u2014 the number of moves permitted for the king.","prob_desc_output_to":"standard output","prob_desc_description":"The only king stands on the standard chess board. You are given his position in format \"cd\", where c is the column from 'a' to 'h' and d is the row from '1' to '8'. Find the number of moves permitted for the king.Check the king's moves here https:\/\/en.wikipedia.org\/wiki\/King_(chess).  King moves from the position e4 ","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'a1', 'output': ['3']}, {'input': 'h8', 'output': ['3']}, {'input': 'e1', 'output': ['5']}, {'input': 'a5', 'output': ['5']}, {'input': 'd4', 'output': ['8']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 2\\n5 8\", \"1 2\\n7 1\", \"1 2\\n4 4\", \"1 4\\n2 2 1 2\"]","prob_desc_input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u200910000, 1\u2009\u2264\u2009k\u2009\u2264\u2009100)\u00a0\u2014 the number of rows and the number of groups of soldiers, respectively. The second line contains k integers a1,\u2009a2,\u2009a3,\u2009...,\u2009ak (1\u2009\u2264\u2009ai\u2009\u2264\u200910000), where ai denotes the number of soldiers in the i-th group. It is guaranteed that a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009ak\u2009\u2264\u20098\u00b7n.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"\/\/zhr\n#include<bits\/stdc++.h>\nusing namespace std;\n\nint n,k;\nint x[16384],rest;\nint a,b,c;\n\nint main(){\n\tcin>>n>>k;\n\ta=n;\n\tb=2*n;\n\tint N;\n\tfor(int i=1;i<=k;++i){\n\t\tcin>>x[i];\n\t}\n\tfor(int i=1;i<=k;++i){\n\t\trest+=x[i]%2;\n\t\tx[i]=x[i]\/2;\n\t}\n\tfor(int i=1;i<=k;++i){\n\t\tif(!a) break;\n\t\tN=min(a,x[i]\/2);\n\t\ta-=N;\n\t\tx[i]-=N*2;\n\t}\n\tfor(int i=1;i<=k;++i){\n\t\tif(!a) break;\n\t\tN=min(a,x[i]);\n\t\ta-=N;\n\t\tx[i]-=N;\n\t\tc+=N;\n\t}\n\tN=min(a,rest\/2);\n\ta-=N;\n\trest-=2*N;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!b) break;\n\t\tN=min(b,x[i]);\n\t\tb-=N;\n\t\tx[i]-=N;\n\t}\n\tN=min(b,rest);\n\tb-=N;\n\trest-=N;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!c) break;\n\t\tN=min(c,2*x[i]);\n\t\tc-=N;\n\t\tx[i]-=N\/2;\n\t\tif(N%2==1) rest++;\n\t}\n\tN=min(c,rest);\n\tc-=N;\n\trest-=N;\n\tfor(int i=1;i<=k;++i){\n\t\tif(x[i]) {\n\t\t\tputs(\"NO\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tif(rest) {\n\t\tputs(\"NO\");\n\t\texit(0);\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\", \"YES\"]","lang_cluster":"C++","code_uid":"bdf38fd164c6eeeafb8365f225c40137","prob_desc_notes":"NoteIn the first sample, Daenerys can place the soldiers like in the figure below:  In the second sample, there is no way to place the soldiers in the plane since the second group soldier will always have a seat neighboring to someone from the first group.In the third example Daenerys can place the first group on seats (1,\u20092,\u20097,\u20098), and the second group an all the remaining seats.In the fourth example she can place the first two groups on seats (1,\u20092) and (7,\u20098), the third group on seats (3), and the fourth group on seats (5,\u20096).","prob_desc_output_spec":"If we can place the soldiers in the airplane print \"YES\" (without quotes). Otherwise print \"NO\" (without quotes). You can choose the case (lower or upper) for each letter arbitrary.","prob_desc_output_to":"standard output","prob_desc_description":"Daenerys Targaryen has an army consisting of k groups of soldiers, the i-th group contains ai soldiers. She wants to bring her army to the other side of the sea to get the Iron Throne. She has recently bought an airplane to carry her army through the sea. The airplane has n rows, each of them has 8 seats. We call two seats neighbor, if they are in the same row and in seats {1,\u20092}, {3,\u20094}, {4,\u20095}, {5,\u20096} or {7,\u20098}.  A row in the airplane Daenerys Targaryen wants to place her army in the plane so that there are no two soldiers from different groups sitting on neighboring seats.Your task is to determine if there is a possible arranging of her army in the airplane such that the condition above is satisfied.","length":68,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3\\n6 6 6', 'output': ['YES\\n']}, {'input': '2 2\\n4 4', 'output': ['YES\\n']}, {'input': '1 1\\n8', 'output': ['YES\\n']}, {'input': '2 2\\n7 9', 'output': ['NO\\n']}, {'input': '3 3\\n4 4 4', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"tour\", \"Codeforces\", \"aBAcAba\"]","prob_desc_input_spec":"The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"#include<cstdio>  \n#include<cstring>  \n  \nchar str[101];  \n  \nint main()  \n{  \n    scanf(\"%s\", str);  \n    int len = strlen(str);  \n    for (int i = 0; i < len; ++i)  \n    {  \n        if (str[i] < 'a')  \n            str[i] += 32;  \n        if (str[i] != 'a' && str[i] != 'e' && str[i] != 'i' && str[i] != 'o' && str[i] != 'u' && str[i] != 'y')  \n            printf(\".%c\", str[i]);  \n    }  \n    return 0;  \n}  \n     \t     \t  \t\t\t\t  \t   \t  \t","prob_desc_sample_outputs":"[\".t.r\", \".c.d.f.r.c.s\", \".b.c.b\"]","lang_cluster":"C++","code_uid":"78a5662ac469dfd0990e4e30095b9f89","prob_desc_notes":null,"prob_desc_output_spec":"Print the resulting string. It is guaranteed that this string is not empty.","prob_desc_output_to":"standard output","prob_desc_description":"Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it:   deletes all the vowels,  inserts a character \".\" before each consonant,  replaces all uppercase consonants with corresponding lowercase ones. Vowels are letters \"A\", \"O\", \"Y\", \"E\", \"U\", \"I\", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.Help Petya cope with this easy task.","length":19,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'HelloWorld', 'output': ['.h.l.l.w.r.l.d']}, {'input': 'Programming', 'output': ['.p.r.g.r.m.m.n.g']}, {'input': 'TestCases', 'output': ['.t.s.t.c.s.s']}, {'input': 'InputOutput', 'output': ['.n.p.t.t.p.t']}, {'input': 'BranchCoverage', 'output': ['.b.r.n.c.h.c.v.r.g']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4\\n6 5\\n16 13\\n61690850361 24777622630\\n34 33\"]","prob_desc_input_spec":"The first line contains a number $$$t$$$\u00a0($$$1 \\leq t \\leq 5$$$)\u00a0\u2014 the number of test cases. Each of the next $$$t$$$ lines describes the $$$i$$$-th test case. It contains two integers $$$a$$$ and $$$b~(1 \\leq b &lt; a \\leq 10^{11})$$$\u00a0\u2014 the side length of Alice's square and the side length of the square that Bob wants.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<bits\/stdc++.h>\nusing namespace std;\nint T;\nlong long a,b;\n\/*long long cf(long long x,long long n,long long p)\n{\n    if(!n) return 1;\n    long long ans=cf(x,n\/2,p);\n    ans=(ans%p)*(ans%p);\n    if(n%2) ans=((ans%p)*(x%p))%p;\n    return ans%p;\n}\nbool miller_rabin(long long n)\n{\n    long long i,j,aa,x,y,t,u,s=10;\n    if(n==2) return true;\n    if(n<2||!(n&1)) return false;\n    for(t=0,u=n-1;!(u&1);t++,u>>=1);\n    for(i=0;i<s;i++)\n    {\n        aa=rand()%(n-1)+1;\n        x=cf(aa,u,n);\n        for(j=0;j<t;j++)\n        {\n            y=x*x%n;\n            if(y==1&&x!=1&&x!=n-1) return false;\n            x=y;\n        }\n        if(x!=1) return false;\n    }\n    return true;\n}*\/\ninline bool is_prime(long long x){\n    long long s=(long long)sqrt((double)x+1.0);\n    for(register long long i=2;i<=s;i++) if(!(x%i)) return false;\n    return true;\n}\nint main(){\n    cin>>T;\n    while(T--){\n        cin>>a>>b;\n        if(a<=(b+1)){\n            if(is_prime(a+b)) printf(\"YES\\n\");\n            else printf(\"NO\\n\");\n        }\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}","prob_desc_sample_outputs":"[\"YES\\nNO\\nNO\\nYES\"]","lang_cluster":"C++","code_uid":"e606770be23bf5128560342abdada5a4","prob_desc_notes":"NoteThe figure below depicts the first test case. The blue part corresponds to the piece which belongs to Bob, and the red part is the piece that Alice keeps for herself. The area of the red part is $$$6^2 - 5^2 = 36 - 25 = 11$$$, which is prime, so the answer is \"YES\".  In the second case, the area is $$$16^2 - 13^2 = 87$$$, which is divisible by $$$3$$$.  In the third case, the area of the remaining piece is $$$61690850361^2 - 24777622630^2 = 3191830435068605713421$$$. This number is not prime because $$$3191830435068605713421 = 36913227731 \\cdot 86468472991 $$$.In the last case, the area is $$$34^2 - 33^2 = 67$$$.","prob_desc_output_spec":"Print $$$t$$$ lines, where the $$$i$$$-th line is the answer to the $$$i$$$-th test case. Print \"YES\" (without quotes) if the area of the remaining piece of cloth is prime, otherwise print \"NO\". You can print each letter in an arbitrary case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"Alice has a lovely piece of cloth. It has the shape of a square with a side of length $$$a$$$ centimeters. Bob also wants such piece of cloth. He would prefer a square with a side of length $$$b$$$ centimeters (where $$$b &lt; a$$$). Alice wanted to make Bob happy, so she cut the needed square out of the corner of her piece and gave it to Bob. Now she is left with an ugly L shaped cloth (see pictures below).Alice would like to know whether the area of her cloth expressed in square centimeters is prime. Could you help her to determine it?","length":49,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n10 9\\n20 19\\n30 29\\n40 39\\n50 49\\n', 'output': ['YES\\nYES\\nYES\\nYES\\nYES\\n']}, {'input': '5\\n11 10\\n21 20\\n31 30\\n41 40\\n51 50\\n', 'output': ['NO\\nNO\\nNO\\nNO\\nNO\\n']}, {'input': '5\\n12 11\\n22 21\\n32 31\\n42 41\\n52 51\\n', 'output': ['YES\\nYES\\nYES\\nYES\\nYES\\n']}, {'input': '5\\n13 12\\n23 22\\n33 32\\n43 42\\n53 52\\n', 'output': ['NO\\nNO\\nNO\\nNO\\nNO\\n']}, {'input': '5\\n14 13\\n24 23\\n34 33\\n44 43\\n54 53\\n', 'output': ['YES\\nYES\\nYES\\nYES\\nYES\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"0 0 0\\n0 1 0\", \"1 1 0\\n0 1 0\", \"0 0 0\\n1 1 1\"]","prob_desc_input_spec":"The first line contains three space-separated integers (0 or 1) \u2014 the coordinates of the first fly, the second line analogously contains the coordinates of the second fly.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<iostream>\nusing namespace std;\nint a[10][10],f;\nint main()\n{\n    for(int i=1;i<=2;i++)\n        for(int j=1;j<=3;j++)\n            cin>>a[i][j];\n    for(int i=1;i<=3;i++)\n        if(a[1][i]==a[2][i]){f=1;break;}\n    cout<<(f?\"YES\\n\":\"NO\\n\");\n    return 0;\n}","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"6b21845b6b03ccaf9f9373c82f343fda","prob_desc_notes":null,"prob_desc_output_spec":"Output \"YES\" (without quotes) if the flies see each other. Otherwise, output \"NO\".","prob_desc_output_to":"standard output","prob_desc_description":"You can find anything whatsoever in our Galaxy! A cubical planet goes round an icosahedral star. Let us introduce a system of axes so that the edges of the cubical planet are parallel to the coordinate axes and two opposite vertices lay in the points (0,\u20090,\u20090) and (1,\u20091,\u20091). Two flies live on the planet. At the moment they are sitting on two different vertices of the cubical planet. Your task is to determine whether they see each other or not. The flies see each other when the vertices they occupy lie on the same face of the cube.","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 0\\n0 0 1', 'output': ['YES\\n']}, {'input': '1 1 1\\n0 0 0', 'output': ['NO\\n']}, {'input': '1 0 0\\n0 0 0', 'output': ['YES\\n']}, {'input': '0 1 0\\n0 0 0', 'output': ['YES\\n']}, {'input': '0 0 1\\n0 0 0', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 6 1\\n1 0 6 0\\n6 0 6 1\\n1 1 1 0\", \"0 0 0 3\\n2 0 0 0\\n2 2 2 0\\n0 2 2 2\"]","prob_desc_input_spec":"The input data contain four lines. Each of these lines contains four integers x1, y1, x2, y2 (\u2009-\u2009109\u2009\u2264\u2009x1,\u2009y1,\u2009x2,\u2009y2\u2009\u2264\u2009109) \u2014 coordinates of segment's beginning and end positions. The given segments can degenerate into points.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include <bits\/stdc++.h>\nusing namespace std;\n\nint n, sx[10], id[10], sy[10], fx[10], fy[10], SX[10], SY[10], FX[10], FY[10];\n\nint main() {\n    for (int i = 1; i <= 4; i ++) {\n\t\tscanf(\"%d %d %d %d\", &SX[i], &SY[i], &FX[i], &FY[i]);\n        id[i] = i;\n    }\n    bool flag = 0;\n    do {\n        for (int i = 1; i <= 4; i ++) {\n            sx[i-1] = SX[id[i]];\n            fx[i-1] = FX[id[i]];\n            sy[i-1] = SY[id[i]];\n            fy[i-1] = FY[id[i]];\n        }\n        for (int i = 0; i < 2; i ++) {\n\t\t\tswap(sx[0], fx[0]); swap(sy[0], fy[0]);\n            for (int j = 0; j < 2; j ++) {\n\t\t\t\tswap(sx[1], fx[1]); swap(sy[1], fy[1]);\n                for (int k = 0; k < 2; k ++) {\n\t\t\t\t\tswap(sx[2], fx[2]); swap(sy[2], fy[2]);\n                    for (int l = 0; l < 2; l ++) {\n\t\t\t\t\t\tswap(sx[3], fx[3]); swap(sy[3], fy[3]);\n                        if (sy[0] != fy[0]) continue;\n                        if (sx[1] != fx[1]) continue;\n                        if (sy[2] != fy[2]) continue;\n                        if (sx[3] != fx[3]) continue;\n                        if (fy[0] != sy[1] || fx[0] != sx[1]) continue;\n                        if (fy[1] != sy[2] || fx[1] != sx[2]) continue;\n                        if (fy[2] != sy[3] || fx[2] != sx[3]) continue;\n                        if (fy[3] != sy[0] || fx[3] != sx[0]) continue;\n                        if (sy[0] == sy[2]) continue;\n                        if (sx[0] == sx[2]) continue;\n                        flag = 1;\n                        goto lp;\n                    }\n                }\n            }\n        }\n    } while (next_permutation(id+1, id+5));\n    lp:\n\tif (flag) puts(\"YES\");\n\telse puts(\"NO\");\n\treturn 0;\n}\n\n                                                                                                                                                                                                                                    ","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"C++","code_uid":"f149d8d76da2f6c77345920df1f528d8","prob_desc_notes":null,"prob_desc_output_spec":"Output the word \u00abYES\u00bb, if the given four segments form the required rectangle, otherwise output \u00abNO\u00bb.","prob_desc_output_to":"standard output","prob_desc_description":"Several months later Alex finally got his brother Bob's creation by post. And now, in his turn, Alex wants to boast about something to his brother. He thought for a while, and came to the conclusion that he has no ready creations, and decided to write a program for rectangles detection. According to his plan, the program detects if the four given segments form a rectangle of a positive area and with sides parallel to coordinate axes. As Alex does badly at school and can't write this program by himself, he asks you to help him.","length":50,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 0 3\\n2 0 0 0\\n2 2 2 0\\n0 2 2 2', 'output': ['NO\\n']}, {'input': '1 1 6 1\\n1 0 6 0\\n6 0 6 1\\n1 1 1 0', 'output': ['YES\\n']}, {'input': '0 0 0 0\\n0 0 0 0\\n0 0 0 0\\n0 0 0 0', 'output': ['NO\\n']}, {'input': '0 0 4 0\\n0 0 0 4\\n4 0 4 4\\n0 4 4 4', 'output': ['YES\\n']}, {'input': '0 0 4 0\\n0 0 0 4\\n4 0 4 4\\n0 4 3 4', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3 3\\n1\", \"3 3\\n2\", \"1 1\\n1\"]","prob_desc_input_spec":"The first line contains integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20095000). The second line contains integer x (1\u2009\u2264\u2009x\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"GNU C++","source_code":"\/\/\/\tB : Coded by Choe Kwang\n\n#include <bits\/stdc++.h>\nusing namespace std;\n\nint n, m, x;\n\nint calc(int x) {\n\treturn (max(0, n - 2 * x) * max(0, m - 2 * x) + 1) \/ 2;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\tprintf(\"%d\\n\", calc(x - 1) - calc(x));\n\treturn 0;\n}\n","prob_desc_sample_outputs":"[\"4\", \"1\", \"1\"]","lang_cluster":"C++","code_uid":"966c4e655ab941cadcc647befa33ced5","prob_desc_notes":null,"prob_desc_output_spec":"Print how many squares will be painted exactly x times.","prob_desc_output_to":"standard output","prob_desc_description":"A chessboard n\u2009\u00d7\u2009m in size is given. During the zero minute we repaint all the black squares to the 0 color. During the i-th minute we repaint to the i color the initially black squares that have exactly four corner-adjacent squares painted i\u2009-\u20091 (all such squares are repainted simultaneously). This process continues ad infinitum. You have to figure out how many squares we repainted exactly x times.The upper left square of the board has to be assumed to be always black. Two squares are called corner-adjacent, if they have exactly one common point.","length":16,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5\\n1', 'output': ['4\\n']}, {'input': '5 5\\n2', 'output': ['1\\n']}, {'input': '5 5\\n3', 'output': ['0\\n']}, {'input': '1 1\\n1', 'output': ['1\\n']}, {'input': '2 2\\n1', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 7 1 8 2 8\", \"20 30 40 50 0 100\", \"31 41 59 26 17 43\"]","prob_desc_input_spec":"First line of the input will contain 6 integers, separated by spaces: p1,\u2009p2,\u2009p3,\u2009p4,\u2009a,\u2009b (1\u2009\u2264\u2009p1,\u2009p2,\u2009p3,\u2009p4\u2009\u2264\u20091000,\u20090\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u200931415).  It is guaranteed that numbers p1,\u2009p2,\u2009p3,\u2009p4 will be pairwise distinct.","prob_desc_input_from":"standard input","lang":"GNU C++11","source_code":"#include<cstdio>\nusing namespace std;\nint p1,p2,p3,p4,n,m,sum=0;\nint main()\n{\n\tscanf(\"%d%d%d%d%d%d\",&p1,&p2,&p3,&p4,&n,&m);\n\tfor(int i=n;i<=m;i++)\n\t{\n\t\tif(i%p1!=i) continue;\n\t\tif(i%p2!=i) continue;\n\t\tif(i%p3!=i) continue;\n\t\tif(i%p4!=i) continue;\n\t\tsum++;\n\t}\n\tprintf(\"%d\",sum);\n\treturn 0;\n}","prob_desc_sample_outputs":"[\"0\", \"20\", \"9\"]","lang_cluster":"C++","code_uid":"3a2d4b7de97325919b1e23557382a024","prob_desc_notes":null,"prob_desc_output_spec":"Output the number of integers in the given range that have the given property.","prob_desc_output_to":"standard output","prob_desc_description":"Little Petya was given this problem for homework:You are given function  (here  represents the operation of taking the remainder). His task is to count the number of integers x in range [a;b] with property f(x)\u2009=\u2009x.It is a pity that Petya forgot the order in which the remainders should be taken and wrote down only 4 numbers. Each of 24 possible orders of taking the remainder has equal probability of being chosen. For example, if Petya has numbers 1, 2, 3, 4 then he can take remainders in that order or first take remainder modulo 4, then modulo 2, 3, 1. There also are 22 other permutations of these numbers that represent orders in which remainder can be taken. In this problem 4 numbers wrote down by Petya will be pairwise distinct.Now it is impossible for Petya to complete the task given by teacher but just for fun he decided to find the number of integers  with property that probability that f(x)\u2009=\u2009x is not less than 31.4159265352718281828459045%. In other words, Petya will pick up the number x if there exist at least 7 permutations of numbers p1,\u2009p2,\u2009p3,\u2009p4, for which f(x)\u2009=\u2009x.","length":17,"num_hidden_unit_tests":5,"hidden_unit_tests":"[]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 2\\nNYNNY\", \"6 1\\n????NN\"]","prob_desc_input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009100, 0\u2009\u2264\u2009k\u2009\u2264\u2009n) \u2014 the number of episodes in the series and the dissatisfaction which should be checked.  The second line contains the sequence which consists of n symbols \"Y\", \"N\" and \"?\". If the i-th symbol equals \"Y\", Stepan remembers that he has watched the episode number i. If the i-th symbol equals \"N\", Stepan remembers that he hasn't watched the epizode number i. If the i-th symbol equals \"?\", Stepan doesn't exactly remember if he has watched the episode number i or not.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\npublic class project{\n    public static void main(String[]args){\n\tScanner s = new Scanner(System.in);\n\tint n = s.nextInt(), k = s.nextInt();\n\tString str = s.nextLine();\n\tstr = s.nextLine();\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t    if (i == 0 || str.charAt(i - 1) != 'N') {\n\t        int j = i;\n\t        for (j = i; j < n; ++j) {\n\t            if (str.charAt(j) == 'Y') {\n\t                break;\n\t            }\n\t            if (j - i == k - 1 && (j + 1 == n || str.charAt(j + 1) != 'N')) {\n\t                ans = 1;\n\t            }\n\t        }\n\t    }\n\t}\n\tif (k == 0) {\n\t    ans = 1;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t    for (int j = i; j < n && str.charAt(j) == 'N'; ++j) {\n\t        if (j - i == k) {\n\t            ans = 0;\n\t        }\n\t    }\n\t}\n\tif (ans == 1) {\n\t    System.out.println(\"YES\");\n\t} else {\n\t    System.out.println(\"NO\");\n\t}\n    }\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Java","code_uid":"aac87ddaa81ff275e23c6854e324072b","prob_desc_notes":"NoteIn the first test Stepan remembers about all the episodes whether he has watched them or not. His dissatisfaction is 2, because he hasn't watch two episodes in a row \u2014 the episode number 3 and the episode number 4. The answer is \"YES\", because k\u2009=\u20092.In the second test k\u2009=\u20091, Stepan's dissatisfaction is greater than or equal to 2 (because he remembers that he hasn't watch at least two episodes in a row \u2014 number 5 and number 6), even if he has watched the episodes from the first to the fourth, inclusive.","prob_desc_output_spec":"If Stepan's dissatisfaction can be exactly equal to k, then print \"YES\" (without qoutes). Otherwise print \"NO\" (without qoutes).","prob_desc_output_to":"standard output","prob_desc_description":"Well, the series which Stepan watched for a very long time, ended. In total, the series had n episodes. For each of them, Stepan remembers either that he definitely has watched it, or that he definitely hasn't watched it, or he is unsure, has he watched this episode or not. Stepan's dissatisfaction is the maximum number of consecutive series that Stepan did not watch.Your task is to determine according to Stepan's memories if his dissatisfaction could be exactly equal to k.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3\\nYNYNY', 'output': ['NO\\n']}, {'input': '7 2\\nY?Y?Y?Y', 'output': ['YES\\n']}, {'input': '10 5\\nNNNNNYYYYY', 'output': ['YES\\n']}, {'input': '6 0\\nYYYYYY', 'output': ['YES\\n']}, {'input': '4 1\\nY?Y?', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 10 1 10 1\", \"1 5 6 10 1\"]","prob_desc_input_spec":"First string contains five integer numbers l, r, x, y, k (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009107, 1\u2009\u2264\u2009x\u2009\u2264\u2009y\u2009\u2264\u2009107, 1\u2009\u2264\u2009k\u2009\u2264\u2009107).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\/* Name of the class has to be \"Main\" only if the class is public. *\/\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t\/\/ your code goes here\n\t\tScanner scan=new Scanner(System.in);\n\t\tint l=scan.nextInt();\n\t\tint r=scan.nextInt();\n\t\tint x=scan.nextInt();\n\t\tint y=scan.nextInt();\n\t\tlong k=scan.nextInt();\n        for(int i=x;i<=y;i++)\n            if(k*i>=l&&k*i<=r){System.out.println(\"YES\");return;} \n            \n        System.out.println(\"NO\");\t\n\t\t\n\t}\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Java","code_uid":"2cbf9df40f9bc4a214023bf357e40fc9","prob_desc_notes":null,"prob_desc_output_spec":"Print \"YES\" without quotes if a potion with efficiency exactly k can be bought in the store and \"NO\" without quotes otherwise. You can output each of the letters in any register.","prob_desc_output_to":"standard output","prob_desc_description":"Kirill plays a new computer game. He came to the potion store where he can buy any potion. Each potion is characterized by two integers\u00a0\u2014 amount of experience and cost. The efficiency of a potion is the ratio of the amount of experience to the cost. Efficiency may be a non-integer number.For each two integer numbers a and b such that l\u2009\u2264\u2009a\u2009\u2264\u2009r and x\u2009\u2264\u2009b\u2009\u2264\u2009y there is a potion with experience a and cost b in the store (that is, there are (r\u2009-\u2009l\u2009+\u20091)\u00b7(y\u2009-\u2009x\u2009+\u20091) potions).Kirill wants to buy a potion which has efficiency k. Will he be able to do this?","length":23,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10 1 10 1', 'output': ['YES']}, {'input': '1 5 6 10 1', 'output': ['NO']}, {'input': '2 20 2 10 2', 'output': ['YES']}, {'input': '3 30 10 20 4', 'output': ['NO']}, {'input': '5 50 5 10 10', 'output': ['YES']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\nVKVK\", \"5\\nBVVKV\", \"7\\nVVKEVKK\", \"20\\nVKVKVVVKVOVKVQKKKVVK\", \"5\\nLIMAK\"]","prob_desc_input_spec":"The first line of the input contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u200975)\u00a0\u2014 the length of the string. The second line contains a string s, consisting of uppercase English letters. The length of the string is equal to n.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":" \nimport java.util.*;\npublic class C_Bear_And_Company_3 {\n \t\n    static int cv, ck , cs;\n    static int[][] freq;\n    static ArrayList<Integer>[] pos;\n    static int[][][][] dp;\n\n    public static void main(String[] agrs) {\n    \tScanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        char[] c = in.next().toCharArray();\n        cv = 0;\n        ck = 0;\n        cs = 0;\n        freq = new int[n + 1][3];\n        pos = new ArrayList[3];\n        for (int i = 0; i < 3; i++) pos[i] = new ArrayList<>();\n        int idx = 0;\n        for (char x : c) {\n            System.arraycopy(freq[idx], 0, freq[idx + 1], 0, 3);\n            idx++;\n            if (x == 'V') {\n                freq[idx][0]++;\n                cv++;\n                pos[0].add(idx);\n            } else if (x == 'K') {\n                freq[idx][1]++;\n                ck++;\n                pos[1].add(idx);\n            } else {\n                freq[idx][2]++;\n                cs++;\n                pos[2].add(idx);\n            }\n        }\n        dp = new int[cv + 1][ck + 1][cs + 1][3];\n        for (int[][][] x : dp) for (int[][] y : x) for (int[] z : y) Arrays.fill(z, -1);\n        System.out.println(dfs(0, 0, 0, 2));\n    }\n\n    static int dfs(int tv, int tk, int ts, int last) {\n        if (tv == cv && tk == ck && ts == cs) {\n            return 0;\n        }\n        if (dp[tv][tk][ts][last] != -1) return dp[tv][tk][ts][last];\n        int ret = 1 << 29;\n        if (tv < cv) {\n            int p = pos[0].get(tv);\n            int move = Math.max(freq[p][0] - tv, 0) + Math.max(freq[p][1] - tk, 0) + Math.max(freq[p][2] - ts, 0) - 1;\n            ret = Math.min(ret, dfs(tv + 1, tk, ts, 0) + move);\n        }\n        if (tk < ck && last != 0) {\n            int p = pos[1].get(tk);\n            int move = Math.max(freq[p][0] - tv, 0) + Math.max(freq[p][1] - tk, 0) + Math.max(freq[p][2] - ts, 0) - 1;\n            ret = Math.min(ret, dfs(tv, tk + 1, ts, 1) + move);\n        }\n        if (ts < cs) {\n            int p = pos[2].get(ts);\n            int move = Math.max(freq[p][0] - tv, 0) + Math.max(freq[p][1] - tk, 0) + Math.max(freq[p][2] - ts, 0) - 1;\n            ret = Math.min(ret, dfs(tv, tk, ts + 1, 2) + move);\n        }\n        return dp[tv][tk][ts][last] = ret;\n    }\n\n}\n","prob_desc_sample_outputs":"[\"3\", \"2\", \"3\", \"8\", \"0\"]","lang_cluster":"Java","code_uid":"da36122d4357f025b60792faf0f976a5","prob_desc_notes":"NoteIn the first sample, the initial string is \"VKVK\". The minimum possible number of moves is 3. One optimal sequence of moves is: Swap two last letters. The string becomes \"VKKV\". Swap first two letters. The string becomes \"KVKV\". Swap the second and the third letter. The string becomes \"KKVV\". Indeed, this string doesn't have a substring \"VK\".In the second sample, there are two optimal sequences of moves. One is \"BVVKV\"\u2009\u2009\u2192\u2009\u2009\"VBVKV\"\u2009\u2009\u2192\u2009\u2009\"VVBKV\". The other is \"BVVKV\"\u2009\u2009\u2192\u2009\u2009\"BVKVV\"\u2009\u2009\u2192\u2009\u2009\"BKVVV\".In the fifth sample, no swaps are necessary.","prob_desc_output_spec":"Print one integer, denoting the minimum possible number of moves Limak can do, in order to obtain a string without a substring \"VK\".","prob_desc_output_to":"standard output","prob_desc_description":"Bear Limak prepares problems for a programming competition. Of course, it would be unprofessional to mention the sponsor name in the statement. Limak takes it seriously and he is going to change some words. To make it still possible to read, he will try to modify each word as little as possible.Limak has a string s that consists of uppercase English letters. In one move he can swap two adjacent letters of the string. For example, he can transform a string \"ABBC\" into \"BABC\" or \"ABCB\" in one move.Limak wants to obtain a string without a substring \"VK\" (i.e. there should be no letter 'V' immediately followed by letter 'K'). It can be easily proved that it's possible for any initial string s.What is the minimum possible number of moves Limak can do?","length":67,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\nVKVK\\n', 'output': ['3\\n']}, {'input': '5\\nBVVKV\\n', 'output': ['2\\n']}, {'input': '7\\nVVKEVKK\\n', 'output': ['3\\n']}, {'input': '20\\nVKVKVVVKVOVKVQKKKVVK\\n', 'output': ['8\\n']}, {'input': '5\\nLIMAK\\n', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"mew\", \"wuffuw\", \"qqqqqqqq\"]","prob_desc_input_spec":"The first line contains a non-empty string $$$s$$$ with length at most $$$50$$$ characters, containing lowercase English letters only.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Nafis {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        int sz = str.length();\n        HashSet<Character> freq = new HashSet<>();\n        for (int i = 0; i <= sz \/ 2; i++) {\n            if (str.charAt(i) == str.charAt(sz - i - 1)) {\n                freq.add(str.charAt(i));\n                continue;\n            } else {\n                System.out.println(sz);\n                return;\n            }\n        }\n\n        System.out.println(freq.size() == 1 ? 0 : sz - 1);\n\n    }\n}","prob_desc_sample_outputs":"[\"3\", \"5\", \"0\"]","lang_cluster":"Java","code_uid":"4b4808a1d50cf5b792f4e4dba57ad81f","prob_desc_notes":"Note\"mew\" is not a palindrome, so the longest substring of it that is not a palindrome, is the string \"mew\" itself. Thus, the answer for the first example is $$$3$$$.The string \"uffuw\" is one of the longest non-palindrome substrings (of length $$$5$$$) of the string \"wuffuw\", so the answer for the second example is $$$5$$$.All substrings of the string \"qqqqqqqq\" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $$$0$$$.","prob_desc_output_spec":"If there is such a substring in $$$s$$$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $$$0$$$. Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","prob_desc_output_to":"standard output","prob_desc_description":"A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings \"kek\", \"abacaba\", \"r\" and \"papicipap\" are palindromes, while the strings \"abb\" and \"iq\" are not.A substring $$$s[l \\ldots r]$$$ ($$$1\u2009\\leq\u2009l\u2009\\leq\u2009r\u2009\\leq\u2009|s|$$$) of a string $$$s\u2009=\u2009s_{1}s_{2} \\ldots s_{|s|}$$$ is the string $$$s_{l}s_{l\u2009+\u20091} \\ldots s_{r}$$$.Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $$$s$$$ is changed into its longest substring that is not a palindrome. If all the substrings of $$$s$$$ are palindromes, she skips the word at all.Some time ago Ann read the word $$$s$$$. What is the word she changed it into?","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'racecar', 'output': ['6']}, {'input': 'hannah', 'output': ['5']}, {'input': 'madam', 'output': ['4']}, {'input': 'level', 'output': ['4']}, {'input': 'rotator', 'output': ['6']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1f\", \"2d\", \"4a\", \"5e\"]","prob_desc_input_spec":"The only line of input contains a description of Vasya's seat in the format ns, where n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) is the index of the row and s is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class FoodOnThePlane {\n\tpublic static void main(String args[]) throws Exception {\n\t\tBufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n\t\t\/\/BufferedReader s = new BufferedReader(new FileReader(\"*.in\"));\n\t\t\/\/PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"*.out\")));\n\t\t\/\/StringTokenizer st = new StringTokenizer(s.readLine());\n\t\tString y = s.readLine();\n\t\tlong row = Long.parseLong(y.substring(0, y.length()-1));\n\t\tint col = y.charAt(y.length()-1) - 'a';\n\t\tlong secs = 0;\n\t\tif(row == 1)secs = 0;\n\t\telse if (row == 2)secs = 7;\n\t\telse {\n\t\t\tlong remainder = row % 4;\n\t\t\tif(remainder == 1){\n\t\t\t\tsecs = ((row - 1) \/ 4) * 16;\n\t\t\t} else if (remainder == 3){\n\t\t\t\tsecs = ((row - 3)\/4) * 16;\n\t\t\t} else if (remainder == 2){\n\t\t\t\tsecs = ((((row + 2) \/ 4)-1) * 16)+7;\n\t\t\t} else {\n\t\t\t\tsecs = (((row \/ 4)-1) * 16)+7;\n\t\t\t}\n\t\t}\n\t\tif(col == 0){\n\t\t\tsecs += 4;\n\t\t} else if(col == 1){\n\t\t\tsecs += 5;\n\t\t} else if(col == 2){\n\t\t\tsecs += 6;\n\t\t} else if(col == 3){\n\t\t\tsecs += 3;\n\t\t} else if(col == 4){\n\t\t\tsecs += 2;\n\t\t} else {\n\t\t\tsecs+=1;\n\t\t}\n\t\tSystem.out.println(secs);\n\t}\n}\n","prob_desc_sample_outputs":"[\"1\", \"10\", \"11\", \"18\"]","lang_cluster":"Java","code_uid":"ab3d85949afbe2b6b5784853440db2a5","prob_desc_notes":"NoteIn the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.In the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6\u2009+\u20091\u2009+\u20093\u2009=\u200910.","prob_desc_output_spec":"Print one integer\u00a0\u2014 the number of seconds Vasya has to wait until he gets his lunch.","prob_desc_output_to":"standard output","prob_desc_description":"A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle.   \u00a0It's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.Flight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one\u00a0\u2014 in seat 'c'. Assume that all seats are occupied.Vasya has seat s in row n and wants to know how many seconds will pass before he gets his lunch.","length":43,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1a', 'output': ['4']}, {'input': '3f', 'output': ['15']}, {'input': '4c', 'output': ['17']}, {'input': '5b', 'output': ['22']}, {'input': '6d', 'output': ['27']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"0.5 second","prob_desc_sample_inputs":"[\"2 2 1 0 0 1\", \"2 2 10 11 0 1\", \"2 4 3 -1 3 7\"]","prob_desc_input_spec":"The only line contains integers a, b, x1, y1, x2 and y2 \u2014 the parameters of the bad squares, the coordinates of the initial and the final squares correspondingly (2\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009109 and |x1|,|y1|,|x2|,|y2|\u2009\u2264\u2009109). It is guaranteed that the initial and the final square aren't bad.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    void solve(Scanner in, PrintWriter out) {\n\n        int a = in.nextInt();\n        int b = in.nextInt();\n        int x1 = in.nextInt();\n        int y1 = in.nextInt();\n        int x2 = in.nextInt();\n        int y2 = in.nextInt();\n\n        int n1 = Math.floorDiv(x1 + y1, 2 * a);\n        int m1 = Math.floorDiv(x1 - y1, 2 * b);\n        int n2 = Math.floorDiv(x2 + y2, 2 * a);\n        int m2 = Math.floorDiv(x2 - y2, 2 * b);\n\n        int res = Math.max(Math.abs(n2 - n1), Math.abs(m2 - m1));\n\n        out.print(res);\n    }\n\n    void run() {\n        try (Scanner in = new Scanner(System.in);\n             PrintWriter out = new PrintWriter(System.out)) {\n\n            solve(in, out);\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n","prob_desc_sample_outputs":"[\"1\", \"5\", \"2\"]","lang_cluster":"Java","code_uid":"47981e3fe56c0955e146c2fd06932f4e","prob_desc_notes":"NoteIn the third sample one of the possible paths in (3;-1)-&gt;(3;0)-&gt;(3;1)-&gt;(3;2)-&gt;(4;2)-&gt;(4;3)-&gt;(4;4)-&gt;(4;5)-&gt;(4;6)-&gt;(4;7)-&gt;(3;7). Squares (3;1) and (4;4) are bad.","prob_desc_output_spec":"Print a single number \u2014 the minimum number of bad cells that one will have to visit in order to travel from square (x1; y1) to square (x2; y2).","prob_desc_output_to":"standard output","prob_desc_description":"You are given an infinite checkered field. You should get from a square (x1; y1) to a square (x2; y2). Using the shortest path is not necessary. You can move on the field squares in four directions. That is, when you are positioned in any square, you can move to any other side-neighboring one. A square (x; y) is considered bad, if at least one of the two conditions is fulfilled: |x\u2009+\u2009y|\u2009\u2261\u20090 (mod\u00a02a), |x\u2009-\u2009y|\u2009\u2261\u20090 (mod\u00a02b). Your task is to find the minimum number of bad cells one will have to visit on the way from (x1; y1) to (x2; y2).","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 1 1 3 3', 'output': ['1']}, {'input': '3 3 0 0 6 6', 'output': ['2']}, {'input': '2 2 -1 -1 -3 -3', 'output': ['1']}, {'input': '3 3 -2 -2 -5 -5', 'output': ['2']}, {'input': '2 2 1 -1 -3 3', 'output': ['2']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1500.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"12\"]","prob_desc_input_spec":"The only line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the prediction on the number of people who will buy the game.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long n = sc.nextLong();\n        long res = (n \/ 2) + (n \/ 3) - (n \/ 6) + (n \/ 42)\n                  +(n \/ 5) + (n \/ 7) + (n\/ 30) + (n \/ 70) + (n \/ 105)\n                  -(n \/ 10) - (n \/ 15) - (n \/ 14) - (n \/ 21) - (n \/ 35) - (n \/ 210);\n        System.out.println(n - res);\n    }\n}\n","prob_desc_sample_outputs":"[\"2\"]","lang_cluster":"Java","code_uid":"80db3d064f45537bd7563130c38d4494","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer showing how many numbers from 1 to n are not divisible by any number from 2 to 10.","prob_desc_output_to":"standard output","prob_desc_description":"IT City company developing computer games decided to upgrade its way to reward its employees. Now it looks the following way. After a new game release users start buying it actively, and the company tracks the number of sales with precision to each transaction. Every time when the next number of sales is not divisible by any number from 2 to 10 every developer of this game gets a small bonus.A game designer Petya knows that the company is just about to release a new game that was partly developed by him. On the basis of his experience he predicts that n people will buy the game during the first month. Now Petya wants to determine how many times he will get the bonus. Help him to know it.","length":12,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1']}, {'input': '10', 'output': ['2']}, {'input': '20', 'output': ['4']}, {'input': '30', 'output': ['6']}, {'input': '100', 'output': ['20']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 1 2\", \"3 4 5\", \"4 1 1\"]","prob_desc_input_spec":"The single line of the input contains three space-separated integers a, b and c (1\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u2009106) \u2014 the valence numbers of the given atoms.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class SimpleMoecules {\n\n\tpublic static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\n\n\t\tScanner input = new Scanner(System.in);\n\t\tint a = input.nextInt();\n\t\tint b = input.nextInt();\n\t\tint c = input.nextInt();\n\t\tif((c+b-a)%2==0){\n\t\t\tint z  = (c+b-a)\/2;\n\t\t\tif(z<0){\n\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = c-z;\n\t\t\tif(y<0){\n\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint x = a-y;\n\t\t\tif(x<0){\n\t\t\t\tSystem.out.println(\"Impossible\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(x+\" \"+z+\" \"+y);\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(\"Impossible\");\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"0 1 1\", \"1 3 2\", \"Impossible\"]","lang_cluster":"Java","code_uid":"82e24be68fd0c717c3c720b2851c3297","prob_desc_notes":"NoteThe first sample corresponds to the first figure. There are no bonds between atoms 1 and 2 in this case.The second sample corresponds to the second figure. There is one or more bonds between each pair of atoms.The third sample corresponds to the third figure. There is no solution, because an atom cannot form bonds with itself.The configuration in the fourth figure is impossible as each atom must have at least one atomic bond.","prob_desc_output_spec":"If such a molecule can be built, print three space-separated integers \u2014 the number of bonds between the 1-st and the 2-nd, the 2-nd and the 3-rd, the 3-rd and the 1-st atoms, correspondingly. If there are multiple solutions, output any of them. If there is no solution, print \"Impossible\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Mad scientist Mike is busy carrying out experiments in chemistry. Today he will attempt to join three atoms into one molecule.A molecule consists of atoms, with some pairs of atoms connected by atomic bonds. Each atom has a valence number \u2014 the number of bonds the atom must form with other atoms. An atom can form one or multiple bonds with any other atom, but it cannot form a bond with itself. The number of bonds of an atom in the molecule must be equal to its valence number.  Mike knows valence numbers of the three atoms. Find a molecule that can be built from these atoms according to the stated rules, or determine that it is impossible.","length":35,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 2', 'output': ['1 1 0\\n']}, {'input': '1 1 1', 'output': ['Impossible\\n']}, {'input': '3 3 3', 'output': ['1 1 1\\n']}, {'input': '5 5 5', 'output': ['2 2 1\\n']}, {'input': '6 6 6', 'output': ['3 3 0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4\"]","prob_desc_input_spec":"The only line contains an integer n (2\u2009\u2264\u2009n\u2009\u2264\u20091012), the number of vertices in the graph.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/\/ http:\/\/codeforces.com\/contest\/959\/problem\/E\n\nimport java.io.*;\nimport java.util.InputMismatchException;\n\n\npublic class CF959E {\n\n    public static void main(String[] args) throws IOException {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        final long N = in.readLong() - 1;\n        long res = 0;\n        long i = 1;\n        for (i = 1; i <= N; i = i << 1) {\n            res = res + ((N - i) \/ (i << 1) + 1) * i;\n        }\n        out.print(res);\n        closeStreams(out, in);\n    }\n\n    private static void closeStreams(OutputWriter out, InputReader in) throws IOException {\n        out.flush();\n        out.close();\n        in.close();\n    }\n\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double readDouble() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, readInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E') {\n                        return res * Math.pow(10, readInt());\n                    }\n                    if (c < '0' || c > '9') {\n                        throw new InputMismatchException();\n                    }\n                    m \/= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public boolean isEndOfLine(int c) {\n            if (filter != null) {\n                return filter.isEndOfLine(c);\n            }\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public void close() throws IOException {\n            this.stream.close();\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n            boolean isEndOfLine(int ch);\n        }\n\n    }\n\n    static class IOUtils {\n\n        public static int[] readIntArray(InputReader in, int elementCount) {\n            return readIntArray(in, elementCount, 0);\n        }\n\n        public static int[] readIntArray(InputReader in, int elementCount, int startOffset) {\n            int[] array = new int[elementCount + startOffset];\n            for (int i = 0; i < elementCount; i++)\n                array[i + startOffset] = in.readInt();\n            return array;\n        }\n\n        public static long[] readLongArray(InputReader in, int elementCount) {\n            return readLongArray(in, elementCount, 0);\n        }\n\n        public static long[] readLongArray(InputReader in, int elementCount, int startOffset) {\n            long[] array = new long[elementCount + startOffset];\n            for (int i = 0; i < elementCount; i++)\n                array[i + startOffset] = in.readLong();\n            return array;\n        }\n\n    }\n\n    static class OutputWriter {\n\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void flush() {\n            writer.flush();\n        }\n\n    }\n}\n","prob_desc_sample_outputs":"[\"4\"]","lang_cluster":"Java","code_uid":"5e64f8683dec9cfa6f6e6619a6895030","prob_desc_notes":"NoteIn the first sample:  The weight of the minimum spanning tree is 1+2+1=4.","prob_desc_output_spec":"The only line contains an integer x, the weight of the graph's minimum spanning tree.","prob_desc_output_to":"standard output","prob_desc_description":"Ehab is interested in the bitwise-xor operation and the special graphs. Mahmoud gave him a problem that combines both. He has a complete graph consisting of n vertices numbered from 0 to n\u2009-\u20091. For all 0\u2009\u2264\u2009u\u2009&lt;\u2009v\u2009&lt;\u2009n, vertex u and vertex v are connected with an undirected edge that has weight  (where  is the bitwise-xor operation). Can you find the weight of the minimum spanning tree of that graph?You can read about complete graphs in https:\/\/en.wikipedia.org\/wiki\/Complete_graphYou can read about the minimum spanning tree in https:\/\/en.wikipedia.org\/wiki\/Minimum_spanning_treeThe weight of the minimum spanning tree is the sum of the weights on the edges included in it.","length":240,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n', 'output': ['1\\n']}, {'input': '3\\n', 'output': ['3\\n']}, {'input': '5\\n', 'output': ['8\\n']}, {'input': '6\\n', 'output': ['11\\n']}, {'input': '10\\n', 'output': ['21\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\", \"3\"]","prob_desc_input_spec":"The first and only line of the input contains a single integer n (3\u2009\u2264\u2009n\u2009\u2264\u200954321) - the number of vertices of the regular polygon drawn by Ari.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"    \nimport java.util.Scanner;\n\npublic class cls_div2_328_B {\n    public static void main(String[] args) {\n\n        Scanner scan = new Scanner(System.in);\n        \n        long n = scan.nextInt();\n        \n        scan.close();\n        \n        long result = (n - 2) + ((n - 3) * (n - 2));\n        \n        System.out.println(result);\n    }\n}\n","prob_desc_sample_outputs":"[\"9\", \"1\"]","lang_cluster":"Java","code_uid":"7e32db57b268384ac62fb9e4ae7d33c5","prob_desc_notes":"NoteOne of the possible solutions for the first sample is shown on the picture above.","prob_desc_output_spec":"Print the minimum number of jumps Ada should make to collect all the walnuts. Note, that she doesn't need to leave the polygon after.","prob_desc_output_to":"standard output","prob_desc_description":"Ari the monster always wakes up very early with the first ray of the sun and the first thing she does is feeding her squirrel.Ari draws a regular convex polygon on the floor and numbers it's vertices 1,\u20092,\u2009...,\u2009n in clockwise order. Then starting from the vertex 1 she draws a ray in the direction of each other vertex. The ray stops when it reaches a vertex or intersects with another ray drawn before. Ari repeats this process for vertex 2,\u20093,\u2009...,\u2009n (in this particular order). And then she puts a walnut in each region inside the polygon.  Ada the squirrel wants to collect all the walnuts, but she is not allowed to step on the lines drawn by Ari. That means Ada have to perform a small jump if she wants to go from one region to another. Ada can jump from one region P to another region Q if and only if P and Q share a side or a corner.Assuming that Ada starts from outside of the picture, what is the minimum number of jumps she has to perform in order to collect all the walnuts?","length":17,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\n', 'output': ['4\\n']}, {'input': '10\\n', 'output': ['64\\n']}, {'input': '20\\n', 'output': ['324\\n']}, {'input': '30\\n', 'output': ['784\\n']}, {'input': '40\\n', 'output': ['1444\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"7\\nABACABA\", \"5\\nZZZAA\"]","prob_desc_input_spec":"The first line of the input contains integer number $$$n$$$ ($$$2 \\le n \\le 100$$$) \u2014 the length of string $$$s$$$. The second line of the input contains the string $$$s$$$ consisting of $$$n$$$ capital Latin letters.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tString s=sc.next();\n\t\tchar c[]=s.toCharArray();\n\t\tchar aa='1',bb='1';\n\t\tint max=-1;\n\t\tfor(int i=0;i<c.length-1;i++){\n\t\t\tchar a=c[i],b=c[i+1];\n\t\t\tint con=1;\n\t\t\tfor(int j=i+1;j<c.length-1;j++){\n\t\t\t\tif(c[j]==c[i]&&c[j+1]==c[i+1]){\n\t\t\t\t\tcon++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(con>max){\n\t\t\t\tmax=con;\n\t\t\t\taa=a;bb=b;\n\t\t\t}else if(con==max&&(a<aa||(a==aa&&b<bb))){\n\t\t\t\t\taa=a;bb=b;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(aa+\"\"+bb);\n\t}\n}\n","prob_desc_sample_outputs":"[\"AB\", \"ZZ\"]","lang_cluster":"Java","code_uid":"1e893aa51d1c23c5787c90d8a946c7bb","prob_desc_notes":"NoteIn the first example \"BA\" is also valid answer.In the second example the only two-gram \"ZZ\" can be printed because it contained in the string \"ZZZAA\" two times.","prob_desc_output_spec":"Print the only line containing exactly two capital Latin letters \u2014 any two-gram contained in the given string $$$s$$$ as a substring (i.e. two consecutive characters of the string) maximal number of times.","prob_desc_output_to":"standard output","prob_desc_description":"Two-gram is an ordered pair (i.e. string of length two) of capital Latin letters. For example, \"AZ\", \"AA\", \"ZA\" \u2014 three distinct two-grams.You are given a string $$$s$$$ consisting of $$$n$$$ capital Latin letters. Your task is to find any two-gram contained in the given string as a substring (i.e. two consecutive characters of the string) maximal number of times. For example, for string $$$s$$$ = \"BBAABBBA\" the answer is two-gram \"BB\", which contained in $$$s$$$ three times. In other words, find any most frequent two-gram.Note that occurrences of the two-gram can overlap with each other.","length":28,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\nAAAAB', 'output': ['AA']}, {'input': '6\\nAABBBB', 'output': ['BB']}, {'input': '7\\nAAABBBB', 'output': ['BB']}, {'input': '8\\nAAAABBBB', 'output': ['AA']}, {'input': '9\\nAAAABBBBB', 'output': ['BB']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2400.0,"prob_desc_time_limit":"4 seconds","prob_desc_sample_inputs":"[\"10 2\\n3 5\\n11 13\", \"10 3\\n3 5\\n9 10\\n11 13\", \"20 1\\n3 19\"]","prob_desc_input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009100\u2009000, 1\u2009\u2264\u2009k\u2009\u2264\u2009100)\u00a0\u2014 the number of seconds the cutlet should be cooked on each side and number of periods of time in which Arkady can flip it. The next k lines contain descriptions of these intervals. Each line contains two integers li and ri (0\u2009\u2264\u2009li\u2009\u2264\u2009ri\u2009\u2264\u20092\u00b7n), meaning that Arkady can flip the cutlet in any moment starting from li seconds after the beginning of cooking and finishing at ri seconds after beginning of cooking. In particular, if li\u2009=\u2009ri then Arkady can flip the cutlet only in the moment li\u2009=\u2009ri. It's guaranteed that li\u2009&gt;\u2009ri\u2009-\u20091 for all 2\u2009\u2264\u2009i\u2009\u2264\u2009k.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\npublic class CF939_D2_F {\n\tpublic static void main(String[] args)throws Throwable {\n\t\tMyScanner sc=new MyScanner();\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\t\n\t\tint n=sc.nextInt()*2;\n\t\tint k=sc.nextInt();\n\t\tint [] l=new int [k+1];\n\t\tint [] r=new int [k+1];\n\t\tSparseTable [][] seg=new SparseTable [2][2];\n\t\tfor(int i=0;i<k;i++){\n\t\t\tl[i]=sc.nextInt();\n\t\t\tr[i]=sc.nextInt();\n\t\t}\n\t\tl[k]=n;\n\t\tfor(int j=0;j<2;j++){\n\t\t\tint [] a=new int [n\/2+2];\n\t\t\tArrays.fill(a, inf);\n\t\t\ta[n\/2]=0;\n\t\t\tseg[1][j]=new SparseTable(a);\n\t\t}\n\t\tint p=0;\n\t\tfor(int i=k-1;i>=0;i--){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tint [] a=new int [n\/2+2];\n\t\t\t\tArrays.fill(a, inf);\n\t\t\t\tfor(int c=0;c<=l[i] && c<a.length;c++){\n\t\t\t\t\tint best=seg[1-p][j].query(c+l[i+1]-l[i], c+l[i+1]-l[i]);\n\t\t\t\t\tbest=Math.min(best, 1+seg[1-p][1-j].query(l[i+1]-(c+r[i]-l[i]), l[i+1]-(c)));\n\t\t\t\t\tif(r[i]>l[i])\n\t\t\t\t\t\tbest=Math.min(best, 2+seg[1-p][j].query(c+l[i+1]-r[i], c+l[i+1]-l[i]-1));\n\t\t\t\t\ta[c]=best;\n\t\t\t\t}\n\t\t\t\tseg[p][j]=new SparseTable(a);\n\t\t\t}\n\t\t\tp^=1;\n\t\t}\n\t\tp^=1;\n\t\tint ans=Math.min(seg[p][0].query(l[0], l[0]), seg[p][1].query(l[0], l[0]));\n\t\tif(ans>2*k)\n\t\t\tpw.println(\"Hungry\");\n\t\telse{\n\t\t\tpw.println(\"Full\");\n\t\t\tpw.println(ans);\n\t\t}\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic int inf=(int)1e7;\n\t\n\tstatic class SparseTable {\n\t\tint [] a;\n\t\tint [][] st;\n\t\t\/\/st[i][j] --> minimum of sub array starting at index i and of length 2^j\n\t\tSparseTable(int [] a){\n\t\t\tint n=a.length;\n\t\t\tthis.a=a;\n\t\t\tint k=(int)Math.floor(Math.log(n)\/Math.log(2))+1;\n\t\t\tst=new int [n][k];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tst[i][0]=i;\n\t\t\t\/\/(1<<j)===(2^j)\n\t\t\tfor(int j=1;(1<<j)<=n;j++)\n\t\t\t\tfor(int i=0;i+(1<<j)-1<n;i++)\n\t\t\t\t\tif(a[st[i][j-1]] < a[st[i+(1<<(j-1))][j-1]])\n\t\t\t\t\t\tst[i][j]=st[i][j-1]; \/\/\n\t\t\t\t\telse\n\t\t\t\t\t\tst[i][j]=st[i+(1<<(j-1))][j-1];\n\t\t}\n\t\tint query(int i,int j){\n\t\t\tif(i>=a.length)\n\t\t\t\treturn inf;\n\t\t\tj=Math.min(j, a.length-1);\n\t\t\tint k=(int)Math.floor(Math.log(j-i+1)\/Math.log(2));\n\t\t\treturn Math.min(a[st[i][k]], a[st[j-(1<<k)+1][k]]);\n\t\t}\n\t}\n\n\t\n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {while (st == null || !st.hasMoreElements()) {\n\t\t\ttry {st = new StringTokenizer(br.readLine());}\n\t\t\tcatch (IOException e) {e.printStackTrace();}}\n\t\treturn st.nextToken();}\n\t\tint nextInt() {return Integer.parseInt(next());}\n\t\tlong nextLong() {return Long.parseLong(next());}\n\t\tdouble nextDouble() {return Double.parseDouble(next());}\n\t\tString nextLine(){String str = \"\";\n\t\ttry {str = br.readLine();}\n\t\tcatch (IOException e) {e.printStackTrace();}\n\t\treturn str;}\n\t}\n}","prob_desc_sample_outputs":"[\"Full\\n2\", \"Full\\n1\", \"Hungry\"]","lang_cluster":"Java","code_uid":"c7e0ec7560756159e9aaf42692f58f00","prob_desc_notes":"NoteIn the first example Arkady should flip the cutlet in time moment 3 seconds after he starts cooking and in time moment 13 seconds after he starts cooking.In the second example, Arkady can flip the cutlet at 10 seconds after he starts cooking.","prob_desc_output_spec":"Output \"Hungry\" if Arkady won't be able to fry the cutlet for exactly n seconds on one side and exactly n seconds on the other side. Otherwise, output \"Full\" in the first line, and the minimum number of times he should flip the cutlet in the second line.","prob_desc_output_to":"standard output","prob_desc_description":"Arkady wants to have a dinner. He has just returned from a shop where he has bought a semifinished cutlet. He only needs to fry it. The cutlet should be fried for 2n seconds, in particular, it should be fried for n seconds on one side and n seconds on the other side. Arkady has already got a frying pan and turn on fire, but understood that maybe he won't be able to flip the cutlet exactly after n seconds after the beginning of cooking.Arkady is too busy with sorting sticker packs in his favorite messenger and can flip the cutlet only in some periods of time. Namely, there are k periods of time in which he can do it, the i-th of them is an interval of time from li seconds after he starts cooking till ri seconds, inclusive. Arkady decided that it's not required to flip the cutlet exactly in the middle of cooking, instead, he will flip it several times in such a way that the cutlet will be fried exactly n seconds on one side and n seconds on the other side in total.Help Arkady and find out if it's possible for him to cook the cutlet, if he is able to flip the cutlet only in given periods of time; and if yes, find the minimum number of flips he needs to cook the cutlet.","length":101,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 1\\n2 8', 'output': ['Full\\n1\\n']}, {'input': '10 2\\n3 5\\n11 13', 'output': ['Full\\n2\\n']}, {'input': '10 3\\n3 5\\n9 10\\n11 13', 'output': ['Full\\n1\\n']}, {'input': '20 1\\n3 19', 'output': ['Hungry\\n']}, {'input': '15 2\\n5 10\\n11 20', 'output': ['Full\\n2\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"4 2\", \"3 2\"]","prob_desc_input_spec":"The input contains a single line consisting of $$$2$$$ integers $$$N$$$ and $$$M$$$ ($$$1 \\le N \\le 10^{18}$$$, $$$2 \\le M \\le 100$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\npublic class issam{\n    static class consecutive{\n        long mod;\n        long[][] matrix;\n        long nbWays(long n,int m,long mod){\n            this.mod = mod;\n            if(n<(long)m) return 1;\n            if(n==(long)m) return 2;\n            if(m==1) return nbPow(2,n);\n            matrix = new long[m][m];\n            for(int i=1;i<m;i++) matrix[i][i-1] = 1;\n            matrix[0][0] = 1;\n            matrix[0][m-1] = 1;\n            matrix = pow(matrix,n-(long)m+1);\n            long ans = 0;\n            for(int i=0;i<m;i++){\n                ans += matrix[0][i];\n                ans %= mod;\n            }\n            return ans;\n        }\n        \n        long nbPow(long a,long n){\n            if(n==1) return a;\n            if(n%2==0){\n                long ans = nbPow(a,n\/2);\n                return (ans*ans)%mod;\n            }\n            return (a*nbPow(a,n-1))%mod;\n        }\n        \n        long[][] pow(long matrix[][], long m) {\n            if (m == 1)\n                return matrix;\n            if (m % 2 == 0) {\n                long mat[][] = pow(matrix, m \/ 2);\n                return multiply(mat, mat);\n            }\n            return multiply(matrix, pow(matrix, m - 1));\n        }\n\n        long[][] multiply(long matrix1[][], long matrix2[][]) {\n            long ans[][] = new long[matrix1.length][matrix2[0].length];\n            for (int i = 0; i < matrix1.length; i++) {\n                for (int j = 0; j < matrix2[0].length; j++) {\n                    for (int k = 0; k < matrix1[0].length; k++) {\n                        ans[i][j] += (matrix1[i][k] * matrix2[k][j]) % mod;\n                        ans[i][j] = ans[i][j] % mod;\n                    }\n                }\n            }\n            return ans;\n        }\n        \n    }\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        long n = sc.nextLong();\n        int m = sc.nextInt();\n        consecutive c = new consecutive();\n        long mod = 1000;\n        mod = mod*mod*mod+7;\n        long res = c.nbWays(n,m,mod);\n        System.out.println(res);\n    }\n}","prob_desc_sample_outputs":"[\"5\", \"3\"]","lang_cluster":"Java","code_uid":"36dd77c492daaa293e7cfbdd4193d67e","prob_desc_notes":"NoteIn the first example each magic gem can split into $$$2$$$ normal gems, and we know that the total amount of gems are $$$4$$$.Let $$$1$$$ denote a magic gem, and $$$0$$$ denote a normal gem.The total configurations you can have is:   $$$1 1 1 1$$$ (None of the gems split);  $$$0 0 1 1$$$ (First magic gem splits into $$$2$$$ normal gems);  $$$1 0 0 1$$$ (Second magic gem splits into $$$2$$$ normal gems);  $$$1 1 0 0$$$ (Third magic gem splits into $$$2$$$ normal gems);  $$$0 0 0 0$$$ (First and second magic gems split into total $$$4$$$ normal gems). Hence, answer is $$$5$$$.","prob_desc_output_spec":"Print one integer, the total number of configurations of the resulting set of gems, given that the total amount of space taken is $$$N$$$ units. Print the answer modulo $$$1000000007$$$ ($$$10^9+7$$$).","prob_desc_output_to":"standard output","prob_desc_description":"Reziba has many magic gems. Each magic gem can be split into $$$M$$$ normal gems. The amount of space each magic (and normal) gem takes is $$$1$$$ unit. A normal gem cannot be split.Reziba wants to choose a set of magic gems and split some of them, so the total space occupied by the resulting set of gems is $$$N$$$ units. If a magic gem is chosen and split, it takes $$$M$$$ units of space (since it is split into $$$M$$$ gems); if a magic gem is not split, it takes $$$1$$$ unit.How many different configurations of the resulting set of gems can Reziba have, such that the total amount of space taken is $$$N$$$ units? Print the answer modulo $$$1000000007$$$ ($$$10^9+7$$$). Two configurations are considered different if the number of magic gems Reziba takes to form them differs, or the indices of gems Reziba has to split differ.","length":67,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 2', 'output': ['144']}, {'input': '20 3', 'output': ['10946']}, {'input': '30 4', 'output': ['1346269']}, {'input': '40 5', 'output': ['165580141']}, {'input': '50 6', 'output': ['365435296162']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3\", \"6\", \"100\"]","prob_desc_input_spec":"The single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Sparsh Sanchorawala\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CInterestingGame solver = new CInterestingGame();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CInterestingGame {\n        public void solve(int testNumber, InputReader s, PrintWriter w) {\n            int n = s.nextInt();\n            ArrayList<Pair>[] pair = new ArrayList[n + 1];\n            for (int i = 1; i <= n; i++)\n                pair[i] = new ArrayList<>();\n            for (int k = 2; k <= n; k++)\n                for (int a = 1; (long) (2 * a + k - 1) * k \/ 2 <= n; a++)\n                    pair[(2 * a + k - 1) * k \/ 2].add(new Pair(a, k));\n            int[] grundy = new int[n + 1];\n            int[] val = new int[n + 1];\n            Arrays.fill(val, Integer.MAX_VALUE);\n            int[] pre = new int[n + 1];\n            for (int i = 2; i <= n; i++) {\n                HashSet<Integer> hs = new HashSet<>();\n                for (Pair p : pair[i]) {\n                    hs.add(pre[p.a + p.n - 1] ^ pre[p.a - 1]);\n                    if ((pre[p.a + p.n - 1] ^ pre[p.a - 1]) == 0)\n                        val[i] = Math.min(p.n, val[i]);\n                }\n                while (hs.contains(grundy[i]))\n                    grundy[i]++;\n                pre[i] = grundy[i] ^ pre[i - 1];\n            }\n            w.println(val[n] != Integer.MAX_VALUE ? val[n] : -1);\n        }\n\n        class Pair {\n            int a;\n            int n;\n\n            Pair(int a, int n) {\n                this.a = a;\n                this.n = n;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","prob_desc_sample_outputs":"[\"2\", \"-1\", \"8\"]","lang_cluster":"Java","code_uid":"be02d488ca253074ed7f069f1f8445f3","prob_desc_notes":null,"prob_desc_output_spec":"If Serozha wins, print k, which represents the minimal number of piles into which he can split the initial one during the first move in order to win the game. If Gena wins, print \"-1\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Two best friends Serozha and Gena play a game.Initially there is one pile consisting of n stones on the table. During one move one pile should be taken and divided into an arbitrary number of piles consisting of a1\u2009&gt;\u2009a2\u2009&gt;\u2009...\u2009&gt;\u2009ak\u2009&gt;\u20090 stones. The piles should meet the condition a1\u2009-\u2009a2\u2009=\u2009a2\u2009-\u2009a3\u2009=\u2009...\u2009=\u2009ak\u2009-\u20091\u2009-\u2009ak\u2009=\u20091. Naturally, the number of piles k should be no less than two.The friends play in turns. The player who cannot make a move loses. Serozha makes the first move. Who will win if both players play in the optimal way?","length":138,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n', 'output': ['-1\\n']}, {'input': '10\\n', 'output': ['4\\n']}, {'input': '15\\n', 'output': ['-1\\n']}, {'input': '21\\n', 'output': ['6\\n']}, {'input': '28\\n', 'output': ['7\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 0 3 3 5 21\", \"2 4 3 0 6 17\"]","prob_desc_input_spec":"The only line contains six integers a1,\u2009b1,\u2009a2,\u2009b2,\u2009L,\u2009R (0\u2009&lt;\u2009a1,\u2009a2\u2009\u2264\u20092\u00b7109,\u2009\u2009-\u20092\u00b7109\u2009\u2264\u2009b1,\u2009b2,\u2009L,\u2009R\u2009\u2264\u20092\u00b7109,\u2009L\u2009\u2264\u2009R).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.math.BigInteger;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class D {\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n\n        long a1 = sc.nextLong();\n        long b1 = sc.nextLong();\n        long a2 = sc.nextLong();\n        long b2 = sc.nextLong();\n        long left = sc.nextLong();\n        long right = sc.nextLong();\n\n        long lcm = lcm(a1, a2);\n        left = Math.max(left, Math.max(b1, b2));\n\n        \/\/ a1*x + b1 = a2*y + b2\n        \/\/ a1*x - a2*y = b1 - b2\n        long[] x_y_gcd = solveDiophantine(a1, -a2, b2 - b1);\n        if (x_y_gcd == null) {\n            System.out.println(0);\n        } else {\n            BigInteger a1Bi = BigInteger.valueOf(a1);\n            BigInteger b1Bi = BigInteger.valueOf(b1);\n            BigInteger leftBi = BigInteger.valueOf(left);\n            BigInteger rightBi = BigInteger.valueOf(right);\n            BigInteger lcmBi = BigInteger.valueOf(lcm);\n\n            BigInteger firstEq = a1Bi.multiply(BigInteger.valueOf(x_y_gcd[0])).add(b1Bi);\n            BigInteger diff = leftBi.subtract(firstEq).divide(lcmBi).subtract(BigInteger.ONE);\n            firstEq = firstEq.add(diff.multiply(lcmBi));\n            while (firstEq.compareTo(leftBi) < 0) {\n                firstEq = firstEq.add(lcmBi);\n            }\n            if (rightBi.compareTo(firstEq) < 0) {\n                System.out.println(0);\n            } else {\n                long count = Math.max(rightBi.subtract(firstEq).divide(lcmBi).longValue() + 1, 0);\n                System.out.println(count);\n            }\n        }\n    }\n\n    \/**\n     * Finds a single solution {x, y} to the LDE a*x + b*y = c.\n     * Outputs an array of the form {x, y, d}, where d = GCD(a,b).\n     *\/\n    private static long[] solveDiophantine(long a, long b, long c) {\n        long[] e = extEuclid(a, b);\n        long k = c \/ e[2];\n\n        \/\/c not divisible by the GCD(a,b) -> no solution\n        if (c - k * e[2] != 0)\n            return null;\n\n        long[] output = {e[0] * k, e[1] * k, e[2]};\n        return output;\n    }\n\n    \/**\n     * Extended Euclidean Algorithm finds {x, y, d}\n     * where d=GCD(a,b) and x and y satisfy a*x + b*y = d\n     * The output is an array of the form {x, y, d}.\n     *\/\n    private static long[] extEuclid(long a, long b) {\n        long s0 = 1, s1 = 0, sTemp;\n        long t0 = 0, t1 = 1, tTemp;\n        long r0 = a, r1 = b, rTemp;\n        long q;\n\n        while (r1 != 0) {\n            q = r0 \/ r1;\n\n            rTemp = r1;\n            r1 = r0 - q * r1;\n            r0 = rTemp;\n\n            sTemp = s1;\n            s1 = s0 - q * s1;\n            s0 = sTemp;\n\n            tTemp = t1;\n            t1 = t0 - q * t1;\n            t0 = tTemp;\n        }\n\n        long[] output = {s0, t0, r0};\n        return output;\n    }\n\n    static long lcm(long a, long b) {\n        return a \/ gcd(a, b) * b;\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n\n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String readNextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int[] readIntArray(int n) {\n            int[] a = new int[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextInt();\n            }\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int idx = 0; idx < n; idx++) {\n                a[idx] = nextLong();\n            }\n            return a;\n        }\n    }\n}\n","prob_desc_sample_outputs":"[\"3\", \"2\"]","lang_cluster":"Java","code_uid":"1f374f695b016fd0122d619fcff020cc","prob_desc_notes":null,"prob_desc_output_spec":"Print the desired number of integers x.","prob_desc_output_to":"standard output","prob_desc_description":"You are given two arithmetic progressions: a1k\u2009+\u2009b1 and a2l\u2009+\u2009b2. Find the number of integers x such that L\u2009\u2264\u2009x\u2009\u2264\u2009R and x\u2009=\u2009a1k'\u2009+\u2009b1\u2009=\u2009a2l'\u2009+\u2009b2, for some integers k',\u2009l'\u2009\u2265\u20090.","length":167,"num_hidden_unit_tests":5,"hidden_unit_tests":"[]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3 2\\n1 3\\n2 1\", \"5 5\\n3 3\\n3 3\", \"4 2\\n2 3\\n1 2\"]","prob_desc_input_spec":"The first line contains two space-separated numbers a1 and b1 \u2014 the sides of the board. Next two lines contain numbers a2,\u2009b2,\u2009a3 and b3 \u2014 the sides of the paintings. All numbers ai,\u2009bi in the input are integers and fit into the range from 1 to 1000.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\n\npublic class CF560BGetaldIntoArts {\n    public static void main(String[] args) {\n\n        Scanner s = new Scanner(System.in);\n        boolean b = true;\n\n        int a1 = s.nextInt();\n        int b1 = s.nextInt();\n        int a2 = s.nextInt();\n        int b2 = s.nextInt();\n        int a3 = s.nextInt();\n        int b3 = s.nextInt();\n\n\n        if(a1 >= Math.max(a2,a3) && b2+b3<=b1) b = true;\n\n\n\n        else if(a1 >= Math.max(a2,b3) && b2+a3<=b1) b = true;\n\n        else if(a1 >= Math.max(a3,b2) && b3+a2<=b1) b = true;\n\n        else if(a1 >= Math.max(b2,b3) && a2+a3<=b1) b = true;\n        else b = false;\n\n\n        if(b1 >= Math.max(a2,a3) && b2+b3<=a1) b = true;\n\n        else if(b1 >= Math.max(a2,b3) && b2+a3<=a1) b = true;\n\n        else if(b1>=Math.max(a3,b2) && b3+a2<=a1) b = true;\n\n        else if(b1>=Math.max(b2,b3) && a2+a3<=a1) b = true;\n\n\n        if(b == false){\n            System.out.println(\"NO\");\n        }\n        else System.out.println(\"YES\");\n\n\n\n\n    }\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\"]","lang_cluster":"Java","code_uid":"eea06fb8d0e6f20c7774140f00cc34b6","prob_desc_notes":"NoteThat's how we can place the pictures in the first test:And that's how we can do it in the third one.","prob_desc_output_spec":"If the paintings can be placed on the wall, print \"YES\" (without the quotes), and if they cannot, print \"NO\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Gerald bought two very rare paintings at the Sotheby's auction and he now wants to hang them on the wall. For that he bought a special board to attach it to the wall and place the paintings on the board. The board has shape of an a1\u2009\u00d7\u2009b1 rectangle, the paintings have shape of a a2\u2009\u00d7\u2009b2 and a3\u2009\u00d7\u2009b3 rectangles.Since the paintings are painted in the style of abstract art, it does not matter exactly how they will be rotated, but still, one side of both the board, and each of the paintings must be parallel to the floor. The paintings can touch each other and the edges of the board, but can not overlap or go beyond the edge of the board. Gerald asks whether it is possible to place the paintings on the board, or is the board he bought not large enough?","length":47,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5\\n2 2\\n2 2', 'output': ['YES\\n']}, {'input': '6 6\\n3 3\\n4 4', 'output': ['NO\\n']}, {'input': '10 10\\n5 5\\n6 6', 'output': ['NO\\n']}, {'input': '7 7\\n3 3\\n4 4', 'output': ['YES\\n']}, {'input': '8 8\\n4 4\\n4 4', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"14 34\", \"50 34\", \"387420489 225159023\", \"5 5\"]","prob_desc_input_spec":"The first line contains two integers a and c (0\u2009\u2264\u2009a,\u2009c\u2009\u2264\u2009109). Both numbers are written in decimal notation.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\n\/\/ ~\/BAU\/ACM-ICPC\/Teams\/A++\/BlackBurn95\n\/\/ ~\/sudo apt-get Accpeted\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n        \n        tk = new StringTokenizer(in.readLine());\n        BigInteger a = new BigInteger(tk.nextToken()),c = new BigInteger(tk.nextToken());\n        \n        String A = a.toString(3),C = c.toString(3) ;\n        \n        if(A.length() < C.length()) {\n            String tmp = \"\";\n            for(int i=0; i<C.length()-A.length(); i++)\n                tmp += \"0\";\n            A = tmp+A;\n        } else if(A.length() > C.length()) {\n            String tmp = \"\";\n            for(int i=0; i<A.length()-C.length(); i++)\n                tmp += \"0\";\n            C = tmp+C;\n        }\n        \n        char [] B = new char[A.length()];\n        for(int i=0; i<A.length(); i++) \n            B[i] = (char)((C.charAt(i)-'0'-(A.charAt(i)-'0')+3)%3 + '0');\n        \n        BigInteger b = new BigInteger(valueOf(B),3);\n        \n        System.out.println(b.toString(10));\n    }\n    \n}\n","prob_desc_sample_outputs":"[\"50\", \"14\", \"1000000001\", \"0\"]","lang_cluster":"Java","code_uid":"51f0c87b5581d4002235f01e789879c0","prob_desc_notes":null,"prob_desc_output_spec":"Print the single integer b, such that a tor b\u2009=\u2009c. If there are several possible numbers b, print the smallest one. You should print the number in decimal notation.","prob_desc_output_to":"standard output","prob_desc_description":"Little Petya very much likes computers. Recently he has received a new \"Ternatron IV\" as a gift from his mother. Unlike other modern computers, \"Ternatron IV\" operates with ternary and not binary logic. Petya immediately wondered how the xor operation is performed on this computer (and whether there is anything like it).It turned out that the operation does exist (however, it is called tor) and it works like this. Suppose that we need to calculate the value of the expression a tor b. Both numbers a and b are written in the ternary notation one under the other one (b under a). If they have a different number of digits, then leading zeroes are added to the shorter number until the lengths are the same. Then the numbers are summed together digit by digit. The result of summing each two digits is calculated modulo 3. Note that there is no carry between digits (i. e. during this operation the digits aren't transferred). For example: 1410 tor 5010\u2009=\u200901123 tor 12123\u2009=\u200910213\u2009=\u20093410.Petya wrote numbers a and c on a piece of paper. Help him find such number b, that a tor b\u2009=\u2009c. If there are several such numbers, print the smallest one.","length":47,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 20', 'output': ['20\\n']}, {'input': '30 40', 'output': ['10\\n']}, {'input': '100 200', 'output': ['200\\n']}, {'input': '300 400', 'output': ['100\\n']}, {'input': '1000 2000', 'output': ['2000\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 4\\n5 2 4 1\", \"3 20\\n199 41 299\"]","prob_desc_input_spec":"The first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u200935, 1\u2009\u2264\u2009m\u2009\u2264\u2009109). The second line contains n integers a1, a2, ..., an (1\u2009\u2264\u2009ai\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n    static int[] p = new int[(1<<18) + 10];\n    static int[] q = new int[(1<<18) + 10];\n    static int lenp = 0, lenq = 0;\n    static int M = 0;\n    public static void main(String[] args){\n        Scanner c = new Scanner(System.in);\n        int n = c.nextInt();\n        int m = c.nextInt();\n        M = m;\n        int[] nums = new int[n];\n        for(int i=0;i<n;i++){\n            nums[i] = c.nextInt() % m;\n        }\n        c.close();\n        if(m == 1){\n            System.out.println(0);\n            return;\n        }\n        if(n == 1){\n            System.out.println(nums[0]);\n            return;\n        }\n        if(n == 2){\n            int ans = Math.max(nums[0],nums[1]);\n            if(nums[0]+nums[1] < M){\n                ans = Math.max(ans,nums[0]+nums[1]);\n            }\n            System.out.println(ans);\n            return;\n        }\n        int mid = n >> 1;\n        dfs1(nums,0,mid-1,0);\n        dfs2(nums,mid,n-1,0);\n\/\/        System.out.println(Arrays.toString(p) + \"-->\" + lenp);\n\/\/        System.out.println(Arrays.toString(q) + \"-->\" + lenq);\n        Arrays.sort(p,0,lenp);\n        Arrays.sort(q,0,lenq);\n\n\n        int i=0, j=lenq-1;\n        int result = p[lenp-1] - M + q[lenq-1];\n        while(i < lenp){\n            while((p[i] + q[j]) >= M)\n                j--;\n            result = Math.max(result,p[i]+q[j]);\n            i++;\n        }\n        System.out.println(result);\n    }\n    \/\/\u5de6\u8fb9\u7684dfs\n    private static void dfs1(int[] nums, int i, int end ,int sum){\n        if(i == end){\n            p[lenp++] = sum;\n            p[lenp++] = ((sum+nums[i])%M);\n            return;\n        }\n        dfs1(nums,i+1,end, sum);\n        dfs1(nums,i+1,end, (sum+nums[i])%M);\n    }\n    \/\/\u53f3\u8fb9\u7684dfs\n    private static void dfs2(int[] nums, int i, int end ,int sum){\n        if(i == end){\n            q[lenq++] = sum;\n            q[lenq++] = ((sum+nums[i])%M);\n            return;\n        }\n        dfs2(nums,i+1,end, sum);\n        dfs2(nums,i+1,end, (sum+nums[i])%M);\n    }\n}\n","prob_desc_sample_outputs":"[\"3\", \"19\"]","lang_cluster":"Java","code_uid":"7959cc34765b379b2782b8d7b927c666","prob_desc_notes":"NoteIn the first example you can choose a sequence b\u2009=\u2009{1,\u20092}, so the sum  is equal to 7 (and that's 3 after taking it modulo 4).In the second example you can choose a sequence b\u2009=\u2009{3}.","prob_desc_output_spec":"Print the maximum possible value of .","prob_desc_output_to":"standard output","prob_desc_description":"You are given an array a consisting of n integers, and additionally an integer m. You have to choose some sequence of indices b1,\u2009b2,\u2009...,\u2009bk (1\u2009\u2264\u2009b1\u2009&lt;\u2009b2\u2009&lt;\u2009...\u2009&lt;\u2009bk\u2009\u2264\u2009n) in such a way that the value of  is maximized. Chosen sequence can be empty.Print the maximum possible value of .","length":76,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 10\\n1 2 3 4 5', 'output': ['9']}, {'input': '6 15\\n5 10 15 20 25 30', 'output': ['14']}, {'input': '7 20\\n7 14 21 28 35 42 49', 'output': ['19']}, {'input': '8 25\\n8 16 24 32 40 48 56 64', 'output': ['24']}, {'input': '9 30\\n9 18 27 36 45 54 63 72 81', 'output': ['29']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"40047\", \"7747774\", \"1000000000000000000\"]","prob_desc_input_spec":"The only line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018). Please do not use the %lld specificator to read or write 64-bit numbers in \u0421++. It is preferred to use the cin, cout streams or the %I64d specificator.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\npublic class test3 {\n    \n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long n = input.nextLong(); \n        if(check(n) == 7 || check(n) == 4)\n            System.out.println(\"YES\");\n        else\n            System.out.println(\"NO\");\n    }    \n    public static int check(long n){\n        int digits = 0;\n        String m = Long.toString(n);\n        for(int i = 0; i < m.length(); i++){                \n            if(n % 10 == 4 || n % 10 == 7){                \n                digits++;\n            } \n            n = n \/ 10;            \n        }\n        return digits; \n    }\n    \n}","prob_desc_sample_outputs":"[\"NO\", \"YES\", \"NO\"]","lang_cluster":"Java","code_uid":"4f157eb29befb1b8cb5aea9f5e2cb880","prob_desc_notes":"NoteIn the first sample there are 3 lucky digits (first one and last two), so the answer is \"NO\".In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is \"YES\".In the third sample there are no lucky digits, so the answer is \"NO\".","prob_desc_output_spec":"Print on the single line \"YES\" if n is a nearly lucky number. Otherwise, print \"NO\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number n is a nearly lucky number.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '444444444444444444', 'output': ['YES']}, {'input': '777777777777777777', 'output': ['YES']}, {'input': '1234567890', 'output': ['NO']}, {'input': '474747474747474747', 'output': ['NO']}, {'input': '747474747474747474', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10\\nrocesfedoc\", \"16\\nplmaetwoxesisiht\", \"1\\nz\"]","prob_desc_input_spec":"The first line of input consists of a single integer $$$n$$$ ($$$1 \\le n \\le 100$$$) \u2014 the length of the string $$$t$$$. The second line of input consists of the string $$$t$$$. The length of $$$t$$$ is $$$n$$$, and it consists only of lowercase Latin letters.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class RevEncrypt {\n\tpublic static void main(String[] args) {\n\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt(), i, j;\n\t\tString t = in.next(), s = \"\";\n\t\tin.close();\n\n\t\tfor (i = 2; i <= n; i++)\n\t\t\tif (n % i == 0) {\n\t\t\t\tfor (j = i - 1; j >= 0; j--)\n\t\t\t\t\ts += t.charAt(j);\n\t\t\t\t\n\t\t\t\ts += t.substring(i);\n\t\t\t\tt = s;\n\t\t\t\ts = \"\";\n\t\t\t}\n\t\tSystem.out.println(t);\n\t}\n}\n","prob_desc_sample_outputs":"[\"codeforces\", \"thisisexampletwo\", \"z\"]","lang_cluster":"Java","code_uid":"1ee6d560c74fa0a059b8abf9c4b047f7","prob_desc_notes":"NoteThe first example is described in the problem statement.","prob_desc_output_spec":"Print a string $$$s$$$ such that the above algorithm results in $$$t$$$.","prob_desc_output_to":"standard output","prob_desc_description":"A string $$$s$$$ of length $$$n$$$ can be encrypted by the following algorithm:  iterate over all divisors of $$$n$$$ in decreasing order (i.e. from $$$n$$$ to $$$1$$$),  for each divisor $$$d$$$, reverse the substring $$$s[1 \\dots d]$$$ (i.e. the substring which starts at position $$$1$$$ and ends at position $$$d$$$). For example, the above algorithm applied to the string $$$s$$$=\"codeforces\" leads to the following changes: \"codeforces\" $$$\\to$$$ \"secrofedoc\" $$$\\to$$$ \"orcesfedoc\" $$$\\to$$$ \"rocesfedoc\" $$$\\to$$$ \"rocesfedoc\" (obviously, the last reverse operation doesn't change the string because $$$d=1$$$).You are given the encrypted string $$$t$$$. Your task is to decrypt this string, i.e., to find a string $$$s$$$ such that the above algorithm results in string $$$t$$$. It can be proven that this string $$$s$$$ always exists and is unique.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\nabcde', 'output': ['edcba']}, {'input': '6\\nfedcba', 'output': ['abcdef']}, {'input': '7\\nhgfedcb', 'output': ['abcdefgh']}, {'input': '8\\nihgfedcb', 'output': ['abcdefghi']}, {'input': '9\\njihgfedcb', 'output': ['abcdefghij']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"0 0 0 0 9\\n0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n7 0 0 0 0\", \"0 43 21 18 2\\n3 0 21 11 65\\n5 2 0 1 4\\n54 62 12 0 99\\n87 64 81 33 0\"]","prob_desc_input_spec":"The input consists of five lines, each line contains five space-separated integers: the j-th number in the i-th line shows gij (0\u2009\u2264\u2009gij\u2009\u2264\u2009105). It is guaranteed that gii\u2009=\u20090 for all i. Assume that the students are numbered from 1 to 5.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\npublic class Temp3 {\n\tpublic static void main(String[] args) throws Throwable {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint[][] arr = new int[5][5];\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tfor (int j = 0; j < arr.length; j++) {\n\t\t\t\tarr[i][j] = Integer.parseInt(st.nextToken());\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int a = 0; a < 5; a++) \n\t\t{\n\t\t\tfor (int b = 0; b < 5; b++)\n\t\t\t{\n\t\t\t\tif(b==a )\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int c = 0; c < 5; c++) \n\t\t\t\t{\n\t\t\t\t\tif(c==a || c==b )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int d = 0; d < 5; d++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(d==a || d==b || d==c )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int e = 0; e < 5; e++) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(e==a || e==b || e==c || e==d )\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tlong cur = arr[a][b] + arr[b][a] + arr[c][d] + arr[d][c];\n\t\t\t\t\t\t\t\t cur+= arr[b][c] + arr[c][b] + arr[d][e] + arr[e][d];\n\t\t\t\t\t\t\t\t cur+= arr[d][c] + arr[c][d];\n\t\t\t\t\t\t\t\t cur+= arr[e][d] + arr[d][e];\n\t\t\t\t\t\t\tans = Math.max(ans, cur);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n","prob_desc_sample_outputs":"[\"32\", \"620\"]","lang_cluster":"Java","code_uid":"4c82f84bb04eecfb71da878b973f0c1d","prob_desc_notes":"NoteIn the first sample, the optimal arrangement of the line is 23154. In this case, the total happiness equals:(g23\u2009+\u2009g32\u2009+\u2009g15\u2009+\u2009g51)\u2009+\u2009(g13\u2009+\u2009g31\u2009+\u2009g54\u2009+\u2009g45)\u2009+\u2009(g15\u2009+\u2009g51)\u2009+\u2009(g54\u2009+\u2009g45)\u2009=\u200932.","prob_desc_output_spec":"Print a single integer \u2014 the maximum possible total happiness of the students.","prob_desc_output_to":"standard output","prob_desc_description":"Many students live in a dormitory. A dormitory is a whole new world of funny amusements and possibilities but it does have its drawbacks. There is only one shower and there are multiple students who wish to have a shower in the morning. That's why every morning there is a line of five people in front of the dormitory shower door. As soon as the shower opens, the first person from the line enters the shower. After a while the first person leaves the shower and the next person enters the shower. The process continues until everybody in the line has a shower.Having a shower takes some time, so the students in the line talk as they wait. At each moment of time the students talk in pairs: the (2i\u2009-\u20091)-th man in the line (for the current moment) talks with the (2i)-th one. Let's look at this process in more detail. Let's number the people from 1 to 5. Let's assume that the line initially looks as 23154 (person number 2 stands at the beginning of the line). Then, before the shower opens, 2 talks with 3, 1 talks with 5, 4 doesn't talk with anyone. Then 2 enters the shower. While 2 has a shower, 3 and 1 talk, 5 and 4 talk too. Then, 3 enters the shower. While 3 has a shower, 1 and 5 talk, 4 doesn't talk to anyone. Then 1 enters the shower and while he is there, 5 and 4 talk. Then 5 enters the shower, and then 4 enters the shower.We know that if students i and j talk, then the i-th student's happiness increases by gij and the j-th student's happiness increases by gji. Your task is to find such initial order of students in the line that the total happiness of all students will be maximum in the end. Please note that some pair of students may have a talk several times. In the example above students 1 and 5 talk while they wait for the shower to open and while 3 has a shower.","length":45,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0\\n0 0 0 0 0', 'output': ['0']}, {'input': '1 1 1 1 1\\n1 1 1 1 1\\n1 1 1 1 1\\n1 1 1 1 1\\n1 1 1 1 1', 'output': ['16']}, {'input': '0 1 2 3 4\\n5 0 6 7 8\\n9 10 0 11 12\\n13 14 15 0 16\\n17 18 19 20 0', 'output': ['86']}, {'input': '0 10 20 30 40\\n50 0 60 70 80\\n90 100 0 110 120\\n130 140 150 0 160\\n170 180 190 200 0', 'output': ['860']}, {'input': '0 10000 20000 30000 40000\\n50000 0 60000 70000 80000\\n90000 100000 0 110000 120000\\n130000 140000 150000 0 160000\\n170000 180000 190000 200000 0', 'output': ['860000']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"8.549e2\", \"8.549e3\", \"0.33e0\"]","prob_desc_input_spec":"The first and only line of input contains a single string of form a.deb where a, d and b are integers and e is usual character 'e' (0\u2009\u2264\u2009a\u2009\u2264\u20099,\u20090\u2009\u2264\u2009d\u2009&lt;\u200910100,\u20090\u2009\u2264\u2009b\u2009\u2264\u2009100)\u00a0\u2014 the scientific notation of the desired distance value. a and b contain no leading zeros and d contains no trailing zeros (but may be equal to 0). Also, b can not be non-zero if a is zero.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\/**\n * Created by kaaveh on 7\/29\/16.\n *\/\npublic class _697B_ {\n    public static void main(String[] args) throws IOException {\n\n        char tmp;\n        int num;\n        int zero;\n        ArrayList<Character> data = new ArrayList<>();\n        kaaveh in = new kaaveh();\n\n        System.out.print((char) System.in.read());\n        System.in.read();\n\n        while(true){\n            tmp = (char) System.in.read();\n            if (tmp == 'e'){\n                break;\n            } else {\n                data.add(tmp);\n            }\n        }\n\n        num = in.kint();\n        zero =num - data.size();\n        if (num > data.size())\n            num = data.size();\n        for (int i=0; i<num; i++){\n            System.out.print(data.get(i));\n        }\n        if ((data.size() - num)!=0 && !(data.size() ==1 && data.get(0)=='0'))\n            System.out.print('.');\n\n        if (!(data.size() ==1 && data.get(0)=='0'))\n            for (int i= num; i<data.size(); i++){\n                System.out.print(data.get(i));\n            }\n\n        while (zero > 0){\n            System.out.print('0');\n            zero--;\n        }\n    }\n}\n\nclass kaaveh {\n    static String kLine(int maxLg) {\n        byte lin[] = new byte[maxLg];\n        int lg = 0, car = -1;\n        String line = \"\";\n\n        try {\n            while (lg < maxLg) {\n                car = System.in.read();\n                if ((car < 0) || (car == '\\n') || (car == '\\r')) break;\n                lin[lg++] += car;\n            }\n        } catch (IOException e) {\n            return (null);\n        }\n\n        if ((car < 0) && (lg == 0)) return (null);  \/\/ eof\n        return (new String(lin, 0, lg));\n    }\n\n    static String knex(int maxLg) {\n        byte lin[] = new byte[maxLg];\n        int lg = 0, car = -1;\n        String line = \"\";\n\n        try {\n\n            while ((car < 0) || (car == '\\n') || (car == ' ') || (car == '\\t') || (car == '\\r'))\n                car = System.in.read();\n\n            while (lg < maxLg) {\n                if ((car < 0) || (car == '\\n') || (car == ' ') || (car == '\\t') || (car == '\\r')) break;\n                lin[lg++] += car;\n                car = System.in.read();\n            }\n        } catch (IOException e) {\n            return (null);\n        }\n\n        if ((car < 0) && (lg == 0)) return (null);  \/\/ eof\n        return (new String(lin, 0, lg));\n    }\n\n    static int kint() {\n        return Integer.parseInt(knex(11));\n    }\n\n    static long kLong() {\n        return Long.parseLong(knex(20));\n    }\n\n    static double kdouble() {\n        return Double.parseDouble(knex(100));\n    }\n}","prob_desc_sample_outputs":"[\"854.9\", \"8549\", \"0.33\"]","lang_cluster":"Java","code_uid":"28edecddfde5fe488a99740254e4b6bc","prob_desc_notes":null,"prob_desc_output_spec":"Print the only real number x (the desired distance value) in the only line in its decimal notation.  Thus if x is an integer, print it's integer value without decimal part and decimal point and without leading zeroes.  Otherwise print x in a form of p.q such that p is an integer that have no leading zeroes (but may be equal to zero), and q is an integer that have no trailing zeroes (and may not be equal to zero).","prob_desc_output_to":"standard output","prob_desc_description":"Barney is standing in a bar and starring at a pretty girl. He wants to shoot her with his heart arrow but he needs to know the distance between him and the girl to make his shot accurate.  Barney asked the bar tender Carl about this distance value, but Carl was so busy talking to the customers so he wrote the distance value (it's a real number) on a napkin. The problem is that he wrote it in scientific notation. The scientific notation of some real number x is the notation of form AeB, where A is a real number and B is an integer and x\u2009=\u2009A\u2009\u00d7\u200910B is true. In our case A is between 0 and 9 and B is non-negative.Barney doesn't know anything about scientific notation (as well as anything scientific at all). So he asked you to tell him the distance value in usual decimal representation with minimal number of digits after the decimal point (and no decimal point if it is an integer). See the output format for better understanding.","length":105,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1.234e2', 'output': ['123.4']}, {'input': '9.876e0', 'output': ['9.876']}, {'input': '0.123e3', 'output': ['123']}, {'input': '5.678e1', 'output': ['56.78']}, {'input': '4.321e4', 'output': ['43210']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"11\\n00000000008\", \"22\\n0011223344556677889988\", \"11\\n31415926535\"]","prob_desc_input_spec":"The first line contains an integer $$$n$$$\u00a0\u2014 the number of cards with digits that you have ($$$1 \\leq n \\leq 100$$$). The second line contains a string of $$$n$$$ digits (characters \"0\", \"1\", ..., \"9\") $$$s_1, s_2, \\ldots, s_n$$$. The string will not contain any other characters, such as leading or trailing spaces.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class PhoneNumbers {\n\n\tvoid solve(Scanner s, PrintWriter out) {\n\t\ts.next();\n\t\tint e = 0, o = 0;\n\t\tfor (char c : s.next().toCharArray())\n\t\t\tif (c == '8')\n\t\t\t\te++;\n\t\t\telse\n\t\t\t\to++;\n\t\tout.println(Math.min(e, (o + e) \/ 11));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tnew PhoneNumbers().solve(s, out);\n\t\tout.close();\n\t\ts.close();\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"1\", \"2\", \"0\"]","lang_cluster":"Java","code_uid":"a01207ee0161127628f9b9182f1eb4ee","prob_desc_notes":"NoteIn the first example, one phone number, \"8000000000\", can be made from these cards.In the second example, you can make two phone numbers from the cards, for example, \"80123456789\" and \"80123456789\".In the third example you can't make any phone number from the given cards.","prob_desc_output_spec":"If at least one phone number can be made from these cards, output the maximum number of phone numbers that can be made. Otherwise, output 0.","prob_desc_output_to":"standard output","prob_desc_description":"Let's call a string a phone number if it has length 11 and fits the pattern \"8xxxxxxxxxx\", where each \"x\" is replaced by a digit.For example, \"80123456789\" and \"80000000000\" are phone numbers, while \"8012345678\" and \"79000000000\" are not.You have $$$n$$$ cards with digits, and you want to use them to make as many phone numbers as possible. Each card must be used in at most one phone number, and you don't have to use all cards. The phone numbers do not necessarily have to be distinct.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '11\\n88888888888', 'output': ['1\\n']}, {'input': '22\\n8888888888888888888888', 'output': ['2\\n']}, {'input': '33\\n888888888888888888888888888888888', 'output': ['3\\n']}, {'input': '44\\n88888888888888888888888888888888888888888888', 'output': ['4\\n']}, {'input': '55\\n88888888888888888888888888888888888888888888888888888', 'output': ['5\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":900.0,"prob_desc_time_limit":"0.5 second","prob_desc_sample_inputs":"[\"7 3\\n5 10\\n2 5\\n3 6\", \"3 3\\n1 3\\n2 2\\n3 1\"]","prob_desc_input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u20092\u00b7108) and integer m (1\u2009\u2264\u2009m\u2009\u2264\u200920). The i\u2009+\u20091-th line contains a pair of numbers ai and bi (1\u2009\u2264\u2009ai\u2009\u2264\u2009108,\u20091\u2009\u2264\u2009bi\u2009\u2264\u200910). All the input numbers are integer.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport static java.util.Collections.reverseOrder;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n\/**\n *\n * @author Ahmed_Naser\n *\/\npublic class HelloWorld {\n\n  \n    \n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        \n        int matchboxes[] = new int[m];\n        int matches[]= new int[m];\n        \n        for(int i = 0 ; i < m ; i++)\n        {\n            matchboxes[i] =in.nextInt();\n            matches[i] = in.nextInt();\n        }\n        \n        \n        int max = matches[0];\n        int index = 0 ; \n        int count = 0 ;\n        while( n > 0)\n        {\n         \n           for( int j = 0 ; j < m ; ++j)\n        {\n            if( matches[j] >= max)\n            {\n                max= matches[j];  \n                index = j;\n              \n            }   \n        } \n           if(  matchboxes[index] <= n)\n           {\n               n = n - matchboxes[index];\n               count = count + (matches[index] * matchboxes[index] ); \n               matches[index] = 0 ;\n           }\n           else\n           {\n               \n               count = count + (n * matches[index]);\n               n = 0 ;\n           }\n           max = matches[0];\n        }\n        \n        System.out.println(count);\n        \n    }\n}\n","prob_desc_sample_outputs":"[\"62\", \"7\"]","lang_cluster":"Java","code_uid":"3681e67415541947c7eef6b74e6654a3","prob_desc_notes":null,"prob_desc_output_spec":"Output the only number \u2014 answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"A burglar got into a matches warehouse and wants to steal as many matches as possible. In the warehouse there are m containers, in the i-th container there are ai matchboxes, and each matchbox contains bi matches. All the matchboxes are of the same size. The burglar's rucksack can hold n matchboxes exactly. Your task is to find out the maximum amount of matches that a burglar can carry away. He has no time to rearrange matches in the matchboxes, that's why he just chooses not more than n matchboxes so that the total amount of matches in them is maximal.","length":73,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 2\\n5 10\\n5 5', 'output': ['75\\n']}, {'input': '5 3\\n2 10\\n2 5\\n1 3', 'output': ['35\\n']}, {'input': '7 1\\n7 7', 'output': ['49\\n']}, {'input': '8 3\\n3 8\\n3 7\\n2 6', 'output': ['59\\n']}, {'input': '6 2\\n3 5\\n3 4', 'output': ['27\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 5 2\", \"6 7 4\"]","prob_desc_input_spec":"A single line contains three space-separated integers a, b, r (1\u2009\u2264\u2009a,\u2009b,\u2009r\u2009\u2264\u2009100) \u2014 the table sides and the plates' radius, correspondingly.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/\/package com.example.hackerranksolutions;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class CodeforcesProblems {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] inputs = br.readLine().split(\" \");\n        int a = Integer.parseInt(inputs[0]);\n        int b = Integer.parseInt(inputs[1]);\n        int r = Integer.parseInt(inputs[2]);\n\n        if(a>=2*r && b>=2*r) System.out.println(\"First\");\n        else System.out.println(\"Second\");\n    }\n}","prob_desc_sample_outputs":"[\"First\", \"Second\"]","lang_cluster":"Java","code_uid":"74ffa3cbcb44042fabeac82c71c6d750","prob_desc_notes":"NoteIn the first sample the table has place for only one plate. The first player puts a plate on the table, the second player can't do that and loses.  In the second sample the table is so small that it doesn't have enough place even for one plate. So the first player loses without making a single move.  ","prob_desc_output_spec":"If wins the player who moves first, print \"First\" (without the quotes). Otherwise print \"Second\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"You've got a rectangular table with length a and width b and the infinite number of plates of radius r. Two players play the following game: they take turns to put the plates on the table so that the plates don't lie on each other (but they can touch each other), and so that any point on any plate is located within the table's border. During the game one cannot move the plates that already lie on the table. The player who cannot make another move loses. Determine which player wins, the one who moves first or the one who moves second, provided that both players play optimally well.","length":32,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 10 3', 'output': ['First']}, {'input': '1 1 1', 'output': ['Second']}, {'input': '20 30 10', 'output': ['First']}, {'input': '100 100 51', 'output': ['Second']}, {'input': '50 50 25', 'output': ['First']}]"}
{"prob_desc_memory_limit":"128 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\", \"4\"]","prob_desc_input_spec":"A single line contains one non-negative integer $$$n$$$ ($$$0 \\le n \\leq 10^{18}$$$)\u00a0\u2014 the number of Shiro's friends. The circular pizza has to be sliced into $$$n + 1$$$ pieces.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n \npublic class Main {\n \n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\t\n\t\t\/\/inputs\n\t\tlong n = input.nextLong();\n                if(n == 0)\n                    System.out.println(0);\n                else if((n + 1) % 2 == 0)\n                    System.out.println((n + 1) \/ 2);\n                else\n                    System.out.println(n + 1);\n\t}\n}","prob_desc_sample_outputs":"[\"2\", \"5\"]","lang_cluster":"Java","code_uid":"727a5daf7d4e53929fba30c9fbea92f3","prob_desc_notes":"NoteTo cut the round pizza into quarters one has to make two cuts through the center with angle $$$90^{\\circ}$$$ between them.To cut the round pizza into five equal parts one has to make five cuts.","prob_desc_output_spec":"A single integer\u00a0\u2014 the number of straight cuts Shiro needs.","prob_desc_output_to":"standard output","prob_desc_description":"Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.Today is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.She has ordered a very big round pizza, in order to serve her many friends. Exactly $$$n$$$ of Shiro's friends are here. That's why she has to divide the pizza into $$$n + 1$$$ slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.Shiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.As usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0', 'output': ['0']}, {'input': '1', 'output': ['2']}, {'input': '2', 'output': ['2']}, {'input': '5', 'output': ['6']}, {'input': '10', 'output': ['6']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"^ &gt;\\n1\", \"&lt; ^\\n3\", \"^ v\\n6\"]","prob_desc_input_spec":"There are two characters in the first string\u00a0\u2013 the starting and the ending position of a spinner. The position is encoded with one of the following characters: v (ASCII code 118, lowercase v), &lt; (ASCII code 60), ^ (ASCII code 94) or &gt; (ASCII code 62) (see the picture above for reference). Characters are separated by a single space. In the second strings, a single number n is given (0\u2009\u2264\u2009n\u2009\u2264\u2009109)\u00a0\u2013 the duration of the rotation. It is guaranteed that the ending position of a spinner is a result of a n second spin in any of the directions, assuming the given starting position.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author pigsoft\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            String a = in.nextLine();\n            int n = in.nextInt();\n            String cw = \"^>v<\";\n            String ccw = \"^<v>\";\n            boolean iscw = false;\n            boolean isccw = false;\n\n            int id = 0;\n            for (int i = 0; i < 4; i++) {\n                if (a.charAt(0) == cw.charAt(i))\n                    id = i;\n            }\n            id = (id + n) % 4;\n\n            if (cw.charAt(id) == a.charAt(2)) {\n                iscw = true;\n            }\n\n            id = 0;\n            for (int i = 0; i < 4; i++) {\n                if (a.charAt(0) == ccw.charAt(i))\n                    id = i;\n            }\n            id = (id + n) % 4;\n            if (ccw.charAt(id) == a.charAt(2)) {\n                isccw = true;\n            }\n\n            if (iscw == isccw)\n                out.print(\"undefined\");\n            else if (iscw)\n                out.print(\"cw\");\n            else\n                out.print(\"ccw\");\n        }\n\n    }\n}\n\n","prob_desc_sample_outputs":"[\"cw\", \"ccw\", \"undefined\"]","lang_cluster":"Java","code_uid":"97905205e168b875cbd7eb9b46901b10","prob_desc_notes":null,"prob_desc_output_spec":"Output cw, if the direction is clockwise, ccw\u00a0\u2013 if counter-clockwise, and undefined otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"  Walking through the streets of Marshmallow City, Slastyona have spotted some merchants selling a kind of useless toy which is very popular nowadays\u00a0\u2013 caramel spinner! Wanting to join the craze, she has immediately bought the strange contraption.Spinners in Sweetland have the form of V-shaped pieces of caramel. Each spinner can, well, spin around an invisible magic axis. At a specific point in time, a spinner can take 4 positions shown below (each one rotated 90 degrees relative to the previous, with the fourth one followed by the first one):  After the spinner was spun, it starts its rotation, which is described by a following algorithm: the spinner maintains its position for a second then majestically switches to the next position in clockwise or counter-clockwise order, depending on the direction the spinner was spun in.Slastyona managed to have spinner rotating for exactly n seconds. Being fascinated by elegance of the process, she completely forgot the direction the spinner was spun in! Lucky for her, she managed to recall the starting position, and wants to deduct the direction given the information she knows. Help her do this.","length":64,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '^ >\\n2', 'output': ['ccw\\n']}, {'input': '< v\\n4', 'output': ['undefined\\n']}, {'input': 'v <\\n1', 'output': ['cw\\n']}, {'input': '> ^\\n3', 'output': ['cw\\n']}, {'input': 'v ^\\n0', 'output': ['undefined\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1001\", \"1\\n1\"]","prob_desc_input_spec":"The first line contains integer number n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the length of string s. The second line contains the string s consisting of characters \"0\" and \"1\". It is guaranteed that the string s is correct.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/\/package codeforces;\n\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint len = sc.nextInt();\n\t\tString str = sc.next();\n\t\tif (len < 2) {\n\t\t\tSystem.out.println(str);\n\t\t} else {\n\t\t\tString[] str_char = str.split(\"\");\n\t\t\tStringBuffer sb = new StringBuffer(\"1\");\n\t\t\tfor (int i = 0; i < str_char.length; i++) {\n\t\t\t\tif(str_char[i].equals(\"0\")){\n\t\t\t\t\tsb.append(\"0\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sb);\n\t\t}\n\t\t\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"100\", \"1\"]","lang_cluster":"Java","code_uid":"135bec62ee09369bdbdfa6e2bd026117","prob_desc_notes":"NoteIn the first example you can obtain the answer by the following sequence of operations: \"1001\"  \"1010\"  \"1100\"  \"100\".In the second example you can't obtain smaller answer no matter what operations you use.","prob_desc_output_spec":"Print one string \u2014 the minimum correct string that you can obtain from the given one.","prob_desc_output_to":"standard output","prob_desc_description":"String can be called correct if it consists of characters \"0\" and \"1\" and there are no redundant leading zeroes. Here are some examples: \"0\", \"10\", \"1001\".You are given a correct string s.You can perform two different operations on this string:   swap any pair of adjacent characters (for example, \"101\"  \"110\");  replace \"11\" with \"1\" (for example, \"110\"  \"10\"). Let val(s) be such a number that s is its binary representation.Correct string a is less than some other correct string b iff val(a)\u2009&lt;\u2009val(b).Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","length":26,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n11011', 'output': ['10000']}, {'input': '3\\n101', 'output': ['100']}, {'input': '6\\n101010', 'output': ['100000']}, {'input': '2\\n10', 'output': ['10']}, {'input': '1\\n0', 'output': ['0']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1100.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"3000\"]","prob_desc_input_spec":"The only line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the prediction on the number of people who will buy the game.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class Divisibility {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tdouble a = sc.nextDouble();\n\t\tdouble ans = Math.floor(a\/2520);\n\n\t\tSystem.out.printf(\"%.0f\",ans);\n\n\t}\n\n}","prob_desc_sample_outputs":"[\"1\"]","lang_cluster":"Java","code_uid":"aa8a180c0397e093163d1aaa66efa1fb","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer showing how many numbers from 1 to n are divisible by all numbers from 2 to 10.","prob_desc_output_to":"standard output","prob_desc_description":"IT City company developing computer games invented a new way to reward its employees. After a new game release users start buying it actively, and the company tracks the number of sales with precision to each transaction. Every time when the next number of sales is divisible by all numbers from 2 to 10 every developer of this game gets a small bonus.A game designer Petya knows that the company is just about to release a new game that was partly developed by him. On the basis of his experience he predicts that n people will buy the game during the first month. Now Petya wants to determine how many times he will get the bonus. Help him to know it.","length":16,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2520', 'output': ['1']}, {'input': '5040', 'output': ['2']}, {'input': '10000', 'output': ['3']}, {'input': '50000', 'output': ['19']}, {'input': '100000', 'output': ['39']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"5\\nabaca\", \"8\\nabcddcba\"]","prob_desc_input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 500$$$) \u2014 the length of string $$$s$$$. The second line contains the string $$$s$$$ ($$$|s| = n$$$) consisting of lowercase Latin letters.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\nimport java.io.*;\npublic class code{\n    public static void main(String[] args)throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] c = sc.next().toCharArray();\n        int[] d = new int[n];\n        for(int i=0;i<n;i++) d[i] = (int)c[i];\n        Coloring col = new Coloring(n,d);\n        int res = col.get(0,n);\n        System.out.println(res);\n    }\n    \n    \n    \n    public static class Coloring{\n        int[][] dp;\n        int[] q;\n        int n;\n        int[] c;\n        Coloring(int l,int[] tab){\n            buildColor(l,tab);\n            dp = new int[n][n];\n            for(int i=0;i<n;i++) dp[i][i] = 1;\n            for(int i=1;i<n;i++){\n                for(int j=0;j<n-i;j++){\n                    regle(dp,j,j+i);\n                }\n            }\n        }\n        void buildColor(int n,int[] tab){\n            int[] d = new int[n];\n            q = new int[n];\n            int cnt = 0;\n            int l = 1;\n            d[0] = tab[0];\n            for(int i=1;i<n;i++){\n                q[i] = i-cnt;\n                if(tab[i]==tab[i-1]){\n                    cnt++;\n                    q[i]--;\n                    continue;\n                }\n                d[l] = tab[i];\n                l++;\n            }\n            this.n = l;\n            c = new int[l];\n            for(int i=0;i<l;i++) c[i] = d[i];\n        }\n        void regle(int[][] dp,int l,int r){\n            dp[l][r] = Math.min(dp[l][r-1]+1,dp[l+1][r]+1);\n            if(c[l]==c[l+1]||c[l]==c[r]) dp[l][r] = Math.min(dp[l][r],dp[l+1][r]);\n            if(c[r]==c[r-1]||c[r]==c[l]) dp[l][r] = Math.min(dp[l][r],dp[l][r-1]);\n            for(int i=l+2;i<r;i++){\n                if(c[l]==c[i]){\n                    dp[l][r] = Math.min(dp[l][r],dp[l+1][i]+dp[i+1][r]);\n                }\n            }\n            for(int i=r-2;i>l;i--){\n                if(c[r]==c[i]){\n                    dp[l][r] = Math.min(dp[l][r],dp[l][i-1]+dp[i][r-1]);\n                }\n            }\n        }\n        int get(int l,int r){\n            return dp[q[l]][q[r-1]];\n        }\n    }\n\n}","prob_desc_sample_outputs":"[\"3\", \"4\"]","lang_cluster":"Java","code_uid":"8c68adbdc25fa0204fa57ebc11d37f57","prob_desc_notes":null,"prob_desc_output_spec":"Output a single integer \u2014 the minimal number of operation to delete string $$$s$$$.","prob_desc_output_to":"standard output","prob_desc_description":"You are given a string $$$s$$$ of length $$$n$$$ consisting of lowercase Latin letters. You may apply some operations to this string: in one operation you can delete some contiguous substring of this string, if all letters in the substring you delete are equal. For example, after deleting substring bbbb from string abbbbaccdd we get the string aaccdd.Calculate the minimum number of operations to delete the whole string $$$s$$$.","length":72,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\na', 'output': ['1\\n']}, {'input': '3\\naaa', 'output': ['1\\n']}, {'input': '5\\nabcde', 'output': ['5\\n']}, {'input': '6\\naabbaa', 'output': ['3\\n']}, {'input': '7\\nabccbaa', 'output': ['3\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"0 0 6 0 6 6 0 6\\n1 3 3 5 5 3 3 1\", \"0 0 6 0 6 6 0 6\\n7 3 9 5 11 3 9 1\", \"6 0 6 6 0 6 0 0\\n7 4 4 7 7 10 10 7\"]","prob_desc_input_spec":"The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order. The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees. All the values are integer and between $$$-100$$$ and $$$100$$$.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\nimport java.awt.Polygon;\nimport java.awt.geom.Line2D;\nimport java.util.Scanner;\npublic class Squares {\n\n\tpublic static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\nScanner in=new Scanner(System.in);\nint x1[]=new int[4];\nint x2[]=new int[4];\nint y1[]=new int[4];\nint y2[]=new int[4];boolean t=false;\nfor(int i=0;i<4;i++)\n{\n\tx1[i]=in.nextInt();\n\ty1[i]=in.nextInt();\n}\nfor(int i=0;i<4;i++)\n{\n\tx2[i]=in.nextInt();\n\ty2[i]=in.nextInt();\n}\nPolygon P=new Polygon(x1,y1,4);\nPolygon Q=new Polygon(x2,y2,4);\nLine2D a[]=new Line2D[4];\nLine2D b[]=new Line2D[4];\n\nfor(int i=0;i<4;i++)\n{\n\ta[i]=new Line2D.Double(x1[i],y1[i],x1[(i+1)%4],y1[(i+1)%4]);\n\tb[i]=new Line2D.Double(x2[i],y2[i],x2[(i+1)%4],y2[(i+1)%4]);\n}\n\nfor(int i=0;i<4;i++)\n{\n\tfor(int j=0;j<4;j++)\n\t{\n\t\tif(a[i].intersectsLine(b[j]))\n\t\t\t{t=true;break;}\n\t}\n\tif(t)\n\t\tbreak;\n}\nif(t==false)\nfor(int i=0;i<4;i++)\n{\n\tif(P.contains(x2[i],y2[i]))\n\t{t=true;break;}\n\tif(Q.contains(x1[i],y1[i]))\n\t{t=true;break;}\n}\nif(t)\n\tSystem.out.println(\"YES\");\nelse\n\tSystem.out.println(\"NO\");\nin.close();\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\"]","lang_cluster":"Java","code_uid":"bcc080b096cf7187cfdfd03f93787d78","prob_desc_notes":"NoteIn the first example the second square lies entirely within the first square, so they do intersect.In the second sample squares do not have any points in common.Here are images corresponding to the samples:      ","prob_desc_output_spec":"Print \"Yes\" if squares intersect, otherwise print \"No\". You can print each letter in any case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.","length":60,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 6 0 6 6 0 6\\n1 3 3 5 5 3 3 1', 'output': ['YES']}, {'input': '0 0 6 0 6 6 0 6\\n7 3 9 5 11 3 9 1', 'output': ['NO']}, {'input': '6 0 6 6 0 6 0 0\\n7 4 4 7 7 10 10 7', 'output': ['YES']}, {'input': '-10 -10 -10 10 10 10 10 -10\\n-5 -5 -5 5 5 5 5 -5', 'output': ['YES']}, {'input': '-10 -10 -10 10 10 10 10 -10\\n15 15 15 25 25 25 25 15', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 2\\n#G#T#\", \"6 1\\nT....G\", \"7 3\\nT..#..G\", \"6 2\\n..GT..\"]","prob_desc_input_spec":"The first line of the input contains two integers n and k (2\u2009\u2264\u2009n\u2009\u2264\u2009100, 1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009-\u20091)\u00a0\u2014 the number of cells in the line and the length of one grasshopper's jump. The second line contains a string of length n consisting of characters '.', '#', 'G' and 'T'. Character '.' means that the corresponding cell is empty, character '#' means that the corresponding cell contains an obstacle and grasshopper can't jump there. Character 'G' means that the grasshopper starts at this position and, finally, 'T' means that the target insect is located at this cell. It's guaranteed that characters 'G' and 'T' appear in this line exactly once.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class Problem2A {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] in = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(in[0]);\n\t\tint k = Integer.parseInt(in[1]);\n\t\tchar[] line = br.readLine().toCharArray();\n\t\tint start = -1;\n\t\tint end = -1;\n\t\tfor(int i=0; i<line.length; i++) {\n\t\t\tif(line[i] == 'G') {\n\t\t\t\tstart = i;\n\t\t\t}\n\t\t\tif(line[i] == 'T') {\n\t\t\t\tend = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(end < start) {\n\t\t\tint temp = end;\n\t\t\tend = start;\n\t\t\tstart = temp;\n\t\t}\n\t\t\n\t\tboolean valid = true;\n\t\t\n\t\tif((end-start) % k != 0)\n\t\t\tvalid = false;\n\t\t\n\t\tfor(int i=start + k; i<end && valid; i+= k) {\n\t\t\tif(line[i] != '.')\n\t\t\t\tvalid = false;\n\t\t}\n\n\t\tif(valid)\n\t\t\tSystem.out.println(\"YES\");\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\", \"NO\"]","lang_cluster":"Java","code_uid":"4c10f47ac244a61e6157269545f0485b","prob_desc_notes":"NoteIn the first sample, the grasshopper can make one jump to the right in order to get from cell 2 to cell 4.In the second sample, the grasshopper is only able to jump to neighboring cells but the way to the insect is free\u00a0\u2014 he can get there by jumping left 5 times.In the third sample, the grasshopper can't make a single jump.In the fourth sample, the grasshopper can only jump to the cells with odd indices, thus he won't be able to reach the insect.","prob_desc_output_spec":"If there exists a sequence of jumps (each jump of length k), such that the grasshopper can get from his initial position to the cell with the insect, print \"YES\" (without quotes) in the only line of the input. Otherwise, print \"NO\" (without quotes).","prob_desc_output_to":"standard output","prob_desc_description":"On the way to Rio de Janeiro Ostap kills time playing with a grasshopper he took with him in a special box. Ostap builds a line of length n such that some cells of this line are empty and some contain obstacles. Then, he places his grasshopper to one of the empty cells and a small insect in another empty cell. The grasshopper wants to eat the insect.Ostap knows that grasshopper is able to jump to any empty cell that is exactly k cells away from the current (to the left or to the right). Note that it doesn't matter whether intermediate cells are empty or not as the grasshopper makes a jump over them. For example, if k\u2009=\u20091 the grasshopper can jump to a neighboring cell only, and if k\u2009=\u20092 the grasshopper can jump over a single cell.Your goal is to determine whether there is a sequence of jumps such that grasshopper will get from his initial position to the cell with an insect.","length":45,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3\\n...G...T..', 'output': ['YES\\n']}, {'input': '10 3\\n...G.#.T..', 'output': ['NO\\n']}, {'input': '10 2\\n..G..T....', 'output': ['YES\\n']}, {'input': '10 2\\n..G.#T....', 'output': ['NO\\n']}, {'input': '10 1\\nG........T', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\\n10 5 0 -5 -10\", \"4\\n1 1 1 1\", \"3\\n5 1 -5\", \"2\\n900 1000\"]","prob_desc_input_spec":"The first line contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of days for which the average air temperature is known. The second line contains a sequence of integers t1,\u2009t2,\u2009...,\u2009tn (\u2009-\u20091000\u2009\u2264\u2009ti\u2009\u2264\u20091000)\u00a0\u2014 where ti is the average temperature in the i-th day.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tint solve(Scanner in, PrintWriter out)\n\t{\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tarr[i] = in.nextInt();\n\t\t\n\t\tif(n == 2)\n\t\t\tout.print(arr[1] + (arr[1] - arr[0]));\n\t\telse{\n\t\t\tint ans = 0;\n\t\t\tint step = arr[0] - arr[1]; \n\t\t\tfor(int i = 0; i < n-1; i++){\n\t\t\t\tif((arr[i] - arr[i+1]) == step)\n\t\t\t\t\tans = arr[n-1] +(arr[1] - arr[0]);\n\t\t\t\telse{\n\t\t\t\t\tans = arr[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.print(ans);\n\t\t}\n\t\t\n\t\t\treturn 0;\n\t\t\t\n\t}\n\n\tvoid run()\n\t{\n\t\ttry(\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tPrintWriter out = new PrintWriter(System.out)) {\n\t\t\n\t\t\tsolve(in, out);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"-15\", \"1\", \"-5\", \"1100\"]","lang_cluster":"Java","code_uid":"c77115e976d5caae929be12c1e7e17e6","prob_desc_notes":"NoteIn the first example the sequence of the average temperatures is an arithmetic progression where the first term is 10 and each following terms decreases by 5. So the predicted average temperature for the sixth day is \u2009-\u200910\u2009-\u20095\u2009=\u2009\u2009-\u200915.In the second example the sequence of the average temperatures is an arithmetic progression where the first term is 1 and each following terms equals to the previous one. So the predicted average temperature in the fifth day is 1.In the third example the average temperatures do not form an arithmetic progression, so the average temperature of the fourth day equals to the temperature of the third day and equals to \u2009-\u20095.In the fourth example the sequence of the average temperatures is an arithmetic progression where the first term is 900 and each the following terms increase by 100. So predicted average temperature in the third day is 1000\u2009+\u2009100\u2009=\u20091100.","prob_desc_output_spec":"Print the average air temperature in the (n\u2009+\u20091)-th day, which Vasya predicts according to his method. Note that the absolute value of the predicted temperature can exceed 1000.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya came up with his own weather forecasting method. He knows the information about the average air temperature for each of the last n days. Assume that the average air temperature for each day is integral.Vasya believes that if the average temperatures over the last n days form an arithmetic progression, where the first term equals to the average temperature on the first day, the second term equals to the average temperature on the second day and so on, then the average temperature of the next (n\u2009+\u20091)-th day will be equal to the next term of the arithmetic progression. Otherwise, according to Vasya's method, the temperature of the (n\u2009+\u20091)-th day will be equal to the temperature of the n-th day.Your task is to help Vasya predict the average temperature for tomorrow, i. e. for the (n\u2009+\u20091)-th day.","length":47,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n-1000 -500', 'output': ['0\\n']}, {'input': '3\\n0 0 0', 'output': ['0\\n']}, {'input': '5\\n1 2 3 4 5', 'output': ['6\\n']}, {'input': '4\\n-1 -2 -3 -4', 'output': ['-5\\n']}, {'input': '3\\n1000 500 -1000', 'output': ['-1000\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\\n3 4 5 6 7\", \"7\\n12 13 14 15 14 13 12\", \"1\\n8\"]","prob_desc_input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200992)\u00a0\u2014 the number of consecutive days Vitya was watching the size of the visible part of the moon.  The second line contains n integers ai (0\u2009\u2264\u2009ai\u2009\u2264\u200915)\u00a0\u2014 Vitya's records. It's guaranteed that the input data is consistent.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class Vitya {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint[] t = new int[n];\n\t\tfor (int i=0;i<n;i++) {\n\t\tt[i]=scanner.nextInt();\t\n\t\t}\n\t\tif (n==1) {if(t[0]==15) {System.out.println(\"DOWN\");}else if(t[0]==0) {System.out.println(\"UP\");}else{System.out.println(-1);} }\n\t\telse { if((t[n-2]<t[n-1]&& t[n-1]!=15)||t[n-1]==0) {System.out.println(\"UP\");}\n\t\telse{System.out.println(\"DOWN\");}\n\t\t}\n\t\t\n\n\t}\n\n}","prob_desc_sample_outputs":"[\"UP\", \"DOWN\", \"-1\"]","lang_cluster":"Java","code_uid":"16d478faa761d88f905679d18ab7663a","prob_desc_notes":"NoteIn the first sample, the size of the moon on the next day will be equal to 8, thus the answer is \"UP\".In the second sample, the size of the moon on the next day will be 11, thus the answer is \"DOWN\".In the third sample, there is no way to determine whether the size of the moon on the next day will be 7 or 9, thus the answer is -1.","prob_desc_output_spec":"If Vitya can be sure that the size of visible part of the moon on day n\u2009+\u20091 will be less than the size of the visible part on day n, then print \"DOWN\" at the only line of the output. If he might be sure that the size of the visible part will increase, then print \"UP\". If it's impossible to determine what exactly will happen with the moon, print -1.","prob_desc_output_to":"standard output","prob_desc_description":"Every summer Vitya comes to visit his grandmother in the countryside. This summer, he got a huge wart. Every grandma knows that one should treat warts when the moon goes down. Thus, Vitya has to catch the moment when the moon is down.Moon cycle lasts 30 days. The size of the visible part of the moon (in Vitya's units) for each day is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, and then cycle repeats, thus after the second 1 again goes 0.As there is no internet in the countryside, Vitya has been watching the moon for n consecutive days and for each of these days he wrote down the size of the visible part of the moon. Help him find out whether the moon will be up or down next day, or this cannot be determined by the data he has.","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3\\n1 2 3', 'output': ['UP\\n']}, {'input': '4\\n14 15 14 13', 'output': ['DOWN\\n']}, {'input': '1\\n0', 'output': ['UP\\n']}, {'input': '1\\n15', 'output': ['DOWN\\n']}, {'input': '2\\n5 6', 'output': ['UP\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\nZCTH\", \"5\\nZDATG\", \"6\\nAFBAKC\"]","prob_desc_input_spec":"The first line contains a single integer $$$n$$$ ($$$4 \\leq n \\leq 50$$$)\u00a0\u2014 the length of the string $$$s$$$. The second line contains the string $$$s$$$, consisting of exactly $$$n$$$ uppercase letters of the Latin alphabet.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\/**\n *\n * @author Lalo\n *\/\npublic class ContestSandbox {\n\n    \/**\n     * @param args the command line arguments\n     *\/\n    public static void main(String[] args) {\n        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int length = Integer.parseInt(in.nextLine());\n        String s = in.nextLine();\n        String genome = \"ACTG\";\n        int miniumChanges = 3215643;\n        Map<String, Integer> alphabet = new HashMap<>();\n\n        int a = 1;\n        for (char ch = 'A'; ch <= 'Z'; ch++) {\n            alphabet.put(String.valueOf(ch), a);\n            a++;\n        }\n\n        for (int i = 0; (i + 4) <= length; i++) {\n            int sum = 0;\n            for (int x = 0; x < 4; x++) {\n                if (Math.abs(alphabet.get(genome.substring(x, x + 1)) - alphabet.get(s.substring(i + x, i + x + 1))) <= 13) {\n                    sum += Math.abs(alphabet.get(genome.substring(x, x + 1)) - alphabet.get(s.substring(i + x, i + x + 1)));\n                } else if (alphabet.get(s.substring(i + x, i + x + 1)) > alphabet.get(genome.substring(x, x + 1))) {\n                    sum += (26 - alphabet.get(s.substring(i + x, i + x + 1)) + alphabet.get(genome.substring(x, x + 1)));\n                } else {\n                    sum += (26 - alphabet.get(genome.substring(x, x + 1)) + alphabet.get(s.substring(i + x, i + x + 1)));\n                }\n            }\n\n            if (sum < miniumChanges) {\n                miniumChanges = sum;\n            }\n        }\n\n        System.out.println(miniumChanges);\n    }\n\n}","prob_desc_sample_outputs":"[\"2\", \"5\", \"16\"]","lang_cluster":"Java","code_uid":"2209564d6053e13ea862817672453c80","prob_desc_notes":"NoteIn the first example, you should replace the letter \"Z\" with \"A\" for one operation, the letter \"H\"\u00a0\u2014 with the letter \"G\" for one operation. You will get the string \"ACTG\", in which the genome is present as a substring.In the second example, we replace the letter \"A\" with \"C\" for two operations, the letter \"D\"\u00a0\u2014 with the letter \"A\" for three operations. You will get the string \"ZACTG\", in which there is a genome.","prob_desc_output_spec":"Output the minimum number of operations that need to be applied to the string $$$s$$$ so that the genome appears as a substring in it.","prob_desc_output_to":"standard output","prob_desc_description":"Today in the scientific lyceum of the Kingdom of Kremland, there was a biology lesson. The topic of the lesson was the genomes. Let's call the genome the string \"ACTG\".Maxim was very boring to sit in class, so the teacher came up with a task for him: on a given string $$$s$$$ consisting of uppercase letters and length of at least $$$4$$$, you need to find the minimum number of operations that you need to apply, so that the genome appears in it as a substring. For one operation, you can replace any letter in the string $$$s$$$ with the next or previous in the alphabet. For example, for the letter \"D\" the previous one will be \"C\", and the next\u00a0\u2014 \"E\". In this problem, we assume that for the letter \"A\", the previous one will be the letter \"Z\", and the next one will be \"B\", and for the letter \"Z\", the previous one is the letter \"Y\", and the next one is the letter \"A\".Help Maxim solve the problem that the teacher gave him.A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.","length":50,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\nACTG', 'output': ['0\\n']}, {'input': '5\\nZACTG', 'output': ['1\\n']}, {'input': '6\\nZZZZZZ', 'output': ['22\\n']}, {'input': '7\\nABCDEFG', 'output': ['15\\n']}, {'input': '8\\nZZZZZZZZ', 'output': ['22\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 4 2\", \"5 5 5\", \"0 2 0\"]","prob_desc_input_spec":"The only line contains three integers l, r and a (0\u2009\u2264\u2009l,\u2009r,\u2009a\u2009\u2264\u2009100) \u2014 the number of left-handers, the number of right-handers and the number of ambidexters at the training. ","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/\/ Why do we fall ? So we can learn to pick ourselves up.\nimport java.util.*;\npublic class solve {\n    static int mod = 1000000007;\n    static int mod1 = 998244353;\n    public static void  main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int lll = sc.nextInt(),rrr = sc.nextInt(),a = sc.nextInt();\n        int l = Math.min(lll,rrr),r = Math.max(lll,rrr);\n        if(lll==rrr) System.out.println(2*(l+a\/2));\n        else {\n            int ll = Math.min(r-l,a);\n            l += ll;\n            int aa = a-ll;\n            System.out.println(2*(l+aa\/2));\n        }\n    }\n}","prob_desc_sample_outputs":"[\"6\", \"14\", \"0\"]","lang_cluster":"Java","code_uid":"efd03436dc3e3f98c37c9bc6d8fd4c35","prob_desc_notes":"NoteIn the first example you can form a team of 6 players. You should take the only left-hander and two ambidexters to play with left hand, and three right-handers to play with right hand. The only person left can't be taken into the team.In the second example you can form a team of 14 people. You have to take all five left-handers, all five right-handers, two ambidexters to play with left hand and two ambidexters to play with right hand.","prob_desc_output_spec":"Print a single even integer\u00a0\u2014 the maximum number of players in the team. It is possible that the team can only have zero number of players.","prob_desc_output_to":"standard output","prob_desc_description":"You are at a water bowling training. There are l people who play with their left hand, r people, who play with their right hand, and a ambidexters, who can play with left or right hand.The coach decided to form a team of even number of players, exactly half of the players should play with their right hand, and exactly half of the players should play with their left hand. One player should use only on of his hands.Ambidexters play as well with their right hand as with their left hand. In the team, an ambidexter can play with their left hand, or with their right hand.Please find the maximum possible size of the team, where equal number of players use their left and right hands, respectively.","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 10 10', 'output': ['30\\n']}, {'input': '0 0 0', 'output': ['0\\n']}, {'input': '50 50 50', 'output': ['150\\n']}, {'input': '100 100 100', 'output': ['300\\n']}, {'input': '1 1 1', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"7 3\\n3 5 7 1 6 2 8\\n1 2 7\", \"4 4\\n3 4 1 0\\n0 1 7 9\"]","prob_desc_input_spec":"The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 10$$$) representing the number of digits in the sequence you have and the number of keys on the keypad that have fingerprints. The next line contains $$$n$$$ distinct space-separated integers $$$x_1, x_2, \\ldots, x_n$$$ ($$$0 \\le x_i \\le 9$$$) representing the sequence. The next line contains $$$m$$$ distinct space-separated integers $$$y_1, y_2, \\ldots, y_m$$$ ($$$0 \\le y_i \\le 9$$$) \u2014 the keys with fingerprints.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\npublic class A\n{\n    public static void main(String[] args)\n    {\n        int n,m;\n        Scanner s = new Scanner(System.in);\n        n = s.nextInt();\n        m = s.nextInt();\n        int a[] = new int[n];\n        int b[] = new int[m];\n        for(int i = 0 ; i < n ; i++)\n        {\n            a[i] = s.nextInt();\n        }\n        for(int j = 0 ; j < m ; j++)\n        {\n            b[j] = s.nextInt();\n        }\n        for(int i1 = 0 ; i1 < n ; i1++)\n        {\n            for(int j1 = 0 ; j1 < m ; j1++)\n            {\n                if(a[i1] == b[j1])\n                {\n                    System.out.print(a[i1] + \" \");\n                }\n            }\n        }\n    }\n}","prob_desc_sample_outputs":"[\"7 1 2\", \"1 0\"]","lang_cluster":"Java","code_uid":"d93eb3e0bdf2a901ba323dfb12b50002","prob_desc_notes":"NoteIn the first example, the only digits with fingerprints are $$$1$$$, $$$2$$$ and $$$7$$$. All three of them appear in the sequence you know, $$$7$$$ first, then $$$1$$$ and then $$$2$$$. Therefore the output is 7 1 2. Note that the order is important, and shall be the same as the order in the original sequence.In the second example digits $$$0$$$, $$$1$$$, $$$7$$$ and $$$9$$$ have fingerprints, however only $$$0$$$ and $$$1$$$ appear in the original sequence. $$$1$$$ appears earlier, so the output is 1 0. Again, the order is important.","prob_desc_output_spec":"In a single line print a space-separated sequence of integers representing the code. If the resulting sequence is empty, both printing nothing and printing a single line break is acceptable.","prob_desc_output_to":"standard output","prob_desc_description":"You are locked in a room with a door that has a keypad with 10 keys corresponding to digits from 0 to 9. To escape from the room, you need to enter a correct code. You also have a sequence of digits.Some keys on the keypad have fingerprints. You believe the correct code is the longest not necessarily contiguous subsequence of the sequence you have that only contains digits with fingerprints on the corresponding keys. Find such code.","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2\\n0 1 2 3 4\\n1 3', 'output': ['1 3 ']}, {'input': '6 3\\n9 8 7 6 5 4\\n9 7 5', 'output': ['9 7 5 ']}, {'input': '4 1\\n0 1 2 3\\n0', 'output': ['0 ']}, {'input': '10 5\\n0 1 2 3 4 5 6 7 8 9\\n9 8 7 6 5', 'output': ['5 6 7 8 9 ']}, {'input': '3 3\\n2 1 0\\n0 1 2', 'output': ['2 1 0 ']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1.5 seconds","prob_desc_sample_inputs":"[\"1\", \"2\", \"3\"]","prob_desc_input_spec":"A single line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20094000).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        long[] equivalence_relations;\n        int[][] bc;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int MOD = 1000000007;\n\n            long ans = 0;\n            compute_equivalence_relations(N, MOD);\n            compute_binomial_coefficients(N, MOD);\n            for (int m = 0; m < N; m++) {\n                ans = (ans + equivalence_relations[m] * bc[N][N - m]) % MOD;\n            }\n\n            out.println(ans);\n        }\n\n        private void compute_binomial_coefficients(int N, int MOD) {\n            bc = new int[N + 1][N + 1];\n            for (int n = 1; n <= N; n++) {\n                for (int k = 0; k <= n; k++) {\n                    if (k == 0) bc[n][k] = 1;\n                    else if (n == k) bc[n][k] = 1;\n                    else bc[n][k] = (bc[n - 1][k - 1] + bc[n - 1][k]) % MOD;\n                }\n            }\n        }\n\n        private void compute_equivalence_relations(int N, int MOD) {\n            long dp[][] = new long[N + 1][N + 1];\n\n            dp[0][0] = 1;\n\n            for (int elems = 1; elems <= N; elems++) {\n                for (int classes = 1; classes <= elems; classes++) {\n                    dp[elems][classes] = (long) (classes) * dp[elems - 1][classes] + dp[elems - 1][classes - 1];\n                    dp[elems][classes] = dp[elems][classes] % MOD;\n                }\n            }\n\n            equivalence_relations = new long[N + 1];\n\n            for (int i = 0; i <= N; i++) {\n                long tmp = 0;\n                for (int j = 0; j <= i; j++) {\n                    tmp = (tmp + dp[i][j]) % MOD;\n                }\n                equivalence_relations[i] = tmp;\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","prob_desc_sample_outputs":"[\"1\", \"3\", \"10\"]","lang_cluster":"Java","code_uid":"7e9453a0ace44aa00204661c417d7314","prob_desc_notes":"NoteIf n\u2009=\u20091 there is only one such relation\u00a0\u2014 an empty one, i.e. . In other words, for a single element x of set A the following is hold: .If n\u2009=\u20092 there are three such relations. Let's assume that set A consists of two elements, x and y. Then the valid relations are , \u03c1\u2009=\u2009{(x,\u2009x)}, \u03c1\u2009=\u2009{(y,\u2009y)}. It is easy to see that the three listed binary relations are symmetric and transitive relations, but they are not equivalence relations.","prob_desc_output_spec":"In a single line print the answer to the problem modulo 109\u2009+\u20097.","prob_desc_output_to":"standard output","prob_desc_description":"Little Johnny has recently learned about set theory. Now he is studying binary relations. You've probably heard the term \"equivalence relation\". These relations are very important in many areas of mathematics. For example, the equality of the two numbers is an equivalence relation.A set \u03c1 of pairs (a,\u2009b) of elements of some set A is called a binary relation on set A. For two elements a and b of the set A we say that they are in relation \u03c1, if pair , in this case we use a notation .Binary relation is equivalence relation, if: It is reflexive (for any a it is true that ); It is symmetric (for any a, b it is true that if , then ); It is transitive (if  and , than ).Little Johnny is not completely a fool and he noticed that the first condition is not necessary! Here is his \"proof\":Take any two elements, a and b. If , then  (according to property (2)), which means  (according to property (3)).It's very simple, isn't it? However, you noticed that Johnny's \"proof\" is wrong, and decided to show him a lot of examples that prove him wrong.Here's your task: count the number of binary relations over a set of size n such that they are symmetric, transitive, but not an equivalence relations (i.e. they are not reflexive).Since their number may be very large (not 0, according to Little Johnny), print the remainder of integer division of this number by 109\u2009+\u20097.","length":106,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\n', 'output': ['35\\n']}, {'input': '5\\n', 'output': ['126\\n']}, {'input': '6\\n', 'output': ['462\\n']}, {'input': '7\\n', 'output': ['1716\\n']}, {'input': '8\\n', 'output': ['6435\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3\", \"4\"]","prob_desc_input_spec":"The first line contains single integer $$$n$$$ ($$$3 \\le n \\le 500$$$) \u2014 the number of vertices in the regular polygon.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\nimport java.io.*;\npublic class Solution\n{\n    public static void main(String []ks) throws Exception\n    {\n       BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        long n=Long.parseLong(bf.readLine());\n        long a=2,b=3;\n        long res=0;\n        for(int i=3;i<=n;i++)\n        {\n            res+=(a*b);\n            a++;\n            b++;\n        }\n        System.out.println(res);\n  }\n}","prob_desc_sample_outputs":"[\"6\", \"18\"]","lang_cluster":"Java","code_uid":"3d0625b6d77bbb587f117badc24e0e73","prob_desc_notes":"NoteAccording to Wiki: polygon triangulation is the decomposition of a polygonal area (simple polygon) $$$P$$$ into a set of triangles, i.\u2009e., finding a set of triangles with pairwise non-intersecting interiors whose union is $$$P$$$.In the first example the polygon is a triangle, so we don't need to cut it further, so the answer is $$$1 \\cdot 2 \\cdot 3 = 6$$$.In the second example the polygon is a rectangle, so it should be divided into two triangles. It's optimal to cut it using diagonal $$$1-3$$$ so answer is $$$1 \\cdot 2 \\cdot 3 + 1 \\cdot 3 \\cdot 4 = 6 + 12 = 18$$$.","prob_desc_output_spec":"Print one integer \u2014 the minimum weight among all triangulations of the given polygon.","prob_desc_output_to":"standard output","prob_desc_description":"You are given a regular polygon with $$$n$$$ vertices labeled from $$$1$$$ to $$$n$$$ in counter-clockwise order. The triangulation of a given polygon is a set of triangles such that each vertex of each triangle is a vertex of the initial polygon, there is no pair of triangles such that their intersection has non-zero area, and the total area of all triangles is equal to the area of the given polygon. The weight of a triangulation is the sum of weigths of triangles it consists of, where the weight of a triagle is denoted as the product of labels of its vertices.Calculate the minimum weight among all triangulations of the polygon.","length":19,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n', 'output': ['40\\n']}, {'input': '6\\n', 'output': ['90\\n']}, {'input': '7\\n', 'output': ['168\\n']}, {'input': '8\\n', 'output': ['280\\n']}, {'input': '9\\n', 'output': ['432\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 162\", \"4 42\", \"100 40021\"]","prob_desc_input_spec":"The first line contains two positive integers a and b (1\u2009\u2264\u2009a\u2009&lt;\u2009b\u2009\u2264\u2009109)\u00a0\u2014 the number which Vasily has and the number he wants to have.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\npublic class transformation { \n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int num1 = scan.nextInt();\n        int num2 = scan.nextInt(),k=num2;\n        ArrayList<Integer> arr = new ArrayList<>();\n        while(num2>num1){\n            if(num2%2==0){\n                num2=num2\/2;\n                arr.add(num2);\n            }\n            else if(num2%10==1){\n                num2=num2\/10;\n                arr.add(num2);\n            }\n            else\n                break;\n        }\n        if(num1==num2){\n            System.out.println(\"YES\");\n            System.out.println(arr.size()+1);\n            for(int i=arr.size()-1;i>=0;i--){\n                System.out.print(arr.get(i)+\" \");\n            }\n            System.out.print(k);\n        }\n        else\n            System.out.println(\"NO\");\n    }\n}\n","prob_desc_sample_outputs":"[\"YES\\n5\\n2 4 8 81 162\", \"NO\", \"YES\\n5\\n100 200 2001 4002 40021\"]","lang_cluster":"Java","code_uid":"1d72d908c655031dc103c2f884bede38","prob_desc_notes":null,"prob_desc_output_spec":"If there is no way to get b from a, print \"NO\" (without quotes). Otherwise print three lines. On the first line print \"YES\" (without quotes). The second line should contain single integer k\u00a0\u2014 the length of the transformation sequence. On the third line print the sequence of transformations x1,\u2009x2,\u2009...,\u2009xk, where:   x1 should be equal to a,  xk should be equal to b,  xi should be obtained from xi\u2009-\u20091 using any of two described operations (1\u2009&lt;\u2009i\u2009\u2264\u2009k).  If there are multiple answers, print any of them.","prob_desc_output_to":"standard output","prob_desc_description":"Vasily has a number a, which he wants to turn into a number b. For this purpose, he can do two types of operations:  multiply the current number by 2 (that is, replace the number x by 2\u00b7x);  append the digit 1 to the right of current number (that is, replace the number x by 10\u00b7x\u2009+\u20091). You need to help Vasily to transform the number a into the number b using only the operations described above, or find that it is impossible.Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform a into b.","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 33', 'output': ['NO\\n']}, {'input': '5 51', 'output': ['YES\\n2\\n5 51\\n']}, {'input': '7 71', 'output': ['YES\\n2\\n7 71\\n']}, {'input': '1 11', 'output': ['YES\\n2\\n1 11\\n']}, {'input': '6 61', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n5\\n6\\n3\\n1\\n2\", \"12\\n11\\n13\\n20\\n4\\n6\", \"17\\n14\\n5\\n21\\n15\\n17\"]","prob_desc_input_spec":"The first line contains one integer $$$a$$$ $$$(1 \\le a \\le 100\\,000)$$$ \u2014 the number of ties. The second line contains one integer $$$b$$$ $$$(1 \\le b \\le 100\\,000)$$$ \u2014 the number of scarves. The third line contains one integer $$$c$$$ $$$(1 \\le c \\le 100\\,000)$$$ \u2014 the number of vests. The fourth line contains one integer $$$d$$$ $$$(1 \\le d \\le 100\\,000)$$$ \u2014 the number of jackets. The fifth line contains one integer $$$e$$$ $$$(1 \\le e \\le 1\\,000)$$$ \u2014 the cost of one suit of the first type. The sixth line contains one integer $$$f$$$ $$$(1 \\le f \\le 1\\,000)$$$ \u2014 the cost of one suit of the second type.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/*package whatever \/\/do not write package name here *\/\n\nimport java.io.*;\nimport java.util.*;\n\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t    Scanner s = new Scanner(System.in);\n\t    int a = s.nextInt();\n\t    int b = s.nextInt();\n\t    int c = s.nextInt();\n\t    int d = s.nextInt();\n\t    int e = s.nextInt();\n\t    int f = s.nextInt();\n\t    int cost=0;\n\t    if(e<f) {\n\t        \n\t        int min = (int)Math.min(b,c);\n\t        min = (int)Math.min(min,d);\n\t        cost=min*f;\n\t        d=d-min;\n\t        if(d>0) {\n\t            cost=cost+(int)Math.min(a,d)*e; \n\t        }\n\t       \n\t        System.out.println(cost);\n\t    }\n\t    else {\n\t          int min = (int)Math.min(a,d);\n\t       \n\t        cost=min*e;\n\t       \n\t        d=d-min;\n\t        if(d>0) {\n\t            min = (int)Math.min(b,c);\n\t         \n\t        cost=cost+(int)Math.min(min,d)*f; \n\t        }\n\t        \n\t         System.out.println(cost);\n\t    }\n\t    \n\t}\n}","prob_desc_sample_outputs":"[\"6\", \"102\", \"325\"]","lang_cluster":"Java","code_uid":"0c4ffd9812aebaf69b823b7845f7cfa5","prob_desc_notes":"NoteIt is possible to compose three suits of the second type in the first example, and their total cost will be $$$6$$$. Since all jackets will be used, it's impossible to add anything to this set.The best course of action in the second example is to compose nine suits of the first type and eleven suits of the second type. The total cost is $$$9 \\cdot 4 + 11 \\cdot 6 = 102$$$.","prob_desc_output_spec":"Print one integer \u2014 the maximum total cost of some set of suits that can be composed from the delivered items. ","prob_desc_output_to":"standard output","prob_desc_description":"A new delivery of clothing has arrived today to the clothing store. This delivery consists of $$$a$$$ ties, $$$b$$$ scarves, $$$c$$$ vests and $$$d$$$ jackets.The store does not sell single clothing items \u2014 instead, it sells suits of two types:  a suit of the first type consists of one tie and one jacket;  a suit of the second type consists of one scarf, one vest and one jacket. Each suit of the first type costs $$$e$$$ coins, and each suit of the second type costs $$$f$$$ coins.Calculate the maximum possible cost of a set of suits that can be composed from the delivered clothing items. Note that one item cannot be used in more than one suit (though some items may be left unused).","length":44,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n10\\n10\\n10\\n10\\n10', 'output': ['200']}, {'input': '100000\\n100000\\n100000\\n100000\\n1000\\n1000', 'output': ['200000000']}, {'input': '1\\n1\\n1\\n1\\n1\\n1', 'output': ['2']}, {'input': '50000\\n50000\\n50000\\n50000\\n500\\n500', 'output': ['50000000']}, {'input': '1000\\n1000\\n1000\\n1000\\n100\\n100', 'output': ['200000']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"8\\nbacabcab\", \"4\\nbcda\", \"6\\nabbbbb\"]","prob_desc_input_spec":"The only line of the input contains one integer $$$|s|$$$ ($$$1 \\le |s| \\le 100$$$) \u2014 the length of $$$s$$$. The second line of the input contains one string $$$s$$$ consisting of $$$|s|$$$ lowercase Latin letters.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tString str = in.next();\n\t\tSystem.out.println(getAns(str, N));\n\t\tin.close();\n\t}\n\n\tpublic static int getAns(String str, int N) {\n\t\tint ans = 0;\n\t\tStringBuilder sb = new StringBuilder(str);\n\t\tfor (int i = 25; i >= 0; i--) {\n\t\t\tchar ch = (char) (97 + i);\n\t\t\tfor (int j = 0; j < sb.length(); j++) {\n\t\t\t\tif (sb.length() == 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar ch1 = sb.charAt(j);\n\t\t\t\tif (ch != ch1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\/\/\t\t\t\tSystem.out.println(j);\n\t\t\t\tif (j == 0 && ((int) ch - 1 == (int) sb.charAt(j + 1))) {\n\t\t\t\t\t\/\/System.out.println(\"leftMost \" + j);\n\t\t\t\t\tsb.deleteCharAt(j);\n\t\t\t\t\tans++;\n\t\t\t\t\tj -= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (j == sb.length() - 1 && ((int) ch - 1 == (int) sb.charAt(j - 1))) {\n\t\t\t\t\t\/\/System.out.println(\"rightMost \" + j);\n\t\t\t\t\tsb.deleteCharAt(j);\n\t\t\t\t\tans++;\n\t\t\t\t\tj -= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if ((j < sb.length() - 1 && (int) ch - 1 == (int) sb.charAt(j + 1))\n\t\t\t\t\t\t|| (j > 0 && (int) ch - 1 == (int) sb.charAt(j - 1))) {\n\t\t\t\t\t\/\/System.out.println(\"middle \" + j);\n\t\t\t\t\tsb.deleteCharAt(j);\n\t\t\t\t\tans++;\n\t\t\t\t\tj -= 2;\n\t\t\t\t\t\/\/System.out.println(\"middle \" + j + \" \" + sb.toString() + \" \" + sb.length());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\/\/System.out.println(sb.toString());\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"4\", \"3\", \"5\"]","lang_cluster":"Java","code_uid":"770d421bfb5c6df811ba45baa8e43a4a","prob_desc_notes":"NoteThe first example is described in the problem statement. Note that the sequence of moves provided in the statement is not the only, but it can be shown that the maximum possible answer to this test is $$$4$$$.In the second example, you can remove all but one character of $$$s$$$. The only possible answer follows.  During the first move, remove the third character $$$s_3=$$$ d, $$$s$$$ becomes bca.  During the second move, remove the second character $$$s_2=$$$ c, $$$s$$$ becomes ba.  And during the third move, remove the first character $$$s_1=$$$ b, $$$s$$$ becomes a. ","prob_desc_output_spec":"Print one integer \u2014 the maximum possible number of characters you can remove if you choose the sequence of moves optimally.","prob_desc_output_to":"standard output","prob_desc_description":"You are given a string $$$s$$$ consisting of lowercase Latin letters. Let the length of $$$s$$$ be $$$|s|$$$. You may perform several operations on this string.In one operation, you can choose some index $$$i$$$ and remove the $$$i$$$-th character of $$$s$$$ ($$$s_i$$$) if at least one of its adjacent characters is the previous letter in the Latin alphabet for $$$s_i$$$. For example, the previous letter for b is a, the previous letter for s is r, the letter a has no previous letters. Note that after each removal the length of the string decreases by one. So, the index $$$i$$$ should satisfy the condition $$$1 \\le i \\le |s|$$$ during each operation.For the character $$$s_i$$$ adjacent characters are $$$s_{i-1}$$$ and $$$s_{i+1}$$$. The first and the last characters of $$$s$$$ both have only one adjacent character (unless $$$|s| = 1$$$).Consider the following example. Let $$$s=$$$ bacabcab.  During the first move, you can remove the first character $$$s_1=$$$ b because $$$s_2=$$$ a. Then the string becomes $$$s=$$$ acabcab.  During the second move, you can remove the fifth character $$$s_5=$$$ c because $$$s_4=$$$ b. Then the string becomes $$$s=$$$ acabab.  During the third move, you can remove the sixth character $$$s_6=$$$'b' because $$$s_5=$$$ a. Then the string becomes $$$s=$$$ acaba.  During the fourth move, the only character you can remove is $$$s_4=$$$ b, because $$$s_3=$$$ a (or $$$s_5=$$$ a). The string becomes $$$s=$$$ acaa and you cannot do anything with it. Your task is to find the maximum possible number of characters you can remove if you choose the sequence of operations optimally.","length":55,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\nabcde', 'output': ['4']}, {'input': '3\\naaa', 'output': ['0']}, {'input': '10\\nabcdefghij', 'output': ['9']}, {'input': '6\\nabcabc', 'output': ['4']}, {'input': '7\\nabccbaa', 'output': ['5']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"21\", \"20\"]","prob_desc_input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n\/**\n *\n * @author arif_\n * @date\n * @algo\n * @difficulty\n *\/\npublic class CF_876C {\n    \/* START OF I\/O ROUTINE *\/\n    \/\/ PrintWriter for faster output\n    public static PrintWriter out;\n\n    \/\/ MyInputReader class for faster input\n    public static class MyInputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyInputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    } \/\/ end of class MyInputReader\n    \/* END OF I\/O ROUTINE *\/\n\n\n    public static void main(String[] args) {\n        MyInputReader in = new MyInputReader(System.in);\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = in.nextInt();\n\n        ArrayList<Integer> ans = new ArrayList<Integer>();\n        for (int i=81; i>=1; i--) {\n            if (i >= n) continue;\n\n            int x = n - i;\n            int sum = 0, y = x;\n            while (y > 0) {\n                sum += (y % 10);\n                y \/= 10;\n            }\n\n            if (sum+x == n) ans.add(x);\n        }\n\n        out.println(ans.size());\n        for (Integer a : ans) {\n            out.println(a);\n        }\n        out.close();\n    } \/\/ end of method main()\n} \/\/ end of class Main","prob_desc_sample_outputs":"[\"1\\n15\", \"0\"]","lang_cluster":"Java","code_uid":"19022bb77b10a26d5642bdcae654dfeb","prob_desc_notes":"NoteIn the first test case x\u2009=\u200915 there is only one variant: 15\u2009+\u20091\u2009+\u20095\u2009=\u200921.In the second test case there are no such x.","prob_desc_output_spec":"In the first line print one integer k\u00a0\u2014 number of different values of x satisfying the condition.  In next k lines print these values in ascending order.","prob_desc_output_to":"standard output","prob_desc_description":"Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system.Since the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova.","length":88,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '21\\n', 'output': ['1\\n15\\n']}, {'input': '20\\n', 'output': ['0\\n']}, {'input': '30\\n', 'output': ['1\\n24\\n']}, {'input': '1\\n', 'output': ['0\\n']}, {'input': '100\\n', 'output': ['1\\n86\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2\\n5\\n7\", \"4\\n7\\n13\", \"2\\n3\\n2\"]","prob_desc_input_spec":"The first line contains the positive integer a (1\u2009\u2264\u2009a\u2009\u2264\u20091000)\u00a0\u2014 the number of lemons Nikolay has.  The second line contains the positive integer b (1\u2009\u2264\u2009b\u2009\u2264\u20091000)\u00a0\u2014 the number of apples Nikolay has.  The third line contains the positive integer c (1\u2009\u2264\u2009c\u2009\u2264\u20091000)\u00a0\u2014 the number of pears Nikolay has.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class JavaApplication1 {\n\n    \/**\n     * @param args the command line arguments\n     *\/\n    public static void main(String[] args) {\n        \/\/ TODO code application logic here\n        Scanner scanner=new Scanner(System.in);\n        int lemon = scanner.nextInt();\n        int apple = scanner.nextInt();\n        int pear = scanner.nextInt();\n        \n         int result=0;\n        \n        for(int i=lemon;i>0;i--){\n             if(2*i<=apple&&4*i<=pear){\n                result=i+(2*i)+(4*i);\n                System.out.println(result+\"\");\n                return;\n            }else if(i==1){\n                 System.out.println(result+\"\");\n            }\n            \n        }\n\n    }\n    \n}\n","prob_desc_sample_outputs":"[\"7\", \"21\", \"0\"]","lang_cluster":"Java","code_uid":"c8d5752ea3fbf41ba020151f0c524fb8","prob_desc_notes":"NoteIn the first example Nikolay can use 1 lemon, 2 apples and 4 pears, so the answer is 1\u2009+\u20092\u2009+\u20094\u2009=\u20097.In the second example Nikolay can use 3 lemons, 6 apples and 12 pears, so the answer is 3\u2009+\u20096\u2009+\u200912\u2009=\u200921.In the third example Nikolay don't have enough pears to cook any compote, so the answer is 0. ","prob_desc_output_spec":"Print the maximum total number of lemons, apples and pears from which Nikolay can cook the compote.","prob_desc_output_to":"standard output","prob_desc_description":"Nikolay has a lemons, b apples and c pears. He decided to cook a compote. According to the recipe the fruits should be in the ratio 1:\u20092:\u20094. It means that for each lemon in the compote should be exactly 2 apples and exactly 4 pears. You can't crumble up, break up or cut these fruits into pieces. These fruits\u00a0\u2014 lemons, apples and pears\u00a0\u2014 should be put in the compote as whole fruits.Your task is to determine the maximum total number of lemons, apples and pears from which Nikolay can cook the compote. It is possible that Nikolay can't use any fruits, in this case print 0. ","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n2\\n4', 'output': ['7\\n']}, {'input': '3\\n6\\n12', 'output': ['21\\n']}, {'input': '2\\n3\\n2', 'output': ['0\\n']}, {'input': '5\\n10\\n20', 'output': ['35\\n']}, {'input': '10\\n20\\n40', 'output': ['70\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 2 6 3\", \"3 1 5 6\", \"8 3 3 2\", \"2 3 10 4\"]","prob_desc_input_spec":"The only line of the input contains four integers $$$a$$$, $$$b$$$, $$$c$$$, $$$d$$$ ($$$1 \\le a, b, c, d \\le 10^9$$$). It is possible that any two (or all three) ropewalkers are in the same position at the beginning of the performance.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import static java.lang.StrictMath.abs;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Ropewalkers {\n    static int a;\n    static int b;\n    static int c;\n    static int d;\n    static  List <Integer> list = new ArrayList();\n    static int counter=0;\n    public static void main(String args[]){\n  Scanner in = new Scanner(System.in);\n  a = in.nextInt();\n  b = in.nextInt();\n  c = in.nextInt();\n  d = in.nextInt();\n  list.add(a); \n  list.add(b);\n  list.add(c);   \n  int max = Collections.max(list);\n  int min = Collections.min(list);\n  int mid = (a+b+c) - (min+max);\n   \n   \n  if (abs(mid - min) < d ){\n    counter += d - (mid-min);\n    \n  }\n  if(abs(max - mid) < d ){\n    \n    counter += d - max + mid;\n  }\n   System.out.println(counter); \n  }  \n \n}\n","prob_desc_sample_outputs":"[\"2\", \"8\", \"2\", \"3\"]","lang_cluster":"Java","code_uid":"188c738082c5ddf2b84deedcda5bd162","prob_desc_notes":"NoteIn the first example: in the first two seconds Konrad moves for 2 positions to the right (to the position $$$8$$$), while Agafon and Boniface stay at their positions. Thus, the distance between Agafon and Boniface will be $$$|5 - 2| = 3$$$, the distance between Boniface and Konrad will be $$$|2 - 8| = 6$$$ and the distance between Agafon and Konrad will be $$$|5 - 8| = 3$$$. Therefore, all three pairwise distances will be at least $$$d=3$$$, so the performance could be finished within 2 seconds.","prob_desc_output_spec":"Output one integer \u2014 the minimum duration (in seconds) of the performance.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarp decided to relax on his weekend and visited to the performance of famous ropewalkers: Agafon, Boniface and Konrad.The rope is straight and infinite in both directions. At the beginning of the performance, Agafon, Boniface and Konrad are located in positions $$$a$$$, $$$b$$$ and $$$c$$$ respectively. At the end of the performance, the distance between each pair of ropewalkers was at least $$$d$$$.Ropewalkers can walk on the rope. In one second, only one ropewalker can change his position. Every ropewalker can change his position exactly by $$$1$$$ (i. e. shift by $$$1$$$ to the left or right direction on the rope). Agafon, Boniface and Konrad can not move at the same time (Only one of them can move at each moment). Ropewalkers can be at the same positions at the same time and can \"walk past each other\".You should find the minimum duration (in seconds) of the performance. In other words, find the minimum number of seconds needed so that the distance between each pair of ropewalkers can be greater or equal to $$$d$$$.Ropewalkers can walk to negative coordinates, due to the rope is infinite to both sides.","length":40,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 2 3 2', 'output': ['2']}, {'input': '5 5 5 1', 'output': ['2']}, {'input': '10 20 30 15', 'output': ['0']}, {'input': '7 8 9 3', 'output': ['0']}, {'input': '100 200 300 150', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 1\\n-1 0 1\", \"2 1\\n1 0\", \"1 1\\n-1\"]","prob_desc_input_spec":"The first line contains two integers $$$n$$$ and $$$p$$$ ($$$1 \\leq n \\leq 50$$$, $$$0 \\leq p \\leq 1$$$) \u2014 the number of pieces and Kuro's wanted parity. The second line contains $$$n$$$ integers $$$c_{1}, c_{2}, ..., c_{n}$$$ ($$$-1 \\leq c_{i} \\leq 1$$$) \u2014 the colors of the pieces.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces979E {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tint p = Integer.parseInt(st.nextToken());\n\t\tint[] c = new int[n];\n\t\tst = new StringTokenizer(br.readLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tc[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\t\n\t\t\/\/list of powers of 2 until 2^{n^2}, mod 1000000007\n\t\tint[] twopower = new int[n*n+1];\n\t\ttwopower[0] = 1;\n\t\tfor (int i = 1; i <= n*n; i++) {\n\t\t\ttwopower[i] = (2*twopower[i-1])%1000000007;\n\t\t}\n\t\t\n\t\t\/\/Pascal's triangle until n choose k, mod 1000000007\n\t\tint[][] pascal = new int[n+1][n+1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tpascal[i][0] = 1;\n\t\t\tpascal[0][i] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tpascal[i][j] = (pascal[i][j-1]+pascal[i-1][j])%1000000007;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/dp[x][y][z] means the last x have all arrows intact\n\t\t\/\/and there are y 0's and z 1's at the start with no\n\t\t\/\/arrows going between them.\n\t\t\/\/we only care when 0 <= x+y+z <= n.\n\t\t\/\/answer is dp[n][0][0].\n\t\tint[][][] dp = new int[n+1][n+1][n+1];\n\t\t\/\/base case of x = 0\n\t\tfor (int y = 0; y <= n; y++) {\n\t\t\tfor (int z = 0; z <= (n-y); z++) {\n\t\t\t\tif (p == (y+z)%2) {\n\t\t\t\t\tdp[0][y][z] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int x = 1; x <= n; x++) {\n\t\t\tfor (int y = 0; y <= (n-x); y++) {\n\t\t\t\tfor (int z = 0; z <= (n-x-y); z++) {\n\t\t\t\t\tif (c[n-x] != 1) {\n\t\t\t\t\t\tint evenmultiple;\n\t\t\t\t\t\tint oddmultiple;\n\t\t\t\t\t\tif (z == 0) {\n\t\t\t\t\t\t\tevenmultiple = 1;\n\t\t\t\t\t\t\toddmultiple = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tevenmultiple = twopower[z-1];\n\t\t\t\t\t\t\toddmultiple = twopower[z-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong evenk = (long) evenmultiple * (long) dp[x-1][y+1][z];\n\t\t\t\t\t\tevenk %= 1000000007;\n\t\t\t\t\t\tlong oddk = (long) oddmultiple * (long) dp[x-1][y][z];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\toddk *= (long) twopower[x-1];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\tlong totalk = evenk+oddk;\n\t\t\t\t\t\ttotalk *= twopower[y];\n\t\t\t\t\t\ttotalk %= 1000000007;\n\t\t\t\t\t\tdp[x][y][z] += (int) totalk;\n\t\t\t\t\t}\n\t\t\t\t\tif (c[n-x] != 0) {\n\t\t\t\t\t\tint evenmultiple;\n\t\t\t\t\t\tint oddmultiple;\n\t\t\t\t\t\tif (y == 0) {\n\t\t\t\t\t\t\tevenmultiple = 1;\n\t\t\t\t\t\t\toddmultiple = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tevenmultiple = twopower[y-1];\n\t\t\t\t\t\t\toddmultiple = twopower[y-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong evenk = (long) evenmultiple * (long) dp[x-1][y][z+1];\n\t\t\t\t\t\tevenk %= 1000000007;\n\t\t\t\t\t\tlong oddk = (long) oddmultiple * (long) dp[x-1][y][z];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\toddk *= (long) twopower[x-1];\n\t\t\t\t\t\toddk %= 1000000007;\n\t\t\t\t\t\tlong totalk = evenk+oddk;\n\t\t\t\t\t\ttotalk *= twopower[z];\n\t\t\t\t\t\ttotalk %= 1000000007;\n\t\t\t\t\t\tdp[x][y][z] += (int) totalk;\n\t\t\t\t\t}\n\t\t\t\t\tdp[x][y][z] %= 1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpw.println(dp[n][0][0]);\n\t\t\n\t\tpw.close();\n\t}\n}\n","prob_desc_sample_outputs":"[\"6\", \"1\", \"2\"]","lang_cluster":"Java","code_uid":"ebc57fb28654ca1bcb3a0a4ae117cf5b","prob_desc_notes":"NoteIn the first example, there are $$$6$$$ ways to color the pieces and add the arrows, as are shown in the figure below. The scores are $$$3, 3, 5$$$ for the first row and $$$5, 3, 3$$$ for the second row, both from left to right.  ","prob_desc_output_spec":"Print a single integer \u2014 the number of ways to put the arrows and choose colors so the number of valid paths of alternating colors has the parity of $$$p$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Kuro has recently won the \"Most intelligent cat ever\" contest. The three friends then decided to go to Katie's home to celebrate Kuro's winning. After a big meal, they took a small break then started playing games.Kuro challenged Katie to create a game with only a white paper, a pencil, a pair of scissors and a lot of arrows (you can assume that the number of arrows is infinite). Immediately, Katie came up with the game called Topological Parity.The paper is divided into $$$n$$$ pieces enumerated from $$$1$$$ to $$$n$$$. Shiro has painted some pieces with some color. Specifically, the $$$i$$$-th piece has color $$$c_{i}$$$ where $$$c_{i} = 0$$$ defines black color, $$$c_{i} = 1$$$ defines white color and $$$c_{i} = -1$$$ means that the piece hasn't been colored yet.The rules of the game is simple. Players must put some arrows between some pairs of different pieces in such a way that for each arrow, the number in the piece it starts from is less than the number of the piece it ends at. Also, two different pieces can only be connected by at most one arrow. After that the players must choose the color ($$$0$$$ or $$$1$$$) for each of the unpainted pieces. The score of a valid way of putting the arrows and coloring pieces is defined as the number of paths of pieces of alternating colors. For example, $$$[1 \\to 0 \\to 1 \\to 0]$$$, $$$[0 \\to 1 \\to 0 \\to 1]$$$, $$$[1]$$$, $$$[0]$$$ are valid paths and will be counted. You can only travel from piece $$$x$$$ to piece $$$y$$$ if and only if there is an arrow from $$$x$$$ to $$$y$$$.But Kuro is not fun yet. He loves parity. Let's call his favorite parity $$$p$$$ where $$$p = 0$$$ stands for \"even\" and $$$p = 1$$$ stands for \"odd\". He wants to put the arrows and choose colors in such a way that the score has the parity of $$$p$$$.It seems like there will be so many ways which satisfy Kuro. He wants to count the number of them but this could be a very large number. Let's help him with his problem, but print it modulo $$$10^{9} + 7$$$.","length":108,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 0\\n-1 -1 -1 -1 -1', 'output': ['1048576']}, {'input': '4 1\\n1 0 -1 -1', 'output': ['16']}, {'input': '3 0\\n1 1 1', 'output': ['1']}, {'input': '2 1\\n0 -1', 'output': ['2']}, {'input': '1 0\\n-1', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\\n1 3 5\", \"5\\n1 0 1 5 1\", \"3\\n4 3 1\", \"4\\n3 9 9 3\"]","prob_desc_input_spec":"The first line of input contains a non-negative integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the length of the sequence. The second line contains n space-separated non-negative integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100) \u2014 the elements of the sequence.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class A {\n    FScanner in = new FScanner();\n    PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out), true);\n\n    void run() {\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            int x = in.nextInt();\n            a[i] = x;\n        }\n        out.print(a[0] % 2 != 0 && a[n - 1] % 2 != 0 && n % 2 == 1 ? \n                \"Yes\" :\n                \"No\");\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new A().run();\n    }\n\n    static class FScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        char[][] nextCharArray(int n, int m) {\n            char[][] g = new char[n][m];\n            for (int i = 0; i < n; i++)\n                g[i] = next().toCharArray();\n            return g;\n        }\n\n        double[] nextDoubleArray(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextDouble();\n            return a;\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n}\n","prob_desc_sample_outputs":"[\"Yes\", \"Yes\", \"No\", \"No\"]","lang_cluster":"Java","code_uid":"17bab6a8bcc9f43b5cece555495a74b7","prob_desc_notes":"NoteIn the first example, divide the sequence into 1 subsegment: {1,\u20093,\u20095} and the requirements will be met.In the second example, divide the sequence into 3 subsegments: {1,\u20090,\u20091}, {5}, {1}.In the third example, one of the subsegments must start with 4 which is an even number, thus the requirements cannot be met.In the fourth example, the sequence can be divided into 2 subsegments: {3,\u20099,\u20099}, {3}, but this is not a valid solution because 2 is an even number.","prob_desc_output_spec":"Output \"Yes\" if it's possible to fulfill the requirements, and \"No\" otherwise. You can output each letter in any case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"Where do odds begin, and where do they end? Where does hope emerge, and will they ever break?Given an integer sequence a1,\u2009a2,\u2009...,\u2009an of length n. Decide whether it is possible to divide it into an odd number of non-empty subsegments, the each of which has an odd length and begins and ends with odd numbers.A subsegment is a contiguous slice of the whole sequence. For example, {3,\u20094,\u20095} and {1} are subsegments of sequence {1,\u20092,\u20093,\u20094,\u20095,\u20096}, while {1,\u20092,\u20094} and {7} are not.","length":95,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 4 5\\n', 'output': ['Yes\\n']}, {'input': '4\\n2 4 6 8\\n', 'output': ['No\\n']}, {'input': '1\\n1\\n', 'output': ['Yes\\n']}, {'input': '3\\n2 3 2\\n', 'output': ['No\\n']}, {'input': '7\\n1 2 3 4 5 6 7\\n', 'output': ['Yes\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 2\", \"123 456789\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 250$$$, $$$1 \\le k \\le 10^{9}$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/\/package cf589d2;\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E {\n\tstatic long MOD = 1000000007;\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tint n = sc.nextInt();\n\t\tlong k = sc.nextLong();\n\t\tlong[][] choose = new long[n + 1][n + 1];\n\t\tlong[][] pow = new long[n + 1][2];\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tchoose[i][0] = 1;\n\t\t\tchoose[i][i] = 1;\n\t\t}\n\t\tfor(int i = 2; i <= n; i++)\n\t\t\tfor(int j = 1; j < i; j++)\n\t\t\t\tchoose[i][j] = (choose[i - 1][j] + choose[i - 1][j - 1]) % MOD;\n\t\tfor(int i = 0; i <= n; i++)\n\t\t\tfor(int j = 0; j < 2; j++)\n\t\t\t\tpow[i][j] = pMod(k - j, i);\n\t\tlong[][] dp = new long[n + 1][n + 1];\n\t\tdp[0][n] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 0; j <= n; j++)\n\t\t\t\tfor(int l = 0; l <= j; l++) {\n\t\t\t\t\tlong del = dp[i - 1][j] * choose[j][l] % MOD * pow[l][1] % MOD;\n\t\t\t\t\tif(l < j)\n\t\t\t\t\t\tdel = del * pow[n - j][0] % MOD;\n\t\t\t\t\telse\n\t\t\t\t\t\tdel = del * (pow[n - j][0] - pow[n - j][1] + MOD) % MOD;\n\t\t\t\t\tdp[i][l] = (dp[i][l] + del) % MOD;\n\t\t\t\t}\n\t\tout.println(dp[n][0]);\n\t\tout.close();\n\t}\n\tpublic static long pMod(long x, long p) {\n\t\tif(p == 0)\n\t\t\treturn 1;\n\t\tlong l = pMod(x, p \/ 2);\n\t\treturn l * l % MOD * (p % 2 == 1 ? x : 1) % MOD;\n\t}\n\tpublic static PrintWriter out  = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static class MyScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements())\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}\n","prob_desc_sample_outputs":"[\"7\", \"689974806\"]","lang_cluster":"Java","code_uid":"b3605c1fb0810a1893fcf50f799b87cd","prob_desc_notes":"NoteIn the first example, following $$$7$$$ cases are possible.  In the second example, make sure you print the answer modulo $$$(10^{9} + 7)$$$.","prob_desc_output_spec":"Print the answer modulo $$$(10^{9} + 7)$$$.","prob_desc_output_to":"standard output","prob_desc_description":"You have $$$n \\times n$$$ square grid and an integer $$$k$$$. Put an integer in each cell while satisfying the conditions below.  All numbers in the grid should be between $$$1$$$ and $$$k$$$ inclusive.  Minimum number of the $$$i$$$-th row is $$$1$$$ ($$$1 \\le i \\le n$$$).  Minimum number of the $$$j$$$-th column is $$$1$$$ ($$$1 \\le j \\le n$$$). Find the number of ways to put integers in the grid. Since the answer can be very large, find the answer modulo $$$(10^{9} + 7)$$$.  These are the examples of valid and invalid grid when $$$n=k=2$$$. ","length":77,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['1\\n']}, {'input': '2 3', 'output': ['15\\n']}, {'input': '3 3', 'output': ['151\\n']}, {'input': '4 4', 'output': ['5473\\n']}, {'input': '5 5', 'output': ['481066515\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 0 0 1\\n0 1 0 0\\n0 0 1 0\\n0 0 0 1\", \"0 1 1 0\\n1 0 1 0\\n1 1 0 0\\n0 0 0 1\", \"1 0 0 0\\n0 0 0 1\\n0 0 0 0\\n1 0 1 0\"]","prob_desc_input_spec":"The input consists of four lines with each line describing a road part given in a counter-clockwise order. Each line contains four integers l, s, r, p \u2014 for the left, straight, right and pedestrian lights, respectively. The possible values are 0 for red light and 1 for green light.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (sc.hasNext()) {\n\t\t\tint a[][] = new int[5][5];\n\t\t\tfor (int i = 1; i < a.length; i++) {\n\t\t\t\tfor (int j = 1; j < a.length; j++) {\n\t\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (a[1][4] == 1\n\t\t\t\t\t&& (a[1][1] == 1 || a[1][2] == 1 || a[1][3] == 1 || a[2][1] == 1 || a[3][2] == 1 || a[4][3] == 1)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else if (a[2][4] == 1\n\t\t\t\t\t&& (a[2][1] == 1 || a[2][2] == 1 || a[2][3] == 1 || a[3][1] == 1 || a[4][2] == 1 || a[1][3] == 1)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\n\t\t\t} else if (a[3][4] == 1\n\t\t\t\t\t&& (a[3][1] == 1 || a[3][2] == 1 || a[3][3] == 1 || a[4][1] == 1 || a[2][3] == 1 || a[1][2] == 1)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else if (a[4][4] == 1\n\t\t\t\t\t&& (a[4][1] == 1 || a[4][2] == 1 || a[4][3] == 1 || a[3][3] == 1 || a[1][1] == 1 || a[2][2] == 1)) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"NO\"]","lang_cluster":"Java","code_uid":"8790a10c04e66b0a6a29b482288744de","prob_desc_notes":"NoteIn the first example, some accidents are possible because cars of part 1 can hit pedestrians of parts 1 and 4. Also, cars of parts 2 and 3 can hit pedestrians of part 4.In the second example, no car can pass the pedestrian crossing of part 4 which is the only green pedestrian light. So, no accident can occur.","prob_desc_output_spec":"On a single line, print \"YES\" if an accident is possible, and \"NO\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"Sagheer is walking in the street when he comes to an intersection of two roads. Each road can be represented as two parts where each part has 3 lanes getting into the intersection (one for each direction) and 3 lanes getting out of the intersection, so we have 4 parts in total. Each part has 4 lights, one for each lane getting into the intersection (l \u2014 left, s \u2014 straight, r \u2014 right) and a light p for a pedestrian crossing.   An accident is possible if a car can hit a pedestrian. This can happen if the light of a pedestrian crossing of some part and the light of a lane that can get to or from that same part are green at the same time.Now, Sagheer is monitoring the configuration of the traffic lights. Your task is to help him detect whether an accident is possible.","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 0 0 1\\n0 1 0 0\\n0 0 1 0\\n0 0 0 1', 'output': ['YES']}, {'input': '0 1 1 0\\n1 0 1 0\\n1 1 0 0\\n0 0 0 1', 'output': ['NO']}, {'input': '1 0 0 0\\n0 0 0 1\\n0 0 0 0\\n1 0 1 0', 'output': ['NO']}, {'input': '1 1 1 1\\n1 1 1 1\\n1 1 1 1\\n1 1 1 1', 'output': ['YES']}, {'input': '0 0 0 0\\n0 0 0 0\\n0 0 0 0\\n0 0 0 0', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\\n2 1 3\", \"3\\n1 2 3\"]","prob_desc_input_spec":"The first line contains a single integer $$$n$$$ ($$$2 \\le n \\le 100$$$) \u2014 the number of figures. The second line contains $$$n$$$ integer numbers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 3$$$, $$$a_i \\ne a_{i + 1}$$$) \u2014 types of the figures.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\nimport java.util.Scanner;\npublic class InscribedFigures {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner (System.in);\n\t\tint n=sc.nextInt();\n\t\tint A[]=new int[n];\n\t\tfor (int x=0;x<n;x++)\n\t\t\tA[x]=sc.nextInt();\n\t\tint s=0;\n\t\tint d=0;\n\t\tfor (int x=0;x<n-1;x++) \n\t\t{\n\t\t\tif (A[x]+A[x+1]==5) \n\t\t\t{\n\t\t\t\ts=-1;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t\telse if(A[x]+A[x+1]==3)\n\t\t\t\ts=s+3;\n\t\t\telse \n\t\t\t\ts=s+4;\t\n\t\t}\n\t\tfor (int x=0;x<n-2;x++)\n\t\t\tif (A[x]==3&&A[x+1]==1&&A[x+2]==2)\n\t\t\t\td=d+1;\n\t\t\t\n\t\tif (s==-1)\n\t\t\tSystem.out.println(\"Infinite\");\n\t\telse \n\t\t{\n\t\t\tSystem.out.println(\"Finite\");\n\t\t\tSystem.out.println(s-d);\n\t\t\t\n\t\t}\n\t\t\t\n\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"Finite\\n7\", \"Infinite\"]","lang_cluster":"Java","code_uid":"29f0692cf659387dea01dc5e5a6e3421","prob_desc_notes":"NoteHere are the glorious pictures for the examples. Note that the triangle is not equilateral but just isosceles with the length of height equal to the length of base. Thus it fits into a square in a unique way.The distinct points where figures touch are marked red.In the second example the triangle and the square touch each other for the whole segment, it contains infinite number of points.  ","prob_desc_output_spec":"The first line should contain either the word \"Infinite\" if the number of distinct points where figures touch is infinite or \"Finite\" otherwise. If the number is finite than print it in the second line. It's guaranteed that the number fits into 32-bit integer type.","prob_desc_output_to":"standard output","prob_desc_description":"The math faculty of Berland State University has suffered the sudden drop in the math skills of enrolling students. This year the highest grade on the entrance math test was 8. Out of 100! Thus, the decision was made to make the test easier.Future students will be asked just a single question. They are given a sequence of integer numbers $$$a_1, a_2, \\dots, a_n$$$, each number is from $$$1$$$ to $$$3$$$ and $$$a_i \\ne a_{i + 1}$$$ for each valid $$$i$$$. The $$$i$$$-th number represents a type of the $$$i$$$-th figure:  circle;  isosceles triangle with the length of height equal to the length of base;  square. The figures of the given sequence are placed somewhere on a Cartesian plane in such a way that:  $$$(i + 1)$$$-th figure is inscribed into the $$$i$$$-th one;  each triangle base is parallel to OX;  the triangle is oriented in such a way that the vertex opposite to its base is at the top;  each square sides are parallel to the axes;  for each $$$i$$$ from $$$2$$$ to $$$n$$$ figure $$$i$$$ has the maximum possible length of side for triangle and square and maximum radius for circle. Note that the construction is unique for some fixed position and size of just the first figure.The task is to calculate the number of distinct points (not necessarily with integer coordinates) where figures touch. The trick is, however, that the number is sometimes infinite. But that won't make the task difficult for you, will it?So can you pass the math test and enroll into Berland State University?","length":42,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2\\n1 2', 'output': ['Finite\\n3\\n']}, {'input': '2\\n2 3', 'output': ['Finite\\n4\\n']}, {'input': '3\\n1 2 1', 'output': ['Finite\\n6\\n']}, {'input': '3\\n2 1 3', 'output': ['Finite\\n7\\n']}, {'input': '3\\n1 2 3', 'output': ['Infinite\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 2 1000\", \"2 2 1000\", \"5 3 1103\"]","prob_desc_input_spec":"Input consists of three integers n,\u2009k,\u2009m (1\u2009\u2264\u2009n\u2009\u2264\u20091000, 1\u2009\u2264\u2009k\u2009\u2264\u2009100, 1\u2009\u2264\u2009m\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.function.Function;\n\npublic class CF287D {\n\n    public static long modPower(long base, long exponent, long mod) {\n        long result = 1;\n        while (exponent > 0) {\n            if ((exponent & 1) != 0)\n                result = (result * base) % mod;\n            base = (base * base) % mod;\n            exponent >>= 1;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        long m = in.nextLong();\n        long[] dp = new long[k];\n        dp[0] = 1;\n        long total = 0;\n        for (int i = 0; i < n; i++) {\n            long[] next = new long[k];\n            for (int j = 0; j < k; j++)\n                for (int d = (i == n - 1) ? 1 : 0; d < 10; d++) {\n                    int res = (int) (modPower(10, i, k) * d + j) % k;\n                    next[res] = (next[res] + dp[j]) % m;\n                }\n            if (i < n - 1)\n                total += (next[0] + m - 1) * 9 % m * modPower(10, n - 2 - i, m)\n                        % m;\n            else\n                total += next[0];\n\n            total %= m;\n            dp = next;\n            dp[0] = 1;\n        }\n        System.out.println(total);\n    }\n}\n","prob_desc_sample_outputs":"[\"4\", \"45\", \"590\"]","lang_cluster":"Java","code_uid":"41e91d84278bc1e9d5b8b84f37707640","prob_desc_notes":"NoteA suffix of a string S is a non-empty string that can be obtained by removing some number (possibly, zero) of first characters from S.","prob_desc_output_spec":"Print the required number modulo m.","prob_desc_output_to":"standard output","prob_desc_description":"Amr doesn't like Maths as he finds it really boring, so he usually sleeps in Maths lectures. But one day the teacher suspected that Amr is sleeping and asked him a question to make sure he wasn't.First he gave Amr two positive integers n and k. Then he asked Amr, how many integer numbers x\u2009&gt;\u20090 exist such that:  Decimal representation of x (without leading zeroes) consists of exactly n digits;  There exists some integer y\u2009&gt;\u20090 such that:   ;  decimal representation of y is a suffix of decimal representation of x.  As the answer to this question may be pretty huge the teacher asked Amr to output only its remainder modulo a number m.Can you help Amr escape this embarrassing situation?","length":45,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1000', 'output': ['10\\n']}, {'input': '3 2 1000', 'output': ['450\\n']}, {'input': '4 3 1000', 'output': ['4950\\n']}, {'input': '5 4 1000', 'output': ['54950\\n']}, {'input': '6 5 1000', 'output': ['604950\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"8 5\\n10 9 8 7 7 7 5 5\", \"4 2\\n0 0 0 0\"]","prob_desc_input_spec":"The first line of the input contains two integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u200950) separated by a single space. The second line contains n space-separated integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009100), where ai is the score earned by the participant who got the i-th place. The given sequence is non-increasing (that is, for all i from 1 to n\u2009-\u20091 the following condition is fulfilled: ai\u2009\u2265\u2009ai\u2009+\u20091).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class NextRound2 {\n    public static void main(String[] args){\n        Scanner scan  = new Scanner(System.in);\n        int n,k,score=-1,count=0;\n        n = scan.nextInt();\n        k = scan.nextInt();\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scan.nextInt();\n        }\n        scan.close();\n        if(a[0]==0){\n            k=0;\n        }else{\n            \/\/6 2\n            \/\/3 0 0 0 0 0 \n            while(a[k-1]==0)k--;\n            \/\/non-incresing, next number from (k-1) must be the same (k).\n            while(k<n && a[k-1]==a[k])k++;\n        }\n        System.out.println(k);\n    }\n}\n","prob_desc_sample_outputs":"[\"6\", \"0\"]","lang_cluster":"Java","code_uid":"cbcda64abba4edd54647c9a419949e15","prob_desc_notes":"NoteIn the first example the participant on the 5th place earned 7 points. As the participant on the 6th place also earned 7 points, there are 6 advancers.In the second example nobody got a positive score.","prob_desc_output_spec":"Output the number of participants who advance to the next round.","prob_desc_output_to":"standard output","prob_desc_description":"\"Contestant who earns a score equal to or greater than the k-th place finisher's score will advance to the next round, as long as the contestant earns a positive score...\" \u2014 an excerpt from contest rules.A total of n participants took part in the contest (n\u2009\u2265\u2009k), and you already know their scores. Calculate how many participants will advance to the next round.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5\\n10 9 8 7 7 6 5 5 4 3', 'output': ['5\\n']}, {'input': '5 3\\n5 4 4 3 2', 'output': ['4\\n']}, {'input': '6 2\\n3 0 0 0 0 0', 'output': ['1\\n']}, {'input': '7 4\\n7 6 5 5 4 3 2', 'output': ['5\\n']}, {'input': '4 2\\n0 0 0 0', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 10 7\", \"4 0 9\"]","prob_desc_input_spec":"The first line contains three integers a, b, mod (0\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009109, 1\u2009\u2264\u2009mod\u2009\u2264\u2009107).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Game {\n  public static void main(String[] args) throws IOException {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    String[] input = bf.readLine().split(\" \");\n    String answer = \"\";\n    long a, b, mod, ans;\n    boolean oneWin = false;\n    a = Integer.parseInt(input[0]);\n    b = Integer.parseInt(input[1]);\n    mod = Integer.parseInt(input[2]);\n    long limit = Math.min(a, mod);\n    long res = 0;\n\n    for (ans = 1; ans <= limit; ans++) {\n      res = (((ans % mod) * (1000000000 % mod)) % mod);\n      if ((mod - res)% mod > b) {\n          oneWin = true;\n          break;\n      }\n    }\n\n    if (oneWin) {\n      String temp = String.valueOf(ans);\n      int digits = temp.length();\n      for (int i = 0;i < 9 - digits; i++) {\n        answer += \"0\";\n      }\n      answer += String.valueOf(ans);\n      System.out.println(\"1 \" + answer);\n    } else {\n      System.out.println(2);\n    }\n  }\n}\n","prob_desc_sample_outputs":"[\"2\", \"1 000000001\"]","lang_cluster":"Java","code_uid":"76c146846eb3993ae95ed256a14e1f4b","prob_desc_notes":"NoteThe lexical comparison of strings is performed by the &lt; operator in modern programming languages. String x is lexicographically less than string y if exists such i (1\u2009\u2264\u2009i\u2009\u2264\u20099), that xi\u2009&lt;\u2009yi, and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. These strings always have length 9.","prob_desc_output_spec":"If the first player wins, print \"1\" and the lexicographically minimum string s1 he has to write to win. If the second player wins, print the single number \"2\".","prob_desc_output_to":"standard output","prob_desc_description":"In a very ancient country the following game was popular. Two people play the game. Initially first player writes a string s1, consisting of exactly nine digits and representing a number that does not exceed a. After that second player looks at s1 and writes a string s2, consisting of exactly nine digits and representing a number that does not exceed b. Here a and b are some given constants, s1 and s2 are chosen by the players. The strings are allowed to contain leading zeroes.If a number obtained by the concatenation (joining together) of strings s1 and s2 is divisible by mod, then the second player wins. Otherwise the first player wins. You are given numbers a, b, mod. Your task is to determine who wins if both players play in the optimal manner. If the first player wins, you are also required to find the lexicographically minimum winning move.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['2\\n']}, {'input': '1000000000 1000000000 10000000', 'output': ['2\\n']}, {'input': '1000000000 0 10000000', 'output': ['1 000000001\\n']}, {'input': '1000000000 9999999 10000000', 'output': ['2\\n']}, {'input': '1000000000 9999998 10000000', 'output': ['1 000000001\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\", \"7\"]","prob_desc_input_spec":"The only line of the input contains integer n (0\u2009\u2264\u2009n\u2009\u2264\u20091018)\u00a0\u2014 the number of Ayrat's moves.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\/**\n * CodeForces : 338\n * \n * @author vinaysaini E. Hexagons\n *\/\npublic class cf338e {\n\n\tstatic int dx[] = { 1, -1, -2, -1, 1, 2 };\n\tstatic int dy[] = { 2, 2, 0, -2, -2, 0 };\n\n\tpublic static void main(String[] args) {\n\t\tlong x = 0, y = 0;\n\n\t\tlong n = in.nextLong();\n\t\tlong ringNumber = getRing(n);\n\t\tlong stepsUpTo = 3 * ringNumber * ringNumber + 3 * ringNumber;\n\t\tx = 2 * ringNumber;\n\t\tlong remainingSteps = n - stepsUpTo;\n\t\tif (remainingSteps > 0) {\n\t\t\tx = x + dx[0];\n\t\t\ty = y + dy[0];\n\t\t\tremainingSteps--;\n\t\t}\n\t\tif (remainingSteps >= ringNumber) {\n\t\t\tx += dx[1] * ringNumber;\n\t\t\ty += dy[1] * ringNumber;\n\t\t\tremainingSteps -= ringNumber;\n\t\t} else {\n\t\t\tx += dx[1] * remainingSteps;\n\t\t\ty += dy[1] * remainingSteps;\n\t\t\tremainingSteps -= remainingSteps;\n\t\t}\n\t\tif (remainingSteps >= ringNumber+1) {\n\t\t\tx += dx[2] * (ringNumber+1);\n\t\t\ty += dy[2] * (ringNumber+1);\n\t\t\tremainingSteps -= ringNumber+1;\n\t\t} else {\n\t\t\tx += dx[2] * remainingSteps;\n\t\t\ty += dy[2] * remainingSteps;\n\t\t\tremainingSteps -= remainingSteps;\n\t\t}\n\t\tif (remainingSteps >= ringNumber+1) {\n\t\t\tx += dx[3] * (ringNumber+1);\n\t\t\ty += dy[3] * (ringNumber+1);\n\t\t\tremainingSteps -= ringNumber+1;\n\t\t} else {\n\t\t\tx += dx[3] * remainingSteps;\n\t\t\ty += dy[3] * remainingSteps;\n\t\t\tremainingSteps -= remainingSteps;\n\t\t}\n\t\tif (remainingSteps >= ringNumber+1) {\n\t\t\tx += dx[4] * (ringNumber+1);\n\t\t\ty += dy[4] * (ringNumber+1);\n\t\t\tremainingSteps -= ringNumber+1;\n\t\t} else {\n\t\t\tx += dx[4] * remainingSteps;\n\t\t\ty += dy[4] * remainingSteps;\n\t\t\tremainingSteps -= remainingSteps;\n\t\t}\n\t\tif (remainingSteps >= ringNumber+1) {\n\t\t\tx += dx[5] * (ringNumber+1);\n\t\t\ty += dy[5] * (ringNumber+1);\n\t\t\tremainingSteps -= ringNumber+1;\n\t\t} else {\n\t\t\tx += dx[5] * remainingSteps;\n\t\t\ty += dy[5] * remainingSteps;\n\t\t\tremainingSteps -= remainingSteps;\n\t\t}\n\t\tif (remainingSteps >= ringNumber) {\n\t\t\tx += dx[0] * ringNumber;\n\t\t\ty += dy[0] * ringNumber;\n\t\t\tremainingSteps -= ringNumber;\n\t\t} else {\n\t\t\tx += dx[0] * remainingSteps;\n\t\t\ty += dy[0] * remainingSteps;\n\t\t\tremainingSteps -= remainingSteps;\n\t\t}\n\n\t\tout.println(x + \" \" + y);\n\t\tout.close();\n\t}\n\n\tstatic long getRing(long n) {\n\t\tlong l = 0;\n\t\tlong r = (long) 1e9;\n\t\twhile (l < r) {\n\t\t\tlong m = (l + r) \/ 2;\n\t\t\tlong sum = 3 * m * m + 3 * m;\n\t\t\tif (n < sum) {\n\t\t\t\tr = m;\n\t\t\t} else\n\t\t\t\tl = m + 1;\n\t\t}\n\t\treturn l - 1;\n\t}\n\n\tpublic static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tpublic static FastScanner in = new FastScanner();\n\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t} \/\/ --fast i\/o ends here----\/\/\n\n}\n","prob_desc_sample_outputs":"[\"-2 0\", \"3 2\"]","lang_cluster":"Java","code_uid":"4af23f0ff02c7d3b490efb7c019dd1af","prob_desc_notes":null,"prob_desc_output_spec":"Print two integers x and y\u00a0\u2014 current coordinates of Ayrat coordinates.","prob_desc_output_to":"standard output","prob_desc_description":"Ayrat is looking for the perfect code. He decided to start his search from an infinite field tiled by hexagons. For convenience the coordinate system is introduced, take a look at the picture to see how the coordinates of hexagon are defined:   Ayrat is searching through the field. He started at point (0,\u20090) and is moving along the spiral (see second picture). Sometimes he forgets where he is now. Help Ayrat determine his location after n moves.","length":149,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0', 'output': ['0 0\\n']}, {'input': '1', 'output': ['1 2\\n']}, {'input': '10', 'output': ['-4 -2\\n']}, {'input': '100', 'output': ['14 -24\\n']}, {'input': '1000', 'output': ['58 100\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"6 1\", \"6 2\", \"60 5\"]","prob_desc_input_spec":"The only line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\leq n \\leq 10^{15}$$$, $$$1 \\leq k \\leq 10^4$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.lang.*;\nimport java.math.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\nclass Node {\n    long p;\n    int a;\n    public Node(long p,int a){\n        this.p=p;\n        this.a=a;\n    }\n}\n    void solve() {\n        long n=nl(); int k=ni();\n        ArrayList<Node> vec=new ArrayList<>();\n        for(long i=2;i*i<=n;i++){\n             if(n%i==0){\n                 int cc=0;\n                 while(n%i==0){\n                     n\/=i;\n                     cc++;\n                 }\n                 vec.add(new Node(i,cc));\n             }\n        }\n        if(n>1) vec.add(new Node(n,1));\n        long dp[][]=new long[51][k+1];\n        long ans=1;\n        long suf[]=new long[51];\n        long curSuf[]=new long[51];\n        long inv[]=new long[52];\n        for(int i=0;i<52;i++) inv[i]=modInverse(i);\n\n        for(Node P : vec){\n            long p=P.p; int a=P.a;\n            for(int i=0;i<=50;i++) Arrays.fill(dp[i],0);\n\n            dp[a][0]=1;\n            Arrays.fill(suf,inv[a+1]);\n\n            for(int s=1;s<=k;s++){\n                Arrays.fill(curSuf,0);\n                for(int i=a;i>=0;i--){\n                    dp[i][s]=suf[i];\n                    curSuf[i]=mul(dp[i][s],inv[i+1]);\n                    if(i+1<=a) curSuf[i]=add(curSuf[i],curSuf[i+1]);\n                   \/\/ for(int j=i;j<=a;j++) dp[i][s]=add(dp[i][s],mul(dp[j][s-1],inv[j+1]));\n\n                }\n                for(int i=0;i<=a;i++) suf[i]=curSuf[i];\n            }\n            long ex=0;\n            for(int i=0;i<=a;i++){\n                ex=add(ex,mul(dp[i][k],modpow(p,i)));\n\n            }\n           \/\/ if(p==2) pw.println(dp[0][k]+\" \"+dp[1][k]+\" \"+modInverse(2)+\" \"+ex+\" \"+mul(3,modInverse(2)));\n            ans=mul(ans,ex);\n\n        }\n        pw.println(ans);\n\n    }\n    long add(long x,long y){\n        x+=y;\n        if(x>=M) x-=M;\n        return x;\n    }\n    long sub(long x,long y){\n        x-=y;\n        if(x<0) x+=M;\n        return x;\n    }\n    long mul(long x,long y){\n        x*=y;\n        if(x>=M) x%=M;\n        return x;\n    }\n    long modpow(long a, long b)\n    {\n        long r=1;\n        while(b>0)\n        {\n            if((b&1)>0) r=mul(r,a);\n            a=mul(a,a);\n            b>>=1;\n        }\n        return r;\n    }\n\n    long modInverse(long A)\n    {\n\n        return modpow(A,M-2);\n    }\n\n\n\n\n    long M= (long)1e9+7;\n    InputStream is;\n    PrintWriter pw;\n    String INPUT = \"\";\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        pw = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        pw.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\n    }\n    public static void main(String[] args) throws Exception { new Main().run(); }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b))){ \/\/ when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n\n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    private boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private void tr(Object... o) { if(INPUT.length() > 0)System.out.println(Arrays.deepToString(o)); }\n\n}","prob_desc_sample_outputs":"[\"3\", \"875000008\", \"237178099\"]","lang_cluster":"Java","code_uid":"0b45b8015a747797dd5485bf6af45dce","prob_desc_notes":"NoteIn the first example, after one step, the number written on the blackboard is $$$1$$$, $$$2$$$, $$$3$$$ or $$$6$$$ \u2014 each occurring with equal probability. Hence, the answer is $$$\\frac{1+2+3+6}{4}=3$$$.In the second example, the answer is equal to $$$1 \\cdot \\frac{9}{16}+2 \\cdot \\frac{3}{16}+3 \\cdot \\frac{3}{16}+6 \\cdot \\frac{1}{16}=\\frac{15}{8}$$$.","prob_desc_output_spec":"Print a single integer \u2014 the expected value of the number on the blackboard after $$$k$$$ steps as $$$P \\cdot Q^{-1} \\pmod{10^9+7}$$$ for $$$P$$$, $$$Q$$$ defined above.","prob_desc_output_to":"standard output","prob_desc_description":"Makoto has a big blackboard with a positive integer $$$n$$$ written on it. He will perform the following action exactly $$$k$$$ times:Suppose the number currently written on the blackboard is $$$v$$$. He will randomly pick one of the divisors of $$$v$$$ (possibly $$$1$$$ and $$$v$$$) and replace $$$v$$$ with this divisor. As Makoto uses his famous random number generator (RNG) and as he always uses $$$58$$$ as his generator seed, each divisor is guaranteed to be chosen with equal probability.He now wonders what is the expected value of the number written on the blackboard after $$$k$$$ steps.It can be shown that this value can be represented as $$$\\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are coprime integers and $$$Q \\not\\equiv 0 \\pmod{10^9+7}$$$. Print the value of $$$P \\cdot Q^{-1}$$$ modulo $$$10^9+7$$$.","length":209,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 1', 'output': ['4']}, {'input': '100 2', 'output': ['875000008']}, {'input': '1000 3', 'output': ['875000008']}, {'input': '10000 4', 'output': ['875000008']}, {'input': '100000 5', 'output': ['875000008']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1 3 3 2\", \"3\\n1 1 1\", \"4\\n42 0 0 42\"]","prob_desc_input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of participants. The next line contains a sequence of n integers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u2009600)\u00a0\u2014 participants' scores. It's guaranteed that at least one participant has non-zero score.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\n \nimport java.io.IOException; \nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner; \nimport java.util.StringTokenizer;\nimport java.util.ArrayList;\nimport java.util.TreeSet;\nimport java.util.Collections;\n  \npublic class Hello\n{ \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n  \n    public static void main(String[] args) \n    { \n        FastReader in=new FastReader(); \n        \n        \n        \/\/start code here\n        int n=in.nextInt();\n        int res=0;\n        ArrayList<Integer> al = new ArrayList<>();\n        for(int i=0;i<n;++i)\n        {\n        \tint x = in.nextInt();\n        \tif(x!=0&&!al.contains(x))\n        \t{\n        \t\t++res;\n        \t\tal.add(x);\n        \t}\n        }\n        System.out.print(res);\n    }\n} ","prob_desc_sample_outputs":"[\"3\", \"1\", \"1\"]","lang_cluster":"Java","code_uid":"d75b817fb7e17cc64b3c9a9ab5b24ed2","prob_desc_notes":"NoteThere are three ways to choose a subset in sample case one.  Only participants with 3 points will get diplomas.  Participants with 2 or 3 points will get diplomas.  Everyone will get a diploma! The only option in sample case two is to award everyone.Note that in sample case three participants with zero scores cannot get anything.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the desired number of ways.","prob_desc_output_to":"standard output","prob_desc_description":"The recent All-Berland Olympiad in Informatics featured n participants with each scoring a certain amount of points.As the head of the programming committee, you are to determine the set of participants to be awarded with diplomas with respect to the following criteria:   At least one participant should get a diploma.  None of those with score equal to zero should get awarded.  When someone is awarded, all participants with score not less than his score should also be awarded. Determine the number of ways to choose a subset of participants that will receive the diplomas.","length":91,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 4 5', 'output': ['5']}, {'input': '6\\n1 1 1 1 1 1', 'output': ['1']}, {'input': '7\\n0 0 0 0 0 0 7', 'output': ['1']}, {'input': '8\\n0 0 0 0 0 0 0 8', 'output': ['1']}, {'input': '9\\n1 2 3 4 5 6 7 8 9', 'output': ['9']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\nxxxiii\", \"5\\nxxoxx\", \"10\\nxxxxxxxxxx\"]","prob_desc_input_spec":"The first line contains integer $$$n$$$ $$$(3 \\le n \\le 100)$$$ \u2014 the length of the file name. The second line contains a string of length $$$n$$$ consisting of lowercase Latin letters only \u2014 the file name.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class A\n{\n    public static void main(String args[])throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n,i,j,count,k;\n        String t=br.readLine();\n        n=Integer.parseInt(t);\n        t=br.readLine();\n        char[] s=t.toCharArray();\n        k=0;\n        for(i=0;i<n;)\n        {\n            if(s[i]=='x')\n            {\n                count=1;\n                for(j=i+1;j<n;j++)\n                {\n                    if(s[j]=='x')\n                    count=count+1;\n                    else\n                    break;\n                }\n                i=i+count;\n                if(count!=1)\n                k=k+(count-2);\n            }\n            else\n            i=i+1;\n        }\n        System.out.println(k);\n    }\n}","prob_desc_sample_outputs":"[\"1\", \"0\", \"8\"]","lang_cluster":"Java","code_uid":"9e4a166a4c43230b9396b29751a94f0d","prob_desc_notes":"NoteIn the first example Polycarp tried to send a file with name contains number $$$33$$$, written in Roman numerals. But he can not just send the file, because it name contains three letters \"x\" in a row. To send the file he needs to remove any one of this letters.","prob_desc_output_spec":"Print the minimum number of characters to remove from the file name so after that the name does not contain \"xxx\" as a substring. If initially the file name dost not contain a forbidden substring \"xxx\", print 0.","prob_desc_output_to":"standard output","prob_desc_description":"You can not just take the file and send it. When Polycarp trying to send a file in the social network \"Codehorses\", he encountered an unexpected problem. If the name of the file contains three or more \"x\" (lowercase Latin letters \"x\") in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed.Determine the minimum number of characters to remove from the file name so after that the name does not contain \"xxx\" as a substring. Print 0 if the file name does not initially contain a forbidden substring \"xxx\".You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by $$$1$$$. For example, if you delete the character in the position $$$2$$$ from the string \"exxxii\", then the resulting string is \"exxii\".","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '7\\nxxaxxxa', 'output': ['1']}, {'input': '8\\nxxaxxxxa', 'output': ['2']}, {'input': '9\\nxxaxxxxax', 'output': ['3']}, {'input': '10\\nxxaxxxxxax', 'output': ['4']}, {'input': '11\\nxxaxxxxxxax', 'output': ['5']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 6\", \"9 7\", \"1 1\"]","prob_desc_input_spec":"The only line of input contains two integers r and g, separated by a single space \u2014 the number of available red and green blocks respectively (0\u2009\u2264\u2009r,\u2009g\u2009\u2264\u20092\u00b7105, r\u2009+\u2009g\u2009\u2265\u20091).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class Abood2D {\n\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint R = sc.nextInt();\n\t\tint G = sc.nextInt();\n\n\t\tint sum = G + R; \n\t\tint H = sum == 1? 1 : 0;\n\t\twhile(sum >= H)\n\t\t\tsum -= H++;\n\t\tH--;\n\t\t\n\t\tint[] acc = new int[H + 1];\n\t\t\n\t\tfor (int i = 1; i <= H; i++)\n\t\t\tacc[i] = acc[i - 1] + i;\n\t\t\n\t\t\n\t\tint[] last = new int[R + 1];\n\t\tArrays.fill(last, 1);\n\t\t\n\t\tfor (int i = H - 1; i >= 0; i--) {\n\t\t\tint[] cur = new int[R + 1];\n\t\t\t\n\t\t\tfor (int j = 0; j < cur.length; j++) {\n\t\t\t\tint r = j;\n\t\t\t\tint g = G - (acc[i] - (R - r));\n\t\t\t\t\n\t\t\t\tif(g - i >= 1)\n\t\t\t\t\tcur[j] += last[j];\n\t\t\t\tif(r - i >= 1)\n\t\t\t\t\tcur[j] += last[j - (i + 1)];\n\t\t\t\t\n\t\t\t\tcur[j] %= (int) 1e9 + 7;\n\t\t\t}\n\t\t\tlast = cur;\n\t\t}\n\t\t\n\t\tout.print(last[R]);\n\n\t\tout.flush();\n\n\t}\n\n\n\n\tstatic class Scanner \n\n\n\n\t{\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\n\t\tpublic double nextDouble() throws IOException\n\t\t{\n\t\t\tString x = next();\n\t\t\tStringBuilder sb = new StringBuilder(\"0\");\n\t\t\tdouble res = 0, f = 1;\n\t\t\tboolean dec = false, neg = false;\n\t\t\tint start = 0;\n\t\t\tif(x.charAt(0) == '-')\n\t\t\t{\n\t\t\t\tneg = true;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tfor(int i = start; i < x.length(); i++)\n\t\t\t\tif(x.charAt(i) == '.')\n\t\t\t\t{\n\t\t\t\t\tres = Long.parseLong(sb.toString());\n\t\t\t\t\tsb = new StringBuilder(\"0\");\n\t\t\t\t\tdec = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.append(x.charAt(i));\n\t\t\t\t\tif(dec)\n\t\t\t\t\t\tf *= 10;\n\t\t\t\t}\n\t\t\tres += Long.parseLong(sb.toString()) \/ f;\n\t\t\treturn res * (neg?-1:1);\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\n\n\t}\n\n\n}","prob_desc_sample_outputs":"[\"2\", \"6\", \"2\"]","lang_cluster":"Java","code_uid":"a977cd12419716342e11683009a73d89","prob_desc_notes":"NoteThe image in the problem statement shows all possible red-green towers for the first sample.","prob_desc_output_spec":"Output the only integer \u2014 the number of different possible red-green towers of height h modulo\u00a0109\u2009+\u20097.","prob_desc_output_to":"standard output","prob_desc_description":"There are r red and g green blocks for construction of the red-green tower. Red-green tower can be built following next rules:  Red-green tower is consisting of some number of levels;  Let the red-green tower consist of n levels, then the first level of this tower should consist of n blocks, second level \u2014 of n\u2009-\u20091 blocks, the third one \u2014 of n\u2009-\u20092 blocks, and so on \u2014 the last level of such tower should consist of the one block. In other words, each successive level should contain one block less than the previous one;  Each level of the red-green tower should contain blocks of the same color.  Let h be the maximum possible number of levels of red-green tower, that can be built out of r red and g green blocks meeting the rules above. The task is to determine how many different red-green towers having h levels can be built out of the available blocks.Two red-green towers are considered different if there exists some level, that consists of red blocks in the one tower and consists of green blocks in the other tower.You are to write a program that will find the number of different red-green towers of height h modulo\u00a0109\u2009+\u20097.","length":122,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5', 'output': ['6']}, {'input': '10 10', 'output': ['85']}, {'input': '0 1', 'output': ['1']}, {'input': '1 0', 'output': ['1']}, {'input': '100000 100000', 'output': ['187690724']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"19\", \"16\"]","prob_desc_input_spec":"The first and only line contains an integer $$$r$$$ ($$$1 \\le r \\le 10^{12}$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/\/1184A1\nimport java.util.*;\npublic class heidiA1{\n  public static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    long r=sc.nextLong();\n    if(r%2==0||r<=3)\n    System.out.println(\"NO\");\n    else{\n      System.out.println(\"1\"+\" \"+((r-3)\/2));\n    }\n  }\n}\n","prob_desc_sample_outputs":"[\"1 8\", \"NO\"]","lang_cluster":"Java","code_uid":"fee9375acf5a84794c8d5e2a7a1fa945","prob_desc_notes":null,"prob_desc_output_spec":"Output integers $$$x, y$$$ such that $$$H(x,y) = r$$$ and $$$x$$$ is smallest possible, or \"NO\" if no such pair exists.","prob_desc_output_to":"standard output","prob_desc_description":"Melody Pond was stolen from her parents as a newborn baby by Madame Kovarian, to become a weapon of the Silence in their crusade against the Doctor. Madame Kovarian changed Melody's name to River Song, giving her a new identity that allowed her to kill the Eleventh Doctor.Heidi figured out that Madame Kovarian uses a very complicated hashing function in order to change the names of the babies she steals. In order to prevent this from happening to future Doctors, Heidi decided to prepare herself by learning some basic hashing techniques.The first hashing function she designed is as follows.Given two positive integers $$$(x, y)$$$ she defines $$$H(x,y):=x^2+2xy+x+1$$$.Now, Heidi wonders if the function is reversible. That is, given a positive integer $$$r$$$, can you find a pair $$$(x, y)$$$ (of positive integers) such that $$$H(x, y) = r$$$?If multiple such pairs exist, output the one with smallest possible $$$x$$$. If there is no such pair, output \"NO\".","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n', 'output': ['1 1\\n']}, {'input': '7\\n', 'output': ['1 2\\n']}, {'input': '9\\n', 'output': ['1 3\\n']}, {'input': '11\\n', 'output': ['1 4\\n']}, {'input': '2\\n', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"24 0\", \"24 1\", \"24 -1\", \"4 -7\", \"1 1\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$p$$$ ($$$1 \\leq n \\leq 10^9$$$, $$$-1000 \\leq p \\leq 1000$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.StringTokenizer;\n\npublic class TaskC {\n    public static String doMain(Reader reader) throws IOException {\n        MyReader in = new MyReader(reader);\n        int n = in.nextInt();\n        int p = in.nextInt();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; n - i * p >= i; ++i) {\n            int count = check(n - p * i);\n            if (count > i){\n                continue;\n            }\n            return i+\"\";\n        }\n        return \"-1\";\n    }\n\n    private static int check(int n) {\n        int answer = 0;\n        while (n > 0) {\n            answer += n % 2;\n            n \/= 2;\n        }\n        return answer;\n    }\n\n    public static void main(String[] args) throws IOException {\n        String result = doMain(new InputStreamReader(System.in));\n        System.out.println(result);\n    }\n\n    static class MyReader {\n        BufferedReader bf;\n\n        StringTokenizer st;\n\n        String last;\n\n        MyReader(Reader reader) throws IOException {\n            bf = new BufferedReader(reader);\n            readNextLine();\n        }\n\n        String nextToken() throws IOException {\n            while (!st.hasMoreTokens()) {\n                readNextLine();\n            }\n            return st.nextToken();\n        }\n\n        void readNextLine() throws IOException {\n            last = bf.readLine();\n            if (last == null) last = \"\";\n            st = new StringTokenizer(last);\n        }\n\n        String nextLine() throws IOException {\n            String s = last;\n            readNextLine();\n            return s;\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        int[] readIntArray(int n) throws IOException {\n            int[] answer = new int[n];\n            for (int i = 0; i < n; ++i) {\n                answer[i] = nextInt();\n            }\n            return answer;\n        }\n\n        long[] readLongArray(int n) throws IOException {\n            long[] answer = new long[n];\n            for (int i = 0; i < n; ++i) {\n                answer[i] = nextLong();\n            }\n            return answer;\n        }\n\n        double[] readDoubleArray(int n) throws IOException {\n            double[] answer = new double[n];\n            for (int i = 0; i < n; ++i) {\n                answer[i] = nextDouble();\n            }\n            return answer;\n        }\n    }\n}\n","prob_desc_sample_outputs":"[\"2\", \"3\", \"4\", \"2\", \"-1\"]","lang_cluster":"Java","code_uid":"a44c692761f655671c553a3fd68e9191","prob_desc_notes":"Note$$$0$$$-binary numbers are just regular binary powers, thus in the first sample case we can represent $$$24 = (2^4 + 0) + (2^3 + 0)$$$.In the second sample case, we can represent $$$24 = (2^4 + 1) + (2^2 + 1) + (2^0 + 1)$$$.In the third sample case, we can represent $$$24 = (2^4 - 1) + (2^2 - 1) + (2^2 - 1) + (2^2 - 1)$$$. Note that repeated summands are allowed.In the fourth sample case, we can represent $$$4 = (2^4 - 7) + (2^1 - 7)$$$. Note that the second summand is negative, which is allowed.In the fifth sample case, no representation is possible.","prob_desc_output_spec":"If it is impossible to represent $$$n$$$ as the sum of any number of $$$p$$$-binary numbers, print a single integer $$$-1$$$. Otherwise, print the smallest possible number of summands.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya will fancy any number as long as it is an integer power of two. Petya, on the other hand, is very conservative and only likes a single integer $$$p$$$ (which may be positive, negative, or zero). To combine their tastes, they invented $$$p$$$-binary numbers of the form $$$2^x + p$$$, where $$$x$$$ is a non-negative integer.For example, some $$$-9$$$-binary (\"minus nine\" binary) numbers are: $$$-8$$$ (minus eight), $$$7$$$ and $$$1015$$$ ($$$-8=2^0-9$$$, $$$7=2^4-9$$$, $$$1015=2^{10}-9$$$).The boys now use $$$p$$$-binary numbers to represent everything. They now face a problem: given a positive integer $$$n$$$, what's the smallest number of $$$p$$$-binary numbers (not necessarily distinct) they need to represent $$$n$$$ as their sum? It may be possible that representation is impossible altogether. Help them solve this problem.For example, if $$$p=0$$$ we can represent $$$7$$$ as $$$2^0 + 2^1 + 2^2$$$.And if $$$p=-9$$$ we can represent $$$7$$$ as one number $$$(2^4-9)$$$.Note that negative $$$p$$$-binary numbers are allowed to be in the sum (see the Notes section for an example).","length":104,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '100 0', 'output': ['3\\n']}, {'input': '50 -5', 'output': ['4\\n']}, {'input': '200 10', 'output': ['5\\n']}, {'input': '500 -50', 'output': ['6\\n']}, {'input': '1000 100', 'output': ['7\\n']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":2400.0,"prob_desc_time_limit":"3 seconds","prob_desc_sample_inputs":"[\"4\", \"3\"]","prob_desc_input_spec":"The only line contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^6$$$), denoting the required number of vertices.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class E {\n\t\n\tstatic int[] tree;\n\t\n\tstatic void fill(int idx) {\n\t\tif (idx >= tree.length) return;\n\t\tfill(2 * idx);\n\t\tfill(2 * idx + 1);\n\t\ttree[idx] = 1;\n\t\tif (2 * idx < tree.length) tree[idx] += tree[2 * idx];\n\t\tif (2 * idx + 1 < tree.length) tree[idx] += tree[2 * idx + 1];\n\t}\n\t\n\tstatic boolean shouldAdd(int idx) {\n\t\tif (idx % 2 == 1) return true;\n\t\twhile (idx % 2 == 0) {\n\t\t\tidx \/= 2;\n\t\t}\n\t\treturn tree[2 * idx] % 2 == 0;\n\t}\n\t\n\tstatic void add(int idx) {\n\t\twhile (idx >= 1) {\n\t\t\ttree[idx]++;\n\t\t\tidx \/= 2;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint level = 0, got = 1;\n\t\twhile (N >= got) {\n\t\t\tN -= got;\n\t\t\tlevel++;\n\t\t\tgot *= 2;\n\t\t}\n\t\ttree = new int[1 << level];\n\t\tfill(1);\n\t\tfor (int i = tree.length - 1; i > 1 << (level-1); i--) {\n\t\t\tif (shouldAdd(i)) {\n\t\t\t\tadd(i);\n\t\t\t\tN--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(N == 0 || N == 1 ? 1 : 0);\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n","prob_desc_sample_outputs":"[\"1\", \"0\"]","lang_cluster":"Java","code_uid":"30b8ecacac4f21f7185cee754cd0b99d","prob_desc_notes":"NoteIn the first example, this is the only tree that satisfies the conditions: In the second example, here are various trees that don't satisfy some condition: ","prob_desc_output_spec":"Output the number of perfectly balanced striped binary search trees with $$$n$$$ vertices and distinct integer keys between $$$1$$$ and $$$n$$$, inclusive, modulo $$$998\\,244\\,353$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Recall that a binary search tree is a rooted binary tree, whose nodes each store a key and each have at most two distinguished subtrees, left and right. The key in each node must be greater than any key stored in the left subtree, and less than any key stored in the right subtree.The depth of a vertex is the number of edges on the simple path from the vertex to the root. In particular, the depth of the root is $$$0$$$.Let's call a binary search tree perfectly balanced if there doesn't exist a binary search tree with the same number of vertices that has a strictly smaller sum of depths of its vertices.Let's call a binary search tree with integer keys striped if both of the following conditions are satisfied for every vertex $$$v$$$:   If $$$v$$$ has a left subtree whose root is $$$u$$$, then the parity of the key of $$$v$$$ is different from the parity of the key of $$$u$$$.  If $$$v$$$ has a right subtree whose root is $$$w$$$, then the parity of the key of $$$v$$$ is the same as the parity of the key of $$$w$$$. You are given a single integer $$$n$$$. Find the number of perfectly balanced striped binary search trees with $$$n$$$ vertices that have distinct integer keys between $$$1$$$ and $$$n$$$, inclusive. Output this number modulo $$$998\\,244\\,353$$$.","length":86,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n', 'output': ['1\\n']}, {'input': '2\\n', 'output': ['1\\n']}, {'input': '5\\n', 'output': ['0\\n']}, {'input': '6\\n', 'output': ['1\\n']}, {'input': '7\\n', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 3\", \"10 15\"]","prob_desc_input_spec":"The only line contains two integers a,\u2009b (1\u2009\u2264\u2009a\u2009\u2264\u2009b\u2009\u2264\u2009106) \u2014 the first and the last number typed by Max.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/*package whatever \/\/do not write package name here *\/\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class S {\n\tpublic static void main (String[] args) {\n\t    Scanner in=new Scanner(System.in);\n\t\tint a=in.nextInt();\n\t\tint b=in.nextInt();\n\t\tMap<Character,Integer> m= new HashMap<>();\n\t\tm.put('0',6);m.put('1',2);m.put('2',5);m.put('3',5);m.put('4',4);m.put('5',5);m.put('6',6);m.put('7',3);\n\t\tm.put('8',7);m.put('9',6);\n\t\tint r=0;\n\t\tfor(int i=a;i<=b;i++)\n\t\t{\n\t\t    String s=String.valueOf(i);\n\t\t    for(int j=0;j<s.length();j++)\n\t\t    {\n\t\t        r=r+m.get(s.charAt(j));\n\t\t    }\n\t\t}\n\t\tSystem.out.println(r);\n\t}\n}","prob_desc_sample_outputs":"[\"12\", \"39\"]","lang_cluster":"Java","code_uid":"7a75b9f867c3f1f974048c01133ed3e6","prob_desc_notes":null,"prob_desc_output_spec":"Print the only integer a \u2014 the total number of printed segments.","prob_desc_output_to":"standard output","prob_desc_description":"Once Max found an electronic calculator from his grandfather Dovlet's chest. He noticed that the numbers were written with seven-segment indicators (https:\/\/en.wikipedia.org\/wiki\/Seven-segment_display).  Max starts to type all the values from a to b. After typing each number Max resets the calculator. Find the total number of segments printed on the calculator.For example if a\u2009=\u20091 and b\u2009=\u20093 then at first the calculator will print 2 segments, then \u2014 5 segments and at last it will print 5 segments. So the total number of printed segments is 12.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['2']}, {'input': '5 5', 'output': ['5']}, {'input': '10 10', 'output': ['7']}, {'input': '100 100', 'output': ['13']}, {'input': '999999 1000000', 'output': ['19']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 2\", \"3 3\"]","prob_desc_input_spec":"The input data contains two space-separated positive integer numbers n and h (n\u2009\u2264\u200935, h\u2009\u2264\u2009n).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/\/package com.company;\nimport java.io.*;\npublic class Main {\n    public static void main(String[] args)throws IOException{\n        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = buffer.readLine().split(\" \");\n        int nodes = Integer.parseInt(line[0]);\n        int height = Integer.parseInt(line[1]);\n        int n = 36;\n        long[][] dynamic = new long[n][n];\n\n        \/\/fill first column with 1s, creates buffer\n        for(int i = 0 ; i < n; i++)\n            dynamic[0][i] = 1;\n\n        \/\/count all the trees\n        for(int i = 1; i < n; i++){\n            for(int j = 1; j < n; j++){\n                for(int k = 0; k < i ;k++)\n                    dynamic[i][j] += dynamic[k][j - 1] * dynamic[i - k - 1][j - 1];\n            }\n        }\n        \/\/the amount of trees to jump\n        System.out.println(dynamic[nodes][35] - dynamic[nodes][height - 1]);\n    }\n}","prob_desc_sample_outputs":"[\"5\", \"4\"]","lang_cluster":"Java","code_uid":"0f024ba7f58f86a52002001418751575","prob_desc_notes":null,"prob_desc_output_spec":"Output one number \u2014 the answer to the problem. It is guaranteed that it does not exceed 9\u00b71018.","prob_desc_output_to":"standard output","prob_desc_description":"In one very old text file there was written Great Wisdom. This Wisdom was so Great that nobody could decipher it, even Phong \u2014 the oldest among the inhabitants of Mainframe. But still he managed to get some information from there. For example, he managed to learn that User launches games for pleasure \u2014 and then terrible Game Cubes fall down on the city, bringing death to those modules, who cannot win the game...For sure, as guard Bob appeared in Mainframe many modules stopped fearing Game Cubes. Because Bob (as he is alive yet) has never been defeated by User, and he always meddles with Game Cubes, because he is programmed to this.However, unpleasant situations can happen, when a Game Cube falls down on Lost Angles. Because there lives a nasty virus \u2014 Hexadecimal, who is... mmm... very strange. And she likes to play very much. So, willy-nilly, Bob has to play with her first, and then with User.This time Hexadecimal invented the following entertainment: Bob has to leap over binary search trees with n nodes. We should remind you that a binary search tree is a binary tree, each node has a distinct key, for each node the following is true: the left sub-tree of a node contains only nodes with keys less than the node's key, the right sub-tree of a node contains only nodes with keys greater than the node's key. All the keys are different positive integer numbers from 1 to n. Each node of such a tree can have up to two children, or have no children at all (in the case when a node is a leaf).In Hexadecimal's game all the trees are different, but the height of each is not lower than h. In this problem \u00abheight\u00bb stands for the maximum amount of nodes on the way from the root to the remotest leaf, the root node and the leaf itself included. When Bob leaps over a tree, it disappears. Bob gets the access to a Cube, when there are no trees left. He knows how many trees he will have to leap over in the worst case. And you?","length":26,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3', 'output': ['42']}, {'input': '10 5', 'output': ['16796']}, {'input': '15 7', 'output': ['129644790']}, {'input': '20 10', 'output': ['35345263800']}, {'input': '25 12', 'output': ['4861946401452']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 3\", \"3 1\"]","prob_desc_input_spec":"In the only line you are given two integers a, b (0\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of even and odd steps, accordingly.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\npublic class A761 {\n    public static void main(String []args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m =sc.nextInt();\n        if(Math.abs(m-n) == 1 || (m+n!=0  && m==n) )\n        {\n            System.out.println(\"YES\");\n        }\n        else\n        {\n            System.out.println(\"NO\");\n        }\n    }\n    \n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Java","code_uid":"3794aa48bbe40fc67062ad2d7b8738a1","prob_desc_notes":"NoteIn the first example one of suitable intervals is from 1 to 5. The interval contains two even steps\u00a0\u2014 2 and 4, and three odd: 1, 3 and 5.","prob_desc_output_spec":"In the only line print \"YES\", if the interval of steps described above exists, and \"NO\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"On her way to programming school tiger Dasha faced her first test \u2014 a huge staircase!  The steps were numbered from one to infinity. As we know, tigers are very fond of all striped things, it is possible that it has something to do with their color. So on some interval of her way she calculated two values \u2014 the number of steps with even and odd numbers. You need to check whether there is an interval of steps from the l-th to the r-th (1\u2009\u2264\u2009l\u2009\u2264\u2009r), for which values that Dasha has found are correct.","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4 5', 'output': ['YES']}, {'input': '6 6', 'output': ['YES']}, {'input': '0 0', 'output': ['NO']}, {'input': '1 3', 'output': ['NO']}, {'input': '10 9', 'output': ['YES']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3+2+1\", \"1+1+3+1+3\", \"2\"]","prob_desc_input_spec":"The first line contains a non-empty string s \u2014 the sum Xenia needs to count. String s contains no spaces. It only contains digits and characters \"+\". Besides, string s is a correct sum of numbers 1, 2 and 3. String s is at most 100 characters long.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n public static void main(String[] args) {\n        Scanner lector = new Scanner(System.in);\n        PriorityQueue<Integer> list = new PriorityQueue();\n        String s = lector.next();\n        int x;\n        \n        for(char c:s.toCharArray()){\n            if(c!='+'){\n                list.add(c-48);\n            }  \n        }\n        \n        x = list.size();\n        \n        for (int i = 0; i < (x-1); i++) {\n             System.out.print(list.poll()+\"+\");\n        }\n            System.out.println(list.poll());\n    } }\n\/\/ 1509316386944\n","prob_desc_sample_outputs":"[\"1+2+3\", \"1+1+1+3+3\", \"2\"]","lang_cluster":"Java","code_uid":"cc6ebefb95c2c53d0ac19fde839e3e2a","prob_desc_notes":null,"prob_desc_output_spec":"Print the new sum that Xenia can count.","prob_desc_output_to":"standard output","prob_desc_description":"Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+3.You've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3+2+1+3+1+2', 'output': ['1+1+2+2+3+3']}, {'input': '1+3+2+1+3+2+1', 'output': ['1+1+1+2+2+3+3']}, {'input': '3+3+3+3+3', 'output': ['3+3+3+3+3']}, {'input': '1+1+1+1+1', 'output': ['1+1+1+1+1']}, {'input': '2+2+2+2+2', 'output': ['2+2+2+2+2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"18 2\", \"9 10\", \"1000000000000 5\", \"1000000000000 499999999999\"]","prob_desc_input_spec":"The first (and the only) line of input contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u20091012), where n is the number of students and k is the ratio between the number of certificates and the number of diplomas.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\n\n \nimport java.io.*;\n \n \n import java.util.*;\n\n    public class Training {\n \n      public static void main(String[] args) throws IOException {\n        Scanner input = new Scanner(System.in);\n        long n = input.nextLong(),k= input.nextLong();\n        \n         long a  = n\/2\/(k+1);\n         long b = a *k  ;\n          System.out.println(a +\" \"+b+\" \"+(n-a-b));\n          \n        \n\n     }  \/\/ end main \n \n    }","prob_desc_sample_outputs":"[\"3 6 9\", \"0 0 9\", \"83333333333 416666666665 500000000002\", \"1 499999999999 500000000000\"]","lang_cluster":"Java","code_uid":"84a64fe4cc96ac9ae4771834484fec82","prob_desc_notes":null,"prob_desc_output_spec":"Output three numbers: the number of students with diplomas, the number of students with certificates and the number of students who are not winners in case when the number of winners is maximum possible. It's possible that there are no winners.","prob_desc_output_to":"standard output","prob_desc_description":"There are n students who have taken part in an olympiad. Now it's time to award the students.Some of them will receive diplomas, some wiil get certificates, and others won't receive anything. Students with diplomas and certificates are called winners. But there are some rules of counting the number of diplomas and certificates. The number of certificates must be exactly k times greater than the number of diplomas. The number of winners must not be greater than half of the number of all students (i.e. not be greater than half of n). It's possible that there are no winners.You have to identify the maximum possible number of winners, according to these rules. Also for this case you have to calculate the number of students with diplomas, the number of students with certificates and the number of students who are not winners.","length":23,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '20 3', 'output': ['4 12 4']}, {'input': '50 5', 'output': ['5 25 20']}, {'input': '100 10', 'output': ['5 50 45']}, {'input': '200 20', 'output': ['5 100 95']}, {'input': '1000 100', 'output': ['5 500 495']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\", \"12\"]","prob_desc_input_spec":"The first line of the input contains an integer x (1\u2009\u2264\u2009x\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 The coordinate of the friend's house.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\npublic class Slonik {\n\n     public static void main(String[] args){\n            Scanner scan = new Scanner(System.in);\n            int input = scan.nextInt();\n\n            float min = input \/ 5f;\n            System.out.println((int)Math.ceil(min));\n        }\n    }\n","prob_desc_sample_outputs":"[\"1\", \"3\"]","lang_cluster":"Java","code_uid":"ea7eac3a4882f97c3f41c4599a642d9c","prob_desc_notes":"NoteIn the first sample the elephant needs to make one step of length 5 to reach the point x.In the second sample the elephant can get to point x if he moves by 3, 5 and 4. There are other ways to get the optimal answer but the elephant cannot reach x in less than three moves.","prob_desc_output_spec":"Print the minimum number of steps that elephant needs to make to get from point 0 to point x.","prob_desc_output_to":"standard output","prob_desc_description":"An elephant decided to visit his friend. It turned out that the elephant's house is located at point 0 and his friend's house is located at point x(x\u2009&gt;\u20090) of the coordinate line. In one step the elephant can move 1, 2, 3, 4 or 5 positions forward. Determine, what is the minimum number of steps he need to make in order to get to his friend's house.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1']}, {'input': '6', 'output': ['2']}, {'input': '10', 'output': ['2']}, {'input': '15', 'output': ['3']}, {'input': '20', 'output': ['4']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\\n0 0 2 3\\n0 3 3 5\\n2 0 5 2\\n3 2 5 5\\n2 2 3 3\", \"4\\n0 0 2 3\\n0 3 3 5\\n2 0 5 2\\n3 2 5 5\"]","prob_desc_input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095). Next n lines contain four integers each, describing a single rectangle: x1, y1, x2, y2 (0\u2009\u2264\u2009x1\u2009&lt;\u2009x2\u2009\u2264\u200931400,\u20090\u2009\u2264\u2009y1\u2009&lt;\u2009y2\u2009\u2264\u200931400) \u2014 x1 and x2 are x-coordinates of the left and right edges of the rectangle, and y1 and y2 are y-coordinates of the bottom and top edges of the rectangle.  No two rectangles overlap (that is, there are no points that belong to the interior of more than one rectangle).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class Main {\n    private static final int MAXN = 4000000;\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] areas = new int[n];\n        int left = MAXN, right = 0, top = MAXN, bottom = 0;\n        for(int i = 0; i < n; i++) {\n            int x1, y1, x2, y2;\n            x1 = scanner.nextInt();\n            y1 = scanner.nextInt();\n            x2 = scanner.nextInt();\n            y2 = scanner.nextInt();\n\n            areas[i] = (x2 - x1) * (y2 - y1);\n            left = Math.min(x1, left);\n            right = Math.max(x2, right);\n            top = Math.min(y1, top);\n            bottom = Math.max(y2, bottom);\n        }\n\n        int total = (right - left) * (bottom - top);\n        int result = 0;\n        for(int i = 0; i < n; i++) {\n           result += areas[i];\n        }\n\n        if((total == result) && ((right - left)  == (bottom - top))) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n    }\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Java","code_uid":"fa8b00f9b6cd8dfe7ad8a8328fc8f44d","prob_desc_notes":null,"prob_desc_output_spec":"In a single line print \"YES\", if the given rectangles form a square, or \"NO\" otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"You are given n rectangles. The corners of rectangles have integer coordinates and their edges are parallel to the Ox and Oy axes. The rectangles may touch each other, but they do not overlap (that is, there are no points that belong to the interior of more than one rectangle). Your task is to determine if the rectangles form a square. In other words, determine if the set of points inside or on the border of at least one rectangle is precisely equal to the set of points inside or on the border of some square.","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n0 0 5 5', 'output': ['YES\\n']}, {'input': '2\\n0 0 2 2\\n2 2 2 2', 'output': ['NO\\n']}, {'input': '3\\n0 0 2 2\\n2 0 4 2\\n0 2 4 4', 'output': ['YES\\n']}, {'input': '4\\n0 0 1 1\\n1 0 2 1\\n0 1 1 2\\n1 1 2 2', 'output': ['YES\\n']}, {'input': '5\\n0 0 2 2\\n2 0 4 2\\n0 2 2 4\\n2 2 4 4\\n4 4 5 5', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 3 1000000\", \"3 3 2\"]","prob_desc_input_spec":"The first line contains three integers n, m, s (1\u2009\u2264\u2009n,\u2009m,\u2009s\u2009\u2264\u2009106) \u2014 length of the board, width of the board and length of the flea's jump.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class practice {\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\tstatic class Print\n\t{\n\t    private final BufferedWriter bw;\n\t    public Print()\n\t    {\n\t        bw=new BufferedWriter(new OutputStreamWriter(System.out));\n\t    }\n\t    public void print(String str)throws IOException\n\t    {\n\t        bw.append(str);\n\t    }\n\t    public void println(String str)throws IOException\n\t    {\n\t        print(str);\n\t        bw.append(\"\\n\");\n\t    }\n\t    public void close()throws IOException\n\t    {\n\t        bw.close();\n\t    }}\n\t\tpublic static void main(String[] args) throws IOException {\t\t\t\n\t\t\tFastReader scn=new FastReader();\n\t\t\tPrint p=new Print();\n\t\t\tlong n=scn.nextLong(),m=scn.nextLong(),s=scn.nextLong();\n\t\t\tlong ans=((n-1)\/s+1)*((m-1)\/s+1)*((n-1)%s+1)*((m-1)%s+1);\n\t\t\tp.println(Long.toString(ans));\n\t\t\t\n\t\t\tp.close();\n\t\t\t\n\t\t}\n}","prob_desc_sample_outputs":"[\"6\", \"4\"]","lang_cluster":"Java","code_uid":"194fb0f2a1d83dc94a3a1f204e862663","prob_desc_notes":null,"prob_desc_output_spec":"Output the only integer \u2014 the number of the required starting positions of the flea.","prob_desc_output_to":"standard output","prob_desc_description":"It is known that fleas in Berland can jump only vertically and horizontally, and the length of the jump is always equal to s centimeters. A flea has found herself at the center of some cell of the checked board of the size n\u2009\u00d7\u2009m centimeters (each cell is 1\u2009\u00d7\u20091 centimeters). She can jump as she wishes for an arbitrary number of times, she can even visit a cell more than once. The only restriction is that she cannot jump out of the board.The flea can count the amount of cells that she can reach from the starting position (x,\u2009y). Let's denote this amount by dx,\u2009y. Your task is to find the number of such starting positions (x,\u2009y), which have the maximum possible value of dx,\u2009y.","length":91,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 1', 'output': ['25\\n']}, {'input': '10 10 2', 'output': ['25\\n']}, {'input': '1000000 1000000 1', 'output': ['1000000000000\\n']}, {'input': '1000000 1000000 1000000', 'output': ['1\\n']}, {'input': '500000 500000 500000', 'output': ['4\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"7\", \"8\", \"9\"]","prob_desc_input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\leq n \\leq 10^9$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Scanner;\n\npublic class Main {\n\n\n    public static void main(String[] args) throws ParseException, IOException {\n\n         BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n         long n=Long.parseLong(br.readLine());\n         System.out.println((int)Math.ceil(1.0*(n+1)\/2));\n         \n        \n        \n\n    }\n}\n\n        ","prob_desc_sample_outputs":"[\"4\", \"5\", \"5\"]","lang_cluster":"Java","code_uid":"9693fdc58d77b222bcd5a1b2c0836cc2","prob_desc_notes":"NoteIn the first sample, there are following possible weights of splits of $$$7$$$:Weight 1: [$$$\\textbf 7$$$] Weight 2: [$$$\\textbf 3$$$, $$$\\textbf 3$$$, 1] Weight 3: [$$$\\textbf 2$$$, $$$\\textbf 2$$$, $$$\\textbf 2$$$, 1] Weight 7: [$$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$, $$$\\textbf 1$$$]","prob_desc_output_spec":"Output one integer\u00a0\u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"Let's define a split of $$$n$$$ as a nonincreasing sequence of positive integers, the sum of which is $$$n$$$. For example, the following sequences are splits of $$$8$$$: $$$[4, 4]$$$, $$$[3, 3, 2]$$$, $$$[2, 2, 1, 1, 1, 1]$$$, $$$[5, 2, 1]$$$.The following sequences aren't splits of $$$8$$$: $$$[1, 7]$$$, $$$[5, 4]$$$, $$$[11, -3]$$$, $$$[1, 1, 4, 1, 1]$$$.The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $$$[1, 1, 1, 1, 1]$$$ is $$$5$$$, the weight of the split $$$[5, 5, 3, 3, 3]$$$ is $$$2$$$ and the weight of the split $$$[9]$$$ equals $$$1$$$.For a given $$$n$$$, find out the number of different weights of its splits.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n', 'output': ['6\\n']}, {'input': '15\\n', 'output': ['8\\n']}, {'input': '20\\n', 'output': ['11\\n']}, {'input': '25\\n', 'output': ['13\\n']}, {'input': '30\\n', 'output': ['16\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"390\", \"7\", \"1000000000\"]","prob_desc_input_spec":"The only input line contains the integer $$$n$$$ ($$$1 \\le n \\le 2\\cdot10^9$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\n\nimport java.util.Scanner;\n\npublic class Nirvana {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tNirvana obj = new Nirvana();\n\t\tSystem.out.println(obj.maxMultiply(n));\n\t\t\n\t\tin.close();\n\t}\n\tint maxMultiply(int n) {\n\t\tif(n == 0)\n\t\t\treturn 1;\n\t\tint nextNum = n\/10;\n\t\tint digit = n%10;\n\t\tif(digit == 9) {\n\t\t\t\/\/ No need to borrow\n\t\t\treturn 9*maxMultiply(nextNum);\n\t\t}\n\t\tint result9 = -1;\n\t\tint resultNormal = -1;\n\t\tif(nextNum>0) {\n\t\t\t\/\/ Can borrow\n\t\t\tresult9 = 9*maxMultiply(nextNum-1);\n\t\t}\n\t\tresultNormal = digit*maxMultiply(nextNum);\n\t\treturn Math.max(result9, resultNormal);\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"216\", \"7\", \"387420489\"]","lang_cluster":"Java","code_uid":"b97713230ae1d58424ca27303c20f187","prob_desc_notes":"NoteIn the first example the maximum product is achieved for $$$389$$$ (the product of digits is $$$3\\cdot8\\cdot9=216$$$).In the second example the maximum product is achieved for $$$7$$$ (the product of digits is $$$7$$$).In the third example the maximum product is achieved for $$$999999999$$$ (the product of digits is $$$9^9=387420489$$$).","prob_desc_output_spec":"Print the maximum product of digits among all integers from $$$1$$$ to $$$n$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Kurt reaches nirvana when he finds the product of all the digits of some positive integer. Greater value of the product makes the nirvana deeper.Help Kurt find the maximum possible product of digits among all integers from $$$1$$$ to $$$n$$$.","length":34,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1']}, {'input': '10', 'output': ['0']}, {'input': '123', 'output': ['18']}, {'input': '999', 'output': ['729']}, {'input': '500', 'output': ['200']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"0 2\", \"2 0\", \"2 2\", \"2000 2000\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$m$$$ ($$$0 \\le n,m \\le 2\\,000$$$).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nIf I'm the sun, you're the moon\nBecause when I go up, you go down\n*******************************\nI'm working for the day I will surpass you\nhttps:\/\/www.a2oj.com\/Ladder16.html\n*\/\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class x1204E\n   {\n      static long MOD = 998244853L;\n      public static void main(String omkar[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int M = Integer.parseInt(st.nextToken());\n         fac = new long[4001];\n         invfac = new long[4001];\n         fac[0] = invfac[0] = 1L;\n         for(int i=1; i <= 4000; i++)\n         {\n            fac[i] = (fac[i-1]*i)%MOD;\n            invfac[i] = power(fac[i], MOD-2, MOD);\n         }\n         long[][] zero = new long[N+1][M+1];\n         Arrays.fill(zero[0], 1L);\n         for(int a=1; a <= N; a++)\n            for(int b=a; b <= M; b++)\n               zero[a][b] = (zero[a-1][b]+zero[a][b-1])%MOD;\n         long[][] dp = new long[N+1][M+1];\n         for(int a=0; a <= N; a++)\n            dp[a][0] = a;\n         for(int a=1; a <= N; a++)\n            for(int b=1; b <= M; b++)\n            {\n               long temp = (dp[a-1][b]+dp[a][b-1])%MOD;\n               temp = (temp+cnt(a-1,b)-cnt(a,b-1)+MOD)%MOD;\n               dp[a][b] = (temp+zero[a][b-1])%MOD;\n            }\n         System.out.println(dp[N][M]);\n      }\n      static long fac[];\n      static long invfac[];\n      public static long cnt(int a, int b)\n      {\n         long val = fac[a+b];\n         val = (val*invfac[a])%MOD;\n         return (val*invfac[b])%MOD;\n      }\n      public static long power(long x, long y, long p) \n      { \n          long res = 1L;      \n          x = x % p;  \n          while (y > 0) \n          { \n              if((y & 1)==1) \n                  res = (res * x) % p; \n              y = y >> 1;  \n              x = (x * x) % p;  \n          } \n          return res; \n      } \n   }","prob_desc_sample_outputs":"[\"0\", \"2\", \"5\", \"674532367\"]","lang_cluster":"Java","code_uid":"4234fe35723e947ce516646bd9ac5046","prob_desc_notes":"NoteIn the first example the only possible array is [-1,-1], its maximal prefix sum is equal to $$$0$$$. In the second example the only possible array is [1,1], its maximal prefix sum is equal to $$$2$$$. There are $$$6$$$ possible arrays in the third example:[1,1,-1,-1], f([1,1,-1,-1]) = 2[1,-1,1,-1], f([1,-1,1,-1]) = 1[1,-1,-1,1], f([1,-1,-1,1]) = 1[-1,1,1,-1], f([-1,1,1,-1]) = 1[-1,1,-1,1], f([-1,1,-1,1]) = 0[-1,-1,1,1], f([-1,-1,1,1]) = 0So the answer for the third example is $$$2+1+1+1+0+0 = 5$$$.","prob_desc_output_spec":"Output the answer to the problem modulo $$$998\\: 244\\: 853$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Natasha's favourite numbers are $$$n$$$ and $$$1$$$, and Sasha's favourite numbers are $$$m$$$ and $$$-1$$$. One day Natasha and Sasha met and wrote down every possible array of length $$$n+m$$$ such that some $$$n$$$ of its elements are equal to $$$1$$$ and another $$$m$$$ elements are equal to $$$-1$$$. For each such array they counted its maximal prefix sum, probably an empty one which is equal to $$$0$$$ (in another words, if every nonempty prefix sum is less to zero, then it is considered equal to zero). Formally, denote as $$$f(a)$$$ the maximal prefix sum of an array $$$a_{1, \\ldots ,l}$$$ of length $$$l \\geq 0$$$. Then: $$$$$$f(a) = \\max (0, \\smash{\\displaystyle\\max_{1 \\leq i \\leq l}} \\sum_{j=1}^{i} a_j )$$$$$$Now they want to count the sum of maximal prefix sums for each such an array and they are asking you to help. As this sum can be very large, output it modulo $$$998\\: 244\\: 853$$$.","length":71,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['2\\n']}, {'input': '3 3', 'output': ['20\\n']}, {'input': '5 5', 'output': ['252\\n']}, {'input': '10 10', 'output': ['48620\\n']}, {'input': '15 15', 'output': ['155117520\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\", \"5\"]","prob_desc_input_spec":"The single line contains the positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091015).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\n\npublic class _486A_CalculatingFunction {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t\/\/ TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tBigInteger n = new BigInteger(br.readLine());\n\t\t\n\t\tif (n.remainder(new BigInteger(\"2\")).equals(new BigInteger(\"0\"))) {\n\t\t\tSystem.out.println(n.divide(new BigInteger(\"2\")));\n\t\t} else {\n\t\t\tSystem.out.println(n.divide(new BigInteger(\"2\")).add(new BigInteger(\"1\")).multiply(new BigInteger(\"-1\")));\n\t\t}\n\t\t\n\t\tbr.close();\n\t}\n\n}","prob_desc_sample_outputs":"[\"2\", \"-3\"]","lang_cluster":"Java","code_uid":"ca32dd2091400ce30c481950d9383602","prob_desc_notes":"Notef(4)\u2009=\u2009\u2009-\u20091\u2009+\u20092\u2009-\u20093\u2009+\u20094\u2009=\u20092f(5)\u2009=\u2009\u2009-\u20091\u2009+\u20092\u2009-\u20093\u2009+\u20094\u2009-\u20095\u2009=\u2009\u2009-\u20093","prob_desc_output_spec":"Print f(n) in a single line.","prob_desc_output_to":"standard output","prob_desc_description":"For a positive integer n let's define a function f:f(n)\u2009=\u2009\u2009-\u20091\u2009+\u20092\u2009-\u20093\u2009+\u2009..\u2009+\u2009(\u2009-\u20091)nn Your task is to calculate f(n) for a given integer n.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['-1']}, {'input': '2', 'output': ['1']}, {'input': '3', 'output': ['-2']}, {'input': '10', 'output': ['5']}, {'input': '11', 'output': ['-6']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n6\\n1\\n1\\n1\\n1\", \"1\\n10\\n5\", \"3\\n6\\n1\\n6\\n5\", \"3\\n7\\n1\\n6\\n5\"]","prob_desc_input_spec":"The first line contains a single integer $$$n$$$ $$$(1 \\le n \\le 100)$$$ \u2014 the number of benches in the park. The second line contains a single integer $$$m$$$ $$$(1 \\le m \\le 10\\,000)$$$ \u2014 the number of people additionally coming to the park. Each of the next $$$n$$$ lines contains a single integer $$$a_i$$$ $$$(1 \\le a_i \\le 100)$$$ \u2014 the initial number of people on the $$$i$$$-th bench.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.* ;\npublic class contes\n{\n   public static void main(String ar[])\n   {\n      Scanner sc =  new Scanner(System.in) ;\n      int n = sc.nextInt() ;\n      int m = sc.nextInt() ;\n      int max = 0 ;\n      int sum = 0 ;\n      for(int i = 0 ; i <n ; i++)\n         {\n            int k = sc.nextInt() ;\n            max = Math.max(max, k) ;\n            sum += k ;\n         }\n      int ans2 = m + max ;\n      int ans1 = Math.max(max, (sum + n + m - 1) \/ (n)) ;\n      System.out.println(ans1+\" \"+ans2) ;\n   }\n}","prob_desc_sample_outputs":"[\"3 7\", \"15 15\", \"6 12\", \"7 13\"]","lang_cluster":"Java","code_uid":"6ef872ef7f4b5050760c2a9f2b797be2","prob_desc_notes":"NoteIn the first example, each of four benches is occupied by a single person. The minimum $$$k$$$ is $$$3$$$. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum $$$k$$$ is $$$7$$$. That requires all six new people to occupy the same bench.The second example has its minimum $$$k$$$ equal to $$$15$$$ and maximum $$$k$$$ equal to $$$15$$$, as there is just a single bench in the park and all $$$10$$$ people will occupy it.","prob_desc_output_spec":"Print the minimum possible $$$k$$$ and the maximum possible $$$k$$$, where $$$k$$$ is the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park.","prob_desc_output_to":"standard output","prob_desc_description":"There are $$$n$$$ benches in the Berland Central park. It is known that $$$a_i$$$ people are currently sitting on the $$$i$$$-th bench. Another $$$m$$$ people are coming to the park and each of them is going to have a seat on some bench out of $$$n$$$ available.Let $$$k$$$ be the maximum number of people sitting on one bench after additional $$$m$$$ people came to the park. Calculate the minimum possible $$$k$$$ and the maximum possible $$$k$$$.Nobody leaves the taken seat during the whole process.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n10\\n2\\n2\\n2\\n2\\n2', 'output': ['4 12']}, {'input': '2\\n5\\n3\\n3', 'output': ['5 8']}, {'input': '3\\n7\\n2\\n2\\n2', 'output': ['5 9']}, {'input': '4\\n8\\n1\\n1\\n1\\n1', 'output': ['3 9']}, {'input': '1\\n15\\n5', 'output': ['20 20']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"AS\\n2H 4C TH JH AD\", \"2H\\n3D 4C AC KD AS\", \"4D\\nAS AC AD AH 5H\"]","prob_desc_input_spec":"The first line of the input contains one string which describes the card on the table. The second line contains five strings which describe the cards in your hand. Each string is two characters long. The first character denotes the rank and belongs to the set $$$\\{{\\tt 2}, {\\tt 3}, {\\tt 4}, {\\tt 5}, {\\tt 6}, {\\tt 7}, {\\tt 8}, {\\tt 9}, {\\tt T}, {\\tt J}, {\\tt Q}, {\\tt K}, {\\tt A}\\}$$$. The second character denotes the suit and belongs to the set $$$\\{{\\tt D}, {\\tt C}, {\\tt S}, {\\tt H}\\}$$$. All the cards in the input are different.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\npublic class Solution{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int t=5;\n        String[] arr=new String[t];\n        String my=sc.next();\n       for(int i=0;i<t;i++){\n            arr[i]=sc.next();\n        }\n        String ans=\"NO\";\n        for(int i=0;i<t;i++){\n            char f=my.charAt(0),s=my.charAt(1);\n            if(f==arr[i].charAt(0) || s == arr[i].charAt(1)) {\n                ans=\"YES\";\n                break;\n            }\n        }\n        System.out.println(\"\"+ans);\n        \n    }\n}","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\"]","lang_cluster":"Java","code_uid":"d7b49e635bf5a04ea72cb0a640b8135d","prob_desc_notes":"NoteIn the first example, there is an Ace of Spades (AS) on the table. You can play an Ace of Diamonds (AD) because both of them are Aces.In the second example, you cannot play any card.In the third example, you can play an Ace of Diamonds (AD) because it has the same suit as a Four of Diamonds (4D), which lies on the table.","prob_desc_output_spec":"If it is possible to play a card from your hand, print one word \"YES\". Otherwise, print \"NO\". You can print each letter in any case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"Gennady owns a small hotel in the countryside where he lives a peaceful life. He loves to take long walks, watch sunsets and play cards with tourists staying in his hotel. His favorite game is called \"Mau-Mau\".To play Mau-Mau, you need a pack of $$$52$$$ cards. Each card has a suit (Diamonds \u2014 D, Clubs \u2014 C, Spades \u2014 S, or Hearts \u2014 H), and a rank (2, 3, 4, 5, 6, 7, 8, 9, T, J, Q, K, or A).At the start of the game, there is one card on the table and you have five cards in your hand. You can play a card from your hand if and only if it has the same rank or the same suit as the card on the table.In order to check if you'd be a good playing partner, Gennady has prepared a task for you. Given the card on the table and five cards in your hand, check if you can play at least one card.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5H\\n2D 3C 4S 5D 6H', 'output': ['YES\\n']}, {'input': '7C\\n2D 3H 4S 5D 6H', 'output': ['NO\\n']}, {'input': 'TD\\n2D 3H TS 5D 6H', 'output': ['YES\\n']}, {'input': 'KH\\n2D 3H 4S KD 6H', 'output': ['YES\\n']}, {'input': '9S\\n2D 3H 4S 5D 6H', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3\\n1 4 6\", \"5\\n1 2 3 4 5\", \"5\\n1 2 3 7 8\"]","prob_desc_input_spec":"The first line contains a single integer n (3\u2009\u2264\u2009n\u2009\u2264\u2009100)\u00a0\u2014 the number of holds. The next line contains n space-separated integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u20091000), where ai is the height where the hold number i hangs. The sequence ai is increasing (i.e. each element except for the first one is strictly larger than the previous one).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class Minimum{\n    \n    public static void main(String[] args) throws IOException{\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[]tab = new int [n];\n        \/*\n        BufferedReader br = new BufferedReader( \n                            new InputStreamReader(System.in)); \n        \/\/int a=Integer.parseInt(br.readLine()) ;         \n\n        StringTokenizer st = new StringTokenizer(br.readLine()); \n        *\/\n        for (int i = 0; i<n;i++){\n            tab[i] = sc.nextInt();   \n        }\n        int x;\n        int max = Math.abs(tab[0]-tab[n-1]);\n        \n        for (int j = 1;j<n-1;j++){\n            int tre = 0;\n            for (int l =0;l<n-1;l++){\n\n                x = tab[l+1]-tab[l];\n\n                if (l+1==j){\n                    x=tab[l+2]-tab[l];\n                }\n                else if (l==j){\n                    x = tab[l+1]-tab[l-1];\n                }\n                \n\n                \n                tre = Math.max(x,tre);\n\n                \/*\n\n                if(l!=j&&l+1!=j&&tab[l+1]-tab[l]>tre){\n                    tre= tab[l+1]-tab[l];\n                }\n                else if (l==j&&tab[l+1]-tab[l-1]>tre){\n                    tre= tab[l+1]-tab[l-1];\n                }\n                else if (l+1==j&&tab[l+2]-tal[l]>tre){\n                    tre = tab[l+2]-tab[l]; \n                }\n                *\/\n\n            }\n\n            if (tre<max){\n                max= tre;\n            }\n        }\n    \n        System.out.print(max);\n    }\n}\n","prob_desc_sample_outputs":"[\"5\", \"2\", \"4\"]","lang_cluster":"Java","code_uid":"ab855196fe30b363445f0cc48faf0c6a","prob_desc_notes":"NoteIn the first sample you can remove only the second hold, then the sequence looks like (1,\u20096), the maximum difference of the neighboring elements equals 5.In the second test after removing every hold the difficulty equals 2.In the third test you can obtain sequences (1,\u20093,\u20097,\u20098), (1,\u20092,\u20097,\u20098), (1,\u20092,\u20093,\u20098), for which the difficulty is 4, 5 and 5, respectively. Thus, after removing the second element we obtain the optimal answer \u2014 4.","prob_desc_output_spec":"Print a single number \u2014 the minimum difficulty of the track after removing a single hold.","prob_desc_output_to":"standard output","prob_desc_description":"Mike is trying rock climbing but he is awful at it. There are n holds on the wall, i-th hold is at height ai off the ground. Besides, let the sequence ai increase, that is, ai\u2009&lt;\u2009ai\u2009+\u20091 for all i from 1 to n\u2009-\u20091; we will call such sequence a track. Mike thinks that the track a1, ..., an has difficulty . In other words, difficulty equals the maximum distance between two holds that are adjacent in height.Today Mike decided to cover the track with holds hanging on heights a1, ..., an. To make the problem harder, Mike decided to remove one hold, that is, remove one element of the sequence (for example, if we take the sequence (1,\u20092,\u20093,\u20094,\u20095) and remove the third element from it, we obtain the sequence (1,\u20092,\u20094,\u20095)). However, as Mike is awful at climbing, he wants the final difficulty (i.e. the maximum difference of heights between adjacent holds after removing the hold) to be as small as possible among all possible options of removing a hold. The first and last holds must stay at their positions.Help Mike determine the minimum difficulty of the track after removing one hold.","length":62,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\n1 3 6 8', 'output': ['3\\n']}, {'input': '5\\n1 2 4 6 8', 'output': ['2\\n']}, {'input': '6\\n1 2 3 5 7 9', 'output': ['2\\n']}, {'input': '7\\n1 3 5 7 9 11 13', 'output': ['2\\n']}, {'input': '8\\n1 2 3 4 6 8 10 12', 'output': ['2\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3 5\", \"7 11\", \"7 9\"]","prob_desc_input_spec":"The first and only input line contains two positive integers \u2014 n and m (2\u2009\u2264\u2009n\u2009&lt;\u2009m\u2009\u2264\u200950). It is guaranteed that n is prime. Pretests contain all the cases with restrictions 2\u2009\u2264\u2009n\u2009&lt;\u2009m\u2009\u2264\u20094.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class PanoramixsPrediction {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n    Integer[] a = new Integer[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};\n    List<Integer> primes = Arrays.asList(a);\n    if (primes.indexOf(n) + 1 < primes.size() && primes.get(primes.indexOf(n) + 1) == m) {\n      System.out.println(\"YES\");\n    } else {\n      System.out.println(\"NO\");\n    }\n    sc.close();\n  }\n}\n","prob_desc_sample_outputs":"[\"YES\", \"YES\", \"NO\"]","lang_cluster":"Java","code_uid":"f96cd55a31b67dd9e057cd6f04b544ee","prob_desc_notes":null,"prob_desc_output_spec":"Print YES, if m is the next prime number after n, or NO otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.The next prime number after x is the smallest prime number greater than x. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is\u00a0not the next prime number for 2.One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly x Roman soldiers, where x is a prime number, and next day they beat exactly y Roman soldiers, where y is the next prime number after x, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.Yesterday the Gauls beat n Roman soldiers and it turned out that the number n was prime! Today their victims were a troop of m Romans (m\u2009&gt;\u2009n). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 3', 'output': ['YES\\n']}, {'input': '5 7', 'output': ['YES\\n']}, {'input': '11 13', 'output': ['YES\\n']}, {'input': '17 19', 'output': ['YES\\n']}, {'input': '23 25', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 5\", \"4 8\"]","prob_desc_input_spec":"The only line of the input contains two integers n and t (1\u2009\u2264\u2009n\u2009\u2264\u200910,\u20090\u2009\u2264\u2009t\u2009\u2264\u200910\u2009000)\u00a0\u2014 the height of the pyramid and the number of seconds Vlad will be pouring champagne from the bottle.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.StringTokenizer;\n\n\/**\n * Created by sachin.goyal on 16\/05\/16.\n *\/\npublic class MainB {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int t = in.nextInt();\n            if(t == 0){\n                out.print(0);\n                return;\n            }\n            double[][] ans = new double[11][11];\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++) {\n                    ans[i][j] = 0d;\n                }}\n            ans[0][0] = t;\n\n            int finalAns = 1;\n            for(int i=1;i<n;i++){\n                for(int j=0;j<=i;j++){\n                    int left = j-1;\n                    int right = left+1;\n                    ans[i][j] += left >=0 && ans[i-1][left] > 1? (ans[i-1][left] -1)\/2 : 0;\n                    ans[i][j] += right<=i-1 && ans[i-1][right] > 1 ? (ans[i-1][right] -1)\/2 : 0;\n                    if(ans[i][j] >= 1d) finalAns++;\n                }\n            }\n            out.print(finalAns);\n\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n","prob_desc_sample_outputs":"[\"4\", \"6\"]","lang_cluster":"Java","code_uid":"b2ad6be255a1a424ec7d1ce7625bc71f","prob_desc_notes":"NoteIn the first sample, the glasses full after 5 seconds are: the top glass, both glasses on the second level and the middle glass at the bottom level. Left and right glasses of the bottom level will be half-empty.","prob_desc_output_spec":"Print the single integer\u00a0\u2014 the number of completely full glasses after t seconds.","prob_desc_output_to":"standard output","prob_desc_description":"Mary has just graduated from one well-known University and is now attending celebration party. Students like to dream of a beautiful life, so they used champagne glasses to construct a small pyramid. The height of the pyramid is n. The top level consists of only 1 glass, that stands on 2 glasses on the second level (counting from the top), then 3 glasses on the third level and so on.The bottom level consists of n glasses.Vlad has seen in the movies many times how the champagne beautifully flows from top levels to bottom ones, filling all the glasses simultaneously. So he took a bottle and started to pour it in the glass located at the top of the pyramid.Each second, Vlad pours to the top glass the amount of champagne equal to the size of exactly one glass. If the glass is already full, but there is some champagne flowing in it, then it pours over the edge of the glass and is equally distributed over two glasses standing under. If the overflowed glass is at the bottom level, then the champagne pours on the table. For the purpose of this problem we consider that champagne is distributed among pyramid glasses immediately. Vlad is interested in the number of completely full glasses if he stops pouring champagne in t seconds.Pictures below illustrate the pyramid consisting of three levels.   ","length":73,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['1']}, {'input': '2 2', 'output': ['2']}, {'input': '3 3', 'output': ['3']}, {'input': '4 4', 'output': ['4']}, {'input': '5 5', 'output': ['5']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\\n0 2 1\", \"2\\n1 1\"]","prob_desc_input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\leq n \\leq 100$$$)\u00a0\u2014 the number of floors. The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\leq a_i \\leq 100$$$)\u00a0\u2014 the number of people on each floor.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/* package whatever; \/\/ don't place package name! *\/\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\/* Name of the class has to be \"Main\" only if the class is public. *\/\npublic class Ideone\n{\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int arr[] = new int[n];\n        for(int i = 0 ; i < n ;++i) {\n            arr[i] = scanner.nextInt();\n        }\n\n        int finalCount = Integer.MAX_VALUE;\n        for(int maxPos = 0; maxPos < n ;++maxPos) {\n            int totalCount = 0;\n            for (int i = 0; i < n; ++i) {\n                int singleVal = 2 * Math.abs(maxPos - i) + 2 * i + 2 * maxPos;\n                totalCount += (arr[i] * singleVal);\n            }\n            if(finalCount > totalCount) {\n                finalCount = totalCount;\n            }\n        }\n\n        System.out.println(finalCount);\n    }\n}","prob_desc_sample_outputs":"[\"16\", \"4\"]","lang_cluster":"Java","code_uid":"b1394049d2263a836e976e90cc9460e2","prob_desc_notes":"NoteIn the first example, the answer can be achieved by choosing the second floor as the $$$x$$$-th floor. Each person from the second floor (there are two of them) would spend $$$4$$$ units of electricity per day ($$$2$$$ to get down and $$$2$$$ to get up), and one person from the third would spend $$$8$$$ units of electricity per day ($$$4$$$ to get down and $$$4$$$ to get up). $$$4 \\cdot 2 + 8 \\cdot 1 = 16$$$.In the second example, the answer can be achieved by choosing the first floor as the $$$x$$$-th floor.","prob_desc_output_spec":"In a single line, print the answer to the problem\u00a0\u2014 the minimum number of electricity units.","prob_desc_output_to":"standard output","prob_desc_description":"The Fair Nut lives in $$$n$$$ story house. $$$a_i$$$ people live on the $$$i$$$-th floor of the house. Every person uses elevator twice a day: to get from the floor where he\/she lives to the ground (first) floor and to get from the first floor to the floor where he\/she lives, when he\/she comes back home in the evening. It was decided that elevator, when it is not used, will stay on the $$$x$$$-th floor, but $$$x$$$ hasn't been chosen yet. When a person needs to get from floor $$$a$$$ to floor $$$b$$$, elevator follows the simple algorithm:   Moves from the $$$x$$$-th floor (initially it stays on the $$$x$$$-th floor) to the $$$a$$$-th and takes the passenger.  Moves from the $$$a$$$-th floor to the $$$b$$$-th floor and lets out the passenger (if $$$a$$$ equals $$$b$$$, elevator just opens and closes the doors, but still comes to the floor from the $$$x$$$-th floor).  Moves from the $$$b$$$-th floor back to the $$$x$$$-th.  The elevator never transposes more than one person and always goes back to the floor $$$x$$$ before transposing a next passenger. The elevator spends one unit of electricity to move between neighboring floors. So moving from the $$$a$$$-th floor to the $$$b$$$-th floor requires $$$|a - b|$$$ units of electricity.Your task is to help Nut to find the minimum number of electricity units, that it would be enough for one day, by choosing an optimal the $$$x$$$-th floor. Don't forget than elevator initially stays on the $$$x$$$-th floor. ","length":33,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 4 5', 'output': ['60\\n']}, {'input': '1\\n100', 'output': ['0\\n']}, {'input': '3\\n3 3 3', 'output': ['36\\n']}, {'input': '4\\n0 0 0 0', 'output': ['0\\n']}, {'input': '2\\n50 50', 'output': ['200\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\\n1 -2 0\", \"6\\n16 23 16 15 42 8\"]","prob_desc_input_spec":"The first line contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of elements in a. The second line contains n integers a1, a2, ..., an (\u2009-\u2009100\u2009\u2264\u2009ai\u2009\u2264\u2009100) \u2014 the elements of sequence a.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class a {\n\tpublic static void main(String[]args) {\n\t\tScanner input=new Scanner (System.in);\n\t\tint n=input.nextInt();\n\t    int b=0;\n\t    int c=0;\n\t    int []x=new int [101];\n\t    int k=0;\n\t    while (k<n) {\n\t    \t x[k]=input.nextInt();\n\t    \t k=k+1; \n\t    }\n\t    int y=x[0];\n\t    for (int t=1;t<n;t++) {\n\t    \tif(x[t]<y)\n\t    \t\ty=x[t];\n\t    }\n\t    if (y>=0) {\n\t    \tfor (int q=0;q<n;q++) {\n\t    \t     b=b+x[q];\n\t    \t}\n\t    \tc=0;\n\t    }\n\t    else {\n\t    \tfor (int w=0;w<n;w++) {\n\t    \t\tif (x[w]>=0)\n\t    \t\t\tb=b+x[w];\n\t    \t\telse c=c+x[w];\n\t    \t}\n\t    \t\t\n\t    }\n\t    System.out.print(b-c);\n\t}\n\n}","prob_desc_sample_outputs":"[\"3\", \"120\"]","lang_cluster":"Java","code_uid":"93e9b8cc31e684206e23f7ddf2acb82c","prob_desc_notes":"NoteIn the first example we may choose b\u2009=\u2009{1,\u20090}, c\u2009=\u2009{\u2009-\u20092}. Then B\u2009=\u20091, C\u2009=\u2009\u2009-\u20092, B\u2009-\u2009C\u2009=\u20093.In the second example we choose b\u2009=\u2009{16,\u200923,\u200916,\u200915,\u200942,\u20098}, c\u2009=\u2009{} (an empty sequence). Then B\u2009=\u2009120, C\u2009=\u20090, B\u2009-\u2009C\u2009=\u2009120.","prob_desc_output_spec":"Print the maximum possible value of B\u2009-\u2009C, where B is the sum of elements of sequence b, and C is the sum of elements of sequence c.","prob_desc_output_to":"standard output","prob_desc_description":"You are given a sequence a consisting of n integers. You may partition this sequence into two sequences b and c in such a way that every element belongs exactly to one of these sequences. Let B be the sum of elements belonging to b, and C be the sum of elements belonging to c (if some of these sequences is empty, then its sum is 0). What is the maximum possible value of B\u2009-\u2009C?","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n10 -20 30 -40 50', 'output': ['150']}, {'input': '4\\n-1 -2 -3 -4', 'output': ['10']}, {'input': '1\\n100', 'output': ['100']}, {'input': '3\\n0 0 0', 'output': ['0']}, {'input': '6\\n-10 -20 30 40 -50 60', 'output': ['210']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1400.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"12345\"]","prob_desc_input_spec":"The only line of the input contains a positive integer five digit number for which the activation code should be found.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class Problem_11 {\n    static long p = 100000;\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        String s = input.nextLine();\n        \/\/13542\n        long n = Long.valueOf(s.substring(0, 1) + s.substring(2, 3) + s.substring(4, 5) + s.substring(3, 4) + s.substring\n                (1,2));\n\n        System.out.printf(\"%05d\", (((((n * n * n) % p) * n) % p) * n) % p);\n    }\n}\n","prob_desc_sample_outputs":"[\"71232\"]","lang_cluster":"Java","code_uid":"c3f00d09b4707b71ec10f761e41328ea","prob_desc_notes":null,"prob_desc_output_spec":"Output exactly 5 digits without spaces between them \u2014 the found activation code of the program.","prob_desc_output_to":"standard output","prob_desc_description":"The protection of a popular program developed by one of IT City companies is organized the following way. After installation it outputs a random five digit number which should be sent in SMS to a particular phone number. In response an SMS activation code arrives.A young hacker Vasya disassembled the program and found the algorithm that transforms the shown number into the activation code. Note: it is clear that Vasya is a law-abiding hacker, and made it for a noble purpose \u2014 to show the developer the imperfection of their protection.The found algorithm looks the following way. At first the digits of the number are shuffled in the following order &lt;first digit&gt;&lt;third digit&gt;&lt;fifth digit&gt;&lt;fourth digit&gt;&lt;second digit&gt;. For example the shuffle of 12345 should lead to 13542. On the second stage the number is raised to the fifth power. The result of the shuffle and exponentiation of the number 12345 is 455\u00a0422\u00a0043\u00a0125\u00a0550\u00a0171\u00a0232. The answer is the 5 last digits of this result. For the number 12345 the answer should be 71232.Vasya is going to write a keygen program implementing this algorithm. Can you do the same?","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '54321', 'output': ['00000']}, {'input': '11111', 'output': ['00001']}, {'input': '22222', 'output': ['00032']}, {'input': '33333', 'output': ['00033']}, {'input': '44444', 'output': ['00044']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3\\n11 23\", \"5\\n01 07\"]","prob_desc_input_spec":"The first line contains a single integer x (1\u2009\u2264\u2009x\u2009\u2264\u200960). The second line contains two two-digit integers, hh and mm (00\u2009\u2264\u2009hh\u2009\u2264\u200923,\u200900\u2009\u2264\u2009mm\u2009\u2264\u200959).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\npublic class JamieAndAlarmSnooze {\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint x=sc.nextInt();\n\t\tint h=sc.nextInt();\n\t\tint m=sc.nextInt();\n\t\tint c=0;\n\t\twhile (h%10!=7 && m%10!=7)\n\t\t{\n\t\t\tm-=x;\n\t\t\tc++;\n\t\t\tif (m<0) \n\t\t\t{\n\t\t\t\th--;\n\t\t\t\tm+=60;\n\t\t\t}\n\t\t\t\t\n\t\t\tif (h<0) \n\t\t\t\th+=24;\n\t\t}\n\t\t\n\t\tSystem.out.println(c);\n\t\tsc.close();\n\t}\n}\n","prob_desc_sample_outputs":"[\"2\", \"0\"]","lang_cluster":"Java","code_uid":"eb6f9a86c7023729022fb72b11dd1d46","prob_desc_notes":"NoteIn the first sample, Jamie needs to wake up at 11:23. So, he can set his alarm at 11:17. He would press the snooze button when the alarm rings at 11:17 and at 11:20.In the second sample, Jamie can set his alarm at exactly at 01:07 which is lucky.","prob_desc_output_spec":"Print the minimum number of times he needs to press the button.","prob_desc_output_to":"standard output","prob_desc_description":"Jamie loves sleeping. One day, he decides that he needs to wake up at exactly hh:\u2009mm. However, he hates waking up, so he wants to make waking up less painful by setting the alarm at a lucky time. He will then press the snooze button every x minutes until hh:\u2009mm is reached, and only then he will wake up. He wants to know what is the smallest number of times he needs to press the snooze button.A time is considered lucky if it contains a digit '7'. For example, 13:\u200907 and 17:\u200927 are lucky, while 00:\u200948 and 21:\u200934 are not lucky.Note that it is not necessary that the time set for the alarm and the wake-up time are on the same day. It is guaranteed that there is a lucky time Jamie can set so that he can wake at hh:\u2009mm.Formally, find the smallest possible non-negative integer y such that the time representation of the time x\u00b7y minutes before hh:\u2009mm contains the digit '7'.Jamie uses 24-hours clock, so after 23:\u200959 comes 00:\u200900.","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n07 07', 'output': ['0\\n']}, {'input': '10\\n23 59', 'output': ['6\\n']}, {'input': '15\\n15 45', 'output': ['3\\n']}, {'input': '30\\n00 00', 'output': ['14\\n']}, {'input': '60\\n12 34', 'output': ['16\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"047\", \"16\", \"472747\"]","prob_desc_input_spec":"The single line contains a non-empty string s whose length can range from 1 to 50, inclusive. The string only contains digits. The string can contain leading zeroes.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.lang.*;\nimport java.util.*;\n\npublic class Luckysubstring {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String input = in.nextLine();\n        int count4 = 0;\n        int count7 = 0;\n        in.close();\n        if (input.contains(\"4\") || input.contains(\"7\")) {\n            for (int i = 0; i < input.length(); i++) {\n                if (input.charAt(i) == '4') {\n                    count4++;\n                } else if (input.charAt(i) == '7') {\n                    count7++;\n                }\n            }\n            if (count4 >= count7) {\n                System.out.println(4);\n            } else {\n                System.out.println(7);\n            }\n        } else {\n            System.out.println(-1);\n        }\n\n    }\n}","prob_desc_sample_outputs":"[\"4\", \"-1\", \"7\"]","lang_cluster":"Java","code_uid":"8d74bb2651d1a145ef41e02e6f589547","prob_desc_notes":"NoteThe lexicographical comparison of strings is performed by the &lt; operator in the modern programming languages. String x is lexicographically less than string y either if x is a prefix of y, or exists such i (1\u2009\u2264\u2009i\u2009\u2264\u2009min(|x|,\u2009|y|)), that xi\u2009&lt;\u2009yi and for any j (1\u2009\u2264\u2009j\u2009&lt;\u2009i) xj\u2009=\u2009yj. Here |a| denotes the length of string a.In the first sample three conditions are fulfilled for strings \"4\", \"7\" and \"47\". The lexicographically minimum one is \"4\".In the second sample s has no substrings which are lucky numbers.In the third sample the three conditions are only fulfilled for string \"7\".","prob_desc_output_spec":"In the only line print the answer to Petya's problem. If the sought string does not exist, print \"-1\" (without quotes).","prob_desc_output_to":"standard output","prob_desc_description":"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.One day Petya was delivered a string s, containing only digits. He needs to find a string that represents a lucky number without leading zeroes, is not empty, is contained in s as a substring the maximum number of times.Among all the strings for which the three conditions given above are fulfilled, Petya only needs the lexicographically minimum one. Find this string for Petya.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '444777', 'output': ['4']}, {'input': '777444', 'output': ['4']}, {'input': '1234567890', 'output': ['4']}, {'input': '7654321', 'output': ['7']}, {'input': '123456789', 'output': ['-1']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2\\n2 8\", \"3\\n5 1 10\", \"7\\n3 3 2 7 9 6 8\"]","prob_desc_input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u200920). The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u200925) \u2014 the number of times Greg repeats the exercises.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class Main{\n\n    public static void main(String[] args) throws IOException {\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nStringTokenizer st=new StringTokenizer(br.readLine());\nint n=Integer.parseInt(st.nextToken());\nst=new StringTokenizer(br.readLine());\nint Nchest=0;\nint Nbiceps=0;\nint Nback=0;\nint w=2;\n        for (int i =1; i <=n; i++) {\n            if(i % 3==0)\n                Nback+=Integer.parseInt(st.nextToken());\n            else if(i==w){\n                w=w+3;\n                Nbiceps+=Integer.parseInt(st.nextToken());\n            }\n            else\n                Nchest+=Integer.parseInt(st.nextToken());\n\n        }\nif(Nchest > Nbiceps && Nchest > Nback)\n            System.out.println(\"chest\");\nelse if( Nbiceps> Nchest && Nbiceps > Nback)\n            System.out.println(\"biceps\");\nelse\n    System.out.println(\"back\");\n    }\n\n}\n","prob_desc_sample_outputs":"[\"biceps\", \"back\", \"chest\"]","lang_cluster":"Java","code_uid":"bafe861d4a21de6a54b3a9505a24953d","prob_desc_notes":"NoteIn the first sample Greg does 2 chest, 8 biceps and zero back exercises, so the biceps gets the most exercises.In the second sample Greg does 5 chest, 1 biceps and 10 back exercises, so the back gets the most exercises.In the third sample Greg does 18 chest, 12 biceps and 8 back exercises, so the chest gets the most exercise.","prob_desc_output_spec":"Print word \"chest\" (without the quotes), if the chest gets the most exercise, \"biceps\" (without the quotes), if the biceps gets the most exercise and print \"back\" (without the quotes) if the back gets the most exercise. It is guaranteed that the input is such that the answer to the problem is unambiguous.","prob_desc_output_to":"standard output","prob_desc_description":"Greg is a beginner bodybuilder. Today the gym coach gave him the training plan. All it had was n integers a1,\u2009a2,\u2009...,\u2009an. These numbers mean that Greg needs to do exactly n exercises today. Besides, Greg should repeat the i-th in order exercise ai times.Greg now only does three types of exercises: \"chest\" exercises, \"biceps\" exercises and \"back\" exercises. Besides, his training is cyclic, that is, the first exercise he does is a \"chest\" one, the second one is \"biceps\", the third one is \"back\", the fourth one is \"chest\", the fifth one is \"biceps\", and so on to the n-th exercise.Now Greg wonders, which muscle will get the most exercise during his training. We know that the exercise Greg repeats the maximum number of times, trains the corresponding muscle the most. Help Greg, determine which muscle will get the most training.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3\\n1 2 3', 'output': ['back\\n']}, {'input': '5\\n5 5 5 5 5', 'output': ['chest\\n']}, {'input': '4\\n1 2 3 4', 'output': ['biceps\\n']}, {'input': '6\\n1 2 3 4 5 6', 'output': ['back\\n']}, {'input': '1\\n1', 'output': ['chest\\n']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6 3\"]","prob_desc_input_spec":"The only line of the input contains two integers: n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009109, 0\u2009\u2264\u2009k\u2009\u2264\u2009n).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n\npublic class scorify{\n\tpublic static void main(String[] args){\n\tScanner in=new Scanner(System.in);\n    int n = in.nextInt();\n    int k = in.nextInt();\n    \n    System.out.print((n>k && k>0) ? 1 : 0 );\n    if(k!=n){\n        if(k>1) System.out.print(\" \" + (  ( (k>=(n\/2)) ? n-k : ( (n>=k*3) ? k*2 : n-k ) ) ) );\n    \tif(k==1) System.out.print( ( n-k==1 ? (\" \" + 1) : (\" \"+2) ) );\n    \tif(k==0) System.out.print(\" \" + 0);\n    }else{System.out.print(\" \" + 0);}\n        \n    }\n}","prob_desc_sample_outputs":"[\"1 3\"]","lang_cluster":"Java","code_uid":"fdb9f68abb2c3019dcbf9ee22981c4b9","prob_desc_notes":"NoteIn the sample test, the number of good apartments could be minimum possible if, for example, apartments with indices 1, 2 and 3 were inhabited. In this case only apartment 4 is good. The maximum possible number could be, for example, if apartments with indices 1, 3 and 5 were inhabited. In this case all other apartments: 2, 4 and 6 are good.","prob_desc_output_spec":"Print the minimum possible and the maximum possible number of apartments good for Maxim.","prob_desc_output_to":"standard output","prob_desc_description":"Maxim wants to buy an apartment in a new house at Line Avenue of Metropolis. The house has n apartments that are numbered from 1 to n and are arranged in a row. Two apartments are adjacent if their indices differ by 1. Some of the apartments can already be inhabited, others are available for sale.Maxim often visits his neighbors, so apartment is good for him if it is available for sale and there is at least one already inhabited apartment adjacent to it. Maxim knows that there are exactly k already inhabited apartments, but he doesn't know their indices yet.Find out what could be the minimum possible and the maximum possible number of apartments that are good for Maxim.","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5', 'output': ['1 5\\n']}, {'input': '7 0', 'output': ['0 0\\n']}, {'input': '8 1', 'output': ['1 2\\n']}, {'input': '15 15', 'output': ['0 0\\n']}, {'input': '20 10', 'output': ['1 10\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 3\\nxyabd\", \"7 4\\nproblem\", \"2 2\\nab\", \"12 1\\nabaabbaaabbb\"]","prob_desc_input_spec":"The first line of input contains two integers\u00a0\u2014 $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 50$$$)\u00a0\u2013 the number of available stages and the number of stages to use in the rocket. The second line contains string $$$s$$$, which consists of exactly $$$n$$$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main{\n    public static void main(String[] args)throws IOException{\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tPrintWriter out = new PrintWriter(System.out);\n\tString s[] = br.readLine().split(\" \");\n\tint n = Integer.parseInt(s[0]);\n\tint k = Integer.parseInt(s[1]);\n\tchar d[] = br.readLine().toCharArray();\n\tArrays.sort(d);\n\tint ans = Integer.MAX_VALUE;\n\tfor(int i = 0; i<n;i++){\n\t    int c = d[i]-'a'+1, p = 1;\n\t    char ul = d[i];\n\t    for(int j = i+1; j<n && p<k;j++){\n\t\tif(d[j]-ul>=2){\n\t\t    ul = d[j];\n\t\t    p++;\n\t\t    c+=d[j]-'a'+1;\n\t\t}\n\t\tif(p==k){\n\t\t    break;\n\t\t}\n\t    }\n\t    if(p==k){\n\t\tans = Math.min(ans,c);\n\t    }\n\t}\n\tout.println(ans==Integer.MAX_VALUE?-1:ans);\n\tout.close();\n    }\n}\n","prob_desc_sample_outputs":"[\"29\", \"34\", \"-1\", \"1\"]","lang_cluster":"Java","code_uid":"2fdfbe018fe0d4d0839ddd87ae28b037","prob_desc_notes":"NoteIn the first example, the following rockets satisfy the condition: \"adx\" (weight is $$$1+4+24=29$$$); \"ady\" (weight is $$$1+4+25=30$$$); \"bdx\" (weight is $$$2+4+24=30$$$); \"bdy\" (weight is $$$2+4+25=31$$$).Rocket \"adx\" has the minimal weight, so the answer is $$$29$$$.In the second example, target rocket is \"belo\". Its weight is $$$2+5+12+15=34$$$.In the third example, $$$n=k=2$$$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.","prob_desc_output_to":"standard output","prob_desc_description":"Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string\u00a0\u2014 concatenation of letters, which correspond to the stages.There are $$$n$$$ stages available. The rocket must contain exactly $$$k$$$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z'\u00a0\u2014 $$$26$$$ tons.Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5\\nabcdefghij', 'output': ['15\\n']}, {'input': '26 13\\nabcdefghijklmnopqrstuvwxyz', 'output': ['87\\n']}, {'input': '3 2\\nabc', 'output': ['4\\n']}, {'input': '4 2\\nabcd', 'output': ['4\\n']}, {'input': '5 3\\nabcde', 'output': ['9\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"...QK...\\n........\\n........\\n........\\n........\\n........\\n........\\n...rk...\", \"rnbqkbnr\\npppppppp\\n........\\n........\\n........\\n........\\nPPPPPPPP\\nRNBQKBNR\", \"rppppppr\\n...k....\\n........\\n........\\n........\\n........\\nK...Q...\\n........\"]","prob_desc_input_spec":"The input contains eight lines, eight characters each \u2014 the board's description. The white pieces on the board are marked with uppercase letters, the black pieces are marked with lowercase letters. The white pieces are denoted as follows: the queen is represented is 'Q', the rook \u2014 as 'R', the bishop \u2014 as'B', the knight \u2014 as 'N', the pawn \u2014 as 'P', the king \u2014 as 'K'. The black pieces are denoted as 'q', 'r', 'b', 'n', 'p', 'k', respectively. An empty square of the board is marked as '.' (a dot).  It is not guaranteed that the given chess position can be achieved in a real game. Specifically, there can be an arbitrary (possibly zero) number pieces of each type, the king may be under attack and so on.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.Scanner;\n\npublic class codeforce519A {\n\n    static PrintWriter out;\n    static StreamTokenizer sin;\n    static BufferedReader bin;\n\n    static void setupOut() {\n        out = new PrintWriter(System.out);\n    }\n\n    static void setupString() {\n        bin = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public static void main(String[] args) throws IOException {\n        setupOut();\n        setupString();\n        Scanner in = new Scanner(System.in);\n        int x = 0;\n        int y = 0;\n\n        for (int i = 0; i < 8; i++) {\n            String s = in.next();\n            for (int j = 0; j < 8; j++) {\n                char c = s.charAt(j);\n                if (c=='Q')\n                    x+=9;\n                if (c=='R')\n                    x+=5;\n                if (c=='B')\n                    x+=3;\n                if (c=='N')\n                    x+=3;\n                if (c=='P')\n                    x+=1;\n                if (c=='q')\n                    y+=9;\n                if (c=='r')\n                    y+=5;\n                if (c=='n')\n                    y+=3;\n                if (c=='p')\n                    y+=1;\n                if (c=='b'){\n                    y+=3;\n                }\n\n            }\n        }\n        if (x==y)\n            out.print(\"Draw\");\n        if (x>y)\n            out.print(\"White\");\n        if (x<y)\n            out.print(\"Black\");\n        out.flush();\n    }\n\n}","prob_desc_sample_outputs":"[\"White\", \"Draw\", \"Black\"]","lang_cluster":"Java","code_uid":"989aa3ee0033d5adac0fc9cbb0199065","prob_desc_notes":"NoteIn the first test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals 5.In the second test sample the weights of the positions of the black and the white pieces are equal to 39.In the third test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals to 16.","prob_desc_output_spec":"Print \"White\" (without quotes) if the weight of the position of the white pieces is more than the weight of the position of the black pieces, print \"Black\" if the weight of the black pieces is more than the weight of the white pieces and print \"Draw\" if the weights of the white and black pieces are equal.","prob_desc_output_to":"standard output","prob_desc_description":"A and B are preparing themselves for programming contests.To train their logical thinking and solve problems better, A and B decided to play chess. During the game A wondered whose position is now stronger.For each chess piece we know its weight:   the queen's weight is 9,  the rook's weight is 5,  the bishop's weight is 3,  the knight's weight is 3,  the pawn's weight is 1,  the king's weight isn't considered in evaluating position. The player's weight equals to the sum of weights of all his pieces on the board.As A doesn't like counting, he asked you to help him determine which player has the larger position weight.","length":62,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '........\\n........\\n........\\n........\\n........\\n........\\n........\\n........', 'output': ['Draw']}, {'input': 'rnbqkbnr\\npppppppp\\n........\\n........\\n........\\n........\\nPPPPPPPP\\nRNBQKBNR', 'output': ['Draw']}, {'input': 'rnbqkbnr\\npppppppp\\n........\\n........\\n........\\n........\\nPPPPPPPP\\nRNBQKBN.', 'output': ['Black']}, {'input': 'rnbqkbnr\\npppppppp\\n........\\n........\\n........\\n........\\nPPPPPPPP\\nRNBQKBNQ', 'output': ['White']}, {'input': 'rnbqkbnr\\npppppppp\\n........\\n........\\n........\\n........\\nPPPPPPPP\\nRNBQKB.R', 'output': ['Black']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"9\", \"7\"]","prob_desc_input_spec":"The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106) \u2014 the n mentioned in the statement.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void solution(BufferedReader reader, PrintWriter out)\n            throws IOException {\n        In in = new In(reader);\n        int n = in.nextInt();\n        long max = 1;\n        for (int a = Math.max(1, n - 100); a <= n; a++)\n            for (int b = Math.max(1, n - 100); b <= n; b++)\n                for (int c = Math.max(1, n - 100); c <= n; c++)\n                    max = Math.max(max, lcm(a, lcm(b, c)));\n        out.println(max);\n    }\n\n    private static long lcm(long a, long b) {\n        long gcd = gcd(a, b);\n        return a \/ gcd * b;\n    }\n\n    private static long gcd(long a, long b) {\n        while (b != 0) {\n            long t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(\n                new BufferedWriter(new OutputStreamWriter(System.out)));\n        solution(reader, out);\n        out.close();\n    }\n\n    protected static class In {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n        public In(BufferedReader reader) {\n            this.reader = reader;\n        }\n\n        public String next() throws IOException {\n            while (!tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n","prob_desc_sample_outputs":"[\"504\", \"210\"]","lang_cluster":"Java","code_uid":"d713cd16583d2ff8099c0477deb72d23","prob_desc_notes":"NoteThe least common multiple of some positive integers is the least positive integer which is multiple for each of them.The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7\u00b76\u00b75\u2009=\u2009210. It is the maximum value we can get.","prob_desc_output_spec":"Print a single integer \u2014 the maximum possible LCM of three not necessarily distinct positive integers that are not greater than n.","prob_desc_output_to":"standard output","prob_desc_description":"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than n. Can you help me to find the maximum possible least common multiple of these three integers?","length":66,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n', 'output': ['630\\n']}, {'input': '15\\n', 'output': ['2730\\n']}, {'input': '20\\n', 'output': ['7980\\n']}, {'input': '25\\n', 'output': ['19500\\n']}, {'input': '30\\n', 'output': ['39270\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 4 11\\n1 2 3 4\", \"5 5 10\\n1 2 4 8 16\"]","prob_desc_input_spec":"The first line contains three integer numbers n, k and M (1\u2009\u2264\u2009n\u2009\u2264\u200945, 1\u2009\u2264\u2009k\u2009\u2264\u200945, 0\u2009\u2264\u2009M\u2009\u2264\u20092\u00b7109). The second line contains k integer numbers, values tj (1\u2009\u2264\u2009tj\u2009\u2264\u20091000000), where tj is the time in minutes required to solve j-th subtask of any task.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Mathshow1 {\n\n\t\/**\n\t * @param args\n\t *\/\n\tpublic static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\n\n\t\tScanner input = new Scanner(System.in);\n\t\t\n\t\tint n = input.nextInt();\n\t\tint k = input.nextInt();\n\t\tint m = input.nextInt();\n\t\tint[] arr = new int[k];\n\t\tint total=0;\n\t\tfor(int i=0; i<k;i++){\n\t\t\tarr[i] = input.nextInt();\n\t\t\ttotal+=arr[i];\n\t\t}\n\t\tint max=-1;\n\t\tArrays.sort(arr);\n\t\tfor(int i=0; i<=n;i++){\n\t\t\tint points = i*(k+1);\n\t\t\tlong rem = m-i*total;\n\t\t\tif(rem <0 )continue;\n\t\t\tfor(int j=0; j<k;j++){\n\t\t\t\tint picks = Math.min(n-i,(int)rem\/arr[j]);\n\t\t\t\tif(picks==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpoints+=picks;\n\t\t\t\trem-=picks*arr[j];\n\t\t\t}\n\t\t\t\n\t\t\tmax = Math.max(points,max);\n\t\t}\n\t\tSystem.out.println(max);\n\t\t\t\t\n\t\t\t\t\n\t\t\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"6\", \"7\"]","lang_cluster":"Java","code_uid":"9d3ca52cd36d1c53af73872e255359d0","prob_desc_notes":"NoteIn the first example Polycarp can complete the first task and spend 1\u2009+\u20092\u2009+\u20093\u2009+\u20094\u2009=\u200910 minutes. He also has the time to solve one subtask of the second task in one minute.In the second example Polycarp can solve the first subtask of all five tasks and spend 5\u00b71\u2009=\u20095 minutes. Also he can solve the second subtasks of two tasks and spend 2\u00b72\u2009=\u20094 minutes. Thus, he earns 5\u2009+\u20092\u2009=\u20097 points in total.","prob_desc_output_spec":"Print the maximum amount of points Polycarp can earn in M minutes.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarp takes part in a math show. He is given n tasks, each consists of k subtasks, numbered 1 through k. It takes him tj minutes to solve the j-th subtask of any task. Thus, time required to solve a subtask depends only on its index, but not on the task itself. Polycarp can solve subtasks in any order.By solving subtask of arbitrary problem he earns one point. Thus, the number of points for task is equal to the number of solved subtasks in it. Moreover, if Polycarp completely solves the task (solves all k of its subtasks), he recieves one extra point. Thus, total number of points he recieves for the complete solution of the task is k\u2009+\u20091.Polycarp has M minutes of time. What is the maximum number of points he can earn?","length":47,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1\\n1', 'output': ['2']}, {'input': '2 2 4\\n1 2', 'output': ['5']}, {'input': '3 3 9\\n1 2 3', 'output': ['10']}, {'input': '4 4 16\\n1 2 3 4', 'output': ['17']}, {'input': '5 5 25\\n1 2 3 4 5', 'output': ['26']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 3 8 1 1\", \"4 2 9 4 2\", \"5 5 25 4 3\", \"100 100 1000000000000000000 100 100\"]","prob_desc_input_spec":"The first and the only line contains five integers n, m, k, x and y (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009k\u2009\u2264\u20091018,\u20091\u2009\u2264\u2009x\u2009\u2264\u2009n,\u20091\u2009\u2264\u2009y\u2009\u2264\u2009m).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\/\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            long k = in.nextLong();\n            int x = in.nextInt();\n            int y = in.nextInt();\n            long grid[][] = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (k > 0) {\n                        grid[i][j] = 1;\n                        k--;\n                    }\n                }\n            }\n\n            if (k > 0 && n != 1) {\n                long mid = (k \/ (m * n - m));\n                boolean isUp = (k \/ (m * n - m)) % 2 == 0;\n                long topRow = (k \/ (m * n - m)) \/ 2 + (!isUp ? 1 : 0);\n                long bottomRow = ((k \/ (m * n - m)) \/ 2);\n                long remK = (k % (m * n - m));\n                for (int i = 0; i < grid.length; i++) {\n                    for (int j = 0; j < grid[0].length; j++) {\n                        if (i == 0) {\n                            grid[i][j] += topRow;\n                        } else if (i == n - 1) {\n                            grid[i][j] += bottomRow;\n                        } else {\n                            grid[i][j] += mid;\n                        }\n                    }\n                }\n                for (int i = isUp ? n - 2 : 1; i >= 0 && i < n; i += isUp ? -1 : 1) {\n                    for (int j = 0; j < m; j++) {\n                        if (remK > 0) {\n                            grid[i][j] += 1;\n                            remK--;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            } else if (n == 1) {\n                for (int i = 0; i < m; i++) {\n                    grid[0][i] += k \/ m;\n                }\n                k = k % m;\n                for (int i = 0; i < m; i++) {\n                    if (k > 0) {\n                        grid[0][i] += 1;\n                        k--;\n                    }\n\n                }\n            }\n            long max = Long.MIN_VALUE;\n            long min = Long.MAX_VALUE;\n            for (long column[] : grid) {\n                for (long cell : column) {\n                    max = Math.max(max, cell);\n                    min = Math.min(min, cell);\n                }\n            }\n            out.println(max + \" \" + min + \" \" + grid[x - 1][y - 1]);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int nextInt() {\n            return readInt();\n        }\n\n        public long nextLong() {\n            return readLong();\n        }\n\n    }\n}\n\n","prob_desc_sample_outputs":"[\"3 2 3\", \"2 1 1\", \"1 1 1\", \"101010101010101 50505050505051 50505050505051\"]","lang_cluster":"Java","code_uid":"3db2b9895fc6eca5d708c756e44ace41","prob_desc_notes":"NoteThe order of asking pupils in the first test:   the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table;  the pupil from the first row who seats at the third table;  the pupil from the first row who seats at the first table, it means it is Sergei;  the pupil from the first row who seats at the second table; The order of asking pupils in the second test:   the pupil from the first row who seats at the first table;  the pupil from the first row who seats at the second table;  the pupil from the second row who seats at the first table;  the pupil from the second row who seats at the second table;  the pupil from the third row who seats at the first table;  the pupil from the third row who seats at the second table;  the pupil from the fourth row who seats at the first table;  the pupil from the fourth row who seats at the second table, it means it is Sergei;  the pupil from the third row who seats at the first table; ","prob_desc_output_spec":"Print three integers:   the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. ","prob_desc_output_to":"standard output","prob_desc_description":"On the Literature lesson Sergei noticed an awful injustice, it seems that some students are asked more often than others.Seating in the class looks like a rectangle, where n rows with m pupils in each. The teacher asks pupils in the following order: at first, she asks all pupils from the first row in the order of their seating, then she continues to ask pupils from the next row. If the teacher asked the last row, then the direction of the poll changes, it means that she asks the previous row. The order of asking the rows looks as follows: the 1-st row, the 2-nd row, ..., the n\u2009-\u20091-st row, the n-th row, the n\u2009-\u20091-st row, ..., the 2-nd row, the 1-st row, the 2-nd row, ...The order of asking of pupils on the same row is always the same: the 1-st pupil, the 2-nd pupil, ..., the m-th pupil.During the lesson the teacher managed to ask exactly k questions from pupils in order described above. Sergei seats on the x-th row, on the y-th place in the row. Sergei decided to prove to the teacher that pupils are asked irregularly, help him count three values:  the maximum number of questions a particular pupil is asked,  the minimum number of questions a particular pupil is asked,  how many times the teacher asked Sergei. If there is only one row in the class, then the teacher always asks children from this row.","length":174,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 4 1 1', 'output': ['1 1 1\\n']}, {'input': '3 3 9 2 2', 'output': ['1 1 1\\n']}, {'input': '1 5 10 1 3', 'output': ['2 2 2\\n']}, {'input': '4 4 16 3 3', 'output': ['1 1 1\\n']}, {'input': '5 5 25 4 4', 'output': ['1 1 1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 2 3\", \"8 2 4\"]","prob_desc_input_spec":"The only line contains three integers n,\u2009b,\u2009p (1\u2009\u2264\u2009n,\u2009b,\u2009p\u2009\u2264\u2009500) \u2014 the number of participants and the parameters described in the problem statement.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\n\/**\n * Created by Peter on 13.04.2016.\n *\/\npublic class TaskA {\n    int n, b, p;\n    TaskA(Scanner sc) {\n        n = sc.nextInt();\n        b = sc.nextInt();\n        p = sc.nextInt();\n\n\n    }\n    private int getGamePlayed() {\n        int nn = n;\n        int ans = 0;\n        while (nn > 1 ) {\n            int k = 1;\n            while (k*2 <= nn) {\n                k *= 2;\n            }\n            ans += k\/2;\n            nn = nn - k\/2;\n\n        }\n        return ans;\n    }\n\n    private void solve(){\n        int totalP = p * n;\n        int gamePlayed = getGamePlayed();\n        int totalB = gamePlayed * (2 * b + 1);\n        System.out.printf(\"%d %d\", totalB, totalP);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        new TaskA(sc).solve();\n        sc.close();\n    }\n}\n","prob_desc_sample_outputs":"[\"20 15\", \"35 32\"]","lang_cluster":"Java","code_uid":"c52c5f5643b990c37898f22f7eedeaab","prob_desc_notes":"NoteIn the first example will be three rounds:  in the first round will be two matches and for each match 5 bottles of water are needed (two for each of the participants and one for the judge),  in the second round will be only one match, so we need another 5 bottles of water,  in the third round will also be only one match, so we need another 5 bottles of water. So in total we need 20 bottles of water.In the second example no participant will move on to some round directly.","prob_desc_output_spec":"Print two integers x and y \u2014 the number of bottles and towels need for the tournament.","prob_desc_output_to":"standard output","prob_desc_description":"A tennis tournament with n participants is running. The participants are playing by an olympic system, so the winners move on and the losers drop out.The tournament takes place in the following way (below, m is the number of the participants of the current round):  let k be the maximal power of the number 2 such that k\u2009\u2264\u2009m,  k participants compete in the current round and a half of them passes to the next round, the other m\u2009-\u2009k participants pass to the next round directly,  when only one participant remains, the tournament finishes. Each match requires b bottles of water for each participant and one bottle for the judge. Besides p towels are given to each participant for the whole tournament.Find the number of bottles and towels needed for the tournament.Note that it's a tennis tournament so in each match two participants compete (one of them will win and the other will lose).","length":42,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1', 'output': ['0 1']}, {'input': '2 2 2', 'output': ['5 4']}, {'input': '3 3 3', 'output': ['12 9']}, {'input': '4 4 4', 'output': ['21 16']}, {'input': '5 5 5', 'output': ['35 25']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 5\\n2 3 1 4 4\", \"3 3\\n3 1 2\"]","prob_desc_input_spec":"The first line contains two integer numbers n, m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009100). The second line contains m integer numbers l1,\u2009l2,\u2009...,\u2009lm (1\u2009\u2264\u2009li\u2009\u2264\u2009n) \u2014 indices of leaders in the beginning of each step.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport java.util.StringTokenizer;\n\n public class Test\n {\n     static PrintWriter pw = new PrintWriter(System.out);\n     static ArrayList<Integer> list = new ArrayList();\n    \n    public static void main(String[] args)throws Exception\n    {\n        Reader.init(System.in);\n        int n = Reader.nextInt();\n        int k = Reader.nextInt();\n        HashMap<Integer , Integer> set = new HashMap();\n        boolean[] flags = new boolean[n+1];\n        int[] res = new int[n+1];\n        int[] game = new int[k];\n        int count = 0;\n        int temp = 0;\n        \n\n        for(int i = 0 ; i<k ; i++)game[i] = Reader.nextInt();\n        \n        for(int i = 0 ; i<k-1 ; i++)\n        {\n\n            int a = game[i];\n            int b = game[i+1];\n            \n            if(b>a)\n                temp = b - a;\n            else\n                temp =  b + (n-a);\n            \n            \n            if(set.containsKey(temp) && set.get(temp) != a)\n            {\n                pw.print(-1);\n                pw.close();\n                return;\n            }\n            else if(res[a] != 0 && res[a] != temp)\n            {\n                pw.print(-1);\n                pw.close();\n                return;\n            }\n            else if(!set.containsKey(res[a]))\n            {\n  \n                set.put(temp , a);\n                res[a] = temp;\n                count ++;\n                flags[res[a]] = true;\n            }\n            \n            \n           \n           \n        }\n \n        if(count <n)\n        {\n            for(int i = 1 ; i<=n ; i++)\n                if(!flags[i])\n                {\n                    list.add(i);\n\n                }\n        }\n  \n \n        StringBuilder str = new StringBuilder();\n        Iterator<Integer> itr = list.iterator();\n        \n        for(int i = 1 ; i<=n ; i++)\n            if(res[i] == 0)\n            {\n                str.append(itr.next()).append(\" \");\n                \n            }\n            else\n                str.append(res[i]).append(\" \");\n        \n        pw.print(str);\n        pw.close();\n    }\n        \n}\n\nclass Reader {\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    public static int pars(String x) {\n        int num = 0;\n        int i = 0;\n        if (x.charAt(0) == '-') {\n            i = 1;\n        }\n        for (; i < x.length(); i++) {\n            num = num * 10 + (x.charAt(i) - '0');\n        }\n\n        if (x.charAt(0) == '-') {\n            return -num;\n        }\n\n        return num;\n    }\n\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static void init(FileReader input) {\n        reader = new BufferedReader(input);\n        tokenizer = new StringTokenizer(\"\");\n    }\n\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(\n                    reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return pars(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}","prob_desc_sample_outputs":"[\"3 1 2 4\", \"-1\"]","lang_cluster":"Java","code_uid":"2eef29dd6ecfce75922678d5cd72ccef","prob_desc_notes":"NoteLet's follow leadership in the first example:   Child 2 starts.  Leadership goes from 2 to 2\u2009+\u2009a2\u2009=\u20093.  Leadership goes from 3 to 3\u2009+\u2009a3\u2009=\u20095. As it's greater than 4, it's going in a circle to 1.  Leadership goes from 1 to 1\u2009+\u2009a1\u2009=\u20094.  Leadership goes from 4 to 4\u2009+\u2009a4\u2009=\u20098. Thus in circle it still remains at 4. ","prob_desc_output_spec":"Print such permutation of n numbers a1,\u2009a2,\u2009...,\u2009an that leaders in the game will be exactly l1,\u2009l2,\u2009...,\u2009lm if all the rules are followed. If there are multiple solutions print any of them.  If there is no permutation which satisfies all described conditions print -1.","prob_desc_output_to":"standard output","prob_desc_description":"n children are standing in a circle and playing a game. Children's numbers in clockwise order form a permutation a1,\u2009a2,\u2009...,\u2009an of length n. It is an integer sequence such that each integer from 1 to n appears exactly once in it.The game consists of m steps. On each step the current leader with index i counts out ai people in clockwise order, starting from the next person. The last one to be pointed at by the leader becomes the new leader.You are given numbers l1,\u2009l2,\u2009...,\u2009lm \u2014 indices of leaders in the beginning of each step. Child with number l1 is the first leader in the game. Write a program which will restore a possible permutation a1,\u2009a2,\u2009...,\u2009an. If there are multiple solutions then print any of them. If there is no solution then print -1.","length":154,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5\\n1 2 3 4 5', 'output': ['1 1 1 1 1 ']}, {'input': '6 6\\n1 2 3 4 5 6', 'output': ['1 1 1 1 1 1 ']}, {'input': '7 7\\n1 2 3 4 5 6 7', 'output': ['1 1 1 1 1 1 1 ']}, {'input': '8 8\\n1 2 3 4 5 6 7 8', 'output': ['1 1 1 1 1 1 1 1 ']}, {'input': '9 9\\n1 2 3 4 5 6 7 8 9', 'output': ['1 1 1 1 1 1 1 1 1 ']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"abacaba\", \"jinotega\"]","prob_desc_input_spec":"In the only line of input there is a string S of lowercase English letters (1\u2009\u2264\u2009|S|\u2009\u2264\u2009500)\u00a0\u2014 the identifiers of a program with removed whitespace characters.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CODE_OBSTUFICATIION {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner nik = new Scanner(System.in);\n\t\tString s = nik.next();\n\t\tboolean b = true;\n\t\tHashMap<Character, Integer> hm = new HashMap<>();\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tint temp = s.charAt(i) - 'a';\n\t\t\tif (hm.size() < temp) {\n\t\t\t\tb = false;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\thm.put(s.charAt(i), hm.getOrDefault(s.charAt(i) + 1, 0));\n\t\t\t}\n\n\t\t}\n\n\t\tSystem.out.println(b == true ? \"YES\" : \"NO\");\n\n\t}\n\n}\n","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Java","code_uid":"e5bc00404301ef2a118826c60a184232","prob_desc_notes":"NoteIn the first sample case, one possible list of identifiers would be \"number string number character number string number\". Here how Kostya would obfuscate the program: replace all occurences of number with a, the result would be \"a string a character a string a\", replace all occurences of string with b, the result would be \"a b a character a b a\", replace all occurences of character with c, the result would be \"a b a c a b a\", all identifiers have been replaced, thus the obfuscation is finished.","prob_desc_output_spec":"If this program can be a result of Kostya's obfuscation, print \"YES\" (without quotes), otherwise print \"NO\".","prob_desc_output_to":"standard output","prob_desc_description":"Kostya likes Codeforces contests very much. However, he is very disappointed that his solutions are frequently hacked. That's why he decided to obfuscate (intentionally make less readable) his code before upcoming contest.To obfuscate the code, Kostya first looks at the first variable name used in his program and replaces all its occurrences with a single symbol a, then he looks at the second variable name that has not been replaced yet, and replaces all its occurrences with b, and so on. Kostya is well-mannered, so he doesn't use any one-letter names before obfuscation. Moreover, there are at most 26 unique identifiers in his programs.You are given a list of identifiers of some program with removed spaces and line breaks. Check if this program can be a result of Kostya's obfuscation.","length":28,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'abcabc', 'output': ['YES']}, {'input': 'abcdcba', 'output': ['NO']}, {'input': 'a', 'output': ['YES']}, {'input': 'abac', 'output': ['YES']}, {'input': 'abca', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"20 2\\n9 19\", \"2 1\\n16 12\"]","prob_desc_input_spec":"The first line of input contains two integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100).  The second line contains two integers c and d (1\u2009\u2264\u2009c,\u2009d\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class A787 {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint accel1 = scanner.nextInt();\n\t\tint initialVal1 = scanner.nextInt();\n\t\tint accel2 = scanner.nextInt();\n\t\tint initialVal2 = scanner.nextInt();\n\t\tint time = checkHit(accel1, initialVal1, accel2, initialVal2);\n\t\tSystem.out.println(time);\n\t}\n\n\tprivate static int checkHit(int accel1, int initialVal1, int accel2, int initialVal2) {\n\t\tif(initialVal1 % 2 != initialVal2 % 2 && accel1 % 2 == 0 && accel2 % 2 == 0)\n\t\t\treturn -1;\n\t\tint difference = initialVal2 - initialVal1;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i * accel1 - j * accel2 != difference) {\n\t\t\tif(i * accel1 - j * accel2 < difference)\n\t\t\t\ti++;\n\t\t\telse\n\t\t\t\tj++;\n\t\t\tif(i > accel1 * accel2 + 100|| j >= 100 + accel1 * accel2)\n\t\t\t\treturn -1;\n\t\t}\n\t\t\t\n\t\treturn accel1 * i + initialVal1;\n\t}\n}\n","prob_desc_sample_outputs":"[\"82\", \"-1\"]","lang_cluster":"Java","code_uid":"7572ba456fcd2f84062bae73e0ed31f7","prob_desc_notes":"NoteIn the first sample testcase, Rick's 5th scream and Morty's 8th time are at time 82. In the second sample testcase, all Rick's screams will be at odd times and Morty's will be at even times, so they will never scream at the same time.","prob_desc_output_spec":"Print the first time Rick and Morty will scream at the same time, or \u2009-\u20091 if they will never scream at the same time.","prob_desc_output_to":"standard output","prob_desc_description":"A monster is chasing after Rick and Morty on another planet. They're so frightened that sometimes they scream. More accurately, Rick screams at times b,\u2009b\u2009+\u2009a,\u2009b\u2009+\u20092a,\u2009b\u2009+\u20093a,\u2009... and Morty screams at times d,\u2009d\u2009+\u2009c,\u2009d\u2009+\u20092c,\u2009d\u2009+\u20093c,\u2009....   The Monster will catch them if at any point they scream at the same time, so it wants to know when it will catch them (the first time they scream at the same time) or that they will never scream at the same time.","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5\\n20 15', 'output': ['105']}, {'input': '1 1\\n1 1', 'output': ['1']}, {'input': '2 1\\n2 2', 'output': ['-1']}, {'input': '3 3\\n3 6', 'output': ['9']}, {'input': '100 1\\n100 2', 'output': ['101']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 2\", \"3 1\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$m~(1 \\le n \\le 10^5, 0 \\le m \\le \\frac{n (n - 1)}{2})$$$. It is guaranteed that there exists a graph without any self-loops or multiple edges with such number of vertices and edges.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        long vertexes = in.nextLong();\n        long edges = in.nextLong();\n\n        long max = 0;\n\n        if (edges == 0) {\n            System.out.println(vertexes + \" \" + vertexes);\n            return;\n        }\n\n        for (long i = 1; i < vertexes; i++) {\n           long currentEdges = (i * (i - 1)) \/ 2;\n            if (currentEdges >= edges) {\n                max = vertexes - i;\n                break;\n            }\n        }\n\n        for (long i = 0; i < edges; i++) {\n            vertexes -= 2;\n\n            if (vertexes < 0) {\n                break;\n            }\n        }\n\n        vertexes = vertexes > 0 ? vertexes : 0;\n\n        System.out.println(vertexes + \" \" + max);\n    }\n}\n","prob_desc_sample_outputs":"[\"0 1\", \"1 1\"]","lang_cluster":"Java","code_uid":"da2b2fad16f5de844ff458c641e7b6df","prob_desc_notes":"NoteIn the first example it is possible to construct a graph with $$$0$$$ isolated vertices: for example, it should contain edges $$$(1, 2)$$$ and $$$(3, 4)$$$. To get one isolated vertex, we may construct a graph with edges $$$(1, 2)$$$ and $$$(1, 3)$$$. In the second example the graph will always contain exactly one isolated vertex.","prob_desc_output_spec":"In the only line print two numbers $$$min$$$ and $$$max$$$ \u2014 the minimum and maximum number of isolated vertices, respectively.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya has got an undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. This graph doesn't contain any self-loops or multiple edges. Self-loop is an edge connecting a vertex to itself. Multiple edges are a pair of edges such that they connect the same pair of vertices. Since the graph is undirected, the pair of edges $$$(1, 2)$$$ and $$$(2, 1)$$$ is considered to be multiple edges. Isolated vertex of the graph is a vertex such that there is no edge connecting this vertex to any other vertex.Vasya wants to know the minimum and maximum possible number of isolated vertices in an undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. ","length":37,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 0', 'output': ['5 5\\n']}, {'input': '10 5', 'output': ['0 5\\n']}, {'input': '7 3', 'output': ['1 4\\n']}, {'input': '6 1', 'output': ['3 4\\n']}, {'input': '8 2', 'output': ['2 5\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3 2\\n50 85 250\\n10 15 25\", \"3 6\\n50 85 250\\n10 15 25\", \"8 1\\n10 20 30 40 50 60 70 80\\n8 10 58 63 71 72 75 76\"]","prob_desc_input_spec":"The first line contains two integers n and c (1\u2009\u2264\u2009n\u2009\u2264\u200950,\u20091\u2009\u2264\u2009c\u2009\u2264\u20091000)\u00a0\u2014 the number of problems and the constant representing the speed of loosing points. The second line contains n integers p1,\u2009p2,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009\u2264\u20091000,\u2009pi\u2009&lt;\u2009pi\u2009+\u20091)\u00a0\u2014 initial scores. The third line contains n integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u20091000,\u2009ti\u2009&lt;\u2009ti\u2009+\u20091) where ti denotes the number of minutes one needs to solve the i-th problem.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.Scanner;\n\npublic class A17 {\n\n\tpublic static void main(String[] args) {\n\t\t\/\/ TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint[] score = new int[n];\n\t\tint[] minute = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscore[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tminute[i] = sc.nextInt();\n\t\t}\n\n\t\tint Limak = 0;\n\t\tint l;\n\t\tint currmin = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcurrmin += minute[i];\n\t\t\tl = score[i] - (c * currmin);\n\n\t\t\tif (l > 0) {\n\t\t\t\tLimak += l;\n\t\t\t}\n\t\t}\n\n\t\tint Radewoosh = 0;\n\t\tint r;\n\t\tint curr = 0;\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tcurr += minute[i];\n\t\t\tr = score[i] - (c * curr);\n\n\t\t\tif (r > 0) {\n\t\t\t\tRadewoosh += r;\n\t\t\t}\n\n\t\t}\n\n\t\tif (Radewoosh == Limak) {\n\t\t\tSystem.out.println(\"Tie\");\n\t\t} \n\t\telse\n\t\t\tSystem.out.println((Radewoosh > Limak) ? \"Radewoosh\" : \"Limak\");\n\n\t}\n\n}","prob_desc_sample_outputs":"[\"Limak\", \"Radewoosh\", \"Tie\"]","lang_cluster":"Java","code_uid":"11d23f879510f86a8c3e68563c6cfa6c","prob_desc_notes":"NoteIn the first sample, there are 3 problems. Limak solves them as follows:  Limak spends 10 minutes on the 1-st problem and he gets 50\u2009-\u2009c\u00b710\u2009=\u200950\u2009-\u20092\u00b710\u2009=\u200930 points.  Limak spends 15 minutes on the 2-nd problem so he submits it 10\u2009+\u200915\u2009=\u200925 minutes after the start of the contest. For the 2-nd problem he gets 85\u2009-\u20092\u00b725\u2009=\u200935 points.  He spends 25 minutes on the 3-rd problem so he submits it 10\u2009+\u200915\u2009+\u200925\u2009=\u200950 minutes after the start. For this problem he gets 250\u2009-\u20092\u00b750\u2009=\u2009150 points. So, Limak got 30\u2009+\u200935\u2009+\u2009150\u2009=\u2009215 points.Radewoosh solves problem in the reversed order:  Radewoosh solves 3-rd problem after 25 minutes so he gets 250\u2009-\u20092\u00b725\u2009=\u2009200 points.  He spends 15 minutes on the 2-nd problem so he submits it 25\u2009+\u200915\u2009=\u200940 minutes after the start. He gets 85\u2009-\u20092\u00b740\u2009=\u20095 points for this problem.  He spends 10 minutes on the 1-st problem so he submits it 25\u2009+\u200915\u2009+\u200910\u2009=\u200950 minutes after the start. He gets max(0,\u200950\u2009-\u20092\u00b750)\u2009=\u2009max(0,\u2009\u2009-\u200950)\u2009=\u20090 points. Radewoosh got 200\u2009+\u20095\u2009+\u20090\u2009=\u2009205 points in total. Limak has 215 points so Limak wins.In the second sample, Limak will get 0 points for each problem and Radewoosh will first solve the hardest problem and he will get 250\u2009-\u20096\u00b725\u2009=\u2009100 points for that. Radewoosh will get 0 points for other two problems but he is the winner anyway.In the third sample, Limak will get 2 points for the 1-st problem and 2 points for the 2-nd problem. Radewoosh will get 4 points for the 8-th problem. They won't get points for other problems and thus there is a tie because 2\u2009+\u20092\u2009=\u20094.","prob_desc_output_spec":"Print \"Limak\" (without quotes) if Limak will get more points in total. Print \"Radewoosh\" (without quotes) if Radewoosh will get more points in total. Print \"Tie\" (without quotes) if Limak and Radewoosh will get the same total number of points.","prob_desc_output_to":"standard output","prob_desc_description":"Limak and Radewoosh are going to compete against each other in the upcoming algorithmic contest. They are equally skilled but they won't solve problems in the same order.There will be n problems. The i-th problem has initial score pi and it takes exactly ti minutes to solve it. Problems are sorted by difficulty\u00a0\u2014 it's guaranteed that pi\u2009&lt;\u2009pi\u2009+\u20091 and ti\u2009&lt;\u2009ti\u2009+\u20091.A constant c is given too, representing the speed of loosing points. Then, submitting the i-th problem at time x (x minutes after the start of the contest) gives max(0,\u2009 pi\u2009-\u2009c\u00b7x) points.Limak is going to solve problems in order 1,\u20092,\u2009...,\u2009n (sorted increasingly by pi). Radewoosh is going to solve them in order n,\u2009n\u2009-\u20091,\u2009...,\u20091 (sorted decreasingly by pi). Your task is to predict the outcome\u00a0\u2014 print the name of the winner (person who gets more points at the end) or a word \"Tie\" in case of a tie.You may assume that the duration of the competition is greater or equal than the sum of all ti. That means both Limak and Radewoosh will accept all n problems.","length":54,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 3\\n10 20 30 40 50\\n5 10 15 20 25', 'output': ['Limak\\n']}, {'input': '4 2\\n10 20 30 40\\n5 10 15 20', 'output': ['Radewoosh\\n']}, {'input': '3 1\\n10 20 30\\n5 10 15', 'output': ['Limak\\n']}, {'input': '3 5\\n10 20 30\\n5 10 15', 'output': ['Radewoosh\\n']}, {'input': '2 1\\n10 20\\n5 10', 'output': ['Tie\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\n1 2 4 3 3 2\", \"1\\n100\"]","prob_desc_input_spec":"The first line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 100$$$) \u2014 the number of coins. The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 100$$$) \u2014 values of coins.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\n\npublic class Watermelon\n{\t\n    public static void main(String[] args)\n    {\n    \tScanner sc = new Scanner(System.in);\n    \tint n = sc.nextInt();\n    \tint a[] = new int[n];\n    \tint c[] = new int[101];\n    \tfor(int i=0; i<n; i++)\n    \t{\n    \t\ta[i] = sc.nextInt();\n    \t\tc[a[i]]++;\n    \t}\n    \tint max = 0;\n    \tfor(int i=0; i<101; i++)\n    \t{\n    \t\tif(c[i]>max)\n    \t\t\tmax = c[i];\n    \t}\n    \tSystem.out.println(max);\n    }\n}","prob_desc_sample_outputs":"[\"2\", \"1\"]","lang_cluster":"Java","code_uid":"29bd8cc7a5eef1c20989eb05c7d3692d","prob_desc_notes":null,"prob_desc_output_spec":"Print only one integer \u2014 the minimum number of pockets Polycarp needs to distribute all the coins so no two coins with the same value are put into the same pocket.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarp has $$$n$$$ coins, the value of the $$$i$$$-th coin is $$$a_i$$$. Polycarp wants to distribute all the coins between his pockets, but he cannot put two coins with the same value into the same pocket.For example, if Polycarp has got six coins represented as an array $$$a = [1, 2, 4, 3, 3, 2]$$$, he can distribute the coins into two pockets as follows: $$$[1, 2, 3], [2, 3, 4]$$$.Polycarp wants to distribute all the coins with the minimum number of used pockets. Help him to do that.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 4 5', 'output': ['1\\n']}, {'input': '10\\n1 1 2 2 3 3 4 4 5 5', 'output': ['2\\n']}, {'input': '7\\n1 2 2 3 3 3 4', 'output': ['3\\n']}, {'input': '3\\n100 100 100', 'output': ['3\\n']}, {'input': '1\\n1', 'output': ['1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 4\", \"2 1\"]","prob_desc_input_spec":"The only line contains two integers $$$N$$$ and $$$M$$$ ($$$1 \\leq N, M \\leq 10^9$$$) \u2014 the number of rows and columns in the grid.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import java.util.*;\r\nimport java.math.*;\r\n\r\npublic class Dominoes {\r\n\tpublic static void main(String[] args) {\r\n\t\tScanner o = new Scanner(System.in);\r\n\t\tint n = o.nextInt(), m = o.nextInt();\r\n\t\tBigInteger b1 = BigInteger.valueOf(n), b2 = BigInteger.valueOf(m);\r\n\t\tif( n == 1 && m == 1)\r\n\t\t\tSystem.out.println(0);\r\n\t\telse if( m == 1 )\r\n\t\t\tSystem.out.println(n - 1);\r\n\t\telse\r\n\t\t\tSystem.out.println(BigInteger.valueOf(m - 1).multiply(b1));\r\n\t}\r\n}\r\n","prob_desc_sample_outputs":"[\"9\", \"1\"]","lang_cluster":"Java","code_uid":"a2ed0a25ce6ea31ecdb5e41cb2263289","prob_desc_notes":"NoteThe picture below is the grid that Pak Chanek has in the first example.  The picture below is an example of a tight domino in the grid.  ","prob_desc_output_spec":"An integer representing the number of distinct tight dominoes in the grid.","prob_desc_output_to":"standard output","prob_desc_description":"Pak Chanek has a grid that has $$$N$$$ rows and $$$M$$$ columns. Each row is numbered from $$$1$$$ to $$$N$$$ from top to bottom. Each column is numbered from $$$1$$$ to $$$M$$$ from left to right.Each tile in the grid contains a number. The numbers are arranged as follows:   Row $$$1$$$ contains integers from $$$1$$$ to $$$M$$$ from left to right.  Row $$$2$$$ contains integers from $$$M+1$$$ to $$$2 \\times M$$$ from left to right.  Row $$$3$$$ contains integers from $$$2 \\times M+1$$$ to $$$3 \\times M$$$ from left to right.  And so on until row $$$N$$$. A domino is defined as two different tiles in the grid that touch by their sides. A domino is said to be tight if and only if the two numbers in the domino have a difference of exactly $$$1$$$. Count the number of distinct tight dominoes in the grid.Two dominoes are said to be distinct if and only if there exists at least one tile that is in one domino, but not in the other.","length":16,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5', 'output': ['20']}, {'input': '1 10', 'output': ['9']}, {'input': '10 1', 'output': ['9']}, {'input': '2 2', 'output': ['3']}, {'input': '1 1', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3 3 1\", \"4 4 1\", \"6 7 2\"]","prob_desc_input_spec":"The first and only line contains three integers: n,\u2009m,\u2009k (1\u2009\u2264\u2009n,\u2009m,\u2009k\u2009\u2264\u20091000).","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"\/* package whatever; \/\/ don't place package name! *\/\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\/* Name of the class has to be \"Main\" only if the class is public. *\/\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t  long mod = 1000000007;\n\t  Scanner in = new Scanner(System.in);\n\t   int n = in.nextInt();\n\t   int m = in.nextInt();\n\t   int k = in.nextInt();\n        if (k * 2 > n - 1 || k * 2 > m - 1) \n          System.out.println(\"0\"); \n        else {\n          long c[][] = new long [1001][1001];\n           c[0][0] = 1;\n            for (int i = 1; i <= Math.max(n - 1, m - 1); ++i) { \n\t          c[i][0] = 1;\n\t           for (int j = 1; j <= i; ++j)\n\t             c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t\t\t}\n\t         System.out.println((c[n - 1][2 * k] * c[m - 1][2 * k]) % mod);  \n        }\n\t}\n}\n","prob_desc_sample_outputs":"[\"1\", \"9\", \"75\"]","lang_cluster":"Java","code_uid":"03822ea31a9b386b94556d7b7dacc080","prob_desc_notes":"NoteTwo ways to play the game are considered different if the final pictures are different. In other words, if one way contains a rectangle that is not contained in the other way.In the first sample Anna, who performs her first and only move, has only one possible action plan \u2014 insert a 1\u2009\u00d7\u20091 square inside the given 3\u2009\u00d7\u20093 square.In the second sample Anna has as much as 9 variants: 4 ways to paint a 1\u2009\u00d7\u20091 square, 2 ways to insert a 1\u2009\u00d7\u20092 rectangle vertically, 2 more ways to insert it horizontally and one more way is to insert a 2\u2009\u00d7\u20092 square.","prob_desc_output_spec":"Print the single number \u2014 the number of the ways to play the game. As this number can be very big, print the value modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"In this task Anna and Maria play the following game. Initially they have a checkered piece of paper with a painted n\u2009\u00d7\u2009m rectangle (only the border, no filling). Anna and Maria move in turns and Anna starts. During each move one should paint inside the last-painted rectangle a new lesser rectangle (along the grid lines). The new rectangle should have no common points with the previous one. Note that when we paint a rectangle, we always paint only the border, the rectangles aren't filled.Nobody wins the game \u2014 Anna and Maria simply play until they have done k moves in total. Count the number of different ways to play this game.","length":30,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 1', 'output': ['16']}, {'input': '7 8 2', 'output': ['210']}, {'input': '10 10 3', 'output': ['4005']}, {'input': '1 1 1', 'output': ['0']}, {'input': '1000 1000 500', 'output': ['152722999']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"3\\n7 20 88\", \"9\\n16 20 30 40 50 60 70 80 90\", \"9\\n15 20 30 40 50 60 70 80 90\"]","prob_desc_input_spec":"The first line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u200990)\u00a0\u2014 the number of interesting minutes. The second line contains n integers t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009t1\u2009&lt;\u2009t2\u2009&lt;\u2009... tn\u2009\u2264\u200990), given in the increasing order.","prob_desc_input_from":"standard input","lang":"Java 8","source_code":"import static java.lang.System.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(in);\n        \n        int n = sc.nextInt();\n        int sum = 0;\n        int m = 0;\n        while (n --> 0 && (m - (m = sc.nextInt())) * -1 <= 15) {\n            sum = m;\n        }\n        if (n >= 0) {\n            while (n --> 0) {\n                sc.nextInt();\n            }\n        }\n        sum += 15;\n        if (sum > 90) sum = 90;\n        out.println(sum);\n    }\n}\n","prob_desc_sample_outputs":"[\"35\", \"15\", \"90\"]","lang_cluster":"Java","code_uid":"f6c45715cdf30cfe4a69c4f286ed1e4e","prob_desc_notes":"NoteIn the first sample, minutes 21,\u200922,\u2009...,\u200935 are all boring and thus Limak will turn TV off immediately after the 35-th minute. So, he would watch the game for 35 minutes.In the second sample, the first 15 minutes are boring.In the third sample, there are no consecutive 15 boring minutes. So, Limak will watch the whole game.","prob_desc_output_spec":"Print the number of minutes Limak will watch the game.","prob_desc_output_to":"standard output","prob_desc_description":"Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts 90 minutes and there are no breaks.Each minute can be either interesting or boring. If 15 consecutive minutes are boring then Limak immediately turns TV off.You know that there will be n interesting minutes t1,\u2009t2,\u2009...,\u2009tn. Your task is to calculate for how many minutes Limak will watch the game.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n1', 'output': ['16\\n']}, {'input': '5\\n1 2 3 4 5', 'output': ['20\\n']}, {'input': '5\\n1 17 33 49 65', 'output': ['32\\n']}, {'input': '10\\n1 2 3 4 5 6 7 8 9 10', 'output': ['25\\n']}, {'input': '10\\n10 20 30 40 50 60 70 80 90', 'output': ['90\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"127\", \"130\", \"123456789101112131415161718192021222324\"]","prob_desc_input_spec":"The first line contains a positive number n. It consists of no more than 100 digits and doesn't contain any leading zeros. The number n can't be represented as an empty string. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n = int(input())\n\nif n >= -128 and n <= 127:\n    print(\"byte\")\nelif n >= -32768 and n <= 32767:\n    print(\"short\")\nelif n >= -2147483648 and n <= 2147483647:\n    print(\"int\")\nelif n >= -9223372036854775808 and n <= 9223372036854775807:\n    print(\"long\")\nelse:\n    print(\"BigInteger\")","prob_desc_sample_outputs":"[\"byte\", \"short\", \"BigInteger\"]","lang_cluster":"Python","code_uid":"fa7035482ef34609ed8d82012e25a3f9","prob_desc_notes":null,"prob_desc_output_spec":"Print the first type from the list \"byte, short, int, long, BigInteger\", that can store the natural number n, in accordance with the data given above.","prob_desc_output_to":"standard output","prob_desc_description":"Little Petya has recently started attending a programming club. Naturally he is facing the problem of choosing a programming language. After long considerations he realized that Java is the best choice. The main argument in favor of choosing Java was that it has a very large integer data type, called BigInteger.But having attended several classes of the club, Petya realized that not all tasks require using the BigInteger type. It turned out that in some tasks it is much easier to use small data types. That's why a question arises: \"Which integer type to use if one wants to store a positive integer n?\"Petya knows only 5 integer types:1) byte occupies 1 byte and allows you to store numbers from \u2009-\u2009128 to 1272) short occupies 2 bytes and allows you to store numbers from \u2009-\u200932768 to 327673) int occupies 4 bytes and allows you to store numbers from \u2009-\u20092147483648 to 21474836474) long occupies 8 bytes and allows you to store numbers from \u2009-\u20099223372036854775808 to 92233720368547758075) BigInteger can store any integer number, but at that it is not a primitive type, and operations with it are much slower.For all the types given above the boundary values are included in the value range.From this list, Petya wants to choose the smallest type that can store a positive integer n. Since BigInteger works much slower, Peter regards it last. Help him.","length":12,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '100', 'output': ['byte\\n']}, {'input': '32767', 'output': ['short\\n']}, {'input': '2147483647', 'output': ['int\\n']}, {'input': '9223372036854775807', 'output': ['long\\n']}, {'input': '123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100', 'output': ['BigInteger\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\n1 3 4 5 6 9\", \"3\\n998 999 1000\", \"5\\n1 2 3 4 5\"]","prob_desc_input_spec":"The first line of the input contains a single integer $$$n$$$ ($$$1 \\le n \\le 100$$$)\u00a0\u2014 the number of elements in the array. The second line of the input contains $$$n$$$ integers $$$a_i$$$ ($$$1 \\le a_1&lt;a_2&lt;\\dots&lt;a_n \\le 10^3$$$)\u00a0\u2014 the array written by Giraffe.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n = int(input())\na = list(map(int,input().split()))\n\ncount=ans=0\n\nif(n>=2 and a[0]==1 and a[1]==2):\n\tcount+=1\n\nfor i in range(1,n-1):\n\tif(a[i-1]+1==a[i] and a[i+1]-1==a[i]):\n\t\tcount+=1\n\telse:\n\t\tans=max(ans,count)\n\t\tcount=0\n\nif(n>=2 and a[-1]==1000 and a[-2]==999):\n\tcount+=1\n\nans=max(count,ans)\nprint(ans)","prob_desc_sample_outputs":"[\"2\", \"2\", \"4\"]","lang_cluster":"Python","code_uid":"ef5fbe01bd96ceb2cc0f3c54b5ebf0cd","prob_desc_notes":"NoteIn the first example, JATC can erase the third and fourth elements, leaving the array $$$[1, 3, \\_, \\_, 6, 9]$$$. As you can see, there is only one way to fill in the blanks.In the second example, JATC can erase the second and the third elements. The array will become $$$[998, \\_, \\_]$$$. Because all the elements are less than or equal to $$$1000$$$, the array is still can be restored. Note, that he can't erase the first $$$2$$$ elements.In the third example, JATC can erase the first $$$4$$$ elements. Since all the elements are greater than or equal to $$$1$$$, Giraffe can still restore the array. Note, that he can't erase the last $$$4$$$ elements.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the maximum number of consecutive elements in the array that JATC can erase. If it is impossible to erase even a single element, print $$$0$$$.","prob_desc_output_to":"standard output","prob_desc_description":"JATC and his friend Giraffe are currently in their room, solving some problems. Giraffe has written on the board an array $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ of integers, such that $$$1 \\le a_1 &lt; a_2 &lt; \\ldots &lt; a_n \\le 10^3$$$, and then went to the bathroom.JATC decided to prank his friend by erasing some consecutive elements in the array. Since he doesn't want for the prank to go too far, he will only erase in a way, such that Giraffe can still restore the array using the information from the remaining elements. Because Giraffe has created the array, he's also aware that it's an increasing array and all the elements are integers in the range $$$[1, 10^3]$$$.JATC wonders what is the greatest number of elements he can erase?","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n1 2 3 4 5 6 7 8 9 10', 'output': ['9\\n']}, {'input': '5\\n1 3 5 7 9', 'output': ['0\\n']}, {'input': '7\\n1 2 3 5 6 7 8', 'output': ['3\\n']}, {'input': '4\\n1 2 100 1000', 'output': ['1\\n']}, {'input': '3\\n1 500 1000', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 6\", \"3 4\"]","prob_desc_input_spec":"The only line contains two integers p and y (2\u2009\u2264\u2009p\u2009\u2264\u2009y\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"p, y = [int(x) for x in input().split()]\nres = -1\nfor i in range(y, p, -1):\n    flag = True\n    for a in range(2, min(p+1, int(i**0.5)+1)):\n        if i % a == 0:\n            flag = False\n            break\n    if flag:\n        res = i\n        break\nprint(res)\n","prob_desc_sample_outputs":"[\"5\", \"-1\"]","lang_cluster":"Python","code_uid":"91b049b463f7a7123db237b4f0ba2e0e","prob_desc_notes":"NoteIn the first sample case grasshopper from branch 2 reaches branches 2, 4 and 6 while branch 3 is initially settled by another grasshopper. Therefore the answer is 5.It immediately follows that there are no valid branches in second sample case.","prob_desc_output_spec":"Output the number of the highest suitable branch. If there are none, print -1 instead.","prob_desc_output_to":"standard output","prob_desc_description":"The weather is fine today and hence it's high time to climb the nearby pine and enjoy the landscape.The pine's trunk includes several branches, located one above another and numbered from 2 to y. Some of them (more precise, from 2 to p) are occupied by tiny vile grasshoppers which you're at war with. These grasshoppers are known for their awesome jumping skills: the grasshopper at branch x can jump to branches .Keeping this in mind, you wisely decided to choose such a branch that none of the grasshoppers could interrupt you. At the same time you wanna settle as high as possible since the view from up there is simply breathtaking.In other words, your goal is to find the highest branch that cannot be reached by any of the grasshoppers or report that it's impossible.","length":12,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 10', 'output': ['7']}, {'input': '5 20', 'output': ['19']}, {'input': '3 9', 'output': ['7']}, {'input': '4 16', 'output': ['13']}, {'input': '6 30', 'output': ['29']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"monday\\ntuesday\", \"sunday\\nsunday\", \"saturday\\ntuesday\"]","prob_desc_input_spec":"The input consists of two lines, each of them containing the name of exactly one day of the week. It's guaranteed that each string in the input is from the set \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\".","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"s1=input()\ns2=input()\nweek=[\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"]\nif week[(week.index(s1)+31)%7]==s2:print(\"YES\")\nelif week[(week.index(s1)+28)%7]==s2:print(\"YES\")\nelif week[(week.index(s1)+30)%7]==s2:print(\"YES\")\nelse:print(\"NO\")","prob_desc_sample_outputs":"[\"NO\", \"YES\", \"YES\"]","lang_cluster":"Python","code_uid":"1eb0efc9a23ae1b6481ad964df1d445a","prob_desc_notes":"NoteIn the second sample, one can consider February 1 and March 1 of year 2015. Both these days were Sundays.In the third sample, one can consider July 1 and August 1 of year 2017. First of these two days is Saturday, while the second one is Tuesday.","prob_desc_output_spec":"Print \"YES\" (without quotes) if such situation is possible during some non-leap year. Otherwise, print \"NO\" (without quotes).","prob_desc_output_to":"standard output","prob_desc_description":"You are given names of two days of the week.Please, determine whether it is possible that during some non-leap year the first day of some month was equal to the first day of the week you are given, while the first day of the next month was equal to the second day of the week you are given. Both months should belong to one year.In this problem, we consider the Gregorian calendar to be used. The number of months in this calendar is equal to 12. The number of days in months during any non-leap year is: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.Names of the days of the week are given with lowercase English letters: \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\".","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'monday\\ntuesday', 'output': ['NO\\n']}, {'input': 'sunday\\nsunday', 'output': ['YES\\n']}, {'input': 'saturday\\ntuesday', 'output': ['YES\\n']}, {'input': 'wednesday\\nfriday', 'output': ['YES\\n']}, {'input': 'friday\\nmonday', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"X0X\\n.0.\\n.X.\"]","prob_desc_input_spec":"The input consists of three lines, each of the lines contains characters \".\", \"X\" or \"0\" (a period, a capital letter X, or a digit zero).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def win(l,s):\n    if l[0] == [s, s, s] or l[1] == [s, s, s] or l[2] == [s, s, s] or l[0][0] == s and l[1][0] == s and l[2][0] == s or \\\n            l[0][1] == s and l[1][1] == s and l[2][1] == s or l[0][2] == s and l[1][2] == s and l[2][2] == s or l[0][\n        0] == s and l[1][1] == s and l[2][2] == s or l[0][2] == s and l[1][1] == s and l[2][0] == s:\n        return 1\n    else:\n        return 0\na=list(input())\nb=list(input())\nc=list(input())\nl=[a,b,c]\nmf=a.count('X')+b.count('X')+c.count('X')\nms=a.count('0')+b.count('0')+c.count('0')\nme=a.count('.')+b.count('.')+c.count('.')\nif  mf -ms!= 1 and mf -ms!=0 :\n    print('illegal')\nelse:\n    n=win(l,'0')\n    m=win(l,'X')\n    if n==1 and m==1 or n==1 and mf-ms!=0 or m==1 and mf-ms!=1:\n        print('illegal')\n    elif n==1:\n        print('the second player won')\n    elif m==1:\n        print('the first player won')\n    else:\n        if me==0:\n            print('draw')\n        elif mf-ms==1:\n            print('second')\n        else:print('first')","prob_desc_sample_outputs":"[\"second\"]","lang_cluster":"Python","code_uid":"5810cb185e940b3920d69c59b78f90a1","prob_desc_notes":null,"prob_desc_output_spec":"Print one of the six verdicts: first, second, illegal, the first player won, the second player won or draw.","prob_desc_output_to":"standard output","prob_desc_description":"Certainly, everyone is familiar with tic-tac-toe game. The rules are very simple indeed. Two players take turns marking the cells in a 3\u2009\u00d7\u20093 grid (one player always draws crosses, the other \u2014 noughts). The player who succeeds first in placing three of his marks in a horizontal, vertical or diagonal line wins, and the game is finished. The player who draws crosses goes first. If the grid is filled, but neither Xs, nor 0s form the required line, a draw is announced.You are given a 3\u2009\u00d7\u20093 grid, each grid cell is empty, or occupied by a cross or a nought. You have to find the player (first or second), whose turn is next, or print one of the verdicts below:   illegal \u2014 if the given board layout can't appear during a valid game;  the first player won \u2014 if in the given board layout the first player has just won;  the second player won \u2014 if in the given board layout the second player has just won;  draw \u2014 if the given board layout has just let to a draw. ","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'X0X\\n.0.\\n.X.\\n', 'output': ['second\\n']}, {'input': 'X0X\\nX0.\\n.X.\\n', 'output': ['illegal\\n']}, {'input': 'X0X\\nX0X\\n.X.\\n', 'output': ['the first player won\\n']}, {'input': 'X0.\\nX0.\\nX..\\n', 'output': ['the first player won\\n']}, {'input': 'X0X\\nX0X\\n0X0\\n', 'output': ['draw\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10\\nrocesfedoc\", \"16\\nplmaetwoxesisiht\", \"1\\nz\"]","prob_desc_input_spec":"The first line of input consists of a single integer $$$n$$$ ($$$1 \\le n \\le 100$$$) \u2014 the length of the string $$$t$$$. The second line of input consists of the string $$$t$$$. The length of $$$t$$$ is $$$n$$$, and it consists only of lowercase Latin letters.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a = int(input())\ns = list(input())\n\nb = []\nfor i in range(a, 1, -1):\n    if a % i == 0:\n        b.append(i)\n\nfor i in range(len(b)-1, -1, -1):\n    s[0:b[i]] = reversed(s[0:b[i]])\n\ns = \"\".join(s)\nprint(s)","prob_desc_sample_outputs":"[\"codeforces\", \"thisisexampletwo\", \"z\"]","lang_cluster":"Python","code_uid":"72f78d9ae9f025807e729b822077ace2","prob_desc_notes":"NoteThe first example is described in the problem statement.","prob_desc_output_spec":"Print a string $$$s$$$ such that the above algorithm results in $$$t$$$.","prob_desc_output_to":"standard output","prob_desc_description":"A string $$$s$$$ of length $$$n$$$ can be encrypted by the following algorithm:  iterate over all divisors of $$$n$$$ in decreasing order (i.e. from $$$n$$$ to $$$1$$$),  for each divisor $$$d$$$, reverse the substring $$$s[1 \\dots d]$$$ (i.e. the substring which starts at position $$$1$$$ and ends at position $$$d$$$). For example, the above algorithm applied to the string $$$s$$$=\"codeforces\" leads to the following changes: \"codeforces\" $$$\\to$$$ \"secrofedoc\" $$$\\to$$$ \"orcesfedoc\" $$$\\to$$$ \"rocesfedoc\" $$$\\to$$$ \"rocesfedoc\" (obviously, the last reverse operation doesn't change the string because $$$d=1$$$).You are given the encrypted string $$$t$$$. Your task is to decrypt this string, i.e., to find a string $$$s$$$ such that the above algorithm results in string $$$t$$$. It can be proven that this string $$$s$$$ always exists and is unique.","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\nabcde', 'output': ['edcba']}, {'input': '6\\nfedcba', 'output': ['abcdef']}, {'input': '7\\nhgfedcb', 'output': ['bcdefgh']}, {'input': '8\\nihgfedcb', 'output': ['bcdefghi']}, {'input': '9\\njihgfedcb', 'output': ['bcdefghij']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 3\", \"6 5\", \"1000000000 1\"]","prob_desc_input_spec":"The only line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le 10^9$$$, $$$1 \\le m \\le 1000$$$)\u00a0\u2014 the size of the field and the number of parts to split the sets into.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n, m = [int(i) for i in input().split()]\nans = 0\nar = [n \/\/ m] * m\nfor i in range(1, n % m + 1, 1):\n    ar[i] += 1\nfor i in range(m):\n    for j in range(m):\n        if ((i * i + j * j) % m == 0):\n            ans += ar[i] * ar[j]\nprint(ans)","prob_desc_sample_outputs":"[\"1\", \"13\", \"1000000000000000000\"]","lang_cluster":"Python","code_uid":"42950263fc19dbfeac9eed130f615dde","prob_desc_notes":"NoteIn the first example, only the set for cell $$$(3, 3)$$$ can be split equally ($$$3^2 + 3^2 = 18$$$, which is divisible by $$$m=3$$$).In the second example, the sets for the following cells can be divided equally:   $$$(1, 2)$$$ and $$$(2, 1)$$$, since $$$1^2 + 2^2 = 5$$$, which is divisible by $$$5$$$;  $$$(1, 3)$$$ and $$$(3, 1)$$$;  $$$(2, 4)$$$ and $$$(4, 2)$$$;  $$$(2, 6)$$$ and $$$(6, 2)$$$;  $$$(3, 4)$$$ and $$$(4, 3)$$$;  $$$(3, 6)$$$ and $$$(6, 3)$$$;  $$$(5, 5)$$$. In the third example, sets in all cells can be divided equally, since $$$m = 1$$$.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the number of sets that can be split equally.","prob_desc_output_to":"standard output","prob_desc_description":"Arkady and his friends love playing checkers on an $$$n \\times n$$$ field. The rows and the columns of the field are enumerated from $$$1$$$ to $$$n$$$.The friends have recently won a championship, so Arkady wants to please them with some candies. Remembering an old parable (but not its moral), Arkady wants to give to his friends one set of candies per each cell of the field: the set of candies for cell $$$(i, j)$$$ will have exactly $$$(i^2 + j^2)$$$ candies of unique type.There are $$$m$$$ friends who deserve the present. How many of these $$$n \\times n$$$ sets of candies can be split equally into $$$m$$$ parts without cutting a candy into pieces? Note that each set has to be split independently since the types of candies in different sets are different.","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2', 'output': ['13\\n']}, {'input': '10 3', 'output': ['44\\n']}, {'input': '7 4', 'output': ['13\\n']}, {'input': '8 5', 'output': ['26\\n']}, {'input': '9 6', 'output': ['27\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"Is it a melon?\", \"Is it an apple?\", \"Is     it a banana ?\", \"Is   it an apple  and a  banana   simultaneouSLY?\"]","prob_desc_input_spec":"The single line contains a question represented by a non-empty line consisting of large and small Latin letters, spaces and a question mark. The line length does not exceed 100. It is guaranteed that the question mark occurs exactly once in the line \u2014 as the last symbol and that the line contains at least one letter.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"s = input()\nvowels = 'aeiouyAEIOUY'\nif s.split()[-1] == '?':\n    if s.split()[-2][-1] in vowels:\n        print('YES')\n    else:\n        print('NO')\nelse:\n    if s.split()[-1][:-1][-1] in vowels:\n        print('YES')\n    else:\n        print('NO')","prob_desc_sample_outputs":"[\"NO\", \"YES\", \"YES\", \"YES\"]","lang_cluster":"Python","code_uid":"e0936e5e62ffeda0bcb32579b1a80625","prob_desc_notes":null,"prob_desc_output_spec":"Print answer for the question in a single line: YES if the answer is \"Yes\", NO if the answer is \"No\". Remember that in the reply to the question the last letter, not the last character counts. I. e. the spaces and the question mark do not count as letters.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya plays the sleuth with his friends. The rules of the game are as follows: those who play for the first time, that is Vasya is the sleuth, he should investigate a \"crime\" and find out what is happening. He can ask any questions whatsoever that can be answered with \"Yes\" or \"No\". All the rest agree beforehand to answer the questions like that: if the question\u2019s last letter is a vowel, they answer \"Yes\" and if the last letter is a consonant, they answer \"No\". Of course, the sleuth knows nothing about it and his task is to understand that.Unfortunately, Vasya is not very smart. After 5 hours of endless stupid questions everybody except Vasya got bored. That\u2019s why Vasya\u2019s friends ask you to write a program that would give answers instead of them.The English alphabet vowels are: A, E, I, O, U, YThe English alphabet consonants are: B, C, D, F, G, H, J, K, L, M, N, P, Q, R, S, T, V, W, X, Z","length":12,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'Is this a cat?', 'output': ['NO']}, {'input': 'Is this a dog?', 'output': ['YES']}, {'input': 'Is this a bird?', 'output': ['NO']}, {'input': 'Is this a fish?', 'output': ['YES']}, {'input': 'Is this a horse?', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4\", \"6\"]","prob_desc_input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"P = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\ndef power(a, b):\n\tres = 1\n\twhile (b):\n\t\tif (b & 1): res *= a\n\t\ta *= a\n\t\tb >>= 1\n\treturn res\nans = []\nans.append(1e30)\ndef solve(pos, n, res):\n\tif (n == 1):\n\t\tans[0] = min(ans[0], res)\n\tfor i in range(2, 62):\n\t\tif (n % i == 0):\n\t\t\tsolve(pos + 1, n \/ i, res * power(P[pos], i - 1))\nn = int(input())\nsolve(0, n, 1)\nprint(ans[0])","prob_desc_sample_outputs":"[\"6\", \"12\"]","lang_cluster":"Python","code_uid":"1cea85e2f66b233a93c24d60fe669bbc","prob_desc_notes":null,"prob_desc_output_spec":"Output the smallest positive integer with exactly n divisors.","prob_desc_output_to":"standard output","prob_desc_description":"Given the number n, find the smallest positive integer which has exactly n divisors. It is guaranteed that for the given n the answer will not exceed 1018.","length":19,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1']}, {'input': '2', 'output': ['2']}, {'input': '3', 'output': ['4']}, {'input': '5', 'output': ['16']}, {'input': '8', 'output': ['36']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\".......A\\n........\\n........\\n........\\n........\\n........\\n........\\nM.......\", \".......A\\n........\\n........\\n........\\n........\\n........\\nSS......\\nM.......\", \".......A\\n........\\n........\\n........\\n........\\n.S......\\nS.......\\nMS......\"]","prob_desc_input_spec":"You are given the 8 strings whose length equals 8, describing the initial position on the board. The first line represents the top row of the board, the next one \u2014 for the second from the top, and so on, the last line represents the bottom row. Each character string matches a single cell board in the appropriate row, and the characters are in the same manner as that of the corresponding cell. If the cell is empty, the corresponding character is \".\". If a cell has Maria, then it is represented by character \"M\". If a cell has Anna, it is represented by the character \"A\". If a cell has a statue, then the cell is represented by character \"S\". It is guaranteed that the last character of the first row is always \"A\", the first character of the last line is always \"M\". The remaining characters are \".\" or \"S\".","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"r, s = [63], ''.join(input() + 'T' for i in range(8)) + 'T' * 9\nfor i in range(0, 72, 9):\n    t = set()\n    for x in r:\n        for y in (x, x - 1, x + 1, x - 9, x + 9, x - 10, x - 8, x + 10, x + 8):\n            if s[y] == 'T': continue\n            if (y < i or s[y - i] != 'S') and (y < i + 9 or s[y - i - 9] != 'S'): t.add(y)\n    r = t\nprint('WIN' if r else 'LOSE')\n","prob_desc_sample_outputs":"[\"WIN\", \"LOSE\", \"LOSE\"]","lang_cluster":"Python","code_uid":"6f2f01bc8e3eb2456c1a859c8ef6e3d3","prob_desc_notes":null,"prob_desc_output_spec":"If Maria wins, print string \"WIN\". If the statues win, print string \"LOSE\".","prob_desc_output_to":"standard output","prob_desc_description":"In this task Anna and Maria play a game with a very unpleasant rival. Anna and Maria are in the opposite squares of a chessboard (8\u2009\u00d7\u20098): Anna is in the upper right corner, and Maria is in the lower left one. Apart from them, the board has several statues. Each statue occupies exactly one square. A square that contains a statue cannot have anything or anyone \u2014 neither any other statues, nor Anna, nor Maria.Anna is present on the board as a figurant (she stands still and never moves), and Maria has been actively involved in the game. Her goal is \u2014 to come to Anna's square. Maria and statues move in turn, Maria moves first. During one move Maria can go to any adjacent on the side or diagonal cell in which there is no statue, or she can stay in the cell where she is. The statues during their move must go one square down simultaneously, and those statues that were in the bottom row fall from the board and are no longer appeared.At that moment, when one of the statues is in the cell in which the Maria is, the statues are declared winners. At the moment when Maria comes into the cell where Anna has been waiting, Maria is declared the winner.Obviously, nothing depends on the statues, so it all depends on Maria. Determine who will win, if Maria does not make a strategic error.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '.......A\\n........\\n........\\n........\\n........\\n........\\n........\\nM.......', 'output': ['WIN']}, {'input': '.......A\\n........\\n........\\n........\\n........\\n........\\nSS......\\nM.......', 'output': ['LOSE']}, {'input': '.......A\\n........\\n........\\n........\\n........\\n.S......\\nS.......\\nMS......', 'output': ['LOSE']}, {'input': '.......A\\n........\\n........\\n........\\n........\\n........\\nS.......\\nM.......', 'output': ['WIN']}, {'input': '.......A\\n........\\n........\\n........\\n........\\nS.......\\nS.......\\nM.......', 'output': ['LOSE']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":2100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2 2 1 1\", \"1 2 1 2\"]","prob_desc_input_spec":"The only line contains four integers $$$n$$$, $$$m$$$, $$$L$$$ and $$$R$$$ ($$$1\\le n,m,L,R \\le 10^9$$$, $$$L \\le R$$$, $$$n \\cdot m \\ge 2$$$).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n, m, L, R = map(int, input().split())\nmod = 998244353\nif n*m % 2:\n  print(pow(R-L+1, n*m, mod))\nelse:\n  print((pow(R-L+1, n*m, mod) + 1 - (R-L) % 2) * pow(2, mod-2, mod) % mod)","prob_desc_sample_outputs":"[\"1\", \"2\"]","lang_cluster":"Python","code_uid":"3f6a00af9736c8661d0d59781103c919","prob_desc_notes":"NoteIn the first sample, the only initial grid that satisfies the requirements is $$$a_{1,1}=a_{2,1}=a_{1,2}=a_{2,2}=1$$$. Thus the answer should be $$$1$$$.In the second sample, initial grids that satisfy the requirements are $$$a_{1,1}=a_{1,2}=1$$$ and $$$a_{1,1}=a_{1,2}=2$$$. Thus the answer should be $$$2$$$.","prob_desc_output_spec":"Output one integer, representing the desired answer modulo $$$998,244,353$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Alice has got addicted to a game called Sirtet recently.In Sirtet, player is given an $$$n \\times m$$$ grid. Initially $$$a_{i,j}$$$ cubes are stacked up in the cell $$$(i,j)$$$. Two cells are called adjacent if they share a side. Player can perform the following operations:   stack up one cube in two adjacent cells;  stack up two cubes in one cell. Cubes mentioned above are identical in height.Here is an illustration of the game. States on the right are obtained by performing one of the above operations on the state on the left, and grey cubes are added due to the operation.  Player's goal is to make the height of all cells the same (i.e. so that each cell has the same number of cubes in it) using above operations. Alice, however, has found out that on some starting grids she may never reach the goal no matter what strategy she uses. Thus, she is wondering the number of initial grids such that   $$$L \\le a_{i,j} \\le R$$$ for all $$$1 \\le i \\le n$$$, $$$1 \\le j \\le m$$$;  player can reach the goal using above operations. Please help Alice with it. Notice that the answer might be large, please output the desired value modulo $$$998,244,353$$$.","length":6,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3 1 1', 'output': ['1']}, {'input': '2 2 2 3', 'output': ['4']}, {'input': '1 3 1 2', 'output': ['8']}, {'input': '4 4 1 2', 'output': ['256']}, {'input': '5 5 2 3', 'output': ['33554432']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"0 1 1 0 0 0 0 0 0 7 0 0 0 0\", \"5 1 1 1 1 0 0 0 0 0 0 0 0 0\"]","prob_desc_input_spec":"The only line contains 14 integers $$$a_1, a_2, \\ldots, a_{14}$$$ ($$$0 \\leq a_i \\leq 10^9$$$)\u00a0\u2014 the number of stones in each hole. It is guaranteed that for any $$$i$$$ ($$$1\\leq i \\leq 14$$$) $$$a_i$$$ is either zero or odd, and there is at least one stone in the board.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"A=list(map(int,input().split()))\nscore=0\nfor i in range(14):\n    score=max(score,sum([j for j in [(A[j] if i!=j else 0)+A[i]\/\/14+(1 if (j+13-i)%14<A[i]%14 else 0) for j in range(14)] if j%2==0]))\nprint(score)\n","prob_desc_sample_outputs":"[\"4\", \"8\"]","lang_cluster":"Python","code_uid":"485f76e306ca4f73720657504c0ad37f","prob_desc_notes":"NoteIn the first test case the board after the move from the hole with $$$7$$$ stones will look like 1 2 2 0 0 0 0 0 0 0 1 1 1 1. Then the player collects the even numbers and ends up with a score equal to $$$4$$$.","prob_desc_output_spec":"Output one integer, the maximum possible score after one move.","prob_desc_output_to":"standard output","prob_desc_description":"Mancala is a game famous in the Middle East. It is played on a board that consists of 14 holes.   Initially, each hole has $$$a_i$$$ stones. When a player makes a move, he chooses a hole which contains a positive number of stones. He takes all the stones inside it and then redistributes these stones one by one in the next holes in a counter-clockwise direction.Note that the counter-clockwise order means if the player takes the stones from hole $$$i$$$, he will put one stone in the $$$(i+1)$$$-th hole, then in the $$$(i+2)$$$-th, etc. If he puts a stone in the $$$14$$$-th hole, the next one will be put in the first hole.After the move, the player collects all the stones from holes that contain even number of stones. The number of stones collected by player is the score, according to Resli.Resli is a famous Mancala player. He wants to know the maximum score he can obtain after one move.","length":5,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1 1 1 1 1 1 1 1 1 1 1 1', 'output': ['7\\n']}, {'input': '0 0 0 0 0 0 0 0 0 0 0 0 0 1', 'output': ['0\\n']}, {'input': '1 0 1 0 1 0 1 0 1 0 1 0 1 0', 'output': ['1\\n']}, {'input': '3 3 3 3 3 3 3 3 3 3 3 3 3 3', 'output': ['21\\n']}, {'input': '0 0 0 0 0 0 0 0 0 0 0 0 0 3', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"abcd\", \"ababa\", \"zzz\"]","prob_desc_input_spec":"The first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"S = input()\n\nans = 0\nmet = set()\n\nfor i in range(len(S)):\n    for j in range(i, -1, -1):\n        if S[j:i+1] in met:\n            ans = max(ans, i - j + 1)\n        else:\n            met.add(S[j:i+1])\n            \nprint(ans)","prob_desc_sample_outputs":"[\"0\", \"3\", \"2\"]","lang_cluster":"Python","code_uid":"487c13218d4e38dfa69397e5d1a8d66f","prob_desc_notes":null,"prob_desc_output_spec":"Output one number \u2014 length of the longest substring that can be met in the string at least twice.","prob_desc_output_to":"standard output","prob_desc_description":"You're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'abcabcabc', 'output': ['3']}, {'input': 'aaaaaa', 'output': ['5']}, {'input': 'abcdefg', 'output': ['0']}, {'input': 'abccba', 'output': ['2']}, {'input': 'abcdeabc', 'output': ['4']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10 5\", \"-10 5\"]","prob_desc_input_spec":"The first line contains two integers x,\u2009y (\u2009-\u2009109\u2009\u2264\u2009x,\u2009y\u2009\u2264\u2009109,\u2009x\u2009\u2260\u20090,\u2009y\u2009\u2260\u20090).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x,y = map(int,input().split())\n\nif  x > 0 and y > 0:\n    print(0, x + y, x + y, 0)\nelif x < 0 and y > 0:\n    print(-y + x, 0, 0,-x + y)\nelif x > 0 and y < 0:\n    print(0, y - x, x - y, 0)\nelse:\n    print(x + y, 0,0, x + y)\n","prob_desc_sample_outputs":"[\"0 15 15 0\", \"-15 0 0 15\"]","lang_cluster":"Python","code_uid":"e8f624d23e36b837e350d21df82c289f","prob_desc_notes":"NoteFigure to the first sample","prob_desc_output_spec":"Print in the single line four integers x1,\u2009y1,\u2009x2,\u2009y2 \u2014 the coordinates of the required points.","prob_desc_output_to":"standard output","prob_desc_description":"Vasily the bear has a favorite rectangle, it has one vertex at point (0,\u20090), and the opposite vertex at point (x,\u2009y). Of course, the sides of Vasya's favorite rectangle are parallel to the coordinate axes. Vasya also loves triangles, if the triangles have one vertex at point B\u2009=\u2009(0,\u20090). That's why today he asks you to find two points A\u2009=\u2009(x1,\u2009y1) and C\u2009=\u2009(x2,\u2009y2), such that the following conditions hold:  the coordinates of points: x1, x2, y1, y2 are integers. Besides, the following inequation holds: x1\u2009&lt;\u2009x2;  the triangle formed by point A, B and C is rectangular and isosceles ( is right);  all points of the favorite rectangle are located inside or on the border of triangle ABC;  the area of triangle ABC is as small as possible. Help the bear, find the required points. It is not so hard to proof that these points are unique.","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '20 10', 'output': ['0 30 30 0\\n']}, {'input': '-20 10', 'output': ['-30 0 0 30\\n']}, {'input': '20 -10', 'output': ['0 -30 30 0\\n']}, {'input': '-20 -10', 'output': ['-30 0 0 -30\\n']}, {'input': '1 1', 'output': ['0 2 2 0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 4 0\\n2 1 2\", \"5 6 1\\n2 7 2\", \"3 3 3\\n2 2 2\"]","prob_desc_input_spec":"The first line of the input contains three integers a, b and c (0\u2009\u2264\u2009a,\u2009b,\u2009c\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 the number of blue, violet and orange spheres that are in the magician's disposal. The second line of the input contains three integers, x, y and z (0\u2009\u2264\u2009x,\u2009y,\u2009z\u2009\u2264\u20091\u2009000\u2009000)\u00a0\u2014 the number of blue, violet and orange spheres that he needs to get.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a, b, c =[int(q) for q in input().split()]\nx, y, z =[int(q) for q in input().split()]\nif a>=x:\n    a -=x\n    x=0\nelse:\n    x -=a\n    a=0\nif b>=y:\n    b -=y\n    y=0\nelse:\n    y -=b\n    b=0\nif c>=z:\n    c -=z\n    z=0\nelse:\n    z -=c\n    c=0\nif x+y+z<=a\/\/2+b\/\/2+c\/\/2:\n    print(\"Yes\")\nelse:\n    print(\"No\")","prob_desc_sample_outputs":"[\"Yes\", \"No\", \"Yes\"]","lang_cluster":"Python","code_uid":"4fa49fbef2bc1a3b13d419c7ffeabf4a","prob_desc_notes":"NoteIn the first sample the wizard has 4 blue and 4 violet spheres. In his first action he can turn two blue spheres into one violet one. After that he will have 2 blue and 5 violet spheres. Then he turns 4 violet spheres into 2 orange spheres and he ends up with 2 blue, 1 violet and 2 orange spheres, which is exactly what he needs.","prob_desc_output_spec":"If the wizard is able to obtain the required numbers of spheres, print \"Yes\". Otherwise, print \"No\".","prob_desc_output_to":"standard output","prob_desc_description":"Carl is a beginner magician. He has a blue, b violet and c orange magic spheres. In one move he can transform two spheres of the same color into one sphere of any other color. To make a spell that has never been seen before, he needs at least x blue, y violet and z orange spheres. Can he get them (possible, in multiple actions)?","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3 3\\n1 1 1', 'output': ['Yes\\n']}, {'input': '0 0 0\\n0 0 0', 'output': ['Yes\\n']}, {'input': '1 1 1\\n2 2 2', 'output': ['No\\n']}, {'input': '5 5 5\\n3 3 3', 'output': ['Yes\\n']}, {'input': '1000000 1000000 1000000\\n500000 500000 500000', 'output': ['Yes\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 7 3 3\", \"7 7 7 7\"]","prob_desc_input_spec":"The first line contains four space-separated integers s1,\u2009s2,\u2009s3,\u2009s4 (1\u2009\u2264\u2009s1,\u2009s2,\u2009s3,\u2009s4\u2009\u2264\u2009109) \u2014 the colors of horseshoes Valera has. Consider all possible colors indexed with integers.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"s = [int(i) for i in input().split()]\nm=0\nfor i in s:\n    if s.count(i) >= 2:\n        s = list(set(s))\n\nm = len(s)\n\nif m == 4:\n    print(0)\nelif m == 3:\n    print(1)\nelif m == 2:\n    print(2)\nelse:\n    print(3)","prob_desc_sample_outputs":"[\"1\", \"3\"]","lang_cluster":"Python","code_uid":"1232c75961b5aefb45139fa03a81cbe9","prob_desc_notes":null,"prob_desc_output_spec":"Print a single integer \u2014 the minimum number of horseshoes Valera needs to buy.","prob_desc_output_to":"standard output","prob_desc_description":"Valera the Horse is going to the party with friends. He has been following the fashion trends for a while, and he knows that it is very popular to wear all horseshoes of different color. Valera has got four horseshoes left from the last year, but maybe some of them have the same color. In this case he needs to go to the store and buy some few more horseshoes, not to lose face in front of his stylish comrades.Fortunately, the store sells horseshoes of all colors under the sun and Valera has enough money to buy any four of them. However, in order to save the money, he would like to spend as little money as possible, so you need to help Valera and determine what is the minimum number of horseshoes he needs to buy to wear four horseshoes of different colors to a party.","length":16,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 2 3 4', 'output': ['0']}, {'input': '5 5 5 5', 'output': ['3']}, {'input': '6 6 7 7', 'output': ['2']}, {'input': '8 9 10 10', 'output': ['1']}, {'input': '11 12 13 14', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"code\\nedoc\", \"abb\\naba\", \"code\\ncode\"]","prob_desc_input_spec":"The first line contains word s, the second line contains word t. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"word1 = input()\nword2 = input()\n\nw1len = len(word1)\nw2len = len(word2)\n\n\n\nif w1len != w2len:\n    print('NO')\n\nelse:\n\n\n    if (w1len % 2) == 0:  # ES\n        index = w1len - 1\n        cant = w1len\n        i = 0\n        while cant != 0:\n            a = word1[i]\n            b = word2[index]\n\n\n\n            if a == b:\n                i += 1\n                index -= 1\n                cant -= 1\n\n            else:\n                print('NO')\n                break\n        if cant == 0:\n            print('YES')\n\n    else:\n        index = w1len - 1\n        cant = w1len\n        i = 0\n        while cant != 0:\n            a = word1[i]\n            b = word2[index]\n\n\n\n            if a == b:\n                i += 1\n                index -= 1\n                cant -= 1\n\n            else:\n                print('NO')\n                break\n        if cant == 0:\n            print('YES')\n\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"NO\"]","lang_cluster":"Python","code_uid":"c7185703101804a6da5a22475a72f139","prob_desc_notes":null,"prob_desc_output_spec":"If the word t is a word s, written reversely, print YES, otherwise print NO.","prob_desc_output_to":"standard output","prob_desc_description":"The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the \u00abtranslation\u00bb. Vasya translated word s from Berlandish into Birlandish as t. Help him: find out if he translated the word correctly.","length":56,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'hello\\nolleh', 'output': ['YES\\n']}, {'input': 'world\\nworld', 'output': ['NO\\n']}, {'input': 'python\\nnohtyp', 'output': ['YES\\n']}, {'input': 'java\\navaj', 'output': ['YES\\n']}, {'input': 'ruby\\nybur', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1100.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"3000\"]","prob_desc_input_spec":"The only line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the prediction on the number of people who will buy the game.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"print(int(int(input())\/2520))","prob_desc_sample_outputs":"[\"1\"]","lang_cluster":"Python","code_uid":"64a8de51f0cd1a62244b393fad5dd07d","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer showing how many numbers from 1 to n are divisible by all numbers from 2 to 10.","prob_desc_output_to":"standard output","prob_desc_description":"IT City company developing computer games invented a new way to reward its employees. After a new game release users start buying it actively, and the company tracks the number of sales with precision to each transaction. Every time when the next number of sales is divisible by all numbers from 2 to 10 every developer of this game gets a small bonus.A game designer Petya knows that the company is just about to release a new game that was partly developed by him. On the basis of his experience he predicts that n people will buy the game during the first month. Now Petya wants to determine how many times he will get the bonus. Help him to know it.","length":1,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2520', 'output': ['1']}, {'input': '5040', 'output': ['2']}, {'input': '10000', 'output': ['3']}, {'input': '25200', 'output': ['10']}, {'input': '1018', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1\", \"2\", \"3\"]","prob_desc_input_spec":"The first line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200940).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"# I've proven, that z takes form of 2 ** (k - 1) - 1,\n# where 2 ** k - 1 is prime, which are called 'Mersenne primes'.\n\np = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127,\\\n    521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689,\\\n    9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503,\\\n    132049, 216091, 756839, 859433, 1257787, 1398269,\\\n    2976221, 3021377, 6972593, 13466917, 20996011]\nn = int(input())\nMOD = 10 ** 9 + 7\nprint((pow(2, p[n - 1] - 1, MOD) - 1) % MOD)\n","prob_desc_sample_outputs":"[\"1\", \"3\", \"15\"]","lang_cluster":"Python","code_uid":"5c9eaf9be0675a4bf093754d1cdfd1ed","prob_desc_notes":null,"prob_desc_output_spec":"Print a single integer \u2014 the number zn modulo 1000000007 (109\u2009+\u20097). It is guaranteed that the answer exists.","prob_desc_output_to":"standard output","prob_desc_description":"Consider the following equation:  where sign [a] represents the integer part of number a.Let's find all integer z (z\u2009&gt;\u20090), for which this equation is unsolvable in positive integers. The phrase \"unsolvable in positive integers\" means that there are no such positive integers x and y (x,\u2009y\u2009&gt;\u20090), for which the given above equation holds.Let's write out all such z in the increasing order: z1,\u2009z2,\u2009z3, and so on (zi\u2009&lt;\u2009zi\u2009+\u20091). Your task is: given the number n, find the number zn.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5', 'output': ['31']}, {'input': '10', 'output': ['352']}, {'input': '15', 'output': ['1048575']}, {'input': '20', 'output': ['2097151']}, {'input': '25', 'output': ['8388607']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 2 1000\", \"2 2 1000\", \"5 3 1103\"]","prob_desc_input_spec":"Input consists of three integers n,\u2009k,\u2009m (1\u2009\u2264\u2009n\u2009\u2264\u20091000, 1\u2009\u2264\u2009k\u2009\u2264\u2009100, 1\u2009\u2264\u2009m\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def get_input():\n    hahaha=input()\n    (n,k,m)=hahaha.split(sep=None, maxsplit=1000)\n    return (int(n),int(k),int(m))\n(n,k,m)=get_input()\nf=[0 for i in range(k)]   \ns=0\nfor v in range(n):\n    tens = 10**v%k\n    f=[  (sum(   [f[(j+k-(x+1)*tens)%k] for x in range(9)] )+f[j])%m       for j in range(k)]\n    for x in range(9):\n        f[(x+1)*tens%k]+=1\n    if n-v-1==0:\n        s+=(f[0]%m)\n    else:\n        s+=f[0]*((10**(n-v-2)*9))%m\n    f[0]=0\nprint(s%m)\n","prob_desc_sample_outputs":"[\"4\", \"45\", \"590\"]","lang_cluster":"Python","code_uid":"a06e529109fcd598188d6765019dd515","prob_desc_notes":"NoteA suffix of a string S is a non-empty string that can be obtained by removing some number (possibly, zero) of first characters from S.","prob_desc_output_spec":"Print the required number modulo m.","prob_desc_output_to":"standard output","prob_desc_description":"Amr doesn't like Maths as he finds it really boring, so he usually sleeps in Maths lectures. But one day the teacher suspected that Amr is sleeping and asked him a question to make sure he wasn't.First he gave Amr two positive integers n and k. Then he asked Amr, how many integer numbers x\u2009&gt;\u20090 exist such that:  Decimal representation of x (without leading zeroes) consists of exactly n digits;  There exists some integer y\u2009&gt;\u20090 such that:   ;  decimal representation of y is a suffix of decimal representation of x.  As the answer to this question may be pretty huge the teacher asked Amr to output only its remainder modulo a number m.Can you help Amr escape this embarrassing situation?","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1000', 'output': ['10']}, {'input': '3 2 1000', 'output': ['495']}, {'input': '4 3 1000', 'output': ['4950']}, {'input': '5 4 1000', 'output': ['49500']}, {'input': '6 5 1000', 'output': ['495000']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"42\", \"5\"]","prob_desc_input_spec":"The only line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910000).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n=int(input())\na=n\/\/3\nb=n%3\nif b==2:\n    a=a+1\np=a\/\/12\nq=a%12\nprint(p,q)","prob_desc_sample_outputs":"[\"1 2\", \"0 2\"]","lang_cluster":"Python","code_uid":"607cfc90cbbdd84013355718b776f850","prob_desc_notes":null,"prob_desc_output_spec":"Print two non-negative space-separated integers a and b, where a is the numbers of feet and b is the number of inches.","prob_desc_output_to":"standard output","prob_desc_description":"Lengths are measures in Baden in inches and feet. To a length from centimeters it is enough to know that an inch equals three centimeters in Baden and one foot contains 12 inches.You are given a length equal to n centimeters. Your task is to convert it to feet and inches so that the number of feet was maximum. The result should be an integer rounded to the closest value containing an integral number of inches.Note that when you round up, 1 cm rounds up to 0 inches and 2 cm round up to 1 inch.","length":8,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '100', 'output': ['2 10']}, {'input': '36', 'output': ['1 0']}, {'input': '50', 'output': ['1 4']}, {'input': '1', 'output': ['0 0']}, {'input': '200', 'output': ['5 4']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\", \"5\"]","prob_desc_input_spec":"The single line contains the positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091015).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x=int(input())\nif x%2==0:\n\tprint(int(x\/2))\nelse:\n\tprint(-(int(x\/2)+1))","prob_desc_sample_outputs":"[\"2\", \"-3\"]","lang_cluster":"Python","code_uid":"1a191d065aaccc57d30c445479f777c0","prob_desc_notes":"Notef(4)\u2009=\u2009\u2009-\u20091\u2009+\u20092\u2009-\u20093\u2009+\u20094\u2009=\u20092f(5)\u2009=\u2009\u2009-\u20091\u2009+\u20092\u2009-\u20093\u2009+\u20094\u2009-\u20095\u2009=\u2009\u2009-\u20093","prob_desc_output_spec":"Print f(n) in a single line.","prob_desc_output_to":"standard output","prob_desc_description":"For a positive integer n let's define a function f:f(n)\u2009=\u2009\u2009-\u20091\u2009+\u20092\u2009-\u20093\u2009+\u2009..\u2009+\u2009(\u2009-\u20091)nn Your task is to calculate f(n) for a given integer n.","length":5,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['-1']}, {'input': '2', 'output': ['1']}, {'input': '3', 'output': ['-2']}, {'input': '6', 'output': ['3']}, {'input': '7', 'output': ['-4']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"21\", \"20\"]","prob_desc_input_spec":"The first line contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n = int(input())\nm = str(n)\ng = len(m)\nl = [int(m[0])-1]+[9]*(g-1)\nh = 0\nless = 0\nwhile(h<len(l)):\n    less = less + l[h]\n    h = h + 1\na = n - less\nr = []\ni = 0\nwhile(a<n):\n    j = 0\n    s = str(a)\n    c = a\n    while j<len(s):\n        c = c + int(s[j])\n        j = j + 1\n    if(c==n):\n        i +=1\n        r = r + [a]\n    a = a + 1\nif(i==0):\n    print(0)\nelse:\n    print(i)\n    j = 0\n    while(j<len(r)):\n        print(r[j])\n        j = j + 1\n","prob_desc_sample_outputs":"[\"1\\n15\", \"0\"]","lang_cluster":"Python","code_uid":"3d9b561821b9d49b6ba48d5bbb08b2e1","prob_desc_notes":"NoteIn the first test case x\u2009=\u200915 there is only one variant: 15\u2009+\u20091\u2009+\u20095\u2009=\u200921.In the second test case there are no such x.","prob_desc_output_spec":"In the first line print one integer k\u00a0\u2014 number of different values of x satisfying the condition.  In next k lines print these values in ascending order.","prob_desc_output_to":"standard output","prob_desc_description":"Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number n. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that n is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer x was given. The task was to add x to the sum of the digits of the number x written in decimal numeral system.Since the number n on the board was small, Vova quickly guessed which x could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number n for all suitable values of x or determine that such x does not exist. Write such a program for Vova.","length":31,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10', 'output': ['1\\n5']}, {'input': '11', 'output': ['1\\n6']}, {'input': '12', 'output': ['1\\n7']}, {'input': '13', 'output': ['1\\n8']}, {'input': '14', 'output': ['1\\n9']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"48\", \"6\"]","prob_desc_input_spec":"The only line of the input contains one integer m (1\u2009\u2264\u2009m\u2009\u2264\u20091015), meaning that Limak wants you to choose X between 1 and m, inclusive.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"#D razbor 1\n\ndef func(n):\n    if n<8:\n        return n,n\n    \n    max_a = int(n**(1\/3))\n    if (max_a+1)**3<=n:\n        max_a += 1\n    \n    v1=func(n-max_a**3)\n    v1=(v1[0]+1,v1[1]+max_a**3)\n    \n    v2=func(max_a**3-1-(max_a-1)**3)\n    v2=(v2[0]+1,v2[1]+(max_a-1)**3)\n    \n    if v2>v1:\n        return v2\n    else:\n        return v1\n\n\nprint(' '.join(map(str, func(int(input())))))  ","prob_desc_sample_outputs":"[\"9 42\", \"6 6\"]","lang_cluster":"Python","code_uid":"5f2c773ab846b2f93540a547db5c3813","prob_desc_notes":"NoteIn the first sample test, there will be 9 blocks if you choose X\u2009=\u200923 or X\u2009=\u200942. Limak wants to maximize X secondarily so you should choose 42.In more detail, after choosing X\u2009=\u200942 the process of building a tower is:  Limak takes a block with side 3 because it's the biggest block with volume not greater than 42. The remaining volume is 42\u2009-\u200927\u2009=\u200915.  The second added block has side 2, so the remaining volume is 15\u2009-\u20098\u2009=\u20097.  Finally, Limak adds 7 blocks with side 1, one by one. So, there are 9 blocks in the tower. The total volume is is 33\u2009+\u200923\u2009+\u20097\u00b713\u2009=\u200927\u2009+\u20098\u2009+\u20097\u2009=\u200942.","prob_desc_output_spec":"Print two integers\u00a0\u2014 the maximum number of blocks in the tower and the maximum required total volume X, resulting in the maximum number of blocks.","prob_desc_output_to":"standard output","prob_desc_description":"Limak is a little polar bear. He plays by building towers from blocks. Every block is a cube with positive integer length of side. Limak has infinitely many blocks of each side length.A block with side a has volume a3. A tower consisting of blocks with sides a1,\u2009a2,\u2009...,\u2009ak has the total volume a13\u2009+\u2009a23\u2009+\u2009...\u2009+\u2009ak3.Limak is going to build a tower. First, he asks you to tell him a positive integer X\u00a0\u2014 the required total volume of the tower. Then, Limak adds new blocks greedily, one by one. Each time he adds the biggest block such that the total volume doesn't exceed X.Limak asks you to choose X not greater than m. Also, he wants to maximize the number of blocks in the tower at the end (however, he still behaves greedily). Secondarily, he wants to maximize X.Can you help Limak? Find the maximum number of blocks his tower can have and the maximum X\u2009\u2264\u2009m that results this number of blocks.","length":23,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '100\\n', 'output': ['10 100\\n']}, {'input': '500\\n', 'output': ['12 486\\n']}, {'input': '1000\\n', 'output': ['13 1000\\n']}, {'input': '2000\\n', 'output': ['14 1728\\n']}, {'input': '3000\\n', 'output': ['15 2744\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 50\\n50\", \"3 100\\n50 50 100\", \"2 50\\n50 50\"]","prob_desc_input_spec":"The first line contains two integers n, k (1\u2009\u2264\u2009n\u2009\u2264\u200950,\u20091\u2009\u2264\u2009k\u2009\u2264\u20095000) \u2014 the number of people, including Greg, and the boat's weight limit. The next line contains n integers \u2014 the people's weights. A person's weight is either 50 kilos or 100 kilos. You can consider Greg and his friends indexed in some way.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"from collections import deque\n\nn, k = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nc50 = sum([1 for i in a if i == 50])\nc100 = sum([1 for i in a if i == 100])\nc = [[0] * 51 for i in range(51)]\nc[0][0] = 1\nc[1][0] = 1\nc[1][1] = 1\nfor x in range(2, 51):\n    for y in range(x + 1):\n        c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\nd = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n# d[i][j][c] \u043e\u0442\u0432\u0435\u0442, \u043a\u043e\u0433\u0434\u0430 \u043c\u044b \u043f\u0435\u0440\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u0438 i \u043f\u043e 50 \u043a\u0433 \u0438 j \u043f\u043e 100 \u043a\u0433 \u0438 \u043b\u043e\u0434\u043a\u0430 \u043d\u0430 \u0431\u0435\u0440\u0435\u0433\u0443 c\nd[0][0][0][0] = 1\nd[0][0][0][1] = 0\nq = deque()\nq.append([0, 0, 0])\nwhile len(q) > 0:\n    i, j, shore = q.popleft()\n    for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n        for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n            if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                continue\n            i1 = i + fifty if shore == 0 else i - fifty\n            j1 = j + hundreds if shore == 0 else j - hundreds\n            if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                d[i1][j1][1 ^ shore][0] = 0\n                q.append((i1, j1, 1 ^ shore))\n            if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                continue\n            koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (\n                c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n            d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n            d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\nif d[c50][c100][1][1] == float('inf'):\n    print(-1)\n    print(0)\nelse:\n    print(d[c50][c100][1][1])\n    print(d[c50][c100][1][0])\n\n","prob_desc_sample_outputs":"[\"1\\n1\", \"5\\n2\", \"-1\\n0\"]","lang_cluster":"Python","code_uid":"95cb9c03cdaa1c1fb1e06a1d9ceae682","prob_desc_notes":"NoteIn the first test Greg walks alone and consequently, he needs only one ride across the river.In the second test you should follow the plan:  transport two 50 kg. people;  transport one 50 kg. person back;  transport one 100 kg. person;  transport one 50 kg. person back;  transport two 50 kg. people. That totals to 5 rides. Depending on which person to choose at step 2, we can get two distinct ways.","prob_desc_output_spec":"In the first line print an integer \u2014 the minimum number of rides. If transporting everyone to the other bank is impossible, print an integer -1. In the second line print the remainder after dividing the number of ways to transport the people in the minimum number of rides by number 1000000007 (109\u2009+\u20097). If transporting everyone to the other bank is impossible, print integer 0.","prob_desc_output_to":"standard output","prob_desc_description":"One day Greg and his friends were walking in the forest. Overall there were n people walking, including Greg. Soon he found himself in front of a river. The guys immediately decided to get across the river. Luckily, there was a boat by the river bank, just where the guys were standing. We know that the boat can hold people with the total weight of at most k kilograms.Greg immediately took a piece of paper and listed there the weights of all people in his group (including himself). It turned out that each person weights either 50 or 100 kilograms. Now Greg wants to know what minimum number of times the boat needs to cross the river to transport the whole group to the other bank. The boat needs at least one person to navigate it from one bank to the other. As the boat crosses the river, it can have any non-zero number of passengers as long as their total weight doesn't exceed k.Also Greg is wondering, how many ways there are to transport everybody to the other side in the minimum number of boat rides. Two ways are considered distinct if during some ride they have distinct sets of people on the boat.Help Greg with this problem. ","length":44,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 200\\n50 50 50 50 100', 'output': ['5\\n4\\n']}, {'input': '4 150\\n50 50 50 100', 'output': ['5\\n2\\n']}, {'input': '3 100\\n50 50 100', 'output': ['5\\n2\\n']}, {'input': '2 100\\n50 50', 'output': ['3\\n2\\n']}, {'input': '1 50\\n50', 'output': ['1\\n1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 2 1 2\", \"1 12 1 12\", \"50 100 3 30\"]","prob_desc_input_spec":"The only line contains four integers l,\u2009r,\u2009x,\u2009y (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009109, 1\u2009\u2264\u2009x\u2009\u2264\u2009y\u2009\u2264\u2009109).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"import math\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n\ndef lcm(a, b):\n    return a * b \/\/ (gcd(a, b))\n\n\ndef f(d):\n    d = str(d)\n    if d[len(d) - 2:] == '.0':\n        return True\n    return False\n\n\nl, r, x, y = [int(i) for i in input().split()]\ncount = 0\nfor c in range(1, int(math.sqrt(y \/ x)) + 1):\n    d = (y \/ x) \/ c\n    if f(d):\n        if l <= c * x and r >= d * x and gcd(c * x, d * x) == x and lcm(c * x, d * x) == y:\n            if c != d:\n                count += 2\n            else:\n                count += 1\nprint(count)","prob_desc_sample_outputs":"[\"2\", \"4\", \"0\"]","lang_cluster":"Python","code_uid":"d2d0b8dde7b2b05874902711639bd40f","prob_desc_notes":"NoteIn the first example there are two suitable good pairs of integers (a,\u2009b): (1,\u20092) and (2,\u20091).In the second example there are four suitable good pairs of integers (a,\u2009b): (1,\u200912), (12,\u20091), (3,\u20094) and (4,\u20093).In the third example there are good pairs of integers, for example, (3,\u200930), but none of them fits the condition l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r.","prob_desc_output_spec":"In the only line print the only integer\u00a0\u2014 the answer for the problem.","prob_desc_output_to":"standard output","prob_desc_description":"Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.We define a pair of integers (a,\u2009b) good, if GCD(a,\u2009b)\u2009=\u2009x and LCM(a,\u2009b)\u2009=\u2009y, where GCD(a,\u2009b) denotes the greatest common divisor of a and b, and LCM(a,\u2009b) denotes the least common multiple of a and b.You are given two integers x and y. You are to find the number of good pairs of integers (a,\u2009b) such that l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r. Note that pairs (a,\u2009b) and (b,\u2009a) are considered different if a\u2009\u2260\u2009b.","length":29,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10 1 10', 'output': ['4\\n']}, {'input': '1 100 2 50', 'output': ['2\\n']}, {'input': '10 20 2 10', 'output': ['0\\n']}, {'input': '1 1000000000 1 1000000000', 'output': ['134\\n']}, {'input': '1 1000000000 2 500000000', 'output': ['66\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"5 2 2\", \"5 4 7\", \"6 2 3\"]","prob_desc_input_spec":"The single line contains three integers T,\u2009S,\u2009q (2\u2009\u2264\u2009q\u2009\u2264\u2009104, 1\u2009\u2264\u2009S\u2009&lt;\u2009T\u2009\u2264\u2009105).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"t,s,q=map(int,input().split())\nres=0\nwhile s<t:s*=q;res+=1\nprint(res)","prob_desc_sample_outputs":"[\"2\", \"1\", \"1\"]","lang_cluster":"Python","code_uid":"075c28eaa1bdc66e9693240308b15533","prob_desc_notes":"NoteIn the first test, the song is played twice faster than it is downloaded, which means that during four first seconds Lesha reaches the moment that has not been downloaded, and starts the song again. After another two seconds, the song is downloaded completely, and thus, Lesha starts the song twice.In the second test, the song is almost downloaded, and Lesha will start it only once.In the third sample test the download finishes and Lesha finishes listening at the same moment. Note that song isn't restarted in this case.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the number of times the song will be restarted.","prob_desc_output_to":"standard output","prob_desc_description":"Little Lesha loves listening to music via his smartphone. But the smartphone doesn't have much memory, so Lesha listens to his favorite songs in a well-known social network InTalk.Unfortunately, internet is not that fast in the city of Ekaterinozavodsk and the song takes a lot of time to download. But Lesha is quite impatient. The song's duration is T seconds. Lesha downloads the first S seconds of the song and plays it. When the playback reaches the point that has not yet been downloaded, Lesha immediately plays the song from the start (the loaded part of the song stays in his phone, and the download is continued from the same place), and it happens until the song is downloaded completely and Lesha listens to it to the end. For q seconds of real time the Internet allows you to download q\u2009-\u20091 seconds of the track.Tell Lesha, for how many times he will start the song, including the very first start.","length":4,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 2 2', 'output': ['3']}, {'input': '20 5 4', 'output': ['2']}, {'input': '100 10 10', 'output': ['2']}, {'input': '50 25 5', 'output': ['1']}, {'input': '1000 1 2', 'output': ['10']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\\n2014 2016 2015\", \"1\\n2050\"]","prob_desc_input_spec":"The first line contains the positive odd integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095) \u2014 the number of groups which Igor joined.  The next line contains n distinct integers a1,\u2009a2,\u2009...,\u2009an (2010\u2009\u2264\u2009ai\u2009\u2264\u20092100) \u2014 years of student's university entrance for each group in which Igor is the member. It is guaranteed that the input data is correct and the answer always exists. Groups are given randomly.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"count = int(input())\n\nsum = 0\nyears = input().split(' ')\nfor y in years:\n    sum += int(y)\nprint(int(sum\/count))","prob_desc_sample_outputs":"[\"2015\", \"2050\"]","lang_cluster":"Python","code_uid":"f6651d27030633c7d0250ee0f1525dd9","prob_desc_notes":"NoteIn the first test the value x\u2009=\u20091. Igor entered the university in 2015. So he joined groups members of which are students who entered the university in 2014, 2015 and 2016.In the second test the value x\u2009=\u20090. Igor entered only the group which corresponds to the year of his university entrance. ","prob_desc_output_spec":"Print the year of Igor's university entrance. ","prob_desc_output_to":"standard output","prob_desc_description":"There is the faculty of Computer Science in Berland. In the social net \"TheContact!\" for each course of this faculty there is the special group whose name equals the year of university entrance of corresponding course of students at the university. Each of students joins the group of his course and joins all groups for which the year of student's university entrance differs by no more than x from the year of university entrance of this student, where x \u2014 some non-negative integer. A value x is not given, but it can be uniquely determined from the available data. Note that students don't join other groups. You are given the list of groups which the student Igor joined. According to this information you need to determine the year of Igor's university entrance.","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3\\n2018 2019 2020', 'output': ['2019\\n']}, {'input': '5\\n2020 2021 2022 2023 2024', 'output': ['2022\\n']}, {'input': '1\\n2099', 'output': ['2099\\n']}, {'input': '3\\n2010 2011 2012', 'output': ['2011\\n']}, {'input': '5\\n2096 2097 2098 2099 2100', 'output': ['2098\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"........\\n........\\n.B....B.\\n....W...\\n........\\n..W.....\\n........\\n........\", \"..B.....\\n..W.....\\n......B.\\n........\\n.....W..\\n......B.\\n........\\n........\"]","prob_desc_input_spec":"The input consists of the board description given in eight lines, each line contains eight characters. Character 'B' is used to denote a black pawn, and character 'W' represents a white pawn. Empty cell is marked with '.'.  It's guaranteed that there will not be white pawns on the first row neither black pawns on the last row.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a = [input() for i in range(8)]\nra, rb = 8, 8\nfor j in range(8) :\n    for i in range(8) :\n        if a[i][j] == 'W' :\n            ra = min(ra, i)\n        if a[i][j] != '.' :\n            break\nfor j in range(8) :\n    for i in range(7,-1,-1) :\n        if a[i][j] == 'B' :\n            rb = min(rb, 7 - i)\n        if a[i][j] != '.' :\n            break\nprint ('A' if ra <= rb else 'B')\n","prob_desc_sample_outputs":"[\"A\", \"B\"]","lang_cluster":"Python","code_uid":"f653a66480279a05542cc29804c669ee","prob_desc_notes":"NoteIn the first sample player A is able to complete his goal in 3 steps by always moving a pawn initially located at (4,\u20095). Player B needs at least 5 steps for any of his pawns to reach the row 8. Hence, player A will be the winner.","prob_desc_output_spec":"Print 'A' if player A wins the game on the given board, and 'B' if player B will claim the victory. Again, it's guaranteed that there will always be a winner on the given board.","prob_desc_output_to":"standard output","prob_desc_description":"Galois is one of the strongest chess players of Byteforces. He has even invented a new variant of chess, which he named \u00abPawnChess\u00bb.This new game is played on a board consisting of 8 rows and 8 columns. At the beginning of every game some black and white pawns are placed on the board. The number of black pawns placed is not necessarily equal to the number of white pawns placed.   Lets enumerate rows and columns with integers from 1 to 8. Rows are numbered from top to bottom, while columns are numbered from left to right. Now we denote as (r,\u2009c) the cell located at the row r and at the column c.There are always two players A and B playing the game. Player A plays with white pawns, while player B plays with black ones. The goal of player A is to put any of his pawns to the row 1, while player B tries to put any of his pawns to the row 8. As soon as any of the players completes his goal the game finishes immediately and the succeeded player is declared a winner.Player A moves first and then they alternate turns. On his move player A must choose exactly one white pawn and move it one step upward and player B (at his turn) must choose exactly one black pawn and move it one step down. Any move is possible only if the targeted cell is empty. It's guaranteed that for any scenario of the game there will always be at least one move available for any of the players.Moving upward means that the pawn located in (r,\u2009c) will go to the cell (r\u2009-\u20091,\u2009c), while moving down means the pawn located in (r,\u2009c) will go to the cell (r\u2009+\u20091,\u2009c). Again, the corresponding cell must be empty, i.e. not occupied by any other pawn of any color.Given the initial disposition of the board, determine who wins the game if both players play optimally. Note that there will always be a winner due to the restriction that for any game scenario both players will have some moves available.","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '........\\n........\\n.B....B.\\n....W...\\n........\\n..W.....\\n........\\n........', 'output': ['A']}, {'input': '..B.....\\n..W.....\\n......B.\\n........\\n.....W..\\n......B.\\n........\\n........', 'output': ['B']}, {'input': '........\\n........\\n........\\n........\\n........\\n..W.....\\n........\\n........', 'output': ['A']}, {'input': '........\\n........\\n........\\n........\\n........\\n........\\n........\\nB.......', 'output': ['B']}, {'input': '........\\n........\\n........\\n........\\n........\\nW.......\\n........\\nB.......', 'output': ['A']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 1 -1\", \"1 3 1\", \"3 3 -1\"]","prob_desc_input_spec":"The only line contains three integers n, m and k (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091018, k is either 1 or -1).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"mod=1000000007\nn,m,k=list(map(int,input().split()))\nif k==-1:\n    co=n+m\n    if co%2!=0:\n      print(\"0\")\n    else:\n      n=n-1\n      m=m-1\n      n=n*m\n      co=pow(2,n,mod)\n      co%=1000000007\n      print(co)\nelse:\n    n=n-1\n    m=m-1\n    n=n*m\n    co=pow(2,n,mod)\n    co%=1000000007\n    print(co)","prob_desc_sample_outputs":"[\"1\", \"1\", \"16\"]","lang_cluster":"Python","code_uid":"ca16485ad2473309ec7f95e5ea164aa4","prob_desc_notes":"NoteIn the first example the only way is to put -1 into the only block.In the second example the only way is to put 1 into every block.","prob_desc_output_spec":"Print a single number denoting the answer modulo 1000000007.","prob_desc_output_to":"standard output","prob_desc_description":"Ralph has a magic field which is divided into n\u2009\u00d7\u2009m blocks. That is to say, there are n rows and m columns on the field. Ralph can put an integer in each block. However, the magic field doesn't always work properly. It works only if the product of integers in each row and each column equals to k, where k is either 1 or -1.Now Ralph wants you to figure out the number of ways to put numbers in each block in such a way that the magic field works properly. Two ways are considered different if and only if there exists at least one block where the numbers in the first way and in the second way are different. You are asked to output the answer modulo 1000000007\u2009=\u2009109\u2009+\u20097.Note that there is no range of the numbers to put in the blocks, but we can prove that the answer is not infinity.","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2 1', 'output': ['4\\n']}, {'input': '3 3 1', 'output': ['16\\n']}, {'input': '4 4 -1', 'output': ['256\\n']}, {'input': '5 5 1', 'output': ['1024\\n']}, {'input': '6 6 -1', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 2\", \"5 4\"]","prob_desc_input_spec":"The input consists of two space-separated integers p and k (3\u2009\u2264\u2009p\u2009\u2264\u20091\u2009000\u2009000, 0\u2009\u2264\u2009k\u2009\u2264\u2009p\u2009-\u20091) on a single line. It is guaranteed that p is an odd prime number.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"__author__ = 'MoonBall'\n\nimport sys\n# sys.stdin = open('data\/D.in', 'r')\nT = 1\nM = 1000000007\n\ndef process():\n    P, K = list(map(int, input().split()))\n    k = [K * x % P for x in range(P)]\n\n    # print(k)\n    # f(0) = k[f(0)]\n    # f(1) = k[f(4)]\n    # f(2) = k[f(3)]\n    # f(3) = k[f(2)]\n    # f(4) = k[f(1)]\n\n    if not K:\n        print(pow(P, P - 1, M))\n        return\n    if K == 1:\n        print(pow(P, P, M))\n        return\n\n    f = [0] * P\n    c = [0] * P\n    ans = 1\n    for i in range(P):\n        if f[i]: continue\n\n        cnt = 1\n        u = i\n        f[u] = 1\n        while not f[k[u]]:\n            u = k[u]\n            f[u] = 1\n            cnt = cnt + 1\n\n        c[cnt] = c[cnt] + 1\n\n    # print(c)\n    for i in range(2, P):\n        if c[i] != 0:\n            cnt = i * c[i] + 1\n            ans = ans * pow(cnt, c[i], M) % M\n\n    print(ans)\n\n\n\n\n\n\n\n\nfor _ in range(T):\n    process()\n","prob_desc_sample_outputs":"[\"3\", \"25\"]","lang_cluster":"Python","code_uid":"5d47a35580bfefd1f36a6d946932b48b","prob_desc_notes":"NoteIn the first sample, p\u2009=\u20093 and k\u2009=\u20092. The following functions work:   f(0)\u2009=\u20090, f(1)\u2009=\u20091, f(2)\u2009=\u20092.  f(0)\u2009=\u20090, f(1)\u2009=\u20092, f(2)\u2009=\u20091.  f(0)\u2009=\u2009f(1)\u2009=\u2009f(2)\u2009=\u20090. ","prob_desc_output_spec":"Print a single integer, the number of distinct functions f modulo 109\u2009+\u20097.","prob_desc_output_to":"standard output","prob_desc_description":"As behooves any intelligent schoolboy, Kevin Sun is studying psycowlogy, cowculus, and cryptcowgraphy at the Bovinia State University (BGU) under Farmer Ivan. During his Mathematics of Olympiads (MoO) class, Kevin was confronted with a weird functional equation and needs your help. For two fixed integers k and p, where p is an odd prime number, the functional equation states that  for some function . (This equation should hold for any integer x in the range 0 to p\u2009-\u20091, inclusive.)It turns out that f can actually be many different functions. Instead of finding a solution, Kevin wants you to count the number of distinct functions f that satisfy this equation. Since the answer may be very large, you should print your result modulo 109\u2009+\u20097.","length":58,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '7 3', 'output': ['49\\n']}, {'input': '11 5', 'output': ['121\\n']}, {'input': '13 6', 'output': ['169\\n']}, {'input': '17 8', 'output': ['289\\n']}, {'input': '19 9', 'output': ['361\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"120 51840\", \"42 42\", \"48 72\"]","prob_desc_input_spec":"The only line of the input contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n \\le m \\le 5\\cdot10^8$$$).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n2, n1 = (int(_) for _ in input().split())\nif n1 % n2 == 0:\n    n = n1 \/\/ n2\n    k = 0\n    f = True\n    while n != 1:\n        if n % 3 == 0:\n            n \/\/= 3\n            k += 1\n        elif n % 2 == 0:\n            n \/\/= 2\n            k += 1\n        else:\n            print(-1)\n            f = False\n            break\n    if f:\n        print(k)\nelse:\n    print(-1)","prob_desc_sample_outputs":"[\"7\", \"0\", \"-1\"]","lang_cluster":"Python","code_uid":"57f28824b7522c133e99bd72194296a5","prob_desc_notes":"NoteIn the first example, the possible sequence of moves is: $$$120 \\rightarrow 240 \\rightarrow 720 \\rightarrow 1440 \\rightarrow 4320 \\rightarrow 12960 \\rightarrow 25920 \\rightarrow 51840.$$$ The are $$$7$$$ steps in total.In the second example, no moves are needed. Thus, the answer is $$$0$$$.In the third example, it is impossible to transform $$$48$$$ to $$$72$$$.","prob_desc_output_spec":"Print the number of moves to transform $$$n$$$ to $$$m$$$, or -1 if there is no solution.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarp plays \"Game 23\". Initially he has a number $$$n$$$ and his goal is to transform it to $$$m$$$. In one move, he can multiply $$$n$$$ by $$$2$$$ or multiply $$$n$$$ by $$$3$$$. He can perform any number of moves.Print the number of moves needed to transform $$$n$$$ to $$$m$$$. Print -1 if it is impossible to do so.It is easy to prove that any way to transform $$$n$$$ to $$$m$$$ contains the same number of moves (i.e. number of moves doesn't depend on the way of transformation).","length":20,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['0\\n']}, {'input': '2 8', 'output': ['2\\n']}, {'input': '3 81', 'output': ['4\\n']}, {'input': '5 25', 'output': ['-1\\n']}, {'input': '10 100', 'output': ['-1\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"25 3\", \"50 5\"]","prob_desc_input_spec":"The only input line contains a pair of integers a, n (1\u2009\u2264\u2009a,\u2009n\u2009\u2264\u2009107; a\u2009+\u2009n\u2009-\u20091\u2009\u2264\u2009107).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"F = {}\n\ndef f(k):\n    if not k in F:\n        s, i, j = 0, 4, 4\n        while i <= k:\n            s += i * f(k \/\/ i)\n            i += j + 1\n            j += 2\n        F[k] = (k * (k + 1)) \/\/ 2 - s\n    return F[k]\n\ndef g(k):\n    s, i, j = 0, 4, 4\n    while i <= k:\n        s += (i - 1) * f(k \/\/ i)\n        i += j + 1\n        j += 2\n    return (k * (k + 1)) \/\/ 2 - s\n\na, n = map(int, input().split())\nprint(g(a + n - 1) - g(a - 1))","prob_desc_sample_outputs":"[\"30\", \"125\"]","lang_cluster":"Python","code_uid":"7eec0f17c590fb5fd85d790a34f8d98a","prob_desc_notes":"NoteA note to the first sample test. A year of 25 days will consist of one month containing 25 days. A year of 26 days will consist of 26 months, one day each. A year of 27 days will have three months, 9 days each.","prob_desc_output_spec":"Print the required number p.  Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use cin, cout streams or the %I64d specifier.","prob_desc_output_to":"standard output","prob_desc_description":"Reforms have started in Berland again! At this time, the Parliament is discussing the reform of the calendar. To make the lives of citizens of Berland more varied, it was decided to change the calendar. As more and more people are complaining that \"the years fly by...\", it was decided that starting from the next year the number of days per year will begin to grow. So the coming year will have exactly a days, the next after coming year will have a\u2009+\u20091 days, the next one will have a\u2009+\u20092 days and so on. This schedule is planned for the coming n years (in the n-th year the length of the year will be equal a\u2009+\u2009n\u2009-\u20091 day).No one has yet decided what will become of months. An MP Palevny made the following proposal.   The calendar for each month is comfortable to be printed on a square sheet of paper. We are proposed to make the number of days in each month be the square of some integer. The number of days per month should be the same for each month of any year, but may be different for different years.  The number of days in each year must be divisible by the number of days per month in this year. This rule ensures that the number of months in each year is an integer.  The number of days per month for each year must be chosen so as to save the maximum amount of paper to print the calendars. In other words, the number of days per month should be as much as possible. These rules provide an unambiguous method for choosing the number of days in each month for any given year length. For example, according to Palevny's proposition, a year that consists of 108 days will have three months, 36 days each. The year that consists of 99 days will have 11 months, 9 days each, and a year of 365 days will have 365 months, one day each.The proposal provoked heated discussion in the community, the famous mathematician Perelmanov quickly calculated that if the proposal is supported, then in a period of n years, beginning with the year that has a days, the country will spend p sheets of paper to print a set of calendars for these years. Perelmanov's calculations take into account the fact that the set will contain one calendar for each year and each month will be printed on a separate sheet.Repeat Perelmanov's achievement and print the required number p. You are given positive integers a and n. Perelmanov warns you that your program should not work longer than four seconds at the maximum test.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['1\\n']}, {'input': '100 10', 'output': ['550\\n']}, {'input': '5000 5000', 'output': ['16668333\\n']}, {'input': '10000 10000', 'output': ['66676667\\n']}, {'input': '9999 1', 'output': ['9999\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 2\\naabb\", \"6 3\\naacaab\"]","prob_desc_input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100) \u2014 the number of baloons and friends. Next line contains string s \u2014 colors of baloons.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Jun 30 16:47:42 2019\n\n@author: avina\n\"\"\"\n\nn,m = map(int, input().split())\ns = input()\nd = []\nw = set(s)\nfor i in w:\n    d.append(s.count(i))\nif max(d) > m:\n    print('NO')\nelse:\n    print('YES')","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Python","code_uid":"502311826264200a481ebbe4cdbe20a3","prob_desc_notes":"NoteIn the first sample Kefa can give 1-st and 3-rd baloon to the first friend, and 2-nd and 4-th to the second.In the second sample Kefa needs to give to all his friends baloons of color a, but one baloon will stay, thats why answer is \u00abNO\u00bb.","prob_desc_output_spec":"Answer to the task \u2014 \u00abYES\u00bb or \u00abNO\u00bb in a single line. You can choose the case (lower or upper) for each letter arbitrary.","prob_desc_output_to":"standard output","prob_desc_description":"One day Kefa found n baloons. For convenience, we denote color of i-th baloon as si \u2014 lowercase letter of the Latin alphabet. Also Kefa has k friends. Friend will be upset, If he get two baloons of the same color. Kefa want to give out all baloons to his friends. Help Kefa to find out, can he give out all his baloons, such that no one of his friens will be upset \u2014 print \u00abYES\u00bb, if he can, and \u00abNO\u00bb, otherwise. Note, that Kefa's friend will not upset, if he doesn't get baloons at all.","length":17,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2\\naabbc', 'output': ['YES\\n']}, {'input': '3 1\\naaa', 'output': ['NO\\n']}, {'input': '7 3\\nabcabcd', 'output': ['YES\\n']}, {'input': '6 2\\naabbcc', 'output': ['YES\\n']}, {'input': '4 1\\nabcd', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\n4 1 7 8 3 8\\n1\"]","prob_desc_input_spec":"The first line of the input contains integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), where n \u2014 the number of students shouted \"Fly, freebie, fly!\" The second line contains n positive integers ti (1\u2009\u2264\u2009ti\u2009\u2264\u20091000). The last line contains integer T (1\u2009\u2264\u2009T\u2009\u2264\u20091000) \u2014 the time interval during which the freebie was near the dormitory.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n, t = input(), [0] * 1002\nfor i in map(int, input().split()): t[i] += 1\nT = int(input()) + 1\nfor i in range(1000): t[i + 1] += t[i]\nprint(max(t[i + T] - t[i] for i in range(-1, 1001 - T)))","prob_desc_sample_outputs":"[\"3\"]","lang_cluster":"Python","code_uid":"a71a01171806a337eb6b0f1c9f3268f4","prob_desc_notes":null,"prob_desc_output_spec":"Print a single integer \u2014 the largest number of people who will pass exam tomorrow because of the freebie visit.","prob_desc_output_to":"standard output","prob_desc_description":"Everyone loves a freebie. Especially students.It is well-known that if in the night before exam a student opens window, opens the student's record-book and shouts loudly three times \"Fly, freebie, fly!\" \u2014 then flown freebie helps him to pass the upcoming exam.In the night before the exam on mathematical analysis n students living in dormitory shouted treasured words. The i-th student made a sacrament at the time ti, where ti is the number of seconds elapsed since the beginning of the night.It is known that the freebie is a capricious and willful lady. That night the freebie was near dormitory only for T seconds. Therefore, if for two students their sacrament times differ for more than T, then the freebie didn't visit at least one of them.Since all students are optimists, they really want to know what is the maximal number of students visited by the freebie can be.","length":5,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 2 3 4 5\\n1', 'output': ['2']}, {'input': '10\\n1 2 3 4 5 6 7 8 9 10\\n5', 'output': ['6']}, {'input': '3\\n1 500 1000\\n499', 'output': ['2']}, {'input': '4\\n1 2 3 4\\n3', 'output': ['4']}, {'input': '2\\n1 1000\\n999', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"60 60 45 55\\n80 80 8 32\", \"60 60 45 55\\n80 60 15 25\", \"50 50 35 45\\n90 50 35 45\"]","prob_desc_input_spec":"The input contains two lines.  Each line has four space-separated integers xi, yi, ri, Ri, that describe the i-th ring; xi and yi are coordinates of the ring's center, ri and Ri are the internal and external radii of the ring correspondingly (\u2009-\u2009100\u2009\u2264\u2009xi,\u2009yi\u2009\u2264\u2009100;\u00a01\u2009\u2264\u2009ri\u2009&lt;\u2009Ri\u2009\u2264\u2009100).  It is guaranteed that the centers of the rings do not coinside.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def is_intersect(r1, r2, R, x1, y1, x2, y2):\n    d = (x1 - x2)**2 + (y1 - y2)**2\n    return d >= (r1 + R)**2 or r1 < r2 and d <= (r2 - r1)**2 or R < r1 and d <= (r1 - R)**2\n\nx1, y1, r1, R1 = map(int, input().split())\nx2, y2, r2, R2 = map(int, input().split())\n\nres1 = is_intersect(r1, r2, R2, x1, y1, x2, y2)\nres2 = is_intersect(R1, r2, R2, x1, y1, x2, y2)\nres3 = is_intersect(r2, r1, R1, x2, y2, x1, y1)\nres4 = is_intersect(R2, r1, R1, x2, y2, x1, y1)\n\nprint(res1 + res2 + res3 + res4)\n","prob_desc_sample_outputs":"[\"1\", \"4\", \"0\"]","lang_cluster":"Python","code_uid":"d5ec3e39a7da50bf1ae1f50bd39dbf68","prob_desc_notes":"NoteFigures for test samples are given below. The possible cuts are marked with red dotted line.     ","prob_desc_output_spec":"A single integer \u2014 the number of ways to cut out a circle from the canvas.","prob_desc_output_to":"standard output","prob_desc_description":"A renowned abstract artist Sasha, drawing inspiration from nowhere, decided to paint a picture entitled \"Special Olympics\". He justly thought that, if the regular Olympic games have five rings, then the Special ones will do with exactly two rings just fine.Let us remind you that a ring is a region located between two concentric circles with radii r and R (r\u2009&lt;\u2009R). These radii are called internal and external, respectively. Concentric circles are circles with centers located at the same point.Soon a white canvas, which can be considered as an infinite Cartesian plane, had two perfect rings, painted with solid black paint. As Sasha is very impulsive, the rings could have different radii and sizes, they intersect and overlap with each other in any way. We know only one thing for sure: the centers of the pair of rings are not the same.When Sasha got tired and fell into a deep sleep, a girl called Ilona came into the room and wanted to cut a circle for the sake of good memories. To make the circle beautiful, she decided to cut along the contour.We'll consider a contour to be a continuous closed line through which there is transition from one color to another (see notes for clarification). If the contour takes the form of a circle, then the result will be cutting out a circle, which Iona wants.But the girl's inquisitive mathematical mind does not rest: how many ways are there to cut a circle out of the canvas?","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 10 20\\n30 30 5 15', 'output': ['2']}, {'input': '0 0 10 20\\n20 20 5 15', 'output': ['3']}, {'input': '0 0 10 20\\n10 10 5 15', 'output': ['4']}, {'input': '0 0 10 20\\n0 0 5 15', 'output': ['4']}, {'input': '0 0 10 20\\n-10 -10 5 15', 'output': ['2']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 3 2 3\", \"5 3 100 1\"]","prob_desc_input_spec":"The only line contains four integers $$$k$$$, $$$n$$$, $$$s$$$, $$$p$$$ ($$$1 \\le k, n, s, p \\le 10^4$$$)\u00a0\u2014 the number of people, the number of airplanes each should make, the number of airplanes that can be made using one sheet and the number of sheets in one pack, respectively.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"from math import *\nk, n, s, p = map(int, input().split())\nq = k * ceil(n \/ s)\nw = ceil(q \/ p)\nprint(w)\n","prob_desc_sample_outputs":"[\"4\", \"5\"]","lang_cluster":"Python","code_uid":"a20312e80bf4ce08b5c1c0917d811db1","prob_desc_notes":"NoteIn the first sample they have to buy $$$4$$$ packs of paper: there will be $$$12$$$ sheets in total, and giving $$$2$$$ sheets to each person is enough to suit everyone's needs.In the second sample they have to buy a pack for each person as they can't share sheets.","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the minimum number of packs they should buy.","prob_desc_output_to":"standard output","prob_desc_description":"To make a paper airplane, one has to use a rectangular piece of paper. From a sheet of standard size you can make $$$s$$$ airplanes.A group of $$$k$$$ people decided to make $$$n$$$ airplanes each. They are going to buy several packs of paper, each of them containing $$$p$$$ sheets, and then distribute the sheets between the people. Each person should have enough sheets to make $$$n$$$ airplanes. How many packs should they buy?","length":5,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1 1 1', 'output': ['1']}, {'input': '10 10 1 10', 'output': ['10']}, {'input': '100 100 10 100', 'output': ['100']}, {'input': '1000 1000 100 1000', 'output': ['1000']}, {'input': '10000 10000 1000 10000', 'output': ['10000']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"30 5 20 20 3 5\", \"10 4 100 5 5 1\"]","prob_desc_input_spec":"The single line of the input contains six integers x,\u2009t,\u2009a,\u2009b,\u2009da,\u2009db (0\u2009\u2264\u2009x\u2009\u2264\u2009600;\u00a01\u2009\u2264\u2009t,\u2009a,\u2009b,\u2009da,\u2009db\u2009\u2264\u2009300) \u2014 Valera's result, the contest's duration, the initial cost of the first problem, the initial cost of the second problem, the number of points that the first and the second problem lose per minute, correspondingly. It is guaranteed that at each minute of the contest each problem has a non-negative cost, that is, a\u2009-\u2009i\u00b7da\u2009\u2265\u20090 and b\u2009-\u2009i\u00b7db\u2009\u2265\u20090 for all 0\u2009\u2264\u2009i\u2009\u2264\u2009t\u2009-\u20091.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x,t,a,b,c,d=map(int,input().split())\nR=range(t)\ny=x==0\nfor i in R:\n\tif x==a-c*i or x==b-d*i:y=1\n\tfor j in R:y|=x==a+b-c*i-d*j\nprint(['NO','YES'][y])","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Python","code_uid":"7048c4237a18b1ea7954f8a38f9512c3","prob_desc_notes":"NoteIn the first sample Valera could have acted like this: he could have submitted the first problem at minute 0 and the second problem \u2014 at minute 2. Then the first problem brings him 20 points and the second problem brings him 10 points, that in total gives the required 30 points.","prob_desc_output_spec":"If Valera could have earned exactly x points at a contest, print \"YES\", otherwise print \"NO\" (without the quotes).","prob_desc_output_to":"standard output","prob_desc_description":"A boy Valera registered on site Codeforces as Valera, and wrote his first Codeforces Round #300. He boasted to a friend Arkady about winning as much as x points for his first contest. But Arkady did not believe his friend's words and decided to check whether Valera could have shown such a result.He knows that the contest number 300 was unusual because there were only two problems. The contest lasted for t minutes, the minutes are numbered starting from zero. The first problem had the initial cost of a points, and every minute its cost reduced by da points. The second problem had the initial cost of b points, and every minute this cost reduced by db points. Thus, as soon as the zero minute of the contest is over, the first problem will cost a\u2009-\u2009da points, and the second problem will cost b\u2009-\u2009db points. It is guaranteed that at any moment of the contest each problem has a non-negative cost.Arkady asks you to find out whether Valera could have got exactly x points for this contest. You should assume that Valera could have solved any number of the offered problems. You should also assume that for each problem Valera made no more than one attempt, besides, he could have submitted both problems at the same minute of the contest, starting with minute 0 and ending with minute number t\u2009-\u20091. Please note that Valera can't submit a solution exactly t minutes after the start of the contest or later.","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 1 1 1 1 1', 'output': ['YES']}, {'input': '600 300 300 300 1 1', 'output': ['YES']}, {'input': '300 2 150 150 1 1', 'output': ['YES']}, {'input': '599 300 300 300 1 1', 'output': ['NO']}, {'input': '301 2 150 150 1 1', 'output': ['NO']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"6 4\\n1 2 5 10 15 20\", \"4 10\\n1 3 2 4\", \"6 100\\n1 2 3 4 5 6\"]","prob_desc_input_spec":"First line of the input contains an integer $$$n$$$ ($$$2 \\le n \\le 100$$$) and an integer $$$B$$$ ($$$1 \\le B \\le 100$$$)\u00a0\u2014 the number of elements in the sequence and the number of bitcoins you have. Second line contains $$$n$$$ integers: $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$1 \\le a_i \\le 100$$$)\u00a0\u2014 elements of the sequence, which contains the equal number of even and odd numbers","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n, B = [int(x) for x in input().split()]\narr = [int(x) for x in input().split()]\n\nposs_Splits = []\nps = 0\nptlan = 0\nfor i in range(n - 1):\n    if arr[i] % 2 == 0:\n        ps += 1\n    else:\n        ptlan += 1\n    if ps == ptlan:\n        poss_Splits.append((abs(arr[i] - arr[i + 1]), i))\n\nposs_Splits = sorted(poss_Splits)\ni = 0\nwhile i < len(poss_Splits) and B >= poss_Splits[i][0]:\n    B -= poss_Splits[i][0]\n    i += 1\n\nprint(i)","prob_desc_sample_outputs":"[\"1\", \"0\", \"2\"]","lang_cluster":"Python","code_uid":"66cfcfd8de32080acc1f9e4a13f022a0","prob_desc_notes":"NoteIn the first sample the optimal answer is to split sequence between $$$2$$$ and $$$5$$$. Price of this cut is equal to $$$3$$$ bitcoins.In the second sample it is not possible to make even one cut even with unlimited number of bitcoins.In the third sample the sequence should be cut between $$$2$$$ and $$$3$$$, and between $$$4$$$ and $$$5$$$. The total price of the cuts is $$$1 + 1 = 2$$$ bitcoins.","prob_desc_output_spec":"Print the maximum possible number of cuts which can be made while spending no more than $$$B$$$ bitcoins.","prob_desc_output_to":"standard output","prob_desc_description":"There are a lot of things which could be cut\u00a0\u2014 trees, paper, \"the rope\". In this problem you are going to cut a sequence of integers.There is a sequence of integers, which contains the equal number of even and odd numbers. Given a limited budget, you need to make maximum possible number of cuts such that each resulting segment will have the same number of odd and even integers.Cuts separate a sequence to continuous (contiguous) segments. You may think about each cut as a break between two adjacent elements in a sequence. So after cutting each element belongs to exactly one segment. Say, $$$[4, 1, 2, 3, 4, 5, 4, 4, 5, 5]$$$ $$$\\to$$$ two cuts $$$\\to$$$ $$$[4, 1 | 2, 3, 4, 5 | 4, 4, 5, 5]$$$. On each segment the number of even elements should be equal to the number of odd elements.The cost of the cut between $$$x$$$ and $$$y$$$ numbers is $$$|x - y|$$$ bitcoins. Find the maximum possible number of cuts that can be made while spending no more than $$$B$$$ bitcoins.","length":21,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4 5\\n2 4 1 3', 'output': ['1\\n']}, {'input': '6 10\\n1 3 2 4 5 7', 'output': ['2\\n']}, {'input': '8 15\\n2 4 6 8 1 3 5 7', 'output': ['3\\n']}, {'input': '4 1\\n1 2 3 4', 'output': ['0\\n']}, {'input': '6 100\\n1 2 3 4 5 6', 'output': ['2\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"harry potter\", \"tom riddle\"]","prob_desc_input_spec":"The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. ","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"first_name, last_name = input().split()\nfirst_done = first_name.lower()\nlast_done = last_name.lower()\nlogin = first_name[0]\nfor i in range(1, len(first_name)):\n    if ord(first_done[i]) < ord(last_done[0]):\n        login += first_name[i]\n    else:\n        break\nlogin += last_name[0]\nprint(login)","prob_desc_sample_outputs":"[\"hap\", \"tomr\"]","lang_cluster":"Python","code_uid":"c7a2a21610b7bbd676b6c6db3f6c6cb0","prob_desc_notes":null,"prob_desc_output_spec":"Output a single string\u00a0\u2014 alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.","prob_desc_output_to":"standard output","prob_desc_description":"The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).As a reminder, a prefix of a string s is its substring which occurs at the beginning of s: \"a\", \"ab\", \"abc\" etc. are prefixes of string \"{abcdef}\" but \"b\" and 'bc\" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: \"a\" and \"ab\" are alphabetically earlier than \"ac\" but \"b\" and \"ba\" are alphabetically later than \"ac\".","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': 'harry potter', 'output': ['hap']}, {'input': 'tom riddle', 'output': ['tomr']}, {'input': 'ron weasley', 'output': ['ronw']}, {'input': 'hermione granger', 'output': ['herg']}, {'input': 'draco malfoy', 'output': ['dram']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"7\\nj......\", \"7\\n...feon\", \"7\\n.l.r.o.\"]","prob_desc_input_spec":"First line contains an integer n (6\u2009\u2264\u2009n\u2009\u2264\u20098) \u2013 the length of the string. Next line contains a string consisting of n characters, each of which is either a lower case english letter (indicating a known letter) or a dot character (indicating an empty cell in the crossword).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"import re\ninput()\nprint(next(filter(re.compile(input()[:-3] + '$').match, ['vapor', 'jolt', 'flar', 'esp', 'umbr', 'leaf', 'glac', 'sylv'])) + 'eon')\n","prob_desc_sample_outputs":"[\"jolteon\", \"leafeon\", \"flareon\"]","lang_cluster":"Python","code_uid":"b9336adcd50f1b3edf352a1219c9659b","prob_desc_notes":"NoteHere's a set of names in a form you can paste into your solution:[\"vaporeon\", \"jolteon\", \"flareon\", \"espeon\", \"umbreon\", \"leafeon\", \"glaceon\", \"sylveon\"]{\"vaporeon\", \"jolteon\", \"flareon\", \"espeon\", \"umbreon\", \"leafeon\", \"glaceon\", \"sylveon\"}","prob_desc_output_spec":"Print a name of the pokemon that Eevee can evolve into that matches the pattern in the input. Use lower case letters only to print the name (in particular, do not capitalize the first letter).","prob_desc_output_to":"standard output","prob_desc_description":"You are solving the crossword problem K from IPSC 2014. You solved all the clues except for one: who does Eevee evolve into? You are not very into pokemons, but quick googling helped you find out, that Eevee can evolve into eight different pokemons: Vaporeon, Jolteon, Flareon, Espeon, Umbreon, Leafeon, Glaceon, and Sylveon.You know the length of the word in the crossword, and you already know some letters. Designers of the crossword made sure that the answer is unambiguous, so you can assume that exactly one pokemon out of the 8 that Eevee evolves into fits the length and the letters given. Your task is to find it.","length":3,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '7\\nv......\\n', 'output': ['vaporeon\\n']}, {'input': '6\\n..sp..\\n', 'output': ['espeon\\n']}, {'input': '7\\n..mbr..\\n', 'output': ['umbreon\\n']}, {'input': '7\\n..ac...\\n', 'output': ['glaceon\\n']}, {'input': '7\\nsyl....\\n', 'output': ['sylveon\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"-2 1\", \"2 1\", \"4 3\"]","prob_desc_input_spec":"The first and single line contains two integers x and y \u2014 the coordinates of the hole made in the clock by the ball. Each of the numbers x and y has an absolute value that does not exceed 1000.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x, y = map(int, input().split())\np = x * x + y * y\nd = int(p ** 0.5)\nif d * d == p: print('black')\nelse:\n    if x * y < 0: print('black' if d % 2 else 'white')\n    else: print('white' if d % 2 else 'black')","prob_desc_sample_outputs":"[\"white\", \"black\", \"black\"]","lang_cluster":"Python","code_uid":"d0988bd7c5fc4587e10a02d6f92f5b8c","prob_desc_notes":null,"prob_desc_output_spec":"Find the required color. All the points between which and the origin of coordinates the distance is integral-value are painted black.","prob_desc_output_to":"standard output","prob_desc_description":"Not so long ago as a result of combat operations the main Berland place of interest \u2014 the magic clock \u2014 was damaged. The cannon's balls made several holes in the clock, that's why the residents are concerned about the repair. The magic clock can be represented as an infinite Cartesian plane, where the origin corresponds to the clock center. The clock was painted two colors as is shown in the picture:  The picture shows only the central part of the clock. This coloring naturally extends to infinity.The balls can be taken to be points on the plane. Your task is to find the color of the area, damaged by the given ball.All the points located on the border of one of the areas have to be considered painted black.","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0', 'output': ['black\\n']}, {'input': '1 1', 'output': ['white\\n']}, {'input': '-1 -1', 'output': ['white\\n']}, {'input': '1 -1', 'output': ['black\\n']}, {'input': '-1 1', 'output': ['black\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"78 87\", \"1 1\"]","prob_desc_input_spec":"The first letter contains two space-separated numbers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u20091000) which represent the given summands.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a, b = input().split()\nx = int(max(a + b)) + 1\ns, v = int(a, x) + int(b, x), 0\nwhile s:\n    s, v = s \/\/ x, v + 1\nprint(v)","prob_desc_sample_outputs":"[\"3\", \"2\"]","lang_cluster":"Python","code_uid":"015ea30b7d0e1b1543b3e8ccc2c19604","prob_desc_notes":null,"prob_desc_output_spec":"Print a single number \u2014 the length of the longest answer.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya studies positional numeral systems. Unfortunately, he often forgets to write the base of notation in which the expression is written. Once he saw a note in his notebook saying a\u2009+\u2009b\u2009=\u2009?, and that the base of the positional notation wasn\u2019t written anywhere. Now Vasya has to choose a base p and regard the expression as written in the base p positional notation. Vasya understood that he can get different results with different bases, and some bases are even invalid. For example, expression 78\u2009+\u200987 in the base 16 positional notation is equal to FF16, in the base 15 positional notation it is equal to 11015, in the base 10 one \u2014 to 16510, in the base 9 one \u2014 to 1769, and in the base 8 or lesser-based positional notations the expression is invalid as all the numbers should be strictly less than the positional notation base. Vasya got interested in what is the length of the longest possible expression value. Help him to find this length.The length of a number should be understood as the number of numeric characters in it. For example, the length of the longest answer for 78\u2009+\u200987\u2009=\u2009? is 3. It is calculated like that in the base 15 (11015), base 10 (16510), base 9 (1769) positional notations, for example, and in some other ones.","length":6,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '100 200', 'output': ['4']}, {'input': '999 1', 'output': ['4']}, {'input': '500 500', 'output': ['4']}, {'input': '123 456', 'output': ['4']}, {'input': '789 321', 'output': ['4']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1500.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n1 1 0 1\", \"6\\n0 1 0 0 1 0\", \"1\\n0\"]","prob_desc_input_spec":"The first line contains one integer number n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). The second line contains n space-separated integer numbers s1,\u2009s2,\u2009...,\u2009sn (0\u2009\u2264\u2009si\u2009\u2264\u20091). 0 corresponds to an unsuccessful game, 1 \u2014 to a successful one.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n = int(input())\nt = -1\nan = 0\na = list(map(int, input().split()))\nwhile a.count(1):\n    an = max(a.index(1) + a.count(1), an)\n    del a[a.index(1)]\n    \nprint(max(an, len(a)))\n","prob_desc_sample_outputs":"[\"3\", \"4\", \"1\"]","lang_cluster":"Python","code_uid":"d22f3f53434188ee8982353ac8c5f44b","prob_desc_notes":null,"prob_desc_output_spec":"Print one integer \u2014 the maximum number of games Hideo can leave in his CV so that no unsuccessful game comes after a successful one.","prob_desc_output_to":"standard output","prob_desc_description":"Hideo Kojima has just quit his job at Konami. Now he is going to find a new place to work. Despite being such a well-known person, he still needs a CV to apply for a job.During all his career Hideo has produced n games. Some of them were successful, some were not. Hideo wants to remove several of them (possibly zero) from his CV to make a better impression on employers. As a result there should be no unsuccessful game which comes right after successful one in his CV.More formally, you are given an array s1,\u2009s2,\u2009...,\u2009sn of zeros and ones. Zero corresponds to an unsuccessful game, one \u2014 to a successful one. Games are given in order they were produced, and Hideo can't swap these values. He should remove some elements from this array in such a way that no zero comes right after one.Besides that, Hideo still wants to mention as much games in his CV as possible. Help this genius of a man determine the maximum number of games he can leave in his CV.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n1 0 1 0 1', 'output': ['4']}, {'input': '7\\n1 1 1 0 0 0 0', 'output': ['3']}, {'input': '10\\n0 0 0 0 0 1 1 1 1 1', 'output': ['5']}, {'input': '3\\n1 0 1', 'output': ['2']}, {'input': '2\\n0 1', 'output': ['1']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 1\", \"2 3\", \"7 3\"]","prob_desc_input_spec":"The single line of the input contains two positive integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of red and blue socks that Vasya's got.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a, b = map(int, input().split())\nk = 0\nk2 = 0\nwhile a > 0 and b > 0:\n    a -= 1\n    b -= 1\n    k += 1\nif a > 0:\n        k2 = int(a\/\/2)\nelif b > 0:\n        k2 = int(b\/\/2)\nprint(k, k2)","prob_desc_sample_outputs":"[\"1 1\", \"2 0\", \"3 2\"]","lang_cluster":"Python","code_uid":"1238f451970ae68c785036cde7ad10a5","prob_desc_notes":"NoteIn the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.","prob_desc_output_spec":"Print two space-separated integers \u2014 the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got. Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","prob_desc_output_to":"standard output","prob_desc_description":"One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Can you help him?","length":12,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5', 'output': ['5 0']}, {'input': '10 7', 'output': ['7 1']}, {'input': '1 1', 'output': ['1 0']}, {'input': '20 15', 'output': ['15 2']}, {'input': '100 50', 'output': ['50 25']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"4 3 9\", \"4 3 24\", \"2 4 4\"]","prob_desc_input_spec":"The only line contains three integers n, m and k (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200910\u2009000, 1\u2009\u2264\u2009k\u2009\u2264\u20092nm)\u00a0\u2014 the number of lanes, the number of desks in each lane and the number of Santa Claus' place.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n, m, k = map(int, input().split())\nl = (k - 1) \/\/ (2 * m) + 1\n\nprint(l, ((k - 1) % (2 * m))  \/\/ 2 + 1, 'L' if k & 1 else 'R')","prob_desc_sample_outputs":"[\"2 2 L\", \"4 3 R\", \"1 2 R\"]","lang_cluster":"Python","code_uid":"d86339ab1fa6be9a6f63934126cb589d","prob_desc_notes":"NoteThe first and the second samples are shown on the picture. The green place corresponds to Santa Claus' place in the first example, the blue place corresponds to Santa Claus' place in the second example.In the third sample there are two lanes with four desks in each, and Santa Claus has the fourth place. Thus, his place is in the first lane at the second desk on the right.","prob_desc_output_spec":"Print two integers: the number of lane r, the number of desk d, and a character s, which stands for the side of the desk Santa Claus. The character s should be \"L\", if Santa Clause should sit on the left, and \"R\" if his place is on the right.","prob_desc_output_to":"standard output","prob_desc_description":"Santa Claus is the first who came to the Christmas Olympiad, and he is going to be the first to take his place at a desk! In the classroom there are n lanes of m desks each, and there are two working places at each of the desks. The lanes are numbered from 1 to n from the left to the right, the desks in a lane are numbered from 1 to m starting from the blackboard. Note that the lanes go perpendicularly to the blackboard, not along it (see picture).The organizers numbered all the working places from 1 to 2nm. The places are numbered by lanes (i.\u00a0e. all the places of the first lane go first, then all the places of the second lane, and so on), in a lane the places are numbered starting from the nearest to the blackboard (i.\u00a0e. from the first desk in the lane), at each desk, the place on the left is numbered before the place on the right.    The picture illustrates the first and the second samples. Santa Clause knows that his place has number k. Help him to determine at which lane at which desk he should sit, and whether his place is on the left or on the right!","length":4,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 5', 'output': ['1 3 L']}, {'input': '10 10 100', 'output': ['5 10 R']}, {'input': '1 1 1', 'output': ['1 1 L']}, {'input': '10000 10000 200000000', 'output': ['10000 10000 R']}, {'input': '3 7 21', 'output': ['2 1 L']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1400.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"5\"]","prob_desc_input_spec":"The only line of the input contains one integer n (5\u2009\u2264\u2009n\u2009\u2264\u2009100) \u2014 the number of east to west paths and north to south paths.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n = int(input())\nprint(((n*(n-1)*(n-2)*(n-3)*(n-4))**2)\/\/120)","prob_desc_sample_outputs":"[\"120\"]","lang_cluster":"Python","code_uid":"59818fd9dcb02014b1f1ecbc70fab20e","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer \u2014 the number of ways to place the benches.","prob_desc_output_to":"standard output","prob_desc_description":"The city park of IT City contains n east to west paths and n north to south paths. Each east to west path crosses each north to south path, so there are n2 intersections.The city funded purchase of five benches. To make it seems that there are many benches it was decided to place them on as many paths as possible. Obviously this requirement is satisfied by the following scheme: each bench is placed on a cross of paths and each path contains not more than one bench.Help the park administration count the number of ways to place the benches.","length":2,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '6', 'output': ['360']}, {'input': '7', 'output': ['840']}, {'input': '8', 'output': ['1680']}, {'input': '9', 'output': ['3024']}, {'input': '10', 'output': ['5040']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2\", \"2 1\\n1 0\\n2 2\\n3 1\"]","prob_desc_input_spec":"The first line contains two space-separated integers R,\u2009B(1\u2009\u2264\u2009R,\u2009B\u2009\u2264\u200910). For 1\u2009\u2264\u2009i\u2009\u2264\u2009R, the i\u2009+\u20091-th line contains two space-separated integers xi and yi (|xi|,\u2009|yi|\u2009\u2264\u200910000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n,m=[int(x) for x in input().split()]\nfor i in range(n+m):\n    s=input()\nif n==m:\n    print('Yes')\nelse:\n    print('No')","prob_desc_sample_outputs":"[\"Yes\", \"No\"]","lang_cluster":"Python","code_uid":"3d0b2703ee180f2eee303e4da431396b","prob_desc_notes":"NoteFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.","prob_desc_output_spec":"If it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).","prob_desc_output_to":"standard output","prob_desc_description":"The Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths \u2013 from a base to its assigned spaceship \u2013 do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2\\n1 1\\n2 2\\n3 3\\n4 4', 'output': ['Yes']}, {'input': '3 2\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5', 'output': ['No']}, {'input': '1 1\\n0 0\\n1 1', 'output': ['Yes']}, {'input': '4 4\\n-1 -1\\n-2 -2\\n-3 -3\\n-4 -4\\n-5 -5\\n-6 -6\\n-7 -7\\n-8 -8', 'output': ['Yes']}, {'input': '5 3\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n8 8', 'output': ['No']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 2 2\", \"5 1 5\"]","prob_desc_input_spec":"The only input line contains three integers $$$n$$$, $$$l$$$ and $$$r$$$ ($$$1 \\leq n \\leq 1\\,000$$$, $$$1 \\leq l \\leq r \\leq \\min(n, 20)$$$)\u00a0\u2014 an array's size, the minimal number and the maximal number of distinct elements in an array.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n,l,r=map(int,input().split())\nm=n\na=1\nx=0\nA=[]\nB=[]\nwhile n>0:\n    if l==1:\n        A.append(1)\n        n-=1\n    else:\n        A.append(2**(l-1))\n        l-=1\n        n-=1\nwhile x<m:\n    if a==r:\n        B.append(2**(a-1))\n        x+=1\n    else:\n        B.append(2**(a-1))\n        x+=1\n        a+=1\nprint(sum(A),sum(B))\n        \n    \n    \n    \n","prob_desc_sample_outputs":"[\"5 7\", \"5 31\"]","lang_cluster":"Python","code_uid":"0dff3782c421099f55a098c99f27387c","prob_desc_notes":"NoteIn the first example, an array could be the one of the following: $$$[1,1,1,2]$$$, $$$[1,1,2,2]$$$ or $$$[1,2,2,2]$$$. In the first case the minimal sum is reached and in the last case the maximal sum is reached.In the second example, the minimal sum is reached at the array $$$[1,1,1,1,1]$$$, and the maximal one is reached at the array $$$[1,2,4,8,16]$$$.","prob_desc_output_spec":"Output two numbers\u00a0\u2014 the minimal and the maximal possible sums of all elements in an array.","prob_desc_output_to":"standard output","prob_desc_description":"Mislove had an array $$$a_1$$$, $$$a_2$$$, $$$\\cdots$$$, $$$a_n$$$ of $$$n$$$ positive integers, but he has lost it. He only remembers the following facts about it: The number of different numbers in the array is not less than $$$l$$$ and is not greater than $$$r$$$; For each array's element $$$a_i$$$ either $$$a_i = 1$$$ or $$$a_i$$$ is even and there is a number $$$\\dfrac{a_i}{2}$$$ in the array.For example, if $$$n=5$$$, $$$l=2$$$, $$$r=3$$$ then an array could be $$$[1,2,2,4,4]$$$ or $$$[1,1,1,1,2]$$$; but it couldn't be $$$[1,2,2,4,8]$$$ because this array contains $$$4$$$ different numbers; it couldn't be $$$[1,2,2,3,3]$$$ because $$$3$$$ is odd and isn't equal to $$$1$$$; and it couldn't be $$$[1,1,2,2,16]$$$ because there is a number $$$16$$$ in the array but there isn't a number $$$\\frac{16}{2} = 8$$$.According to these facts, he is asking you to count the minimal and the maximal possible sums of all elements in an array. ","length":27,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 1 1', 'output': ['10 10\\n']}, {'input': '7 2 3', 'output': ['7 15\\n']}, {'input': '6 3 4', 'output': ['14 31\\n']}, {'input': '8 1 5', 'output': ['8 63\\n']}, {'input': '9 2 2', 'output': ['10 18\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 2\\n5 8\", \"1 2\\n7 1\", \"1 2\\n4 4\", \"1 4\\n2 2 1 2\"]","prob_desc_input_spec":"The first line contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u200910000, 1\u2009\u2264\u2009k\u2009\u2264\u2009100)\u00a0\u2014 the number of rows and the number of groups of soldiers, respectively. The second line contains k integers a1,\u2009a2,\u2009a3,\u2009...,\u2009ak (1\u2009\u2264\u2009ai\u2009\u2264\u200910000), where ai denotes the number of soldiers in the i-th group. It is guaranteed that a1\u2009+\u2009a2\u2009+\u2009...\u2009+\u2009ak\u2009\u2264\u20098\u00b7n.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n,k = map(int, input().split())\n\na = list(map(int,input().split()))\nall_sum = sum(a)\nr4,r2 = n,n*2\nfor v in range(len(a)):\n\tmid = a[v] \/\/ 4\n\ta[v] = a[v] % 4\n\tif mid <= r4:\n\t\tr4 -= mid\n\telse:\n\t\ta[v] += 4 * (mid - r4)\n\t\tr4 = 0\n\tif r4 == 0:\n\t\tbreak\nmid = 0\nr22 = 0\nfor v in a:\n\tif v % 2 == 1:\n\t\tmid += 1\n\tr22 += v \/\/ 2\n#print(r4,r22,mid,r2)\nif r4 > 0:\n\tmid -=r4\n\tr22 -= r4\n\tif mid < 0:\n\t\tr22 -= (mid \/\/ -2)\n\t\tmid = 0\n\nif r22 + mid > r2:\n\tprint('NO')\nelse:\n\tprint('YES')\n\n\n\n\n\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\", \"YES\"]","lang_cluster":"Python","code_uid":"cc232d8bd2224b6b72afb51d11f41cfa","prob_desc_notes":"NoteIn the first sample, Daenerys can place the soldiers like in the figure below:  In the second sample, there is no way to place the soldiers in the plane since the second group soldier will always have a seat neighboring to someone from the first group.In the third example Daenerys can place the first group on seats (1,\u20092,\u20097,\u20098), and the second group an all the remaining seats.In the fourth example she can place the first two groups on seats (1,\u20092) and (7,\u20098), the third group on seats (3), and the fourth group on seats (5,\u20096).","prob_desc_output_spec":"If we can place the soldiers in the airplane print \"YES\" (without quotes). Otherwise print \"NO\" (without quotes). You can choose the case (lower or upper) for each letter arbitrary.","prob_desc_output_to":"standard output","prob_desc_description":"Daenerys Targaryen has an army consisting of k groups of soldiers, the i-th group contains ai soldiers. She wants to bring her army to the other side of the sea to get the Iron Throne. She has recently bought an airplane to carry her army through the sea. The airplane has n rows, each of them has 8 seats. We call two seats neighbor, if they are in the same row and in seats {1,\u20092}, {3,\u20094}, {4,\u20095}, {5,\u20096} or {7,\u20098}.  A row in the airplane Daenerys Targaryen wants to place her army in the plane so that there are no two soldiers from different groups sitting on neighboring seats.Your task is to determine if there is a possible arranging of her army in the airplane such that the condition above is satisfied.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 3\\n6 6 6', 'output': ['YES\\n']}, {'input': '2 2\\n4 5', 'output': ['YES\\n']}, {'input': '4 4\\n4 4 4 4', 'output': ['YES\\n']}, {'input': '1 1\\n8', 'output': ['YES\\n']}, {'input': '3 3\\n10 2 2', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 1 2 1 2\", \"3 3 1 1 1\", \"4 5 3 1 5\"]","prob_desc_input_spec":"The first line contains five integers s, v1, v2, t1, t2 (1\u2009\u2264\u2009s,\u2009v1,\u2009v2,\u2009t1,\u2009t2\u2009\u2264\u20091000)\u00a0\u2014 the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"\ndef t(a,b,c,d,e):\n    #for i in range(5):\n      #  v.append (int(input(\"podaj liczbe\")))\n\n        \n    gr1=0\n    gr2=0\n\n    gr1=(b*a)+(d*2)\n    gr2=(c*a)+(e*2)\n    #print(gr1)\n    #print(gr2)\n    if gr1>gr2:\n        print(\"Second\")\n    if gr1<gr2:\n        print(\"First\")\n    if gr1==gr2:\n        print(\"Friendship\")\n\na,b,c,d,e = input().split(\" \")\nt(int(a),int(b),int(c),int(d),int(e))","prob_desc_sample_outputs":"[\"First\", \"Second\", \"Friendship\"]","lang_cluster":"Python","code_uid":"6f9436a329d5d3a638fb45e8375716e7","prob_desc_notes":"NoteIn the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant\u00a0\u2014 in 14 milliseconds. So, the first wins.In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant\u00a0\u2014 in 5 milliseconds. So, the second wins.In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant\u00a0\u2014 in 22 milliseconds. So, it is be a draw.","prob_desc_output_spec":"If the first participant wins, print \"First\". If the second participant wins, print \"Second\". In case of a draw print \"Friendship\".","prob_desc_output_to":"standard output","prob_desc_description":"Two boys decided to compete in text typing on the site \"Key races\". During the competition, they have to type a text consisting of s characters. The first participant types one character in v1 milliseconds and has ping t1 milliseconds. The second participant types one character in v2 milliseconds and has ping t2 milliseconds.If connection ping (delay) is t milliseconds, the competition passes for a participant as follows:   Exactly after t milliseconds after the start of the competition the participant receives the text to be entered.  Right after that he starts to type it.  Exactly t milliseconds after he ends typing all the text, the site receives information about it. The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.Given the length of the text and the information about participants, determine the result of the game.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5 3 2 1', 'output': ['Second\\n']}, {'input': '7 2 4 1 2', 'output': ['First\\n']}, {'input': '6 3 3 2 2', 'output': ['Friendship\\n']}, {'input': '8 4 2 1 3', 'output': ['Second\\n']}, {'input': '9 3 5 2 1', 'output': ['First\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"0 1 1 1 1 0\", \"1 1 0 0 1000 1000\"]","prob_desc_input_spec":"The only line contains six integers ax,\u2009ay,\u2009bx,\u2009by,\u2009cx,\u2009cy (|ax|,\u2009|ay|,\u2009|bx|,\u2009|by|,\u2009|cx|,\u2009|cy|\u2009\u2264\u2009109). It's guaranteed that the points are distinct.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"ax,ay,bx,by,cx,cy=list(map(int,input().split()))\nax-=bx\nay-=by\ncx-=bx\ncy-=by\nprint('No'if ax*cy-ay*cx==0 or ax**2+ay**2!=cx**2+cy**2 else'Yes')\n","prob_desc_sample_outputs":"[\"Yes\", \"No\"]","lang_cluster":"Python","code_uid":"25fa9c110cf15920ffad234fdbbdd06b","prob_desc_notes":"NoteIn the first sample test, rotate the page around (0.5,\u20090.5) by .In the second sample test, you can't find any solution.","prob_desc_output_spec":"Print \"Yes\" if the problem has a solution, \"No\" otherwise. You can print each letter in any case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"Arpa is taking a geometry exam. Here is the last problem of the exam.You are given three points a,\u2009b,\u2009c.Find a point and an angle such that if we rotate the page around the point by the angle, the new position of a is the same as the old position of b, and the new position of b is the same as the old position of c.Arpa is doubting if the problem has a solution or not (i.e. if there exists a point and an angle satisfying the condition). Help Arpa determine if the question has a solution or not.","length":6,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 1 1 2 2', 'output': ['No\\n']}, {'input': '0 0 1 0 2 0', 'output': ['Yes\\n']}, {'input': '0 0 0 1 0 2', 'output': ['Yes\\n']}, {'input': '0 0 1 1 3 3', 'output': ['No\\n']}, {'input': '0 0 2 2 4 4', 'output': ['No\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 1\\n2 1 4\", \"3 0\\n7 7 7\", \"6 3\\n1 3 4 6 9 10\"]","prob_desc_input_spec":"The first line contains two integers n and d (1\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20090\u2009\u2264\u2009d\u2009\u2264\u2009100)\u00a0\u2014 the amount of points and the maximum allowed diameter respectively. The second line contains n space separated integers (1\u2009\u2264\u2009xi\u2009\u2264\u2009100)\u00a0\u2014 the coordinates of the points.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x=input()\nx=x.split(' ')\nn=int(x[0])\nd=int(x[1])\nx=input()\nx=x.split(' ')\nfor i in range(n):\n    x[i]=int(x[i])\nx.sort()\nl = []\nfor i in range(0, n):\n    for j in range(i+1, n):\n        if (x[j]-x[i])<=d:\n            l.append(i + (n - j) - 1)\nif l == []:\n    print(n-1)\nelse:\n     print(min(l))\n","prob_desc_sample_outputs":"[\"1\", \"0\", \"3\"]","lang_cluster":"Python","code_uid":"20c768b19dd414a5b3f4e10cbe7b2a4e","prob_desc_notes":"NoteIn the first test case the optimal strategy is to remove the point with coordinate 4. The remaining points will have coordinates 1 and 2, so the diameter will be equal to 2\u2009-\u20091\u2009=\u20091.In the second test case the diameter is equal to 0, so its is unnecessary to remove any points. In the third test case the optimal strategy is to remove points with coordinates 1, 9 and 10. The remaining points will have coordinates 3, 4 and 6, so the diameter will be equal to 6\u2009-\u20093\u2009=\u20093.","prob_desc_output_spec":"Output a single integer\u00a0\u2014 the minimum number of points you have to remove.","prob_desc_output_to":"standard output","prob_desc_description":"We've got no test cases. A big olympiad is coming up. But the problemsetters' number one priority should be adding another problem to the round. The diameter of a multiset of points on the line is the largest distance between two points from this set. For example, the diameter of the multiset {1,\u20093,\u20092,\u20091} is 2.Diameter of multiset consisting of one point is 0.You are given n points on the line. What is the minimum number of points you have to remove, so that the diameter of the multiset of the remaining points will not exceed d?","length":18,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2\\n1 3 5 7 9', 'output': ['2']}, {'input': '4 0\\n4 4 4 4', 'output': ['0']}, {'input': '7 5\\n1 2 3 4 5 6 7', 'output': ['2']}, {'input': '6 3\\n1 2 3 4 5 6', 'output': ['2']}, {'input': '8 4\\n1 2 3 4 5 6 7 8', 'output': ['3']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 10 3 3\", \"3 10 1 3\", \"100 100 1 1000\"]","prob_desc_input_spec":"The first line contains four space-separated integers k, a, b, v (2\u2009\u2264\u2009k\u2009\u2264\u20091000; 1\u2009\u2264\u2009a,\u2009b,\u2009v\u2009\u2264\u20091000) \u2014 the maximum number of sections in the box, the number of nuts, the number of divisors and the capacity of each section of the box.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"k,a,b,v = map(int, input().split())\nansw = 0\nwhile a != 0 and b != 0:\n    a -= min(v*min(k,b+1),a)\n    b -= min(k-1,b)\n    answ+=1\nansw += a\/\/v + int(a%v != 0)\nprint(answ)","prob_desc_sample_outputs":"[\"2\", \"3\", \"1\"]","lang_cluster":"Python","code_uid":"55bb7e5a85fa02f0c1918825bb463f23","prob_desc_notes":"NoteIn the first sample you can act like this:   Put two divisors to the first box. Now the first box has three sections and we can put three nuts into each section. Overall, the first box will have nine nuts.  Do not put any divisors into the second box. Thus, the second box has one section for the last nut. In the end we've put all the ten nuts into boxes.The second sample is different as we have exactly one divisor and we put it to the first box. The next two boxes will have one section each.","prob_desc_output_spec":"Print a single integer \u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"You have a nuts and lots of boxes. The boxes have a wonderful feature: if you put x (x\u2009\u2265\u20090) divisors (the spacial bars that can divide a box) to it, you get a box, divided into x\u2009+\u20091 sections.You are minimalist. Therefore, on the one hand, you are against dividing some box into more than k sections. On the other hand, you are against putting more than v nuts into some section of the box. What is the minimum number of boxes you have to use if you want to put all the nuts in boxes, and you have b divisors?Please note that you need to minimize the number of used boxes, not sections. You do not have to minimize the number of used divisors.","length":8,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 5 2 2', 'output': ['2']}, {'input': '4 20 5 4', 'output': ['3']}, {'input': '3 15 4 3', 'output': ['3']}, {'input': '5 25 6 5', 'output': ['3']}, {'input': '6 30 7 6', 'output': ['3']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"01.01.98\\n01.01.80\", \"20.10.20\\n10.02.30\", \"28.02.74\\n28.02.64\"]","prob_desc_input_spec":"The first line contains the date DD.MM.YY, the second line contains the date BD.BM.BY. It is guaranteed that both dates are correct, and YY and BY are always in [01;99]. It could be that by passport Bob was born after the finals. In this case, he can still change the order of numbers in date.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"import itertools as it\n\nmonth_to_days_non_leap = {\n    1: 31,\n    2: 28,\n    3: 31,\n    4: 30,\n    5: 31,\n    6: 30,\n    7: 31,\n    8: 31,\n    9: 30,\n    10: 31,\n    11: 30,\n    12: 31,\n}\n\ndef month_year_to_day(month, year):\n    if year % 4 == 0 and month == 2:\n        return 29\n    else:\n        return month_to_days_non_leap[month]\n\ndef good_date(day, month, year):\n    if month > 12: return False\n    if day > month_year_to_day(month, year): return False\n    return True\n\ndd, mm, yy = map(int, input().split('.'))\nbd, bm, by = map(int, input().split('.'))\n\nfound_sol = False\n\nfor p_bd, p_bm, p_by in it.permutations([bd, bm, by]):\n    if good_date(p_bd, p_bm, p_by):\n        year_diff = yy - p_by\n        if year_diff > 18:\n            found_sol = True\n            break\n        elif year_diff < 18:\n            continue\n        if p_bm < mm:\n            found_sol = True\n            break\n        elif p_bm > mm:\n            continue\n        if p_bd < dd:\n            found_sol = True\n            break\n        elif p_bd > dd:\n            continue\n        found_sol = True\n        break\n\nif found_sol:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"NO\"]","lang_cluster":"Python","code_uid":"b8d79caf394704bc5d1fb0d994266b22","prob_desc_notes":null,"prob_desc_output_spec":"If it is possible to rearrange the numbers in the date of birth so that Bob will be at least 18 years old on the DD.MM.YY, output YES. In the other case, output NO.  Each number contains exactly two digits and stands for day, month or year in a date. Note that it is permitted to rearrange only numbers, not digits.","prob_desc_output_to":"standard output","prob_desc_description":"The king Copa often has been reported about the Codeforces site, which is rapidly getting more and more popular among the brightest minds of the humanity, who are using it for training and competing. Recently Copa understood that to conquer the world he needs to organize the world Codeforces tournament. He hopes that after it the brightest minds will become his subordinates, and the toughest part of conquering the world will be completed.The final round of the Codeforces World Finals 20YY is scheduled for DD.MM.YY, where DD is the day of the round, MM is the month and YY are the last two digits of the year. Bob is lucky to be the first finalist form Berland. But there is one problem: according to the rules of the competition, all participants must be at least 18 years old at the moment of the finals. Bob was born on BD.BM.BY. This date is recorded in his passport, the copy of which he has already mailed to the organizers. But Bob learned that in different countries the way, in which the dates are written, differs. For example, in the US the month is written first, then the day and finally the year. Bob wonders if it is possible to rearrange the numbers in his date of birth so that he will be at least 18 years old on the day DD.MM.YY. He can always tell that in his motherland dates are written differently. Help him.According to another strange rule, eligible participant must be born in the same century as the date of the finals. If the day of the finals is participant's 18-th birthday, he is allowed to participate. As we are considering only the years from 2001 to 2099 for the year of the finals, use the following rule: the year is leap if it's number is divisible by four.","length":58,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '01.01.01\\n01.01.01', 'output': ['NO\\n']}, {'input': '01.01.20\\n01.01.02', 'output': ['YES\\n']}, {'input': '29.02.20\\n29.02.02', 'output': ['YES\\n']}, {'input': '31.12.20\\n31.12.02', 'output': ['YES\\n']}, {'input': '31.12.20\\n12.31.02', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"2\\nRB\", \"3\\nGRG\", \"5\\nBBBBB\"]","prob_desc_input_spec":"The first line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009200)\u00a0\u2014 the total number of cards. The next line contains a string s of length n \u2014 the colors of the cards. s contains only the characters 'B', 'G', and 'R', representing blue, green, and red, respectively.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"from collections import Counter\n\ndef go(s):\n    ct = Counter(s)\n    pos = ''.join(c for c in 'BGR' if ct[c] > 0)\n    if len(pos) == 3 or len(pos) == 1:\n        return pos\n    \n    one = ''.join(c for c in 'BGR' if ct[c] <= 1)\n    \n    if len(one) == 1:\n        return 'BGR'\n    if len(one) == 2:\n        return one\n   \n    return ''.join(c for c in 'BGR' if ct[c] == 0)\n\ninput()\nprint(go(input()))\n","prob_desc_sample_outputs":"[\"G\", \"BR\", \"B\"]","lang_cluster":"Python","code_uid":"ffcf12e402bef8d171f551c12e5bc85e","prob_desc_notes":"NoteIn the first sample, Catherine has one red card and one blue card, which she must exchange for a green card.In the second sample, Catherine has two green cards and one red card. She has two options: she can exchange the two green cards for a green card, then exchange the new green card and the red card for a blue card. Alternatively, she can exchange a green and a red card for a blue card, then exchange the blue card and remaining green card for a red card.In the third sample, Catherine only has blue cards, so she can only exchange them for more blue cards.","prob_desc_output_spec":"Print a single string of up to three characters\u00a0\u2014 the possible colors of the final card (using the same symbols as the input) in alphabetical order.","prob_desc_output_to":"standard output","prob_desc_description":"Catherine has a deck of n cards, each of which is either red, green, or blue. As long as there are at least two cards left, she can do one of two actions:   take any two (not necessarily adjacent) cards with different colors and exchange them for a new card of the third color;  take any two (not necessarily adjacent) cards with the same color and exchange them for a new card with that color. She repeats this process until there is only one card left. What are the possible colors for the final card?","length":19,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\nRRBB', 'output': ['G\\n']}, {'input': '6\\nRRGGBB', 'output': ['BGR\\n']}, {'input': '3\\nRRR', 'output': ['R\\n']}, {'input': '5\\nGGGGB', 'output': ['BR\\n']}, {'input': '7\\nBBBGGRR', 'output': ['BGR\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 3 3\\n1 1 1\\n2 2 3\\n3 3 2\", \"4 10 2\\n2 3 8\\n3 4 7\"]","prob_desc_input_spec":"The first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$)\u00a0\u2014 the number of spots, the maximum height, and the number of restrictions. Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$)\u00a0\u2014 left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"(n,h,m) = [int(x) for x in input().split()]\nhouses= [h]*n\nfor i in range(m):\n    (l,r,x) = [int(x) for x in input().split()]\n    for j in range(l-1,r):\n        houses[j] = min(houses[j],x)\n\nmx = 0\nfor j in range(n):\n    mx += houses[j]*houses[j]\n\nprint(mx)\n    ","prob_desc_sample_outputs":"[\"14\", \"262\"]","lang_cluster":"Python","code_uid":"7b509396aeaeb6bb60154fd40d60ccae","prob_desc_notes":"NoteIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).","prob_desc_output_spec":"Print a single integer, the maximum profit you can make.","prob_desc_output_to":"standard output","prob_desc_description":"You are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.","length":13,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 2\\n1 2 3\\n4 5 2', 'output': ['39\\n']}, {'input': '6 4 3\\n1 2 2\\n3 4 3\\n5 6 1', 'output': ['30\\n']}, {'input': '7 7 1\\n3 5 4', 'output': ['147\\n']}, {'input': '8 6 2\\n2 4 5\\n6 8 3', 'output': ['94\\n']}, {'input': '9 9 3\\n1 3 6\\n4 6 5\\n7 9 4', 'output': ['204\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6 2\\n2 1 2 2 2 1\", \"8 4\\n1 1 2 1 1 1 2 1\", \"9 3\\n2 1 1 1 2 1 1 1 2\"]","prob_desc_input_spec":"The first line of the input contains a pair of integers n, k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009100), where n is the length of the array and the value n is divisible by k. The second line contains the sequence of elements of the given array a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u20092), ai is the i-th element of the array.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a=int(input().split()[1])\n*b,=map(int,input().split())\nc=0\nfor i in range(a):\n    d=b[i::a]\n    c+=min(d.count(1),d.count(2))\nprint(c)\n","prob_desc_sample_outputs":"[\"1\", \"0\", \"3\"]","lang_cluster":"Python","code_uid":"79f48e5b25e6338aeea56182a2dbaebc","prob_desc_notes":"NoteIn the first sample it is enough to change the fourth element from 2 to 1, then the array changes to [2,\u20091,\u20092,\u20091,\u20092,\u20091].In the second sample, the given array already is 4-periodic.In the third sample it is enough to replace each occurrence of number two by number one. In this case the array will look as [1,\u20091,\u20091,\u20091,\u20091,\u20091,\u20091,\u20091,\u20091] \u2014 this array is simultaneously 1-, 3- and 9-periodic.","prob_desc_output_spec":"Print the minimum number of array elements we need to change to make the array k-periodic. If the array already is k-periodic, then print 0.","prob_desc_output_to":"standard output","prob_desc_description":"This task will exclusively concentrate only on the arrays where all elements equal 1 and\/or 2.Array a is k-period if its length is divisible by k and there is such array b of length k, that a is represented by array b written exactly  times consecutively. In other words, array a is k-periodic, if it has period of length k.For example, any array is n-periodic, where n is the array length. Array [2,\u20091,\u20092,\u20091,\u20092,\u20091] is at the same time 2-periodic and 6-periodic and array [1,\u20092,\u20091,\u20091,\u20092,\u20091,\u20091,\u20092,\u20091] is at the same time 3-periodic and 9-periodic.For the given array a, consisting only of numbers one and two, find the minimum number of elements to change to make the array k-periodic. If the array already is k-periodic, then the required value equals 0.","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5\\n1 2 1 2 1 1 2 1 2 1', 'output': ['0']}, {'input': '12 3\\n1 2 2 1 1 2 1 2 2 1 1 2', 'output': ['2']}, {'input': '15 5\\n1 1 2 2 1 1 1 2 2 1 1 1 2 2 1', 'output': ['1']}, {'input': '20 4\\n1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1 1 2 1 1', 'output': ['4']}, {'input': '18 6\\n2 2 1 1 2 2 2 2 1 1 2 2 2 2 1 1 2 2', 'output': ['3']}]"}
{"prob_desc_memory_limit":"512 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5\\n6\\n3\", \"5\\n3\\n5\"]","prob_desc_input_spec":"The first line contains an integer $$$b$$$ ($$$1 \\le b \\le 300$$$), the number of boys.  The second line contains an integer $$$g$$$ ($$$1 \\le g \\le 300$$$), the number of girls.  The third line contains an integer $$$n$$$ ($$$1 \\le n \\le b + g$$$), the number of the board games tournament participants.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"b = int(input())\ng = int(input())\nn = int(input())\n\nminig = min(n,g)\nminib = min(n,b)\nprint(minig - (n-minib) +1)\n\n","prob_desc_sample_outputs":"[\"4\", \"4\"]","lang_cluster":"Python","code_uid":"759fe1bf495cee74e37b43688ae3923a","prob_desc_notes":"NoteIn the first example, each of 4 decks should be taken: (0 blue, 3 red), (1 blue, 2 red), (2 blue, 1 red), (3 blue, 0 red).In the second example, 4 decks should be taken: (2 blue, 3 red), (3 blue, 2 red), (4 blue, 1 red), (5 blue, 0 red). Piles (0 blue, 5 red) and (1 blue, 4 red) can not be used.","prob_desc_output_spec":"Output the only integer, the minimum number of badge decks that Vasya could take.","prob_desc_output_to":"standard output","prob_desc_description":"There are $$$b$$$ boys and $$$g$$$ girls participating in Olympiad of Metropolises. There will be a board games tournament in the evening and $$$n$$$ participants have accepted the invitation. The organizers do not know how many boys and girls are among them.Organizers are preparing red badges for girls and blue ones for boys.Vasya prepared $$$n+1$$$ decks of badges. The $$$i$$$-th (where $$$i$$$ is from $$$0$$$ to $$$n$$$, inclusive) deck contains $$$i$$$ blue badges and $$$n-i$$$ red ones. The total number of badges in any deck is exactly $$$n$$$.Determine the minimum number of decks among these $$$n+1$$$ that Vasya should take, so that there will be a suitable deck no matter how many girls and boys there will be among the participants of the tournament.","length":8,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n10\\n5', 'output': ['6\\n']}, {'input': '300\\n300\\n150', 'output': ['151\\n']}, {'input': '1\\n1\\n1', 'output': ['2\\n']}, {'input': '100\\n200\\n50', 'output': ['51\\n']}, {'input': '200\\n100\\n50', 'output': ['51\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6 2\\n1 0 1 1 1 1\\n2 10\\n4 7\", \"3 3\\n1 0 2\\n2 5\\n2 4\", \"7 16\\n15 15 4 0 0 7 10\\n7 9\\n4 8 0 3 1 5 0\"]","prob_desc_input_spec":"The first line of the input contains two space-separated integers n and bx (1\u2009\u2264\u2009n\u2009\u2264\u200910, 2\u2009\u2264\u2009bx\u2009\u2264\u200940), where n is the number of digits in the bx-based representation of X.  The second line contains n space-separated integers x1,\u2009x2,\u2009...,\u2009xn (0\u2009\u2264\u2009xi\u2009&lt;\u2009bx) \u2014 the digits of X. They are given in the order from the most significant digit to the least significant one. The following two lines describe Y in the same way: the third line contains two space-separated integers m and by (1\u2009\u2264\u2009m\u2009\u2264\u200910, 2\u2009\u2264\u2009by\u2009\u2264\u200940, bx\u2009\u2260\u2009by), where m is the number of digits in the by-based representation of Y, and the fourth line contains m space-separated integers y1,\u2009y2,\u2009...,\u2009ym (0\u2009\u2264\u2009yi\u2009&lt;\u2009by) \u2014 the digits of Y. There will be no leading zeroes. Both X and Y will be positive. All digits of both numbers are given in the standard decimal numeral system.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n, b = map(int, input().split())\ncurr = 1\nc1 = 0\na = [int(i) for i in input().split()]\na = a[::-1]\nfor i in range(n):\n    c1 += a[i] * curr\n    curr *= b\nn, b = map(int, input().split())\ncurr = 1\nc2 = 0\na = [int(i) for i in input().split()]\na = a[::-1]\nfor i in range(n):\n    c2 += a[i] * curr\n    curr *= b\nif (c1 < c2):\n    print('<')\nelif (c1 == c2):\n    print('=')\nelse:\n    print('>')","prob_desc_sample_outputs":"[\"=\", \"&lt;\", \"&gt;\"]","lang_cluster":"Python","code_uid":"db50f777ce979295bb6553388c705acd","prob_desc_notes":"NoteIn the first sample, X\u2009=\u20091011112\u2009=\u20094710\u2009=\u2009Y.In the second sample, X\u2009=\u20091023\u2009=\u2009215 and Y\u2009=\u2009245\u2009=\u20091123, thus X\u2009&lt;\u2009Y.In the third sample,  and Y\u2009=\u200948031509. We may notice that X starts with much larger digits and bx is much larger than by, so X is clearly larger than Y.","prob_desc_output_spec":"Output a single character (quotes for clarity):    '&lt;' if X\u2009&lt;\u2009Y  '&gt;' if X\u2009&gt;\u2009Y  '=' if X\u2009=\u2009Y ","prob_desc_output_to":"standard output","prob_desc_description":"After seeing the \"ALL YOUR BASE ARE BELONG TO US\" meme for the first time, numbers X and Y realised that they have different bases, which complicated their relations.You're given a number X represented in base bx and a number Y represented in base by. Compare those two numbers.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 2\\n1 0 1\\n3 3\\n1 1 1', 'output': ['=']}, {'input': '4 5\\n4 3 2 1\\n4 6\\n1 2 3 4', 'output': ['<']}, {'input': '5 10\\n9 8 7 6 5\\n5 11\\n5 6 7 8 9', 'output': ['>']}, {'input': '2 2\\n1 1\\n2 3\\n1 2', 'output': ['<']}, {'input': '3 4\\n3 2 1\\n3 5\\n1 2 3', 'output': ['>']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1\", \"8\", \"10\"]","prob_desc_input_spec":"The single line of input contains the integer m (1\u2009\u2264\u2009m\u2009\u2264\u20091015)\u00a0\u2014 the number of ways the thieves might steal the chocolates, as rumours say.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"cubes = [i**3.0 for i in range(2, int(1.8e5+5))]\n\ndef valid(mid):\n    return sum([mid\/\/i for i in cubes if i <= mid])\n\ndef binary_search(k):\n    l = int(4.8 * k)\n    r = min(8.0 * k, 5.0 * (10**15))\n    while (l+1 < r):\n        mid = (l+r) \/ 2.0\n        res = valid(mid)\n        if (res < k):\n            l = mid\n        else:\n            r = mid\n    return int(r) if int(valid(r)) == k else -1\n\ndef main():\n    k = int(input())\n    print(binary_search(k))\n\nmain()\n","prob_desc_sample_outputs":"[\"8\", \"54\", \"-1\"]","lang_cluster":"Python","code_uid":"1ea3abdc6ea00928a8332713ef7e09c4","prob_desc_notes":"NoteIn the first sample case the smallest n that leads to exactly one way of stealing chocolates is n\u2009=\u20098, whereas the amounts of stealed chocolates are (1,\u20092,\u20094,\u20098) (the number of chocolates stolen by each of the thieves).In the second sample case the smallest n that leads to exactly 8 ways is n\u2009=\u200954 with the possibilities: (1,\u20092,\u20094,\u20098),\u2009\u2002(1,\u20093,\u20099,\u200927),\u2009\u2002(2,\u20094,\u20098,\u200916),\u2009\u2002(2,\u20096,\u200918,\u200954),\u2009\u2002(3,\u20096,\u200912,\u200924),\u2009\u2002(4,\u20098,\u200916,\u200932),\u2009\u2002(5,\u200910,\u200920,\u200940),\u2009\u2002(6,\u200912,\u200924,\u200948).There is no n leading to exactly 10 ways of stealing chocolates in the third sample case.","prob_desc_output_spec":"Print the only integer n\u00a0\u2014 the maximum amount of chocolates that thieves' bags can carry. If there are more than one n satisfying the rumors, print the smallest one. If there is no such n for a false-rumoured m, print \u2009-\u20091.","prob_desc_output_to":"standard output","prob_desc_description":"Bad news came to Mike's village, some thieves stole a bunch of chocolates from the local factory! Horrible! Aside from loving sweet things, thieves from this area are known to be very greedy. So after a thief takes his number of chocolates for himself, the next thief will take exactly k times more than the previous one. The value of k (k\u2009&gt;\u20091) is a secret integer known only to them. It is also known that each thief's bag can carry at most n chocolates (if they intend to take more, the deal is cancelled) and that there were exactly four thieves involved. Sadly, only the thieves know the value of n, but rumours say that the numbers of ways they could have taken the chocolates (for a fixed n, but not fixed k) is m. Two ways are considered different if one of the thieves (they should be numbered in the order they take chocolates) took different number of chocolates in them.Mike want to track the thieves down, so he wants to know what their bags are and value of n will help him in that. Please find the smallest possible value of n or tell him that the rumors are false and there is no such n.","length":22,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2', 'output': ['16']}, {'input': '3', 'output': ['24']}, {'input': '4', 'output': ['32']}, {'input': '5', 'output': ['40']}, {'input': '6', 'output': ['48']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 2\\n1 3 1 4 2\", \"6 4\\n1 1 2 2 3 3\"]","prob_desc_input_spec":"The first line contains two integers n,\u2009m (1\u2009\u2264\u2009n\u2009\u2264\u2009100;\u00a01\u2009\u2264\u2009m\u2009\u2264\u2009100). The second line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"# http:\/\/codeforces.com\/problemset\/problem\/450\/A\n\nfrom collections import deque\nfrom math import ceil\n# n, m = [int(x) for x in input().split()]\nn, m = map(int, input().split())\ncandies = [int(x) for x in input().split()]\n\nchildren = deque([int(x) for x in range(1, n + 1)])\nhome = []\n\nmax_num = 0\ncounter = 0\ncandies_dict = {}\n\nfor k in candies:\n    counter += 1\n    candies_dict[counter] = k\n\n\nfor i in candies:\n    result = ceil(i \/ m)\n    if result >= max_num:\n        max_num = ceil(i \/ m)\n        max_candies = i\n\n# print(candies_dict)\n# print(max_candies)\n\nmax_keys = []\n\nfor k, v in candies_dict.items():\n    if v == max_candies:\n        max_keys.append(k)\n\nprint(max_keys[-1])\n","prob_desc_sample_outputs":"[\"4\", \"6\"]","lang_cluster":"Python","code_uid":"d915f7b6597e4e4e368d12fccd4f7569","prob_desc_notes":"NoteLet's consider the first sample. Firstly child 1 gets 2 candies and go home. Then child 2 gets 2 candies and go to the end of the line. Currently the line looks like [3, 4, 5, 2] (indices of the children in order of the line). Then child 3 gets 2 candies and go home, and then child 4 gets 2 candies and goes to the end of the line. Currently the line looks like [5, 2, 4]. Then child 5 gets 2 candies and goes home. Then child 2 gets two candies and goes home, and finally child 4 gets 2 candies and goes home.Child 4 is the last one who goes home.","prob_desc_output_spec":"Output a single integer, representing the number of the last child.","prob_desc_output_to":"standard output","prob_desc_description":"There are n children in Jzzhu's school. Jzzhu is going to give some candies to them. Let's number all the children from 1 to n. The i-th child wants to get at least ai candies.Jzzhu asks children to line up. Initially, the i-th child stands at the i-th place of the line. Then Jzzhu start distribution of the candies. He follows the algorithm:  Give m candies to the first child of the line.  If this child still haven't got enough candies, then the child goes to the end of the line, else the child go home.  Repeat the first two steps while the line is not empty. Consider all the children in the order they go home. Jzzhu wants to know, which child will be the last in this order?","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2\\n1 3 1 4 2', 'output': ['4\\n']}, {'input': '6 4\\n1 1 2 2 3 3', 'output': ['6\\n']}, {'input': '3 1\\n1 2 3', 'output': ['3\\n']}, {'input': '4 3\\n3 3 3 3', 'output': ['4\\n']}, {'input': '7 5\\n5 10 15 20 25 30 35', 'output': ['7\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"0 0\", \"1 0\", \"0 1\", \"-1 -1\"]","prob_desc_input_spec":"The first line contains two space-separated integers x and y (|x|,\u2009|y|\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x = 0\ny = 0\nnx,ny = map(int,input().split())\nif ((nx == 0 or nx == 1) and ny == 0):\n    print(0)\nelse:\n    x = 1\n    turn = 0\n    flag = 0\n    while True:\n        turn = turn + 1\n        while y != x:\n            y = y + 1\n            if(x == nx and y == ny):\n                flag = 1    \n                break\n        if flag == 1:\n            break\n        k = x * -1\n        turn = turn + 1\n        while x != k:\n            x = x - 1\n            if(x == nx and y == ny):\n                flag = 1\n                break\n        if flag == 1:\n            break\n        turn  = turn + 1\n        while y != x:\n            y = y - 1 \n            if(x == nx and y == ny):\n                flag = 1\n                break\n        if flag == 1:\n            break\n        k = (x * -1) + 1\n        turn = turn  + 1\n        while x != k:\n            x = x + 1\n            if(x == nx and y == ny):\n                flag = 1\n                break\n        if flag == 1:\n            break\n    print(turn)","prob_desc_sample_outputs":"[\"0\", \"0\", \"2\", \"3\"]","lang_cluster":"Python","code_uid":"c1577d63964782d720f9d6b0b370dd4b","prob_desc_notes":null,"prob_desc_output_spec":"Print a single integer, showing how many times Valera has to turn.","prob_desc_output_to":"standard output","prob_desc_description":"Valera the horse lives on a plane. The Cartesian coordinate system is defined on this plane. Also an infinite spiral is painted on the plane. The spiral consists of segments: [(0,\u20090),\u2009(1,\u20090)], [(1,\u20090),\u2009(1,\u20091)], [(1,\u20091),\u2009(\u2009-\u20091,\u20091)], [(\u2009-\u20091,\u20091),\u2009(\u2009-\u20091,\u2009\u2009-\u20091)], [(\u2009-\u20091,\u2009\u2009-\u20091),\u2009(2,\u2009\u2009-\u20091)], [(2,\u2009\u2009-\u20091),\u2009(2,\u20092)] and so on. Thus, this infinite spiral passes through each integer point of the plane.Valera the horse lives on the plane at coordinates (0,\u20090). He wants to walk along the spiral to point (x,\u2009y). Valera the horse has four legs, so he finds turning very difficult. Count how many times he will have to turn if he goes along a spiral from point (0,\u20090) to point (x,\u2009y).","length":45,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2', 'output': ['4\\n']}, {'input': '-1 1', 'output': ['2\\n']}, {'input': '-2 -2', 'output': ['5\\n']}, {'input': '3 -1', 'output': ['5\\n']}, {'input': '0 -1', 'output': ['3\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 0\", \"2 1\", \"3 2\", \"4 1\", \"7 4\"]","prob_desc_input_spec":"The single line contains two space-separated integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u20091000,\u20090\u2009\u2264\u2009k\u2009\u2264\u2009n).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"mod=10**9+7\nn,k=map(int,input().split())\n\nA=[0]*(n+1)\nB=[0]*(n+1)\nC=[0]*(n+1)\nF=[0]*(n+1)\nG=[0]*(n+1)\n\nF[0]=G[0]=1\nfor i in range(1,n+1):\n\tG[i]=F[i]=F[i-1]*i%mod\n\tG[i]=pow(F[i],(mod-2),mod)\n\nfor i in range(0,n):\n\tif i*2>n:\n\t\tbreak\n\tB[i]=(F[n-i]*G[i]*G[n-i*2])%mod\nfor i in range(0,n\/\/2+1):\n\tfor j in range(0,n\/\/2+1):\n\t\tA[i+j]=(A[i+j]+B[i]*B[j])%mod\nfor i in range(0,n+1):\n\tA[i]=A[i]*F[n-i]%mod\nfor i in range(0,n+1):\n\tfor j in range(0,i+1):\n\t\tC[j]=(C[j]+A[i]*F[i]*G[j]*G[i-j]*(1-(i-j)%2*2))%mod\nprint(C[k]%mod)\n\n","prob_desc_sample_outputs":"[\"1\", \"0\", \"4\", \"6\", \"328\"]","lang_cluster":"Python","code_uid":"6b934f463744b99cabe28dd0c20d4578","prob_desc_notes":"NoteThe only permutation of size 1 has 0 good positions.Permutation (1,\u20092) has 0 good positions, and permutation (2,\u20091) has 2 positions.Permutations of size 3: (1,\u20092,\u20093) \u2014 0 positions  \u2014 2 positions  \u2014 2 positions  \u2014 2 positions  \u2014 2 positions (3,\u20092,\u20091) \u2014 0 positions","prob_desc_output_spec":"Print the number of permutations of length n with exactly k good positions modulo 1000000007 (109\u2009+\u20097).","prob_desc_output_to":"standard output","prob_desc_description":"Permutation p is an ordered set of integers p1,\u2009\u2009p2,\u2009\u2009...,\u2009\u2009pn, consisting of n distinct positive integers, each of them doesn't exceed n. We'll denote the i-th element of permutation p as pi. We'll call number n the size or the length of permutation p1,\u2009\u2009p2,\u2009\u2009...,\u2009\u2009pn.We'll call position i (1\u2009\u2264\u2009i\u2009\u2264\u2009n) in permutation p1,\u2009p2,\u2009...,\u2009pn good, if |p[i]\u2009-\u2009i|\u2009=\u20091. Count the number of permutations of size n with exactly k good positions. Print the answer modulo 1000000007 (109\u2009+\u20097).","length":28,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2', 'output': ['20']}, {'input': '6 3', 'output': ['80']}, {'input': '7 3', 'output': ['560']}, {'input': '8 4', 'output': ['3360']}, {'input': '9 4', 'output': ['30240']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"WUBWUBABCWUB\", \"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\"]","prob_desc_input_spec":"The input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring \"WUB\" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n = input()\nn = list(n)\nspace = 1\n\ns = []\ni = 0\nfor _ in range(0,len(n), 1):\n    if i == len(n):\n        break\n    elif i + 2 < len(n) and n[i] == 'W' and n[i+1] == 'U' and n[i+2] == 'B':\n        i += 3\n        if space == 0:\n            s.append(\" \")\n        space = 1\n    else:\n        s.append(n[i])\n        i += 1\n        space = 0\nans = \"\"\nfor i in range(0, len(s)):\n    ans = ans + s[i]\n\nprint(ans)\n","prob_desc_sample_outputs":"[\"ABC\", \"WE ARE THE CHAMPIONS MY FRIEND\"]","lang_cluster":"Python","code_uid":"b74d1efc8dc7c743f39b0603ef78ded1","prob_desc_notes":"NoteIn the first sample: \"WUBWUBABCWUB\" = \"WUB\" + \"WUB\" + \"ABC\" + \"WUB\". That means that the song originally consisted of a single word \"ABC\", and all words \"WUB\" were added by Vasya.In the second sample Vasya added a single word \"WUB\" between all neighbouring words, in the beginning and in the end, except for words \"ARE\" and \"THE\" \u2014 between them Vasya added two \"WUB\".","prob_desc_output_spec":"Print the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.Let's assume that a song consists of some number of words. To make the dubstep remix of this song, Vasya inserts a certain number of words \"WUB\" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including \"WUB\", in one string and plays the song at the club.For example, a song with words \"I AM X\" can transform into a dubstep remix as \"WUBWUBIWUBAMWUBWUBX\" and cannot transform into \"WUBWUBIAMWUBX\".Recently, Petya has heard Vasya's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Vasya remixed. Help Petya restore the original song.","length":23,"num_hidden_unit_tests":5,"hidden_unit_tests":"[]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 7 0\", \"2 0 1\", \"1 1 0\", \"0 0 1\"]","prob_desc_input_spec":"The only line contains three integers $$$x$$$, $$$y$$$, $$$z$$$ ($$$0\\le x,y,z\\le100$$$), corresponding to the number of persons who would upvote, downvote or unknown.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a,b,c=map(int,input().split())\nx=a-b\nif(c>=abs(x) and c!=0):\n\tprint(\"?\")\nelif(x==0):\n\tprint(\"0\")\nelif(x<0):\n\tprint(\"-\")\nelse:\n\tprint(\"+\")","prob_desc_sample_outputs":"[\"-\", \"+\", \"0\", \"?\"]","lang_cluster":"Python","code_uid":"faa620d5a241e146059c5ea1bae3a2a9","prob_desc_notes":"NoteIn the first example, Nauuo would definitely get three upvotes and seven downvotes, so the only possible result is \"-\".In the second example, no matter the person unknown downvotes or upvotes, Nauuo would get more upvotes than downvotes. So the only possible result is \"+\".In the third example, Nauuo would definitely get one upvote and one downvote, so the only possible result is \"0\".In the fourth example, if the only one person upvoted, the result would be \"+\", otherwise, the result would be \"-\". There are two possible results, so the result is uncertain.","prob_desc_output_spec":"If there is only one possible result, print the result : \"+\", \"-\" or \"0\". Otherwise, print \"?\" to report that the result is uncertain.","prob_desc_output_to":"standard output","prob_desc_description":"Nauuo is a girl who loves writing comments.One day, she posted a comment on Codeforces, wondering whether she would get upvotes or downvotes.It's known that there were $$$x$$$ persons who would upvote, $$$y$$$ persons who would downvote, and there were also another $$$z$$$ persons who would vote, but you don't know whether they would upvote or downvote. Note that each of the $$$x+y+z$$$ people would vote exactly one time.There are three different results: if there are more people upvote than downvote, the result will be \"+\"; if there are more people downvote than upvote, the result will be \"-\"; otherwise the result will be \"0\".Because of the $$$z$$$ unknown persons, the result may be uncertain (i.e. there are more than one possible results). More formally, the result is uncertain if and only if there exist two different situations of how the $$$z$$$ persons vote, that the results are different in the two situations.Tell Nauuo the result or report that the result is uncertain.","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5 0', 'output': ['0\\n']}, {'input': '10 5 0', 'output': ['+\\n']}, {'input': '5 10 0', 'output': ['-\\n']}, {'input': '5 5 5', 'output': ['?\\n']}, {'input': '10 5 5', 'output': ['+\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6\\n1 5\\n2 6\\n3 7\", \"10\\n1 2\\n1 3\\n1 5\", \"6\\n1 3\\n2 2\\n2 2\"]","prob_desc_input_spec":"The first line of the input contains a single integer n (3\u2009\u2264\u2009n\u2009\u2264\u20093\u00b7106)\u00a0\u2014\u00a0the number of schoolchildren who will participate in the Olympiad. The next line of the input contains two integers min1 and max1 (1\u2009\u2264\u2009min1\u2009\u2264\u2009max1\u2009\u2264\u2009106)\u00a0\u2014\u00a0the minimum and maximum limits on the number of diplomas of the first degree that can be distributed. The third line of the input contains two integers min2 and max2 (1\u2009\u2264\u2009min2\u2009\u2264\u2009max2\u2009\u2264\u2009106)\u00a0\u2014\u00a0the minimum and maximum limits on the number of diplomas of the second degree that can be distributed.  The next line of the input contains two integers min3 and max3 (1\u2009\u2264\u2009min3\u2009\u2264\u2009max3\u2009\u2264\u2009106)\u00a0\u2014\u00a0the minimum and maximum limits on the number of diplomas of the third degree that can be distributed.  It is guaranteed that min1\u2009+\u2009min2\u2009+\u2009min3\u2009\u2264\u2009n\u2009\u2264\u2009max1\u2009+\u2009max2\u2009+\u2009max3.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n=int(input())\na=[None]*3\na[0]=list(map(int,input().split()))\na[1]=list(map(int,input().split()))\na[2]=list(map(int,input().split()))\ntotal=0\nb=[None]*3\nfor i in range(3):\n      total+=a[i][0]\n      b[i]=a[i][0]\n\nwhile total<n:\n      if b[0]<a[0][1]:\n            k=a[0][1]-b[0]\n            if total+k>n:\n                  b[0]+=(n-total)\n                  total=n\n            else:\n                  b[0]+=k\n                  total+=k\n      if b[1]<a[1][1]:\n            k=a[1][1]-b[1]\n            if total+k>n:\n                  b[1]+=(n-total)\n                  total=n\n            else:\n                  b[1]+=k\n                  total+=k\n      if b[2]<a[2][1]:\n            k=a[2][1]-b[2]\n            if total+k>n:\n                  b[2]+=(n-total)\n                  total=n\n            else:\n                  b[2]+=k\n                  total+=k\n      \nprint(b[0],b[1],b[2])\n","prob_desc_sample_outputs":"[\"1 2 3\", \"2 3 5\", \"2 2 2\"]","lang_cluster":"Python","code_uid":"c1f9c3691e5a36d411545872d8b51544","prob_desc_notes":null,"prob_desc_output_spec":"In the first line of the output print three numbers, showing how many diplomas of the first, second and third degree will be given to students in the optimal variant of distributing diplomas. The optimal variant of distributing diplomas is the one that maximizes the number of students who receive diplomas of the first degree. Of all the suitable options, the best one is the one which maximizes the number of participants who receive diplomas of the second degree. If there are several of these options, the best one is the one that maximizes the number of diplomas of the third degree.","prob_desc_output_to":"standard output","prob_desc_description":"Soon a school Olympiad in Informatics will be held in Berland, n schoolchildren will participate there.At a meeting of the jury of the Olympiad it was decided that each of the n participants, depending on the results, will get a diploma of the first, second or third degree. Thus, each student will receive exactly one diploma.They also decided that there must be given at least min1 and at most max1 diplomas of the first degree, at least min2 and at most max2 diplomas of the second degree, and at least min3 and at most max3 diplomas of the third degree.After some discussion it was decided to choose from all the options of distributing diplomas satisfying these limitations the one that maximizes the number of participants who receive diplomas of the first degree. Of all these options they select the one which maximizes the number of the participants who receive diplomas of the second degree. If there are multiple of these options, they select the option that maximizes the number of diplomas of the third degree.Choosing the best option of distributing certificates was entrusted to Ilya, one of the best programmers of Berland. However, he found more important things to do, so it is your task now to choose the best option of distributing of diplomas, based on the described limitations.It is guaranteed that the described limitations are such that there is a way to choose such an option of distributing diplomas that all n participants of the Olympiad will receive a diploma of some degree.","length":38,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10\\n1 3\\n2 3\\n3 4', 'output': ['3 3 4\\n']}, {'input': '15\\n2 5\\n3 6\\n4 7', 'output': ['5 6 4\\n']}, {'input': '20\\n3 7\\n4 8\\n5 9', 'output': ['7 8 5\\n']}, {'input': '25\\n4 9\\n5 10\\n6 11', 'output': ['9 10 6\\n']}, {'input': '30\\n5 10\\n6 11\\n7 12', 'output': ['10 11 9\\n']}]"}
{"prob_desc_memory_limit":"255 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 1 10\", \"1 2 5\", \"2 3 9\"]","prob_desc_input_spec":"The only string contains three integers\u00a0\u2014 n, m and z (1\u2009\u2264\u2009n,\u2009m,\u2009z\u2009\u2264\u2009104).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n = list(map(int, input().split()))\na = set()\nb = set()\nfor i in range(n[2]\/\/n[0]):\n a.add((i+1)*n[0])\nfor i in range(n[2]\/\/n[1]):\n b.add((i+1)*n[1])\nprint(len(a & b))","prob_desc_sample_outputs":"[\"10\", \"2\", \"1\"]","lang_cluster":"Python","code_uid":"d62c78efb9dc6541e7ef583be9972947","prob_desc_notes":"NoteTaymyr is a place in the north of Russia.In the first test the artists come each minute, as well as the calls, so we need to kill all of them.In the second test we need to kill artists which come on the second and the fourth minutes.In the third test\u00a0\u2014 only the artist which comes on the sixth minute. ","prob_desc_output_spec":"Print single integer\u00a0\u2014 the minimum number of artists that should be killed so that there are no artists in the room when Ilia calls.","prob_desc_output_to":"standard output","prob_desc_description":"Comrade Dujikov is busy choosing artists for Timofey's birthday and is recieving calls from Taymyr from Ilia-alpinist.Ilia-alpinist calls every n minutes, i.e. in minutes n, 2n, 3n and so on. Artists come to the comrade every m minutes, i.e. in minutes m, 2m, 3m and so on. The day is z minutes long, i.e. the day consists of minutes 1,\u20092,\u2009...,\u2009z. How many artists should be killed so that there are no artists in the room when Ilia calls? Consider that a call and a talk with an artist take exactly one minute.","length":8,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 5 15', 'output': ['1']}, {'input': '4 6 24', 'output': ['2']}, {'input': '2 7 14', 'output': ['1']}, {'input': '5 10 50', 'output': ['5']}, {'input': '1 3 9', 'output': ['3']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"17 15 5 3\", \"14 16 7 22\", \"4 2 6 4\", \"1000000000000000000 1000000000000000000 999999866000004473 999999822000007597\"]","prob_desc_input_spec":"The first line contains four integers $$$a$$$, $$$b$$$, $$$x$$$, $$$y$$$ ($$$1 \\le a, b, x, y \\le 10^{18}$$$)\u00a0\u2014 the constraints on the screen width and height, and on the aspect ratio.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"from math import gcd\n\nx, y, a, b = [int(x) for x in input().split()]\n\ngc = gcd(a, b)\na = a \/\/ gc\nb = b \/\/ gc\n\nprint(min(x\/\/a, y\/\/b))","prob_desc_sample_outputs":"[\"3\", \"0\", \"1\", \"1000000063\"]","lang_cluster":"Python","code_uid":"bba9c820b0f2b0a5076b015644d66f4a","prob_desc_notes":"NoteIn the first example, there are $$$3$$$ possible variants: $$$(5, 3)$$$, $$$(10, 6)$$$, $$$(15, 9)$$$.In the second example, there is no TV set meeting the constraints.In the third example, there is only one variant: $$$(3, 2)$$$.","prob_desc_output_spec":"Print one integer\u00a0\u2014 the number of different variants to choose TV screen width and screen height so that they meet the aforementioned constraints.","prob_desc_output_to":"standard output","prob_desc_description":"Monocarp has decided to buy a new TV set and hang it on the wall in his flat. The wall has enough free space so Monocarp can buy a TV set with screen width not greater than $$$a$$$ and screen height not greater than $$$b$$$. Monocarp is also used to TV sets with a certain aspect ratio: formally, if the width of the screen is $$$w$$$, and the height of the screen is $$$h$$$, then the following condition should be met: $$$\\frac{w}{h} = \\frac{x}{y}$$$.There are many different TV sets in the shop. Monocarp is sure that for any pair of positive integers $$$w$$$ and $$$h$$$ there is a TV set with screen width $$$w$$$ and height $$$h$$$ in the shop.Monocarp isn't ready to choose the exact TV set he is going to buy. Firstly he wants to determine the optimal screen resolution. He has decided to try all possible variants of screen size. But he must count the number of pairs of positive integers $$$w$$$ and $$$h$$$, beforehand, such that $$$(w \\le a)$$$, $$$(h \\le b)$$$ and $$$(\\frac{w}{h} = \\frac{x}{y})$$$.In other words, Monocarp wants to determine the number of TV sets having aspect ratio $$$\\frac{x}{y}$$$, screen width not exceeding $$$a$$$, and screen height not exceeding $$$b$$$. Two TV sets are considered different if they have different screen width or different screen height.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '20 10 2 1', 'output': ['10\\n']}, {'input': '100 200 3 2', 'output': ['33\\n']}, {'input': '1000 500 5 2', 'output': ['200\\n']}, {'input': '10000 5000 10 5', 'output': ['1000\\n']}, {'input': '100000 50000 20 10', 'output': ['5000\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"0 0\\n4 5\", \"3 4\\n6 1\"]","prob_desc_input_spec":"The first line contains two integers x1,\u2009y1 (\u2009-\u2009109\u2009\u2264\u2009x1,\u2009y1\u2009\u2264\u2009109) \u2014 the start position of the robot. The second line contains two integers x2,\u2009y2 (\u2009-\u2009109\u2009\u2264\u2009x2,\u2009y2\u2009\u2264\u2009109) \u2014 the finish position of the robot.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a, b=map(int, input().split())\nc, d=map(int, input().split())\n\ng=abs(c-a)\nh=abs(d-b)\nx=max(g, h)\ny=min(g, h)\nz=abs(x-y)\nif g==h:\n  print(g)\nelse:\n  print(y+z)","prob_desc_sample_outputs":"[\"5\", \"3\"]","lang_cluster":"Python","code_uid":"673ab16d6e3c18c72916134d40852e99","prob_desc_notes":"NoteIn the first example robot should increase both of its coordinates by one four times, so it will be in position (4,\u20094). After that robot should simply increase its y coordinate and get the finish position.In the second example robot should simultaneously increase x coordinate and decrease y coordinate by one three times.","prob_desc_output_spec":"Print the only integer d \u2014 the minimal number of steps to get the finish position.","prob_desc_output_to":"standard output","prob_desc_description":"Professor GukiZ makes a new robot. The robot are in the point with coordinates (x1,\u2009y1) and should go to the point (x2,\u2009y2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.","length":12,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0\\n0 0', 'output': ['0\\n']}, {'input': '-1 -1\\n1 1', 'output': ['2\\n']}, {'input': '0 0\\n-5 -5', 'output': ['5\\n']}, {'input': '1000000000 1000000000\\n-1000000000 -1000000000', 'output': ['2000000000\\n']}, {'input': '0 0\\n1000000000 1000000000', 'output': ['1000000000\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6 10\", \"21 31\", \"5 10\"]","prob_desc_input_spec":"The only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"a, b = input().split()\na, b = int(a), int(b)\na, b = min(a, b), max(a, b)\n\ndef eu(a, b):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    if a > b:\n        return eu(a%b, b)\n    return eu(a, b%a)\n\nopt = b - a\nfactor = []\ni = 1\nwhile i**2 < opt+1:\n    if opt % i == 0:\n        factor.append(i)\n        factor.append(int(opt\/i))\n    i+=1\n\ntarget = a * b \/ eu(a, b)\ndrop = 0\n\nfor i in factor:\n    firstupd = a - (a % i) + i\n    secondupd = b - (b % i) + i\n    dres = firstupd * int(secondupd\/eu(firstupd,secondupd))\n    if dres <= target:\n        if dres == target:\n            drop = min(i-(a%i),drop)\n        else:\n            target = dres\n            drop = i-(a%i)\nprint(drop)","prob_desc_sample_outputs":"[\"2\", \"9\", \"0\"]","lang_cluster":"Python","code_uid":"8b34db2607886facf600047b2f94c505","prob_desc_notes":"NoteIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.","prob_desc_output_spec":"Print the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.","prob_desc_output_to":"standard output","prob_desc_description":"Neko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?","length":36,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 1', 'output': ['0\\n']}, {'input': '100 200', 'output': ['0\\n']}, {'input': '999999999 1000000000', 'output': ['0\\n']}, {'input': '123456789 987654321', 'output': ['0\\n']}, {'input': '500000000 500000001', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"QAQAQYSYIOIWIN\", \"QAQQQZZYNOIWIN\"]","prob_desc_input_spec":"The only line contains a string of length n (1\u2009\u2264\u2009n\u2009\u2264\u2009100). It's guaranteed that the string only contains uppercase English letters.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"import itertools\n \nprint(sum(map(lambda x:(x==('Q','A','Q')), itertools.combinations(input(),3))))","prob_desc_sample_outputs":"[\"4\", \"3\"]","lang_cluster":"Python","code_uid":"7b81a4801fc6c454082998b70a435eae","prob_desc_notes":"NoteIn the first example there are 4 subsequences \"QAQ\": \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\", \"QAQAQYSYIOIWIN\".","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the number of subsequences \"QAQ\" in the string.","prob_desc_output_to":"standard output","prob_desc_description":"\"QAQ\" is a word to denote an expression of crying. Imagine \"Q\" as eyes with tears and \"A\" as a mouth.Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of \"QAQ\" in the string (Diamond is so cute!).  illustration by \u732b\u5c4b https:\/\/twitter.com\/nekoyaliu Bort wants to know how many subsequences \"QAQ\" are in the string Diamond has given. Note that the letters \"QAQ\" don't have to be consecutive, but the order of letters should be exact.","length":3,"num_hidden_unit_tests":5,"hidden_unit_tests":"[]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 2\", \"9 3\"]","prob_desc_input_spec":"The single line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009100;\u00a02\u2009\u2264\u2009m\u2009\u2264\u2009100), separated by a space.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def gogo(n, m): \n    return n + ((n-1)\/\/(m-1))\n\n\ndef main():\n    pairs, bought = map(int, input().split())\n    print(gogo(pairs, bought))\n\n\nmain()\n\n","prob_desc_sample_outputs":"[\"3\", \"13\"]","lang_cluster":"Python","code_uid":"bfa17fde86ca6c500cecdd3dab5415f2","prob_desc_notes":"NoteIn the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.","prob_desc_output_spec":"Print a single integer \u2014 the answer to the problem.","prob_desc_output_to":"standard output","prob_desc_description":"Vasya has n pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every m-th day (at days with numbers m,\u20092m,\u20093m,\u2009...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 2', 'output': ['9']}, {'input': '10 3', 'output': ['14']}, {'input': '20 5', 'output': ['24']}, {'input': '30 6', 'output': ['35']}, {'input': '40 7', 'output': ['46']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1098\", \"10\"]","prob_desc_input_spec":"The first line contains one integer $$$n$$$ ($$$1 \\le n \\le 10^9$$$).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def f(x):    \n    x+=1\n    while not x % 10:\n        x \/\/=10\n    return x\n        \nprevious = set()\n\nn = int(input())\nwhile n not in previous:\n    previous.add(n)\n    n = f(n)\n    \nprint(len(previous))","prob_desc_sample_outputs":"[\"20\", \"19\"]","lang_cluster":"Python","code_uid":"87807144a21d31696051967aa976d835","prob_desc_notes":"NoteThe numbers that are reachable from $$$1098$$$ are:$$$1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1098, 1099$$$.","prob_desc_output_spec":"Print one integer: the number of different numbers that are reachable from $$$n$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Let's denote a function $$$f(x)$$$ in such a way: we add $$$1$$$ to $$$x$$$, then, while there is at least one trailing zero in the resulting number, we remove that zero. For example,   $$$f(599) = 6$$$: $$$599 + 1 = 600 \\rightarrow 60 \\rightarrow 6$$$;  $$$f(7) = 8$$$: $$$7 + 1 = 8$$$;  $$$f(9) = 1$$$: $$$9 + 1 = 10 \\rightarrow 1$$$;  $$$f(10099) = 101$$$: $$$10099 + 1 = 10100 \\rightarrow 1010 \\rightarrow 101$$$. We say that some number $$$y$$$ is reachable from $$$x$$$ if we can apply function $$$f$$$ to $$$x$$$ some (possibly zero) times so that we get $$$y$$$ as a result. For example, $$$102$$$ is reachable from $$$10098$$$ because $$$f(f(f(10098))) = f(f(10099)) = f(101) = 102$$$; and any number is reachable from itself.You are given a number $$$n$$$; your task is to count how many different numbers are reachable from $$$n$$$.","length":14,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n', 'output': ['1\\n']}, {'input': '100\\n', 'output': ['19\\n']}, {'input': '999999999\\n', 'output': ['19\\n']}, {'input': '500\\n', 'output': ['15\\n']}, {'input': '1000000000\\n', 'output': ['20\\n']}]"}
{"prob_desc_memory_limit":"64 megabytes","difficulty":1500.0,"prob_desc_time_limit":"0.5 seconds","prob_desc_sample_inputs":"[\"12\"]","prob_desc_input_spec":"The only line of the input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) \u2014 the prediction on the number of people who will buy the game.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def main():\n\tn = int(input())\n\tprint(solver(n))\n\ndef solver(n):\n\tfactors = [2, 3, 5, 7]\n\tsingles = n \/\/ 2 + n \/\/ 3 + n \/\/ 5 + n \/\/ 7\n\tpairs = n \/\/ (2 * 3) + n \/\/ (2 * 5) + n \/\/ (2 * 7) + \\\n\tn \/\/ (3 * 5) + n \/\/ (3 * 7) + n \/\/ (5 * 7)\n\ttriples = n \/\/ (2 * 3 * 5) + n \/\/ (2 * 3 * 7) + \\\n\tn \/\/ (2 * 5 * 7) + n \/\/ (3 * 5 * 7)\n\tquads = n \/\/ (2 * 3 * 5 * 7)\n\treturn n - singles + pairs - triples + quads\n\nmain()","prob_desc_sample_outputs":"[\"2\"]","lang_cluster":"Python","code_uid":"55019f26f970076f44fd5b6f9d161b40","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer showing how many numbers from 1 to n are not divisible by any number from 2 to 10.","prob_desc_output_to":"standard output","prob_desc_description":"IT City company developing computer games decided to upgrade its way to reward its employees. Now it looks the following way. After a new game release users start buying it actively, and the company tracks the number of sales with precision to each transaction. Every time when the next number of sales is not divisible by any number from 2 to 10 every developer of this game gets a small bonus.A game designer Petya knows that the company is just about to release a new game that was partly developed by him. On the basis of his experience he predicts that n people will buy the game during the first month. Now Petya wants to determine how many times he will get the bonus. Help him to know it.","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1']}, {'input': '10', 'output': ['2']}, {'input': '20', 'output': ['4']}, {'input': '50', 'output': ['10']}, {'input': '100', 'output': ['20']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 1 4 4 2 1\", \"1 6 6 2 1 1\", \"4 1 7 4 1 2\"]","prob_desc_input_spec":"The only line contains six integers $$$x$$$, $$$y$$$, $$$z$$$, $$$t_1$$$, $$$t_2$$$, $$$t_3$$$ ($$$1 \\leq x, y, z, t_1, t_2, t_3 \\leq 1000$$$)\u00a0\u2014 the floor Masha is at, the floor Masha wants to get to, the floor the elevator is located on, the time it takes Masha to pass between two floors by stairs, the time it takes the elevator to pass between two floors and the time it takes for the elevator to close or open the doors. It is guaranteed that $$$x \\ne y$$$.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x,y,z,t1,t2,t3 = map(int,input().split())\ny=abs(y-x)\nif abs(z-x)*t2+y*t2+3*t3 <= y*t1 :\n   print('YES')\nelse:\n   print('NO') \n\n\n \n","prob_desc_sample_outputs":"[\"YES\", \"NO\", \"YES\"]","lang_cluster":"Python","code_uid":"654b366320659b02d312390dbcc667c2","prob_desc_notes":"NoteIn the first example:If Masha goes by the stairs, the time she spends is $$$4 \\cdot 4 = 16$$$, because she has to go $$$4$$$ times between adjacent floors and each time she spends $$$4$$$ seconds. If she chooses the elevator, she will have to wait $$$2$$$ seconds while the elevator leaves the $$$4$$$-th floor and goes to the $$$5$$$-th. After that the doors will be opening for another $$$1$$$ second. Then Masha will enter the elevator, and she will have to wait for $$$1$$$ second for the doors closing. Next, the elevator will spend $$$4 \\cdot 2 = 8$$$ seconds going from the $$$5$$$-th floor to the $$$1$$$-st, because the elevator has to pass $$$4$$$ times between adjacent floors and spends $$$2$$$ seconds each time. And finally, it will take another $$$1$$$ second before the doors are open and Masha can come out. Thus, all the way by elevator will take $$$2 + 1 + 1 + 8 + 1 = 13$$$ seconds, which is less than $$$16$$$ seconds, so Masha has to choose the elevator.In the second example, it is more profitable for Masha to use the stairs, because it will take $$$13$$$ seconds to use the elevator, that is more than the $$$10$$$ seconds it will takes to go by foot.In the third example, the time it takes to use the elevator is equal to the time it takes to walk up by the stairs, and is equal to $$$12$$$ seconds. That means Masha will take the elevator.","prob_desc_output_spec":"If the time it will take to use the elevator is not greater than the time it will take to use the stairs, print \u00abYES\u00bb (without quotes), otherwise print \u00abNO&gt; (without quotes). You can print each letter in any case (upper or lower).","prob_desc_output_to":"standard output","prob_desc_description":"Masha lives in a multi-storey building, where floors are numbered with positive integers. Two floors are called adjacent if their numbers differ by one. Masha decided to visit Egor. Masha lives on the floor $$$x$$$, Egor on the floor $$$y$$$ (not on the same floor with Masha).The house has a staircase and an elevator. If Masha uses the stairs, it takes $$$t_1$$$ seconds for her to walk between adjacent floors (in each direction). The elevator passes between adjacent floors (in each way) in $$$t_2$$$ seconds. The elevator moves with doors closed. The elevator spends $$$t_3$$$ seconds to open or close the doors. We can assume that time is not spent on any action except moving between adjacent floors and waiting for the doors to open or close. If Masha uses the elevator, it immediately goes directly to the desired floor.Coming out of the apartment on her floor, Masha noticed that the elevator is now on the floor $$$z$$$ and has closed doors. Now she has to choose whether to use the stairs or use the elevator. If the time that Masha needs to get to the Egor's floor by the stairs is strictly less than the time it will take her using the elevator, then she will use the stairs, otherwise she will choose the elevator.Help Mary to understand whether to use the elevator or the stairs.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 5 2 2 1 1', 'output': ['YES\\n']}, {'input': '7 2 6 3 2 1', 'output': ['NO\\n']}, {'input': '1 10 5 2 1 1', 'output': ['YES\\n']}, {'input': '9 1 5 3 2 1', 'output': ['NO\\n']}, {'input': '5 8 3 2 1 1', 'output': ['YES\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1300.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 5 3 2\", \"7 5 5 2\"]","prob_desc_input_spec":"The first line contains four space-separated integers n, a, b and c (1\u2009\u2264\u2009n,\u2009a,\u2009b,\u2009c\u2009\u2264\u20094000) \u2014 the length of the original ribbon and the acceptable lengths of the ribbon pieces after the cutting, correspondingly. The numbers a, b and c can coincide.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def f(n):\n    # Build maximum number of pieces for\n    #length 1 upto n in bottom up manner\n    dp = [float(\"-inf\")] * (n + 1)\n \n    # Base Case\n    dp[0] = 0\n \n    # dp[i] gives maximum number of pieces that can\n    # be obtained by cutting ribbon of length  i into pieces\n    # of length a, b or c\n    # dp[i] = -inf if it is not possible to cut the ribbon into pieces\n    for i in range(1, n + 1):\n        for length in l:\n            # Cut into pieces if only we dont have negative length of ribbon\n            if i - length >= 0:\n                dp[i] = max(dp[i], 1 + dp[i - length])\n    # return maximum number of pieces possible for ribbon with length n\n    return dp[n]\n \n \nl = list(map(int, input().split()))\nn, l = l[0], l[1:]\nprint(f(n))","prob_desc_sample_outputs":"[\"2\", \"2\"]","lang_cluster":"Python","code_uid":"c155139d34bf2eb226311b8978705e78","prob_desc_notes":"NoteIn the first example Polycarpus can cut the ribbon in such way: the first piece has length 2, the second piece has length 3.In the second example Polycarpus can cut the ribbon in such way: the first piece has length 5, the second piece has length 2.","prob_desc_output_spec":"Print a single number \u2014 the maximum possible number of ribbon pieces. It is guaranteed that at least one correct ribbon cutting exists.","prob_desc_output_to":"standard output","prob_desc_description":"Polycarpus has a ribbon, its length is n. He wants to cut the ribbon in a way that fulfils the following two conditions:   After the cutting each ribbon piece should have length a, b or c.  After the cutting the number of ribbon pieces should be maximum. Help Polycarpus and find the number of ribbon pieces after the required cutting.","length":24,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 2 3 5', 'output': ['5']}, {'input': '15 5 3 2', 'output': ['5']}, {'input': '20 4 5 6', 'output': ['5']}, {'input': '25 5 5 5', 'output': ['5']}, {'input': '30 10 10 10', 'output': ['3']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 4\", \"2 1\"]","prob_desc_input_spec":"The only line contains two integers $$$N$$$ and $$$M$$$ ($$$1 \\leq N, M \\leq 10^9$$$) \u2014 the number of rows and columns in the grid.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"G = list(map(int, input().split()))\nN = G[0]\nM = G[1]\n\nif M > 1:\n  print(N * (M - 1))\nelse:\n  print(M * (N - 1))\n\t\t \t\t\t\t\t \t        \t\t\t\t\t  \t \t\t\t\t","prob_desc_sample_outputs":"[\"9\", \"1\"]","lang_cluster":"Python","code_uid":"bd0cd59e2175057a315437451a1cd34d","prob_desc_notes":"NoteThe picture below is the grid that Pak Chanek has in the first example.  The picture below is an example of a tight domino in the grid.  ","prob_desc_output_spec":"An integer representing the number of distinct tight dominoes in the grid.","prob_desc_output_to":"standard output","prob_desc_description":"Pak Chanek has a grid that has $$$N$$$ rows and $$$M$$$ columns. Each row is numbered from $$$1$$$ to $$$N$$$ from top to bottom. Each column is numbered from $$$1$$$ to $$$M$$$ from left to right.Each tile in the grid contains a number. The numbers are arranged as follows:   Row $$$1$$$ contains integers from $$$1$$$ to $$$M$$$ from left to right.  Row $$$2$$$ contains integers from $$$M+1$$$ to $$$2 \\times M$$$ from left to right.  Row $$$3$$$ contains integers from $$$2 \\times M+1$$$ to $$$3 \\times M$$$ from left to right.  And so on until row $$$N$$$. A domino is defined as two different tiles in the grid that touch by their sides. A domino is said to be tight if and only if the two numbers in the domino have a difference of exactly $$$1$$$. Count the number of distinct tight dominoes in the grid.Two dominoes are said to be distinct if and only if there exists at least one tile that is in one domino, but not in the other.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 5', 'output': ['20']}, {'input': '1 10', 'output': ['0']}, {'input': '10 1', 'output': ['9']}, {'input': '100 100', 'output': ['9900']}, {'input': '1000000000 1', 'output': ['999999999']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":800.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\", \"11\"]","prob_desc_input_spec":"The only line of the input contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000)\u00a0\u2014 the position of the digit you need to print.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n=int(input())\nst=\"\"\nfor i in range(1,1000):\n    st=st+str(i)\nprint(st[n-1] )\n\n    ","prob_desc_sample_outputs":"[\"3\", \"0\"]","lang_cluster":"Python","code_uid":"21396af87304a95563d5b4b4a9eebdfd","prob_desc_notes":"NoteIn the first sample the digit at position 3 is '3', as both integers 1 and 2 consist on one digit.In the second sample, the digit at position 11 is '0', it belongs to the integer 10.","prob_desc_output_spec":"Print the n-th digit of the line.","prob_desc_output_to":"standard output","prob_desc_description":"Every year, hundreds of people come to summer camps, they learn new algorithms and solve hard problems.This is your first year at summer camp, and you are asked to solve the following problem. All integers starting with 1 are written in one line. The prefix of these line is \"123456789101112131415...\". Your task is to print the n-th digit of this string (digits are numbered starting with 1.","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1', 'output': ['1']}, {'input': '10', 'output': ['10']}, {'input': '100', 'output': ['5']}, {'input': '500', 'output': ['3']}, {'input': '1000', 'output': ['3']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":2700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3\\n0 0 1\\n2 0 1\\n4 0 1\", \"3\\n0 0 2\\n3 0 2\\n6 0 2\", \"3\\n0 0 2\\n2 0 2\\n1 1 2\"]","prob_desc_input_spec":"The first line of input contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20093), denoting the number of circles. The following n lines each contains three space-separated integers x, y and r (\u2009-\u200910\u2009\u2264\u2009x,\u2009y\u2009\u2264\u200910, 1\u2009\u2264\u2009r\u2009\u2264\u200910), describing a circle whose center is (x,\u2009y) and the radius is r. No two circles have the same x, y and r at the same time.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"from math import sqrt\npt = lambda *a, **k: print(*a, **k, flush=True)\nrd = lambda: map(int, input().split())\nn = int(input())\ndef f(x1, y1, r1, x2, y2, r2):\n    a = (r1 + r2) ** 2\n    b = (r1 - r2) ** 2\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > a:\n        return 1\n    elif d == a:\n        return 4\n    elif d < b:\n        return 3\n    elif d == b:\n        return 5\n    else:\n        return 2\ndef g(x1, y1, r1, x2, y2, r2):\n    ds = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    d = sqrt(ds)\n    A = (r1 ** 2 - r2 ** 2 + ds) \/ (2 * d)\n    h = sqrt(r1 ** 2 - A ** 2)\n    x = x1 + A * (x2 - x1) \/ d  \n    y = y1 + A * (y2 - y1) \/ d\n    x3 = x - h * (y2 - y1) \/ d  \n    y3 = y + h * (x2 - x1) \/ d\n    x4 = x + h * (y2 - y1) \/ d  \n    y4 = y - h * (x2 - x1) \/ d\n    return x3, y3, x4, y4 \nif n is 1:\n    pt(2)\nif n is 2:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    pt(4 if a is 2 else 3)\nif n is 3:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    x3, y3, r3 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    b = f(x1, y1, r1, x3, y3, r3)\n    c = f(x3, y3, r3, x2, y2, r2)\n    t = [a, b, c]\n    t.sort()\n    a, b, c = t\n    if a is 1 and b is 1 and c in [1, 3, 4, 5]:\n        pt(4)\n    if a is 1 and b is 1 and c is 2:\n        pt(5)\n    if a is 1 and b is 2 and c is 2:\n        pt(6)\n    if a is 1 and b is 2 and c in [3, 4, 5]:\n        pt(5)\n    if a is 1 and b in [3, 4, 5]:\n        pt(4)\n    if a is 2 and b is 2 and c is 2:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        r = 8\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        pt(r)\n    if a is 2 and b is 2 and c is 3:\n        pt(6)\n    if a is 2 and b is 2 and c in [4, 5]:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            pt(6)\n        else:\n            pt(7)\n    if a is 2 and b is 3:\n        pt(5)\n    if a is 2 and b in [4, 5]:\n        pt(6)\n    if a is 3 and b in [3, 4, 5]:\n        pt(4)\n    if a is 4 and b is 4 and c is 4:\n        pt(5)\n    if a is 4 and b is 4 and c is 5:\n        pt(4)\n    if a is 4 and b is 5 and c is 5:\n        pt(5)\n    if a is 5 and b is 5 and c is 5:\n        pt(4)\n","prob_desc_sample_outputs":"[\"4\", \"6\", \"8\"]","lang_cluster":"Python","code_uid":"8f579f9ebc8eb9a0ceec8194d4027c4c","prob_desc_notes":"NoteFor the first example,  For the second example,  For the third example,  ","prob_desc_output_spec":"Print a single integer\u00a0\u2014 the number of regions on the plane.","prob_desc_output_to":"standard output","prob_desc_description":"Firecrackers scare Nian the monster, but they're wayyyyy too noisy! Maybe fireworks make a nice complement.Little Tommy is watching a firework show. As circular shapes spread across the sky, a splendid view unfolds on the night of Lunar New Year's eve.A wonder strikes Tommy. How many regions are formed by the circles on the sky? We consider the sky as a flat plane. A region is a connected part of the plane with positive area, whose bound consists of parts of bounds of the circles and is a curve or several curves without self-intersections, and that does not contain any curve other than its boundaries. Note that exactly one of the regions extends infinitely.","length":87,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1\\n0 0 1', 'output': ['2\\n']}, {'input': '2\\n0 0 1\\n2 0 1', 'output': ['3\\n']}, {'input': '2\\n0 0 1\\n0 0 2', 'output': ['3\\n']}, {'input': '3\\n0 0 1\\n2 0 1\\n4 0 1', 'output': ['4\\n']}, {'input': '3\\n0 0 2\\n2 0 2\\n1 1 2', 'output': ['8\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10 5\", \"6 12\", \"5 13\"]","prob_desc_input_spec":"The single line contains numbers n and x (1\u2009\u2264\u2009n\u2009\u2264\u2009105, 1\u2009\u2264\u2009x\u2009\u2264\u2009109) \u2014 the size of the table and the number that we are looking for in the table.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n, x = map(int, input().split())\ncount = 0\ni = 1\nwhile i * i <= x:\n    if x % i == 0 and i <= n and x \/\/ i <= n:\n        if i != x \/\/ i:\n            count += 2\n        else:\n            count += 1\n    i += 1\nprint(count)","prob_desc_sample_outputs":"[\"2\", \"4\", \"0\"]","lang_cluster":"Python","code_uid":"c3fd538eb6bdebb3dbb84f04b054ff14","prob_desc_notes":"NoteA table for the second sample test is given below. The occurrences of number 12 are marked bold.   ","prob_desc_output_spec":"Print a single number: the number of times x occurs in the table.","prob_desc_output_to":"standard output","prob_desc_description":"Let's consider a table consisting of n rows and n columns. The cell located at the intersection of i-th row and j-th column contains number i\u2009\u00d7\u2009j. The rows and columns are numbered starting from 1.You are given a positive integer x. Your task is to count the number of cells in a table that contain number x.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '20 10', 'output': ['4']}, {'input': '100 25', 'output': ['6']}, {'input': '50 100', 'output': ['4']}, {'input': '30 1', 'output': ['30']}, {'input': '1000 1000000', 'output': ['64']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"5 2\", \"8 1\"]","prob_desc_input_spec":"The only line of the input contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091018)\u00a0\u2014 the capacity of the barn and the number of grains that are brought every day.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"(n, m) = map(int, input().split())\nif n <= m:\n\tprint(n)\nelse:\n\taM = m\n\tn -= m\n\t(l, r) = (0, int(2e9))\n\twhile l < r:\n\t\tm = (l + r) \/\/ 2;\n\t\tval = m * (m+1) \/\/ 2;\n\t\tif val >= n:\n\t\t\tr = m\n\t\telse:\n\t\t\tl = m+1\n\tprint(l + aM)","prob_desc_sample_outputs":"[\"4\", \"5\"]","lang_cluster":"Python","code_uid":"5cb6bf0ddff3f71d687ad26bb8116d6c","prob_desc_notes":"NoteIn the first sample the capacity of the barn is five grains and two grains are brought every day. The following happens:  At the beginning of the first day grain is brought to the barn. It's full, so nothing happens.  At the end of the first day one sparrow comes and eats one grain, so 5\u2009-\u20091\u2009=\u20094 grains remain.  At the beginning of the second day two grains are brought. The barn becomes full and one grain doesn't fit to it.  At the end of the second day two sparrows come. 5\u2009-\u20092\u2009=\u20093 grains remain.  At the beginning of the third day two grains are brought. The barn becomes full again.  At the end of the third day three sparrows come and eat grain. 5\u2009-\u20093\u2009=\u20092 grains remain.  At the beginning of the fourth day grain is brought again. 2\u2009+\u20092\u2009=\u20094 grains remain.  At the end of the fourth day four sparrows come and eat grain. 4\u2009-\u20094\u2009=\u20090 grains remain. The barn is empty. So the answer is 4, because by the end of the fourth day the barn becomes empty.","prob_desc_output_spec":"Output one integer\u00a0\u2014 the number of the day when the barn will become empty for the first time. Days are numbered starting with one.","prob_desc_output_to":"standard output","prob_desc_description":"Anton likes to listen to fairy tales, especially when Danik, Anton's best friend, tells them. Right now Danik tells Anton a fairy tale:\"Once upon a time, there lived an emperor. He was very rich and had much grain. One day he ordered to build a huge barn to put there all his grain. Best builders were building that barn for three days and three nights. But they overlooked and there remained a little hole in the barn, from which every day sparrows came through. Here flew a sparrow, took a grain and flew away...\"More formally, the following takes place in the fairy tale. At the beginning of the first day the barn with the capacity of n grains was full. Then, every day (starting with the first day) the following happens:  m grains are brought to the barn. If m grains doesn't fit to the barn, the barn becomes full and the grains that doesn't fit are brought back (in this problem we can assume that the grains that doesn't fit to the barn are not taken into account).  Sparrows come and eat grain. In the i-th day i sparrows come, that is on the first day one sparrow come, on the second day two sparrows come and so on. Every sparrow eats one grain. If the barn is empty, a sparrow eats nothing. Anton is tired of listening how Danik describes every sparrow that eats grain from the barn. Anton doesn't know when the fairy tale ends, so he asked you to determine, by the end of which day the barn will become empty for the first time. Help Anton and write a program that will determine the number of that day!","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3', 'output': ['5']}, {'input': '20 5', 'output': ['7']}, {'input': '30 7', 'output': ['9']}, {'input': '40 9', 'output': ['11']}, {'input': '50 11', 'output': ['13']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"6 9\", \"38 11\", \"5 2\", \"5 10\"]","prob_desc_input_spec":"The only line of the input contains two integers $$$n$$$ and $$$b$$$ ($$$1 \\le n \\le 10^{18}$$$, $$$2 \\le b \\le 10^{12}$$$).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"# Python3 code to find largest prime \n# factor of number \nfrom collections import Counter\nimport math \n  \n# A function to print all prime factors of  \n# a given number n \ndef primeFactors(n): \n      \n    # Print the number of two's that divide n\n    list=[]\n    while n % 2 == 0: \n        \n        list.append(2)\n        n = n \/ 2\n          \n    # n must be odd at this point \n    # so a skip of 2 ( i = i + 2) can be used \n    for i in range(3,int(math.sqrt(n))+1,2): \n          \n        # while i divides n , print i ad divide n \n        while n % i== 0: \n            \n            list.append(i)\n            n = n \/ i \n              \n    # Condition if n is a prime \n    # number greater than 2 \n    if n > 2: \n        \n        list.append(n)\n    return list\n\n  \n  \n#write your main here\n#find the count of maximum factor in the b\nn,b=map(int,input().split())\n\nm_fact=primeFactors(b)\n#counter = Counter(m_fact)\n#print(counter)\nll=[]\n#print(m_fact)\nfor fact in m_fact:\n    #print(fact)\n    div=0\n    bb=b\n    while (bb%fact)==0:\n        div+=1\n        bb=int(bb\/\/fact)\n    #print(div)\n    #print(div)\n\n    t_count=int(0)\n    num=n\n    #print(num)\n    while num>=fact:\n        t_count+=int(num\/\/fact)\n        num=(num\/\/fact)\n        #print(num)\n    #print(t_count)\n\n    ll.append(t_count\/\/div)\n    #print(ll)\nprint(min(ll))","prob_desc_sample_outputs":"[\"1\", \"3\", \"3\", \"1\"]","lang_cluster":"Python","code_uid":"843c56481ab76363747fb1c6f803cc68","prob_desc_notes":"NoteIn the first example, $$$6!_{(10)} = 720_{(10)} = 880_{(9)}$$$.In the third and fourth example, $$$5!_{(10)} = 120_{(10)} = 1111000_{(2)}$$$.The representation of the number $$$x$$$ in the $$$b$$$-ary base is $$$d_1, d_2, \\ldots, d_k$$$ if $$$x = d_1 b^{k - 1} + d_2 b^{k - 2} + \\ldots + d_k b^0$$$, where $$$d_i$$$ are integers and $$$0 \\le d_i \\le b - 1$$$. For example, the number $$$720$$$ from the first example is represented as $$$880_{(9)}$$$ since $$$720 = 8 \\cdot 9^2 + 8 \\cdot 9 + 0 \\cdot 1$$$.You can read more about bases here.","prob_desc_output_spec":"Print an only integer\u00a0\u2014 the number of trailing zero digits in the $$$b$$$-ary representation of $$$n!$$$","prob_desc_output_to":"standard output","prob_desc_description":" The number \"zero\" is called \"love\" (or \"l'oeuf\" to be precise, literally means \"egg\" in French), for example when denoting the zero score in a game of tennis. Aki is fond of numbers, especially those with trailing zeros. For example, the number $$$9200$$$ has two trailing zeros. Aki thinks the more trailing zero digits a number has, the prettier it is.However, Aki believes, that the number of trailing zeros of a number is not static, but depends on the base (radix) it is represented in. Thus, he considers a few scenarios with some numbers and bases. And now, since the numbers he used become quite bizarre, he asks you to help him to calculate the beauty of these numbers.Given two integers $$$n$$$ and $$$b$$$ (in decimal notation), your task is to calculate the number of trailing zero digits in the $$$b$$$-ary (in the base\/radix of $$$b$$$) representation of $$$n\\,!$$$ (factorial of $$$n$$$). ","length":66,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 5', 'output': ['2\\n']}, {'input': '20 10', 'output': ['4\\n']}, {'input': '30 15', 'output': ['6\\n']}, {'input': '40 20', 'output': ['8\\n']}, {'input': '50 25', 'output': ['10\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 6\\n10 12 10 7 5 22\"]","prob_desc_input_spec":"The first line contains space-separated integers n and m (2\u2009\u2264\u2009n\u2009\u2264\u2009m\u2009\u2264\u200950). The second line contains m space-separated integers f1,\u2009f2,\u2009...,\u2009fm (4\u2009\u2264\u2009fi\u2009\u2264\u20091000) \u2014 the quantities of pieces in the puzzles sold in the shop.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n,m = input().split()\nm=int(m)\nn=int(n)\narr = sorted(map(int,input().split()))\nmini=999999999\nfor j in range(m-n+1):\n if (arr[j+n-1]-arr[j]<mini):\n   mini=arr[j+n-1]-arr[j]\nprint (mini)","prob_desc_sample_outputs":"[\"5\"]","lang_cluster":"Python","code_uid":"889715f9788c64eeaa5df9c316caa65b","prob_desc_notes":"NoteSample 1. The class has 4 students. The shop sells 6 puzzles. If Ms. Manana buys the first four puzzles consisting of 10, 12, 10 and 7 pieces correspondingly, then the difference between the sizes of the largest and the smallest puzzle will be equal to 5. It is impossible to obtain a smaller difference. Note that the teacher can also buy puzzles 1, 3, 4 and 5 to obtain the difference 5.","prob_desc_output_spec":"Print a single integer \u2014 the least possible difference the teacher can obtain.","prob_desc_output_to":"standard output","prob_desc_description":"The end of the school year is near and Ms. Manana, the teacher, will soon have to say goodbye to a yet another class. She decided to prepare a goodbye present for her n students and give each of them a jigsaw puzzle (which, as wikipedia states, is a tiling puzzle that requires the assembly of numerous small, often oddly shaped, interlocking and tessellating pieces).The shop assistant told the teacher that there are m puzzles in the shop, but they might differ in difficulty and size. Specifically, the first jigsaw puzzle consists of f1 pieces, the second one consists of f2 pieces and so on.Ms. Manana doesn't want to upset the children, so she decided that the difference between the numbers of pieces in her presents must be as small as possible. Let A be the number of pieces in the largest puzzle that the teacher buys and B be the number of pieces in the smallest such puzzle. She wants to choose such n puzzles that A\u2009-\u2009B is minimum possible. Help the teacher and find the least possible value of A\u2009-\u2009B.","length":9,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2\\n4 5\\n', 'output': ['1\\n']}, {'input': '3 5\\n7 8 9 10 11\\n', 'output': ['1\\n']}, {'input': '4 6\\n10 12 10 7 5 22\\n', 'output': ['5\\n']}, {'input': '5 7\\n15 20 25 30 35 40 45\\n', 'output': ['5\\n']}, {'input': '2 3\\n100 200 300\\n', 'output': ['100\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1700.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"2 1 2 2\", \"4 7 7 4\"]","prob_desc_input_spec":"The first line contains four integers: xp,\u2009yp,\u2009xv,\u2009yv (0\u2009\u2264\u2009xp,\u2009yp,\u2009xv,\u2009yv\u2009\u2264\u2009105) \u2014 Polycarp's and Vasiliy's starting coordinates. It is guaranteed that in the beginning the pawns are in different cells and none of them is in the cell (0,\u20090).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"x1, y1, x2, y2 = map(int, input().split())\nif (x1 > x2 or y1 > y2) and x1 + y1 > max(x2, y2):\n\tprint(\"Vasiliy\")\nelse:\n\tprint(\"Polycarp\")\n","prob_desc_sample_outputs":"[\"Polycarp\", \"Vasiliy\"]","lang_cluster":"Python","code_uid":"d2ef760ef34e8097365e8dc2adae51b8","prob_desc_notes":"NoteIn the first sample test Polycarp starts in (2,\u20091) and will move to (1,\u20091) in the first turn. No matter what his opponent is doing, in the second turn Polycarp can move to (1,\u20090) and finally to (0,\u20090) in the third turn.","prob_desc_output_spec":"Output the name of the winner: \"Polycarp\" or \"Vasiliy\".","prob_desc_output_to":"standard output","prob_desc_description":"Polycarp and Vasiliy love simple logical games. Today they play a game with infinite chessboard and one pawn for each player. Polycarp and Vasiliy move in turns, Polycarp starts. In each turn Polycarp can move his pawn from cell (x,\u2009y) to (x\u2009-\u20091,\u2009y) or (x,\u2009y\u2009-\u20091). Vasiliy can move his pawn from (x,\u2009y) to one of cells: (x\u2009-\u20091,\u2009y),\u2009(x\u2009-\u20091,\u2009y\u2009-\u20091) and (x,\u2009y\u2009-\u20091). Both players are also allowed to skip move. There are some additional restrictions \u2014 a player is forbidden to move his pawn to a cell with negative x-coordinate or y-coordinate or to the cell containing opponent's pawn The winner is the first person to reach cell (0,\u20090). You are given the starting coordinates of both pawns. Determine who will win if both of them play optimally well.","length":5,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '3 2 4 3', 'output': ['Polycarp']}, {'input': '5 5 6 6', 'output': ['Polycarp']}, {'input': '7 8 6 7', 'output': ['Vasiliy']}, {'input': '10 10 9 9', 'output': ['Vasiliy']}, {'input': '1 1 2 2', 'output': ['Polycarp']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\nZCTH\", \"5\\nZDATG\", \"6\\nAFBAKC\"]","prob_desc_input_spec":"The first line contains a single integer $$$n$$$ ($$$4 \\leq n \\leq 50$$$)\u00a0\u2014 the length of the string $$$s$$$. The second line contains the string $$$s$$$, consisting of exactly $$$n$$$ uppercase letters of the Latin alphabet.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"def solve(a, b):\n    return min((26 + a - b) % 26, (26 + b - a) % 26)\n\n\ndef main():\n    n = int(input())\n    s = input().lower()\n    print(min((sum((solve(ord(a), ord(b)) for a, b in zip(s[i:i + 4], 'actg'))) for i in range(n - 3))))\n\n\nmain()\n","prob_desc_sample_outputs":"[\"2\", \"5\", \"16\"]","lang_cluster":"Python","code_uid":"cd1d0c47a7fea7dc94f1b0756f4a22d0","prob_desc_notes":"NoteIn the first example, you should replace the letter \"Z\" with \"A\" for one operation, the letter \"H\"\u00a0\u2014 with the letter \"G\" for one operation. You will get the string \"ACTG\", in which the genome is present as a substring.In the second example, we replace the letter \"A\" with \"C\" for two operations, the letter \"D\"\u00a0\u2014 with the letter \"A\" for three operations. You will get the string \"ZACTG\", in which there is a genome.","prob_desc_output_spec":"Output the minimum number of operations that need to be applied to the string $$$s$$$ so that the genome appears as a substring in it.","prob_desc_output_to":"standard output","prob_desc_description":"Today in the scientific lyceum of the Kingdom of Kremland, there was a biology lesson. The topic of the lesson was the genomes. Let's call the genome the string \"ACTG\".Maxim was very boring to sit in class, so the teacher came up with a task for him: on a given string $$$s$$$ consisting of uppercase letters and length of at least $$$4$$$, you need to find the minimum number of operations that you need to apply, so that the genome appears in it as a substring. For one operation, you can replace any letter in the string $$$s$$$ with the next or previous in the alphabet. For example, for the letter \"D\" the previous one will be \"C\", and the next\u00a0\u2014 \"E\". In this problem, we assume that for the letter \"A\", the previous one will be the letter \"Z\", and the next one will be \"B\", and for the letter \"Z\", the previous one is the letter \"Y\", and the next one is the letter \"A\".Help Maxim solve the problem that the teacher gave him.A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '4\\nABCD', 'output': ['13\\n']}, {'input': '5\\nZZZZZ', 'output': ['25\\n']}, {'input': '6\\nQWERTY', 'output': ['30\\n']}, {'input': '7\\nASDFGHJ', 'output': ['31\\n']}, {'input': '8\\nZXCVBNML', 'output': ['49\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"1 10 9 20 1\", \"1 100 50 200 75\"]","prob_desc_input_spec":"The only line of the input contains integers l1, r1, l2, r2 and k (1\u2009\u2264\u2009l1,\u2009r1,\u2009l2,\u2009r2,\u2009k\u2009\u2264\u20091018, l1\u2009\u2264\u2009r1, l2\u2009\u2264\u2009r2), providing the segments of time for Sonya and Filya and the moment of time when Sonya prinks.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"data = [int(info) for info in input().split(' ')]\n\nif data[0] == data[2] and data[1] == data[3]:\n\ttime = data[1] - data[0] + 1\n\tif data[4] >= data[0] and data[4] <= data[1]:\n\t\ttime -= 1\n\nelif (((data[2] < data[0]) and (data[2] < data[1])) and ((data[3] < data[0]) and (data[3] < data[1]))) or (((data[1] < data[2]) and (data[0] < data[2])) and ((data[0] < data[3]) and (data[0] < data[3]))):\n\t#import code\n\t#code.interact(local=locals())\n\t#print('bine pa')\n\ttime = 0\nelse:\n\tif data[0] < data[2]:\n\t\tif data[1] < data[3]:\n\t\t\ttime = data[1] - data[2] + 1\n\t\t\tif data[4] <= data[1] and data[4] >= data[2]:\n\t\t\t\ttime -= 1\n\t\telse:\n\t\t\ttime = data[3] - data[2] + 1\n\t\t\tif data[4] <= data[3] and data[4] >= data[2]:\n\t\t\t\ttime -= 1\n\n\telse:\n\t\tif data[1] > data[3]:\n\t\t\ttime = data[3] - data[0] + 1\n\t\t\t#import code\n\t\t\t#code.interact(local=locals())\n\t\t\tif data[4] <= data[3] and data[4] >= data[0]:\n\t\t\t\ttime -= 1\n\t\telse:\n\t\t\ttime = data[1] - data[0] + 1\n\t\t\tif data[4] >= data[0] and data[4] <= data[1]:\n\t\t\t\ttime -= 1\nprint(time)\t\n","prob_desc_sample_outputs":"[\"2\", \"50\"]","lang_cluster":"Python","code_uid":"e75dc50c8f545d9038967f6c8af8e8ec","prob_desc_notes":"NoteIn the first sample, they will be together during minutes 9 and 10.In the second sample, they will be together from minute 50 to minute 74 and from minute 76 to minute 100.","prob_desc_output_spec":"Print one integer\u00a0\u2014 the number of minutes Sonya and Filya will be able to spend together.","prob_desc_output_to":"standard output","prob_desc_description":"Today an outstanding event is going to happen in the forest\u00a0\u2014 hedgehog Filya will come to his old fried Sonya!Sonya is an owl and she sleeps during the day and stay awake from minute l1 to minute r1 inclusive. Also, during the minute k she prinks and is unavailable for Filya.Filya works a lot and he plans to visit Sonya from minute l2 to minute r2 inclusive.Calculate the number of minutes they will be able to spend together.","length":35,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1 10 5 15 7', 'output': ['5']}, {'input': '1 5 6 10 8', 'output': ['0']}, {'input': '1 10 1 10 5', 'output': ['9']}, {'input': '1 10 2 9 10', 'output': ['8']}, {'input': '1 10 10 20 10', 'output': ['0']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1600.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1 1 1 1\\n+ + *\", \"2 2 2 2\\n* * +\", \"1 2 3 4\\n* + +\"]","prob_desc_input_spec":"First line contains four integers separated by space: 0\u2009\u2264\u2009a,\u2009b,\u2009c,\u2009d\u2009\u2264\u20091000 \u2014 the original numbers. Second line contains three signs ('+' or '*' each) separated by space \u2014 the sequence of the operations in the order of performing. ('+' stands for addition, '*' \u2014 multiplication)","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"I=input\na=I().split()\ndef f(s,z):\n\tif not z:return int(s[0])\n\tm=10**99\n\tfor i in s:\n\t\tt=s[::];t.remove(i)\n\t\tfor j in t:k=t[::];k.remove(j);m=min(m,f(k+[str(eval(i+z[0]+j))],z[1:]))\n\treturn m\nprint(f(a,I().split()))","prob_desc_sample_outputs":"[\"3\", \"8\", \"9\"]","lang_cluster":"Python","code_uid":"dd66e205e4ba8e2c7ada0b83a33f32c7","prob_desc_notes":null,"prob_desc_output_spec":"Output one integer number \u2014 the minimal result which can be obtained. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).","prob_desc_output_to":"standard output","prob_desc_description":"Recently, Vladimir got bad mark in algebra again. To avoid such unpleasant events in future he decided to train his arithmetic skills. He wrote four integer numbers a, b, c, d on the blackboard. During each of the next three minutes he took two numbers from the blackboard (not necessarily adjacent) and replaced them with their sum or their product. In the end he got one number. Unfortunately, due to the awful memory he forgot that number, but he remembers four original numbers, sequence of the operations and his surprise because of the very small result. Help Vladimir remember the forgotten number: find the smallest number that can be obtained from the original numbers by the given sequence of operations.","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '0 0 0 0\\n+ + +', 'output': ['0\\n']}, {'input': '1 1 1 1\\n* * *', 'output': ['1\\n']}, {'input': '2 3 4 5\\n+ + +', 'output': ['14\\n']}, {'input': '10 20 30 40\\n* * *', 'output': ['240000\\n']}, {'input': '100 200 300 400\\n+ * +', 'output': ['60100\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4\\n3 2 1 2\", \"3\\n2 3 8\"]","prob_desc_input_spec":"The first line of input contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009100), the number of the columns in the box. The next line contains n space-separated integer numbers. The i-th number ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009100) denotes the number of cubes in the i-th column.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"number_of_columns = int(input())\nbox_p_column = [int(i) for i in input().split(' ')]\n\nbox_p_column = [str(i) for i in sorted(box_p_column)]\nprint(' '.join(box_p_column).strip())\n\n","prob_desc_sample_outputs":"[\"1 2 2 3\", \"2 3 8\"]","lang_cluster":"Python","code_uid":"d6f0a47d0c65c3153e295eb91252bcdd","prob_desc_notes":"NoteThe first example case is shown on the figure. The top cube of the first column falls to the top of the last column; the top cube of the second column falls to the top of the third column; the middle cube of the first column falls to the top of the second column.In the second example case the gravity switch does not change the heights of the columns.","prob_desc_output_spec":"Output n integer numbers separated by spaces, where the i-th number is the amount of cubes in the i-th column after the gravity switch.","prob_desc_output_to":"standard output","prob_desc_description":"Little Chris is bored during his physics lessons (too easy), so he has built a toy box to keep himself occupied. The box is special, since it has the ability to change gravity.There are n columns of toy cubes in the box arranged in a line. The i-th column contains ai cubes. At first, the gravity in the box is pulling the cubes downwards. When Chris switches the gravity, it begins to pull all the cubes to the right side of the box. The figure shows the initial and final configurations of the cubes in the box: the cubes that have changed their position are highlighted with orange.  Given the initial configuration of the toy cubes in the box, find the amounts of cubes in each of the n columns after the gravity switch!","length":6,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5\\n5 4 3 2 1', 'output': ['1 2 3 4 5 ']}, {'input': '1\\n100', 'output': ['100 ']}, {'input': '3\\n3 3 3', 'output': ['3 3 3 ']}, {'input': '6\\n1 2 3 4 5 6', 'output': ['1 2 3 4 5 6 ']}, {'input': '4\\n4 3 2 1', 'output': ['1 2 3 4 ']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"4 1 2\", \"8 2 6\", \"8 7 5\"]","prob_desc_input_spec":"The only line contains three integers n, a and b (2\u2009\u2264\u2009n\u2009\u2264\u2009256, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n)\u00a0\u2014 the total number of teams, and the ids of the teams that Arkady is interested in.  It is guaranteed that n is such that in each round an even number of team advance, and that a and b are not equal.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"total_teams,team1,team2 = map(int,input().split())\n\ncount = 1\nwhile True:\n\tif round((team1\/2)+0.1)==round((team2\/2)+0.1):\n\t\tbreak\n\t\n\tteam1=round((team1\/2)+0.1)\n\tteam2=round((team2\/2)+0.1)\n\ttotal_teams\/\/=2\n\tcount+=1\n\t\nif total_teams==2:\n  print('Final!')\nelse:\n\n  print(count)\n","prob_desc_sample_outputs":"[\"1\", \"Final!\", \"2\"]","lang_cluster":"Python","code_uid":"7070a2585b613516b14a7f9bdba8385b","prob_desc_notes":"NoteIn the first example teams 1 and 2 meet in the first round.In the second example teams 2 and 6 can only meet in the third round, which is the Final, if they win all their opponents in earlier rounds.In the third example the teams with ids 7 and 5 can meet in the second round, if they win their opponents in the first round.","prob_desc_output_spec":"In the only line print \"Final!\" (without quotes), if teams a and b can meet in the Final. Otherwise, print a single integer\u00a0\u2014 the number of the round in which teams a and b can meet. The round are enumerated from 1.","prob_desc_output_to":"standard output","prob_desc_description":"The last stage of Football World Cup is played using the play-off system.There are n teams left in this stage, they are enumerated from 1 to n. Several rounds are held, in each round the remaining teams are sorted in the order of their ids, then the first in this order plays with the second, the third\u00a0\u2014 with the fourth, the fifth\u00a0\u2014 with the sixth, and so on. It is guaranteed that in each round there is even number of teams. The winner of each game advances to the next round, the loser is eliminated from the tournament, there are no draws. In the last round there is the only game with two remaining teams: the round is called the Final, the winner is called the champion, and the tournament is over.Arkady wants his two favorite teams to play in the Final. Unfortunately, the team ids are already determined, and it may happen that it is impossible for teams to meet in the Final, because they are to meet in some earlier stage, if they are strong enough. Determine, in which round the teams with ids a and b can meet.","length":17,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '16 1 2', 'output': ['1']}, {'input': '16 1 16', 'output': ['Final!']}, {'input': '16 8 9', 'output': ['2']}, {'input': '16 4 5', 'output': ['3']}, {'input': '16 3 4', 'output': ['1']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1100.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"####\\n.#..\\n####\\n....\", \"####\\n....\\n####\\n....\"]","prob_desc_input_spec":"Four lines contain four characters each: the j-th character of the i-th line equals \".\" if the cell in the i-th row and the j-th column of the square is painted white, and \"#\", if the cell is black.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"#!\/usr\/bin\/env python\n# coding: utf-8\n\n# In[14]:\n\n\n# # n = int(input())\n# # line = list(map(int, input().split()))\n# # line = list(str(input()))\n# from tqdm import trange\n\n\n# In[24]:\n\n\nfrom collections import Counter\n\n\n# In[13]:\n\n\nmatrix = []\n\nfor _ in range(4):\n    matrix.append(list(str(input())))\n\n\n# In[29]:\n\n\nans = \"NO\"\n\nfor i in range(3):\n    for j in range(3):\n        tmp_list = [matrix[i][j], matrix[i][j+1], matrix[i+1][j], matrix[i+1][j+1]]\n        tmp_dict = Counter(tmp_list)\n        if max(tmp_dict.values()) >= 3:\n            ans = \"YES\"\n            break\n\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n","prob_desc_sample_outputs":"[\"YES\", \"NO\"]","lang_cluster":"Python","code_uid":"08666196b2637004356f559eef4c2fdb","prob_desc_notes":"NoteIn the first test sample it is enough to repaint the first cell in the second row. After such repainting the required 2\u2009\u00d7\u20092 square is on the intersection of the 1-st and 2-nd row with the 1-st and 2-nd column.","prob_desc_output_spec":"Print \"YES\" (without the quotes), if the test can be passed and \"NO\" (without the quotes) otherwise.","prob_desc_output_to":"standard output","prob_desc_description":"In the city of Ultima Thule job applicants are often offered an IQ test. The test is as follows: the person gets a piece of squared paper with a 4\u2009\u00d7\u20094 square painted on it. Some of the square's cells are painted black and others are painted white. Your task is to repaint at most one cell the other color so that the picture has a 2\u2009\u00d7\u20092 square, completely consisting of cells of the same color. If the initial picture already has such a square, the person should just say so and the test will be completed. Your task is to write a program that determines whether it is possible to pass the test. You cannot pass the test if either repainting any cell or no action doesn't result in a 2\u2009\u00d7\u20092 square, consisting of cells of the same color.","length":54,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '####\\n....\\n####\\n....\\n', 'output': ['NO\\n']}, {'input': '####\\n.#..\\n####\\n....\\n', 'output': ['YES\\n']}, {'input': '....\\n....\\n....\\n....\\n', 'output': ['YES\\n']}, {'input': '#...\\n#...\\n#...\\n#...\\n', 'output': ['NO\\n']}, {'input': '#.#.\\n.#.#\\n#.#.\\n.#.#\\n', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"390\", \"7\", \"1000000000\"]","prob_desc_input_spec":"The only input line contains the integer $$$n$$$ ($$$1 \\le n \\le 2\\cdot10^9$$$).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"import math\ni=int(input())\nmax=0\nk=len(str(i))-1\nif i<10:\n    print(i)\nelse:\n    list=[]\n    p=str(i)\n    for m in p:\n        list.append(int(m))\n    p=list\n    m=1\n    for j in p:\n        m*=j\n    if m>max:\n        max=m\n    m=1\n    for l in range(k,0,-1):\n        q=i\n        minus=i%10**l+1\n        q-=minus\n        list=[]\n        p=str(q)\n        for m in p:\n            list.append(int(m))\n        p=list\n        m=1\n        for j in p:\n            m*=j\n        if m>max:\n            max=m\n    print(max)\n    ","prob_desc_sample_outputs":"[\"216\", \"7\", \"387420489\"]","lang_cluster":"Python","code_uid":"946191473fe8debb20ab3f4dbbde1696","prob_desc_notes":"NoteIn the first example the maximum product is achieved for $$$389$$$ (the product of digits is $$$3\\cdot8\\cdot9=216$$$).In the second example the maximum product is achieved for $$$7$$$ (the product of digits is $$$7$$$).In the third example the maximum product is achieved for $$$999999999$$$ (the product of digits is $$$9^9=387420489$$$).","prob_desc_output_spec":"Print the maximum product of digits among all integers from $$$1$$$ to $$$n$$$.","prob_desc_output_to":"standard output","prob_desc_description":"Kurt reaches nirvana when he finds the product of all the digits of some positive integer. Greater value of the product makes the nirvana deeper.Help Kurt find the maximum possible product of digits among all integers from $$$1$$$ to $$$n$$$.","length":34,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10', 'output': ['9']}, {'input': '100', 'output': ['81']}, {'input': '500', 'output': ['324']}, {'input': '1000', 'output': ['729']}, {'input': '2000', 'output': ['1458']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"500 1000 20 30\", \"1000 1000 1 1\", \"1500 1000 176 177\"]","prob_desc_input_spec":"The first line contains four integers a, b, c, d (250\u2009\u2264\u2009a,\u2009b\u2009\u2264\u20093500, 0\u2009\u2264\u2009c,\u2009d\u2009\u2264\u2009180).  It is guaranteed that numbers a and b are divisible by 250 (just like on any real Codeforces round).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"\na,b,c,d = map(int, input().split())\ns1 = max(0.3 * a, int(a * (1 - c \/ 250)))\ns2 = max(0.3 * b, int(b * (1 - d \/ 250)))\nif s1 > s2:\n\tprint('Misha')\nelif s1 == s2:\n\tprint('Tie')\nelse:\n\tprint('Vasya')","prob_desc_sample_outputs":"[\"Vasya\", \"Tie\", \"Misha\"]","lang_cluster":"Python","code_uid":"0c1f0907f688cfeaf6f5f0c1fdb45149","prob_desc_notes":null,"prob_desc_output_spec":"Output on a single line:  \"Misha\" (without the quotes), if Misha got more points than Vasya. \"Vasya\" (without the quotes), if Vasya got more points than Misha. \"Tie\" (without the quotes), if both of them got the same number of points.","prob_desc_output_to":"standard output","prob_desc_description":"Misha and Vasya participated in a Codeforces contest. Unfortunately, each of them solved only one problem, though successfully submitted it at the first attempt. Misha solved the problem that costs a points and Vasya solved the problem that costs b points. Besides, Misha submitted the problem c minutes after the contest started and Vasya submitted the problem d minutes after the contest started. As you know, on Codeforces the cost of a problem reduces as a round continues. That is, if you submit a problem that costs p points t minutes after the contest started, you get  points. Misha and Vasya are having an argument trying to find out who got more points. Help them to find out the truth.","length":10,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '500 1000 20 30', 'output': ['Vasya\\n']}, {'input': '1000 1000 1 1', 'output': ['Tie\\n']}, {'input': '1500 1000 176 177', 'output': ['Misha\\n']}, {'input': '2500 3000 50 60', 'output': ['Misha\\n']}, {'input': '3500 3500 180 180', 'output': ['Tie\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"19\", \"16\"]","prob_desc_input_spec":"The first and only line contains an integer $$$r$$$ ($$$1 \\le r \\le 10^{12}$$$).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"r = int(input())\ny = int((r-3)\/2)\nif(r&1 and y > 0):\n\tprint(\"{} {}\".format(1,y))\n\t\nelse :\n\tprint(\"NO\")","prob_desc_sample_outputs":"[\"1 8\", \"NO\"]","lang_cluster":"Python","code_uid":"90ad214db1b22713120fb1054cca9ac6","prob_desc_notes":null,"prob_desc_output_spec":"Output integers $$$x, y$$$ such that $$$H(x,y) = r$$$ and $$$x$$$ is smallest possible, or \"NO\" if no such pair exists.","prob_desc_output_to":"standard output","prob_desc_description":"Melody Pond was stolen from her parents as a newborn baby by Madame Kovarian, to become a weapon of the Silence in their crusade against the Doctor. Madame Kovarian changed Melody's name to River Song, giving her a new identity that allowed her to kill the Eleventh Doctor.Heidi figured out that Madame Kovarian uses a very complicated hashing function in order to change the names of the babies she steals. In order to prevent this from happening to future Doctors, Heidi decided to prepare herself by learning some basic hashing techniques.The first hashing function she designed is as follows.Given two positive integers $$$(x, y)$$$ she defines $$$H(x,y):=x^2+2xy+x+1$$$.Now, Heidi wonders if the function is reversible. That is, given a positive integer $$$r$$$, can you find a pair $$$(x, y)$$$ (of positive integers) such that $$$H(x, y) = r$$$?If multiple such pairs exist, output the one with smallest possible $$$x$$$. If there is no such pair, output \"NO\".","length":7,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '21\\n', 'output': ['1 9\\n']}, {'input': '15\\n', 'output': ['NO\\n']}, {'input': '1000000000001\\n', 'output': ['1 500000000000\\n']}, {'input': '7\\n', 'output': ['1 2\\n']}, {'input': '1000000000000\\n', 'output': ['NO\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1000.0,"prob_desc_time_limit":"0.5 second","prob_desc_sample_inputs":"[\"3 1 1\", \"5 2 3\"]","prob_desc_input_spec":"The only line contains three integers n, a and b (0\u2009\u2264\u2009a,\u2009b\u2009&lt;\u2009n\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n,a,b = map(int, input().split(' '))\nprint(n-max(a+1,n-b)+1)","prob_desc_sample_outputs":"[\"2\", \"3\"]","lang_cluster":"Python","code_uid":"915fd3552f5c052dfbf1de5e980152a7","prob_desc_notes":"NoteThe possible positions in the first sample are: 2 and 3 (if we number the positions starting with 1).In the second sample they are 3, 4 and 5.","prob_desc_output_spec":"Print the single number \u2014 the number of the sought positions.","prob_desc_output_to":"standard output","prob_desc_description":"Petr stands in line of n people, but he doesn't know exactly which position he occupies. He can say that there are no less than a people standing in front of him and no more than b people standing behind him. Find the number of different positions Petr can occupy.","length":2,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '10 3 5', 'output': ['6']}, {'input': '20 5 10', 'output': ['11']}, {'input': '30 10 15', 'output': ['16']}, {'input': '40 15 20', 'output': ['21']}, {'input': '50 20 25', 'output': ['26']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1400.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"6 4\\n5237\\n2753\\n7523\\n5723\\n5327\\n2537\", \"3 3\\n010\\n909\\n012\", \"7 5\\n50808\\n36603\\n37198\\n44911\\n29994\\n42543\\n50156\"]","prob_desc_input_spec":"The first line contains integers n and k \u2014 the number and digit capacity of numbers correspondingly (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u20098). Next n lines contain k-digit positive integers. Leading zeroes are allowed both in the initial integers and the integers resulting from the rearranging of digits.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"\nimport itertools, sys\n\nn, k = [int(x) for x in input().split()]\n\nperms = zip(*[[int(''.join(p)) for p in itertools.permutations(input())] for y in range(n)])\n\nperms = list(perms)\n\n# print(perms)\n\nminimum = float(\"inf\")\n\nfor p in perms:\n\n\ttemp = max(p) - min(p)\n\n\tif temp < minimum:\n\t\tminimum = temp\n\nprint(minimum)\n\n\n\n# Made By Mostafa_Khaled","prob_desc_sample_outputs":"[\"2700\", \"3\", \"20522\"]","lang_cluster":"Python","code_uid":"6641d80a5bda4ca0c4e46aa2da489db9","prob_desc_notes":"NoteIn the first sample, if we rearrange the digits in numbers as (3,1,4,2), then the 2-nd and the 4-th numbers will equal 5237 and 2537 correspondingly (they will be maximum and minimum for such order of digits).In the second sample, if we swap the second digits and the first ones, we get integers 100, 99 and 102.","prob_desc_output_spec":"Print a single number: the minimally possible difference between the largest and the smallest number after the digits are rearranged in all integers by the same rule.","prob_desc_output_to":"standard output","prob_desc_description":"You are given n k-digit integers. You have to rearrange the digits in the integers so that the difference between the largest and the smallest number was minimum. Digits should be rearranged by the same rule in all integers.","length":25,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '2 2\\n12\\n21', 'output': ['9\\n']}, {'input': '3 3\\n123\\n321\\n231', 'output': ['198\\n']}, {'input': '4 4\\n1234\\n4321\\n3412\\n2143', 'output': ['3087\\n']}, {'input': '5 5\\n12345\\n54321\\n23451\\n34512\\n45123', 'output': ['41976\\n']}, {'input': '1 1\\n1', 'output': ['0\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 6\\n2 3 5\", \"6 7\\n1 2 3 4 5 6\"]","prob_desc_input_spec":"The first line of input contains two integer numbers n and k (1\u2009\u2264\u2009n,\u2009k\u2009\u2264\u2009100) \u2014 the number of buckets and the length of the garden, respectively. The second line of input contains n integer numbers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009100) \u2014 the length of the segment that can be watered by the i-th bucket in one hour. It is guaranteed that there is at least one bucket such that it is possible to water the garden in integer number of hours using only this bucket.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"import sys\n\nn, k = sys.stdin.readline().strip().split(' ')\na = sys.stdin.readline().strip().split(' ')\na = list(map(int,a))\ns=0\nm=0\nn = int(n)\nk = int(k)\nfor i in range(n,0,-1):\n\tr = k%a[i-1]\n\tif r==0 and a[i-1]>m:\n\t\tm=a[i-1]\ns=k\/m\nprint(int(s))","prob_desc_sample_outputs":"[\"2\", \"7\"]","lang_cluster":"Python","code_uid":"431125b3842ce267420e6a80d5fe0f58","prob_desc_notes":"NoteIn the first test the best option is to choose the bucket that allows to water the segment of length 3. We can't choose the bucket that allows to water the segment of length 5 because then we can't water the whole garden.In the second test we can choose only the bucket that allows us to water the segment of length 1.","prob_desc_output_spec":"Print one integer number \u2014 the minimum number of hours required to water the garden.","prob_desc_output_to":"standard output","prob_desc_description":"Luba thinks about watering her garden. The garden can be represented as a segment of length k. Luba has got n buckets, the i-th bucket allows her to water some continuous subsegment of garden of length exactly ai each hour. Luba can't water any parts of the garden that were already watered, also she can't water the ground outside the garden.Luba has to choose one of the buckets in order to water the garden as fast as possible (as mentioned above, each hour she will water some continuous subsegment of length ai if she chooses the i-th bucket). Help her to determine the minimum number of hours she has to spend watering the garden. It is guaranteed that Luba can always choose a bucket so it is possible water the garden.See the examples for better understanding.","length":15,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 10\\n2 3 4 5 6', 'output': ['2']}, {'input': '4 12\\n3 4 5 6', 'output': ['3']}, {'input': '3 15\\n5 6 7', 'output': ['3']}, {'input': '2 8\\n2 4', 'output': ['2']}, {'input': '1 100\\n10', 'output': ['10']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":1200.0,"prob_desc_time_limit":"2 seconds","prob_desc_sample_inputs":"[\"1f\", \"2d\", \"4a\", \"5e\"]","prob_desc_input_spec":"The only line of input contains a description of Vasya's seat in the format ns, where n (1\u2009\u2264\u2009n\u2009\u2264\u20091018) is the index of the row and s is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"import math\nrows = [0, 1, 0, 1]\nseats = [\"f\", \"e\", \"d\", \"a\", \"b\", \"c\"]\ns = input()\na, b = int(s[:-1]), s[-1]\nprint((a - 1) \/\/ 4 * 16 + rows[a % 4 - 1] * 7 + seats.index(b) + 1)","prob_desc_sample_outputs":"[\"1\", \"10\", \"11\", \"18\"]","lang_cluster":"Python","code_uid":"b332753ba91c1b18078f3d0963564d1d","prob_desc_notes":"NoteIn the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.In the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6\u2009+\u20091\u2009+\u20093\u2009=\u200910.","prob_desc_output_spec":"Print one integer\u00a0\u2014 the number of seconds Vasya has to wait until he gets his lunch.","prob_desc_output_to":"standard output","prob_desc_description":"A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle.   \u00a0It's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.Flight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one\u00a0\u2014 in seat 'c'. Assume that all seats are occupied.Vasya has seat s in row n and wants to know how many seconds will pass before he gets his lunch.","length":6,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '1f', 'output': ['1']}, {'input': '2d', 'output': ['10']}, {'input': '4a', 'output': ['11']}, {'input': '5e', 'output': ['18']}, {'input': '3c', 'output': ['15']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"10 3\", \"7 7\"]","prob_desc_input_spec":"The only line of input contains integers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u20091012). Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"n,k=map(int,input().split())\nif n%2==0 :\n    if (k > n\/\/2) :\n        print((k-n\/\/2)*2)\n    else :\n        print(2*k - 1)\nelse :\n    if (k > ((n-1)\/\/2)+ 1) :\n        print((k-1-((n-1)\/\/2))*2)\n    else :\n        print(2*k - 1)","prob_desc_sample_outputs":"[\"5\", \"6\"]","lang_cluster":"Python","code_uid":"e30a8a57dd6baed05c58727c914bbf11","prob_desc_notes":"NoteIn the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.","prob_desc_output_spec":"Print the number that will stand at the position number k after Volodya's manipulations.","prob_desc_output_to":"standard output","prob_desc_description":"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first n. He writes down the following sequence of numbers: firstly all odd integers from 1 to n (in ascending order), then all even integers from 1 to n (also in ascending order). Help our hero to find out which number will stand at the position number k.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '20 10', 'output': ['18\\n']}, {'input': '15 8', 'output': ['2\\n']}, {'input': '100 50', 'output': ['98\\n']}, {'input': '25 13', 'output': ['2\\n']}, {'input': '30 15', 'output': ['28\\n']}]"}
{"prob_desc_memory_limit":"256 megabytes","difficulty":900.0,"prob_desc_time_limit":"1 second","prob_desc_sample_inputs":"[\"3 30\\n2 2 1\", \"3 20\\n2 1 1\"]","prob_desc_input_spec":"The first line contains two space separated integers n, d (1\u2009\u2264\u2009n\u2009\u2264\u2009100;\u00a01\u2009\u2264\u2009d\u2009\u2264\u200910000). The second line contains n space-separated integers: t1,\u2009t2,\u2009...,\u2009tn (1\u2009\u2264\u2009ti\u2009\u2264\u2009100).","prob_desc_input_from":"standard input","lang":"Python 3","source_code":"__author__ = 'myduomilia'\n\nn, t = list(map(int, input().split()))\narr = list(map(int, input().split()))\ns = sum(arr)\nans = 0\n\nif s + (len(arr) - 1) * 10 > t:\n    print(-1)\nelse:\n    print((t - s) \/\/ 5)","prob_desc_sample_outputs":"[\"5\", \"-1\"]","lang_cluster":"Python","code_uid":"7839b462979f317f3f02850efbf73dbb","prob_desc_notes":"NoteConsider the first example. The duration of the event is 30 minutes. There could be maximum 5 jokes in the following way:  First Churu cracks a joke in 5 minutes.  Then Devu performs the first song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now Devu performs second song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now finally Devu will perform his last song in 1 minutes.  Total time spent is 5\u2009+\u20092\u2009+\u200910\u2009+\u20092\u2009+\u200910\u2009+\u20091\u2009=\u200930 minutes.Consider the second example. There is no way of organizing Devu's all songs. Hence the answer is -1. ","prob_desc_output_spec":"If there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.","prob_desc_output_to":"standard output","prob_desc_description":"Devu is a renowned classical singer. He is invited to many big functions\/festivals. Recently he was invited to \"All World Classical Singing Festival\". Other than Devu, comedian Churu was also invited.Devu has provided organizers a list of the songs and required time for singing them. He will sing n songs, ith song will take ti minutes exactly. The Comedian, Churu will crack jokes. All his jokes are of 5 minutes exactly.People have mainly come to listen Devu. But you know that he needs rest of 10 minutes after each song. On the other hand, Churu being a very active person, doesn't need any rest.You as one of the organizers should make an optimal s\u0441hedule for the event. For some reasons you must follow the conditions:  The duration of the event must be no more than d minutes;  Devu must complete all his songs;  With satisfying the two previous conditions the number of jokes cracked by Churu should be as many as possible. If it is not possible to find a way to conduct all the songs of the Devu, output -1. Otherwise find out maximum number of jokes that Churu can crack in the grand event.","length":11,"num_hidden_unit_tests":5,"hidden_unit_tests":"[{'input': '5 50\\n2 2 2 2 2', 'output': ['6']}, {'input': '4 40\\n5 5 5 5', 'output': ['4']}, {'input': '2 15\\n5 5', 'output': ['1']}, {'input': '3 30\\n10 10 10', 'output': ['-1']}, {'input': '1 10\\n5', 'output': ['1']}]"}
